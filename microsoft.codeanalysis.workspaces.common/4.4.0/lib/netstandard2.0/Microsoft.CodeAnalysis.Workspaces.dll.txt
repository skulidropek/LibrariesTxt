internal abstract class Microsoft.CodeAnalysis.AbstractLinkedFileMergeConflictCommentAdditionService : object {
    internal abstract virtual string GetConflictCommentText(string header, string beforeString, string afterString);
    public sealed virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
    private static IEnumerable`1<IEnumerable`1<TextChange>> PartitionChangesForDocument(IEnumerable`1<TextChange> changes, SourceText originalSourceText);
    private List`1<TextChange> GetCommentChangesForDocument(IEnumerable`1<IEnumerable`1<TextChange>> partitionedChanges, string projectName, SourceText oldDocumentText);
    private static string TrimBlankLines(SourceText text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AddImport.AbstractAddImportsService`4 : object {
    protected abstract virtual SyntaxNode GetAlias(TUsingOrAliasSyntax usingOrAlias);
    protected abstract virtual ImmutableArray`1<SyntaxNode> GetGlobalImports(Compilation compilation, SyntaxGenerator generator);
    protected abstract virtual SyntaxList`1<TUsingOrAliasSyntax> GetUsingsAndAliases(SyntaxNode node);
    protected abstract virtual SyntaxList`1<TExternSyntax> GetExterns(SyntaxNode node);
    protected abstract virtual bool IsStaticUsing(TUsingOrAliasSyntax usingOrAlias);
    public sealed virtual AddImportPlacementOptions GetAddImportOptions(AnalyzerConfigOptions configOptions, bool allowInHiddenRegions, AddImportPlacementOptions fallbackOptions);
    public abstract virtual CodeStyleOption2`1<AddImportPlacement> GetUsingDirectivePlacementCodeStyleOption(AnalyzerConfigOptions configOptions, CodeStyleOption2`1<AddImportPlacement> fallbackValue);
    private bool IsSimpleUsing(TUsingOrAliasSyntax usingOrAlias);
    private bool IsAlias(TUsingOrAliasSyntax usingOrAlias);
    private bool HasAliases(SyntaxNode node);
    private bool HasUsings(SyntaxNode node);
    private bool HasStaticUsings(SyntaxNode node);
    private bool HasExterns(SyntaxNode node);
    private bool HasAnyImports(SyntaxNode node);
    public sealed virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, SyntaxGenerator generator);
    private static ImmutableArray`1<SyntaxNode> GetAllContainers(SyntaxNode root, SyntaxNode contextLocation);
    private bool HasExistingImport(SyntaxNode import, ImmutableArray`1<SyntaxNode> containers, ImmutableArray`1<SyntaxNode> globalImports);
    protected abstract virtual bool IsEquivalentImport(SyntaxNode a, SyntaxNode b);
    public sealed virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, AddImportPlacementOptions options);
    public sealed virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected abstract virtual SyntaxNode Rewrite(TExternSyntax[] externAliases, TUsingOrAliasSyntax[] usingDirectives, TUsingOrAliasSyntax[] staticUsingDirectives, TUsingOrAliasSyntax[] aliasDirectives, SyntaxNode externContainer, SyntaxNode usingContainer, SyntaxNode staticUsingContainer, SyntaxNode aliasContainer, AddImportPlacementOptions options, SyntaxNode root, CancellationToken cancellationToken);
    private void GetContainers(SyntaxNode root, SyntaxNode contextLocation, AddImportPlacementOptions options, SyntaxNode& externContainer, SyntaxNode& usingContainer, SyntaxNode& staticUsingContainer, SyntaxNode& aliasContainer);
    private static SyntaxNode GetFirstApplicableContainer(SyntaxNode contextNode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.AddImport.AddImportHelpers : object {
    public static TRootSyntax MoveTrivia(ISyntaxFacts syntaxFacts, TRootSyntax root, SyntaxList`1<TImportDirectiveSyntax> existingImports, List`1<TImportDirectiveSyntax> newImports);
    private static bool IsDocCommentOrElastic(ISyntaxFacts syntaxFacts, SyntaxTrivia t);
}
internal enum Microsoft.CodeAnalysis.AddImport.AddImportPlacement : Enum {
    public int value__;
    public static AddImportPlacement InsideNamespace;
    public static AddImportPlacement OutsideNamespace;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions : object {
    public static CodeStyleOption2`1<AddImportPlacement> s_outsideNamespacePlacementWithSilentEnforcement;
    [CompilerGeneratedAttribute]
private bool <PlaceSystemNamespaceFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<AddImportPlacement> <UsingDirectivePlacement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowInHiddenRegions>k__BackingField;
    public static AddImportPlacementOptions Default;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool PlaceSystemNamespaceFirst { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<AddImportPlacement> UsingDirectivePlacement { get; public set; }
    [DataMemberAttribute]
public bool AllowInHiddenRegions { get; public set; }
    public bool PlaceImportsInsideNamespaces { get; }
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions(AddImportPlacementOptions original);
    private static AddImportPlacementOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_PlaceSystemNamespaceFirst();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PlaceSystemNamespaceFirst(bool value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<AddImportPlacement> get_UsingDirectivePlacement();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UsingDirectivePlacement(CodeStyleOption2`1<AddImportPlacement> value);
    [CompilerGeneratedAttribute]
public bool get_AllowInHiddenRegions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AllowInHiddenRegions(bool value);
    public bool get_PlaceImportsInsideNamespaces();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(AddImportPlacementOptions left, AddImportPlacementOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(AddImportPlacementOptions left, AddImportPlacementOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(AddImportPlacementOptions other);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders : object {
    [ExtensionAttribute]
public static AddImportPlacementOptions GetAddImportPlacementOptions(AnalyzerConfigOptions options, bool allowInHiddenRegions, AddImportPlacementOptions fallbackOptions, LanguageServices languageServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders/<GetAddImportPlacementOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<AddImportPlacementOptions> GetAddImportPlacementOptionsAsync(Document document, AddImportPlacementOptions fallbackOptions, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AllowImportsInHiddenRegions(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders/<GetAddImportPlacementOptionsAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<AddImportPlacementOptions> GetAddImportPlacementOptionsAsync(Document document, AddImportPlacementOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptionsProviders/<GetAddImportPlacementOptionsAsync>d__4")]
[ExtensionAttribute]
internal static ValueTask`1<AddImportPlacementOptions> GetAddImportPlacementOptionsAsync(Document document, IAddImportsService addImportsService, AddImportPlacementOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AddImport.IAddImportServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode AddImport(IAddImportsService service, Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode newImport, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.AddImport.IAddImportsService {
    public abstract virtual AddImportPlacementOptions GetAddImportOptions(AnalyzerConfigOptions configOptions, bool allowInHiddenRegions, AddImportPlacementOptions fallbackOptions);
    public abstract virtual bool HasExistingImport(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, SyntaxGenerator generator);
    public abstract virtual SyntaxNode GetImportContainer(SyntaxNode root, SyntaxNode contextLocation, SyntaxNode import, AddImportPlacementOptions options);
    public abstract virtual SyntaxNode AddImports(Compilation compilation, SyntaxNode root, SyntaxNode contextLocation, IEnumerable`1<SyntaxNode> newImports, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.AdditionalDocument : TextDocument {
    [NullableContextAttribute("1")]
internal AdditionalDocument(Project project, TextDocumentState state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.AdditionalDocumentState : TextDocumentState {
    private AdditionalText _additionalText;
    public AdditionalText AdditionalText { get; }
    private AdditionalDocumentState(HostWorkspaceServices solutionServices, IDocumentServiceProvider documentServiceProvider, DocumentAttributes attributes, SourceText sourceText, ValueSource`1<TextAndVersion> textAndVersionSource);
    public AdditionalDocumentState(DocumentInfo documentInfo, HostWorkspaceServices solutionServices);
    public AdditionalText get_AdditionalText();
    public AdditionalDocumentState UpdateText(TextLoader loader, PreservationMode mode);
    public AdditionalDocumentState UpdateText(SourceText text, PreservationMode mode);
    public AdditionalDocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    protected virtual TextDocumentState UpdateText(ValueSource`1<TextAndVersion> newTextSource, PreservationMode mode, bool incremental);
}
public class Microsoft.CodeAnalysis.AdhocWorkspace : Workspace {
    public bool CanOpenDocuments { get; }
    public AdhocWorkspace(HostServices host, string workspaceKind);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    public virtual bool get_CanOpenDocuments();
    public void ClearSolution();
    public Solution AddSolution(SolutionInfo solutionInfo);
    public Project AddProject(string name, string language);
    public Project AddProject(ProjectInfo projectInfo);
    public void AddProjects(IEnumerable`1<ProjectInfo> projectInfos);
    public Document AddDocument(ProjectId projectId, string name, SourceText text);
    public Document AddDocument(DocumentInfo documentInfo);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
    public virtual void OpenAnalyzerConfigDocument(DocumentId documentId, bool activate);
    public virtual void CloseAnalyzerConfigDocument(DocumentId documentId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.AnalyzerAssemblyLoader : object {
    private object _guard;
    private Dictionary`2<string, Assembly> _loadedAssembliesByPath;
    private Dictionary`2<string, ImmutableHashSet`1<string>> _knownAssemblyPathsBySimpleName;
    protected abstract virtual Assembly LoadFromPathUncheckedImpl(string fullPath);
    public sealed virtual void AddDependencyLocation(string fullPath);
    public sealed virtual Assembly LoadFromPath(string fullPath);
    protected Assembly LoadFromPathUnchecked(string fullPath);
    protected ImmutableHashSet`1<string> GetPaths(string simpleName);
    protected virtual string GetPathToLoad(string fullPath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.AnalyzerConfigData : ValueType {
    public StructuredAnalyzerConfigOptions ConfigOptions;
    public ImmutableDictionary`2<string, string> AnalyzerOptions;
    public ImmutableDictionary`2<string, ReportDiagnostic> TreeOptions;
    public AnalyzerConfigData(AnalyzerConfigOptionsResult result);
}
public class Microsoft.CodeAnalysis.AnalyzerConfigDocument : TextDocument {
    [NullableContextAttribute("1")]
internal AnalyzerConfigDocument(Project project, AnalyzerConfigDocumentState state);
}
internal class Microsoft.CodeAnalysis.AnalyzerConfigDocumentState : TextDocumentState {
    private ValueSource`1<AnalyzerConfig> _analyzerConfigValueSource;
    private AnalyzerConfigDocumentState(HostWorkspaceServices solutionServices, IDocumentServiceProvider documentServiceProvider, DocumentAttributes attributes, SourceText sourceTextOpt, ValueSource`1<TextAndVersion> textAndVersionSource);
    public AnalyzerConfigDocumentState(DocumentInfo documentInfo, HostWorkspaceServices solutionServices);
    private ValueSource`1<AnalyzerConfig> CreateAnalyzerConfigValueSource();
    public AnalyzerConfig GetAnalyzerConfig(CancellationToken cancellationToken);
    public Task`1<AnalyzerConfig> GetAnalyzerConfigAsync(CancellationToken cancellationToken);
    public AnalyzerConfigDocumentState UpdateText(TextLoader loader, PreservationMode mode);
    public AnalyzerConfigDocumentState UpdateText(SourceText text, PreservationMode mode);
    public AnalyzerConfigDocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    protected virtual TextDocumentState UpdateText(ValueSource`1<TextAndVersion> newTextSource, PreservationMode mode, bool incremental);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.AnalyzerConfigDocumentState/<<CreateAnalyzerConfigValueSource>b__3_0>d")]
[CompilerGeneratedAttribute]
private Task`1<AnalyzerConfig> <CreateAnalyzerConfigValueSource>b__3_0(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private AnalyzerConfig <CreateAnalyzerConfigValueSource>b__3_1(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.AnalyzerConfigOptionsExtensions : object {
    [ExtensionAttribute]
public static T GetOption(AnalyzerConfigOptions analyzerConfigOptions, Option2`1<T> option);
    [ExtensionAttribute]
public static T GetOption(AnalyzerConfigOptions analyzerConfigOptions, PerLanguageOption2`1<T> option);
    private static T GetOptionWithAssertOnFailure(AnalyzerConfigOptions analyzerConfigOptions, IOption option);
    [ExtensionAttribute]
private static bool TryGetEditorConfigOptionOrDefault(AnalyzerConfigOptions analyzerConfigOptions, IOption option, T& value);
    [ExtensionAttribute]
public static bool TryGetEditorConfigOption(AnalyzerConfigOptions analyzerConfigOptions, IOption option, T& value);
    [ExtensionAttribute]
public static T GetEditorConfigOption(AnalyzerConfigOptions analyzerConfigOptions, IOption option, T defaultValue);
    [ExtensionAttribute]
public static T GetEditorConfigOptionValue(AnalyzerConfigOptions analyzerConfigOptions, IOption option, T defaultValue);
    [ExtensionAttribute]
private static bool TryGetEditorConfigOption(AnalyzerConfigOptions analyzerConfigOptions, IOption option, Optional`1<T> defaultValue, T& value);
}
public enum Microsoft.CodeAnalysis.ApplyChangesKind : Enum {
    public int value__;
    public static ApplyChangesKind AddProject;
    public static ApplyChangesKind RemoveProject;
    public static ApplyChangesKind AddProjectReference;
    public static ApplyChangesKind RemoveProjectReference;
    public static ApplyChangesKind AddMetadataReference;
    public static ApplyChangesKind RemoveMetadataReference;
    public static ApplyChangesKind AddDocument;
    public static ApplyChangesKind RemoveDocument;
    public static ApplyChangesKind ChangeDocument;
    public static ApplyChangesKind AddAnalyzerReference;
    public static ApplyChangesKind RemoveAnalyzerReference;
    public static ApplyChangesKind AddAdditionalDocument;
    public static ApplyChangesKind RemoveAdditionalDocument;
    public static ApplyChangesKind ChangeAdditionalDocument;
    public static ApplyChangesKind ChangeCompilationOptions;
    public static ApplyChangesKind ChangeParseOptions;
    public static ApplyChangesKind ChangeDocumentInfo;
    public static ApplyChangesKind AddAnalyzerConfigDocument;
    public static ApplyChangesKind RemoveAnalyzerConfigDocument;
    public static ApplyChangesKind ChangeAnalyzerConfigDocument;
    public static ApplyChangesKind AddSolutionAnalyzerReference;
    public static ApplyChangesKind RemoveSolutionAnalyzerReference;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ArrayBuilderExtensions : object {
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool Any(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(ArrayBuilder`1<T> builder, Func`3<T, A, bool> predicate, A arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`2<TItem, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ArrayBuilder`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArrayWithIndex(ArrayBuilder`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static void AddOptional(ArrayBuilder`1<T> builder, T item);
    [ExtensionAttribute]
public static void Push(ArrayBuilder`1<T> builder, T e);
    [ExtensionAttribute]
public static T Pop(ArrayBuilder`1<T> builder);
    [ExtensionAttribute]
public static bool TryPop(ArrayBuilder`1<T> builder, T& result);
    [ExtensionAttribute]
public static T Peek(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableOrEmptyAndFree(ArrayBuilder`1<T> builder);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ArrayBuilder`1<T> builder, T value);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void FreeAll(ArrayBuilder`1<T> builder, Func`2<T, ArrayBuilder`1<T>> getNested);
}
internal static class Microsoft.CodeAnalysis.AssemblyIdentityUtils : object {
    [NullableContextAttribute("1")]
public static AssemblyIdentity TryGetAssemblyIdentity(string filePath);
}
internal abstract class Microsoft.CodeAnalysis.AsyncSymbolVisitor : SymbolVisitor`1<ValueTask> {
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.AsyncSymbolVisitor`1 : SymbolVisitor`1<ValueTask`1<TResult>> {
    protected TResult DefaultResult { get; }
    protected abstract virtual TResult get_DefaultResult();
    [NullableContextAttribute("2")]
public virtual ValueTask`1<TResult> Visit(ISymbol symbol);
    public virtual ValueTask`1<TResult> DefaultVisit(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.BitVector : ValueType {
    private static ulong ZeroWord;
    private static int Log2BitsPerWord;
    public static int BitsPerWord;
    private static BitVector s_nullValue;
    private static BitVector s_emptyValue;
    private ulong _bits0;
    private UInt64[] _bits;
    private int _capacity;
    private static UInt64[] s_emptyArray { get; }
    public int Capacity { get; }
    public bool IsNull { get; }
    public static BitVector Null { get; }
    public static BitVector Empty { get; }
    public bool Item { get; public set; }
    private BitVector(ulong bits0, UInt64[] bits, int capacity);
    private static BitVector();
    private static UInt64[] get_s_emptyArray();
    public sealed virtual bool Equals(BitVector other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static bool op_Equality(BitVector left, BitVector right);
    public static bool op_Inequality(BitVector left, BitVector right);
    public virtual int GetHashCode();
    private static int WordsForCapacity(int capacity);
    public int get_Capacity();
    [ConditionalAttribute("DEBUG_BITARRAY")]
private void Check();
    public void EnsureCapacity(int newCapacity);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<Words>d__21")]
public IEnumerable`1<ulong> Words();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.BitVector/<TrueBits>d__22")]
public IEnumerable`1<int> TrueBits();
    public static BitVector FromWords(ulong bits0, UInt64[] bits, int capacity);
    public static BitVector Create(int capacity);
    public static BitVector AllSet(int capacity);
    public BitVector Clone();
    public void Invert();
    public bool get_IsNull();
    public static BitVector get_Null();
    public static BitVector get_Empty();
    public bool IntersectWith(BitVector& other);
    public bool UnionWith(BitVector& other);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
    public void Clear();
    public static bool IsTrue(ulong word, int index);
    public static int WordsRequired(int capacity);
    internal string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Boxes : object {
    public static object BoxedTrue;
    public static object BoxedFalse;
    public static object BoxedByteZero;
    public static object BoxedSByteZero;
    public static object BoxedInt16Zero;
    public static object BoxedUInt16Zero;
    public static object BoxedInt32Zero;
    public static object BoxedInt32One;
    public static object BoxedUInt32Zero;
    public static object BoxedInt64Zero;
    public static object BoxedUInt64Zero;
    public static object BoxedSingleZero;
    public static object BoxedDoubleZero;
    public static object BoxedDecimalZero;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Object[] s_boxedAsciiChars;
    private static Boxes();
    public static object Box(bool b);
    public static object Box(byte b);
    public static object Box(sbyte sb);
    public static object Box(short s);
    public static object Box(ushort us);
    public static object Box(int i);
    public static object Box(UInt32 u);
    public static object Box(long l);
    public static object Box(ulong ul);
    public static object Box(float f);
    public static object Box(double d);
    public static object Box(char c);
    public static object Box(decimal d);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService : object {
    protected abstract virtual void AddReplacements(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> replacements, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.AbstractCaseCorrectionService/<CaseCorrectAsync>d__1")]
public sealed virtual Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    private SyntaxNode CaseCorrect(SemanticModel semanticModel, SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector : object {
    public static SyntaxAnnotation Annotation;
    private static CaseCorrector();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__1")]
public static Task`1<Document> CaseCorrectAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__2")]
public static Task`1<Document> CaseCorrectAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CaseCorrection.CaseCorrector/<CaseCorrectAsync>d__3")]
public static Task`1<Document> CaseCorrectAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    public static Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    internal static SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SolutionServices services, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CaseCorrection.ICaseCorrectionService {
    public abstract virtual Task`1<Document> CaseCorrectAsync(Document document, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CaseCorrect(SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ChangeNamespace.IChangeNamespaceService {
    public abstract virtual Task`1<bool> CanChangeNamespaceAsync(Document document, SyntaxNode container, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> ChangeNamespaceAsync(Document document, SyntaxNode container, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Solution> TryChangeTopLevelNamespacesAsync(Document document, string targetNamespace, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Checksum : object {
    public static int HashSize;
    public static Checksum Null;
    [DataMemberAttribute]
private HashData _checksum;
    [CompilerGeneratedAttribute]
private static Func`2<Checksum, string> <GetChecksumLogInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private static Func`2<IEnumerable`1<Checksum>, string> <GetChecksumsLogInfo>k__BackingField;
    [NullableAttribute("1")]
private static ObjectPool`1<IncrementalHash> s_incrementalHashPool;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public static Func`2<Checksum, string> GetChecksumLogInfo { get; }
    public static Func`2<IEnumerable`1<Checksum>, string> GetChecksumsLogInfo { get; }
    public Checksum(HashData hash);
    private static Checksum();
    public static Checksum From(Byte[] checksum);
    public static Checksum From(ImmutableArray`1<byte> checksum);
    public static Checksum From(ReadOnlySpan`1<byte> checksum);
    public sealed virtual bool Equals(Checksum other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public string ToBase64String();
    public static Checksum FromBase64String(string value);
    public virtual string ToString();
    public static bool op_Equality(Checksum left, Checksum right);
    public static bool op_Inequality(Checksum left, Checksum right);
    public static bool op_Equality(Checksum left, HashData right);
    public static bool op_Inequality(Checksum left, HashData right);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    public void WriteTo(Span`1<byte> span);
    public static Checksum ReadFrom(ObjectReader reader);
    [CompilerGeneratedAttribute]
public static Func`2<Checksum, string> get_GetChecksumLogInfo();
    [CompilerGeneratedAttribute]
public static Func`2<IEnumerable`1<Checksum>, string> get_GetChecksumsLogInfo();
    [NullableContextAttribute("1")]
public static Checksum Create(IEnumerable`1<string> values);
    [NullableContextAttribute("1")]
public static Checksum Create(string value);
    [NullableContextAttribute("1")]
public static Checksum Create(Stream stream);
    [NullableContextAttribute("1")]
public static Checksum Create(IObjectWritable object);
    [NullableContextAttribute("1")]
public static Checksum Create(Checksum checksum1, Checksum checksum2);
    [NullableContextAttribute("1")]
public static Checksum Create(Checksum checksum1, Checksum checksum2, Checksum checksum3);
    [NullableContextAttribute("1")]
public static Checksum Create(IEnumerable`1<Checksum> checksums);
    public static Checksum Create(ImmutableArray`1<byte> bytes);
    [NullableContextAttribute("1")]
public static Checksum Create(T value, ISerializerService serializer);
    [NullableContextAttribute("1")]
public static Checksum Create(ParseOptions value, ISerializerService serializer);
    [NullableContextAttribute("1")]
private static void AppendData(IncrementalHash hash, Byte[] buffer, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractClassificationService : object {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
    public sealed virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual Task AddEmbeddedLanguageClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddClassificationsAsync>d__4")]
private static Task AddClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ClassificationType type, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    private static bool IsFullyLoaded(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<TryGetCachedClassificationsAsync>d__6")]
private static Task`1<bool> TryGetCachedClassificationsAsync(Document document, TextSpan textSpan, ClassificationType type, RemoteHostClient client, bool isFullyLoaded, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddClassificationsInCurrentProcessAsync>d__7")]
public static Task AddClassificationsInCurrentProcessAsync(Document document, TextSpan textSpan, ClassificationType type, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractClassificationService/<AddSyntacticClassificationsAsync>d__8")]
public sealed virtual Task AddSyntacticClassificationsAsync(Document document, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual void AddSyntacticClassifications(SolutionServices services, SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    protected static void AddRange(ArrayBuilder`1<ClassifiedSpan> temp, List`1<ClassifiedSpan> result);
    public sealed virtual ValueTask`1<Nullable`1<TextChangeRange>> ComputeSyntacticChangeRangeAsync(Document oldDocument, Document newDocument, TimeSpan timeout, CancellationToken cancellationToken);
    public sealed virtual Nullable`1<TextChangeRange> ComputeSyntacticChangeRange(SolutionServices services, SyntaxNode oldRoot, SyntaxNode newRoot, TimeSpan timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService : object {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
    [NullableContextAttribute("2")]
public abstract virtual string GetSyntacticClassificationForIdentifier(SyntaxToken identifier);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.AbstractSyntaxClassificationService/<AddSemanticClassificationsAsync>d__6")]
public sealed virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public sealed virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, ClassificationOptions options, CancellationToken cancellationToken);
    public sealed virtual Nullable`1<TextChangeRange> ComputeSyntacticChangeRange(SyntaxNode oldRoot, SyntaxNode newRoot, TimeSpan timeout, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Classification.ClassificationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetClassification(ITypeSymbol type);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Classification.ClassificationOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <ClassifyReassignedVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ColorizeRegexPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ColorizeJsonPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceFrozenPartialSemanticsForCrossProcessOperations>k__BackingField;
    public static ClassificationOptions Default;
    [DataMemberAttribute]
public bool ClassifyReassignedVariables { get; public set; }
    [DataMemberAttribute]
public bool ColorizeRegexPatterns { get; public set; }
    [DataMemberAttribute]
public bool ColorizeJsonPatterns { get; public set; }
    [DataMemberAttribute]
public bool ForceFrozenPartialSemanticsForCrossProcessOperations { get; public set; }
    private static ClassificationOptions();
    [CompilerGeneratedAttribute]
public bool get_ClassifyReassignedVariables();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ClassifyReassignedVariables(bool value);
    [CompilerGeneratedAttribute]
public bool get_ColorizeRegexPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorizeRegexPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_ColorizeJsonPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ColorizeJsonPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_ForceFrozenPartialSemanticsForCrossProcessOperations();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ForceFrozenPartialSemanticsForCrossProcessOperations(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ClassificationOptions left, ClassificationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ClassificationOptions left, ClassificationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ClassificationOptions other);
}
internal enum Microsoft.CodeAnalysis.Classification.ClassificationType : Enum {
    public int value__;
    public static ClassificationType Semantic;
    public static ClassificationType EmbeddedLanguage;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Classification.ClassificationTypeNames : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<string> <AdditiveTypeNames>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<string> <AllTypeNames>k__BackingField;
    public static string Comment;
    public static string ExcludedCode;
    public static string Identifier;
    public static string Keyword;
    public static string ControlKeyword;
    public static string NumericLiteral;
    public static string Operator;
    public static string OperatorOverloaded;
    public static string PreprocessorKeyword;
    public static string StringLiteral;
    public static string WhiteSpace;
    public static string Text;
    internal static string ReassignedVariable;
    public static string StaticSymbol;
    public static string PreprocessorText;
    public static string Punctuation;
    public static string VerbatimStringLiteral;
    public static string StringEscapeCharacter;
    public static string ClassName;
    public static string RecordClassName;
    public static string DelegateName;
    public static string EnumName;
    public static string InterfaceName;
    public static string ModuleName;
    public static string StructName;
    public static string RecordStructName;
    public static string TypeParameterName;
    public static string FieldName;
    public static string EnumMemberName;
    public static string ConstantName;
    public static string LocalName;
    public static string ParameterName;
    public static string MethodName;
    public static string ExtensionMethodName;
    public static string PropertyName;
    public static string EventName;
    public static string NamespaceName;
    public static string LabelName;
    public static string XmlDocCommentAttributeName;
    public static string XmlDocCommentAttributeQuotes;
    public static string XmlDocCommentAttributeValue;
    public static string XmlDocCommentCDataSection;
    public static string XmlDocCommentComment;
    public static string XmlDocCommentDelimiter;
    public static string XmlDocCommentEntityReference;
    public static string XmlDocCommentName;
    public static string XmlDocCommentProcessingInstruction;
    public static string XmlDocCommentText;
    public static string XmlLiteralAttributeName;
    public static string XmlLiteralAttributeQuotes;
    public static string XmlLiteralAttributeValue;
    public static string XmlLiteralCDataSection;
    public static string XmlLiteralComment;
    public static string XmlLiteralDelimiter;
    public static string XmlLiteralEmbeddedExpression;
    public static string XmlLiteralEntityReference;
    public static string XmlLiteralName;
    public static string XmlLiteralProcessingInstruction;
    public static string XmlLiteralText;
    public static string RegexComment;
    public static string RegexCharacterClass;
    public static string RegexAnchor;
    public static string RegexQuantifier;
    public static string RegexGrouping;
    public static string RegexAlternation;
    public static string RegexText;
    public static string RegexSelfEscapedCharacter;
    public static string RegexOtherEscape;
    internal static string JsonComment;
    internal static string JsonNumber;
    internal static string JsonString;
    internal static string JsonKeyword;
    internal static string JsonText;
    internal static string JsonOperator;
    internal static string JsonPunctuation;
    internal static string JsonArray;
    internal static string JsonObject;
    internal static string JsonPropertyName;
    internal static string JsonConstructorName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> AdditiveTypeNames { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<string> AllTypeNames { get; }
    private static ClassificationTypeNames();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<string> get_AdditiveTypeNames();
    [CompilerGeneratedAttribute]
public static ImmutableArray`1<string> get_AllTypeNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Classification.ClassifiedSpan : ValueType {
    [CompilerGeneratedAttribute]
private string <ClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    public string ClassificationType { get; }
    public TextSpan TextSpan { get; }
    public ClassifiedSpan(string classificationType, TextSpan textSpan);
    public ClassifiedSpan(TextSpan textSpan, string classificationType);
    [CompilerGeneratedAttribute]
public string get_ClassificationType();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ClassifiedSpan other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Classification.ClassifiedText : ValueType {
    [CompilerGeneratedAttribute]
private string <ClassificationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string ClassificationType { get; }
    public string Text { get; }
    public ClassifiedText(string classificationType, string text);
    [CompilerGeneratedAttribute]
public string get_ClassificationType();
    [CompilerGeneratedAttribute]
public string get_Text();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Classification.Classifier : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSpansAsync>d__0")]
public static Task`1<IEnumerable`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan textSpan, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use GetClassifiedSpansAsync instead")]
public static IEnumerable`1<ClassifiedSpan> GetClassifiedSpans(SemanticModel semanticModel, TextSpan textSpan, Workspace workspace, CancellationToken cancellationToken);
    internal static IEnumerable`1<ClassifiedSpan> GetClassifiedSpans(SolutionServices services, Project project, SemanticModel semanticModel, TextSpan textSpan, ClassificationOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<GetClassifiedSymbolDisplayPartsAsync>d__3")]
internal static Task`1<ImmutableArray`1<SymbolDisplayPart>> GetClassifiedSymbolDisplayPartsAsync(SolutionServices services, SemanticModel semanticModel, TextSpan textSpan, ClassificationOptions options, CancellationToken cancellationToken);
    internal static ImmutableArray`1<SymbolDisplayPart> ConvertClassificationsToParts(SourceText sourceText, int startPosition, IEnumerable`1<ClassifiedSpan> classifiedSpans);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Classification.Classifier/<Space>d__5")]
private static IEnumerable`1<SymbolDisplayPart> Space(int count);
    private static Nullable`1<SymbolDisplayPartKind> GetClassificationKind(string type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Classification.ClassifierHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.ClassifierHelper/<GetClassifiedSpansAsync>d__0")]
public static Task`1<ImmutableArray`1<ClassifiedSpan>> GetClassifiedSpansAsync(Document document, TextSpan span, ClassificationOptions options, CancellationToken cancellationToken, bool removeAdditiveSpans, bool fillInClassifiedSpanGaps);
    private static void RemoveAdditiveSpans(ArrayBuilder`1<ClassifiedSpan> spans);
    private static ImmutableArray`1<ClassifiedSpan> MergeClassifiedSpans(ArrayBuilder`1<ClassifiedSpan> syntaxSpans, ArrayBuilder`1<ClassifiedSpan> semanticSpans, TextSpan widenedSpan, bool fillInClassifiedSpanGaps);
    private static void Order(ArrayBuilder`1<ClassifiedSpan> syntaxSpans);
    private static void AdjustSpans(ArrayBuilder`1<ClassifiedSpan> spans, TextSpan widenedSpan);
    public static void FillInClassifiedSpanGaps(int startPosition, ArrayBuilder`1<ClassifiedSpan> classifiedSpans, ArrayBuilder`1<ClassifiedSpan> result);
    private static ImmutableArray`1<ClassifiedSpan> MergeParts(ArrayBuilder`1<ClassifiedSpan> syntaxParts, ArrayBuilder`1<ClassifiedSpan> semanticParts);
    private static bool IsClassifiedAsText(ClassifiedSpan partAndSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Classification.Classifiers.AbstractNameSyntaxClassifier : AbstractSyntaxClassifier {
    protected abstract virtual Nullable`1<int> GetRightmostNameArity(SyntaxNode node);
    protected abstract virtual bool IsParentAnAttribute(SyntaxNode node);
    protected ISymbol TryGetSymbol(SyntaxNode node, SymbolInfo symbolInfo);
    protected static void TryClassifyStaticSymbol(ISymbol symbol, TextSpan span, ArrayBuilder`1<ClassifiedSpan> result);
    protected static bool IsStaticSymbol(ISymbol symbol);
}
internal abstract class Microsoft.CodeAnalysis.Classification.Classifiers.AbstractSyntaxClassifier : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    [NullableContextAttribute("1")]
protected static string GetClassificationForType(ITypeSymbol type);
    [NullableContextAttribute("1")]
public virtual void AddClassifications(SyntaxNode syntax, SemanticModel semanticModel, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public virtual void AddClassifications(SyntaxToken syntax, SemanticModel semanticModel, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
}
internal interface Microsoft.CodeAnalysis.Classification.Classifiers.ISyntaxClassifier {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Type> SyntaxNodeTypes { get; }
    public ImmutableArray`1<int> SyntaxTokenKinds { get; }
    public abstract virtual ImmutableArray`1<Type> get_SyntaxNodeTypes();
    public abstract virtual ImmutableArray`1<int> get_SyntaxTokenKinds();
    [NullableContextAttribute("1")]
public abstract virtual void AddClassifications(SyntaxNode node, SemanticModel semanticModel, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual void AddClassifications(SyntaxToken token, SemanticModel semanticModel, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Classification.IClassificationService {
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SolutionServices services, SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSyntacticClassificationsAsync(Document document, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddEmbeddedLanguageClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual ClassifiedSpan AdjustStaleClassification(SourceText text, ClassifiedSpan classifiedSpan);
    public abstract virtual ValueTask`1<Nullable`1<TextChangeRange>> ComputeSyntacticChangeRangeAsync(Document oldDocument, Document newDocument, TimeSpan timeout, CancellationToken cancellationToken);
    public abstract virtual Nullable`1<TextChangeRange> ComputeSyntacticChangeRange(SolutionServices workspace, SyntaxNode oldRoot, SyntaxNode newRoot, TimeSpan timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Classification.IEmbeddedLanguageClassificationService {
    public abstract virtual Task AddEmbeddedLanguageClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddEmbeddedLanguageClassifications(Project project, SemanticModel semanticModel, TextSpan textSpan, ClassificationOptions options, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Classification.IRemoteSemanticClassificationService {
    public abstract virtual ValueTask`1<SerializableClassifiedSpans> GetClassificationsAsync(Checksum solutionChecksum, DocumentId documentId, TextSpan span, ClassificationType type, ClassificationOptions options, bool isFullyLoaded, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<SerializableClassifiedSpans> GetCachedClassificationsAsync(DocumentKey documentKey, TextSpan textSpan, ClassificationType type, Checksum checksum, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Classification.ISyntaxClassificationService {
    public abstract virtual ImmutableArray`1<ISyntaxClassifier> GetDefaultSyntaxClassifiers();
    public abstract virtual void AddLexicalClassifications(SourceText text, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSyntacticClassifications(SyntaxNode root, TextSpan textSpan, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual Task AddSemanticClassificationsAsync(Document document, TextSpan textSpan, ClassificationOptions options, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, CancellationToken cancellationToken);
    public abstract virtual void AddSemanticClassifications(SemanticModel semanticModel, TextSpan textSpan, Func`2<SyntaxNode, ImmutableArray`1<ISyntaxClassifier>> getNodeClassifiers, Func`2<SyntaxToken, ImmutableArray`1<ISyntaxClassifier>> getTokenClassifiers, ArrayBuilder`1<ClassifiedSpan> result, ClassificationOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual string GetSyntacticClassificationForIdentifier(SyntaxToken identifier);
    public abstract virtual ClassifiedSpan FixClassification(SourceText text, ClassifiedSpan classifiedSpan);
    public abstract virtual Nullable`1<TextChangeRange> ComputeSyntacticChangeRange(SyntaxNode oldRoot, SyntaxNode newRoot, TimeSpan timeout, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Classification.SemanticClassificationCacheUtilities : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Classification.SemanticClassificationCacheUtilities/<GetDocumentKeyAndChecksumAsync>d__0")]
public static Task`1<ValueTuple`2<DocumentKey, Checksum>> GetDocumentKeyAndChecksumAsync(Document document, CancellationToken cancellationToken);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Classification.SerializableClassifiedSpans : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public List`1<string> ClassificationTypes;
    [NullableAttribute("2")]
[DataMemberAttribute]
public List`1<int> ClassificationTriples;
    internal static SerializableClassifiedSpans Dehydrate(ImmutableArray`1<ClassifiedSpan> classifiedSpans);
    [NullableContextAttribute("1")]
private static SerializableClassifiedSpans Dehydrate(ImmutableArray`1<ClassifiedSpan> classifiedSpans, Dictionary`2<string, int> classificationTypeToId);
    [NullableContextAttribute("1")]
internal void Rehydrate(ArrayBuilder`1<ClassifiedSpan> classifiedSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Classification.SyntacticChangeRangeComputer : object {
    private static ObjectPool`1<Stack`1<SyntaxNodeOrToken>> s_pool;
    private static SyntacticChangeRangeComputer();
    public static TextChangeRange ComputeSyntacticChangeRange(SyntaxNode oldRoot, SyntaxNode newRoot, TimeSpan timeout, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static Nullable`1<int> <ComputeSyntacticChangeRange>g__ComputeCommonLeftWidth|1_0(<>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static int <ComputeSyntacticChangeRange>g__ComputeCommonRightWidth|1_1(<>c__DisplayClass1_0& );
}
internal abstract class Microsoft.CodeAnalysis.CodeActions.AbstractCodeActionOptionsProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual CodeActionOptions GetOptions(LanguageServices languageServices);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<LineFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.LineFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<DocumentFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<SyntaxFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<SimplifierOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Simplification.SimplifierOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<AddImportPlacementOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<OrganizeImportsOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<CodeCleanupOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<CodeGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<NamingStylePreferences> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<CleanCodeGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<CodeAndImportGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeActions.ApplyChangesOperation : CodeActionOperation {
    [CompilerGeneratedAttribute]
private Solution <ChangedSolution>k__BackingField;
    public Solution ChangedSolution { get; }
    internal bool ApplyDuringTests { get; }
    public ApplyChangesOperation(Solution changedSolution);
    [CompilerGeneratedAttribute]
public Solution get_ChangedSolution();
    internal virtual bool get_ApplyDuringTests();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
    internal sealed virtual Task`1<bool> TryApplyAsync(Workspace workspace, Solution originalSolution, IProgressTracker progressTracker, CancellationToken cancellationToken);
    internal static bool ApplyOrMergeChanges(Workspace workspace, Solution originalSolution, Solution changedSolution, IProgressTracker progressTracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeAction : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <CustomTags>k__BackingField;
    [NullableAttribute("2")]
private Type _providerTypeForTelemetry;
    public string Title { get; }
    internal string Message { get; }
    [NullableAttribute("2")]
public string EquivalenceKey { get; }
    internal bool IsInlinable { get; }
    internal CodeActionPriority Priority { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> Tags { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableArray`1<CodeAction> NestedCodeActions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableArray`1<string> CustomTags { get; private set; }
    public abstract virtual string get_Title();
    internal virtual string get_Message();
    [NullableContextAttribute("2")]
public virtual string get_EquivalenceKey();
    internal virtual bool get_IsInlinable();
    internal virtual CodeActionPriority get_Priority();
    public virtual ImmutableArray`1<string> get_Tags();
    internal virtual ImmutableArray`1<CodeAction> get_NestedCodeActions();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<string> get_CustomTags();
    [CompilerGeneratedAttribute]
private void set_CustomTags(ImmutableArray`1<string> value);
    internal void AddCustomTagAndTelemetryInfo(CodeChangeProviderMetadata providerMetadata, object provider);
    internal Guid GetTelemetryId(Nullable`1<FixAllScope> fixAllScope);
    public Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsAsync(CancellationToken cancellationToken);
    internal Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetOperationsCoreAsync>d__23")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetPreviewOperationsAsync>d__24")]
public Task`1<ImmutableArray`1<CodeActionOperation>> GetPreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputeOperationsAsync>d__25")]
protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<ComputeOperationsAsync>d__26")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> ComputeOperationsAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputePreviewOperationsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionAsync>d__28")]
protected virtual Task`1<Solution> GetChangedSolutionAsync(CancellationToken cancellationToken);
    internal virtual Task`1<Solution> GetChangedSolutionAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected virtual Task`1<Document> GetChangedDocumentAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<GetChangedSolutionInternalAsync>d__31")]
internal Task`1<Solution> GetChangedSolutionInternalAsync(bool postProcessChanges, CancellationToken cancellationToken);
    internal Task`1<Document> GetChangedDocumentInternalAsync(CancellationToken cancellation);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessAsync>d__33")]
protected Task`1<ImmutableArray`1<CodeActionOperation>> PostProcessAsync(IEnumerable`1<CodeActionOperation> operations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessChangesAsync>d__34")]
protected Task`1<Solution> PostProcessChangesAsync(Solution changedSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<PostProcessChangesAsync>d__35")]
protected virtual Task`1<Document> PostProcessChangesAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeAction/<CleanupDocumentAsync>d__36")]
internal static Task`1<Document> CleanupDocumentAsync(Document document, CodeCleanupOptions options, CancellationToken cancellationToken);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string equivalenceKey);
    public static CodeAction Create(string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, string equivalenceKey);
    public static CodeAction Create(string title, ImmutableArray`1<CodeAction> nestedActions, bool isInlinable);
    internal static CodeAction CreateWithPriority(CodeActionPriority priority, string title, Func`2<CancellationToken, Task`1<Document>> createChangedDocument, string equivalenceKey);
    internal static CodeAction CreateWithPriority(CodeActionPriority priority, string title, Func`2<CancellationToken, Task`1<Solution>> createChangedSolution, string equivalenceKey);
    internal static CodeAction CreateWithPriority(CodeActionPriority priority, string title, ImmutableArray`1<CodeAction> nestedActions, bool isInlinable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionOperation : object {
    [NullableAttribute("2")]
public string Title { get; }
    internal bool ApplyDuringTests { get; }
    [NullableContextAttribute("2")]
public virtual string get_Title();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
    internal virtual Task`1<bool> TryApplyAsync(Workspace workspace, Solution originalSolution, IProgressTracker progressTracker, CancellationToken cancellationToken);
    internal virtual bool get_ApplyDuringTests();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CodeActionOptions : object {
    public static CodeActionOptionsProvider DefaultProvider;
    public static int DefaultWrappingColumn;
    public static int DefaultConditionalExpressionWrappingLength;
    [CompilerGeneratedAttribute]
private CodeCleanupOptions <CleanupOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <CodeGenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IdeCodeStyleOptions <CodeStyleOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolSearchOptions <SearchOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplementTypeOptions <ImplementTypeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractMethodOptions <ExtractMethodOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private int <WrappingColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConditionalExpressionWrappingLength>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableConvertToRecord>k__BackingField;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public CodeCleanupOptions CleanupOptions { get; public set; }
    [DataMemberAttribute]
public CodeGenerationOptions CodeGenerationOptions { get; public set; }
    [DataMemberAttribute]
public IdeCodeStyleOptions CodeStyleOptions { get; public set; }
    [DataMemberAttribute]
public SymbolSearchOptions SearchOptions { get; public set; }
    [DataMemberAttribute]
public ImplementTypeOptions ImplementTypeOptions { get; public set; }
    [DataMemberAttribute]
public ExtractMethodOptions ExtractMethodOptions { get; public set; }
    [DataMemberAttribute]
public bool HideAdvancedMembers { get; public set; }
    [DataMemberAttribute]
public int WrappingColumn { get; public set; }
    [DataMemberAttribute]
public int ConditionalExpressionWrappingLength { get; public set; }
    [DataMemberAttribute]
public bool EnableConvertToRecord { get; public set; }
    public CodeActionOptions(CodeCleanupOptions cleanupOptions, CodeGenerationOptions codeGenerationOptions, IdeCodeStyleOptions codeStyleOptions);
    [CompilerGeneratedAttribute]
private CodeActionOptions(CodeActionOptions original);
    private static CodeActionOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public CodeCleanupOptions get_CleanupOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanupOptions(CodeCleanupOptions value);
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_CodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeGenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public IdeCodeStyleOptions get_CodeStyleOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeStyleOptions(IdeCodeStyleOptions value);
    [CompilerGeneratedAttribute]
public SymbolSearchOptions get_SearchOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SearchOptions(SymbolSearchOptions value);
    [CompilerGeneratedAttribute]
public ImplementTypeOptions get_ImplementTypeOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ImplementTypeOptions(ImplementTypeOptions value);
    [CompilerGeneratedAttribute]
public ExtractMethodOptions get_ExtractMethodOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtractMethodOptions(ExtractMethodOptions value);
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [CompilerGeneratedAttribute]
public int get_WrappingColumn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WrappingColumn(int value);
    [CompilerGeneratedAttribute]
public int get_ConditionalExpressionWrappingLength();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConditionalExpressionWrappingLength(int value);
    [CompilerGeneratedAttribute]
public bool get_EnableConvertToRecord();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnableConvertToRecord(bool value);
    public static CodeActionOptions GetDefault(LanguageServices languageServices);
    public CodeActionOptionsProvider CreateProvider();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CodeActionOptions left, CodeActionOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CodeActionOptions left, CodeActionOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeActionOptions other);
    [CompilerGeneratedAttribute]
public CodeActionOptions <Clone>$();
    [CompilerGeneratedAttribute]
private CodeActionOptions <CreateProvider>b__47_0(LanguageServices _);
}
internal interface Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProvider {
    [NullableContextAttribute("1")]
public abstract virtual CodeActionOptions GetOptions(LanguageServices languageService);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CodeActionOptionsProviders : object {
    [ExtensionAttribute]
internal static CodeActionOptionsProvider GetOptionsProvider(CodeFixContext context);
    [ExtensionAttribute]
internal static CodeActionOptionsProvider GetOptionsProvider(IFixAllContext context);
    [ExtensionAttribute]
public static ImplementTypeGenerationOptions GetImplementTypeGenerationOptions(CodeActionOptionsProvider provider, LanguageServices languageServices);
    [ExtensionAttribute]
public static ExtractMethodGenerationOptions GetExtractMethodGenerationOptions(CodeActionOptionsProvider provider, LanguageServices languageServices);
}
internal enum Microsoft.CodeAnalysis.CodeActions.CodeActionPriority : Enum {
    public int value__;
    public static CodeActionPriority Lowest;
    public static CodeActionPriority Low;
    public static CodeActionPriority Medium;
    public static CodeActionPriority High;
    public static CodeActionPriority Default;
}
internal enum Microsoft.CodeAnalysis.CodeActions.CodeActionRequestPriority : Enum {
    public int value__;
    public static CodeActionRequestPriority None;
    public static CodeActionRequestPriority Lowest;
    public static CodeActionRequestPriority Low;
    public static CodeActionRequestPriority Normal;
    public static CodeActionRequestPriority High;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions : CodeAction {
    [NullableContextAttribute("2")]
public abstract virtual object GetOptions(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsAsync>d__1")]
public Task`1<IEnumerable`1<CodeActionOperation>> GetOperationsAsync(object options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeActionWithOptions/<GetOperationsCoreAsync>d__2")]
internal virtual Task`1<ImmutableArray`1<CodeActionOperation>> GetOperationsCoreAsync(IProgressTracker progressTracker, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(object options, CancellationToken cancellationToken);
    protected virtual Task`1<IEnumerable`1<CodeActionOperation>> ComputeOperationsAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProvider : ValueType {
    private AnalyzerConfigOptions _options;
    private HostLanguageServices _languageServices;
    private CodeActionOptionsProvider _fallbackOptions;
    public string NewLine { get; }
    public AccessibilityModifiersRequired AccessibilityModifiersRequired { get; }
    private LineFormattingOptions FallbackLineFormattingOptions { get; }
    [NullableAttribute("2")]
private SyntaxFormattingOptions FallbackSyntaxFormattingOptions { get; }
    private CommonOptions FallbackCommonSyntaxFormattingOptions { get; }
    public CodeFixOptionsProvider(AnalyzerConfigOptions options, CodeActionOptionsProvider fallbackOptions, HostLanguageServices languageServices);
    public string get_NewLine();
    public LineFormattingOptions GetLineFormattingOptions();
    public SyntaxFormattingOptions GetFormattingOptions(ISyntaxFormatting formatting);
    public AccessibilityModifiersRequired get_AccessibilityModifiersRequired();
    private TValue GetOption(PerLanguageOption2`1<TValue> option, TValue defaultValue);
    private LineFormattingOptions get_FallbackLineFormattingOptions();
    [NullableContextAttribute("2")]
private SyntaxFormattingOptions get_FallbackSyntaxFormattingOptions();
    private CommonOptions get_FallbackCommonSyntaxFormattingOptions();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProviders : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeActions.CodeFixOptionsProviders/<GetCodeFixOptionsAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<CodeFixOptionsProvider> GetCodeFixOptionsAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CodeActions.ConflictAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeActions.CustomCodeActions : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeActions.DelegatingCodeActionOptionsProvider : AbstractCodeActionOptionsProvider {
    private Func`2<LanguageServices, CodeActionOptions> _delegate;
    public DelegatingCodeActionOptionsProvider(Func`2<LanguageServices, CodeActionOptions> delegate);
    public virtual CodeActionOptions GetOptions(LanguageServices languageService);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeActions.NavigationAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeActions.OpenDocumentOperation : CodeActionOperation {
    private DocumentId _documentId;
    private bool _activate;
    public DocumentId DocumentId { get; }
    public OpenDocumentOperation(DocumentId documentId, bool activateIfAlreadyOpen);
    public DocumentId get_DocumentId();
    public virtual void Apply(Workspace workspace, CancellationToken cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeActions.PreviewOperation : CodeActionOperation {
    public abstract virtual Task`1<object> GetPreviewAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CodeActions.RenameAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeActions.SuppressDiagnosticsAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CodeActions.WarningAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(string description);
    public static string GetDescription(SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService : object {
    public abstract virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    [NullableContextAttribute("0")]
protected abstract virtual ImmutableArray`1<TextSpan> GetSpansToAvoid(SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<CleanupAsync>d__2")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<CleanupAsync>d__3")]
public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<TextSpan> GetTextSpansFromAnnotation(SyntaxNode node, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations, CancellationToken cancellationToken);
    private static bool TryGetTextSpanFromAnnotation(SpanMarker previousTokenMarker, SpanMarker nextTokenMarker, SyntaxNode node, IEnumerable`1<SyntaxToken> previousTokens, IEnumerable`1<SyntaxToken> nextTokens, TextSpan& span);
    private static int GetPreviousTokenStartPosition(SpanMarkerType spanMarkerType, SyntaxToken previousToken);
    private static int GetNextTokenEndPosition(SpanMarkerType spanMarkerType, SyntaxToken nextToken);
    [NullableContextAttribute("0")]
private static ValueTuple`2<SyntaxNode, List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>>> AnnotateNodeForTextSpans(SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<TextSpan> GetNonOverlappingSpans(SyntaxNode root, ImmutableArray`1<TextSpan> spans, CancellationToken cancellationToken);
    private static void GetTokensAroundSpan(SyntaxNode root, TextSpan span, SyntaxToken& previousToken, SyntaxToken& startToken, SyntaxToken& endToken, SyntaxToken& nextToken);
    private static TextSpan GetSpanAlignedToTokens(SyntaxNode root, TextSpan span, SyntaxToken& startToken, SyntaxToken& endToken);
    private static SyntaxToken FindTokenOnRightOfPosition(SyntaxNode root, int position);
    private static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position);
    private static bool CleanupWholeNode(List`1<ValueTuple`2<SyntaxAnnotation, SyntaxAnnotation>> annotations);
    [NullableContextAttribute("0")]
private static bool CleanupWholeNode(TextSpan nodeSpan, ImmutableArray`1<TextSpan> spans);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<IterateAllCodeCleanupProvidersAsync>d__16")]
private Task`1<Document> IterateAllCodeCleanupProvidersAsync(Document originalDocument, Document annotatedDocument, CodeCleanupOptions options, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter, ImmutableArray`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private ImmutableArray`1<TextSpan> GetSpans(SyntaxNode root, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanerService/<IterateAllCodeCleanupProvidersAsync>d__18")]
private Task`1<SyntaxNode> IterateAllCodeCleanupProvidersAsync(SyntaxNode originalRoot, SyntaxNode annotatedRoot, SyntaxFormattingOptions options, Func`2<SyntaxNode, ImmutableArray`1<TextSpan>> spanGetter, SolutionServices services, ImmutableArray`1<ICodeCleanupProvider> codeCleaners, CancellationToken cancellationToken);
    private string GetCodeCleanerTypeName(ICodeCleanupProvider codeCleaner);
    private static SyntaxNode InjectAnnotations(SyntaxNode node, Dictionary`2<SyntaxToken, List`1<SyntaxAnnotation>> map);
    private static bool TryCreateTextSpan(int start, int end, TextSpan& span);
}
internal abstract class Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider : object {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<CodeCleanupOptions> GetCodeCleanupOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
private sealed virtual override ValueTask`1<CodeCleanupOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-Formatting-LineFormattingOptions>-GetOptionsAsync>d__2")]
private sealed virtual override ValueTask`1<LineFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.LineFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-Formatting-DocumentFormattingOptions>-GetOptionsAsync>d__3")]
private sealed virtual override ValueTask`1<DocumentFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-Formatting-SyntaxFormattingOptions>-GetOptionsAsync>d__4")]
private sealed virtual override ValueTask`1<SyntaxFormattingOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-Simplification-SimplifierOptions>-GetOptionsAsync>d__5")]
private sealed virtual override ValueTask`1<SimplifierOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Simplification.SimplifierOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.AbstractCodeCleanupOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-AddImport-AddImportPlacementOptions>-GetOptionsAsync>d__6")]
private sealed virtual override ValueTask`1<AddImportPlacementOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.AddImport.AddImportPlacementOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner : object {
    public static ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__1")]
public static Task`1<Document> CleanupAsync(Document document, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__2")]
public static Task`1<Document> CleanupAsync(Document document, SyntaxAnnotation annotation, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<Document> CleanupAsync(Document document, TextSpan span, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleaner/<CleanupAsync>d__4")]
public static Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, TextSpan span, SyntaxFormattingOptions options, SolutionServices services, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public static Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptions : object {
    [CompilerGeneratedAttribute]
private SyntaxFormattingOptions <FormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private SimplifierOptions <SimplifierOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions <AddImportOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentFormattingOptions <DocumentFormattingOptions>k__BackingField;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public SyntaxFormattingOptions FormattingOptions { get; public set; }
    [DataMemberAttribute]
public SimplifierOptions SimplifierOptions { get; public set; }
    [DataMemberAttribute]
public AddImportPlacementOptions AddImportOptions { get; public set; }
    [DataMemberAttribute]
public DocumentFormattingOptions DocumentFormattingOptions { get; public set; }
    public CodeCleanupOptions(SyntaxFormattingOptions FormattingOptions, SimplifierOptions SimplifierOptions);
    [CompilerGeneratedAttribute]
private CodeCleanupOptions(CodeCleanupOptions original);
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public SyntaxFormattingOptions get_FormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormattingOptions(SyntaxFormattingOptions value);
    [CompilerGeneratedAttribute]
public SimplifierOptions get_SimplifierOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SimplifierOptions(SimplifierOptions value);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions get_AddImportOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddImportOptions(AddImportPlacementOptions value);
    [CompilerGeneratedAttribute]
public DocumentFormattingOptions get_DocumentFormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentFormattingOptions(DocumentFormattingOptions value);
    public static CodeCleanupOptions GetDefault(LanguageServices languageServices);
    public OrganizeImportsOptions GetOrganizeImportsOptions();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(CodeCleanupOptions left, CodeCleanupOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(CodeCleanupOptions left, CodeCleanupOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeCleanupOptions other);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(SyntaxFormattingOptions& FormattingOptions, SimplifierOptions& SimplifierOptions);
}
internal interface Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProviders : object {
    [ExtensionAttribute]
public static CodeCleanupOptions GetCodeCleanupOptions(AnalyzerConfigOptions options, bool allowImportsInHiddenRegions, CodeCleanupOptions fallbackOptions, LanguageServices languageServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProviders/<GetCodeCleanupOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<CodeCleanupOptions> GetCodeCleanupOptionsAsync(Document document, CodeCleanupOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.CodeCleanupOptionsProviders/<GetCodeCleanupOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<CodeCleanupOptions> GetCodeCleanupOptionsAsync(Document document, CodeCleanupOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeCleanup.ICodeCleanerService {
    public abstract virtual ImmutableArray`1<ICodeCleanupProvider> GetDefaultProviders();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, ImmutableArray`1<ICodeCleanupProvider> providers, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.ExportCodeCleanupProvider : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public string Name { get; }
    public IEnumerable`1<string> Languages { get; }
    public ExportCodeCleanupProvider(string name, String[] languages);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Languages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<AbstractFormattingRule> _rules;
    public string Name { get; }
    public FormatCodeCleanupProvider(IEnumerable`1<AbstractFormattingRule> rules);
    public sealed virtual string get_Name();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeCleanup.Providers.FormatCodeCleanupProvider/<CleanupAsync>d__4")]
public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeCleanup.Providers.ICodeCleanupProvider {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeCleanup.Providers.PredefinedCodeCleanupProviderNames : object {
    public static string Simplification;
    public static string CaseCorrection;
    public static string AddMissingTokens;
    public static string NormalizeModifiersOrOperators;
    public static string RemoveUnnecessaryLineContinuation;
    public static string Format;
    public static string FixIncorrectTokens;
    public static string ReduceTokens;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeCleanup.Providers.SimplificationCodeCleanupProvider : object {
    public string Name { get; }
    public sealed virtual string get_Name();
    public sealed virtual Task`1<Document> CleanupAsync(Document document, ImmutableArray`1<TextSpan> spans, CodeCleanupOptions options, CancellationToken cancellationToken);
    public sealed virtual Task`1<SyntaxNode> CleanupAsync(SyntaxNode root, ImmutableArray`1<TextSpan> spans, SyntaxFormattingOptions options, SolutionServices services, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider : FixAllProvider {
    public static FixAllProvider Instance;
    private static BatchFixAllProvider();
    public virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<FixAllContextsAsync>d__4")]
private Task`1<Solution> FixAllContextsAsync(FixAllContext originalFixAllContext, ImmutableArray`1<FixAllContext> fixAllContexts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<FixSingleContextAsync>d__5")]
private static Task FixSingleContextAsync(FixAllContext fixAllContext, IProgressTracker progressTracker, Dictionary`2<DocumentId, TextChangeMerger> docIdToTextMerger);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<DetermineDiagnosticsAsync>d__6")]
private static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> DetermineDiagnosticsAsync(FixAllContext fixAllContext, IProgressTracker progressTracker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<AddDocumentChangesAsync>d__7")]
private static Task AddDocumentChangesAsync(FixAllContext fixAllContext, IProgressTracker progressTracker, Dictionary`2<DocumentId, TextChangeMerger> docIdToTextMerger, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentToDiagnostics);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<GetAllChangedDocumentsInDiagnosticsOrderAsync>d__8")]
private static Task`1<ImmutableArray`1<Document>> GetAllChangedDocumentsInDiagnosticsOrderAsync(FixAllContext fixAllContext, ImmutableArray`1<Diagnostic> orderedDiagnostics);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<MergeTextChangesAsync>d__9")]
private static Task MergeTextChangesAsync(FixAllContext fixAllContext, ImmutableArray`1<Document> allChangedDocumentsInDiagnosticsOrder, Dictionary`2<DocumentId, TextChangeMerger> docIdToTextMerger);
    private static Action`2<CodeAction, ImmutableArray`1<Diagnostic>> GetRegisterCodeFixAction(string codeActionEquivalenceKey, ArrayBuilder`1<CodeAction> codeActions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.BatchFixAllProvider/<ApplyChangesAsync>d__11")]
private static Task`1<Solution> ApplyChangesAsync(Solution currentSolution, ImmutableArray`1<ValueTuple`2<DocumentId, TextChangeMerger>> docIdsAndMerger, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.CodeFix : object {
    internal Project Project;
    internal CodeAction Action;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableArray`1<Diagnostic> Diagnostics;
    internal Diagnostic PrimaryDiagnostic { get; }
    internal CodeFix(Project project, CodeAction action, Diagnostic diagnostic);
    internal CodeFix(Project project, CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    internal Diagnostic get_PrimaryDiagnostic();
    internal DiagnosticData GetPrimaryDiagnosticData();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.CodeFixes.CodeFixContext : ValueType {
    private Document _document;
    private TextSpan _span;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Diagnostic> _diagnostics;
    private CancellationToken _cancellationToken;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`2<CodeAction, ImmutableArray`1<Diagnostic>> _registerCodeFix;
    internal CodeActionOptionsProvider Options;
    private bool _isBlocking;
    public Document Document { get; }
    public TextSpan Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Diagnostic> Diagnostics { get; }
    public CancellationToken CancellationToken { get; }
    [ObsoleteAttribute]
private bool Microsoft.CodeAnalysis.CodeFixes.ITypeScriptCodeFixContext.IsBlocking { get; }
    public CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    public CodeFixContext(Document document, Diagnostic diagnostic, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CancellationToken cancellationToken);
    internal CodeFixContext(Document document, TextSpan span, ImmutableArray`1<Diagnostic> diagnostics, Action`2<CodeAction, ImmutableArray`1<Diagnostic>> registerCodeFix, CodeActionOptionsProvider options, bool isBlocking, CancellationToken cancellationToken);
    public Document get_Document();
    public TextSpan get_Span();
    public ImmutableArray`1<Diagnostic> get_Diagnostics();
    public CancellationToken get_CancellationToken();
    private sealed virtual override bool Microsoft.CodeAnalysis.CodeFixes.ITypeScriptCodeFixContext.get_IsBlocking();
    public void RegisterCodeFix(CodeAction action, Diagnostic diagnostic);
    public void RegisterCodeFix(CodeAction action, IEnumerable`1<Diagnostic> diagnostics);
    public void RegisterCodeFix(CodeAction action, ImmutableArray`1<Diagnostic> diagnostics);
    private static ImmutableArray`1<Diagnostic> VerifyDiagnosticsArgument(ImmutableArray`1<Diagnostic> diagnostics, TextSpan span);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.CodeFixProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> FixableDiagnosticIds { get; }
    internal CodeActionRequestPriority RequestPriority { get; }
    public abstract virtual ImmutableArray`1<string> get_FixableDiagnosticIds();
    [NullableContextAttribute("1")]
public abstract virtual Task RegisterCodeFixesAsync(CodeFixContext context);
    [NullableContextAttribute("2")]
public virtual FixAllProvider GetFixAllProvider();
    internal CodeActionRequestPriority get_RequestPriority();
    private protected virtual CodeActionRequestPriority ComputeRequestPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider : FixAllProvider {
    [NullableAttribute("0")]
private ImmutableArray`1<FixAllScope> _supportedFixAllScopes;
    [NullableContextAttribute("0")]
protected DocumentBasedFixAllProvider(ImmutableArray`1<FixAllScope> supportedFixAllScopes);
    protected virtual string GetFixAllTitle(FixAllContext fixAllContext);
    protected abstract virtual Task`1<Document> FixAllAsync(FixAllContext fixAllContext, Document document, ImmutableArray`1<Diagnostic> diagnostics);
    public sealed virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public sealed virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    private Task`1<Solution> FixAllContextsHelperAsync(FixAllContext originalFixAllContext, ImmutableArray`1<FixAllContext> fixAllContexts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider/<DetermineDiagnosticsAndGetFixedDocumentsAsync>d__8")]
private Task`1<Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>>> DetermineDiagnosticsAndGetFixedDocumentsAsync(FixAllContext fixAllContext, IProgressTracker progressTracker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider/<DetermineDiagnosticsAsync>d__9")]
private static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> DetermineDiagnosticsAsync(FixAllContext fixAllContext, IProgressTracker progressTracker);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.DocumentBasedFixAllProvider/<GetFixedDocumentsAsync>d__10")]
private Task`1<Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>>> GetFixedDocumentsAsync(FixAllContext fixAllContext, IProgressTracker progressTracker, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> diagnostics);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeFixes.ExportCodeFixProviderAttribute : ExportAttribute {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeFixProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeFixes.FixAllContext : object {
    [CompilerGeneratedAttribute]
private FixAllState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgressTracker <ProgressTracker>k__BackingField;
    internal FixAllState State { get; }
    internal FixAllProvider FixAllProvider { get; }
    public Solution Solution { get; }
    public Project Project { get; }
    [NullableAttribute("2")]
public Document Document { get; }
    public CodeFixProvider CodeFixProvider { get; }
    public FixAllScope Scope { get; }
    public ImmutableHashSet`1<string> DiagnosticIds { get; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; }
    public CancellationToken CancellationToken { get; }
    internal IProgressTracker ProgressTracker { get; }
    private IFixAllState Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.State { get; }
    private IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.FixAllProvider { get; }
    private object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.Provider { get; }
    private IProgressTracker Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.ProgressTracker { get; }
    public FixAllContext(Document document, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public FixAllContext(Document document, Nullable`1<TextSpan> diagnosticSpan, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    public FixAllContext(Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CancellationToken cancellationToken);
    internal FixAllContext(FixAllState state, IProgressTracker progressTracker, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal FixAllState get_State();
    internal FixAllProvider get_FixAllProvider();
    public sealed virtual Solution get_Solution();
    public sealed virtual Project get_Project();
    [NullableContextAttribute("2")]
public sealed virtual Document get_Document();
    public CodeFixProvider get_CodeFixProvider();
    public sealed virtual FixAllScope get_Scope();
    public ImmutableHashSet`1<string> get_DiagnosticIds();
    [NullableContextAttribute("2")]
public sealed virtual string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal IProgressTracker get_ProgressTracker();
    private sealed virtual override IFixAllState Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_State();
    private sealed virtual override IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_FixAllProvider();
    private sealed virtual override object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_Provider();
    private sealed virtual override IProgressTracker Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_ProgressTracker();
    private sealed virtual override string Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.GetDefaultFixAllTitle();
    [NullableContextAttribute("0")]
private sealed virtual override IFixAllContext Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetDocumentDiagnosticsAsync>d__39")]
public Task`1<ImmutableArray`1<Diagnostic>> GetDocumentDiagnosticsAsync(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetFilteredDiagnosticsAsync>d__40")]
private static Task`1<ImmutableArray`1<Diagnostic>> GetFilteredDiagnosticsAsync(Task`1<IEnumerable`1<Diagnostic>> getDiagnosticsTask, ImmutableHashSet`1<string> diagnosticIds, Nullable`1<TextSpan> filterSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetDocumentSpanDiagnosticsAsync>d__41")]
internal Task`1<ImmutableArray`1<Diagnostic>> GetDocumentSpanDiagnosticsAsync(Document document, TextSpan filterSpan);
    public Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project);
    public Task`1<ImmutableArray`1<Diagnostic>> GetAllDiagnosticsAsync(Project project);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContext/<GetProjectDiagnosticsAsync>d__44")]
private Task`1<ImmutableArray`1<Diagnostic>> GetProjectDiagnosticsAsync(Project project, bool includeAllDocumentDiagnostics);
    public FixAllContext WithCancellationToken(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
internal FixAllContext With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
    internal Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync();
    internal Task`1<ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>>> GetProjectDiagnosticsToFixAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeFixes.FixAllContextExtensions : object {
    [ExtensionAttribute]
public static IProgressTracker GetProgressTracker(FixAllContext context);
    [ExtensionAttribute]
public static string GetDefaultFixAllTitle(FixAllContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixes.FixAllContextHelper : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContextHelper/<GetDocumentDiagnosticsToFixAsync>d__0")]
public static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync(FixAllContext fixAllContext);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContextHelper/<GetDocumentDiagnosticsToFixAsync>d__1")]
private static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> GetDocumentDiagnosticsToFixAsync(Solution solution, ImmutableArray`1<Diagnostic> diagnostics, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.FixAllContextHelper/<<GetDocumentDiagnosticsToFixAsync>g__GetSpanDiagnosticsAsync|0_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>>> <GetDocumentDiagnosticsToFixAsync>g__GetSpanDiagnosticsAsync|0_1(FixAllContext fixAllContext, IEnumerable`1<KeyValuePair`2<Document, ImmutableArray`1<TextSpan>>> documentsAndSpans);
}
public abstract class Microsoft.CodeAnalysis.CodeFixes.FixAllProvider : object {
    private protected static ImmutableArray`1<FixAllScope> DefaultSupportedFixAllScopes;
    private static FixAllProvider();
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<string> GetSupportedFixAllDiagnosticIds(CodeFixProvider originalCodeFixProvider);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [NullableContextAttribute("1")]
public static FixAllProvider Create(Func`4<FixAllContext, Document, ImmutableArray`1<Diagnostic>, Task`1<Document>> fixAllAsync);
    public static FixAllProvider Create(Func`4<FixAllContext, Document, ImmutableArray`1<Diagnostic>, Task`1<Document>> fixAllAsync, ImmutableArray`1<FixAllScope> supportedFixAllScopes);
    [NullableContextAttribute("1")]
private sealed virtual override Task`1<CodeAction> Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllProvider.GetFixAsync(IFixAllContext fixAllContext);
}
public enum Microsoft.CodeAnalysis.CodeFixes.FixAllScope : Enum {
    public int value__;
    public static FixAllScope Document;
    public static FixAllScope Project;
    public static FixAllScope Solution;
    public static FixAllScope Custom;
    public static FixAllScope ContainingMember;
    public static FixAllScope ContainingType;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CodeFixes.FixAllState : CommonFixAllState`3<CodeFixProvider, FixAllProvider, FixAllState> {
    [CompilerGeneratedAttribute]
private DiagnosticProvider <DiagnosticProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<string> <DiagnosticIds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <DiagnosticSpan>k__BackingField;
    public FixAllKind FixAllKind { get; }
    public DiagnosticProvider DiagnosticProvider { get; }
    public ImmutableHashSet`1<string> DiagnosticIds { get; }
    public Nullable`1<TextSpan> DiagnosticSpan { get; }
    internal bool IsFixMultiple { get; }
    internal FixAllState(FixAllProvider fixAllProvider, Nullable`1<TextSpan> diagnosticSpan, Document document, Project project, CodeFixProvider codeFixProvider, FixAllScope scope, string codeActionEquivalenceKey, IEnumerable`1<string> diagnosticIds, DiagnosticProvider fixAllDiagnosticProvider, CodeActionOptionsProvider codeActionOptionsProvider);
    public virtual FixAllKind get_FixAllKind();
    [CompilerGeneratedAttribute]
public DiagnosticProvider get_DiagnosticProvider();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<string> get_DiagnosticIds();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_DiagnosticSpan();
    internal bool get_IsFixMultiple();
    protected virtual FixAllState With(Document document, Project project, FixAllScope scope, string codeActionEquivalenceKey);
    internal static FixAllState Create(FixAllProvider fixAllProvider, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> diagnosticsToFix, CodeFixProvider codeFixProvider, string codeActionEquivalenceKey, CodeActionOptionsProvider codeActionOptionsProvider);
    internal static FixAllState Create(FixAllProvider fixAllProvider, ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> diagnosticsToFix, CodeFixProvider codeFixProvider, string codeActionEquivalenceKey, CodeActionOptionsProvider codeActionOptionsProvider);
    private static ImmutableHashSet`1<string> GetDiagnosticsIds(IEnumerable`1<ImmutableArray`1<Diagnostic>> diagnosticsCollection);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixes.IConfigurationFixProvider {
    public abstract virtual bool IsFixableDiagnostic(Diagnostic diagnostic);
    public abstract virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Document document, TextSpan span, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<CodeFix>> GetFixesAsync(Project project, IEnumerable`1<Diagnostic> diagnostics, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual FixAllProvider GetFixAllProvider();
}
[ObsoleteAttribute]
internal interface Microsoft.CodeAnalysis.CodeFixes.ITypeScriptCodeFixContext {
    public bool IsBlocking { get; }
    public abstract virtual bool get_IsBlocking();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeFixes.NoOpFixAllProvider : FixAllProvider {
    public static NoOpFixAllProvider Instance;
    private static NoOpFixAllProvider();
    public virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider : CodeFixProvider {
    [NullableAttribute("0")]
private static ImmutableArray`1<FixAllScope> s_defaultSupportedFixAllScopes;
    private bool _supportsFixAll;
    protected SyntaxEditorBasedCodeFixProvider(bool supportsFixAll);
    private static SyntaxEditorBasedCodeFixProvider();
    [NullableContextAttribute("2")]
public sealed virtual FixAllProvider GetFixAllProvider();
    protected void RegisterCodeFix(CodeFixContext context, string title, string equivalenceKey, Diagnostic diagnostic);
    protected void RegisterCodeFix(CodeFixContext context, string title, string equivalenceKey, CodeActionPriority priority, Diagnostic diagnostic);
    protected Func`2<CancellationToken, Task`1<Document>> GetDocumentUpdater(CodeFixContext context, Diagnostic diagnostic);
    private Task`1<Document> FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, CodeActionOptionsProvider options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider/<FixAllWithEditorAsync>d__8")]
internal static Task`1<Document> FixAllWithEditorAsync(Document document, Func`2<SyntaxEditor, Task> editAsync, CancellationToken cancellationToken);
    protected abstract virtual Task FixAllAsync(Document document, ImmutableArray`1<Diagnostic> diagnostics, SyntaxEditor editor, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, SemanticModel model, string equivalenceKey, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic, Document document, string equivalenceKey, CancellationToken cancellationToken);
    protected virtual bool IncludeDiagnosticDuringFixAll(Diagnostic diagnostic);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.SyntaxEditorBasedCodeFixProvider/<<GetFixAllProvider>b__3_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__3_0(FixAllContext fixAllContext, Document document, ImmutableArray`1<Diagnostic> diagnostics);
}
internal class Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger : object {
    [NullableAttribute("1")]
private Document _oldDocument;
    [NullableAttribute("1")]
private IDocumentTextDifferencingService _differenceService;
    [NullableAttribute("1")]
private SimpleIntervalTree`2<TextChange, IntervalIntrospector> _totalChangesIntervalTree;
    [NullableContextAttribute("1")]
public TextChangeMerger(Document document);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger/<TryMergeChangesAsync>d__5")]
public Task TryMergeChangesAsync(Document newDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger/<TryMergeChangesAsync>d__6")]
public Task TryMergeChangesAsync(ImmutableArray`1<Document> newDocuments, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixes.TextChangeMerger/<GetFinalMergedTextAsync>d__7")]
public Task`1<SourceText> GetFinalMergedTextAsync(CancellationToken cancellationToken);
    private static bool AllChangesCanBeApplied(SimpleIntervalTree`2<TextChange, IntervalIntrospector> cumulativeChanges, ImmutableArray`1<TextChange> currentChanges);
    private static bool AllChangesCanBeApplied(SimpleIntervalTree`2<TextChange, IntervalIntrospector> cumulativeChanges, ImmutableArray`1<TextChange> currentChanges, TemporaryArray`1& overlappingSpans, TemporaryArray`1& intersectingSpans);
    private static bool ChangeCanBeApplied(TextChange change, TemporaryArray`1& overlappingSpans, TemporaryArray`1& intersectingSpans);
    private static bool IsPureInsertion(TextChange change);
    private static bool PureInsertionChangeCanBeApplied(TextChange change, TemporaryArray`1& overlappingSpans, TemporaryArray`1& intersectingSpans);
    private static bool OverwriteChangeCanBeApplied(TextChange change, TemporaryArray`1& overlappingSpans, TemporaryArray`1& intersectingSpans);
    private static bool OverwriteChangeConflictsWithOverlappingSpans(TextChange change, TemporaryArray`1& overlappingSpans);
    private static bool OverwriteChangeConflictsWithIntersectingSpans(TextChange change, TemporaryArray`1& intersectingSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.CodeFixes.WellKnownFixAllProviders : object {
    public static FixAllProvider BatchFixer { get; }
    public static FixAllProvider get_BatchFixer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllSpanMappingService : object {
    protected abstract virtual Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<TextSpan>>> GetFixAllSpansIfWithinGlobalStatementAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<TextSpan>>> GetFixAllSpansAsync(Document document, TextSpan triggerSpan, FixAllScope fixAllScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllSpanMappingService/<GetFixAllSpansAsync>d__2")]
private Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<TextSpan>>> GetFixAllSpansAsync(Document document, TextSpan span, bool fixAllInContainingMember, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.AbstractFixAllSpanMappingService/<GetContainingMemberOrTypeDeclarationAsync>d__3")]
private static Task`1<SyntaxNode> GetContainingMemberOrTypeDeclarationAsync(Document document, bool fixAllInContainingMember, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.CommonFixAllState`3 : object {
    [CompilerGeneratedAttribute]
private int <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private TFixAllProvider <FixAllProvider>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <CodeActionEquivalenceKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TProvider <Provider>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private FixAllScope <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeActionOptionsProvider <CodeActionOptionsProvider>k__BackingField;
    public int CorrelationId { get; }
    public TFixAllProvider FixAllProvider { get; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; }
    public TProvider Provider { get; }
    [NullableAttribute("2")]
public Document Document { get; }
    public Project Project { get; }
    public Solution Solution { get; }
    public FixAllScope Scope { get; }
    public FixAllKind FixAllKind { get; }
    public CodeActionOptionsProvider CodeActionOptionsProvider { get; }
    private IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.FixAllProvider { get; }
    private object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.Provider { get; }
    protected CommonFixAllState`3(TFixAllProvider fixAllProvider, Document document, Project project, TProvider provider, CodeActionOptionsProvider optionsProvider, FixAllScope scope, string codeActionEquivalenceKey);
    [CompilerGeneratedAttribute]
public sealed virtual int get_CorrelationId();
    [CompilerGeneratedAttribute]
public TFixAllProvider get_FixAllProvider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public TProvider get_Provider();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual Document get_Document();
    [CompilerGeneratedAttribute]
public sealed virtual Project get_Project();
    public sealed virtual Solution get_Solution();
    [CompilerGeneratedAttribute]
public sealed virtual FixAllScope get_Scope();
    public abstract virtual FixAllKind get_FixAllKind();
    [CompilerGeneratedAttribute]
public sealed virtual CodeActionOptionsProvider get_CodeActionOptionsProvider();
    protected abstract virtual TFixAllState With(Document document, Project project, FixAllScope scope, string codeActionEquivalenceKey);
    [NullableContextAttribute("0")]
public TFixAllState With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
    private sealed virtual override IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.get_FixAllProvider();
    private sealed virtual override object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.get_Provider();
    [NullableContextAttribute("0")]
private sealed virtual override IFixAllState Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState.With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DefaultFixAllProviderHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DefaultFixAllProviderHelpers/<GetFixAsync>d__0`1")]
public static Task`1<CodeAction> GetFixAsync(string title, TFixAllContext fixAllContext, Func`3<TFixAllContext, ImmutableArray`1<TFixAllContext>, Task`1<Solution>> fixAllContextsAsync);
    private static Task`1<Solution> GetDocumentFixesAsync(TFixAllContext fixAllContext, Func`3<TFixAllContext, ImmutableArray`1<TFixAllContext>, Task`1<Solution>> fixAllContextsAsync);
    private static Task`1<Solution> GetProjectFixesAsync(TFixAllContext fixAllContext, Func`3<TFixAllContext, ImmutableArray`1<TFixAllContext>, Task`1<Solution>> fixAllContextsAsync);
    private static Task`1<Solution> GetSolutionFixesAsync(TFixAllContext fixAllContext, Func`3<TFixAllContext, ImmutableArray`1<TFixAllContext>, Task`1<Solution>> fixAllContextsAsync);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DocumentBasedFixAllProviderHelpers : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DocumentBasedFixAllProviderHelpers/<FixAllContextsAsync>d__0`1")]
public static Task`1<Solution> FixAllContextsAsync(TFixAllContext originalFixAllContext, ImmutableArray`1<TFixAllContext> fixAllContexts, IProgressTracker progressTracker, string progressTrackerDescription, Func`3<TFixAllContext, IProgressTracker, Task`1<Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>>>> getFixedDocumentsAsync);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DocumentBasedFixAllProviderHelpers/<FixSingleContextAsync>d__1`1")]
private static Task`1<Solution> FixSingleContextAsync(Solution currentSolution, TFixAllContext fixAllContext, IProgressTracker progressTracker, Func`3<TFixAllContext, IProgressTracker, Task`1<Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>>>> getFixedDocumentsAsync);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeFixesAndRefactorings.DocumentBasedFixAllProviderHelpers/<CleanupAndApplyChangesAsync>d__2")]
private static Task`1<Solution> CleanupAndApplyChangesAsync(IProgressTracker progressTracker, Solution currentSolution, Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>> docIdToNewRootOrText, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllHelper : object {
    [NullableContextAttribute("1")]
public static string GetDefaultFixAllTitle(FixAllScope fixAllScope, string title, Document triggerDocument, Project triggerProject);
}
internal enum Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllKind : Enum {
    public int value__;
    public static FixAllKind CodeFix;
    public static FixAllKind Refactoring;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllLogger : object {
    public static string CorrelationId;
    private static string CodeFixProvider;
    private static string CodeRefactoringProvider;
    private static string CodeActionEquivalenceKey;
    public static string FixAllScope;
    private static string LanguageName;
    private static string DocumentCount;
    private static string Result;
    private static string Completed;
    private static string TimedOut;
    private static string Cancelled;
    private static string AllChangesApplied;
    private static string SubsetOfChangesApplied;
    private static string DocumentsWithDiagnosticsToFix;
    private static string ProjectsWithDiagnosticsToFix;
    private static string TotalDiagnosticsToFix;
    private static string TotalFixesToMerge;
    public static void LogState(IFixAllState fixAllState, bool isInternalProvider);
    public static void LogComputationResult(FixAllKind fixAllKind, int correlationId, bool completed, bool timedOut);
    public static void LogPreviewChangesResult(FixAllKind fixAllKind, Nullable`1<int> correlationId, bool applied, bool allChangesApplied);
    public static void LogDiagnosticsStats(int correlationId, ImmutableDictionary`2<Document, ImmutableArray`1<Diagnostic>> documentsAndDiagnosticsToFixMap);
    public static void LogDiagnosticsStats(int correlationId, ImmutableDictionary`2<Project, ImmutableArray`1<Diagnostic>> projectsAndDiagnosticsToFixMap);
    public static void LogFixesToMergeStats(FunctionId functionId, int correlationId, int count);
    public static LogMessage CreateCorrelationLogMessage(int correlationId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeFixesAndRefactorings.FixAllProviderInfo : object {
    public IFixAllProvider FixAllProvider;
    [NullableAttribute("0")]
public ImmutableArray`1<FixAllScope> SupportedScopes;
    [NullableContextAttribute("0")]
private FixAllProviderInfo(IFixAllProvider fixAllProvider, ImmutableArray`1<FixAllScope> supportedScopes);
    public static FixAllProviderInfo Create(object provider);
    private static FixAllProviderInfo CreateWithCodeFixer(CodeFixProvider provider);
    private static FixAllProviderInfo CreateWithCodeRefactoring(CodeRefactoringProvider provider);
    private static FixAllProviderInfo CreateWithSuppressionFixer(IConfigurationFixProvider provider);
    public abstract virtual bool CanBeFixed(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext {
    public IFixAllState State { get; }
    public IFixAllProvider FixAllProvider { get; }
    public Solution Solution { get; }
    public Project Project { get; }
    [NullableAttribute("2")]
public Document Document { get; }
    public object Provider { get; }
    public FixAllScope Scope { get; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; }
    public CancellationToken CancellationToken { get; }
    public IProgressTracker ProgressTracker { get; }
    public abstract virtual IFixAllState get_State();
    public abstract virtual IFixAllProvider get_FixAllProvider();
    public abstract virtual Solution get_Solution();
    public abstract virtual Project get_Project();
    [NullableContextAttribute("2")]
public abstract virtual Document get_Document();
    public abstract virtual object get_Provider();
    public abstract virtual FixAllScope get_Scope();
    [NullableContextAttribute("2")]
public abstract virtual string get_CodeActionEquivalenceKey();
    public abstract virtual CancellationToken get_CancellationToken();
    public abstract virtual IProgressTracker get_ProgressTracker();
    public abstract virtual string GetDefaultFixAllTitle();
    [NullableContextAttribute("0")]
public abstract virtual IFixAllContext With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllProvider {
    public abstract virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public abstract virtual Task`1<CodeAction> GetFixAsync(IFixAllContext fixAllContext);
}
internal interface Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllSpanMappingService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableDictionary`2<Document, ImmutableArray`1<TextSpan>>> GetFixAllSpansAsync(Document document, TextSpan triggerSpan, FixAllScope fixAllScope, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllState {
    public int CorrelationId { get; }
    public IFixAllProvider FixAllProvider { get; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; }
    public FixAllScope Scope { get; }
    public FixAllKind FixAllKind { get; }
    [NullableAttribute("2")]
public Document Document { get; }
    public Project Project { get; }
    public Solution Solution { get; }
    public object Provider { get; }
    public CodeActionOptionsProvider CodeActionOptionsProvider { get; }
    public abstract virtual int get_CorrelationId();
    public abstract virtual IFixAllProvider get_FixAllProvider();
    [NullableContextAttribute("2")]
public abstract virtual string get_CodeActionEquivalenceKey();
    public abstract virtual FixAllScope get_Scope();
    public abstract virtual FixAllKind get_FixAllKind();
    [NullableContextAttribute("2")]
public abstract virtual Document get_Document();
    public abstract virtual Project get_Project();
    public abstract virtual Solution get_Solution();
    public abstract virtual object get_Provider();
    public abstract virtual CodeActionOptionsProvider get_CodeActionOptionsProvider();
    [NullableContextAttribute("0")]
public abstract virtual IFixAllState With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractCleanCodeGenerationOptionsProvider : AbstractCodeCleanupOptionsProvider {
    public abstract virtual ValueTask`1<CleanCodeGenerationOptions> GetCleanCodeGenerationOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCleanCodeGenerationOptionsProvider/<GetCodeCleanupOptionsAsync>d__1")]
public sealed virtual ValueTask`1<CodeCleanupOptions> GetCodeCleanupOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    private sealed virtual override ValueTask`1<CleanCodeGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCleanCodeGenerationOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-CodeGeneration-CodeAndImportGenerationOptions>-GetOptionsAsync>d__3")]
private sealed virtual override ValueTask`1<CodeAndImportGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCleanCodeGenerationOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-CodeGeneration-CodeGenerationOptions>-GetOptionsAsync>d__4")]
private sealed virtual override ValueTask`1<CodeGenerationOptions> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCleanCodeGenerationOptionsProvider/<Microsoft-CodeAnalysis-OptionsProvider<Microsoft-CodeAnalysis-Diagnostics-Analyzers-NamingStyles-NamingStylePreferences>-GetOptionsAsync>d__5")]
private sealed virtual override ValueTask`1<NamingStylePreferences> Microsoft.CodeAnalysis.OptionsProvider<Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences>.GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1 : object {
    private ISymbolDeclarationService _symbolDeclarationService;
    public CodeGenerationOptions DefaultOptions { get; }
    protected AbstractCodeGenerationService`1(ISymbolDeclarationService symbolDeclarationService);
    public abstract virtual CodeGenerationOptions get_DefaultOptions();
    public abstract virtual CodeGenerationOptions GetCodeGenerationOptions(AnalyzerConfigOptions info, CodeGenerationOptions fallbackOptions);
    public sealed virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    private static TNode WithAnnotations(TNode node, CodeGenerationContextInfo info);
    public sealed virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public sealed virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, TCodeGenerationContextInfo info, IList`1<bool> availableIndices, CancellationToken cancellationToken);
    protected abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<SyntaxNode> members);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destinationMember, IEnumerable`1<IParameterSymbol> parameters, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destinationMember, IEnumerable`1<SyntaxNode> statements, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual CodeGenerationDestination GetDestination(SyntaxNode node);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    protected static T Cast(object value);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    protected static void CheckDeclarationNode(SyntaxNode destination);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<GetEditAsync>d__56")]
private Task`1<Document> GetEditAsync(CodeGenerationSolutionContext context, INamespaceOrTypeSymbol destination, Func`5<SyntaxNode, TCodeGenerationContextInfo, IList`1<bool>, CancellationToken, SyntaxNode> declarationTransform, CancellationToken cancellationToken);
    protected TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToEndOfDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private TDeclarationSyntax AddMembersToAppropriateLocationInDestination(TDeclarationSyntax destination, IEnumerable`1<ISymbol> members, IList`1<bool> availableIndices, TCodeGenerationContextInfo info, CancellationToken cancellationToken);
    private SyntaxNode GetNewMember(TCodeGenerationContextInfo info, CodeGenerationDestination codeGenerationDestination, ISymbol member, CancellationToken cancellationToken);
    private TDeclarationNode UpdateDestination(IList`1<bool> availableIndices, TCodeGenerationContextInfo info, TDeclarationNode currentDestination, ISymbol member, CancellationToken cancellationToken);
    private static bool GeneratingEnum(IEnumerable`1<ISymbol> members);
    protected abstract virtual IComparer`1<SyntaxNode> GetMemberComparer();
    protected static TCodeGenerationContextInfo CreateContextInfoForMultipleMembers(TCodeGenerationContextInfo info);
    public virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddFieldAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddPropertyAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMethodAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddMembersAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public sealed virtual Task`1<Document> AddNamespaceOrTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    protected static void CheckLocation(SyntaxNode destinationMember, Location location);
    protected static void ComputePositionAndTriviaForRemoveAttributeList(SyntaxNode attributeList, Func`2<SyntaxTrivia, bool> isEndOfLineTrivia, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static void ComputePositionAndTriviaForRemoveAttributeFromAttributeList(SyntaxNode attributeToRemove, Func`2<SyntaxToken, bool> isComma, Int32& positionOfRemovedNode, IEnumerable`1& triviaOfRemovedNode);
    protected static T AppendTriviaAtPosition(T node, int position, SyntaxTriviaList trivia);
    protected static SyntaxTokenList GetUpdatedDeclarationAccessibilityModifiers(ArrayBuilder`1<SyntaxToken> newModifierTokens, SyntaxTokenList modifiersList, Func`2<SyntaxToken, bool> isAccessibilityModifier);
    protected abstract virtual IList`1<bool> GetAvailableInsertionIndices(SyntaxNode destination, CancellationToken cancellationToken);
    private IList`1<bool> GetAvailableInsertionIndices(TDeclarationNode destination, CancellationToken cancellationToken);
    public sealed virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    protected static SyntaxToken GetEndToken(SyntaxNode node);
    protected static TextSpan GetSpan(SyntaxNode node);
    public sealed virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken, IList`1& availableIndices, bool checkGeneratedCode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<FindMostRelevantNameSpaceOrTypeDeclarationAsync>d__86")]
public sealed virtual Task`1<SyntaxNode> FindMostRelevantNameSpaceOrTypeDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<FindMostRelevantDeclarationAsync>d__87")]
private Task`1<ValueTuple`2<SyntaxNode, IList`1<bool>>> FindMostRelevantDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.AbstractCodeGenerationService`1/<SelectFirstOrDefaultAsync>d__88")]
private static Task`1<SyntaxNode> SelectFirstOrDefaultAsync(IEnumerable`1<SyntaxReference> references, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.AbstractFlagsEnumGenerator : object {
    protected abstract virtual SyntaxGenerator GetSyntaxGenerator();
    protected abstract virtual SyntaxNode CreateExplicitlyCastedLiteralValue(INamedTypeSymbol enumType, SpecialType underlyingSpecialType, object constantValue);
    protected abstract virtual bool IsValidName(INamedTypeSymbol enumType, string name);
    public SyntaxNode CreateEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private static bool IsFlagsEnum(INamedTypeSymbol typeSymbol);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private SyntaxNode CreateFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues, List`1<ValueTuple`2<IFieldSymbol, ulong>> usedFieldsAndValues);
    private SyntaxNode CreateMemberAccessExpression(IFieldSymbol field, INamedTypeSymbol enumType, SpecialType underlyingSpecialType);
    [NullableContextAttribute("2")]
private static IFieldSymbol GetZeroField(List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private void GetSortedEnumFieldsAndValues(INamedTypeSymbol enumType, List`1<ValueTuple`2<IFieldSymbol, ulong>> allFieldsAndValues);
    private SyntaxNode CreateNonFlagsEnumConstantValue(INamedTypeSymbol enumType, object constantValue);
    private sealed virtual override int System.Collections.Generic.IComparer<(Microsoft.CodeAnalysis.IFieldSymbolfield,System.UInt64value)>.Compare(ValueTuple`2<IFieldSymbol, ulong> x, ValueTuple`2<IFieldSymbol, ulong> y);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <GenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeCleanupOptions <CleanupOptions>k__BackingField;
    [DataMemberAttribute]
public CodeGenerationOptions GenerationOptions { get; public set; }
    [DataMemberAttribute]
public CodeCleanupOptions CleanupOptions { get; public set; }
    public CodeAndImportGenerationOptions CodeAndImportGenerationOptions { get; }
    public CleanCodeGenerationOptions(CodeGenerationOptions GenerationOptions, CodeCleanupOptions CleanupOptions);
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_GenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public CodeCleanupOptions get_CleanupOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanupOptions(CodeCleanupOptions value);
    public static CleanCodeGenerationOptions GetDefault(LanguageServices languageServices);
    public CodeAndImportGenerationOptions get_CodeAndImportGenerationOptions();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CleanCodeGenerationOptions left, CleanCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CleanCodeGenerationOptions left, CleanCodeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CleanCodeGenerationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CodeGenerationOptions& GenerationOptions, CodeCleanupOptions& CleanupOptions);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptionsProvider {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptionsProviders : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptionsProviders/<GetCleanCodeGenerationOptionsAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<CleanCodeGenerationOptions> GetCleanCodeGenerationOptionsAsync(Document document, CleanCodeGenerationOptions fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.CleanCodeGenerationOptionsProviders/<GetCleanCodeGenerationOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<CleanCodeGenerationOptions> GetCleanCodeGenerationOptionsAsync(Document document, CleanCodeGenerationOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <GenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions <AddImportOptions>k__BackingField;
    [DataMemberAttribute]
public CodeGenerationOptions GenerationOptions { get; public set; }
    [DataMemberAttribute]
public AddImportPlacementOptions AddImportOptions { get; public set; }
    public CodeAndImportGenerationOptions(CodeGenerationOptions GenerationOptions, AddImportPlacementOptions AddImportOptions);
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_GenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_GenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions get_AddImportOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddImportOptions(AddImportPlacementOptions value);
    internal static CodeAndImportGenerationOptions GetDefault(LanguageServices languageServices);
    internal CodeAndImportGenerationOptionsProvider CreateProvider();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CodeAndImportGenerationOptions left, CodeAndImportGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CodeAndImportGenerationOptions left, CodeAndImportGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeAndImportGenerationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CodeGenerationOptions& GenerationOptions, AddImportPlacementOptions& AddImportOptions);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CodeAndImportGenerationOptionsProvider {
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractMethodSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private IMethodSymbol <OriginalDefinition>k__BackingField;
    private ImmutableArray`1<AttributeData> _returnTypeAttributes;
    public IMethodSymbol OriginalDefinition { get; protected set; }
    public int Arity { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public bool IsPartialDefinition { get; }
    public NullableAnnotation ReceiverNullableAnnotation { get; }
    public NullableAnnotation ReturnNullableAnnotation { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ITypeSymbol ReceiverType { get; }
    public MethodKind MethodKind { get; }
    public SymbolKind Kind { get; }
    public bool IsGenericMethod { get; }
    public bool IsExtensionMethod { get; }
    public bool IsAsync { get; }
    public bool IsVararg { get; }
    public bool IsCheckedBuiltin { get; }
    public ISymbol ContainingSymbol { get; }
    public bool HidesBaseMethodsByName { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> ReturnTypeCustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public INamedTypeSymbol AssociatedAnonymousDelegate { get; }
    public bool IsConditional { get; }
    public SignatureCallingConvention CallingConvention { get; }
    public ImmutableArray`1<INamedTypeSymbol> UnmanagedCallingConventionTypes { get; }
    protected CodeGenerationAbstractMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(IMethodSymbol value);
    public virtual ImmutableArray`1<AttributeData> GetReturnTypeAttributes();
    public abstract virtual int get_Arity();
    public abstract virtual MethodImplAttributes get_MethodImplementationFlags();
    public abstract virtual bool get_ReturnsVoid();
    public abstract virtual bool get_ReturnsByRef();
    public abstract virtual bool get_ReturnsByRefReadonly();
    public abstract virtual RefKind get_RefKind();
    public abstract virtual ITypeSymbol get_ReturnType();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public abstract virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public abstract virtual IMethodSymbol get_ConstructedFrom();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual bool get_IsInitOnly();
    public abstract virtual IMethodSymbol get_OverriddenMethod();
    public abstract virtual IMethodSymbol get_ReducedFrom();
    public abstract virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public abstract virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public abstract virtual IMethodSymbol get_PartialDefinitionPart();
    public abstract virtual IMethodSymbol get_PartialImplementationPart();
    public abstract virtual bool get_IsPartialDefinition();
    public sealed virtual NullableAnnotation get_ReceiverNullableAnnotation();
    public sealed virtual NullableAnnotation get_ReturnNullableAnnotation();
    public sealed virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual ITypeSymbol get_ReceiverType();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual MethodKind get_MethodKind();
    public virtual SymbolKind get_Kind();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsExtensionMethod();
    public virtual bool get_IsAsync();
    public virtual bool get_IsVararg();
    public sealed virtual bool get_IsCheckedBuiltin();
    public virtual ISymbol get_ContainingSymbol();
    public virtual bool get_HidesBaseMethodsByName();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public virtual ImmutableArray`1<CustomModifier> get_ReturnTypeCustomModifiers();
    public virtual ISymbol get_AssociatedSymbol();
    public sealed virtual INamedTypeSymbol get_AssociatedAnonymousDelegate();
    public sealed virtual bool get_IsConditional();
    public sealed virtual SignatureCallingConvention get_CallingConvention();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_UnmanagedCallingConventionTypes();
    public sealed virtual IMethodSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual IMethodSymbol Construct(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<NullableAnnotation> typeArgumentNullableAnnotations);
    public sealed virtual DllImportData GetDllImportData();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAbstractNamedTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <OriginalDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IFieldSymbol> <TupleElements>k__BackingField;
    internal ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> TypeMembers;
    [CompilerGeneratedAttribute]
private ISymbol <AssociatedSymbol>k__BackingField;
    public INamedTypeSymbol OriginalDefinition { get; protected set; }
    public ImmutableArray`1<IFieldSymbol> TupleElements { get; protected set; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    private INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public string MetadataName { get; }
    public ISymbol AssociatedSymbol { get; internal set; }
    public bool MightContainExtensionMethods { get; }
    public bool IsComImport { get; }
    public bool IsUnmanagedType { get; }
    public bool IsRefLikeType { get; }
    public INamedTypeSymbol NativeIntegerUnderlyingType { get; }
    public INamedTypeSymbol TupleUnderlyingType { get; }
    public bool IsSerializable { get; }
    public bool IsFileLocal { get; }
    protected CodeGenerationAbstractNamedTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, NullableAnnotation nullableAnnotation, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_OriginalDefinition();
    [CompilerGeneratedAttribute]
protected void set_OriginalDefinition(INamedTypeSymbol value);
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IFieldSymbol> get_TupleElements();
    [CompilerGeneratedAttribute]
protected void set_TupleElements(ImmutableArray`1<IFieldSymbol> value);
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual INamedTypeSymbol Construct(ITypeSymbol[] typeArguments);
    public sealed virtual INamedTypeSymbol Construct(ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<NullableAnnotation> typeArgumentNullableAnnotations);
    public abstract virtual int get_Arity();
    public abstract virtual bool get_IsGenericType();
    public abstract virtual bool get_IsUnboundGenericType();
    public abstract virtual bool get_IsScriptClass();
    public abstract virtual bool get_IsImplicitClass();
    public abstract virtual IEnumerable`1<string> get_MemberNames();
    public abstract virtual IMethodSymbol get_DelegateInvokeMethod();
    public abstract virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected abstract virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    private sealed virtual override INamedTypeSymbol Microsoft.CodeAnalysis.INamedTypeSymbol.get_ConstructedFrom();
    public abstract virtual INamedTypeSymbol ConstructUnboundGenericType();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public abstract virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public abstract virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public abstract virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public sealed virtual ImmutableArray`1<CustomModifier> GetTypeArgumentCustomModifiers(int ordinal);
    public abstract virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual string get_MetadataName();
    [CompilerGeneratedAttribute]
public sealed virtual ISymbol get_AssociatedSymbol();
    [CompilerGeneratedAttribute]
internal void set_AssociatedSymbol(ISymbol value);
    public sealed virtual bool get_MightContainExtensionMethods();
    public sealed virtual bool get_IsComImport();
    public sealed virtual bool get_IsUnmanagedType();
    public sealed virtual bool get_IsRefLikeType();
    public sealed virtual INamedTypeSymbol get_NativeIntegerUnderlyingType();
    public sealed virtual INamedTypeSymbol get_TupleUnderlyingType();
    public sealed virtual bool get_IsSerializable();
    public sealed virtual bool get_IsFileLocal();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationArrayTypeSymbol : CodeGenerationTypeSymbol {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol ElementType { get; }
    public int Rank { get; }
    public bool IsSZArray { get; }
    public ImmutableArray`1<int> Sizes { get; }
    public ImmutableArray`1<int> LowerBounds { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public NullableAnnotation ElementNullableAnnotation { get; }
    [NullableContextAttribute("1")]
public CodeGenerationArrayTypeSymbol(ITypeSymbol elementType, int rank, NullableAnnotation nullableAnnotation);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_ElementType();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Rank();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual ImmutableArray`1<int> get_Sizes();
    public sealed virtual ImmutableArray`1<int> get_LowerBounds();
    [NullableContextAttribute("1")]
protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    [NullableContextAttribute("1")]
public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    [NullableContextAttribute("1")]
public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual NullableAnnotation get_ElementNullableAnnotation();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IArrayTypeSymbol other);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationAttributeData : AttributeData {
    private INamedTypeSymbol _attributeClass;
    private ImmutableArray`1<TypedConstant> _constructorArguments;
    private ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> _namedArguments;
    protected INamedTypeSymbol CommonAttributeClass { get; }
    protected IMethodSymbol CommonAttributeConstructor { get; }
    protected ImmutableArray`1<TypedConstant> CommonConstructorArguments { get; }
    protected ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> CommonNamedArguments { get; }
    protected SyntaxReference CommonApplicationSyntaxReference { get; }
    public CodeGenerationAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    protected virtual INamedTypeSymbol get_CommonAttributeClass();
    protected virtual IMethodSymbol get_CommonAttributeConstructor();
    protected virtual ImmutableArray`1<TypedConstant> get_CommonConstructorArguments();
    protected virtual ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> get_CommonNamedArguments();
    protected virtual SyntaxReference get_CommonApplicationSyntaxReference();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedMethodSymbol : CodeGenerationAbstractMethodSymbol {
    private CodeGenerationAbstractMethodSymbol _constructedFrom;
    private ImmutableArray`1<ITypeSymbol> _typeArguments;
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRefReadonly { get; }
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public bool IsPartialDefinition { get; }
    public CodeGenerationConstructedMethodSymbol(CodeGenerationAbstractMethodSymbol constructedFrom, ImmutableArray`1<ITypeSymbol> typeArguments);
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual RefKind get_RefKind();
    public virtual bool get_ReturnsByRefReadonly();
    public virtual ITypeSymbol get_ReturnType();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsInitOnly();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual bool get_IsPartialDefinition();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructedNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private CodeGenerationNamedTypeSymbol _constructedFrom;
    private ImmutableArray`1<ITypeSymbol> _typeArguments;
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public TypeKind TypeKind { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public CodeGenerationConstructedNamedTypeSymbol(CodeGenerationNamedTypeSymbol constructedFrom, ImmutableArray`1<ITypeSymbol> typeArguments, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers);
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    public virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual TypeKind get_TypeKind();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationConstructorInfo> s_constructorToInfoMap;
    private bool _isPrimaryConstructor;
    private bool _isUnsafe;
    private string _typeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _baseConstructorArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _thisConstructorArguments;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationConstructorInfo(bool isPrimaryConstructor, bool isUnsafe, string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo();
    public static void Attach(IMethodSymbol constructor, bool isPrimaryConstructor, bool isUnsafe, string typeName, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments);
    private static CodeGenerationConstructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(IMethodSymbol constructor);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol constructor);
    public static string GetTypeName(IMethodSymbol constructor);
    public static bool GetIsUnsafe(IMethodSymbol constructor);
    public static bool GetIsPrimaryConstructor(IMethodSymbol constructor);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetThisConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetBaseConstructorArgumentsOpt(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationConstructorInfo info);
    private static string GetTypeName(CodeGenerationConstructorInfo info, IMethodSymbol constructor);
    [NullableContextAttribute("2")]
private static bool GetIsUnsafe(CodeGenerationConstructorInfo info);
    [NullableContextAttribute("2")]
private static bool GetIsPrimaryConstructor(CodeGenerationConstructorInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConstructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConstructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ImmutableArray`1<IParameterSymbol> parameters);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContext : object {
    [NullableAttribute("1")]
public static CodeGenerationContext Default;
    [CompilerGeneratedAttribute]
private Location <ContextLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <AfterThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <BeforeThisLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddImports>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<INamespaceSymbol> <AdditionalImports>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeNestedNamespaces>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDefaultAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateMethodBodies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateDocumentationComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoInsertionLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SortMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReuseSyntax>k__BackingField;
    public Location ContextLocation { get; }
    public Location AfterThisLocation { get; }
    public Location BeforeThisLocation { get; }
    public bool AddImports { get; }
    [NullableAttribute("1")]
public IEnumerable`1<INamespaceSymbol> AdditionalImports { get; }
    public bool GenerateMembers { get; }
    public bool MergeNestedNamespaces { get; }
    public bool MergeAttributes { get; }
    public bool GenerateDefaultAccessibility { get; }
    public bool GenerateMethodBodies { get; }
    public bool GenerateDocumentationComments { get; }
    public bool AutoInsertionLocation { get; }
    public bool SortMembers { get; }
    public bool ReuseSyntax { get; }
    internal Location BestLocation { get; }
    public CodeGenerationContext(Location contextLocation, Location afterThisLocation, Location beforeThisLocation, bool addImports, IEnumerable`1<INamespaceSymbol> additionalImports, bool generateMembers, bool mergeNestedNamespaces, bool mergeAttributes, bool generateDefaultAccessibility, bool generateMethodBodies, bool generateDocumentationComments, bool autoInsertionLocation, bool sortMembers, bool reuseSyntax);
    private static CodeGenerationContext();
    [CompilerGeneratedAttribute]
public Location get_ContextLocation();
    [CompilerGeneratedAttribute]
public Location get_AfterThisLocation();
    [CompilerGeneratedAttribute]
public Location get_BeforeThisLocation();
    [CompilerGeneratedAttribute]
public bool get_AddImports();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public IEnumerable`1<INamespaceSymbol> get_AdditionalImports();
    [CompilerGeneratedAttribute]
public bool get_GenerateMembers();
    [CompilerGeneratedAttribute]
public bool get_MergeNestedNamespaces();
    [CompilerGeneratedAttribute]
public bool get_MergeAttributes();
    [CompilerGeneratedAttribute]
public bool get_GenerateDefaultAccessibility();
    [CompilerGeneratedAttribute]
public bool get_GenerateMethodBodies();
    [CompilerGeneratedAttribute]
public bool get_GenerateDocumentationComments();
    [CompilerGeneratedAttribute]
public bool get_AutoInsertionLocation();
    [CompilerGeneratedAttribute]
public bool get_SortMembers();
    [CompilerGeneratedAttribute]
public bool get_ReuseSyntax();
    [NullableContextAttribute("1")]
private static void CheckLocation(Location location, string name);
    internal Location get_BestLocation();
    [NullableContextAttribute("0")]
public CodeGenerationContext With(Optional`1<Location> contextLocation, Optional`1<Location> afterThisLocation, Optional`1<Location> beforeThisLocation, Optional`1<bool> addImports, Optional`1<IEnumerable`1<INamespaceSymbol>> additionalImports, Optional`1<bool> generateMembers, Optional`1<bool> mergeNestedNamespaces, Optional`1<bool> mergeAttributes, Optional`1<bool> generateDefaultAccessibility, Optional`1<bool> generateMethodBodies, Optional`1<bool> generateDocumentationComments, Optional`1<bool> autoInsertionLocation, Optional`1<bool> sortMembers, Optional`1<bool> reuseSyntax);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationContextInfo : object {
    public CodeGenerationContext Context;
    public CodeGenerationOptions Options { get; }
    protected CodeGenerationOptions OptionsImpl { get; }
    protected CodeGenerationContextInfo(CodeGenerationContext context);
    public CodeGenerationContextInfo WithContext(CodeGenerationContext value);
    public CodeGenerationOptions get_Options();
    protected abstract virtual CodeGenerationOptions get_OptionsImpl();
    protected abstract virtual CodeGenerationContextInfo WithContextImpl(CodeGenerationContext value);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationConversionSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationConversionSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, bool isImplicit, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public virtual MethodKind get_MethodKind();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestination : Enum {
    public int value__;
    public static CodeGenerationDestination Unspecified;
    public static CodeGenerationDestination CompilationUnit;
    public static CodeGenerationDestination Namespace;
    public static CodeGenerationDestination ClassType;
    public static CodeGenerationDestination EnumType;
    public static CodeGenerationDestination InterfaceType;
    public static CodeGenerationDestination ModuleType;
    public static CodeGenerationDestination StructType;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationDestructorInfo> s_destructorToInfoMap;
    private string _typeName;
    private ImmutableArray`1<SyntaxNode> _statements;
    private CodeGenerationDestructorInfo(string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo();
    public static void Attach(IMethodSymbol destructor, string typeName, ImmutableArray`1<SyntaxNode> statements);
    private static CodeGenerationDestructorInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol destructor);
    public static string GetTypeName(IMethodSymbol destructor);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationDestructorInfo info);
    private static string GetTypeName(CodeGenerationDestructorInfo info, IMethodSymbol constructor);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationDestructorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationDestructorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes);
    public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventInfo : object {
    private static ConditionalWeakTable`2<IEventSymbol, CodeGenerationEventInfo> s_eventToInfoMap;
    private bool _isUnsafe;
    private CodeGenerationEventInfo(bool isUnsafe);
    private static CodeGenerationEventInfo();
    public static void Attach(IEventSymbol event, bool isUnsafe);
    private static CodeGenerationEventInfo GetInfo(IEventSymbol event);
    public static bool GetIsUnsafe(IEventSymbol event);
    private static bool GetIsUnsafe(CodeGenerationEventInfo info);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationEventSymbol : CodeGenerationSymbol {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IEventSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <AddMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RemoveMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <RaiseMethod>k__BackingField;
    [NullableAttribute("1")]
public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IEventSymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol AddMethod { get; }
    public IMethodSymbol RemoveMethod { get; }
    public IMethodSymbol RaiseMethod { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("1")]
public IEventSymbol OriginalDefinition { get; }
    public bool IsWindowsRuntimeEvent { get; }
    public IEventSymbol OverriddenEvent { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationEventSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IEventSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_AddMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RemoveMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_RaiseMethod();
    [NullableContextAttribute("1")]
protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    [NullableContextAttribute("1")]
public virtual void Accept(SymbolVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    [NullableContextAttribute("1")]
public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    [NullableContextAttribute("1")]
public sealed virtual IEventSymbol get_OriginalDefinition();
    public sealed virtual bool get_IsWindowsRuntimeEvent();
    public sealed virtual IEventSymbol get_OverriddenEvent();
    public static ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldInfo : object {
    private static ConditionalWeakTable`2<IFieldSymbol, CodeGenerationFieldInfo> s_fieldToInfoMap;
    private bool _isUnsafe;
    private bool _isWithEvents;
    private SyntaxNode _initializer;
    private CodeGenerationFieldInfo(bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo();
    public static void Attach(IFieldSymbol field, bool isUnsafe, bool isWithEvents, SyntaxNode initializer);
    private static CodeGenerationFieldInfo GetInfo(IFieldSymbol field);
    private static bool GetIsUnsafe(CodeGenerationFieldInfo info);
    public static bool GetIsUnsafe(IFieldSymbol field);
    private static bool GetIsWithEvents(CodeGenerationFieldInfo info);
    public static bool GetIsWithEvents(IFieldSymbol field);
    private static SyntaxNode GetInitializer(CodeGenerationFieldInfo info);
    public static SyntaxNode GetInitializer(IFieldSymbol field);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationFieldSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ConstantValue>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstantValue>k__BackingField;
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public object ConstantValue { get; }
    public bool HasConstantValue { get; }
    public IFieldSymbol OriginalDefinition { get; }
    public IFieldSymbol CorrespondingTupleField { get; }
    public SymbolKind Kind { get; }
    public bool IsConst { get; }
    public bool IsReadOnly { get; }
    public bool IsVolatile { get; }
    public bool IsRequired { get; }
    public bool IsFixedSizeBuffer { get; }
    public int FixedSize { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ISymbol AssociatedSymbol { get; }
    public bool IsExplicitlyNamedTupleElement { get; }
    public CodeGenerationFieldSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ConstantValue();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstantValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IFieldSymbol get_OriginalDefinition();
    public sealed virtual IFieldSymbol get_CorrespondingTupleField();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsConst();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsVolatile();
    public sealed virtual bool get_IsRequired();
    public sealed virtual bool get_IsFixedSizeBuffer();
    public sealed virtual int get_FixedSize();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ISymbol get_AssociatedSymbol();
    public sealed virtual bool get_IsExplicitlyNamedTupleElement();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationHelpers : object {
    public static SyntaxNode GenerateThrowStatement(SyntaxGenerator factory, SemanticDocument document, string exceptionMetadataName);
    public static TSyntaxNode AddAnnotationsTo(ISymbol symbol, TSyntaxNode syntax);
    public static TSyntaxNode AddFormatterAndCodeGeneratorAnnotationsTo(TSyntaxNode node);
    public static void GetNameAndInnermostNamespace(INamespaceSymbol namespace, CodeGenerationContextInfo info, String& name, INamespaceSymbol& innermostNamespace);
    [NullableContextAttribute("2")]
public static bool IsSpecialType(ITypeSymbol type, SpecialType specialType);
    [NullableContextAttribute("2")]
public static int GetPreferredIndex(int index, IList`1<bool> availableIndices, bool forward);
    public static bool TryGetDocumentationComment(ISymbol symbol, string commentToken, String& comment, CancellationToken cancellationToken);
    public static bool TypesMatch(ITypeSymbol type, object value);
    public static IEnumerable`1<ISymbol> GetMembers(INamedTypeSymbol namedType);
    public static T RemoveLeadingDirectiveTrivia(T node);
    public static T GetReuseableSyntaxNodeForAttribute(AttributeData attribute, CodeGenerationContextInfo info);
    public static int GetInsertionIndex(SyntaxList`1<TDeclaration> declarationList, TDeclaration declaration, CodeGenerationContextInfo info, IList`1<bool> availableIndices, IComparer`1<TDeclaration> comparerWithoutNameCheck, IComparer`1<TDeclaration> comparerWithNameCheck, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> after, Func`2<SyntaxList`1<TDeclaration>, TDeclaration> before);
    public static Nullable`1<int> TryGetDesiredIndexIfGrouped(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
    private static Nullable`1<int> TryGetDesiredIndexIfGroupedWorker(SyntaxList`1<TDeclarationSyntax> declarationList, TDeclarationSyntax declaration, IList`1<bool> availableIndices, IComparer`1<TDeclarationSyntax> comparerWithoutNameCheck, IComparer`1<TDeclarationSyntax> comparerWithNameCheck);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodInfo : object {
    private static ConditionalWeakTable`2<IMethodSymbol, CodeGenerationMethodInfo> s_methodToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private bool _isPartial;
    private bool _isAsync;
    private ImmutableArray`1<SyntaxNode> _statements;
    private ImmutableArray`1<SyntaxNode> _handlesExpressions;
    private CodeGenerationMethodInfo(bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo();
    public static void Attach(IMethodSymbol method, bool isNew, bool isUnsafe, bool isPartial, bool isAsync, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions);
    private static CodeGenerationMethodInfo GetInfo(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetStatements(IMethodSymbol method);
    public static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(IMethodSymbol method);
    public static bool GetIsNew(IMethodSymbol method);
    public static bool GetIsUnsafe(IMethodSymbol method);
    public static bool GetIsPartial(IMethodSymbol method);
    public static bool GetIsAsyncMethod(IMethodSymbol method);
    private static ImmutableArray`1<SyntaxNode> GetStatements(CodeGenerationMethodInfo info);
    private static ImmutableArray`1<SyntaxNode> GetHandlesExpressions(CodeGenerationMethodInfo info);
    private static bool GetIsNew(CodeGenerationMethodInfo info);
    private static bool GetIsUnsafe(CodeGenerationMethodInfo info);
    private static bool GetIsPartial(CodeGenerationMethodInfo info);
    private static bool GetIsAsyncMethod(CodeGenerationMethodInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationMethodSymbol : CodeGenerationAbstractMethodSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeParameterSymbol> <TypeParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IMethodSymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodKind <MethodKind>k__BackingField;
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInitOnly>k__BackingField;
    public ITypeSymbol ReturnType { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IMethodSymbol> ExplicitInterfaceImplementations { get; }
    public MethodKind MethodKind { get; }
    public int Arity { get; }
    public bool ReturnsVoid { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public RefKind RefKind { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public IMethodSymbol ConstructedFrom { get; }
    public bool IsReadOnly { get; }
    public bool IsInitOnly { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public IMethodSymbol OverriddenMethod { get; }
    public IMethodSymbol ReducedFrom { get; }
    public IMethodSymbol PartialImplementationPart { get; }
    public IMethodSymbol PartialDefinitionPart { get; }
    public bool IsPartialDefinition { get; }
    public CodeGenerationMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml, MethodKind methodKind, bool isInitOnly);
    [CompilerGeneratedAttribute]
public virtual ITypeSymbol get_ReturnType();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public virtual ImmutableArray`1<IMethodSymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public virtual MethodKind get_MethodKind();
    protected virtual CodeGenerationSymbol Clone();
    public virtual int get_Arity();
    public virtual bool get_ReturnsVoid();
    public virtual bool get_ReturnsByRef();
    public virtual bool get_ReturnsByRefReadonly();
    [CompilerGeneratedAttribute]
public virtual RefKind get_RefKind();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual IMethodSymbol get_ConstructedFrom();
    public virtual bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public virtual bool get_IsInitOnly();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual IMethodSymbol get_OverriddenMethod();
    public virtual IMethodSymbol get_ReducedFrom();
    public virtual ITypeSymbol GetTypeInferredDuringReduction(ITypeParameterSymbol reducedFromTypeParameter);
    public virtual IMethodSymbol ReduceExtensionMethod(ITypeSymbol receiverType);
    public virtual IMethodSymbol get_PartialImplementationPart();
    public virtual IMethodSymbol get_PartialDefinitionPart();
    public virtual bool get_IsPartialDefinition();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamedTypeSymbol : CodeGenerationAbstractNamedTypeSymbol {
    private ImmutableArray`1<ITypeParameterSymbol> _typeParameters;
    private ImmutableArray`1<INamedTypeSymbol> _interfaces;
    private ImmutableArray`1<ISymbol> _members;
    [CompilerGeneratedAttribute]
private bool <IsRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeKind <TypeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <EnumUnderlyingType>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <BaseType>k__BackingField;
    public bool IsRecord { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    public int Arity { get; }
    public bool IsGenericType { get; }
    public bool IsUnboundGenericType { get; }
    public bool IsScriptClass { get; }
    public bool IsImplicitClass { get; }
    public IEnumerable`1<string> MemberNames { get; }
    public IMethodSymbol DelegateInvokeMethod { get; }
    public INamedTypeSymbol EnumUnderlyingType { get; }
    protected CodeGenerationNamedTypeSymbol ConstructedFrom { get; }
    public static ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    public ImmutableArray`1<ITypeSymbol> TypeArguments { get; }
    public ImmutableArray`1<NullableAnnotation> TypeArgumentNullableAnnotations { get; }
    public ImmutableArray`1<ITypeParameterSymbol> TypeParameters { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<IMethodSymbol> InstanceConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> StaticConstructors { get; }
    public ImmutableArray`1<IMethodSymbol> Constructors { get; }
    public CodeGenerationNamedTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, bool isRecord, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, NullableAnnotation nullableAnnotation, ImmutableArray`1<ISymbol> members, ImmutableArray`1<CodeGenerationAbstractNamedTypeSymbol> typeMembers, INamedTypeSymbol enumUnderlyingType);
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
public virtual bool get_IsRecord();
    [CompilerGeneratedAttribute]
public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual int get_Arity();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsUnboundGenericType();
    public virtual bool get_IsScriptClass();
    public virtual bool get_IsImplicitClass();
    public virtual IEnumerable`1<string> get_MemberNames();
    public virtual IMethodSymbol get_DelegateInvokeMethod();
    [CompilerGeneratedAttribute]
public virtual INamedTypeSymbol get_EnumUnderlyingType();
    protected virtual CodeGenerationNamedTypeSymbol get_ConstructedFrom();
    public virtual INamedTypeSymbol ConstructUnboundGenericType();
    public static ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public virtual ImmutableArray`1<ITypeSymbol> get_TypeArguments();
    public virtual ImmutableArray`1<NullableAnnotation> get_TypeArgumentNullableAnnotations();
    public virtual ImmutableArray`1<ITypeParameterSymbol> get_TypeParameters();
    [CompilerGeneratedAttribute]
public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public virtual ImmutableArray`1<IMethodSymbol> get_InstanceConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_StaticConstructors();
    public virtual ImmutableArray`1<IMethodSymbol> get_Constructors();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceInfo : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, CodeGenerationNamespaceInfo> s_namespaceToInfoMap;
    private IList`1<ISymbol> _imports;
    private CodeGenerationNamespaceInfo(IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo();
    public static void Attach(INamespaceSymbol namespace, IList`1<ISymbol> imports);
    private static CodeGenerationNamespaceInfo GetInfo(INamespaceSymbol namespace);
    public static IList`1<ISymbol> GetImports(INamespaceSymbol namespace);
    private static IList`1<ISymbol> GetImports(CodeGenerationNamespaceInfo info);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceOrTypeSymbol : CodeGenerationSymbol {
    public bool IsNamespace { get; }
    public bool IsType { get; }
    protected CodeGenerationNamespaceOrTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name);
    public virtual ImmutableArray`1<ISymbol> GetMembers();
    public sealed virtual ImmutableArray`1<ISymbol> GetMembers(string name);
    public virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name);
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> GetTypeMembers(string name, int arity);
    public abstract virtual bool get_IsNamespace();
    public abstract virtual bool get_IsType();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationNamespaceSymbol : CodeGenerationNamespaceOrTypeSymbol {
    private IList`1<INamespaceOrTypeSymbol> _members;
    public bool IsNamespace { get; }
    public bool IsType { get; }
    public SymbolKind Kind { get; }
    public bool IsGlobalNamespace { get; }
    public NamespaceKind NamespaceKind { get; }
    public Compilation ContainingCompilation { get; }
    public static INamedTypeSymbol ImplicitType { get; }
    public ImmutableArray`1<INamespaceSymbol> ConstituentNamespaces { get; }
    public CodeGenerationNamespaceSymbol(string name, IList`1<INamespaceOrTypeSymbol> members);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual IEnumerable`1<INamespaceOrTypeSymbol> GetMembers();
    private sealed virtual override IEnumerable`1<INamespaceOrTypeSymbol> Microsoft.CodeAnalysis.INamespaceSymbol.GetMembers(string name);
    public sealed virtual IEnumerable`1<INamespaceSymbol> GetNamespaceMembers();
    public sealed virtual bool get_IsGlobalNamespace();
    public sealed virtual NamespaceKind get_NamespaceKind();
    public sealed virtual Compilation get_ContainingCompilation();
    public static INamedTypeSymbol get_ImplicitType();
    public sealed virtual ImmutableArray`1<INamespaceSymbol> get_ConstituentNamespaces();
}
internal enum Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorKind : Enum {
    public int value__;
    public static CodeGenerationOperatorKind Addition;
    public static CodeGenerationOperatorKind BitwiseAnd;
    public static CodeGenerationOperatorKind BitwiseOr;
    public static CodeGenerationOperatorKind Concatenate;
    public static CodeGenerationOperatorKind Decrement;
    public static CodeGenerationOperatorKind Division;
    public static CodeGenerationOperatorKind Equality;
    public static CodeGenerationOperatorKind ExclusiveOr;
    public static CodeGenerationOperatorKind Exponent;
    public static CodeGenerationOperatorKind False;
    public static CodeGenerationOperatorKind GreaterThan;
    public static CodeGenerationOperatorKind GreaterThanOrEqual;
    public static CodeGenerationOperatorKind Increment;
    public static CodeGenerationOperatorKind Inequality;
    public static CodeGenerationOperatorKind IntegerDivision;
    public static CodeGenerationOperatorKind LeftShift;
    public static CodeGenerationOperatorKind LessThan;
    public static CodeGenerationOperatorKind LessThanOrEqual;
    public static CodeGenerationOperatorKind Like;
    public static CodeGenerationOperatorKind LogicalNot;
    public static CodeGenerationOperatorKind Modulus;
    public static CodeGenerationOperatorKind Multiplication;
    public static CodeGenerationOperatorKind OnesComplement;
    public static CodeGenerationOperatorKind RightShift;
    public static CodeGenerationOperatorKind Subtraction;
    public static CodeGenerationOperatorKind True;
    public static CodeGenerationOperatorKind UnaryPlus;
    public static CodeGenerationOperatorKind UnaryNegation;
    public static CodeGenerationOperatorKind UnsignedRightShift;
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOperatorSymbol : CodeGenerationMethodSymbol {
    public MethodKind MethodKind { get; }
    public CodeGenerationOperatorSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    public virtual MethodKind get_MethodKind();
    public static int GetParameterCount(CodeGenerationOperatorKind operatorKind);
    private static string GetMetadataName(CodeGenerationOperatorKind operatorKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptions : object {
    [CompilerGeneratedAttribute]
private CommonOptions <Common>k__BackingField;
    [DataMemberAttribute]
public CommonOptions Common { get; public set; }
    public NamingStylePreferences NamingStyle { get; }
    [CompilerGeneratedAttribute]
public CommonOptions get_Common();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Common(CommonOptions value);
    public NamingStylePreferences get_NamingStyle();
    public static CodeGenerationOptions GetDefault(LanguageServices languageServices);
    public abstract virtual CodeGenerationContextInfo GetInfo(CodeGenerationContext context, ParseOptions parseOptions);
    public CodeGenerationContextInfo GetInfo(CodeGenerationContext context, Project project);
}
internal interface Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProviders : object {
    [ExtensionAttribute]
public static CommonOptions GetCommonCodeGenerationOptions(AnalyzerConfigOptions options, CommonOptions fallbackOptions);
    [ExtensionAttribute]
public static CodeGenerationOptions GetCodeGenerationOptions(AnalyzerConfigOptions options, CodeGenerationOptions fallbackOptions, HostLanguageServices languageServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProviders/<GetCodeGenerationOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<CodeGenerationOptions> GetCodeGenerationOptionsAsync(Document document, CodeGenerationOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationOptionsProviders/<GetCodeGenerationOptionsAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<CodeGenerationOptions> GetCodeGenerationOptionsAsync(Document document, CodeGenerationOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationParameterSymbol : CodeGenerationSymbol {
    [CompilerGeneratedAttribute]
private RefKind <RefKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOptional>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasExplicitDefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ExplicitDefaultValue>k__BackingField;
    public RefKind RefKind { get; }
    public bool IsParams { get; }
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsOptional { get; }
    public int Ordinal { get; }
    public bool HasExplicitDefaultValue { get; }
    public object ExplicitDefaultValue { get; }
    public IParameterSymbol OriginalDefinition { get; }
    public SymbolKind Kind { get; }
    public bool IsThis { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public ScopedKind ScopedKind { get; }
    public bool IsDiscard { get; }
    public CodeGenerationParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    [CompilerGeneratedAttribute]
public sealed virtual RefKind get_RefKind();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsParams();
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsOptional();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasExplicitDefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual object get_ExplicitDefaultValue();
    protected virtual CodeGenerationSymbol Clone();
    public sealed virtual IParameterSymbol get_OriginalDefinition();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsThis();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
    public sealed virtual ScopedKind get_ScopedKind();
    public sealed virtual bool get_IsDiscard();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPointerTypeSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private ITypeSymbol <PointedAtType>k__BackingField;
    public ITypeSymbol PointedAtType { get; }
    public TypeKind TypeKind { get; }
    public SymbolKind Kind { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<CustomModifier> CustomModifiers { get; }
    public CodeGenerationPointerTypeSymbol(ITypeSymbol pointedAtType);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_PointedAtType();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public virtual TypeKind get_TypeKind();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    [NullableContextAttribute("0")]
public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual ImmutableArray`1<CustomModifier> get_CustomModifiers();
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertyInfo : object {
    private static ConditionalWeakTable`2<IPropertySymbol, CodeGenerationPropertyInfo> s_propertyToInfoMap;
    private bool _isNew;
    private bool _isUnsafe;
    private SyntaxNode _initializer;
    private CodeGenerationPropertyInfo(bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo();
    public static void Attach(IPropertySymbol property, bool isNew, bool isUnsafe, SyntaxNode initializer);
    private static CodeGenerationPropertyInfo GetInfo(IPropertySymbol property);
    public static SyntaxNode GetInitializer(CodeGenerationPropertyInfo info);
    public static SyntaxNode GetInitializer(IPropertySymbol property);
    public static bool GetIsNew(IPropertySymbol property);
    public static bool GetIsUnsafe(IPropertySymbol property);
    private static bool GetIsNew(CodeGenerationPropertyInfo info);
    private static bool GetIsUnsafe(CodeGenerationPropertyInfo info);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationPropertySymbol : CodeGenerationSymbol {
    private RefKind _refKind;
    [CompilerGeneratedAttribute]
private ITypeSymbol <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsIndexer>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IParameterSymbol> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<IPropertySymbol> <ExplicitInterfaceImplementations>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <GetMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private IMethodSymbol <SetMethod>k__BackingField;
    public ITypeSymbol Type { get; }
    public NullableAnnotation NullableAnnotation { get; }
    public bool IsIndexer { get; }
    public ImmutableArray`1<IParameterSymbol> Parameters { get; }
    public ImmutableArray`1<IPropertySymbol> ExplicitInterfaceImplementations { get; }
    public IMethodSymbol GetMethod { get; }
    public IMethodSymbol SetMethod { get; }
    public SymbolKind Kind { get; }
    public bool IsReadOnly { get; }
    public bool IsWriteOnly { get; }
    public bool IsRequired { get; }
    public IPropertySymbol OriginalDefinition { get; }
    public RefKind RefKind { get; }
    public bool ReturnsByRef { get; }
    public bool ReturnsByRefReadonly { get; }
    public IPropertySymbol OverriddenProperty { get; }
    public bool IsWithEvents { get; }
    public ImmutableArray`1<CustomModifier> RefCustomModifiers { get; }
    public ImmutableArray`1<CustomModifier> TypeCustomModifiers { get; }
    public CodeGenerationPropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, bool isIndexer, ImmutableArray`1<IParameterSymbol> parametersOpt, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [CompilerGeneratedAttribute]
public sealed virtual ITypeSymbol get_Type();
    public sealed virtual NullableAnnotation get_NullableAnnotation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsIndexer();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IParameterSymbol> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IPropertySymbol> get_ExplicitInterfaceImplementations();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_GetMethod();
    [CompilerGeneratedAttribute]
public sealed virtual IMethodSymbol get_SetMethod();
    protected virtual CodeGenerationSymbol Clone();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsWriteOnly();
    public sealed virtual bool get_IsRequired();
    public sealed virtual IPropertySymbol get_OriginalDefinition();
    public sealed virtual RefKind get_RefKind();
    public sealed virtual bool get_ReturnsByRef();
    public sealed virtual bool get_ReturnsByRefReadonly();
    public sealed virtual IPropertySymbol get_OverriddenProperty();
    public sealed virtual bool get_IsWithEvents();
    public sealed virtual ImmutableArray`1<CustomModifier> get_RefCustomModifiers();
    public sealed virtual ImmutableArray`1<CustomModifier> get_TypeCustomModifiers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSolutionContext : ValueType {
    [CompilerGeneratedAttribute]
private Solution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeGenerationContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeAndImportGenerationOptionsProvider <FallbackOptions>k__BackingField;
    public Solution Solution { get; public set; }
    public CodeGenerationContext Context { get; public set; }
    public CodeAndImportGenerationOptionsProvider FallbackOptions { get; public set; }
    public CodeGenerationSolutionContext(Solution Solution, CodeGenerationContext Context, CodeAndImportGenerationOptionsProvider FallbackOptions);
    [CompilerGeneratedAttribute]
public Solution get_Solution();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Solution(Solution value);
    [CompilerGeneratedAttribute]
public CodeGenerationContext get_Context();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Context(CodeGenerationContext value);
    [CompilerGeneratedAttribute]
public CodeAndImportGenerationOptionsProvider get_FallbackOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FallbackOptions(CodeAndImportGenerationOptionsProvider value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(CodeGenerationSolutionContext left, CodeGenerationSolutionContext right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(CodeGenerationSolutionContext left, CodeGenerationSolutionContext right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(CodeGenerationSolutionContext other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Solution& Solution, CodeGenerationContext& Context, CodeAndImportGenerationOptionsProvider& FallbackOptions);
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbol : object {
    protected static ConditionalWeakTable`2<CodeGenerationSymbol, SyntaxAnnotation[]> annotationsTable;
    private ImmutableArray`1<AttributeData> _attributes;
    protected string _documentationCommentXml;
    [CompilerGeneratedAttribute]
private Accessibility <DeclaredAccessibility>k__BackingField;
    [CompilerGeneratedAttribute]
private DeclarationModifiers <Modifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private INamedTypeSymbol <ContainingType>k__BackingField;
    [CompilerGeneratedAttribute]
private IAssemblySymbol <ContainingAssembly>k__BackingField;
    public Accessibility DeclaredAccessibility { get; }
    protected internal DeclarationModifiers Modifiers { get; }
    public string Name { get; }
    public INamedTypeSymbol ContainingType { get; protected set; }
    public SymbolKind Kind { get; }
    public string Language { get; }
    public ISymbol ContainingSymbol { get; }
    public IAssemblySymbol ContainingAssembly { get; }
    public static IMethodSymbol ContainingMethod { get; }
    public IModuleSymbol ContainingModule { get; }
    public INamespaceSymbol ContainingNamespace { get; }
    public bool IsDefinition { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsAbstract { get; }
    public bool IsSealed { get; }
    public bool IsExtern { get; }
    public bool IsImplicitlyDeclared { get; }
    public bool CanBeReferencedByName { get; }
    public ImmutableArray`1<Location> Locations { get; }
    public static ImmutableArray`1<SyntaxNode> DeclaringSyntaxNodes { get; }
    public ImmutableArray`1<SyntaxReference> DeclaringSyntaxReferences { get; }
    public ISymbol OriginalDefinition { get; }
    public string MetadataName { get; }
    public int MetadataToken { get; }
    public bool HasUnsupportedMetadata { get; }
    protected CodeGenerationSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, string documentationCommentXml);
    private static CodeGenerationSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual Accessibility get_DeclaredAccessibility();
    [CompilerGeneratedAttribute]
protected internal DeclarationModifiers get_Modifiers();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual INamedTypeSymbol get_ContainingType();
    [CompilerGeneratedAttribute]
protected void set_ContainingType(INamedTypeSymbol value);
    protected abstract virtual CodeGenerationSymbol Clone();
    internal SyntaxAnnotation[] GetAnnotations();
    internal CodeGenerationSymbol WithAdditionalAnnotations(SyntaxAnnotation[] annotations);
    private static CodeGenerationSymbol AddAnnotationsTo(CodeGenerationSymbol originalDefinition, CodeGenerationSymbol newDefinition, SyntaxAnnotation[] annotations);
    public abstract virtual SymbolKind get_Kind();
    public sealed virtual string get_Language();
    public virtual ISymbol get_ContainingSymbol();
    [CompilerGeneratedAttribute]
public sealed virtual IAssemblySymbol get_ContainingAssembly();
    public static IMethodSymbol get_ContainingMethod();
    public sealed virtual IModuleSymbol get_ContainingModule();
    public sealed virtual INamespaceSymbol get_ContainingNamespace();
    public sealed virtual bool get_IsDefinition();
    public sealed virtual bool get_IsStatic();
    public sealed virtual bool get_IsVirtual();
    public sealed virtual bool get_IsOverride();
    public sealed virtual bool get_IsAbstract();
    public sealed virtual bool get_IsSealed();
    public sealed virtual bool get_IsExtern();
    public sealed virtual bool get_IsImplicitlyDeclared();
    public sealed virtual bool get_CanBeReferencedByName();
    public sealed virtual ImmutableArray`1<Location> get_Locations();
    public static ImmutableArray`1<SyntaxNode> get_DeclaringSyntaxNodes();
    public sealed virtual ImmutableArray`1<SyntaxReference> get_DeclaringSyntaxReferences();
    public sealed virtual ImmutableArray`1<AttributeData> GetAttributes();
    public ImmutableArray`1<AttributeData> GetAttributes(INamedTypeSymbol attributeType);
    public ImmutableArray`1<AttributeData> GetAttributes(IMethodSymbol attributeConstructor);
    public sealed virtual ISymbol get_OriginalDefinition();
    public abstract virtual void Accept(SymbolVisitor visitor);
    public abstract virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public abstract virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public sealed virtual string GetDocumentationCommentId();
    public sealed virtual string GetDocumentationCommentXml(CultureInfo preferredCulture, bool expandIncludes, CancellationToken cancellationToken);
    public sealed virtual string ToDisplayString(SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, int position, SymbolDisplayFormat format);
    public virtual string get_MetadataName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool get_HasUnsupportedMetadata();
    public sealed virtual bool Equals(ISymbol other);
    public sealed virtual bool Equals(ISymbol other, SymbolEqualityComparer equalityComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationSymbolFactory : object {
    [ExtensionAttribute]
public static bool IsCodeGenerationSymbol(ISymbol symbol);
    public static IEventSymbol CreateEventSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod, IMethodSymbol raiseMethod);
    [NullableContextAttribute("2")]
internal static IPropertySymbol CreatePropertySymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer, SyntaxNode initializer);
    public static IPropertySymbol CreatePropertySymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, RefKind refKind, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<IParameterSymbol> parameters, IMethodSymbol getMethod, IMethodSymbol setMethod, bool isIndexer);
    public static IFieldSymbol CreateFieldSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol type, string name, bool hasConstantValue, object constantValue, SyntaxNode initializer);
    public static IMethodSymbol CreateConstructorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, string typeName, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> baseConstructorArguments, ImmutableArray`1<SyntaxNode> thisConstructorArguments, bool isPrimaryConstructor);
    public static IMethodSymbol CreateDestructorSymbol(ImmutableArray`1<AttributeData> attributes, string typeName, ImmutableArray`1<SyntaxNode> statements);
    internal static IMethodSymbol CreateMethodSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind, bool isInitOnly);
    public static IMethodSymbol CreateMethodSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<SyntaxNode> handlesExpressions, ImmutableArray`1<AttributeData> returnTypeAttributes, MethodKind methodKind, bool isInitOnly);
    public static IMethodSymbol CreateOperatorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, CodeGenerationOperatorKind operatorKind, ImmutableArray`1<IParameterSymbol> parameters, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> returnTypeAttributes, string documentationCommentXml);
    public static IMethodSymbol CreateConversionSymbol(ITypeSymbol toType, IParameterSymbol fromType, INamedTypeSymbol containingType, bool isImplicit, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public static IMethodSymbol CreateConversionSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol toType, IParameterSymbol fromType, INamedTypeSymbol containingType, bool isImplicit, ImmutableArray`1<SyntaxNode> statements, ImmutableArray`1<AttributeData> toTypeAttributes, string documentationCommentXml);
    public static IParameterSymbol CreateParameterSymbol(ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(RefKind refKind, ITypeSymbol type, string name);
    public static IParameterSymbol CreateParameterSymbol(ImmutableArray`1<AttributeData> attributes, RefKind refKind, bool isParams, ITypeSymbol type, string name, bool isOptional, bool hasDefaultValue, object defaultValue);
    internal static IParameterSymbol CreateParameterSymbol(IParameterSymbol parameter, Nullable`1<ImmutableArray`1<AttributeData>> attributes, Nullable`1<RefKind> refKind, Nullable`1<bool> isParams, ITypeSymbol type, Optional`1<string> name, Nullable`1<bool> isOptional, Nullable`1<bool> hasDefaultValue, Optional`1<object> defaultValue);
    public static ITypeParameterSymbol CreateTypeParameterSymbol(string name, int ordinal);
    public static ITypeParameterSymbol CreateTypeParameter(ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, ImmutableArray`1<ITypeSymbol> constraintTypes, NullableAnnotation nullableAnnotation, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasUnmanagedConstraint, bool hasValueConstraint, bool hasNotNullConstraint, int ordinal);
    public static IPointerTypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public static IArrayTypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank, NullableAnnotation nullableAnnotation);
    internal static IMethodSymbol CreateAccessorSymbol(IMethodSymbol accessor, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, ImmutableArray`1<SyntaxNode> statements);
    public static IMethodSymbol CreateAccessorSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, ImmutableArray`1<SyntaxNode> statements);
    public static AttributeData CreateAttributeData(INamedTypeSymbol attributeClass, ImmutableArray`1<TypedConstant> constructorArguments, ImmutableArray`1<KeyValuePair`2<string, TypedConstant>> namedArguments);
    public static INamedTypeSymbol CreateNamedTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members, NullableAnnotation nullableAnnotation, IAssemblySymbol containingAssembly);
    public static INamedTypeSymbol CreateNamedTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, bool isRecord, TypeKind typeKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, INamedTypeSymbol baseType, ImmutableArray`1<INamedTypeSymbol> interfaces, SpecialType specialType, ImmutableArray`1<ISymbol> members, NullableAnnotation nullableAnnotation, IAssemblySymbol containingAssembly);
    public static CodeGenerationNamedTypeSymbol CreateDelegateTypeSymbol(ImmutableArray`1<AttributeData> attributes, Accessibility accessibility, DeclarationModifiers modifiers, ITypeSymbol returnType, RefKind refKind, string name, ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<IParameterSymbol> parameters, NullableAnnotation nullableAnnotation);
    public static INamespaceSymbol CreateNamespaceSymbol(string name, IList`1<ISymbol> imports, IList`1<INamespaceOrTypeSymbol> members);
    [NullableContextAttribute("2")]
internal static IMethodSymbol CreateMethodSymbol(IMethodSymbol method, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IMethodSymbol> explicitInterfaceImplementations, string name, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters, ImmutableArray`1<SyntaxNode> statements, INamedTypeSymbol containingType, ITypeSymbol returnType, Optional`1<ImmutableArray`1<AttributeData>> returnTypeAttributes);
    [NullableContextAttribute("2")]
internal static IPropertySymbol CreatePropertySymbol(IPropertySymbol property, ImmutableArray`1<AttributeData> attributes, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IPropertySymbol> explicitInterfaceImplementations, string name, Nullable`1<bool> isIndexer, IMethodSymbol getMethod, IMethodSymbol setMethod);
    [NullableContextAttribute("2")]
internal static IEventSymbol CreateEventSymbol(IEventSymbol event, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, ImmutableArray`1<IEventSymbol> explicitInterfaceImplementations, string name, IMethodSymbol addMethod, IMethodSymbol removeMethod);
    internal static IFieldSymbol CreateFieldSymbol(IFieldSymbol field, ImmutableArray`1<AttributeData> attributes, Nullable`1<Accessibility> accessibility, Nullable`1<DeclarationModifiers> modifiers, string name);
}
internal class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeParameterSymbol : CodeGenerationTypeSymbol {
    [CompilerGeneratedAttribute]
private VarianceKind <Variance>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <ConstraintTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasConstructorConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReferenceTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValueTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUnmanagedTypeConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNotNullConstraint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Ordinal>k__BackingField;
    public VarianceKind Variance { get; }
    public ImmutableArray`1<ITypeSymbol> ConstraintTypes { get; internal set; }
    public bool HasConstructorConstraint { get; }
    public bool HasReferenceTypeConstraint { get; }
    public bool HasValueTypeConstraint { get; }
    public bool HasUnmanagedTypeConstraint { get; }
    public bool HasNotNullConstraint { get; }
    public int Ordinal { get; }
    public ITypeParameterSymbol OriginalDefinition { get; }
    public ITypeParameterSymbol ReducedFrom { get; }
    public SymbolKind Kind { get; }
    public TypeKind TypeKind { get; }
    public TypeParameterKind TypeParameterKind { get; }
    public IMethodSymbol DeclaringMethod { get; }
    public INamedTypeSymbol DeclaringType { get; }
    public NullableAnnotation ReferenceTypeConstraintNullableAnnotation { get; }
    public ImmutableArray`1<NullableAnnotation> ConstraintNullableAnnotations { get; }
    public CodeGenerationTypeParameterSymbol(INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, VarianceKind varianceKind, string name, NullableAnnotation nullableAnnotation, ImmutableArray`1<ITypeSymbol> constraintTypes, bool hasConstructorConstraint, bool hasReferenceConstraint, bool hasValueConstraint, bool hasUnmanagedConstraint, bool hasNotNullConstraint, int ordinal);
    [CompilerGeneratedAttribute]
public sealed virtual VarianceKind get_Variance();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<ITypeSymbol> get_ConstraintTypes();
    [CompilerGeneratedAttribute]
internal void set_ConstraintTypes(ImmutableArray`1<ITypeSymbol> value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasConstructorConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasReferenceTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasValueTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasUnmanagedTypeConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_HasNotNullConstraint();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Ordinal();
    protected virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
    public sealed virtual ITypeParameterSymbol get_OriginalDefinition();
    public sealed virtual ITypeParameterSymbol get_ReducedFrom();
    public virtual SymbolKind get_Kind();
    public virtual void Accept(SymbolVisitor visitor);
    public virtual TResult Accept(SymbolVisitor`1<TResult> visitor);
    public virtual TResult Accept(SymbolVisitor`2<TArgument, TResult> visitor, TArgument argument);
    public virtual TypeKind get_TypeKind();
    public sealed virtual TypeParameterKind get_TypeParameterKind();
    public sealed virtual IMethodSymbol get_DeclaringMethod();
    public sealed virtual INamedTypeSymbol get_DeclaringType();
    public sealed virtual NullableAnnotation get_ReferenceTypeConstraintNullableAnnotation();
    public sealed virtual ImmutableArray`1<NullableAnnotation> get_ConstraintNullableAnnotations();
}
internal abstract class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerationTypeSymbol : CodeGenerationNamespaceOrTypeSymbol {
    [CompilerGeneratedAttribute]
private SpecialType <SpecialType>k__BackingField;
    [CompilerGeneratedAttribute]
private NullableAnnotation <NullableAnnotation>k__BackingField;
    public SpecialType SpecialType { get; protected set; }
    public TypeKind TypeKind { get; }
    public INamedTypeSymbol BaseType { get; }
    public ImmutableArray`1<INamedTypeSymbol> Interfaces { get; }
    public ImmutableArray`1<INamedTypeSymbol> AllInterfaces { get; }
    public bool IsReferenceType { get; }
    public bool IsValueType { get; }
    public bool IsAnonymousType { get; }
    public bool IsTupleType { get; }
    public bool IsNativeIntegerType { get; }
    public static ImmutableArray`1<ITypeSymbol> TupleElementTypes { get; }
    public static ImmutableArray`1<string> TupleElementNames { get; }
    public ITypeSymbol OriginalDefinition { get; }
    public bool IsNamespace { get; }
    public bool IsType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsRefLikeType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsUnmanagedType { get; }
    private bool Microsoft.CodeAnalysis.ITypeSymbol.IsReadOnly { get; }
    public bool IsRecord { get; }
    public NullableAnnotation NullableAnnotation { get; }
    protected CodeGenerationTypeSymbol(IAssemblySymbol containingAssembly, INamedTypeSymbol containingType, ImmutableArray`1<AttributeData> attributes, Accessibility declaredAccessibility, DeclarationModifiers modifiers, string name, SpecialType specialType, NullableAnnotation nullableAnnotation);
    [CompilerGeneratedAttribute]
public sealed virtual SpecialType get_SpecialType();
    [CompilerGeneratedAttribute]
protected void set_SpecialType(SpecialType value);
    public abstract virtual TypeKind get_TypeKind();
    public virtual INamedTypeSymbol get_BaseType();
    public virtual ImmutableArray`1<INamedTypeSymbol> get_Interfaces();
    public sealed virtual ImmutableArray`1<INamedTypeSymbol> get_AllInterfaces();
    public sealed virtual bool get_IsReferenceType();
    public sealed virtual bool get_IsValueType();
    public sealed virtual bool get_IsAnonymousType();
    public sealed virtual bool get_IsTupleType();
    public sealed virtual bool get_IsNativeIntegerType();
    public static ImmutableArray`1<ITypeSymbol> get_TupleElementTypes();
    public static ImmutableArray`1<string> get_TupleElementNames();
    public sealed virtual ITypeSymbol get_OriginalDefinition();
    public sealed virtual ISymbol FindImplementationForInterfaceMember(ISymbol interfaceMember);
    public sealed virtual string ToDisplayString(NullableFlowState topLevelNullability, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToDisplayParts(NullableFlowState topLevelNullability, SymbolDisplayFormat format);
    public sealed virtual string ToMinimalDisplayString(SemanticModel semanticModel, NullableFlowState topLevelNullability, int position, SymbolDisplayFormat format);
    public sealed virtual ImmutableArray`1<SymbolDisplayPart> ToMinimalDisplayParts(SemanticModel semanticModel, NullableFlowState topLevelNullability, int position, SymbolDisplayFormat format);
    public virtual bool get_IsNamespace();
    public virtual bool get_IsType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsRefLikeType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsUnmanagedType();
    private sealed virtual override bool Microsoft.CodeAnalysis.ITypeSymbol.get_IsReadOnly();
    public virtual bool get_IsRecord();
    [CompilerGeneratedAttribute]
public sealed virtual NullableAnnotation get_NullableAnnotation();
    public sealed virtual ITypeSymbol WithNullableAnnotation(NullableAnnotation nullableAnnotation);
    protected sealed virtual CodeGenerationSymbol Clone();
    protected abstract virtual CodeGenerationTypeSymbol CloneWithNullableAnnotation(NullableAnnotation nullableAnnotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeGeneration.CodeGenerator : object {
    public static SyntaxAnnotation Annotation;
    private static CodeGenerator();
    private static ICodeGenerationService GetCodeGenerationService(SolutionServices services, string language);
    public static Task`1<Document> AddEventDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public static Task`1<Document> AddFieldDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public static Task`1<Document> AddMethodDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public static Task`1<Document> AddPropertyDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamedTypeDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public static Task`1<Document> AddNamespaceOrTypeDeclarationAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    public static Task`1<Document> AddMemberDeclarationsAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public static bool CanAdd(Solution solution, ISymbol destination, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeGeneration.ICodeGenerationService {
    public CodeGenerationOptions DefaultOptions { get; }
    public abstract virtual CodeGenerationOptions get_DefaultOptions();
    public abstract virtual CodeGenerationOptions GetCodeGenerationOptions(AnalyzerConfigOptions options, CodeGenerationOptions fallbackOptions);
    public abstract virtual SyntaxNode CreateEventDeclaration(IEventSymbol event, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateFieldDeclaration(IFieldSymbol field, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateMethodDeclaration(IMethodSymbol method, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreatePropertyDeclaration(IPropertySymbol property, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamedTypeDeclaration(INamedTypeSymbol namedType, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual SyntaxNode CreateNamespaceDeclaration(INamespaceSymbol namespace, CodeGenerationDestination destination, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddEvent(TDeclarationNode destination, IEventSymbol event, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddField(TDeclarationNode destination, IFieldSymbol field, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMethod(TDeclarationNode destination, IMethodSymbol method, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddProperty(TDeclarationNode destination, IPropertySymbol property, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamedType(TDeclarationNode destination, INamedTypeSymbol namedType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddNamespace(TDeclarationNode destination, INamespaceSymbol namespace, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddMembers(TDeclarationNode destination, IEnumerable`1<ISymbol> members, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddParameters(TDeclarationNode destination, IEnumerable`1<IParameterSymbol> parameters, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddAttributes(TDeclarationNode destination, IEnumerable`1<AttributeData> attributes, Nullable`1<SyntaxToken> target, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, SyntaxNode attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode RemoveAttribute(TDeclarationNode destination, AttributeData attributeToRemove, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationModifiers(TDeclarationNode declaration, IEnumerable`1<SyntaxToken> newModifiers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationAccessibility(TDeclarationNode declaration, Accessibility newAccessibility, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationType(TDeclarationNode declaration, ITypeSymbol newType, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode UpdateDeclarationMembers(TDeclarationNode declaration, IList`1<ISymbol> newMembers, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual TDeclarationNode AddStatements(TDeclarationNode destination, IEnumerable`1<SyntaxNode> statements, CodeGenerationContextInfo info, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddEventAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEventSymbol event, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddFieldAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IFieldSymbol field, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMethodAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IMethodSymbol method, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddPropertyAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IPropertySymbol property, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamedTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamedTypeSymbol namedType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceSymbol namespace, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddNamespaceOrTypeAsync(CodeGenerationSolutionContext context, INamespaceSymbol destination, INamespaceOrTypeSymbol namespaceOrType, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> AddMembersAsync(CodeGenerationSolutionContext context, INamedTypeSymbol destination, IEnumerable`1<ISymbol> members, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(ISymbol destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual bool CanAddTo(SyntaxNode destination, Solution solution, CancellationToken cancellationToken);
    public abstract virtual Task`1<SyntaxNode> FindMostRelevantNameSpaceOrTypeDeclarationAsync(Solution solution, INamespaceOrTypeSymbol namespaceOrType, Location location, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.INamedTypeSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static CodeGenerationAbstractNamedTypeSymbol ToCodeGenerationSymbol(INamedTypeSymbol namedType);
}
internal static class Microsoft.CodeAnalysis.CodeGeneration.LiteralSpecialValues : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<byte, string>> ByteSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<sbyte, string>> SByteSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<short, string>> Int16SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<ushort, string>> UInt16SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<int, string>> Int32SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<UInt32, string>> UInt32SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<long, string>> Int64SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<ulong, string>> UInt64SpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<float, string>> SingleSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<double, string>> DoubleSpecialValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static IEnumerable`1<KeyValuePair`2<decimal, string>> DecimalSpecialValues;
    private static LiteralSpecialValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.NullableSyntaxAnnotation : object {
    public static SyntaxAnnotation Oblivious;
    public static SyntaxAnnotation AnnotatedOrNotAnnotated;
    private static NullableSyntaxAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeGeneration.SyntaxAnnotationExtensions : object {
    [ExtensionAttribute]
public static TSymbol AddAnnotationToSymbol(SyntaxAnnotation annotation, TSymbol symbol);
    internal static SyntaxAnnotation[] CombineAnnotations(SyntaxAnnotation[] originalAnnotations, SyntaxAnnotation[] newAnnotations);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeGeneration.TypeGenerator : object {
    public sealed virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public sealed virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public sealed virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringContext : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    internal CodeActionOptionsProvider Options;
    private bool _isBlocking;
    private Action`2<CodeAction, Nullable`1<TextSpan>> _registerRefactoring;
    public Document Document { get; }
    public TextSpan Span { get; }
    public CancellationToken CancellationToken { get; }
    [ObsoleteAttribute]
private bool Microsoft.CodeAnalysis.CodeRefactorings.ITypeScriptCodeRefactoringContext.IsBlocking { get; }
    public CodeRefactoringContext(Document document, TextSpan span, Action`1<CodeAction> registerRefactoring, CancellationToken cancellationToken);
    internal CodeRefactoringContext(Document document, TextSpan span, Action`2<CodeAction, Nullable`1<TextSpan>> registerRefactoring, CodeActionOptionsProvider options, bool isBlocking, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    private sealed virtual override bool Microsoft.CodeAnalysis.CodeRefactorings.ITypeScriptCodeRefactoringContext.get_IsBlocking();
    public void RegisterRefactoring(CodeAction action);
    internal void RegisterRefactoring(CodeAction action, TextSpan applicableToSpan);
    private void RegisterRefactoring(CodeAction action, Nullable`1<TextSpan> applicableToSpan);
    internal void Deconstruct(Document& document, TextSpan& span, CancellationToken& cancellationToken);
}
public abstract class Microsoft.CodeAnalysis.CodeRefactorings.CodeRefactoringProvider : object {
    internal CodeActionRequestPriority RequestPriority { get; }
    [NullableContextAttribute("1")]
public abstract virtual Task ComputeRefactoringsAsync(CodeRefactoringContext context);
    [NullableContextAttribute("2")]
internal virtual FixAllProvider GetFixAllProvider();
    internal CodeActionRequestPriority get_RequestPriority();
    private protected virtual CodeActionRequestPriority ComputeRequestPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider : FixAllProvider {
    [NullableAttribute("0")]
private ImmutableArray`1<FixAllScope> _supportedFixAllScopes;
    [NullableContextAttribute("0")]
protected DocumentBasedFixAllProvider(ImmutableArray`1<FixAllScope> supportedFixAllScopes);
    protected virtual string GetFixAllTitle(FixAllContext fixAllContext);
    protected abstract virtual Task`1<Document> FixAllAsync(FixAllContext fixAllContext, Document document, Optional`1<ImmutableArray`1<TextSpan>> fixAllSpans);
    public sealed virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    public sealed virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    private Task`1<Solution> FixAllContextsHelperAsync(FixAllContext originalFixAllContext, ImmutableArray`1<FixAllContext> fixAllContexts);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.DocumentBasedFixAllProvider/<GetFixedDocumentsAsync>d__8")]
private Task`1<Dictionary`2<DocumentId, ValueTuple`2<SyntaxNode, SourceText>>> GetFixedDocumentsAsync(FixAllContext fixAllContext, IProgressTracker progressTracker);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.CodeRefactorings.ExportCodeRefactoringProviderAttribute : ExportAttribute {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Languages>k__BackingField;
    [NullableAttribute("2")]
public string Name { get; public set; }
    public String[] Languages { get; }
    public ExportCodeRefactoringProviderAttribute(string firstLanguage, String[] additionalLanguages);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public String[] get_Languages();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.CodeRefactorings.FixAllContext : object {
    [CompilerGeneratedAttribute]
private FixAllState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IProgressTracker <ProgressTracker>k__BackingField;
    internal FixAllState State { get; }
    internal FixAllProvider FixAllProvider { get; }
    public Document Document { get; }
    public CodeRefactoringProvider CodeRefactoringProvider { get; }
    public FixAllScope Scope { get; }
    [NullableAttribute("2")]
public string CodeActionEquivalenceKey { get; }
    public CancellationToken CancellationToken { get; }
    internal IProgressTracker ProgressTracker { get; }
    public Project Project { get; }
    public Solution Solution { get; }
    private IFixAllState Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.State { get; }
    private IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.FixAllProvider { get; }
    private object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.Provider { get; }
    private IProgressTracker Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.ProgressTracker { get; }
    internal FixAllContext(FixAllState state, IProgressTracker progressTracker, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal FixAllState get_State();
    internal FixAllProvider get_FixAllProvider();
    public sealed virtual Document get_Document();
    public CodeRefactoringProvider get_CodeRefactoringProvider();
    public sealed virtual FixAllScope get_Scope();
    [NullableContextAttribute("2")]
public sealed virtual string get_CodeActionEquivalenceKey();
    [CompilerGeneratedAttribute]
public sealed virtual CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal IProgressTracker get_ProgressTracker();
    public sealed virtual Project get_Project();
    public sealed virtual Solution get_Solution();
    private sealed virtual override IFixAllState Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_State();
    private sealed virtual override IFixAllProvider Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_FixAllProvider();
    private sealed virtual override object Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_Provider();
    private sealed virtual override IProgressTracker Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.get_ProgressTracker();
    private sealed virtual override string Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.GetDefaultFixAllTitle();
    [NullableContextAttribute("0")]
private sealed virtual override IFixAllContext Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllContext.With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
    public FixAllContext WithCancellationToken(CancellationToken cancellationToken);
    public Task`1<ImmutableDictionary`2<Document, Optional`1<ImmutableArray`1<TextSpan>>>> GetFixAllSpansAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
internal FixAllContext With(Optional`1<ValueTuple`2<Document, Project>> documentAndProject, Optional`1<FixAllScope> scope, Optional`1<string> codeActionEquivalenceKey);
    internal string GetDefaultFixAllTitle();
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.FixAllProvider : object {
    private protected static ImmutableArray`1<FixAllScope> DefaultSupportedFixAllScopes;
    private static FixAllProvider();
    [NullableContextAttribute("1")]
public virtual IEnumerable`1<FixAllScope> GetSupportedFixAllScopes();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<CodeAction> GetFixAsync(FixAllContext fixAllContext);
    [NullableContextAttribute("1")]
private sealed virtual override Task`1<CodeAction> Microsoft.CodeAnalysis.CodeFixesAndRefactorings.IFixAllProvider.GetFixAsync(IFixAllContext fixAllContext);
    [NullableContextAttribute("1")]
public static FixAllProvider Create(Func`4<FixAllContext, Document, Optional`1<ImmutableArray`1<TextSpan>>, Task`1<Document>> fixAllAsync);
    public static FixAllProvider Create(Func`4<FixAllContext, Document, Optional`1<ImmutableArray`1<TextSpan>>, Task`1<Document>> fixAllAsync, ImmutableArray`1<FixAllScope> supportedFixAllScopes);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.CodeRefactorings.FixAllState : CommonFixAllState`3<CodeRefactoringProvider, FixAllProvider, FixAllState> {
    private TextSpan _selectionSpan;
    [CompilerGeneratedAttribute]
private string <CodeActionTitle>k__BackingField;
    public FixAllKind FixAllKind { get; }
    public string CodeActionTitle { get; }
    public FixAllState(FixAllProvider fixAllProvider, Document document, TextSpan selectionSpan, CodeRefactoringProvider codeRefactoringProvider, CodeActionOptionsProvider optionsProvider, FixAllScope fixAllScope, CodeAction codeAction);
    public FixAllState(FixAllProvider fixAllProvider, Project project, TextSpan selectionSpan, CodeRefactoringProvider codeRefactoringProvider, CodeActionOptionsProvider optionsProvider, FixAllScope fixAllScope, CodeAction codeAction);
    private FixAllState(FixAllProvider fixAllProvider, Document document, Project project, TextSpan selectionSpan, CodeRefactoringProvider codeRefactoringProvider, CodeActionOptionsProvider optionsProvider, FixAllScope fixAllScope, string codeActionTitle, string codeActionEquivalenceKey);
    public virtual FixAllKind get_FixAllKind();
    [CompilerGeneratedAttribute]
public string get_CodeActionTitle();
    protected virtual FixAllState With(Document document, Project project, FixAllScope scope, string codeActionEquivalenceKey);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.FixAllState/<GetFixAllSpansAsync>d__10")]
internal Task`1<ImmutableDictionary`2<Document, Optional`1<ImmutableArray`1<TextSpan>>>> GetFixAllSpansAsync(CancellationToken cancellationToken);
}
[ObsoleteAttribute]
internal interface Microsoft.CodeAnalysis.CodeRefactorings.ITypeScriptCodeRefactoringContext {
    public bool IsBlocking { get; }
    public abstract virtual bool get_IsBlocking();
}
internal abstract class Microsoft.CodeAnalysis.CodeRefactorings.SyntaxEditorBasedCodeRefactoringProvider : CodeRefactoringProvider {
    protected static ImmutableArray`1<FixAllScope> DefaultFixAllScopes;
    protected static ImmutableArray`1<FixAllScope> AllFixAllScopes;
    protected ImmutableArray`1<FixAllScope> SupportedFixAllScopes { get; }
    private static SyntaxEditorBasedCodeRefactoringProvider();
    protected abstract virtual ImmutableArray`1<FixAllScope> get_SupportedFixAllScopes();
    [NullableContextAttribute("2")]
internal sealed virtual FixAllProvider GetFixAllProvider();
    [NullableContextAttribute("1")]
protected Task`1<Document> FixAsync(Document document, TextSpan fixAllSpan, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected Task`1<Document> FixAllAsync(Document document, Optional`1<ImmutableArray`1<TextSpan>> fixAllSpans, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.SyntaxEditorBasedCodeRefactoringProvider/<FixAllWithEditorAsync>d__7")]
internal static Task`1<Document> FixAllWithEditorAsync(Document document, Func`2<SyntaxEditor, Task> editAsync, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
protected abstract virtual Task FixAllAsync(Document document, ImmutableArray`1<TextSpan> fixAllSpans, SyntaxEditor editor, CodeActionOptionsProvider optionsProvider, string equivalenceKey, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeRefactorings.SyntaxEditorBasedCodeRefactoringProvider/<<GetFixAllProvider>b__4_0>d")]
[CompilerGeneratedAttribute]
private Task`1<Document> <GetFixAllProvider>b__4_0(FixAllContext fixAllContext, Document document, Optional`1<ImmutableArray`1<TextSpan>> fixAllSpans);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.AccessibilityModifiersRequired : Enum {
    public int value__;
    public static AccessibilityModifiersRequired Never;
    public static AccessibilityModifiersRequired Always;
    public static AccessibilityModifiersRequired ForNonInterfaceMembers;
    public static AccessibilityModifiersRequired OmitIfDefault;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleHelpers : object {
    private static CodeStyleOption2`1<UnusedValuePreference> s_preferNoneUnusedValuePreference;
    private static BidirectionalMap`2<string, UnusedValuePreference> s_unusedExpressionAssignmentPreferenceMap;
    private static CodeStyleHelpers();
    public static bool TryParseStringEditorConfigCodeStyleOption(string arg, CodeStyleOption2`1<string> defaultValue, CodeStyleOption2`1& option);
    public static bool TryParseBoolEditorConfigCodeStyleOption(string arg, CodeStyleOption2`1<bool> defaultValue, CodeStyleOption2`1& option);
    public static bool TryGetCodeStyleValue(string arg, String& value);
    public static bool TryGetCodeStyleValueAndOptionalNotification(string arg, NotificationOption2 defaultNotification, String& value, NotificationOption2& notification);
    private static bool TryParseNotification(string value, NotificationOption2& notification);
    public static Option2`1<T> CreateOption(OptionGroup group, string feature, string name, T defaultValue, Builder<IOption2> optionsBuilder, OptionStorageLocation2 storageLocation, string languageName);
    public static Option2`1<T> CreateOption(OptionGroup group, string feature, string name, T defaultValue, Builder<IOption2> optionsBuilder, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2, string languageName);
    public static Option2`1<CodeStyleOption2`1<UnusedValuePreference>> CreateUnusedExpressionAssignmentOption(OptionGroup group, string feature, string name, string editorConfigName, CodeStyleOption2`1<UnusedValuePreference> defaultValue, Builder<IOption2> optionsBuilder, string languageName);
    private static Optional`1<CodeStyleOption2`1<UnusedValuePreference>> ParseUnusedExpressionAssignmentPreference(string optionString, CodeStyleOption2`1<UnusedValuePreference> defaultCodeStyleOption);
    private static string GetUnusedExpressionAssignmentPreferenceEditorConfigString(CodeStyleOption2`1<UnusedValuePreference> option, CodeStyleOption2`1<UnusedValuePreference> defaultValue);
    internal static string GetEditorConfigStringNotificationPart(CodeStyleOption2`1<T> option, CodeStyleOption2`1<T> defaultValue);
}
public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption`1 : object {
    private CodeStyleOption2`1<T> _codeStyleOptionImpl;
    public static CodeStyleOption`1<T> Default { get; }
    public T Value { get; public set; }
    private object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.Value { get; }
    private NotificationOption2 Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.Notification { get; }
    public NotificationOption Notification { get; public set; }
    internal CodeStyleOption2`1<T> UnderlyingOption { get; }
    internal CodeStyleOption`1(CodeStyleOption2`1<T> codeStyleOptionImpl);
    public CodeStyleOption`1(T value, NotificationOption notification);
    public static CodeStyleOption`1<T> get_Default();
    public T get_Value();
    [ObsoleteAttribute("Modifying a CodeStyleOption<T> is not supported.", "True")]
public void set_Value(T value);
    private sealed virtual override object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.get_Value();
    private sealed virtual override NotificationOption2 Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.get_Notification();
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.WithValue(object value);
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.WithNotification(NotificationOption2 notification);
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.AsCodeStyleOption();
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.AsPublicCodeStyleOption();
    public NotificationOption get_Notification();
    [ObsoleteAttribute("Modifying a CodeStyleOption<T> is not supported.", "True")]
public void set_Notification(NotificationOption value);
    internal CodeStyleOption2`1<T> get_UnderlyingOption();
    public sealed virtual XElement ToXElement();
    public static CodeStyleOption`1<T> FromXElement(XElement element);
    public sealed virtual bool Equals(CodeStyleOption`1<T> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOption2`1 : object {
    public static CodeStyleOption2`1<T> Default;
    private static int SerializationVersion;
    private static string XmlElement_CodeStyleOption;
    private static string XmlAttribute_SerializationVersion;
    private static string XmlAttribute_Type;
    private static string XmlAttribute_Value;
    private static string XmlAttribute_DiagnosticSeverity;
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private NotificationOption2 <Notification>k__BackingField;
    [DataMemberAttribute]
public T Value { get; }
    [DataMemberAttribute]
public NotificationOption2 Notification { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.Value { get; }
    private int EnumValueAsInt32 { get; }
    public CodeStyleOption2`1(T value, NotificationOption2 notification);
    private static CodeStyleOption2`1();
    public static CodeStyleOption`1<T> op_Explicit(CodeStyleOption2`1<T> option);
    public static CodeStyleOption2`1<T> op_Explicit(CodeStyleOption`1<T> option);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public sealed virtual NotificationOption2 get_Notification();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.get_Value();
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.WithValue(object value);
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.WithNotification(NotificationOption2 notification);
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.AsCodeStyleOption();
    private sealed virtual override ICodeStyleOption Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption.AsPublicCodeStyleOption();
    private int get_EnumValueAsInt32();
    public sealed virtual XElement ToXElement();
    private object GetValueForSerialization();
    private string GetTypeNameForSerialization();
    private bool IsZeroOrOneValueOfEnum();
    public static CodeStyleOption2`1<T> FromXElement(XElement element);
    private static Func`2<string, T> GetParser(string type);
    private static T Convert(bool b);
    private static T Convert(int i);
    public sealed virtual bool Equals(CodeStyleOption2`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptionGroups : object {
    public static OptionGroup Usings;
    public static OptionGroup ThisOrMe;
    public static OptionGroup PredefinedTypeNameUsage;
    public static OptionGroup Parentheses;
    public static OptionGroup Modifier;
    public static OptionGroup ExpressionLevelPreferences;
    public static OptionGroup Field;
    public static OptionGroup Parameter;
    public static OptionGroup Suppressions;
    public static OptionGroup NewLinePreferences;
    private static CodeStyleOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions : object {
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyFieldAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyPropertyAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyMethodAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> QualifyEventAccess;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
    public static PerLanguageOption`1<CodeStyleOption`1<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
    private static CodeStyleOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.CodeStyleOptions2 : object {
    private static Builder<IOption2> s_allOptionsBuilder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static ImmutableArray`1<IOption2> <AllOptions>k__BackingField;
    internal static CodeStyleOption2`1<bool> TrueWithSilentEnforcement;
    internal static CodeStyleOption2`1<bool> FalseWithSilentEnforcement;
    internal static CodeStyleOption2`1<bool> TrueWithSuggestionEnforcement;
    internal static CodeStyleOption2`1<bool> FalseWithSuggestionEnforcement;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyFieldAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyPropertyAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyMethodAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> QualifyEventAccess;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIntrinsicPredefinedTypeKeywordInDeclaration;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIntrinsicPredefinedTypeKeywordInMemberAccess;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferObjectInitializer;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCollectionInitializer;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSimplifiedBooleanExpressions;
    internal static Option2`1<OperatorPlacementWhenWrappingPreference> OperatorPlacementWhenWrapping;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCoalesceExpression;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferNullPropagation;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferExplicitTupleNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferAutoProperties;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferInferredTupleNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferInferredAnonymousTypeMemberNames;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferIsNullCheckOverReferenceEqualityMethod;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferConditionalExpressionOverAssignment;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferConditionalExpressionOverReturn;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferCompoundAssignment;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSimplifiedInterpolation;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<UnusedParametersPreference>> UnusedParameters;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<AccessibilityModifiersRequired>> AccessibilityModifiersRequired;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferReadonly;
    internal static Option2`1<string> FileHeaderTemplate;
    internal static Option2`1<string> RemoveUnnecessarySuppressionExclusions;
    private static BidirectionalMap`2<string, AccessibilityModifiersRequired> s_accessibilityModifiersRequiredMap;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> ArithmeticBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> OtherBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> RelationalBinaryParentheses;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> OtherParentheses;
    private static BidirectionalMap`2<string, ParenthesesPreference> s_parenthesesPreferenceMap;
    private static BidirectionalMap`2<string, UnusedParametersPreference> s_unusedParametersPreferenceMap;
    private static BidirectionalMap`2<string, ForEachExplicitCastInSourcePreference> s_forEachExplicitCastInSourcePreferencePreferenceMap;
    internal static Option2`1<CodeStyleOption2`1<ForEachExplicitCastInSourcePreference>> ForEachExplicitCastInSource;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferSystemHashCode;
    public static PerLanguageOption2`1<CodeStyleOption2`1<bool>> PreferNamespaceAndFolderMatchStructure;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> AllowMultipleBlankLines;
    internal static PerLanguageOption2`1<CodeStyleOption2`1<bool>> AllowStatementImmediatelyAfterBlock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption2> AllOptions { get; }
    private static CodeStyleOptions2();
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOption2> get_AllOptions();
    private static PerLanguageOption2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    private static PerLanguageOption2`1<T> CreateOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2);
    private static Option2`1<T> CreateCommonOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    private static Option2`1<T> CreateCommonOption(OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2);
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> CreateOption(OptionGroup group, string name, CodeStyleOption2`1<bool> defaultValue, string editorconfigKeyName, string roamingProfileStorageKeyName);
    private static PerLanguageOption2`1<CodeStyleOption2`1<bool>> CreateQualifyAccessOption(string optionName, string editorconfigKeyName);
    private static CodeStyleOption2`1<AccessibilityModifiersRequired> ParseAccessibilityModifiersRequired(string optionString, CodeStyleOption2`1<AccessibilityModifiersRequired> defaultValue);
    private static string GetAccessibilityModifiersRequiredEditorConfigString(CodeStyleOption2`1<AccessibilityModifiersRequired> option, CodeStyleOption2`1<AccessibilityModifiersRequired> defaultValue);
    private static PerLanguageOption2`1<CodeStyleOption2`1<ParenthesesPreference>> CreateParenthesesOption(string fieldName, CodeStyleOption2`1<ParenthesesPreference> defaultValue, string styleName);
    private static CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> ParseForEachExplicitCastInSourcePreference(string optionString, CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> defaultValue);
    private static string GetForEachExplicitCastInSourceEditorConfigString(CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> option, CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> defaultValue);
    private static CodeStyleOption2`1<ParenthesesPreference> ParseParenthesesPreference(string optionString, CodeStyleOption2`1<ParenthesesPreference> defaultValue);
    private static string GetParenthesesPreferenceEditorConfigString(CodeStyleOption2`1<ParenthesesPreference> option, CodeStyleOption2`1<ParenthesesPreference> defaultValue);
    private static CodeStyleOption2`1<UnusedParametersPreference> ParseUnusedParametersPreference(string optionString, CodeStyleOption2`1<UnusedParametersPreference> defaultValue);
    private static string GetUnusedParametersPreferenceEditorConfigString(CodeStyleOption2`1<UnusedParametersPreference> option, CodeStyleOption2`1<UnusedParametersPreference> defaultValue);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ExpressionBodyPreference : Enum {
    public int value__;
    public static ExpressionBodyPreference Never;
    public static ExpressionBodyPreference WhenPossible;
    public static ExpressionBodyPreference WhenOnSingleLine;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.FadingOptions : object {
    public static PerLanguageOption2`1<bool> FadeOutUnusedImports;
    public static PerLanguageOption2`1<bool> FadeOutUnreachableCode;
    private static FadingOptions();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ForEachExplicitCastInSourcePreference : Enum {
    public int value__;
    public static ForEachExplicitCastInSourcePreference Always;
    public static ForEachExplicitCastInSourcePreference WhenStronglyTyped;
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeStyle.ICodeStyleOption {
    [NullableAttribute("2")]
public object Value { get; }
    public NotificationOption2 Notification { get; }
    public abstract virtual XElement ToXElement();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
    public abstract virtual NotificationOption2 get_Notification();
    public abstract virtual ICodeStyleOption WithValue(object value);
    public abstract virtual ICodeStyleOption WithNotification(NotificationOption2 notification);
    public abstract virtual ICodeStyleOption AsCodeStyleOption();
    public abstract virtual ICodeStyleOption AsPublicCodeStyleOption();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.CodeStyle.ICodeStyleService {
    public IdeCodeStyleOptions DefaultOptions { get; }
    public abstract virtual IdeCodeStyleOptions get_DefaultOptions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.CodeStyle.IdeCodeStyleOptions : object {
    protected static CodeStyleOption2`1<bool> s_trueWithSuggestionEnforcement;
    protected static CodeStyleOption2`1<bool> s_trueWithSilentEnforcement;
    private static CodeStyleOption2`1<UnusedParametersPreference> s_preferAllMethodsUnusedParametersPreference;
    private static CodeStyleOption2`1<AccessibilityModifiersRequired> s_accessibilityModifiersRequiredDefault;
    private static CodeStyleOption2`1<ParenthesesPreference> s_alwaysForClarityPreference;
    private static CodeStyleOption2`1<ParenthesesPreference> s_neverIfUnnecessaryPreference;
    private static CodeStyleOption2`1<ForEachExplicitCastInSourcePreference> s_forEachExplicitCastInSourceNonLegacyPreference;
    [CompilerGeneratedAttribute]
private CommonOptions <Common>k__BackingField;
    [DataMemberAttribute]
public CommonOptions Common { get; public set; }
    private static IdeCodeStyleOptions();
    [CompilerGeneratedAttribute]
public CommonOptions get_Common();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Common(CommonOptions value);
    public static IdeCodeStyleOptions GetDefault(LanguageServices languageServices);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.NamespaceDeclarationPreference : Enum {
    public int value__;
    public static NamespaceDeclarationPreference BlockScoped;
    public static NamespaceDeclarationPreference FileScoped;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.NamingStyleOptions : object {
    private static string FeatureName;
    [CompilerGeneratedAttribute]
private static PerLanguageOption2`1<NamingStylePreferences> <NamingPreferences>k__BackingField;
    internal static PerLanguageOption2`1<NamingStylePreferences> NamingPreferences { get; }
    private static NamingStyleOptions();
    [CompilerGeneratedAttribute]
internal static PerLanguageOption2`1<NamingStylePreferences> get_NamingPreferences();
    public static OptionKey2 GetNamingPreferencesOptionKey(string language);
}
internal interface Microsoft.CodeAnalysis.CodeStyle.NamingStylePreferencesProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.NamingStylePreferencesProviders : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.NamingStylePreferencesProviders/<GetNamingStylePreferencesAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<NamingStylePreferences> GetNamingStylePreferencesAsync(Document document, NamingStylePreferences fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.CodeStyle.NamingStylePreferencesProviders/<GetNamingStylePreferencesAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<NamingStylePreferences> GetNamingStylePreferencesAsync(Document document, NamingStylePreferencesProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.CodeStyle.NotificationOption : object {
    private NotificationOption2 _notificationOptionImpl;
    public static NotificationOption None;
    public static NotificationOption Silent;
    public static NotificationOption Suggestion;
    public static NotificationOption Warning;
    public static NotificationOption Error;
    public string Name { get; public set; }
    public ReportDiagnostic Severity { get; public set; }
    [ObsoleteAttribute("Use Severity instead.")]
public DiagnosticSeverity Value { get; public set; }
    private NotificationOption(NotificationOption2 notificationOptionImpl);
    private static NotificationOption();
    public string get_Name();
    [ObsoleteAttribute("Modifying a NotificationOption is not supported.", "True")]
public void set_Name(string value);
    public ReportDiagnostic get_Severity();
    [ObsoleteAttribute("Modifying a NotificationOption is not supported.", "True")]
public void set_Severity(ReportDiagnostic value);
    public DiagnosticSeverity get_Value();
    public void set_Value(DiagnosticSeverity value);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.NotificationOption2 : ValueType {
    [CompilerGeneratedAttribute]
private ReportDiagnostic <Severity>k__BackingField;
    [DataMemberAttribute]
public ReportDiagnostic Severity { get; public set; }
    public static NotificationOption2 None { get; }
    public static NotificationOption2 Silent { get; }
    public static NotificationOption2 Suggestion { get; }
    public static NotificationOption2 Warning { get; }
    public static NotificationOption2 Error { get; }
    public NotificationOption2(ReportDiagnostic Severity);
    [NullableContextAttribute("1")]
public static NotificationOption op_Explicit(NotificationOption2 notificationOption);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_Severity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Severity(ReportDiagnostic value);
    public static NotificationOption2 get_None();
    public static NotificationOption2 get_Silent();
    public static NotificationOption2 get_Suggestion();
    public static NotificationOption2 get_Warning();
    public static NotificationOption2 get_Error();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NotificationOption2 left, NotificationOption2 right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NotificationOption2 left, NotificationOption2 right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NotificationOption2 other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ReportDiagnostic& Severity);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.CodeStyle.NotificationOptionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(NotificationOption2 notificationOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.CodeStyle.OperatorPlacementUtilities : object {
    private static string end_of_line;
    private static string beginning_of_line;
    public static string GetEditorConfigString(OperatorPlacementWhenWrappingPreference value);
    [NullableContextAttribute("0")]
public static Optional`1<OperatorPlacementWhenWrappingPreference> Parse(string optionString);
}
internal enum Microsoft.CodeAnalysis.CodeStyle.OperatorPlacementWhenWrappingPreference : Enum {
    public int value__;
    public static OperatorPlacementWhenWrappingPreference BeginningOfLine;
    public static OperatorPlacementWhenWrappingPreference EndOfLine;
}
internal enum Microsoft.CodeAnalysis.CodeStyle.ParenthesesPreference : Enum {
    public int value__;
    public static ParenthesesPreference AlwaysForClarity;
    public static ParenthesesPreference NeverIfUnnecessary;
}
[ExportSolutionOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.CodeStyle.SolutionCodeStyleOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
internal enum Microsoft.CodeAnalysis.CodeStyle.UnusedParametersPreference : Enum {
    public int value__;
    public static UnusedParametersPreference NonPublicMethods;
    public static UnusedParametersPreference AllMethods;
}
internal enum Microsoft.CodeAnalysis.CodeStyle.UnusedValuePreference : Enum {
    public int value__;
    public static UnusedValuePreference UnusedLocalVariable;
    public static UnusedValuePreference DiscardVariable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary : object {
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create();
    public static ImmutableSegmentedDictionary`2<TKey, TValue> Create(IEqualityComparer`1<TKey> keyComparer);
    public static Builder<TKey, TValue> CreateBuilder();
    public static Builder<TKey, TValue> CreateBuilder(IEqualityComparer`1<TKey> keyComparer);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> CreateRange(IEqualityComparer`1<TKey> keyComparer, IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(Builder<TKey, TValue> builder);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TValue> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector, IEqualityComparer`1<TKey> keyComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector);
    [ExtensionAttribute]
public static ImmutableSegmentedDictionary`2<TKey, TSource> ToImmutableSegmentedDictionary(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, IEqualityComparer`1<TKey> keyComparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedDictionary`2<TKey, TValue> Empty;
    private SegmentedDictionary`2<TKey, TValue> _dictionary;
    public IEqualityComparer`1<TKey> KeyComparer { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsDefault { get; }
    public bool IsDefaultOrEmpty { get; }
    [NullableAttribute("0")]
public KeyCollection<TKey, TValue> Keys { get; }
    [NullableAttribute("0")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    public TValue Item { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ImmutableSegmentedDictionary`2(SegmentedDictionary`2<TKey, TValue> dictionary);
    private static ImmutableSegmentedDictionary`2();
    public IEqualityComparer`1<TKey> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool get_IsDefault();
    public bool get_IsDefaultOrEmpty();
    [NullableContextAttribute("0")]
public KeyCollection<TKey, TValue> get_Keys();
    [NullableContextAttribute("0")]
public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    public sealed virtual TValue get_Item(TKey key);
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public static bool op_Equality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Inequality(ImmutableSegmentedDictionary`2<TKey, TValue> left, ImmutableSegmentedDictionary`2<TKey, TValue> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> left, Nullable`1<ImmutableSegmentedDictionary`2<TKey, TValue>> right);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableSegmentedDictionary`2<TKey, TValue> Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> pair);
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    public ImmutableSegmentedDictionary`2<TKey, TValue> Remove(TKey key);
    public ImmutableSegmentedDictionary`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public ImmutableSegmentedDictionary`2<TKey, TValue> WithComparer(IEqualityComparer`1<TKey> keyComparer);
    public Builder<TKey, TValue> ToBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedDictionary`2<TKey, TValue> other);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private static bool TryCastToImmutableSegmentedDictionary(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, ImmutableSegmentedDictionary`2& other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create();
    public static ImmutableSegmentedHashSet`1<T> Create(T item);
    public static ImmutableSegmentedHashSet`1<T> Create(T[] items);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T item);
    public static ImmutableSegmentedHashSet`1<T> Create(IEqualityComparer`1<T> equalityComparer, T[] items);
    public static Builder<T> CreateBuilder();
    public static Builder<T> CreateBuilder(IEqualityComparer`1<T> equalityComparer);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEnumerable`1<T> items);
    public static ImmutableSegmentedHashSet`1<T> CreateRange(IEqualityComparer`1<T> equalityComparer, IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(IEnumerable`1<TSource> source, IEqualityComparer`1<TSource> equalityComparer);
    [ExtensionAttribute]
public static ImmutableSegmentedHashSet`1<TSource> ToImmutableSegmentedHashSet(Builder<TSource> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedHashSet`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedHashSet`1<T> Empty;
    private SegmentedHashSet`1<T> _set;
    public IEqualityComparer`1<T> KeyComparer { get; }
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private ImmutableSegmentedHashSet`1(SegmentedHashSet`1<T> set);
    private static ImmutableSegmentedHashSet`1();
    public IEqualityComparer`1<T> get_KeyComparer();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public static bool op_Equality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedHashSet`1<T> left, ImmutableSegmentedHashSet`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedHashSet`1<T>> left, Nullable`1<ImmutableSegmentedHashSet`1<T>> right);
    public ImmutableSegmentedHashSet`1<T> Add(T value);
    public ImmutableSegmentedHashSet`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedHashSet`1<T> Except(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedHashSet`1<T> Intersect(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> Remove(T value);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public ImmutableSegmentedHashSet`1<T> SymmetricExcept(IEnumerable`1<T> other);
    public sealed virtual bool TryGetValue(T equalValue, T& actualValue);
    public ImmutableSegmentedHashSet`1<T> Union(IEnumerable`1<T> other);
    public Builder<T> ToBuilder();
    public ImmutableSegmentedHashSet`1<T> WithComparer(IEqualityComparer`1<T> equalityComparer);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedHashSet`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Clear();
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Add(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Remove(T value);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Intersect(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Except(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.SymmetricExcept(IEnumerable`1<T> other);
    private sealed virtual override IImmutableSet`1<T> System.Collections.Immutable.IImmutableSet<T>.Union(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.Collections.Generic.ISet<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ISet<T>.UnionWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.IntersectWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.ExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ISet<T>.SymmetricExceptWith(IEnumerable`1<T> other);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList : object {
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> Create();
    public static ImmutableSegmentedList`1<T> Create(T item);
    public static ImmutableSegmentedList`1<T> Create(T[] items);
    public static Builder<T> CreateBuilder();
    public static ImmutableSegmentedList`1<T> CreateRange(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static ImmutableSegmentedList`1<T> ToImmutableSegmentedList(Builder<T> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.ImmutableSegmentedList`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableSegmentedList`1<T> Empty;
    private SegmentedList`1<T> _list;
    public int Count { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    private ImmutableSegmentedList`1(SegmentedList`1<T> list);
    private static ImmutableSegmentedList`1();
    public sealed virtual int get_Count();
    public bool get_IsDefault();
    public bool get_IsEmpty();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static bool op_Equality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Inequality(ImmutableSegmentedList`1<T> left, ImmutableSegmentedList`1<T> right);
    public static bool op_Equality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public static bool op_Inequality(Nullable`1<ImmutableSegmentedList`1<T>> left, Nullable`1<ImmutableSegmentedList`1<T>> right);
    public T& modreq(System.Runtime.InteropServices.InAttribute) ItemRef(int index);
    public ImmutableSegmentedList`1<T> Add(T value);
    public ImmutableSegmentedList`1<T> AddRange(IEnumerable`1<T> items);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Clear();
    public sealed virtual bool Contains(T value);
    public ImmutableSegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableSegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T value);
    public sealed virtual int IndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Insert(int index, T item);
    public ImmutableSegmentedList`1<T> InsertRange(int index, IEnumerable`1<T> items);
    public sealed virtual int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Remove(T value);
    public ImmutableSegmentedList`1<T> Remove(T value, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveAll(Predicate`1<T> match);
    public ImmutableSegmentedList`1<T> RemoveAt(int index);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items);
    public ImmutableSegmentedList`1<T> RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> RemoveRange(int index, int count);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue);
    public ImmutableSegmentedList`1<T> Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    public ImmutableSegmentedList`1<T> Reverse();
    public ImmutableSegmentedList`1<T> Reverse(int index, int count);
    public ImmutableSegmentedList`1<T> SetItem(int index, T value);
    public ImmutableSegmentedList`1<T> Sort();
    public ImmutableSegmentedList`1<T> Sort(IComparer`1<T> comparer);
    public ImmutableSegmentedList`1<T> Sort(Comparison`1<T> comparison);
    public ImmutableSegmentedList`1<T> Sort(int index, int count, IComparer`1<T> comparer);
    public Builder<T> ToBuilder();
    [NullableContextAttribute("0")]
private ValueBuilder<T> ToValueBuilder();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ImmutableSegmentedList`1<T> other);
    public bool TrueForAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Clear();
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Add(T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.AddRange(IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Insert(int index, T element);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.InsertRange(int index, IEnumerable`1<T> items);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Remove(T value, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAll(Predicate`1<T> match);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(IEnumerable`1<T> items, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveRange(int index, int count);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.RemoveAt(int index);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.SetItem(int index, T value);
    private sealed virtual override IImmutableList`1<T> System.Collections.Immutable.IImmutableList<T>.Replace(T oldValue, T newValue, IEqualityComparer`1<T> equalityComparer);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class Microsoft.CodeAnalysis.Collections.Internal.BitHelper : ValueType {
    private static int IntSize;
    private Span`1<int> _span;
    internal BitHelper(Span`1<int> span, bool clear);
    internal void MarkBit(int bitPosition);
    internal bool IsMarked(int bitPosition);
    internal static int ToIntArrayLength(int n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryKeyCollectionDebugView`2 : object {
    private ICollection`1<TKey> _collection;
    [DebuggerBrowsableAttribute("3")]
public TKey[] Items { get; }
    public DictionaryKeyCollectionDebugView`2(ICollection`1<TKey> collection);
    public TKey[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.DictionaryValueCollectionDebugView`2 : object {
    private ICollection`1<TValue> _collection;
    [DebuggerBrowsableAttribute("3")]
public TValue[] Items { get; }
    public DictionaryValueCollectionDebugView`2(ICollection`1<TValue> collection);
    public TValue[] get_Items();
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionArgument : Enum {
    public int value__;
    public static ExceptionArgument dictionary;
    public static ExceptionArgument array;
    public static ExceptionArgument info;
    public static ExceptionArgument key;
    public static ExceptionArgument value;
    public static ExceptionArgument startIndex;
    public static ExceptionArgument index;
    public static ExceptionArgument capacity;
    public static ExceptionArgument collection;
    public static ExceptionArgument item;
    public static ExceptionArgument converter;
    public static ExceptionArgument match;
    public static ExceptionArgument count;
    public static ExceptionArgument action;
    public static ExceptionArgument comparison;
    public static ExceptionArgument source;
    public static ExceptionArgument length;
    public static ExceptionArgument destinationArray;
    public static ExceptionArgument other;
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.ExceptionResource : Enum {
    public int value__;
    public static ExceptionResource ArgumentOutOfRange_Index;
    public static ExceptionResource ArgumentOutOfRange_Count;
    public static ExceptionResource Arg_ArrayPlusOffTooSmall;
    public static ExceptionResource Arg_RankMultiDimNotSupported;
    public static ExceptionResource Arg_NonZeroLowerBound;
    public static ExceptionResource ArgumentOutOfRange_ListInsert;
    public static ExceptionResource ArgumentOutOfRange_NeedNonNegNum;
    public static ExceptionResource ArgumentOutOfRange_SmallCapacity;
    public static ExceptionResource Argument_InvalidOffLen;
    public static ExceptionResource ArgumentOutOfRange_BiggerThanCollection;
    public static ExceptionResource NotSupported_KeyCollectionSet;
    public static ExceptionResource NotSupported_ValueCollectionSet;
    public static ExceptionResource InvalidOperation_IComparerFailed;
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.HashHelpers : object {
    public static int MaxPrimeArrayLength;
    public static int HashPrime;
    private static ImmutableArray`1<int> s_primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
    public static int ExpandPrime(int oldSize);
    public static ulong GetFastModMultiplier(UInt32 divisor);
    public static UInt32 FastMod(UInt32 value, UInt32 divisor, ulong multiplier);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls : object {
    public static bool IsSynchronized(TCollection& collection);
    public static void CopyTo(TCollection& collection, Array array, int index);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.ICollectionCalls`1 : object {
    [NullableContextAttribute("1")]
public static bool IsReadOnly(TCollection& collection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1 : object {
    private ICollection`1<T> _collection;
    [DebuggerBrowsableAttribute("3")]
public T[] Items { get; }
    public ICollectionDebugView`1(ICollection`1<T> collection);
    public T[] get_Items();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2 : object {
    private IDictionary`2<K, V> _dict;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("3")]
public KeyValuePair`2[] Items { get; }
    public IDictionaryDebugView`2(IDictionary`2<K, V> dictionary);
    public KeyValuePair`2[] get_Items();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls : object {
    [NullableContextAttribute("1")]
public static IEnumerator GetEnumerator(TEnumerable& enumerable);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.IEnumerableCalls`1 : object {
    [NullableContextAttribute("1")]
public static IEnumerator`1<T> GetEnumerator(TEnumerable& enumerable);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.IListCalls : object {
    public static object GetItem(TList& list, int index);
    public static void SetItem(TList& list, int index, object value);
    public static bool IsFixedSize(TList& list);
    public static bool IsReadOnly(TList& list);
    public static int Add(TList& list, object value);
    public static bool Contains(TList& list, object value);
    public static int IndexOf(TList& list, object value);
    public static void Insert(TList& list, int index, object value);
    public static void Remove(TList& list, object value);
}
internal enum Microsoft.CodeAnalysis.Collections.Internal.InsertionBehavior : Enum {
    public byte value__;
    public static InsertionBehavior None;
    public static InsertionBehavior OverwriteExisting;
    public static InsertionBehavior ThrowOnExisting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.RoslynUnsafe : object {
    public static T& NullRef();
    public static bool IsNullRef(T& source);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArrayHelper : object {
    internal static int IntrosortSizeThreshold;
    internal static MethodImplOptions FastPathMethodImplOptions;
    [NullableContextAttribute("2")]
internal static int GetSegmentSize();
    [NullableContextAttribute("2")]
internal static int GetSegmentShift();
    [NullableContextAttribute("2")]
internal static int GetOffsetMask();
    private static int CalculateSegmentSize(int elementSize);
    private static int CalculateSegmentShift(int segmentSize);
    private static int CalculateOffsetMask(int segmentSize);
    [CompilerGeneratedAttribute]
internal static int <CalculateSegmentSize>g__ArraySize|5_0(int elementSize, int segmentSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySegment`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private SegmentedArray`1<T> <Array>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SegmentedArray`1<T> Array { get; }
    public int Start { get; }
    public int Length { get; }
    public T& Item { get; }
    public SegmentedArraySegment`1(SegmentedArray`1<T> array, int start, int length);
    [CompilerGeneratedAttribute]
public SegmentedArray`1<T> get_Array();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_Length();
    public T& get_Item(int index);
    public SegmentedArraySegment`1<T> Slice(int start);
    public SegmentedArraySegment`1<T> Slice(int start, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    internal static void Sort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    internal static int InternalBinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static void SwapIfGreater(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<T> a, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit, Comparison`1<T> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void HeapSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, int lo, Comparison`1<T> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys, Comparison`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit, IComparer`1<TKey> comparer);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, int lo, IComparer`1<TKey> comparer);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedArraySortUtils : object {
    private static ReadOnlySpan`1<byte> Log2DeBruijn { get; }
    private static ReadOnlySpan`1<byte> get_Log2DeBruijn();
    [NullableContextAttribute("1")]
public static int MoveNansToFront(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    public static int Log2(UInt32 value);
    private static int Log2SoftwareFallback(UInt32 value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`1 : object {
    public static void Sort(SegmentedArraySegment`1<T> keys, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    private static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    private static void SwapIfGreater(T& i, T& j);
    private static void Swap(T& i, T& j);
    private static void IntroSort(SegmentedArraySegment`1<T> keys, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<T> keys);
    private static void HeapSort(SegmentedArraySegment`1<T> keys);
    private static void DownHeap(SegmentedArraySegment`1<T> keys, int i, int n, int lo);
    private static void InsertionSort(SegmentedArraySegment`1<T> keys);
    private static bool LessThan(T& left, T& right);
    private static bool GreaterThan(T& left, T& right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.SegmentedGenericArraySortHelper`2 : object {
    public static void Sort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, IComparer`1<TKey> comparer);
    private static void SwapIfGreaterWithValues(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void Swap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int j);
    private static void IntroSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int depthLimit);
    private static int PickPivotAndPartition(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void HeapSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static void DownHeap(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values, int i, int n, int lo);
    private static void InsertionSort(SegmentedArraySegment`1<TKey> keys, Span`1<TValue> values);
    private static bool LessThan(TKey& left, TKey& right);
    private static bool GreaterThan(TKey& left, TKey& right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Collections.Internal.SegmentedHashSetEqualityComparer`1 : object {
    public sealed virtual bool Equals(SegmentedHashSet`1<T> x, SegmentedHashSet`1<T> y);
    public sealed virtual int GetHashCode(SegmentedHashSet`1<T> obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.Collections.Internal.SR : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Arg_ArrayPlusOffTooSmall { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_KeyNotFoundWithKey { get; }
    internal static string Arg_LongerThanDestArray { get; }
    internal static string Arg_LongerThanSrcArray { get; }
    internal static string Arg_NonZeroLowerBound { get; }
    internal static string Arg_RankMultiDimNotSupported { get; }
    internal static string Arg_WrongType { get; }
    internal static string Argument_AddingDuplicateWithKey { get; }
    internal static string Argument_InvalidArrayType { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string ArgumentOutOfRange_ArrayLB { get; }
    internal static string ArgumentOutOfRange_BiggerThanCollection { get; }
    internal static string ArgumentOutOfRange_Count { get; }
    internal static string ArgumentOutOfRange_Index { get; }
    internal static string ArgumentOutOfRange_ListInsert { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_SmallCapacity { get; }
    internal static string InvalidOperation_ConcurrentOperationsNotSupported { get; }
    internal static string InvalidOperation_EnumFailedVersion { get; }
    internal static string InvalidOperation_EnumOpCantHappen { get; }
    internal static string InvalidOperation_IComparerFailed { get; }
    internal static string NotSupported_KeyCollectionSet { get; }
    internal static string NotSupported_ValueCollectionSet { get; }
    internal static string Rank_MustMatch { get; }
    internal static string NotSupported_FixedSizeCollection { get; }
    internal static string ArgumentException_OtherNotArrayOfCorrectLength { get; }
    internal static string Arg_BogusIComparer { get; }
    internal static string CannotFindOldValue { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Arg_ArrayPlusOffTooSmall();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_KeyNotFoundWithKey();
    internal static string get_Arg_LongerThanDestArray();
    internal static string get_Arg_LongerThanSrcArray();
    internal static string get_Arg_NonZeroLowerBound();
    internal static string get_Arg_RankMultiDimNotSupported();
    internal static string get_Arg_WrongType();
    internal static string get_Argument_AddingDuplicateWithKey();
    internal static string get_Argument_InvalidArrayType();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_ArgumentOutOfRange_ArrayLB();
    internal static string get_ArgumentOutOfRange_BiggerThanCollection();
    internal static string get_ArgumentOutOfRange_Count();
    internal static string get_ArgumentOutOfRange_Index();
    internal static string get_ArgumentOutOfRange_ListInsert();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_SmallCapacity();
    internal static string get_InvalidOperation_ConcurrentOperationsNotSupported();
    internal static string get_InvalidOperation_EnumFailedVersion();
    internal static string get_InvalidOperation_EnumOpCantHappen();
    internal static string get_InvalidOperation_IComparerFailed();
    internal static string get_NotSupported_KeyCollectionSet();
    internal static string get_NotSupported_ValueCollectionSet();
    internal static string get_Rank_MustMatch();
    internal static string get_NotSupported_FixedSizeCollection();
    internal static string get_ArgumentException_OtherNotArrayOfCorrectLength();
    internal static string get_Arg_BogusIComparer();
    internal static string get_CannotFindOldValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.Internal.ThrowHelper : object {
    [DoesNotReturnAttribute]
internal static void ThrowIndexOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException();
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRange_IndexException();
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
internal static void ThrowArgumentException_BadComparer(object comparer);
    [DoesNotReturnAttribute]
internal static void ThrowIndexArgumentOutOfRange_NeedNonNegNumException();
    [DoesNotReturnAttribute]
internal static void ThrowLengthArgumentOutOfRange_ArgumentOutOfRange_NeedNonNegNum();
    [DoesNotReturnAttribute]
internal static void ThrowStartIndexArgumentOutOfRange_ArgumentOutOfRange_Index();
    [DoesNotReturnAttribute]
internal static void ThrowCountArgumentOutOfRange_ArgumentOutOfRange_Count();
    [DoesNotReturnAttribute]
internal static void ThrowWrongKeyTypeArgumentException(T key, Type targetType);
    [DoesNotReturnAttribute]
internal static void ThrowWrongValueTypeArgumentException(T value, Type targetType);
    private static ArgumentException GetAddingDuplicateWithKeyArgumentException(object key);
    [DoesNotReturnAttribute]
internal static void ThrowAddingDuplicateWithKeyArgumentException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowKeyNotFoundException(T key);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException(ExceptionResource resource);
    private static ArgumentNullException GetArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentNullException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException(ExceptionResource resource, Exception e);
    [DoesNotReturnAttribute]
internal static void ThrowNotSupportedException(ExceptionResource resource);
    [DoesNotReturnAttribute]
internal static void ThrowArgumentException_Argument_InvalidArrayType();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumFailedVersion();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_InvalidOperation_EnumOpCantHappen();
    [DoesNotReturnAttribute]
internal static void ThrowInvalidOperationException_ConcurrentOperationsNotSupported();
    private static ArgumentException GetArgumentException(ExceptionResource resource);
    private static ArgumentException GetWrongKeyTypeArgumentException(object key, Type targetType);
    private static ArgumentException GetWrongValueTypeArgumentException(object value, Type targetType);
    private static KeyNotFoundException GetKeyNotFoundException(object key);
    private static ArgumentOutOfRangeException GetArgumentOutOfRangeException(ExceptionArgument argument, ExceptionResource resource);
    [NullableContextAttribute("2")]
internal static void IfNullAndNullsAreIllegalThenThrow(object value, ExceptionArgument argName);
    private static string GetArgumentName(ExceptionArgument argument);
    private static string GetResourceString(ExceptionResource resource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> _pool;
    private static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> s_poolInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Dictionary`2<K, ValueSet<K, V>> s_emptyDictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private PooledDictionary`2<K, ValueSet<K, V>> _dictionary;
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<V> Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    private OrderPreservingMultiDictionary`2(ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> pool);
    private static OrderPreservingMultiDictionary`2();
    public void Free();
    public static ObjectPool`1<OrderPreservingMultiDictionary`2<K, V>> CreatePool();
    public static OrderPreservingMultiDictionary`2<K, V> GetInstance();
    private void EnsureDictionary();
    public bool get_IsEmpty();
    public void Add(K k, V v);
    public bool TryGetValue(K key, Func`3<V, TArg, bool> predicate, TArg arg, V& value);
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Microsoft.CodeAnalysis.Collections.OrderPreservingMultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<V> get_Item(K k);
    public bool Contains(K key, V value);
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Collections.RoslynImmutableInterlocked : object {
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`2<ImmutableSegmentedList`1<T>, ImmutableSegmentedList`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedList`1& location, Func`3<ImmutableSegmentedList`1<T>, TArg, ImmutableSegmentedList`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedList`1<T> InterlockedCompareExchange(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value, ImmutableSegmentedList`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedList`1& location, ImmutableSegmentedList`1<T> value);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`2<ImmutableSegmentedHashSet`1<T>, ImmutableSegmentedHashSet`1<T>> transformer);
    [NullableContextAttribute("2")]
public static bool Update(ImmutableSegmentedHashSet`1& location, Func`3<ImmutableSegmentedHashSet`1<T>, TArg, ImmutableSegmentedHashSet`1<T>> transformer, TArg transformerArgument);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    [NullableContextAttribute("2")]
public static ImmutableSegmentedHashSet`1<T> InterlockedCompareExchange(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value, ImmutableSegmentedHashSet`1<T> comparand);
    [NullableContextAttribute("2")]
public static bool InterlockedInitialize(ImmutableSegmentedHashSet`1& location, ImmutableSegmentedHashSet`1<T> value);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`2<ImmutableSegmentedDictionary`2<TKey, TValue>, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer);
    public static bool Update(ImmutableSegmentedDictionary`2& location, Func`3<ImmutableSegmentedDictionary`2<TKey, TValue>, TArg, ImmutableSegmentedDictionary`2<TKey, TValue>> transformer, TArg transformerArgument);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static ImmutableSegmentedDictionary`2<TKey, TValue> InterlockedCompareExchange(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value, ImmutableSegmentedDictionary`2<TKey, TValue> comparand);
    public static bool InterlockedInitialize(ImmutableSegmentedDictionary`2& location, ImmutableSegmentedDictionary`2<TKey, TValue> value);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> valueFactory);
    public static TValue GetOrAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, Func`2<TKey, TValue> addValueFactory, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static TValue AddOrUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue addValue, Func`3<TKey, TValue, TValue> updateValueFactory);
    public static bool TryAdd(ImmutableSegmentedDictionary`2& location, TKey key, TValue value);
    public static bool TryUpdate(ImmutableSegmentedDictionary`2& location, TKey key, TValue newValue, TValue comparisonValue);
    public static bool TryRemove(ImmutableSegmentedDictionary`2& location, TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Collections.SegmentedArray : object {
    [NullableContextAttribute("2")]
internal static void Clear(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
internal static void Copy(SegmentedArray`1<T> sourceArray, SegmentedArray`1<T> destinationArray, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, Array destinationArray, int length);
    [NullableContextAttribute("2")]
public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, SegmentedArray`1<T> destinationArray, int destinationIndex, int length);
    [NullableContextAttribute("2")]
private static void CopyOverlapped(SegmentedArray`1<T> array, int sourceIndex, int destinationIndex, int length);
    public static void Copy(SegmentedArray`1<T> sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static int BinarySearch(SegmentedArray`1<T> array, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, T value, IComparer`1<T> comparer);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value);
    public static int BinarySearch(SegmentedArray`1<T> array, int index, int length, T value, IComparer`1<T> comparer);
    public static int IndexOf(SegmentedArray`1<T> array, T value);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int IndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count);
    public static int LastIndexOf(SegmentedArray`1<T> array, T value, int startIndex, int count, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Reverse(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(SegmentedArray`1<T> array, int index, int length, IComparer`1<T> comparer);
    public static void Sort(SegmentedArray`1<T> array, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static SegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> array, int offset, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegments(SegmentedArray`1<T> first, SegmentedArray`1<T> second, int length);
    [NullableContextAttribute("2")]
private static AlignedSegmentEnumerable`1<T> GetSegmentsAligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
    [NullableContextAttribute("2")]
private static UnalignedSegmentEnumerable`1<T> GetSegmentsUnaligned(SegmentedArray`1<T> first, int firstOffset, SegmentedArray`1<T> second, int secondOffset, int length);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedArray`1 : ValueType {
    private int _length;
    private T[][] _items;
    private static int SegmentSize { get; }
    private static int SegmentShift { get; }
    private static int OffsetMask { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public object SyncRoot { get; }
    public T& Item { get; }
    private int System.Collections.ICollection.Count { get; }
    private int System.Collections.Generic.ICollection<T>.Count { get; }
    private int System.Collections.Generic.IReadOnlyCollection<T>.Count { get; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedArray`1(int length);
    private SegmentedArray`1(int length, T[][] items);
    private static int get_SegmentSize();
    private static int get_SegmentShift();
    private static int get_OffsetMask();
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public sealed virtual object get_SyncRoot();
    public T& get_Item(int index);
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override int System.Collections.Generic.ICollection<T>.get_Count();
    private sealed virtual override int System.Collections.Generic.IReadOnlyCollection<T>.get_Count();
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual object Clone();
    public sealed virtual void CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(SegmentedArray`1<T> other);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T value);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    [NullableContextAttribute("0")]
internal TestAccessor<T> GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.IDictionaryDebugView`2")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedDictionary`2 : object {
    private static bool SupportsComparerDevirtualization;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<TKey, TValue>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<TKey> _comparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private KeyCollection<TKey, TValue> _keys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueCollection<TKey, TValue> _values;
    private static int StartOfFreeList;
    public IEqualityComparer`1<TKey> Comparer { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<TKey, TValue> Keys { get; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<TKey, TValue> Values { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    public TValue Item { get; public set; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    public SegmentedDictionary`2(int capacity);
    public SegmentedDictionary`2(IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public SegmentedDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection);
    public SegmentedDictionary`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> collection, IEqualityComparer`1<TKey> comparer);
    public IEqualityComparer`1<TKey> get_Comparer();
    public sealed virtual int get_Count();
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public ValueCollection<TKey, TValue> get_Values();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(TKey key, TValue value);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(TKey key);
    public bool ContainsValue(TValue value);
    private void CopyTo(KeyValuePair`2[] array, int index);
    [NullableContextAttribute("0")]
public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private TValue& FindValue(TKey key);
    private int Initialize(int capacity);
    private bool TryInsert(TKey key, TValue value, InsertionBehavior behavior);
    private void Resize();
    private void Resize(int newSize);
    public sealed virtual bool Remove(TKey key);
    public bool Remove(TKey key, TValue& value);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public bool TryAdd(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public int EnsureCapacity(int capacity);
    public void TrimExcess();
    public void TrimExcess(int capacity);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private static bool IsCompatibleKey(object key);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private Int32& GetBucket(UInt32 hashCode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedHashSet`1 : object {
    private static bool SupportsComparerDevirtualization;
    private static int StackAllocThreshold;
    private static int ShrinkThreshold;
    private static int StartOfFreeList;
    [NullableAttribute("0")]
private SegmentedArray`1<int> _buckets;
    [NullableAttribute("0")]
private SegmentedArray`1<Entry<T>> _entries;
    private ulong _fastModMultiplier;
    private int _count;
    private int _freeList;
    private int _freeCount;
    private int _version;
    private IEqualityComparer`1<T> _comparer;
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public IEqualityComparer`1<T> Comparer { get; }
    public SegmentedHashSet`1(IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity);
    public SegmentedHashSet`1(IEnumerable`1<T> collection);
    public SegmentedHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public SegmentedHashSet`1(int capacity, IEqualityComparer`1<T> comparer);
    private void ConstructFrom(SegmentedHashSet`1<T> source);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    private int FindItemIndex(T item);
    private Int32& GetBucketRef(int hashCode);
    public sealed virtual bool Remove(T item);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool Add(T item);
    public bool TryGetValue(T equalValue, T& actualValue);
    public sealed virtual void UnionWith(IEnumerable`1<T> other);
    public sealed virtual void IntersectWith(IEnumerable`1<T> other);
    public sealed virtual void ExceptWith(IEnumerable`1<T> other);
    public sealed virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public sealed virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public sealed virtual bool Overlaps(IEnumerable`1<T> other);
    public sealed virtual bool SetEquals(IEnumerable`1<T> other);
    public void CopyTo(T[] array);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public void CopyTo(T[] array, int arrayIndex, int count);
    public int RemoveWhere(Predicate`1<T> match);
    public IEqualityComparer`1<T> get_Comparer();
    public int EnsureCapacity(int capacity);
    private void Resize();
    private void Resize(int newSize);
    public void TrimExcess();
    public static IEqualityComparer`1<SegmentedHashSet`1<T>> CreateSetComparer();
    private int Initialize(int capacity);
    private bool AddIfNotPresent(T value, Int32& location);
    private bool ContainsAllElements(IEnumerable`1<T> other);
    internal bool IsSubsetOfHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithHashSetWithSameComparer(SegmentedHashSet`1<T> other);
    private void IntersectWithEnumerable(IEnumerable`1<T> other);
    private void SymmetricExceptWithUniqueHashSet(SegmentedHashSet`1<T> other);
    private void SymmetricExceptWithEnumerable(IEnumerable`1<T> other);
    [NullableContextAttribute("0")]
private ValueTuple`2<int, int> CheckUniqueAndUnfoundElements(IEnumerable`1<T> other, bool returnIfUnfound);
    internal static bool EqualityComparersAreEqual(SegmentedHashSet`1<T> set1, SegmentedHashSet`1<T> set2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.Collections.Internal.ICollectionDebugView`1")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.CodeAnalysis.Collections.SegmentedList`1 : object {
    private static int DefaultCapacity;
    private static int MaxArrayLength;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal SegmentedArray`1<T> _items;
    internal int _size;
    private int _version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static SegmentedArray`1<T> s_emptyArray;
    public int Capacity { get; public set; }
    public int Count { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    public T Item { get; public set; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public SegmentedList`1(int capacity);
    public SegmentedList`1(IEnumerable`1<T> collection);
    private static SegmentedList`1();
    public int get_Capacity();
    public void set_Capacity(int value);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    [NullableContextAttribute("2")]
private static bool IsCompatibleObject(object value);
    [NullableContextAttribute("2")]
private sealed virtual override object System.Collections.IList.get_Item(int index);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    private void AddWithResize(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.Add(object item);
    public void AddRange(IEnumerable`1<T> collection);
    public ReadOnlyCollection`1<T> AsReadOnly();
    public int BinarySearch(int index, int count, T item, IComparer`1<T> comparer);
    public int BinarySearch(T item);
    public int BinarySearch(T item, IComparer`1<T> comparer);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.IList.Contains(object item);
    public SegmentedList`1<TOutput> ConvertAll(Converter`2<T, TOutput> converter);
    public void CopyTo(T[] array);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int arrayIndex);
    public void CopyTo(int index, T[] array, int arrayIndex, int count);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    private void EnsureCapacity(int min);
    public bool Exists(Predicate`1<T> match);
    public T Find(Predicate`1<T> match);
    public SegmentedList`1<T> FindAll(Predicate`1<T> match);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public T FindLast(Predicate`1<T> match);
    public int FindLastIndex(Predicate`1<T> match);
    public int FindLastIndex(int startIndex, Predicate`1<T> match);
    public int FindLastIndex(int startIndex, int count, Predicate`1<T> match);
    public void ForEach(Action`1<T> action);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public SegmentedList`1<T> GetRange(int index, int count);
    public sealed virtual int IndexOf(T item);
    [NullableContextAttribute("2")]
private sealed virtual override int System.Collections.IList.IndexOf(object item);
    public int IndexOf(T item, int index);
    public int IndexOf(T item, int index, int count);
    public int IndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual void Insert(int index, T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Insert(int index, object item);
    public void InsertRange(int index, IEnumerable`1<T> collection);
    public int LastIndexOf(T item);
    public int LastIndexOf(T item, int index);
    public int LastIndexOf(T item, int index, int count);
    public int LastIndexOf(T item, int index, int count, IEqualityComparer`1<T> comparer);
    public sealed virtual bool Remove(T item);
    [NullableContextAttribute("2")]
private sealed virtual override void System.Collections.IList.Remove(object item);
    public int RemoveAll(Predicate`1<T> match);
    public sealed virtual void RemoveAt(int index);
    public void RemoveRange(int index, int count);
    public void Reverse();
    public void Reverse(int index, int count);
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(int index, int count, IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> comparison);
    public T[] ToArray();
    public void TrimExcess();
    public bool TrueForAll(Predicate`1<T> match);
}
public static class Microsoft.CodeAnalysis.CommandLineProject : object {
    private static Char[] s_folderSplitters;
    private static CommandLineProject();
    public static ProjectInfo CreateProjectInfo(string projectName, string language, IEnumerable`1<string> commandLineArgs, string projectDirectory, Workspace workspace);
    public static ProjectInfo CreateProjectInfo(string projectName, string language, string commandLine, string baseDirectory, Workspace workspace);
    private static IList`1<string> GetFolders(string path);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.CompilationOutputInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    public string AssemblyPath { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    internal CompilationOutputInfo(string assemblyPath);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public CompilationOutputInfo WithAssemblyPath(string path);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CompilationOutputInfo other);
    public virtual int GetHashCode();
    public static bool op_Equality(CompilationOutputInfo& left, CompilationOutputInfo& right);
    public static bool op_Inequality(CompilationOutputInfo& left, CompilationOutputInfo& right);
    [NullableContextAttribute("1")]
private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    [NullableContextAttribute("1")]
internal static CompilationOutputInfo ReadFrom(ObjectReader reader);
}
internal static class Microsoft.CodeAnalysis.CompilerExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Absolute_path_expected { get; }
    internal static string An_element_with_the_same_key_but_a_different_value_already_exists { get; }
    internal static string Organize_usings { get; }
    internal static string this_dot_and_Me_dot_preferences { get; }
    internal static string Language_keywords_vs_BCL_types_preferences { get; }
    internal static string Parentheses_preferences { get; }
    internal static string Modifier_preferences { get; }
    internal static string Expression_level_preferences { get; }
    internal static string Field_preferences { get; }
    internal static string Parameter_preferences { get; }
    internal static string Suppression_preferences { get; }
    internal static string Pascal_Case { get; }
    internal static string Abstract_Method { get; }
    internal static string Begins_with_I { get; }
    internal static string Class { get; }
    internal static string Delegate { get; }
    internal static string Enum { get; }
    internal static string Event { get; }
    internal static string Interface { get; }
    internal static string Non_Field_Members { get; }
    internal static string Private_Method { get; }
    internal static string Private_or_Internal_Field { get; }
    internal static string Private_or_Internal_Static_Field { get; }
    internal static string Property { get; }
    internal static string Public_or_Protected_Field { get; }
    internal static string Static_Field { get; }
    internal static string Static_Method { get; }
    internal static string Struct { get; }
    internal static string Types { get; }
    internal static string Method { get; }
    internal static string Missing_prefix_colon_0 { get; }
    internal static string Missing_suffix_colon_0 { get; }
    internal static string Prefix_0_does_not_match_expected_prefix_1 { get; }
    internal static string Prefix_0_is_not_expected { get; }
    internal static string These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0 { get; }
    internal static string These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0 { get; }
    internal static string These_words_cannot_contain_lower_case_characters_colon_0 { get; }
    internal static string These_words_cannot_contain_upper_case_characters_colon_0 { get; }
    internal static string These_words_must_begin_with_upper_case_characters_colon_0 { get; }
    internal static string The_first_word_0_must_begin_with_an_upper_case_character { get; }
    internal static string The_first_word_0_must_begin_with_a_lower_case_character { get; }
    internal static string Cast_is_redundant { get; }
    internal static string Naming_styles { get; }
    internal static string Naming_rules { get; }
    internal static string Symbol_specifications { get; }
    internal static string Specified_sequence_has_duplicate_items { get; }
    internal static string Segment_size_must_be_power_of_2_greater_than_1 { get; }
    internal static string New_line_preferences { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Absolute_path_expected();
    internal static string get_An_element_with_the_same_key_but_a_different_value_already_exists();
    internal static string get_Organize_usings();
    internal static string get_this_dot_and_Me_dot_preferences();
    internal static string get_Language_keywords_vs_BCL_types_preferences();
    internal static string get_Parentheses_preferences();
    internal static string get_Modifier_preferences();
    internal static string get_Expression_level_preferences();
    internal static string get_Field_preferences();
    internal static string get_Parameter_preferences();
    internal static string get_Suppression_preferences();
    internal static string get_Pascal_Case();
    internal static string get_Abstract_Method();
    internal static string get_Begins_with_I();
    internal static string get_Class();
    internal static string get_Delegate();
    internal static string get_Enum();
    internal static string get_Event();
    internal static string get_Interface();
    internal static string get_Non_Field_Members();
    internal static string get_Private_Method();
    internal static string get_Private_or_Internal_Field();
    internal static string get_Private_or_Internal_Static_Field();
    internal static string get_Property();
    internal static string get_Public_or_Protected_Field();
    internal static string get_Static_Field();
    internal static string get_Static_Method();
    internal static string get_Struct();
    internal static string get_Types();
    internal static string get_Method();
    internal static string get_Missing_prefix_colon_0();
    internal static string get_Missing_suffix_colon_0();
    internal static string get_Prefix_0_does_not_match_expected_prefix_1();
    internal static string get_Prefix_0_is_not_expected();
    internal static string get_These_non_leading_words_must_begin_with_an_upper_case_letter_colon_0();
    internal static string get_These_non_leading_words_must_begin_with_a_lowercase_letter_colon_0();
    internal static string get_These_words_cannot_contain_lower_case_characters_colon_0();
    internal static string get_These_words_cannot_contain_upper_case_characters_colon_0();
    internal static string get_These_words_must_begin_with_upper_case_characters_colon_0();
    internal static string get_The_first_word_0_must_begin_with_an_upper_case_character();
    internal static string get_The_first_word_0_must_begin_with_a_lower_case_character();
    internal static string get_Cast_is_redundant();
    internal static string get_Naming_styles();
    internal static string get_Naming_rules();
    internal static string get_Symbol_specifications();
    internal static string get_Specified_sequence_has_duplicate_items();
    internal static string get_Segment_size_must_be_power_of_2_greater_than_1();
    internal static string get_New_line_preferences();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DefaultAnalyzerAssemblyLoader : AnalyzerAssemblyLoader {
    private object _guard;
    private Dictionary`2<AssemblyIdentity, Assembly> _loadedAssembliesByIdentity;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, AssemblyIdentity> _loadedAssemblyIdentitiesByPath;
    private int _hookedAssemblyResolve;
    protected virtual Assembly LoadFromPathUncheckedImpl(string fullPath);
    private Assembly CurrentDomain_AssemblyResolve(object sender, ResolveEventArgs args);
    private AssemblyIdentity GetOrAddAssemblyIdentity(string fullPath);
    private Assembly GetOrLoad(string displayName);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.IDocumentTextDifferencingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService : object {
    [NullableContextAttribute("1")]
public sealed virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DefaultDocumentTextDifferencingService/<GetTextChangesAsync>d__2")]
public sealed virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, TextDifferenceTypes preferredDifferenceType, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.ISupportedChangesService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.DefaultSupportedChangesServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.DefaultTextDocumentServiceProvider : object {
    public static DefaultTextDocumentServiceProvider Instance;
    private static DefaultTextDocumentServiceProvider();
    public sealed virtual TService GetService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DeferredDocumentationProvider : DocumentationProvider {
    private Compilation _compilation;
    public DeferredDocumentationProvider(Compilation compilation);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class Microsoft.CodeAnalysis.DiagnosticProvider : object {
    public static void Enable(Workspace workspace, Options options);
    public static void Disable(Workspace workspace);
    private static OptionSet GetOptions(Workspace workspace, Options options);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.AbstractDiagnosticPropertiesService : object {
    public sealed virtual ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic);
    protected abstract virtual Compilation GetCompilation();
    private static ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.AdditionalTextWithState : AdditionalText {
    private AdditionalDocumentState _documentState;
    public string Path { get; }
    public AdditionalTextWithState(AdditionalDocumentState documentState);
    public virtual string get_Path();
    public virtual SourceText GetText(CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.AnalysisKind : Enum {
    public int value__;
    public static AnalysisKind Syntax;
    public static AnalysisKind Semantic;
    public static AnalysisKind NonLocal;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.AccessibilityExtensions : object {
    [ExtensionAttribute]
internal static bool MatchesSymbol(Accessibility accessibility, ISymbol symbol);
    [ExtensionAttribute]
internal static XElement CreateXElement(Accessibility accessibility);
    internal static Accessibility FromXElement(XElement accessibilityElement);
    private static Accessibility GetAccessibility(ISymbol symbol);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.Capitalization : Enum {
    public byte value__;
    public static Capitalization PascalCase;
    public static Capitalization CamelCase;
    public static Capitalization FirstUpper;
    public static Capitalization AllUpper;
    public static Capitalization AllLower;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.EditorConfigNamingStyleParser : object {
    private static SymbolKindOrTypeKind _namespace;
    private static SymbolKindOrTypeKind _class;
    private static SymbolKindOrTypeKind _struct;
    private static SymbolKindOrTypeKind _interface;
    private static SymbolKindOrTypeKind _enum;
    private static SymbolKindOrTypeKind _property;
    private static SymbolKindOrTypeKind _method;
    private static SymbolKindOrTypeKind _localFunction;
    private static SymbolKindOrTypeKind _field;
    private static SymbolKindOrTypeKind _event;
    private static SymbolKindOrTypeKind _delegate;
    private static SymbolKindOrTypeKind _parameter;
    private static SymbolKindOrTypeKind _typeParameter;
    private static SymbolKindOrTypeKind _local;
    [NullableAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> _all;
    [NullableAttribute("0")]
private static ImmutableArray`1<Accessibility> s_allAccessibility;
    private static ModifierKind s_abstractModifierKind;
    private static ModifierKind s_asyncModifierKind;
    private static ModifierKind s_constModifierKind;
    private static ModifierKind s_readonlyModifierKind;
    private static ModifierKind s_staticModifierKind;
    [NullableAttribute("0")]
private static ImmutableArray`1<ModifierKind> _allModifierKind;
    private static EditorConfigNamingStyleParser();
    public static NamingStylePreferences ParseDictionary(AnalyzerConfigOptions allRawConventions);
    internal static Dictionary`2<string, string> TrimDictionary(AnalyzerConfigOptions allRawConventions);
    public static IEnumerable`1<string> GetRuleTitles(IReadOnlyDictionary`2<string, T> allRawConventions);
    private static bool TryGetSerializableNamingRule(string namingRuleTitle, SymbolSpecification symbolSpec, NamingStyle namingStyle, IReadOnlyDictionary`2<string, string> conventionsDictionary, SerializableNamingRule& serializableNamingRule);
    [NullableContextAttribute("0")]
internal static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> conventionsDictionary, ValueTuple`2& value);
    private static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, string> conventionsDictionary, ReportDiagnostic& severity);
    private static bool TryGetRuleSeverity(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, string> valueSelector, Func`2<T, V> partSelector, ValueTuple`2& value);
    private static ReportDiagnostic ParseEnforcementLevel(string ruleSeverity);
    internal static bool TryGetNamingStyleData(Section section, string namingRuleName, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties, NamingScheme& namingScheme);
    private static bool TryGetNamingStyleData(string namingRuleName, IReadOnlyDictionary`2<string, string> rawOptions, NamingStyle& namingStyle);
    private static bool TryGetNamingStyleData(string namingRuleName, IReadOnlyDictionary`2<string, T> rawOptions, Func`2<T, string> nameSelector, Func`2<T, TData> dataSelector, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`6<ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<string, TData>, ValueTuple`2<Capitalization, TData>, TResult> constructor, TResult& namingStyle);
    private static bool TryGetNamingStyleTitle(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, string> nameSelector, Func`2<T, TData> dataSelector, ValueTuple`2& result);
    private static ValueTuple`2<string, TData> GetNamingRequiredPrefix(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static ValueTuple`2<string, TData> GetNamingRequiredSuffix(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static ValueTuple`2<string, TData> GetNamingWordSeparator(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static bool TryGetNamingCapitalization(string namingStyleName, IReadOnlyDictionary`2<string, T> properties, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, ValueTuple`2& result);
    private static ValueTuple`2<string, TData> GetValueFromDictionary(string namingStyleName, string optionName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector);
    private static bool TryParseCapitalizationScheme(string namingStyleCapitalization, Nullable`1& capitalization);
    [ExtensionAttribute]
public static string ToEditorConfigString(Capitalization capitalization);
    internal static bool TryGetSymbolSpec(Section section, string namingRuleTitle, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties, ApplicableSymbolInfo& applicableSymbolInfo);
    private static bool TryGetSymbolSpec(string namingRuleTitle, IReadOnlyDictionary`2<string, string> conventionsDictionary, SymbolSpecification& symbolSpec);
    [NullableContextAttribute("2")]
private static bool TryGetSymbolSpec(string namingRuleTitle, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue, Func`5<ValueTuple`2<string, TData>, ValueTuple`2<ImmutableArray`1<SymbolKindOrTypeKind>, TData>, ValueTuple`2<ImmutableArray`1<Accessibility>, TData>, ValueTuple`2<ImmutableArray`1<ModifierKind>, TData>, TResult> constructor, TResult& symbolSpec);
    private static bool TryGetSymbolSpecNameForNamingRule(string namingRuleName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, ValueTuple`2& result);
    private static ValueTuple`2<ImmutableArray`1<SymbolKindOrTypeKind>, TData> GetSymbolsApplicableKinds(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SymbolKindOrTypeKind> ParseSymbolKindList(string symbolSpecApplicableKinds);
    private static ValueTuple`2<ImmutableArray`1<Accessibility>, TData> GetSymbolsApplicableAccessibilities(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<Accessibility> ParseAccessibilityKindList(string symbolSpecApplicableAccessibilities);
    private static ValueTuple`2<ImmutableArray`1<ModifierKind>, TData> GetSymbolsRequiredModifiers(string symbolSpecName, IReadOnlyDictionary`2<string, T> conventionsDictionary, Func`2<T, ValueTuple`2<string, TData>> tupleSelector, Func`1<TData> defaultValue);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<ModifierKind> ParseModifiers(string symbolSpecRequiredModifiers);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<SymbolKindOrTypeKind> symbols);
    [ExtensionAttribute]
private static string ToEditorConfigString(SymbolKindOrTypeKind symbol);
    [ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<Accessibility> accessibilities, string languageName);
    [ExtensionAttribute]
private static string ToEditorConfigString(Accessibility accessibility, string languageName);
    [ExtensionAttribute]
public static string ToEditorConfigString(ImmutableArray`1<ModifierKind> modifiers, string languageName);
    [ExtensionAttribute]
private static string ToEditorConfigString(ModifierKind modifier, string languageName);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.MutableNamingStyle : object {
    [CompilerGeneratedAttribute]
private NamingStyle <NamingStyle>k__BackingField;
    public NamingStyle NamingStyle { get; private set; }
    public Guid ID { get; }
    public string Name { get; public set; }
    public string Prefix { get; public set; }
    public string Suffix { get; public set; }
    public string WordSeparator { get; public set; }
    public Capitalization CapitalizationScheme { get; public set; }
    public MutableNamingStyle(NamingStyle namingStyle);
    [CompilerGeneratedAttribute]
public NamingStyle get_NamingStyle();
    [CompilerGeneratedAttribute]
private void set_NamingStyle(NamingStyle value);
    public Guid get_ID();
    public string get_Name();
    public void set_Name(string value);
    public string get_Prefix();
    public void set_Prefix(string value);
    public string get_Suffix();
    public void set_Suffix(string value);
    public string get_WordSeparator();
    public void set_WordSeparator(string value);
    public Capitalization get_CapitalizationScheme();
    public void set_CapitalizationScheme(Capitalization value);
    internal MutableNamingStyle Clone();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingRule : ValueType {
    public SymbolSpecification SymbolSpecification;
    public NamingStyle NamingStyle;
    public ReportDiagnostic EnforcementLevel;
    public NamingRule(SymbolSpecification symbolSpecification, NamingStyle namingStyle, ReportDiagnostic enforcementLevel);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStylePreferences : object {
    private static int s_serializationVersion;
    [DataMemberAttribute]
public ImmutableArray`1<SymbolSpecification> SymbolSpecifications;
    [DataMemberAttribute]
public ImmutableArray`1<NamingStyle> NamingStyles;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableNamingRule> NamingRules;
    private Lazy`1<NamingStyleRules> _lazyRules;
    private static string _defaultNamingPreferencesString;
    public static NamingStylePreferences Default { get; }
    public static NamingStylePreferences Empty { get; }
    public static string DefaultNamingPreferencesString { get; }
    public bool IsEmpty { get; }
    public NamingStyleRules Rules { get; }
    public NamingStylePreferences(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles, ImmutableArray`1<SerializableNamingRule> namingRules);
    private static NamingStylePreferences();
    public static NamingStylePreferences get_Default();
    public static NamingStylePreferences get_Empty();
    public static string get_DefaultNamingPreferencesString();
    public bool get_IsEmpty();
    internal NamingStyle GetNamingStyle(Guid namingStyleID);
    internal SymbolSpecification GetSymbolSpecification(Guid symbolSpecificationID);
    public NamingStyleRules get_Rules();
    public NamingStyleRules CreateRules();
    internal XElement CreateXElement();
    internal static NamingStylePreferences FromXElement(XElement element);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(NamingStylePreferences other);
    public static bool op_Equality(NamingStylePreferences left, NamingStylePreferences right);
    public static bool op_Inequality(NamingStylePreferences left, NamingStylePreferences right);
    public virtual int GetHashCode();
    private static XElement GetUpgradedSerializationIfNecessary(XElement rootElement);
    private static void UpgradeSerialization_4To5(XElement rootElement);
    [CompilerGeneratedAttribute]
private NamingRule <CreateRules>b__18_0(SerializableNamingRule r);
}
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.NamingStyleRules : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<NamingRule> <NamingRules>k__BackingField;
    private ImmutableArray`1<SymbolKind> _symbolKindsThatCanBeOverridden;
    public ImmutableArray`1<NamingRule> NamingRules { get; }
    public NamingStyleRules(ImmutableArray`1<NamingRule> namingRules);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<NamingRule> get_NamingRules();
    internal bool TryGetApplicableRule(ISymbol symbol, NamingRule& applicableRule);
    private bool IsSymbolNameAnalyzable(ISymbol symbol);
    private static bool DoesSymbolImplementAnotherSymbol(ISymbol symbol);
    private static bool IsInterfaceImplementation(ISymbol symbol);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SerializableNamingRule : object {
    [CompilerGeneratedAttribute]
private Guid <SymbolSpecificationID>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <NamingStyleID>k__BackingField;
    [CompilerGeneratedAttribute]
private ReportDiagnostic <EnforcementLevel>k__BackingField;
    [NullableAttribute("1")]
private Type EqualityContract { get; }
    [DataMemberAttribute]
public Guid SymbolSpecificationID { get; public set; }
    [DataMemberAttribute]
public Guid NamingStyleID { get; public set; }
    [DataMemberAttribute]
public ReportDiagnostic EnforcementLevel { get; public set; }
    public bool ShouldReuseInSerialization { get; }
    [CompilerGeneratedAttribute]
private SerializableNamingRule(SerializableNamingRule original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Guid get_SymbolSpecificationID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolSpecificationID(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_NamingStyleID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingStyleID(Guid value);
    [CompilerGeneratedAttribute]
public ReportDiagnostic get_EnforcementLevel();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnforcementLevel(ReportDiagnostic value);
    public NamingRule GetRule(NamingStylePreferences info);
    internal XElement CreateXElement();
    internal static SerializableNamingRule FromXElement(XElement namingRuleElement);
    public sealed virtual bool get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    public static SerializableNamingRule ReadFrom(ObjectReader reader);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SerializableNamingRule left, SerializableNamingRule right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SerializableNamingRule left, SerializableNamingRule right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SerializableNamingRule other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public SerializableNamingRule <Clone>$();
}
[DataContractAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
internal class Microsoft.CodeAnalysis.Diagnostics.Analyzers.NamingStyles.SymbolSpecification : object {
    private static SymbolSpecification DefaultSymbolSpecificationTemplate;
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<SymbolKindOrTypeKind> <ApplicableSymbolKindList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<Accessibility> <ApplicableAccessibilityList>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ModifierKind> <RequiredModifierList>k__BackingField;
    [DataMemberAttribute]
public Guid ID { get; }
    [DataMemberAttribute]
public string Name { get; }
    [DataMemberAttribute]
public ImmutableArray`1<SymbolKindOrTypeKind> ApplicableSymbolKindList { get; }
    [DataMemberAttribute]
public ImmutableArray`1<Accessibility> ApplicableAccessibilityList { get; }
    [DataMemberAttribute]
public ImmutableArray`1<ModifierKind> RequiredModifierList { get; }
    public bool ShouldReuseInSerialization { get; }
    public SymbolSpecification(Guid id, string name, ImmutableArray`1<SymbolKindOrTypeKind> symbolKindList, ImmutableArray`1<Accessibility> accessibilityList, ImmutableArray`1<ModifierKind> modifiers);
    private static SymbolSpecification();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<SymbolKindOrTypeKind> get_ApplicableSymbolKindList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<Accessibility> get_ApplicableAccessibilityList();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ModifierKind> get_RequiredModifierList();
    private string GetDebuggerDisplay();
    public static SymbolSpecification CreateDefaultSymbolSpecification();
    public bool AppliesTo(ISymbol symbol);
    public bool AppliesTo(SymbolKind symbolKind, Accessibility accessibility);
    public bool AppliesTo(SymbolKindOrTypeKind kind, DeclarationModifiers modifiers, Nullable`1<Accessibility> accessibility);
    private static DeclarationModifiers CollapseModifiers(ImmutableArray`1<ModifierKind> requiredModifierList);
    private static bool AnyMatches(ImmutableArray`1<TSymbolMatcher> matchers, ISymbol symbol);
    private static bool AnyMatches(ImmutableArray`1<Accessibility> matchers, ISymbol symbol);
    private static bool AllMatches(ImmutableArray`1<TSymbolMatcher> matchers, ISymbol symbol);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolSpecification other);
    public virtual int GetHashCode();
    internal XElement CreateXElement();
    public sealed virtual bool get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    public static SymbolSpecification ReadFrom(ObjectReader reader);
    private XElement CreateSymbolKindsXElement();
    private XElement CreateAccessibilitiesXElement();
    private XElement CreateModifiersXElement();
    internal static SymbolSpecification FromXElement(XElement symbolSpecificationElement);
    private static ImmutableArray`1<SymbolKindOrTypeKind> GetSymbolKindListFromXElement(XElement symbolKindListElement);
    private static ImmutableArray`1<Accessibility> GetAccessibilityListFromXElement(XElement accessibilityListElement);
    private static ImmutableArray`1<ModifierKind> GetModifierListFromXElement(XElement modifierListElement);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.CompilerDiagnosticAnalyzerNames : object {
    internal static string CSharpCompilerAnalyzerTypeName;
    internal static string VisualBasicCompilerAnalyzerTypeName;
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerCategory : Enum {
    public int value__;
    public static DiagnosticAnalyzerCategory None;
    public static DiagnosticAnalyzerCategory SyntaxTreeWithoutSemanticsAnalysis;
    public static DiagnosticAnalyzerCategory SemanticSpanAnalysis;
    public static DiagnosticAnalyzerCategory SemanticDocumentAnalysis;
    public static DiagnosticAnalyzerCategory ProjectAnalysis;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerExtensions : object {
    [ExtensionAttribute]
public static DiagnosticAnalyzerCategory GetDiagnosticAnalyzerCategory(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool SupportAnalysisKind(DiagnosticAnalyzer analyzer, AnalysisKind kind);
    [ExtensionAttribute]
public static bool SupportsSyntaxDiagnosticAnalysis(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool SupportsSemanticDiagnosticAnalysis(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool SupportsSpanBasedSemanticDiagnosticAnalysis(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool SupportsProjectDiagnosticAnalysis(DiagnosticAnalyzer analyzer);
    [ExtensionAttribute]
public static bool IsCompilerAnalyzer(DiagnosticAnalyzer analyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticAnalyzerInfoCache : object {
    private ConditionalWeakTable`2<DiagnosticAnalyzer, DiagnosticDescriptorsInfo> _descriptorsInfo;
    public ImmutableArray`1<DiagnosticDescriptor> GetDiagnosticDescriptors(DiagnosticAnalyzer analyzer);
    public ImmutableArray`1<DiagnosticDescriptor> GetNonCompilationEndDiagnosticDescriptors(DiagnosticAnalyzer analyzer);
    public bool IsCompilationEndAnalyzer(DiagnosticAnalyzer analyzer);
    public bool IsTelemetryCollectionAllowed(DiagnosticAnalyzer analyzer);
    private DiagnosticDescriptorsInfo GetOrCreateDescriptorsInfo(DiagnosticAnalyzer analyzer);
    private static DiagnosticDescriptorsInfo CalculateDescriptorsInfo(DiagnosticAnalyzer analyzer);
    private static bool IsTelemetryCollectionAllowed(DiagnosticAnalyzer analyzer, ImmutableArray`1<DiagnosticDescriptor> descriptors);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticCategory : object {
    public static string Style;
    public static string CodeQuality;
    public static string EditAndContinue;
    public static string Compiler;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticData : object {
    [DataMemberAttribute]
public string Id;
    [DataMemberAttribute]
public string Category;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Message;
    [DataMemberAttribute]
public DiagnosticSeverity Severity;
    [DataMemberAttribute]
public DiagnosticSeverity DefaultSeverity;
    [DataMemberAttribute]
public bool IsEnabledByDefault;
    [DataMemberAttribute]
public int WarningLevel;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> CustomTags;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableDictionary`2<string, string> Properties;
    [NullableAttribute("2")]
[DataMemberAttribute]
public ProjectId ProjectId;
    [DataMemberAttribute]
public DiagnosticDataLocation DataLocation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DiagnosticDataLocation> AdditionalLocations;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Language;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Title;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Description;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string HelpLink;
    [DataMemberAttribute]
public bool IsSuppressed;
    [CompilerGeneratedAttribute]
private static ImmutableDictionary`2<string, string> <PropertiesForBuildDiagnostic>k__BackingField;
    internal static ImmutableDictionary`2<string, string> PropertiesForBuildDiagnostic { get; }
    [NullableAttribute("2")]
public DocumentId DocumentId { get; }
    [NullableContextAttribute("2")]
public DiagnosticData(string id, string category, string message, DiagnosticSeverity severity, DiagnosticSeverity defaultSeverity, bool isEnabledByDefault, int warningLevel, ImmutableArray`1<string> customTags, ImmutableDictionary`2<string, string> properties, ProjectId projectId, DiagnosticDataLocation location, ImmutableArray`1<DiagnosticDataLocation> additionalLocations, string language, string title, string description, string helpLink, bool isSuppressed);
    private static DiagnosticData();
    [CompilerGeneratedAttribute]
internal static ImmutableDictionary`2<string, string> get_PropertiesForBuildDiagnostic();
    public DiagnosticData WithLocations(DiagnosticDataLocation location, ImmutableArray`1<DiagnosticDataLocation> additionalLocations);
    [NullableContextAttribute("2")]
public DocumentId get_DocumentId();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DiagnosticData other);
    public virtual int GetHashCode();
    public virtual string ToString();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.DiagnosticData/<ToDiagnosticAsync>d__28")]
public Task`1<Diagnostic> ToDiagnosticAsync(Project project, CancellationToken cancellationToken);
    public Diagnostic ToDiagnostic(Location location, ImmutableArray`1<Location> additionalLocations);
    private static DiagnosticDataLocation CreateLocation(TextDocument document, Location location);
    public static DiagnosticData Create(Solution solution, Diagnostic diagnostic, Project project);
    public static DiagnosticData Create(Diagnostic diagnostic, TextDocument document);
    private static DiagnosticData Create(Diagnostic diagnostic, ProjectId projectId, string language, DiagnosticDataLocation location, ImmutableArray`1<DiagnosticDataLocation> additionalLocations, ImmutableDictionary`2<string, string> additionalProperties);
    private static ImmutableDictionary`2<string, string> GetAdditionalProperties(TextDocument document, Diagnostic diagnostic);
    private static ImmutableArray`1<DiagnosticDataLocation> GetAdditionalLocations(TextDocument document, Diagnostic diagnostic);
    public static bool TryCreate(DiagnosticDescriptor descriptor, String[] messageArguments, Project project, DiagnosticData& diagnosticData);
    private static DiagnosticSeverity GetEffectiveSeverity(ReportDiagnostic effectiveReportDiagnostic, DiagnosticSeverity defaultSeverity);
    internal bool IsBuildDiagnostic();
    [NullableContextAttribute("2")]
internal Uri GetValidHelpLinkUri();
    [NullableContextAttribute("2")]
internal string GetHelpKeyword();
    [CompilerGeneratedAttribute]
internal static void <CreateLocation>g__GetLocationInfo|30_0(FileLinePositionSpan& originalLineInfo, FileLinePositionSpan& mappedLineInfo, <>c__DisplayClass30_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.DiagnosticDataLocation : object {
    [DataMemberAttribute]
public FileLinePositionSpan UnmappedFileSpan;
    [DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public FileLinePositionSpan MappedFileSpan;
    public DiagnosticDataLocation(FileLinePositionSpan unmappedFileSpan, DocumentId documentId, Nullable`1<FileLinePositionSpan> mappedFileSpan);
    private DiagnosticDataLocation(FileLinePositionSpan unmappedFileSpan, DocumentId documentId, Nullable`1<FileLinePositionSpan> mappedFileSpan, bool forceMappedPath);
    [NullableContextAttribute("1")]
public DiagnosticDataLocation WithSpan(TextSpan newSourceSpan, SyntaxTree tree);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <.ctor>g__GetNormalizedFilePath|4_0(string original, string mapped);
}
internal enum Microsoft.CodeAnalysis.Diagnostics.DiagnosticMode : Enum {
    public int value__;
    public static DiagnosticMode Push;
    public static DiagnosticMode Pull;
    public static DiagnosticMode Default;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticPropertyConstants : object {
    public static string UnreferencedAssemblyIdentity;
    public static string RequiredLanguageVersion;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.DiagnosticSeverityExtensions : object {
    [ExtensionAttribute]
public static ReportDiagnostic ToReportDiagnostic(DiagnosticSeverity diagnosticSeverity);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(DiagnosticSeverity diagnosticSeverity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DictionaryAnalyzerConfigOptions : AnalyzerConfigOptions {
    internal static ImmutableDictionary`2<string, string> EmptyDictionary;
    [CompilerGeneratedAttribute]
private static DictionaryAnalyzerConfigOptions <Empty>k__BackingField;
    internal ImmutableDictionary`2<string, string> Options;
    public static DictionaryAnalyzerConfigOptions Empty { get; }
    public IEnumerable`1<string> Keys { get; }
    public DictionaryAnalyzerConfigOptions(ImmutableDictionary`2<string, string> options);
    private static DictionaryAnalyzerConfigOptions();
    [CompilerGeneratedAttribute]
public static DictionaryAnalyzerConfigOptions get_Empty();
    public virtual bool TryGetValue(string key, String& value);
    public virtual IEnumerable`1<string> get_Keys();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.DocumentAnalysisScope : object {
    private Lazy`1<AdditionalText> _lazyAdditionalFile;
    [CompilerGeneratedAttribute]
private TextDocument <TextDocument>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<DiagnosticAnalyzer> <Analyzers>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalysisKind <Kind>k__BackingField;
    public TextDocument TextDocument { get; }
    public Nullable`1<TextSpan> Span { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticAnalyzer> Analyzers { get; }
    public AnalysisKind Kind { get; }
    public AdditionalText AdditionalFile { get; }
    public DocumentAnalysisScope(TextDocument document, Nullable`1<TextSpan> span, ImmutableArray`1<DiagnosticAnalyzer> analyzers, AnalysisKind kind);
    [CompilerGeneratedAttribute]
public TextDocument get_TextDocument();
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<DiagnosticAnalyzer> get_Analyzers();
    [CompilerGeneratedAttribute]
public AnalysisKind get_Kind();
    public AdditionalText get_AdditionalFile();
    private AdditionalText ComputeAdditionalFile();
    public DocumentAnalysisScope WithSpan(Nullable`1<TextSpan> span);
    public DocumentAnalysisScope WithAnalyzers(ImmutableArray`1<DiagnosticAnalyzer> analyzers);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.DocumentDiagnosticAnalyzer : DiagnosticAnalyzer {
    public static int DefaultPriority;
    public int Priority { get; }
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSyntaxAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeSemanticsAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual void Initialize(AnalysisContext context);
    public virtual int get_Priority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.Extensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ToDiagnosticsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<Diagnostic>> ToDiagnosticsAsync(IEnumerable`1<DiagnosticData> diagnostics, Project project, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<Location>> ConvertLocationsAsync(IReadOnlyCollection`1<DiagnosticDataLocation> locations, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ConvertLocationAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<Location> ConvertLocationAsync(DiagnosticDataLocation dataLocation, Project project, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GetAnalyzerId(DiagnosticAnalyzer analyzer);
    private static string GetAssemblyQualifiedName(Type type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<ToResultBuilderMapAsync>d__5")]
[ExtensionAttribute]
public static Task`1<ImmutableDictionary`2<DiagnosticAnalyzer, DiagnosticAnalysisResultBuilder>> ToResultBuilderMapAsync(AnalysisResult analysisResult, ImmutableArray`1<Diagnostic> additionalPragmaSuppressionDiagnostics, DocumentAnalysisScope documentAnalysisScope, Project project, VersionStamp version, Compilation compilation, IEnumerable`1<DiagnosticAnalyzer> analyzers, SkippedHostAnalyzersInfo skippedAnalyzersInfo, bool includeSuppressedDiagnostics, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<Diagnostic> Filter(ImmutableArray`1<Diagnostic> diagnostics, ImmutableArray`1<string> diagnosticIdsToFilter, bool includeSuppressedDiagnostics, Nullable`1<TextSpan> filterSpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<GetAnalysisResultAsync>d__7")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<AnalysisResult, ImmutableArray`1<Diagnostic>>> GetAnalysisResultAsync(CompilationWithAnalyzers compilationWithAnalyzers, DocumentAnalysisScope documentAnalysisScope, Project project, DiagnosticAnalyzerInfoCache analyzerInfoCache, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<GetAnalysisResultAsync>d__8")]
private static Task`1<AnalysisResult> GetAnalysisResultAsync(CompilationWithAnalyzers compilationWithAnalyzers, DocumentAnalysisScope documentAnalysisScope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Diagnostics.Extensions/<GetPragmaSuppressionAnalyzerDiagnosticsAsync>d__9")]
[ExtensionAttribute]
private static Task`1<ImmutableArray`1<Diagnostic>> GetPragmaSuppressionAnalyzerDiagnosticsAsync(CompilationWithAnalyzers compilationWithAnalyzers, DocumentAnalysisScope documentAnalysisScope, Project project, DiagnosticAnalyzerInfoCache analyzerInfoCache, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <ToResultBuilderMapAsync>g__AddAnalyzerDiagnosticsToResult|5_0(DiagnosticAnalyzer analyzer, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<Diagnostic>> diagnosticsByAnalyzer, DiagnosticAnalysisResultBuilder& result, Compilation compilation, SyntaxTree tree, DocumentId additionalDocumentId, Nullable`1<TextSpan> span, AnalysisKind kind, ImmutableArray`1<string> diagnosticIdsToFilter, bool includeSuppressedDiagnostics);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static void <ToResultBuilderMapAsync>g__AddDiagnosticsToResult|5_1(ImmutableArray`1<Diagnostic> diagnostics, DiagnosticAnalysisResultBuilder& result, Compilation compilation, SyntaxTree tree, DocumentId additionalDocumentId, Nullable`1<TextSpan> span, AnalysisKind kind, ImmutableArray`1<string> diagnosticIdsToFilter, bool includeSuppressedDiagnostics);
}
internal class Microsoft.CodeAnalysis.Diagnostics.FileContentLoadAnalyzer : DiagnosticAnalyzer {
    internal static FileContentLoadAnalyzer Instance;
    public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static FileContentLoadAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.GeneratorDiagnosticsPlaceholderAnalyzer : DiagnosticAnalyzer {
    internal static GeneratorDiagnosticsPlaceholderAnalyzer Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticDescriptor> SupportedDiagnostics { get; }
    private static GeneratorDiagnosticsPlaceholderAnalyzer();
    public virtual ImmutableArray`1<DiagnosticDescriptor> get_SupportedDiagnostics();
    public sealed virtual void Initialize(AnalysisContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Diagnostics.HostDiagnosticAnalyzers : object {
    private ImmutableDictionary`2<object, AnalyzerReference> _hostAnalyzerReferencesMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>>> _hostDiagnosticAnalyzersPerLanguageMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>>> _lazyHostDiagnosticAnalyzersPerReferenceMap;
    private ImmutableDictionary`2<string, DiagnosticAnalyzer> _compilerDiagnosticAnalyzerMap;
    private ConditionalWeakTable`2<IReadOnlyList`1<AnalyzerReference>, StrongBox`1<ImmutableDictionary`2<string, SkippedHostAnalyzersInfo>>> _skippedHostAnalyzers;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <HostAnalyzerReferences>k__BackingField;
    public IReadOnlyList`1<AnalyzerReference> HostAnalyzerReferences { get; }
    internal HostDiagnosticAnalyzers(IReadOnlyList`1<AnalyzerReference> hostAnalyzerReferences);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_HostAnalyzerReferences();
    public ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> GetOrCreateHostDiagnosticAnalyzersPerReference(string language);
    public ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticDescriptor>> GetDiagnosticDescriptorsPerReference(DiagnosticAnalyzerInfoCache infoCache);
    public ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticDescriptor>> GetDiagnosticDescriptorsPerReference(DiagnosticAnalyzerInfoCache infoCache, Project project);
    private static ImmutableDictionary`2<string, ImmutableArray`1<DiagnosticDescriptor>> ConvertReferenceIdentityToName(ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticDescriptor>> descriptorsPerReference, ImmutableDictionary`2<object, AnalyzerReference> map);
    public ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> CreateDiagnosticAnalyzersPerReference(Project project);
    public ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> CreateProjectDiagnosticAnalyzersPerReference(Project project);
    public ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> CreateProjectDiagnosticAnalyzersPerReference(IReadOnlyList`1<AnalyzerReference> projectAnalyzerReferences, string language);
    public DiagnosticAnalyzer GetCompilerDiagnosticAnalyzer(string language);
    private ImmutableDictionary`2<object, AnalyzerReference> CreateProjectAnalyzerReferencesMap(IReadOnlyList`1<AnalyzerReference> projectAnalyzerReferences);
    private static ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticDescriptor>> CreateDiagnosticDescriptorsPerReference(DiagnosticAnalyzerInfoCache infoCache, ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> analyzersMap);
    private ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> CreateHostDiagnosticAnalyzersAndBuildMap(string language);
    private void UpdateCompilerAnalyzerMapIfNeeded(string language, ImmutableArray`1<DiagnosticAnalyzer> analyzers);
    private static ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> CreateDiagnosticAnalyzersPerReferenceMap(IDictionary`2<object, AnalyzerReference> analyzerReferencesMap, string language);
    private static ImmutableDictionary`2<object, AnalyzerReference> CreateAnalyzerReferencesMap(IEnumerable`1<AnalyzerReference> analyzerReferences);
    private static ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> MergeDiagnosticAnalyzerMap(ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> map1, ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> map2);
    public SkippedHostAnalyzersInfo GetSkippedAnalyzersInfo(Project project, DiagnosticAnalyzerInfoCache infoCache);
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<object, ImmutableArray`1<DiagnosticAnalyzer>> <.ctor>b__5_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <CreateProjectAnalyzerReferencesMap>b__17_0(AnalyzerReference reference);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IBuiltInAnalyzer {
    public CodeActionRequestPriority RequestPriority { get; }
    public abstract virtual DiagnosticAnalyzerCategory GetAnalyzerCategory();
    public abstract virtual bool OpenFileOnly(SimplifierOptions options);
    public abstract virtual CodeActionRequestPriority get_RequestPriority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.IdeAnalyzerOptions : object {
    private static CodeStyleOption2`1<bool> s_defaultPreferSystemHashCode;
    public static IdeAnalyzerOptions CommonDefault;
    [CompilerGeneratedAttribute]
private bool <CrashOnAnalyzerException>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidPlaceholdersInStringDotFormatCalls>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidRegexPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ReportInvalidJsonPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DetectAndOfferEditorFeaturesForProbableJsonStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeStyleOption2`1<bool> <PreferSystemHashCode>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CleanCodeGenerationOptions> <CleanCodeGenerationOptions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IdeCodeStyleOptions <CodeStyleOptions>k__BackingField;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool CrashOnAnalyzerException { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidPlaceholdersInStringDotFormatCalls { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidRegexPatterns { get; public set; }
    [DataMemberAttribute]
public bool ReportInvalidJsonPatterns { get; public set; }
    [DataMemberAttribute]
public bool DetectAndOfferEditorFeaturesForProbableJsonStrings { get; public set; }
    [DataMemberAttribute]
public CodeStyleOption2`1<bool> PreferSystemHashCode { get; public set; }
    [DataMemberAttribute]
public Nullable`1<CleanCodeGenerationOptions> CleanCodeGenerationOptions { get; public set; }
    [NullableAttribute("2")]
[DataMemberAttribute]
public IdeCodeStyleOptions CodeStyleOptions { get; public set; }
    [NullableAttribute("2")]
public CodeCleanupOptions CleanupOptions { get; }
    [NullableAttribute("2")]
public CodeGenerationOptions GenerationOptions { get; }
    [CompilerGeneratedAttribute]
private IdeAnalyzerOptions(IdeAnalyzerOptions original);
    private static IdeAnalyzerOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_CrashOnAnalyzerException();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CrashOnAnalyzerException(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidPlaceholdersInStringDotFormatCalls();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidPlaceholdersInStringDotFormatCalls(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidRegexPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidRegexPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_ReportInvalidJsonPatterns();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ReportInvalidJsonPatterns(bool value);
    [CompilerGeneratedAttribute]
public bool get_DetectAndOfferEditorFeaturesForProbableJsonStrings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DetectAndOfferEditorFeaturesForProbableJsonStrings(bool value);
    [CompilerGeneratedAttribute]
public CodeStyleOption2`1<bool> get_PreferSystemHashCode();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferSystemHashCode(CodeStyleOption2`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<CleanCodeGenerationOptions> get_CleanCodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CleanCodeGenerationOptions(Nullable`1<CleanCodeGenerationOptions> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IdeCodeStyleOptions get_CodeStyleOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeStyleOptions(IdeCodeStyleOptions value);
    [NullableContextAttribute("2")]
public CodeCleanupOptions get_CleanupOptions();
    [NullableContextAttribute("2")]
public CodeGenerationOptions get_GenerationOptions();
    public static IdeAnalyzerOptions GetDefault(LanguageServices languageServices);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(IdeAnalyzerOptions left, IdeAnalyzerOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(IdeAnalyzerOptions left, IdeAnalyzerOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(IdeAnalyzerOptions other);
    [CompilerGeneratedAttribute]
public IdeAnalyzerOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IDiagnosticPropertiesService {
    public abstract virtual ImmutableDictionary`2<string, string> GetAdditionalProperties(Diagnostic diagnostic);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.ILegacyDocumentOptionsProvider {
    [NullableContextAttribute("1")]
public abstract virtual AnalyzerConfigOptions GetOptions(ProjectId projectId, string documentPath);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.InternalRuntimeDiagnosticOptions : object {
    public static Option2`1<bool> Syntax;
    public static Option2`1<bool> Semantic;
    public static Option2`1<bool> ScriptSemantic;
    private static InternalRuntimeDiagnosticOptions();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Diagnostics.IPragmaSuppressionsAnalyzer {
    public abstract virtual Task AnalyzeAsync(SemanticModel semanticModel, Nullable`1<TextSpan> span, CompilationWithAnalyzers compilationWithAnalyzers, Func`2<DiagnosticAnalyzer, ImmutableArray`1<DiagnosticDescriptor>> getSupportedDiagnostics, Action`1<Diagnostic> reportDiagnostic, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Diagnostics.IWorkspaceVenusSpanMappingService {
    public abstract virtual void GetAdjustedDiagnosticSpan(DocumentId documentId, Location location, TextSpan& span, FileLinePositionSpan& originalLineInfo, FileLinePositionSpan& mappedLineInfo);
}
internal abstract class Microsoft.CodeAnalysis.Diagnostics.ProjectDiagnosticAnalyzer : DiagnosticAnalyzer {
    public static int DefaultPriority;
    public int Priority { get; }
    public abstract virtual Task`1<ImmutableArray`1<Diagnostic>> AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    public sealed virtual void Initialize(AnalysisContext context);
    public virtual int get_Priority();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Diagnostics.ReportDiagnosticExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<DiagnosticSeverity> ToDiagnosticSeverity(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static ReportDiagnostic WithDefaultSeverity(ReportDiagnostic reportDiagnostic, DiagnosticSeverity defaultSeverity);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string ToEditorConfigString(ReportDiagnostic reportDiagnostic);
    [ExtensionAttribute]
public static NotificationOption2 ToNotificationOption(ReportDiagnostic reportDiagnostic, DiagnosticSeverity defaultSeverity);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.SerializableDiagnosticAnalysisResults : ValueType {
    public static SerializableDiagnosticAnalysisResults Empty;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
internal ImmutableArray`1<ValueTuple`2<string, SerializableDiagnosticMap>> Diagnostics;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
internal ImmutableArray`1<ValueTuple`2<string, AnalyzerTelemetryInfo>> Telemetry;
    public SerializableDiagnosticAnalysisResults(ImmutableArray`1<ValueTuple`2<string, SerializableDiagnosticMap>> diagnostics, ImmutableArray`1<ValueTuple`2<string, AnalyzerTelemetryInfo>> telemetry);
    private static SerializableDiagnosticAnalysisResults();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.SerializableDiagnosticMap : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> Syntax;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> Semantic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> NonLocal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DiagnosticData> Other;
    public SerializableDiagnosticMap(ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> syntax, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> semantic, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<DiagnosticData>>> nonLocal, ImmutableArray`1<DiagnosticData> other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Diagnostics.SkippedHostAnalyzersInfo : ValueType {
    public static SkippedHostAnalyzersInfo Empty;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<DiagnosticAnalyzer> <SkippedAnalyzers>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<string>> <FilteredDiagnosticIdsForAnalyzers>k__BackingField;
    public ImmutableHashSet`1<DiagnosticAnalyzer> SkippedAnalyzers { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<string>> FilteredDiagnosticIdsForAnalyzers { get; }
    private SkippedHostAnalyzersInfo(ImmutableHashSet`1<DiagnosticAnalyzer> skippedHostAnalyzers, ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<string>> filteredDiagnosticIdsForAnalyzers);
    private static SkippedHostAnalyzersInfo();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<DiagnosticAnalyzer> get_SkippedAnalyzers();
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<DiagnosticAnalyzer, ImmutableArray`1<string>> get_FilteredDiagnosticIdsForAnalyzers();
    public static SkippedHostAnalyzersInfo Create(HostDiagnosticAnalyzers hostAnalyzers, IReadOnlyList`1<AnalyzerReference> projectAnalyzerReferences, string language, DiagnosticAnalyzerInfoCache analyzerInfoCache);
    [CompilerGeneratedAttribute]
internal static bool <Create>g__ShouldIncludeHostAnalyzer|8_0(DiagnosticAnalyzer hostAnalyzer, HashSet`1<string> projectAnalyzerDiagnosticIds, HashSet`1<string> projectSuppressedDiagnosticIds, DiagnosticAnalyzerInfoCache analyzerInfoCache, ImmutableArray`1& skippedDiagnosticIdsForAnalyzer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Diagnostics.StructuredAnalyzerConfigOptions : AnalyzerConfigOptions {
    public static StructuredAnalyzerConfigOptions Empty;
    private static StructuredAnalyzerConfigOptions();
    public abstract virtual NamingStylePreferences GetNamingStylePreferences();
    public static StructuredAnalyzerConfigOptions Create(ImmutableDictionary`2<string, string> options);
    public static StructuredAnalyzerConfigOptions Create(AnalyzerConfigOptions options);
    public static bool TryGetStructuredOptions(AnalyzerConfigOptions configOptions, StructuredAnalyzerConfigOptions& options);
}
internal static class Microsoft.CodeAnalysis.Diagnostics.WellKnownDiagnosticCustomTags : object {
    [NullableAttribute("1")]
public static string DoesNotSupportF1Help;
}
internal static class Microsoft.CodeAnalysis.Diagnostics.WellKnownDiagnosticPropertyNames : object {
    public static string Origin;
}
internal class Microsoft.CodeAnalysis.Diagnostics.WorkspaceAnalyzerOptions : AnalyzerOptions {
    [CompilerGeneratedAttribute]
private IdeAnalyzerOptions <IdeOptions>k__BackingField;
    public IdeAnalyzerOptions IdeOptions { get; }
    public WorkspaceAnalyzerOptions(AnalyzerOptions options, IdeAnalyzerOptions ideOptions);
    [CompilerGeneratedAttribute]
public IdeAnalyzerOptions get_IdeOptions();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.DictionaryExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TValue GetOrAdd(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Differencing.AbstractSyntaxComparer : TreeComparer`1<SyntaxNode> {
    protected static double ExactMatchDist;
    protected static double EpsilonDist;
    internal static int IgnoredNode;
    [NullableAttribute("2")]
protected SyntaxNode _oldRoot;
    [NullableAttribute("2")]
protected SyntaxNode _newRoot;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<SyntaxNode> _oldRootChildren;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerable`1<SyntaxNode> _newRootChildren;
    protected bool _compareStatementSyntax;
    [NullableContextAttribute("2")]
internal AbstractSyntaxComparer(SyntaxNode oldRoot, SyntaxNode newRoot, IEnumerable`1<SyntaxNode> oldRootChildren, IEnumerable`1<SyntaxNode> newRootChildren, bool compareStatementSyntax);
    protected internal sealed virtual bool TreesEqual(SyntaxNode oldNode, SyntaxNode newNode);
    protected internal sealed virtual TextSpan GetSpan(SyntaxNode node);
    protected abstract virtual bool TryComputeWeightedDistance(SyntaxNode oldNode, SyntaxNode newNode, Double& distance);
    protected abstract virtual bool IsLambdaBodyStatementOrExpression(SyntaxNode node);
    protected internal virtual bool TryGetParent(SyntaxNode node, SyntaxNode& parent);
    protected internal virtual IEnumerable`1<SyntaxNode> GetChildren(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.AbstractSyntaxComparer/<EnumerateChildren>d__15")]
private IEnumerable`1<SyntaxNode> EnumerateChildren(SyntaxNode node);
    private bool DescendIntoChildren(SyntaxNode node);
    protected internal sealed virtual IEnumerable`1<SyntaxNode> GetDescendants(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.AbstractSyntaxComparer/<EnumerateDescendants>d__18")]
private IEnumerable`1<SyntaxNode> EnumerateDescendants(IEnumerable`1<SyntaxNode> nodes);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.AbstractSyntaxComparer/<EnumerateDescendants>d__19")]
private IEnumerable`1<SyntaxNode> EnumerateDescendants(SyntaxNode node);
    protected bool HasChildren(SyntaxNode node);
    internal bool HasLabel(SyntaxNode node);
    [NullableContextAttribute("2")]
internal abstract virtual int Classify(int kind, SyntaxNode node, Boolean& isLeaf);
    protected internal virtual int GetLabel(SyntaxNode node);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.Differencing.Edit`1 : ValueType {
    private TreeComparer`1<TNode> _comparer;
    private EditKind _kind;
    private TNode _oldNode;
    private TNode _newNode;
    public EditKind Kind { get; }
    public TNode OldNode { get; }
    public TNode NewNode { get; }
    internal Edit`1(EditKind kind, TreeComparer`1<TNode> comparer, TNode oldNode, TNode newNode);
    public EditKind get_Kind();
    public TNode get_OldNode();
    public TNode get_NewNode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Edit`1<TNode> other);
    public virtual int GetHashCode();
    internal string GetDebuggerDisplay();
    private string DisplayPosition(TNode node);
}
public enum Microsoft.CodeAnalysis.Differencing.EditKind : Enum {
    public int value__;
    public static EditKind None;
    public static EditKind Update;
    public static EditKind Insert;
    public static EditKind Delete;
    public static EditKind Move;
    public static EditKind Reorder;
}
public class Microsoft.CodeAnalysis.Differencing.EditScript`1 : object {
    private Match`1<TNode> _match;
    private ImmutableArray`1<Edit`1<TNode>> _edits;
    public ImmutableArray`1<Edit`1<TNode>> Edits { get; }
    public Match`1<TNode> Match { get; }
    private TreeComparer`1<TNode> Comparer { get; }
    private TNode Root1 { get; }
    private TNode Root2 { get; }
    internal EditScript`1(Match`1<TNode> match);
    public ImmutableArray`1<Edit`1<TNode>> get_Edits();
    public Match`1<TNode> get_Match();
    private TreeComparer`1<TNode> get_Comparer();
    private TNode get_Root1();
    private TNode get_Root2();
    private void AddUpdatesInsertsMoves(List`1<Edit`1<TNode>> edits);
    private void ProcessNode(List`1<Edit`1<TNode>> edits, TNode x);
    private void AddDeletes(List`1<Edit`1<TNode>> edits);
    private void AlignChildren(List`1<Edit`1<TNode>> edits, TNode w, TNode x);
    private static bool ContainsPair(Dictionary`2<TNode, TNode> dict, TNode a, TNode b);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonImmutableArraySubsequence`1 : LongestCommonSubsequence`1<ImmutableArray`1<TElement>> {
    protected abstract virtual bool Equals(TElement oldElement, TElement newElement);
    protected sealed virtual bool ItemsEqual(ImmutableArray`1<TElement> oldSequence, int oldIndex, ImmutableArray`1<TElement> newSequence, int newIndex);
    public IEnumerable`1<SequenceEdit> GetEdits(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
    public double ComputeDistance(ImmutableArray`1<TElement> oldSequence, ImmutableArray`1<TElement> newSequence);
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence : object {
    private static ObjectPool`1<VBuffer> s_pool;
    private static LongestCommonSubsequence();
    protected static VStack CreateStack();
}
internal abstract class Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1 : LongestCommonSubsequence {
    protected abstract virtual bool ItemsEqual(TSequence oldSequence, int oldIndex, TSequence newSequence, int newIndex);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetMatchingPairs>d__1")]
protected IEnumerable`1<KeyValuePair`2<int, int>> GetMatchingPairs(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Differencing.LongestCommonSubsequence`1/<GetEdits>d__2")]
protected IEnumerable`1<SequenceEdit> GetEdits(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    protected double ComputeDistance(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
    private VStack ComputeEditPaths(TSequence oldSequence, int oldLength, TSequence newSequence, int newLength);
}
internal class Microsoft.CodeAnalysis.Differencing.LongestCommonSubstring : LongestCommonSubsequence`1<string> {
    private static LongestCommonSubstring s_instance;
    private static LongestCommonSubstring();
    protected virtual bool ItemsEqual(string oldSequence, int oldIndex, string newSequence, int newIndex);
    public static double ComputeDistance(string oldValue, string newValue);
    public static IEnumerable`1<SequenceEdit> GetEdits(string oldValue, string newValue);
}
public class Microsoft.CodeAnalysis.Differencing.Match`1 : object {
    private static double ExactMatchDistance;
    private static double EpsilonDistance;
    private static double MatchingDistance1;
    private static double MatchingDistance2;
    private static double MatchingDistance3;
    private static double MaxDistance;
    private TreeComparer`1<TNode> _comparer;
    private TNode _root1;
    private TNode _root2;
    private Dictionary`2<TNode, TNode> _oneToTwo;
    private Dictionary`2<TNode, TNode> _twoToOne;
    public TreeComparer`1<TNode> Comparer { get; }
    public TNode OldRoot { get; }
    public TNode NewRoot { get; }
    public IReadOnlyDictionary`2<TNode, TNode> Matches { get; }
    public IReadOnlyDictionary`2<TNode, TNode> ReverseMatches { get; }
    internal Match`1(TNode root1, TNode root2, TreeComparer`1<TNode> comparer, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    private static void CategorizeNodesByLabels(TreeComparer`1<TNode> comparer, TNode root, int labelCount, List`1[]& nodes, Int32& totalCount);
    private void ComputeMatch(List`1[] nodes1, List`1[] nodes2);
    private void ComputeMatchForLabel(int label, List`1<TNode> s1, List`1<TNode> s2);
    private void ComputeMatchForLabel(List`1<TNode> s1, List`1<TNode> s2, int tiedToAncestor, double maxAcceptableDistance);
    internal bool TryAdd(TNode node1, TNode node2);
    internal bool TryGetPartnerInTree1(TNode node2, TNode& partner1);
    internal bool HasPartnerInTree1(TNode node2);
    internal bool TryGetPartnerInTree2(TNode node1, TNode& partner2);
    internal bool HasPartnerInTree2(TNode node1);
    internal bool Contains(TNode node1, TNode node2);
    public TreeComparer`1<TNode> get_Comparer();
    public TNode get_OldRoot();
    public TNode get_NewRoot();
    public IReadOnlyDictionary`2<TNode, TNode> get_Matches();
    public IReadOnlyDictionary`2<TNode, TNode> get_ReverseMatches();
    public bool TryGetNewNode(TNode oldNode, TNode& newNode);
    public bool TryGetOldNode(TNode newNode, TNode& oldNode);
    public EditScript`1<TNode> GetTreeEdits();
    public IEnumerable`1<Edit`1<TNode>> GetSequenceEdits(IEnumerable`1<TNode> oldNodes, IEnumerable`1<TNode> newNodes);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
internal class Microsoft.CodeAnalysis.Differencing.SequenceEdit : ValueType {
    private int _oldIndex;
    private int _newIndex;
    public EditKind Kind { get; }
    public int OldIndex { get; }
    public int NewIndex { get; }
    internal SequenceEdit(int oldIndex, int newIndex);
    public EditKind get_Kind();
    public int get_OldIndex();
    public int get_NewIndex();
    public sealed virtual bool Equals(SequenceEdit other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Differencing.TreeComparer`1 : object {
    protected internal int LabelCount { get; }
    public EditScript`1<TNode> ComputeEditScript(TNode oldRoot, TNode newRoot);
    public Match`1<TNode> ComputeMatch(TNode oldRoot, TNode newRoot, IEnumerable`1<KeyValuePair`2<TNode, TNode>> knownMatches);
    public abstract virtual double GetDistance(TNode oldNode, TNode newNode);
    public abstract virtual bool ValuesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual int get_LabelCount();
    protected internal abstract virtual int GetLabel(TNode node);
    protected internal abstract virtual int TiedToAncestor(int label);
    protected internal abstract virtual IEnumerable`1<TNode> GetChildren(TNode node);
    protected internal abstract virtual IEnumerable`1<TNode> GetDescendants(TNode node);
    protected internal abstract virtual bool TryGetParent(TNode node, TNode& parent);
    internal TNode GetParent(TNode node);
    internal bool TryGetAncestor(TNode node, int level, TNode& ancestor);
    protected internal abstract virtual bool TreesEqual(TNode oldNode, TNode newNode);
    protected internal abstract virtual TextSpan GetSpan(TNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Document : TextDocument {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<SemanticModel> _model;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<SyntaxTree> _syntaxTreeResultTask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private AsyncLazy`1<DocumentOptionSet> _cachedOptions;
    internal DocumentState DocumentState { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool SupportsSyntaxTree { get; }
    public bool SupportsSemanticModel { get; }
    internal Document(Project project, DocumentState state);
    internal DocumentState get_DocumentState();
    public SourceCodeKind get_SourceCodeKind();
    internal virtual bool HasInfoChanged(TextDocument otherTextDocument);
    [ObsoleteAttribute("Use TextDocument.HasTextChanged")]
internal bool HasTextChanged(Document otherDocument);
    [NullableContextAttribute("2")]
public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    public bool TryGetSyntaxVersion(VersionStamp& version);
    internal bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxVersionAsync>d__12")]
public Task`1<VersionStamp> GetSyntaxVersionAsync(CancellationToken cancellationToken);
    public bool get_SupportsSyntaxTree();
    public bool get_SupportsSemanticModel();
    public Task`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal SyntaxTree GetSyntaxTreeSynchronously(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool TryGetSyntaxRoot(SyntaxNode& root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSyntaxRootAsync>d__20")]
public Task`1<SyntaxNode> GetSyntaxRootAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal SyntaxNode GetSyntaxRootSynchronously(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public bool TryGetSemanticModel(SemanticModel& semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetSemanticModelAsync>d__23")]
public Task`1<SemanticModel> GetSemanticModelAsync(CancellationToken cancellationToken);
    public Document WithSourceCodeKind(SourceCodeKind kind);
    public Document WithText(SourceText text);
    public Document WithSyntaxRoot(SyntaxNode root);
    public Document WithName(string name);
    public Document WithFolders(IEnumerable`1<string> folders);
    public Document WithFilePath(string filePath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetTextChangesAsync>d__30")]
public Task`1<IEnumerable`1<TextChange>> GetTextChangesAsync(Document oldDocument, CancellationToken cancellationToken);
    public ImmutableArray`1<DocumentId> GetLinkedDocumentIds();
    internal virtual Document WithFrozenPartialSemantics(CancellationToken cancellationToken);
    private string GetDebuggerDisplay();
    public Task`1<DocumentOptionSet> GetOptionsAsync(CancellationToken cancellationToken);
    private void InitializeCachedOptions(OptionSet solutionOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Document/<GetAnalyzerConfigOptionsAsync>d__37")]
internal ValueTask`1<StructuredAnalyzerConfigOptions> GetAnalyzerConfigOptionsAsync(CancellationToken cancellationToken);
}
public class Microsoft.CodeAnalysis.DocumentActiveContextChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Solution <Solution>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceTextContainer <SourceTextContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <OldActiveContextDocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <NewActiveContextDocumentId>k__BackingField;
    public Solution Solution { get; }
    public SourceTextContainer SourceTextContainer { get; }
    public DocumentId OldActiveContextDocumentId { get; }
    public DocumentId NewActiveContextDocumentId { get; }
    public DocumentActiveContextChangedEventArgs(Solution solution, SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);
    [CompilerGeneratedAttribute]
public Solution get_Solution();
    [CompilerGeneratedAttribute]
public SourceTextContainer get_SourceTextContainer();
    [CompilerGeneratedAttribute]
public DocumentId get_OldActiveContextDocumentId();
    [CompilerGeneratedAttribute]
public DocumentId get_NewActiveContextDocumentId();
}
public class Microsoft.CodeAnalysis.DocumentDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public DocumentId DocumentId { get; }
    public DocumentDiagnostic(WorkspaceDiagnosticKind kind, string message, DocumentId documentId);
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public class Microsoft.CodeAnalysis.DocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    public Document Document { get; }
    public DocumentEventArgs(Document document);
    [CompilerGeneratedAttribute]
public Document get_Document();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.DocumentId : object {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [NullableAttribute("2")]
[DataMemberAttribute]
private string _debugName;
    [DataMemberAttribute]
public ProjectId ProjectId { get; }
    [DataMemberAttribute]
public Guid Id { get; }
    [NullableAttribute("2")]
internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private DocumentId(ProjectId projectId, Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static DocumentId CreateNewId(ProjectId projectId, string debugName);
    public static DocumentId CreateFromSerialized(ProjectId projectId, Guid id, string debugName);
    [NullableContextAttribute("2")]
internal string get_DebugName();
    internal string GetDebuggerDisplay();
    public virtual string ToString();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(DocumentId other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(DocumentId left, DocumentId right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(DocumentId left, DocumentId right);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static DocumentId ReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay() , nq}")]
public class Microsoft.CodeAnalysis.DocumentInfo : object {
    [CompilerGeneratedAttribute]
private DocumentAttributes <Attributes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TextLoader <TextLoader>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IDocumentServiceProvider <DocumentServiceProvider>k__BackingField;
    internal DocumentAttributes Attributes { get; }
    public DocumentId Id { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public SourceCodeKind SourceCodeKind { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public bool IsGenerated { get; }
    [NullableAttribute("2")]
public TextLoader TextLoader { get; }
    [NullableAttribute("2")]
internal IDocumentServiceProvider DocumentServiceProvider { get; }
    [NullableContextAttribute("2")]
internal DocumentInfo(DocumentAttributes attributes, TextLoader loader, IDocumentServiceProvider documentServiceProvider);
    [CompilerGeneratedAttribute]
internal DocumentAttributes get_Attributes();
    public DocumentId get_Id();
    public string get_Name();
    public IReadOnlyList`1<string> get_Folders();
    public SourceCodeKind get_SourceCodeKind();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public bool get_IsGenerated();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public TextLoader get_TextLoader();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal IDocumentServiceProvider get_DocumentServiceProvider();
    public static DocumentInfo Create(DocumentId id, string name, IEnumerable`1<string> folders, SourceCodeKind sourceCodeKind, TextLoader loader, string filePath, bool isGenerated);
    internal static DocumentInfo Create(DocumentId id, string name, IReadOnlyList`1<string> folders, SourceCodeKind sourceCodeKind, TextLoader loader, string filePath, bool isGenerated, bool designTimeOnly, IDocumentServiceProvider documentServiceProvider);
    private DocumentInfo With(DocumentAttributes attributes, Optional`1<TextLoader> loader, Optional`1<IDocumentServiceProvider> documentServiceProvider);
    public DocumentInfo WithId(DocumentId id);
    public DocumentInfo WithName(string name);
    public DocumentInfo WithFolders(IEnumerable`1<string> folders);
    public DocumentInfo WithSourceCodeKind(SourceCodeKind kind);
    public DocumentInfo WithFilePath(string filePath);
    public DocumentInfo WithTextLoader(TextLoader loader);
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.DocumentState : TextDocumentState {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<string, PreservationMode, string> s_fullParseLog;
    private static ConditionalWeakTable`2<SyntaxTree, DocumentId> s_syntaxTreeToIdMap;
    private HostLanguageServices _languageServices;
    [NullableAttribute("2")]
private ParseOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueSource`1<TreeAndVersion> _treeSource;
    private static int MaxTextChangeRangeLength;
    [MemberNotNullWhenAttribute("True", "_treeSource")]
internal bool SupportsSyntaxTree { get; }
    public HostLanguageServices LanguageServices { get; }
    [NullableAttribute("2")]
public ParseOptions ParseOptions { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public bool IsGenerated { get; }
    protected DocumentState(HostLanguageServices languageServices, HostWorkspaceServices solutionServices, IDocumentServiceProvider documentServiceProvider, DocumentAttributes attributes, ParseOptions options, SourceText sourceText, ValueSource`1<TextAndVersion> textSource, ValueSource`1<TreeAndVersion> treeSource);
    public DocumentState(DocumentInfo info, ParseOptions options, HostLanguageServices languageServices, HostWorkspaceServices services);
    private static DocumentState();
    [MemberNotNullWhenAttribute("True", "_treeSource")]
internal bool get_SupportsSyntaxTree();
    public HostLanguageServices get_LanguageServices();
    [NullableContextAttribute("2")]
public ParseOptions get_ParseOptions();
    public SourceCodeKind get_SourceCodeKind();
    public bool get_IsGenerated();
    private static string GetSyntaxTreeFilePath(DocumentAttributes info);
    protected static ValueSource`1<TreeAndVersion> CreateLazyFullyParsedTree(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<FullyParseTreeAsync>d__19")]
private static Task`1<TreeAndVersion> FullyParseTreeAsync(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, PreservationMode mode, CancellationToken cancellationToken);
    private static TreeAndVersion FullyParseTree(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, PreservationMode mode, CancellationToken cancellationToken);
    private static TreeAndVersion CreateTreeAndVersion(ValueSource`1<TextAndVersion> newTextSource, ProjectId cacheKey, string filePath, ParseOptions options, HostLanguageServices languageServices, PreservationMode mode, TextAndVersion textAndVersion, CancellationToken cancellationToken);
    private static ValueSource`1<TreeAndVersion> CreateLazyIncrementallyParsedTree(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<IncrementallyParseTreeAsync>d__23")]
private static Task`1<TreeAndVersion> IncrementallyParseTreeAsync(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource, CancellationToken cancellationToken);
    private static TreeAndVersion IncrementallyParseTree(ValueSource`1<TreeAndVersion> oldTreeSource, ValueSource`1<TextAndVersion> newTextSource, CancellationToken cancellationToken);
    private static TreeAndVersion IncrementallyParse(TextAndVersion newTextAndVersion, TreeAndVersion oldTreeAndVersion, CancellationToken cancellationToken);
    private static TreeAndVersion MakeNewTreeAndVersion(SyntaxTree oldTree, SourceText oldText, VersionStamp oldVersion, SyntaxTree newTree, SourceText newText, VersionStamp newVersion);
    private static bool TopLevelChanged(SyntaxTree oldTree, SourceText oldText, SyntaxTree newTree, SourceText newText);
    public bool HasContentChanged(DocumentState oldState);
    [ObsoleteAttribute("Use TextDocumentState.HasTextChanged")]
public bool HasTextChanged(DocumentState oldState);
    public DocumentState UpdateParseOptions(ParseOptions options, bool onlyPreprocessorDirectiveChange);
    private DocumentState SetParseOptions(ParseOptions options, bool onlyPreprocessorDirectiveChange);
    public DocumentState UpdateSourceCodeKind(SourceCodeKind kind);
    public DocumentState UpdateName(string name);
    public DocumentState UpdateFolders(IReadOnlyList`1<string> folders);
    private DocumentState UpdateAttributes(DocumentAttributes attributes);
    public DocumentState UpdateFilePath(string filePath);
    public DocumentState UpdateText(SourceText newText, PreservationMode mode);
    public DocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    protected virtual TextDocumentState UpdateText(ValueSource`1<TextAndVersion> newTextSource, PreservationMode mode, bool incremental);
    internal DocumentState UpdateText(TextLoader loader, SourceText text, PreservationMode mode);
    internal DocumentState UpdateTree(SyntaxNode newRoot, PreservationMode mode);
    private VersionStamp GetNewTreeVersionForUpdatedTree(SyntaxNode newRoot, VersionStamp newTextVersion, PreservationMode mode);
    private static ValueTuple`2<ValueSource`1<TextAndVersion>, TreeAndVersion> CreateRecoverableTextAndTree(SyntaxNode newRoot, string filePath, VersionStamp textVersion, VersionStamp treeVersion, Encoding encoding, DocumentAttributes attributes, ParseOptions options, ISyntaxTreeFactoryService factory, PreservationMode mode);
    internal virtual Task`1<Diagnostic> GetLoadDiagnosticAsync(CancellationToken cancellationToken);
    private VersionStamp GetNewerVersion();
    [NullableContextAttribute("2")]
public bool TryGetSyntaxTree(SyntaxTree& syntaxTree);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetSyntaxTreeAsync>d__48")]
public ValueTask`1<SyntaxTree> GetSyntaxTreeAsync(CancellationToken cancellationToken);
    internal SyntaxTree GetSyntaxTree(CancellationToken cancellationToken);
    public bool TryGetTopLevelChangeTextVersion(VersionStamp& version);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.DocumentState/<GetTopLevelChangeTextVersionAsync>d__51")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    private static void BindSyntaxTreeToId(SyntaxTree tree, DocumentId id);
    public static DocumentId GetDocumentIdForTree(SyntaxTree tree);
    private static void CheckTree(SyntaxTree newTree, SourceText newText, SyntaxTree oldTree, SourceText oldText);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Editing.AddParameterEditor : object {
    public static void AddParameter(ISyntaxFacts syntaxFacts, SyntaxEditor editor, SyntaxNode declaration, int insertionIndex, SyntaxNode parameterDeclaration, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxTrivia> GetDesiredLeadingIndentation(SyntaxGenerator generator, ISyntaxFacts syntaxFacts, SyntaxNode node, bool includeLeadingNewLine);
    private static bool ShouldPlaceParametersOnNewLine(IReadOnlyList`1<SyntaxNode> parameters, CancellationToken cancellationToken);
}
public enum Microsoft.CodeAnalysis.Editing.DeclarationKind : Enum {
    public int value__;
    public static DeclarationKind None;
    public static DeclarationKind CompilationUnit;
    public static DeclarationKind Class;
    public static DeclarationKind Struct;
    public static DeclarationKind Interface;
    public static DeclarationKind Enum;
    public static DeclarationKind Delegate;
    public static DeclarationKind Method;
    public static DeclarationKind Operator;
    public static DeclarationKind ConversionOperator;
    public static DeclarationKind Constructor;
    public static DeclarationKind Destructor;
    public static DeclarationKind Field;
    public static DeclarationKind Property;
    public static DeclarationKind Indexer;
    public static DeclarationKind EnumMember;
    public static DeclarationKind Event;
    public static DeclarationKind CustomEvent;
    public static DeclarationKind Namespace;
    public static DeclarationKind NamespaceImport;
    public static DeclarationKind Parameter;
    public static DeclarationKind Variable;
    public static DeclarationKind Attribute;
    public static DeclarationKind LambdaExpression;
    public static DeclarationKind GetAccessor;
    public static DeclarationKind SetAccessor;
    public static DeclarationKind AddAccessor;
    public static DeclarationKind RemoveAccessor;
    public static DeclarationKind RaiseAccessor;
    [ObsoleteAttribute("This value is not used. Use Class instead.")]
[EditorBrowsableAttribute("1")]
public static DeclarationKind RecordClass;
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.Editing.DeclarationModifiers : ValueType {
    private Modifiers _modifiers;
    public bool IsStatic { get; }
    public bool IsAbstract { get; }
    public bool IsNew { get; }
    public bool IsUnsafe { get; }
    public bool IsReadOnly { get; }
    public bool IsVirtual { get; }
    public bool IsOverride { get; }
    public bool IsSealed { get; }
    public bool IsConst { get; }
    public bool IsWithEvents { get; }
    public bool IsPartial { get; }
    public bool IsAsync { get; }
    public bool IsWriteOnly { get; }
    public bool IsRef { get; }
    public bool IsVolatile { get; }
    public bool IsExtern { get; }
    public bool IsRequired { get; }
    public bool IsFile { get; }
    public static DeclarationModifiers None { get; }
    public static DeclarationModifiers Static { get; }
    public static DeclarationModifiers Abstract { get; }
    public static DeclarationModifiers New { get; }
    public static DeclarationModifiers Unsafe { get; }
    public static DeclarationModifiers ReadOnly { get; }
    public static DeclarationModifiers Virtual { get; }
    public static DeclarationModifiers Override { get; }
    public static DeclarationModifiers Sealed { get; }
    public static DeclarationModifiers Const { get; }
    public static DeclarationModifiers WithEvents { get; }
    public static DeclarationModifiers Partial { get; }
    public static DeclarationModifiers Async { get; }
    public static DeclarationModifiers WriteOnly { get; }
    public static DeclarationModifiers Ref { get; }
    public static DeclarationModifiers Volatile { get; }
    public static DeclarationModifiers Extern { get; }
    public static DeclarationModifiers Required { get; }
    public static DeclarationModifiers File { get; }
    private DeclarationModifiers(Modifiers modifiers);
    internal DeclarationModifiers(bool isStatic, bool isAbstract, bool isNew, bool isUnsafe, bool isReadOnly, bool isVirtual, bool isOverride, bool isSealed, bool isConst, bool isWithEvents, bool isPartial, bool isAsync, bool isWriteOnly, bool isRef, bool isVolatile, bool isExtern, bool isRequired, bool isFile);
    public static DeclarationModifiers From(ISymbol symbol);
    public bool get_IsStatic();
    public bool get_IsAbstract();
    public bool get_IsNew();
    public bool get_IsUnsafe();
    public bool get_IsReadOnly();
    public bool get_IsVirtual();
    public bool get_IsOverride();
    public bool get_IsSealed();
    public bool get_IsConst();
    public bool get_IsWithEvents();
    public bool get_IsPartial();
    public bool get_IsAsync();
    public bool get_IsWriteOnly();
    public bool get_IsRef();
    public bool get_IsVolatile();
    public bool get_IsExtern();
    public bool get_IsRequired();
    public bool get_IsFile();
    public DeclarationModifiers WithIsStatic(bool isStatic);
    public DeclarationModifiers WithIsAbstract(bool isAbstract);
    public DeclarationModifiers WithIsNew(bool isNew);
    public DeclarationModifiers WithIsUnsafe(bool isUnsafe);
    public DeclarationModifiers WithIsReadOnly(bool isReadOnly);
    public DeclarationModifiers WithIsVirtual(bool isVirtual);
    public DeclarationModifiers WithIsOverride(bool isOverride);
    public DeclarationModifiers WithIsSealed(bool isSealed);
    public DeclarationModifiers WithIsConst(bool isConst);
    public DeclarationModifiers WithWithEvents(bool withEvents);
    public DeclarationModifiers WithPartial(bool isPartial);
    public DeclarationModifiers WithAsync(bool isAsync);
    public DeclarationModifiers WithIsWriteOnly(bool isWriteOnly);
    public DeclarationModifiers WithIsRef(bool isRef);
    public DeclarationModifiers WithIsVolatile(bool isVolatile);
    public DeclarationModifiers WithIsExtern(bool isExtern);
    public DeclarationModifiers WithIsRequired(bool isRequired);
    public DeclarationModifiers WithIsFile(bool isFile);
    private static Modifiers SetFlag(Modifiers existing, Modifiers modifier, bool isSet);
    public static DeclarationModifiers get_None();
    public static DeclarationModifiers get_Static();
    public static DeclarationModifiers get_Abstract();
    public static DeclarationModifiers get_New();
    public static DeclarationModifiers get_Unsafe();
    public static DeclarationModifiers get_ReadOnly();
    public static DeclarationModifiers get_Virtual();
    public static DeclarationModifiers get_Override();
    public static DeclarationModifiers get_Sealed();
    public static DeclarationModifiers get_Const();
    public static DeclarationModifiers get_WithEvents();
    public static DeclarationModifiers get_Partial();
    public static DeclarationModifiers get_Async();
    public static DeclarationModifiers get_WriteOnly();
    public static DeclarationModifiers get_Ref();
    public static DeclarationModifiers get_Volatile();
    public static DeclarationModifiers get_Extern();
    public static DeclarationModifiers get_Required();
    public static DeclarationModifiers get_File();
    public static DeclarationModifiers op_BitwiseOr(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_BitwiseAnd(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Addition(DeclarationModifiers left, DeclarationModifiers right);
    public static DeclarationModifiers op_Subtraction(DeclarationModifiers left, DeclarationModifiers right);
    public sealed virtual bool Equals(DeclarationModifiers modifiers);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DeclarationModifiers left, DeclarationModifiers right);
    public static bool op_Inequality(DeclarationModifiers left, DeclarationModifiers right);
    public virtual string ToString();
    public static bool TryParse(string value, DeclarationModifiers& modifiers);
}
public class Microsoft.CodeAnalysis.Editing.DocumentEditor : SyntaxEditor {
    private Document _document;
    private SemanticModel _model;
    public Document OriginalDocument { get; }
    public SemanticModel SemanticModel { get; }
    private DocumentEditor(Document document, SemanticModel model, SyntaxNode root);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.DocumentEditor/<CreateAsync>d__3")]
public static Task`1<DocumentEditor> CreateAsync(Document document, CancellationToken cancellationToken);
    public Document get_OriginalDocument();
    public SemanticModel get_SemanticModel();
    public Document GetChangedDocument();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Editing.GenerationOptions : object {
    public static PerLanguageOption2`1<bool> PlaceSystemNamespaceFirst;
    public static PerLanguageOption2`1<bool> SeparateImportDirectiveGroups;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<IOption2> AllOptions;
    private static GenerationOptions();
}
[ExportSolutionOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Editing.GenerationOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Editing.ImportAdder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<GetSpansAsync>d__0")]
private static ValueTask`1<IEnumerable`1<TextSpan>> GetSpansAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<GetSpansAsync>d__1")]
private static ValueTask`1<IEnumerable`1<TextSpan>> GetSpansAsync(Document document, SyntaxAnnotation annotation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__2")]
public static Task`1<Document> AddImportsAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsAsync>d__4")]
public static Task`1<Document> AddImportsAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    public static Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsFromSyntaxesAsync>d__6")]
private static Task`1<Document> AddImportsFromSyntaxesAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet _, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsFromSyntaxesAsync>d__7")]
internal static Task`1<Document> AddImportsFromSyntaxesAsync(Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsFromSyntaxesAsync>d__8")]
internal static Task`1<Document> AddImportsFromSyntaxesAsync(Document document, SyntaxAnnotation annotation, AddImportPlacementOptions options, CancellationToken cancellationToken);
    internal static Task`1<Document> AddImportsFromSyntaxesAsync(Document document, IEnumerable`1<TextSpan> spans, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsFromSymbolAnnotationAsync>d__10")]
internal static Task`1<Document> AddImportsFromSymbolAnnotationAsync(Document document, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdder/<AddImportsFromSymbolAnnotationAsync>d__11")]
internal static Task`1<Document> AddImportsFromSymbolAnnotationAsync(Document document, SyntaxAnnotation annotation, AddImportPlacementOptions options, CancellationToken cancellationToken);
    internal static Task`1<Document> AddImportsFromSymbolAnnotationAsync(Document document, IEnumerable`1<TextSpan> spans, AddImportPlacementOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Editing.ImportAdderService : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService/<AddImportsAsync>d__1")]
public Task`1<Document> AddImportsAsync(Document document, IEnumerable`1<TextSpan> spans, Strategy strategy, AddImportPlacementOptions options, CancellationToken cancellationToken);
    protected abstract virtual INamespaceSymbol GetExplicitNamespaceSymbol(SyntaxNode node, SemanticModel model);
    private ISet`1<INamespaceSymbol> GetSafeToAddImports(ImmutableArray`1<INamespaceSymbol> namespaceSymbols, SyntaxNode container, SemanticModel model, CancellationToken cancellationToken);
    protected abstract virtual void AddPotentiallyConflictingImports(SemanticModel model, SyntaxNode container, ImmutableArray`1<INamespaceSymbol> namespaceSymbols, HashSet`1<INamespaceSymbol> conflicts, CancellationToken cancellationToken);
    private static SyntaxNode GenerateNamespaceImportDeclaration(INamespaceSymbol namespaceSymbol, SyntaxGenerator generator);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService/<AddImportDirectivesFromSyntaxesAsync>d__6")]
private Task`1<Document> AddImportDirectivesFromSyntaxesAsync(Document document, IEnumerable`1<SyntaxNode> syntaxNodes, IAddImportsService addImportsService, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.ImportAdderService/<AddImportDirectivesFromSymbolAnnotationsAsync>d__7")]
private Task`1<Document> AddImportDirectivesFromSymbolAnnotationsAsync(Document document, IEnumerable`1<SyntaxNode> syntaxNodes, IAddImportsService addImportsService, SyntaxGenerator generator, AddImportPlacementOptions options, CancellationToken cancellationToken);
    private static bool IsInsideNamespace(SyntaxNode node, INamespaceSymbol symbol, SemanticModel model, CancellationToken cancellationToken);
}
public enum Microsoft.CodeAnalysis.Editing.OperatorKind : Enum {
    public int value__;
    public static OperatorKind ImplicitConversion;
    public static OperatorKind ExplicitConversion;
    public static OperatorKind Addition;
    public static OperatorKind BitwiseAnd;
    public static OperatorKind BitwiseOr;
    public static OperatorKind Decrement;
    public static OperatorKind Division;
    public static OperatorKind Equality;
    public static OperatorKind ExclusiveOr;
    public static OperatorKind False;
    public static OperatorKind GreaterThan;
    public static OperatorKind GreaterThanOrEqual;
    public static OperatorKind Increment;
    public static OperatorKind Inequality;
    public static OperatorKind LeftShift;
    public static OperatorKind LessThan;
    public static OperatorKind LessThanOrEqual;
    public static OperatorKind LogicalNot;
    public static OperatorKind Modulus;
    public static OperatorKind Multiply;
    public static OperatorKind OnesComplement;
    public static OperatorKind RightShift;
    public static OperatorKind Subtraction;
    public static OperatorKind True;
    public static OperatorKind UnaryNegation;
    public static OperatorKind UnaryPlus;
    public static OperatorKind UnsignedRightShift;
}
public class Microsoft.CodeAnalysis.Editing.SolutionEditor : object {
    private Solution _solution;
    private Dictionary`2<DocumentId, DocumentEditor> _documentEditors;
    public Solution OriginalSolution { get; }
    public SolutionEditor(Solution solution);
    public Solution get_OriginalSolution();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SolutionEditor/<GetDocumentEditorAsync>d__5")]
public Task`1<DocumentEditor> GetDocumentEditorAsync(DocumentId id, CancellationToken cancellationToken);
    public Solution GetChangedSolution();
}
[FlagsAttribute]
public enum Microsoft.CodeAnalysis.Editing.SpecialTypeConstraintKind : Enum {
    public int value__;
    public static SpecialTypeConstraintKind None;
    public static SpecialTypeConstraintKind ReferenceType;
    public static SpecialTypeConstraintKind ValueType;
    public static SpecialTypeConstraintKind Constructor;
}
public class Microsoft.CodeAnalysis.Editing.SymbolEditor : object {
    private Solution _originalSolution;
    private Solution _currentSolution;
    private ImmutableDictionary`2<string, ImmutableArray`1<ProjectId>> _assemblyNameToProjectIdMap;
    public Solution OriginalSolution { get; }
    public Solution ChangedSolution { get; }
    private SymbolEditor(Solution solution);
    public static SymbolEditor Create(Solution solution);
    public static SymbolEditor Create(Document document);
    public Solution get_OriginalSolution();
    public Solution get_ChangedSolution();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetChangedDocuments>d__9")]
public IEnumerable`1<Document> GetChangedDocuments();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentSymbolAsync>d__10")]
public Task`1<ISymbol> GetCurrentSymbolAsync(ISymbol symbol, CancellationToken cancellationToken);
    private ImmutableArray`1<ProjectId> GetProjectsForAssembly(IAssemblySymbol assembly);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetSymbolAsync>d__13")]
private static Task`1<ISymbol> GetSymbolAsync(Solution solution, ProjectId projectId, string symbolId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<GetCurrentDeclarationsAsync>d__14")]
public Task`1<IReadOnlyList`1<SyntaxNode>> GetCurrentDeclarationsAsync(ISymbol symbol, CancellationToken cancellationToken);
    private IEnumerable`1<SyntaxNode> GetDeclarations(ISymbol symbol);
    private bool TryGetBestDeclarationForSingleEdit(ISymbol symbol, SyntaxNode& declaration);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__19")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    private static void CheckSymbolArgument(ISymbol currentSymbol, ISymbol argSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditDeclarationAsync>d__22")]
private Task`1<ISymbol> EditDeclarationAsync(ISymbol currentSymbol, SyntaxNode declaration, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, Location location, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__25")]
private Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, DocumentId documentId, int position, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditOneDeclarationAsync>d__26")]
public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditOneDeclarationAsync(ISymbol symbol, ISymbol member, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditor/<EditAllDeclarationsAsync>d__28")]
public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, AsyncDeclarationEditAction editAction, CancellationToken cancellationToken);
    public Task`1<ISymbol> EditAllDeclarationsAsync(ISymbol symbol, DeclarationEditAction editAction, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private SyntaxNode <GetDeclarations>b__15_1(SyntaxNode n);
    [CompilerGeneratedAttribute]
private DocumentId <EditAllDeclarationsAsync>b__28_0(SyntaxNode d);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<GetBaseOrInterfaceDeclarationReferenceAsync>d__0")]
[ExtensionAttribute]
public static Task`1<SyntaxNode> GetBaseOrInterfaceDeclarationReferenceAsync(SymbolEditor editor, ISymbol symbol, ITypeSymbol baseOrInterfaceType, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SymbolEditorExtensions/<SetBaseTypeAsync>d__1")]
[ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, Func`2<SyntaxGenerator, SyntaxNode> getNewBaseType, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ISymbol> SetBaseTypeAsync(SymbolEditor editor, INamedTypeSymbol symbol, ITypeSymbol newBaseType, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Editing.SyntaxEditor : object {
    private SyntaxGenerator _generator;
    private List`1<Change> _changes;
    private bool _allowEditsOnLazilyCreatedTrackedNewNodes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<SyntaxNode> _lazyTrackedNewNodesOpt;
    [CompilerGeneratedAttribute]
private SyntaxNode <OriginalRoot>k__BackingField;
    public SyntaxNode OriginalRoot { get; }
    public SyntaxGenerator Generator { get; }
    [ObsoleteAttribute("Use SyntaxEditor(SyntaxNode, HostWorkspaceServices)")]
public SyntaxEditor(SyntaxNode root, Workspace workspace);
    public SyntaxEditor(SyntaxNode root, HostWorkspaceServices services);
    public SyntaxEditor(SyntaxNode root, SolutionServices services);
    internal SyntaxEditor(SyntaxNode root, SyntaxGenerator generator);
    [NullableContextAttribute("2")]
private SyntaxNode ApplyTrackingToNewNode(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Editing.SyntaxEditor/<ApplyTrackingToNewNodes>d__9")]
private IEnumerable`1<SyntaxNode> ApplyTrackingToNewNodes(IEnumerable`1<SyntaxNode> nodes);
    [CompilerGeneratedAttribute]
public SyntaxNode get_OriginalRoot();
    public SyntaxGenerator get_Generator();
    public SyntaxNode GetChangedRoot();
    public void TrackNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node);
    public void RemoveNode(SyntaxNode node, SyntaxRemoveOptions options);
    public void ReplaceNode(SyntaxNode node, Func`3<SyntaxNode, SyntaxGenerator, SyntaxNode> computeReplacement);
    internal void ReplaceNode(SyntaxNode node, Func`3<SyntaxNode, SyntaxGenerator, IEnumerable`1<SyntaxNode>> computeReplacement);
    internal void ReplaceNode(SyntaxNode node, Func`4<SyntaxNode, SyntaxGenerator, TArgument, SyntaxNode> computeReplacement, TArgument argument);
    public void ReplaceNode(SyntaxNode node, SyntaxNode newNode);
    public void InsertBefore(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertBefore(SyntaxNode node, SyntaxNode newNode);
    public void InsertAfter(SyntaxNode node, IEnumerable`1<SyntaxNode> newNodes);
    public void InsertAfter(SyntaxNode node, SyntaxNode newNode);
    private void CheckNodeInOriginalTreeOrTracked(SyntaxNode node);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetChangedRoot>b__15_0(Change c);
}
[ExtensionAttribute]
public static class Microsoft.CodeAnalysis.Editing.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static void SetAccessibility(SyntaxEditor editor, SyntaxNode declaration, Accessibility accessibility);
    [ExtensionAttribute]
public static void SetModifiers(SyntaxEditor editor, SyntaxNode declaration, DeclarationModifiers modifiers);
    [ExtensionAttribute]
internal static void RemoveAllAttributes(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
internal static void RemoveAllComments(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
internal static void RemoveAllTypeInheritance(SyntaxEditor editor, SyntaxNode declaration);
    [ExtensionAttribute]
public static void SetName(SyntaxEditor editor, SyntaxNode declaration, string name);
    [ExtensionAttribute]
public static void SetType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode type);
    [ExtensionAttribute]
public static void SetTypeParameters(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    [ExtensionAttribute]
public static void SetTypeConstraint(SyntaxEditor editor, SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kind, IEnumerable`1<SyntaxNode> types);
    [ExtensionAttribute]
public static void SetExpression(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode expression);
    [ExtensionAttribute]
public static void SetStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetGetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void SetSetAccessorStatements(SyntaxEditor editor, SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    [ExtensionAttribute]
public static void AddParameter(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode parameter);
    [ExtensionAttribute]
public static void InsertParameter(SyntaxEditor editor, SyntaxNode declaration, int index, SyntaxNode parameter);
    [ExtensionAttribute]
public static void AddAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddReturnAttribute(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode attribute);
    [ExtensionAttribute]
public static void AddAttributeArgument(SyntaxEditor editor, SyntaxNode attributeDeclaration, SyntaxNode attributeArgument);
    [ExtensionAttribute]
public static void AddMember(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode member);
    [ExtensionAttribute]
public static void InsertMembers(SyntaxEditor editor, SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    [ExtensionAttribute]
public static void AddInterfaceType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode interfaceType);
    [ExtensionAttribute]
public static void AddBaseType(SyntaxEditor editor, SyntaxNode declaration, SyntaxNode baseType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Editing.SyntaxGenerator : object {
    public static SyntaxRemoveOptions DefaultRemoveOptions;
    private static Char[] s_dotSeparator;
    internal SyntaxTrivia CarriageReturnLineFeed { get; }
    internal SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    internal SyntaxTrivia ElasticMarker { get; }
    internal bool RequiresExplicitImplementationForInterfaceMembers { get; }
    internal ISyntaxFacts SyntaxFacts { get; }
    internal SyntaxGeneratorInternal SyntaxGeneratorInternal { get; }
    private static SyntaxGenerator();
    internal abstract virtual SyntaxTrivia get_CarriageReturnLineFeed();
    internal abstract virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    internal abstract virtual SyntaxTrivia get_ElasticMarker();
    internal abstract virtual bool get_RequiresExplicitImplementationForInterfaceMembers();
    internal ISyntaxFacts get_SyntaxFacts();
    internal abstract virtual SyntaxGeneratorInternal get_SyntaxGeneratorInternal();
    internal abstract virtual SyntaxTrivia Whitespace(string text);
    internal abstract virtual SyntaxTrivia SingleLineComment(string text);
    internal abstract virtual SyntaxToken CreateInterpolatedStringStartToken(bool isVerbatim);
    internal abstract virtual SyntaxToken CreateInterpolatedStringEndToken();
    public static SyntaxGenerator GetGenerator(Workspace workspace, string language);
    internal static SyntaxGenerator GetGenerator(SolutionServices services, string language);
    public static SyntaxGenerator GetGenerator(Document document);
    public static SyntaxGenerator GetGenerator(Project project);
    [NullableContextAttribute("2")]
public SyntaxNode GetDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public SyntaxNode GetDeclaration(SyntaxNode node, DeclarationKind kind);
    public abstract virtual SyntaxNode FieldDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode initializer);
    public SyntaxNode FieldDeclaration(IFieldSymbol field);
    public SyntaxNode FieldDeclaration(IFieldSymbol field, SyntaxNode initializer);
    public abstract virtual SyntaxNode MethodDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode MethodDeclaration(IMethodSymbol method, IEnumerable`1<SyntaxNode> statements);
    internal SyntaxNode MethodDeclaration(IMethodSymbol method, string name, IEnumerable`1<SyntaxNode> statements);
    public virtual SyntaxNode OperatorDeclaration(OperatorKind kind, IEnumerable`1<SyntaxNode> parameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode OperatorDeclaration(IMethodSymbol method, IEnumerable`1<SyntaxNode> statements);
    private static OperatorKind GetOperatorKind(IMethodSymbol method);
    public abstract virtual SyntaxNode ParameterDeclaration(string name, SyntaxNode type, SyntaxNode initializer, RefKind refKind);
    public SyntaxNode ParameterDeclaration(IParameterSymbol symbol, SyntaxNode initializer);
    public abstract virtual SyntaxNode PropertyDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode PropertyDeclaration(IPropertySymbol property, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, SyntaxNode[] accessorDeclarations);
    public abstract virtual SyntaxNode WithAccessorDeclarations(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessorDeclarations);
    public abstract virtual SyntaxNode GetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode SetAccessorDeclaration(Accessibility accessibility, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode IndexerDeclaration(IEnumerable`1<SyntaxNode> parameters, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public SyntaxNode IndexerDeclaration(IPropertySymbol indexer, IEnumerable`1<SyntaxNode> getAccessorStatements, IEnumerable`1<SyntaxNode> setAccessorStatements);
    public abstract virtual SyntaxNode AddEventHandler(SyntaxNode event, SyntaxNode handler);
    public abstract virtual SyntaxNode RemoveEventHandler(SyntaxNode event, SyntaxNode handler);
    public abstract virtual SyntaxNode EventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode EventDeclaration(IEventSymbol symbol);
    public abstract virtual SyntaxNode CustomEventDeclaration(string name, SyntaxNode type, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public SyntaxNode CustomEventDeclaration(IEventSymbol symbol, IEnumerable`1<SyntaxNode> addAccessorStatements, IEnumerable`1<SyntaxNode> removeAccessorStatements);
    public abstract virtual SyntaxNode ConstructorDeclaration(string containingTypeName, IEnumerable`1<SyntaxNode> parameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ConstructorDeclaration(IMethodSymbol constructorMethod, IEnumerable`1<SyntaxNode> baseConstructorArguments, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPublicInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType);
    public abstract virtual SyntaxNode AsPrivateInterfaceImplementation(SyntaxNode declaration, SyntaxNode interfaceType, string interfaceMemberName);
    public abstract virtual SyntaxNode ClassDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, SyntaxNode baseType, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode StructDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode InterfaceDeclaration(string name, IEnumerable`1<string> typeParameters, Accessibility accessibility, IEnumerable`1<SyntaxNode> interfaceTypes, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumDeclaration(string name, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    internal abstract virtual SyntaxNode EnumDeclaration(string name, SyntaxNode underlyingType, Accessibility accessibility, DeclarationModifiers modifiers, IEnumerable`1<SyntaxNode> members);
    public abstract virtual SyntaxNode EnumMember(string name, SyntaxNode expression);
    public abstract virtual SyntaxNode DelegateDeclaration(string name, IEnumerable`1<SyntaxNode> parameters, IEnumerable`1<string> typeParameters, SyntaxNode returnType, Accessibility accessibility, DeclarationModifiers modifiers);
    public SyntaxNode Declaration(ISymbol symbol);
    private static bool CanBeDeclared(ISymbol symbol);
    private SyntaxNode WithTypeParametersAndConstraints(SyntaxNode declaration, ImmutableArray`1<ITypeParameterSymbol> typeParameters);
    internal abstract virtual SyntaxNode WithExplicitInterfaceImplementations(SyntaxNode declaration, ImmutableArray`1<ISymbol> explicitInterfaceImplementations, bool removeDefaults);
    public abstract virtual SyntaxNode WithTypeParameters(SyntaxNode declaration, IEnumerable`1<string> typeParameters);
    public SyntaxNode WithTypeParameters(SyntaxNode declaration, String[] typeParameters);
    public abstract virtual SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, IEnumerable`1<SyntaxNode> types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SpecialTypeConstraintKind kinds, SyntaxNode[] types);
    public SyntaxNode WithTypeConstraint(SyntaxNode declaration, string typeParameterName, SyntaxNode[] types);
    public abstract virtual SyntaxNode NamespaceDeclaration(SyntaxNode name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(SyntaxNode name, SyntaxNode[] declarations);
    public SyntaxNode NamespaceDeclaration(string name, IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode NamespaceDeclaration(string name, SyntaxNode[] declarations);
    public abstract virtual SyntaxNode CompilationUnit(IEnumerable`1<SyntaxNode> declarations);
    public SyntaxNode CompilationUnit(SyntaxNode[] declarations);
    public abstract virtual SyntaxNode NamespaceImportDeclaration(SyntaxNode name);
    public SyntaxNode NamespaceImportDeclaration(string name);
    public SyntaxNode AliasImportDeclaration(string aliasIdentifierName, INamespaceOrTypeSymbol symbol);
    public abstract virtual SyntaxNode AliasImportDeclaration(string aliasIdentifierName, SyntaxNode name);
    public abstract virtual SyntaxNode Attribute(SyntaxNode name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode Attribute(string name, SyntaxNode[] attributeArguments);
    public SyntaxNode Attribute(AttributeData attribute);
    public abstract virtual SyntaxNode AttributeArgument(string name, SyntaxNode expression);
    public SyntaxNode AttributeArgument(SyntaxNode expression);
    public SyntaxNode RemoveAllAttributes(SyntaxNode declaration);
    internal abstract virtual SyntaxNode RemoveAllComments(SyntaxNode node);
    internal SyntaxNode RemoveLeadingAndTrailingComments(SyntaxNode node);
    internal SyntaxToken RemoveLeadingAndTrailingComments(SyntaxToken token);
    internal abstract virtual SyntaxTriviaList RemoveCommentLines(SyntaxTriviaList syntaxTriviaList);
    internal abstract virtual bool IsRegularOrDocComment(SyntaxTrivia trivia);
    internal SyntaxNode RemoveAllTypeInheritance(SyntaxNode declaration);
    internal abstract virtual ImmutableArray`1<SyntaxNode> GetTypeInheritance(SyntaxNode declaration);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetReturnAttributes(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode InsertReturnAttributes(SyntaxNode declaration, int index, SyntaxNode[] attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, IEnumerable`1<SyntaxNode> attributes);
    public SyntaxNode AddReturnAttributes(SyntaxNode declaration, SyntaxNode[] attributes);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAttributeArguments(SyntaxNode attributeDeclaration);
    public abstract virtual SyntaxNode InsertAttributeArguments(SyntaxNode attributeDeclaration, int index, IEnumerable`1<SyntaxNode> attributeArguments);
    public SyntaxNode AddAttributeArguments(SyntaxNode attributeDeclaration, IEnumerable`1<SyntaxNode> attributeArguments);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetNamespaceImports(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode InsertNamespaceImports(SyntaxNode declaration, int index, SyntaxNode[] imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, IEnumerable`1<SyntaxNode> imports);
    public SyntaxNode AddNamespaceImports(SyntaxNode declaration, SyntaxNode[] imports);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetMembers(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertMembers(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode InsertMembers(SyntaxNode declaration, int index, SyntaxNode[] members);
    public SyntaxNode AddMembers(SyntaxNode declaration, IEnumerable`1<SyntaxNode> members);
    public SyntaxNode AddMembers(SyntaxNode declaration, SyntaxNode[] members);
    public abstract virtual Accessibility GetAccessibility(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithAccessibility(SyntaxNode declaration, Accessibility accessibility);
    public abstract virtual DeclarationModifiers GetModifiers(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithModifiers(SyntaxNode declaration, DeclarationModifiers modifiers);
    public abstract virtual DeclarationKind GetDeclarationKind(SyntaxNode declaration);
    public abstract virtual string GetName(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithName(SyntaxNode declaration, string name);
    public abstract virtual SyntaxNode GetType(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithType(SyntaxNode declaration, SyntaxNode type);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetParameters(SyntaxNode declaration);
    internal abstract virtual SyntaxNode GetParameterListNode(SyntaxNode declaration);
    public abstract virtual SyntaxNode InsertParameters(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> parameters);
    public SyntaxNode AddParameters(SyntaxNode declaration, IEnumerable`1<SyntaxNode> parameters);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetSwitchSections(SyntaxNode switchStatement);
    public abstract virtual SyntaxNode InsertSwitchSections(SyntaxNode switchStatement, int index, IEnumerable`1<SyntaxNode> switchSections);
    public SyntaxNode AddSwitchSections(SyntaxNode switchStatement, IEnumerable`1<SyntaxNode> switchSections);
    public abstract virtual SyntaxNode GetExpression(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithExpression(SyntaxNode declaration, SyntaxNode expression);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetAccessors(SyntaxNode declaration);
    public SyntaxNode GetAccessor(SyntaxNode declaration, DeclarationKind kind);
    public abstract virtual SyntaxNode InsertAccessors(SyntaxNode declaration, int index, IEnumerable`1<SyntaxNode> accessors);
    public SyntaxNode AddAccessors(SyntaxNode declaration, IEnumerable`1<SyntaxNode> accessors);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetGetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithGetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetSetAccessorStatements(SyntaxNode declaration);
    public abstract virtual SyntaxNode WithSetAccessorStatements(SyntaxNode declaration, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetBaseAndInterfaceTypes(SyntaxNode declaration);
    public abstract virtual SyntaxNode AddBaseType(SyntaxNode declaration, SyntaxNode baseType);
    public abstract virtual SyntaxNode AddInterfaceType(SyntaxNode declaration, SyntaxNode interfaceType);
    internal abstract virtual SyntaxNode AsInterfaceMember(SyntaxNode member);
    public virtual SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, SyntaxNode newDeclaration);
    internal static SyntaxNode ReplaceNode(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesBefore(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode InsertNodesAfter(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> newDeclarations);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node);
    public virtual SyntaxNode RemoveNode(SyntaxNode root, SyntaxNode node, SyntaxRemoveOptions options);
    public SyntaxNode RemoveNodes(SyntaxNode root, IEnumerable`1<SyntaxNode> declarations);
    [NullableContextAttribute("0")]
internal abstract virtual SeparatedSyntaxList`1<TElement> SeparatedList(SyntaxNodeOrTokenList list);
    internal abstract virtual SeparatedSyntaxList`1<TElement> SeparatedList(IEnumerable`1<TElement> nodes, IEnumerable`1<SyntaxToken> separators);
    internal static SyntaxTokenList Merge(SyntaxTokenList original, SyntaxTokenList newList);
    private static bool Any(SyntaxTokenList original, int rawKind);
    protected static SyntaxNode PreserveTrivia(TNode node, Func`2<TNode, SyntaxNode> nodeChanger);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxNode original, SyntaxNode replacement);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, TNode original, Func`2<TNode, SyntaxNode> replacer);
    protected static SyntaxNode ReplaceWithTrivia(SyntaxNode root, SyntaxToken original, SyntaxToken replacement);
    public abstract virtual TNode ClearTrivia(TNode node);
    protected int IndexOf(IReadOnlyList`1<T> list, T element);
    protected static SyntaxNode ReplaceRange(SyntaxNode root, SyntaxNode node, IEnumerable`1<SyntaxNode> replacements);
    [NullableContextAttribute("0")]
protected static SeparatedSyntaxList`1<TNode> RemoveRange(SeparatedSyntaxList`1<TNode> list, int offset, int count);
    [NullableContextAttribute("0")]
protected static SyntaxList`1<TNode> RemoveRange(SyntaxList`1<TNode> list, int offset, int count);
    public abstract virtual SyntaxNode ExpressionStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ReturnStatement(SyntaxNode expression);
    internal SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ThrowStatement(SyntaxNode expression);
    public abstract virtual SyntaxNode ThrowExpression(SyntaxNode expression);
    internal abstract virtual bool SupportsThrowExpression();
    internal bool RequiresLocalDeclarationType();
    public abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, string identifier, SyntaxNode initializer, bool isConst);
    [NullableContextAttribute("2")]
internal SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken identifier, SyntaxNode initializer, bool isConst);
    internal SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    internal SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    public SyntaxNode LocalDeclarationStatement(ITypeSymbol type, string name, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(string name, SyntaxNode initializer);
    internal SyntaxNode LocalDeclarationStatement(SyntaxToken name, SyntaxNode initializer);
    public abstract virtual SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, IEnumerable`1<SyntaxNode> falseStatements);
    public SyntaxNode IfStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> trueStatements, SyntaxNode falseStatement);
    public abstract virtual SyntaxNode SwitchStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> sections);
    public SyntaxNode SwitchStatement(SyntaxNode expression, SyntaxNode[] sections);
    public abstract virtual SyntaxNode SwitchSection(IEnumerable`1<SyntaxNode> caseExpressions, IEnumerable`1<SyntaxNode> statements);
    internal abstract virtual SyntaxNode SwitchSectionFromLabels(IEnumerable`1<SyntaxNode> labels, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode SwitchSection(SyntaxNode caseExpression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode DefaultSwitchSection(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode ExitSwitchStatement();
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode type, string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode UsingStatement(string name, SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode UsingStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode LockStatement(SyntaxNode expression, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> catchClauses, IEnumerable`1<SyntaxNode> finallyStatements);
    public SyntaxNode TryCatchStatement(IEnumerable`1<SyntaxNode> tryStatements, SyntaxNode[] catchClauses);
    public SyntaxNode TryFinallyStatement(IEnumerable`1<SyntaxNode> tryStatements, IEnumerable`1<SyntaxNode> finallyStatements);
    public abstract virtual SyntaxNode CatchClause(SyntaxNode type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode CatchClause(ITypeSymbol type, string identifier, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode WhileStatement(SyntaxNode condition, IEnumerable`1<SyntaxNode> statements);
    internal abstract virtual SyntaxNode ScopeBlock(IEnumerable`1<SyntaxNode> statements);
    internal abstract virtual SyntaxNode GlobalStatement(SyntaxNode statement);
    internal abstract virtual SyntaxToken NumericLiteralToken(string text, ulong value);
    internal SyntaxToken InterpolatedStringTextToken(string content, string value);
    internal SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    internal SyntaxNode Interpolation(SyntaxNode syntaxNode);
    internal SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    internal SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    internal SyntaxNode InterpolationFormatClause(string format);
    public abstract virtual SyntaxNode DefaultExpression(SyntaxNode type);
    public abstract virtual SyntaxNode DefaultExpression(ITypeSymbol type);
    public abstract virtual SyntaxNode ThisExpression();
    public abstract virtual SyntaxNode BaseExpression();
    public abstract virtual SyntaxNode LiteralExpression(object value);
    public abstract virtual SyntaxNode TypedConstantExpression(TypedConstant value);
    public SyntaxNode FalseLiteralExpression();
    public SyntaxNode TrueLiteralExpression();
    public SyntaxNode NullLiteralExpression();
    public abstract virtual SyntaxNode IdentifierName(string identifier);
    internal abstract virtual SyntaxNode IdentifierName(SyntaxToken identifier);
    internal SyntaxToken Identifier(string identifier);
    internal abstract virtual SyntaxNode NamedAnonymousObjectMemberDeclarator(SyntaxNode identifier, SyntaxNode expression);
    public abstract virtual SyntaxNode GenericName(string identifier, IEnumerable`1<SyntaxNode> typeArguments);
    internal abstract virtual SyntaxNode GenericName(SyntaxToken identifier, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode GenericName(string identifier, IEnumerable`1<ITypeSymbol> typeArguments);
    public SyntaxNode GenericName(string identifier, SyntaxNode[] typeArguments);
    public SyntaxNode GenericName(string identifier, ITypeSymbol[] typeArguments);
    public abstract virtual SyntaxNode WithTypeArguments(SyntaxNode expression, IEnumerable`1<SyntaxNode> typeArguments);
    public SyntaxNode WithTypeArguments(SyntaxNode expression, SyntaxNode[] typeArguments);
    public abstract virtual SyntaxNode QualifiedName(SyntaxNode left, SyntaxNode right);
    internal abstract virtual SyntaxNode GlobalAliasedName(SyntaxNode name);
    public SyntaxNode DottedName(string dottedName);
    public abstract virtual SyntaxNode NameExpression(INamespaceOrTypeSymbol namespaceOrTypeSymbol);
    public abstract virtual SyntaxNode TypeExpression(ITypeSymbol typeSymbol);
    public SyntaxNode TypeExpression(ITypeSymbol typeSymbol, bool addImport);
    public abstract virtual SyntaxNode TypeExpression(SpecialType specialType);
    public abstract virtual SyntaxNode ArrayTypeExpression(SyntaxNode type);
    public abstract virtual SyntaxNode NullableTypeExpression(SyntaxNode type);
    public SyntaxNode TupleTypeExpression(IEnumerable`1<SyntaxNode> elements);
    internal abstract virtual SyntaxNode CreateTupleType(IEnumerable`1<SyntaxNode> elements);
    public SyntaxNode TupleTypeExpression(SyntaxNode[] elements);
    public SyntaxNode TupleTypeExpression(IEnumerable`1<ITypeSymbol> elementTypes, IEnumerable`1<string> elementNames);
    public abstract virtual SyntaxNode TupleElementExpression(SyntaxNode type, string name);
    public SyntaxNode TupleElementExpression(ITypeSymbol type, string name);
    public abstract virtual SyntaxNode AssignmentStatement(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ValueNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ReferenceNotEqualsExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LessThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode GreaterThanOrEqualExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode NegateExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode AddExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode SubtractExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode MultiplyExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode DivideExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ModuloExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode BitwiseNotExpression(SyntaxNode operand);
    public abstract virtual SyntaxNode LogicalAndExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalOrExpression(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode LogicalNotExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode ConditionalExpression(SyntaxNode condition, SyntaxNode whenTrue, SyntaxNode whenFalse);
    public abstract virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public abstract virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public abstract virtual SyntaxNode ElementBindingExpression(IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ElementBindingExpression(SyntaxNode[] arguments);
    public abstract virtual SyntaxNode CoalesceExpression(SyntaxNode left, SyntaxNode right);
    public virtual SyntaxNode MemberAccessExpression(SyntaxNode expression, SyntaxNode memberName);
    internal abstract virtual SyntaxNode MemberAccessExpressionWorker(SyntaxNode expression, SyntaxNode memberName);
    internal SyntaxNode RefExpression(SyntaxNode expression);
    public SyntaxNode MemberAccessExpression(SyntaxNode expression, string memberName);
    public abstract virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, SyntaxNode size);
    public abstract virtual SyntaxNode ArrayCreationExpression(SyntaxNode elementType, IEnumerable`1<SyntaxNode> elements);
    public abstract virtual SyntaxNode ObjectCreationExpression(SyntaxNode namedType, IEnumerable`1<SyntaxNode> arguments);
    internal abstract virtual SyntaxNode ObjectCreationExpression(SyntaxNode namedType, SyntaxToken openParen, SeparatedSyntaxList`1<SyntaxNode> arguments, SyntaxToken closeParen);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ObjectCreationExpression(SyntaxNode type, SyntaxNode[] arguments);
    public SyntaxNode ObjectCreationExpression(ITypeSymbol type, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode InvocationExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode InvocationExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode Argument(string name, RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(RefKind refKind, SyntaxNode expression);
    public SyntaxNode Argument(SyntaxNode expression);
    public abstract virtual SyntaxNode ElementAccessExpression(SyntaxNode expression, IEnumerable`1<SyntaxNode> arguments);
    public SyntaxNode ElementAccessExpression(SyntaxNode expression, SyntaxNode[] arguments);
    public abstract virtual SyntaxNode TypeOfExpression(SyntaxNode type);
    public abstract virtual SyntaxNode IsTypeExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode IsTypeExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode TryCastExpression(SyntaxNode expression, SyntaxNode type);
    public SyntaxNode TryCastExpression(SyntaxNode expression, ITypeSymbol type);
    public abstract virtual SyntaxNode CastExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode CastExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ConvertExpression(SyntaxNode type, SyntaxNode expression);
    public SyntaxNode ConvertExpression(ITypeSymbol type, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, SyntaxNode expression);
    public abstract virtual SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> lambdaParameters, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(string parameterName, IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode ValueReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode VoidReturningLambdaExpression(SyntaxNode expression);
    public SyntaxNode ValueReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public SyntaxNode VoidReturningLambdaExpression(IEnumerable`1<SyntaxNode> statements);
    public abstract virtual SyntaxNode LambdaParameter(string identifier, SyntaxNode type);
    public SyntaxNode LambdaParameter(string identifier, ITypeSymbol type);
    public abstract virtual SyntaxNode AwaitExpression(SyntaxNode expression);
    internal SyntaxNode AddParentheses(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public abstract virtual SyntaxNode NameOfExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode TupleExpression(IEnumerable`1<SyntaxNode> arguments);
    internal abstract virtual SyntaxNode ParseExpression(string stringToParse);
    internal abstract virtual SyntaxTrivia Trivia(SyntaxNode node);
    internal abstract virtual SyntaxNode DocumentationCommentTrivia(IEnumerable`1<SyntaxNode> nodes, SyntaxTriviaList trailingTrivia, string endOfLineString);
    internal abstract virtual SyntaxNode DocumentationCommentTriviaWithUpdatedContent(SyntaxTrivia trivia, IEnumerable`1<SyntaxNode> content);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <MethodDeclaration>b__28_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <OperatorDeclaration>b__30_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <IndexerDeclaration>b__41_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <CustomEventDeclaration>b__47_1(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <ConstructorDeclaration>b__49_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <Declaration>b__61_0(IParameterSymbol p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__83_0(TypedConstant a);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <Attribute>b__83_1(KeyValuePair`2<string, TypedConstant> n);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SyntaxNode <TupleTypeExpression>b__244_0(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Editing.SyntaxGeneratorInternal : object {
    public ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual SyntaxTrivia EndOfLine(string text);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode LocalDeclarationStatement(SyntaxNode type, SyntaxToken identifier, SyntaxNode initializer, bool isConst);
    public SyntaxNode LocalDeclarationStatement(SyntaxToken name, SyntaxNode initializer);
    public abstract virtual SyntaxNode WithInitializer(SyntaxNode variableDeclarator, SyntaxNode initializer);
    public abstract virtual SyntaxNode EqualsValueClause(SyntaxToken operatorToken, SyntaxNode value);
    public abstract virtual SyntaxToken Identifier(string identifier);
    public abstract virtual SyntaxNode ConditionalAccessExpression(SyntaxNode expression, SyntaxNode whenNotNull);
    public abstract virtual SyntaxNode MemberBindingExpression(SyntaxNode name);
    public abstract virtual SyntaxNode RefExpression(SyntaxNode expression);
    public abstract virtual SyntaxNode AddParentheses(SyntaxNode expression, bool includeElasticTrivia, bool addSimplifierAnnotation);
    public abstract virtual SyntaxNode YieldReturnStatement(SyntaxNode expression);
    public abstract virtual bool RequiresLocalDeclarationType();
    public abstract virtual SyntaxToken InterpolatedStringTextToken(string content, string value);
    public abstract virtual SyntaxNode InterpolatedStringText(SyntaxToken textToken);
    public abstract virtual SyntaxNode Interpolation(SyntaxNode syntaxNode);
    public abstract virtual SyntaxNode InterpolatedStringExpression(SyntaxToken startToken, IEnumerable`1<SyntaxNode> content, SyntaxToken endToken);
    public abstract virtual SyntaxNode InterpolationAlignmentClause(SyntaxNode alignment);
    public abstract virtual SyntaxNode InterpolationFormatClause(string format);
    public abstract virtual SyntaxNode TypeParameterList(IEnumerable`1<string> typeParameterNames);
    public abstract virtual SyntaxNode Type(ITypeSymbol typeSymbol, bool typeContext);
    public abstract virtual SyntaxNode NegateEquality(SyntaxGenerator generator, SyntaxNode binaryExpression, SyntaxNode left, BinaryOperatorKind negatedKind, SyntaxNode right);
    public abstract virtual SyntaxNode IsNotTypeExpression(SyntaxNode expression, SyntaxNode type);
    public abstract virtual bool SupportsPatterns(ParseOptions options);
    public abstract virtual SyntaxNode IsPatternExpression(SyntaxNode expression, SyntaxToken isToken, SyntaxNode pattern);
    public abstract virtual SyntaxNode AndPattern(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode DeclarationPattern(INamedTypeSymbol type, string name);
    public abstract virtual SyntaxNode ConstantPattern(SyntaxNode expression);
    public abstract virtual SyntaxNode NotPattern(SyntaxNode pattern);
    public abstract virtual SyntaxNode OrPattern(SyntaxNode left, SyntaxNode right);
    public abstract virtual SyntaxNode ParenthesizedPattern(SyntaxNode pattern);
    public abstract virtual SyntaxNode TypePattern(SyntaxNode type);
    public abstract virtual SyntaxNode UnaryPattern(SyntaxToken operatorToken, SyntaxNode pattern);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.EditorConfig.Language : Enum {
    public int value__;
    public static Language CSharp;
    public static Language VisualBasic;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.LanguageConstants : object {
    public static string DefaultCSharpPath;
    public static string DefaultCSharpSplat;
    public static string DefaultCSharpExtension;
    public static string DefaultCSharpExtensionWithoutDot;
    public static string DefaultVisualBasicPath;
    public static string DefaultVisualBasicSplat;
    public static string DefaultVisualBasicExtension;
    public static string DefaultVisualBasicExtensionWithoutDot;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditorConfig.LanguageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool TryGetLanguageFromFilePath(string filePath, Language& language);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigFile`1 : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<T> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ImmutableArray`1<Section>> _sections;
    [NullableAttribute("1")]
protected Type EqualityContract { get; }
    public string FilePath { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<T> Options { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<Section> Sections { get; }
    public EditorConfigFile`1(string FilePath, ImmutableArray`1<T> Options);
    [CompilerGeneratedAttribute]
protected EditorConfigFile`1(EditorConfigFile`1<T> original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<T> get_Options();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Options(ImmutableArray`1<T> value);
    public ImmutableArray`1<Section> get_Sections();
    public bool TryGetSectionForLanguage(Language language, Section& sectionResult);
    public bool TryGetSectionForLanguage(Language language, SectionMatch matchKind, Section& sectionResult);
    [NullableContextAttribute("1")]
public bool TryGetSectionForFilePath(string filePath, Section& sectionResult);
    [NullableContextAttribute("1")]
public bool TryGetSectionForFilePath(string filePath, SectionMatch matchKind, Section& sectionResult);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigFile`1<T> left, EditorConfigFile`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigFile`1<T> left, EditorConfigFile`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigFile`1<T> other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigFile`1<T> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FilePath, ImmutableArray`1& Options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption : object {
    [CompilerGeneratedAttribute]
private Section <Section>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TextSpan> <Span>k__BackingField;
    protected Type EqualityContract { get; }
    public Section Section { get; public set; }
    public Nullable`1<TextSpan> Span { get; public set; }
    public EditorConfigOption(Section Section, Nullable`1<TextSpan> Span);
    [CompilerGeneratedAttribute]
protected EditorConfigOption(EditorConfigOption original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public Section get_Section();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Section(Section value);
    [CompilerGeneratedAttribute]
public Nullable`1<TextSpan> get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(Nullable`1<TextSpan> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigOption left, EditorConfigOption right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigOption left, EditorConfigOption right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigOption other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, Nullable`1& Span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigOption`1 : EditorConfigOption {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    protected Type EqualityContract { get; }
    public T Value { get; public set; }
    public EditorConfigOption`1(Section Section, Nullable`1<TextSpan> Span, T Value);
    [CompilerGeneratedAttribute]
protected EditorConfigOption`1(EditorConfigOption`1<T> original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Value(T value);
    public static T op_Implicit(EditorConfigOption`1<T> option);
    public static EditorConfigOption`1<T> op_Implicit(ValueTuple`3<Section, Nullable`1<TextSpan>, T> tuple);
    public static EditorConfigOption`1<T> op_Implicit(ValueTuple`2<Section, T> tuple);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigOption`1<T> left, EditorConfigOption`1<T> right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigOption`1<T> left, EditorConfigOption`1<T> right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigOption other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigOption`1<T> other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, Nullable`1& Span, T& Value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.EditorConfigParser : object {
    private static Regex s_sectionMatcher;
    private static Regex s_propertyMatcher;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> <ReservedKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> <ReservedValues>k__BackingField;
    private static ImmutableHashSet`1<string> ReservedKeys { get; }
    private static ImmutableHashSet`1<string> ReservedValues { get; }
    private static EditorConfigParser();
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> get_ReservedKeys();
    [CompilerGeneratedAttribute]
private static ImmutableHashSet`1<string> get_ReservedValues();
    public static TEditorConfigFile Parse(string text, string pathToFile, TAccumulator accumulator);
    public static TEditorConfigFile Parse(SourceText text, string pathToFile, TAccumulator accumulator);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static void <Parse>g__ProcessActiveSection|9_0(<>c__DisplayClass9_0`3& );
    [CompilerGeneratedAttribute]
internal static bool <Parse>g__IsComment|9_1(string line);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.EditorConfig.Parsing.IEditorConfigOptionAccumulator`2 {
    public abstract virtual void ProcessSection(Section section, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties);
    public abstract virtual TResults Complete(string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.ApplicableSymbolInfo : object {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <OptionName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> <SymbolKinds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<Accessibility>> <Accessibilities>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<ImmutableArray`1<ModifierKind>> <Modifiers>k__BackingField;
    protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> OptionName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> SymbolKinds { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<Accessibility>> Accessibilities { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<ImmutableArray`1<ModifierKind>> Modifiers { get; public set; }
    public ApplicableSymbolInfo(EditorConfigOption`1<string> OptionName, EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> SymbolKinds, EditorConfigOption`1<ImmutableArray`1<Accessibility>> Accessibilities, EditorConfigOption`1<ImmutableArray`1<ModifierKind>> Modifiers);
    [CompilerGeneratedAttribute]
protected ApplicableSymbolInfo(ApplicableSymbolInfo original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_OptionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OptionName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> get_SymbolKinds();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SymbolKinds(EditorConfigOption`1<ImmutableArray`1<SymbolKindOrTypeKind>> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<Accessibility>> get_Accessibilities();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Accessibilities(EditorConfigOption`1<ImmutableArray`1<Accessibility>> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ImmutableArray`1<ModifierKind>> get_Modifiers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Modifiers(EditorConfigOption`1<ImmutableArray`1<ModifierKind>> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ApplicableSymbolInfo left, ApplicableSymbolInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ApplicableSymbolInfo left, ApplicableSymbolInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ApplicableSymbolInfo other);
    [CompilerGeneratedAttribute]
public virtual ApplicableSymbolInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(EditorConfigOption`1& OptionName, EditorConfigOption`1& SymbolKinds, EditorConfigOption`1& Accessibilities, EditorConfigOption`1& Modifiers);
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStyles : EditorConfigFile`1<NamingStyleOption> {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<NamingStyleOption> <Rules>k__BackingField;
    [NullableAttribute("1")]
protected Type EqualityContract { get; }
    public string FileName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<NamingStyleOption> Rules { get; public set; }
    public EditorConfigNamingStyles(string FileName, ImmutableArray`1<NamingStyleOption> Rules);
    [CompilerGeneratedAttribute]
protected EditorConfigNamingStyles(EditorConfigNamingStyles original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileName(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<NamingStyleOption> get_Rules();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Rules(ImmutableArray`1<NamingStyleOption> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(EditorConfigNamingStyles left, EditorConfigNamingStyles right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(EditorConfigNamingStyles left, EditorConfigNamingStyles right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigFile`1<NamingStyleOption> other);
    [CompilerGeneratedAttribute]
public virtual bool Equals(EditorConfigNamingStyles other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual EditorConfigFile`1<NamingStyleOption> <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& FileName, ImmutableArray`1& Rules);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.EditorConfigNamingStylesParser : object {
    public static EditorConfigNamingStyles Parse(string editorConfigText, string pathToEditorConfigFile);
    public static EditorConfigNamingStyles Parse(SourceText editorConfigText, string pathToEditorConfigFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingScheme : object {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <OptionName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <Prefix>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <Suffix>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <WordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<Capitalization> <Capitalization>k__BackingField;
    protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> OptionName { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> Prefix { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> Suffix { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EditorConfigOption`1<string> WordSeparator { get; public set; }
    public EditorConfigOption`1<Capitalization> Capitalization { get; public set; }
    public NamingScheme(EditorConfigOption`1<string> OptionName, EditorConfigOption`1<string> Prefix, EditorConfigOption`1<string> Suffix, EditorConfigOption`1<string> WordSeparator, EditorConfigOption`1<Capitalization> Capitalization);
    [CompilerGeneratedAttribute]
protected NamingScheme(NamingScheme original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_OptionName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OptionName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_WordSeparator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WordSeparator(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<Capitalization> get_Capitalization();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Capitalization(EditorConfigOption`1<Capitalization> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingScheme left, NamingScheme right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingScheme left, NamingScheme right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(NamingScheme other);
    [CompilerGeneratedAttribute]
public virtual NamingScheme <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(EditorConfigOption`1& OptionName, EditorConfigOption`1& Prefix, EditorConfigOption`1& Suffix, EditorConfigOption`1& WordSeparator, EditorConfigOption`1& Capitalization);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOption : EditorConfigOption {
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<string> <RuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicableSymbolInfo <ApplicableSymbolInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private NamingScheme <NamingScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private EditorConfigOption`1<ReportDiagnostic> <Severity>k__BackingField;
    protected Type EqualityContract { get; }
    public EditorConfigOption`1<string> RuleName { get; public set; }
    public ApplicableSymbolInfo ApplicableSymbolInfo { get; public set; }
    public NamingScheme NamingScheme { get; public set; }
    public EditorConfigOption`1<ReportDiagnostic> Severity { get; public set; }
    public NamingStyleOption(Section Section, EditorConfigOption`1<string> RuleName, ApplicableSymbolInfo ApplicableSymbolInfo, NamingScheme NamingScheme, EditorConfigOption`1<ReportDiagnostic> Severity);
    [CompilerGeneratedAttribute]
protected NamingStyleOption(NamingStyleOption original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<string> get_RuleName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RuleName(EditorConfigOption`1<string> value);
    [CompilerGeneratedAttribute]
public ApplicableSymbolInfo get_ApplicableSymbolInfo();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ApplicableSymbolInfo(ApplicableSymbolInfo value);
    [CompilerGeneratedAttribute]
public NamingScheme get_NamingScheme();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NamingScheme(NamingScheme value);
    [CompilerGeneratedAttribute]
public EditorConfigOption`1<ReportDiagnostic> get_Severity();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Severity(EditorConfigOption`1<ReportDiagnostic> value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NamingStyleOption left, NamingStyleOption right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NamingStyleOption left, NamingStyleOption right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(EditorConfigOption other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(NamingStyleOption other);
    [CompilerGeneratedAttribute]
public virtual EditorConfigOption <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Section& Section, EditorConfigOption`1& RuleName, ApplicableSymbolInfo& ApplicableSymbolInfo, NamingScheme& NamingScheme, EditorConfigOption`1& Severity);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.NamingStyles.NamingStyleOptionAccumulator : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<NamingStyleOption> _rules;
    public sealed virtual EditorConfigNamingStyles Complete(string fileName);
    public sealed virtual void ProcessSection(Section section, IReadOnlyDictionary`2<string, ValueTuple`2<string, Nullable`1<TextLine>>> properties);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.Section : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobal>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullText>k__BackingField;
    private Nullable`1<SectionMatcher> _matcher;
    [NullableAttribute("2")]
private string _containingDirectory;
    [NullableAttribute("2")]
public string FilePath { get; public set; }
    public bool IsGlobal { get; public set; }
    public TextSpan Span { get; public set; }
    public string Text { get; public set; }
    public string FullText { get; public set; }
    private bool IsSplatHeader { get; }
    public Section(string filePath, bool isGlobal, TextSpan span, string text, string fullText);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    [CompilerGeneratedAttribute]
public bool get_IsGlobal();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsGlobal(bool value);
    [CompilerGeneratedAttribute]
public TextSpan get_Span();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Span(TextSpan value);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(string value);
    [CompilerGeneratedAttribute]
public string get_FullText();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FullText(string value);
    private bool get_IsSplatHeader();
    [NullableContextAttribute("2")]
public static string GetHeaderTextForLanguage(Language language);
    public bool SupportsLanguage(Language language, SectionMatch matchKind);
    public bool SupportsFilePath(string codeFilePath, SectionMatch matchKind);
    public SectionMatch GetMatchKind(Language language);
    public SectionMatch GetMatchKind(string codeFilePath);
    public static bool op_Inequality(Section left, Section right);
    public static bool op_Equality(Section left, Section right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Section other);
    public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
internal static string <GetMatchKind>g__GetPathRelativeToEditorconfig|29_0(string directoryContainingEditorconfig, string codeFilePath);
}
internal enum Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatch : Enum {
    public int value__;
    public static SectionMatch ExactLanguageMatch;
    public static SectionMatch ExactLanguageMatchWithOthers;
    public static SectionMatch AnyLanguageMatch;
    public static SectionMatch SupersetFilePatternMatch;
    public static SectionMatch FilePatternMatch;
    public static SectionMatch SplatMatch;
    public static SectionMatch GlobalSectionMatch;
    public static SectionMatch AnyButGlobal;
    public static SectionMatch Any;
    public static SectionMatch NoMatch;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatcher : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("0")]
private ImmutableArray`1<ValueTuple`2<int, int>> _numberRangePairs;
    private string _headerText;
    private static Regex s_multiFileWithDotOutside;
    private static Regex s_multiFileWithDotInside;
    private static Regex s_fileExtensionMatcher;
    [CompilerGeneratedAttribute]
private Regex <Regex>k__BackingField;
    private Regex Regex { get; }
    private SectionMatcher(Regex regex, string headerText, ImmutableArray`1<ValueTuple`2<int, int>> numberRangePairs);
    private static SectionMatcher();
    [CompilerGeneratedAttribute]
private Regex get_Regex();
    public bool IsLanguageMatch(Language language, SectionMatch matchKind);
    public bool IsPathMatch(string relativePath, SectionMatch matchKind);
    public SectionMatch GetLanguageMatchKind(Language language);
    public SectionMatch GetPathMatchKind(string relativePath);
    private bool IsExactLanguageMatch(Language language);
    private bool IsExactLanguageMatchForCSharp(Language language);
    private bool IsExactLanguageMatchForVisualBasic(Language language);
    private bool IsExactLanguageMatchForBothVisualBasicAndCSharp(Language language);
    private static bool MatchesBothLanguages(string text, Regex pattern, string firstFileExtension, string secondFileExtension);
    private bool IsExactLanguageMatchWithOthers(Language language);
    private bool IsExactMatchForCSharpWithOthers(Language language);
    private bool IsExactMatchForVisualBasicWithOthers(Language language);
    private static bool IsMatchWithOthers(string text, Regex pattern, string mustMatchFileExtension, string mustNotMatchFileExtension);
    private bool IsExactMatchForBothVisualBasicAndCSharpWithOthers(Language language);
    private static bool MatchesBothLanguagesWithOthers(string text, Regex pattern, string firstFileExtension, string secondFileExtension);
    private bool IsAnyLanguageMatch(Language language);
    private bool IsAnyLanguageMatchForCSharp(Language language);
    private bool IsAnyLanguageMatchForVisualBasic(Language language);
    private bool IsFilePatternMatch(Language language);
    private bool IsCSharpFilePatternMatch(Language language);
    private bool IsVisualBasicFilePatternMatch(Language language);
    private bool IsPatternMatchForBothVisualBasicAndCSharp(Language language);
    private static bool IsSuperSet(Language language, string pattern);
    private static bool IsCSharpSuperSet(Language language, string pattern);
    private static bool IsVisualBasicSuperSet(Language language, string pattern);
    private static bool IsCSharpOrVisualBasicSuperSet(Language language, string pattern);
    private bool IsPathMatch(string s);
    public static bool TryParseSection(string headerText, SectionMatcher& matcher);
    private static bool TryCompilePathList(Lexer& lexer, StringBuilder sb, bool parsingChoice, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
    private static Nullable`1<ValueTuple`2<string, string>> TryParseNumberRange(Lexer& lexer);
    private static bool TryCompileCharacterClass(Lexer& lexer, StringBuilder sb);
    private static bool TryCompileChoice(Lexer& lexer, StringBuilder sb, ArrayBuilder`1<ValueTuple`2<int, int>> numberRangePairs);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.EditorConfig.Parsing.SectionMatchExtensions : object {
    [ExtensionAttribute]
public static bool IsWorseMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsWorseOrEqualMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsBetterMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
    [ExtensionAttribute]
public static bool IsBetterOrEqualMatchThan(SectionMatch actualMatchKind, SectionMatch expectedMatchKind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.EditorConfigSeverityStrings : object {
    public static string None;
    public static string Refactoring;
    public static string Silent;
    public static string Suggestion;
    public static string Warning;
    public static string Error;
    public static bool TryParse(string editorconfigSeverityString, ReportDiagnostic& reportDiagnostic);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedDiagnostic : ValueType {
    public string Message;
    public TextSpan Span;
    public EmbeddedDiagnostic(string message, TextSpan span);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(EmbeddedDiagnostic other);
    public virtual string ToString();
    public virtual int GetHashCode();
    public static bool op_Equality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
    public static bool op_Inequality(EmbeddedDiagnostic diagnostic1, EmbeddedDiagnostic diagnostic2);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSeparatedSyntaxNodeList`3 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> <NodesAndTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SeparatorLength>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static EmbeddedSeparatedSyntaxNodeList`3<TSyntaxKind, TSyntaxNode, TDerivedNode> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> NodesAndTokens { get; }
    public int Length { get; }
    public int SeparatorLength { get; }
    [NullableAttribute("1")]
public TDerivedNode Item { get; }
    public EmbeddedSeparatedSyntaxNodeList`3(ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> nodesAndTokens);
    private static EmbeddedSeparatedSyntaxNodeList`3();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode>> get_NodesAndTokens();
    [CompilerGeneratedAttribute]
public int get_Length();
    [CompilerGeneratedAttribute]
public int get_SeparatorLength();
    [ConditionalAttribute("DEBUG")]
private void Verify();
    [NullableContextAttribute("1")]
public TDerivedNode get_Item(int index);
    public Enumerator<TSyntaxKind, TSyntaxNode, TDerivedNode> GetEnumerator();
}
internal static class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxHelpers : object {
    public static TextSpan GetSpan(EmbeddedSyntaxToken`1<TSyntaxKind> token1, EmbeddedSyntaxToken`1<TSyntaxKind> token2);
    public static TextSpan GetSpan(VirtualCharSequence virtualChars);
    public static TextSpan GetSpan(VirtualChar firstChar, VirtualChar lastChar);
}
[DefaultMemberAttribute("Item")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNode`2 : object {
    public TSyntaxKind Kind;
    private Nullable`1<TextSpan> _fullSpan;
    internal int ChildCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> Item { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> Item { get; }
    protected EmbeddedSyntaxNode`2(TSyntaxKind kind);
    internal abstract virtual int get_ChildCount();
    internal abstract virtual EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> ChildAt(int index);
    public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> get_Item(int index);
    public EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> get_Item(Index index);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    private Nullable`1<TextSpan> ComputeFullSpan();
    private void GetSpan(Int32& start, Int32& end);
    public bool Contains(VirtualChar virtualChar);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToFullString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb, bool leading, bool trailing);
    public Enumerator<TSyntaxKind, TSyntaxNode> GetEnumerator();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeStart|12_0();
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ComputeFullSpan>g__ComputeEnd|12_1();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxNodeOrToken`2 : ValueType {
    private EmbeddedSyntaxToken`1<TSyntaxKind> _token;
    [NullableAttribute("2")]
public TSyntaxNode Node;
    public EmbeddedSyntaxToken`1<TSyntaxKind> Token { get; }
    public TSyntaxKind Kind { get; }
    [MemberNotNullWhenAttribute("True", "Node")]
public bool IsNode { get; }
    [NullableContextAttribute("2")]
private EmbeddedSyntaxNodeOrToken`2(TSyntaxNode node);
    private EmbeddedSyntaxNodeOrToken`2(EmbeddedSyntaxToken`1<TSyntaxKind> token);
    public EmbeddedSyntaxToken`1<TSyntaxKind> get_Token();
    public TSyntaxKind get_Kind();
    [MemberNotNullWhenAttribute("True", "Node")]
public bool get_IsNode();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("2")]
public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(TSyntaxNode node);
    public static EmbeddedSyntaxNodeOrToken`2<TSyntaxKind, TSyntaxNode> op_Implicit(EmbeddedSyntaxToken`1<TSyntaxKind> token);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxToken`1 : ValueType {
    public TSyntaxKind Kind;
    public ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> LeadingTrivia;
    public VirtualCharSequence VirtualChars;
    public ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> TrailingTrivia;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    [NullableAttribute("1")]
public object Value;
    public bool IsMissing { get; }
    public EmbeddedSyntaxToken`1(TSyntaxKind kind, ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> leadingTrivia, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>> trailingTrivia, ImmutableArray`1<EmbeddedDiagnostic> diagnostics, object value);
    public bool get_IsMissing();
    public EmbeddedSyntaxToken`1<TSyntaxKind> AddDiagnosticIfNone(EmbeddedDiagnostic diagnostic);
    public EmbeddedSyntaxToken`1<TSyntaxKind> WithDiagnostics(ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public EmbeddedSyntaxToken`1<TSyntaxKind> With(Optional`1<TSyntaxKind> kind, Optional`1<ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>>> leadingTrivia, Optional`1<VirtualCharSequence> virtualChars, Optional`1<ImmutableArray`1<EmbeddedSyntaxTrivia`1<TSyntaxKind>>> trailingTrivia, Optional`1<ImmutableArray`1<EmbeddedDiagnostic>> diagnostics, Optional`1<object> value);
    public TextSpan GetSpan();
    public Nullable`1<TextSpan> GetFullSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToFullString();
    [NullableContextAttribute("1")]
public void WriteTo(StringBuilder sb, bool leading, bool trailing);
}
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTree`3 : object {
    public VirtualCharSequence Text;
    [NullableAttribute("1")]
public TCompilationUnitSyntax Root;
    public ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    protected EmbeddedSyntaxTree`3(VirtualCharSequence text, TCompilationUnitSyntax root, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.Common.EmbeddedSyntaxTrivia`1 : ValueType {
    public TSyntaxKind Kind;
    public VirtualCharSequence VirtualChars;
    internal ImmutableArray`1<EmbeddedDiagnostic> Diagnostics;
    public EmbeddedSyntaxTrivia`1(TSyntaxKind kind, VirtualCharSequence virtualChars, ImmutableArray`1<EmbeddedDiagnostic> diagnostics);
    public TextSpan GetSpan();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.AbstractVirtualCharService : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapedChar);
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual VirtualCharSequence TryConvertToVirtualCharsWorker(SyntaxToken token);
    protected abstract virtual bool IsMultiLineRawStringToken(SyntaxToken token);
    protected static bool IsLegalBraceEscape(string tokenText, int index, int offset, TextSpan& span);
    public sealed virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    [ConditionalAttribute("DEBUG")]
private void CheckInvariants(SyntaxToken token, VirtualCharSequence result);
    protected static VirtualCharSequence TryConvertSimpleDoubleQuoteString(SyntaxToken token, string startDelimiter, string endDelimiter, bool escapeBraces);
    protected static int ConvertTextAtIndexToRune(string tokenText, int index, Builder<VirtualChar> result, int offset);
    protected static int ConvertTextAtIndexToRune(SourceText tokenText, int index, Builder<VirtualChar> result, int offset);
    private static int ConvertTextAtIndexToRune(T tokenText, int index, TTextInfo info, Builder<VirtualChar> result, int offset);
    protected static bool IsOpenOrCloseBrace(char ch);
    protected static VirtualCharSequence CreateVirtualCharSequence(string tokenText, int offset, int startIndexInclusive, int endIndexExclusive, Builder<VirtualChar> result);
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharLanguageService {
}
internal interface Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.IVirtualCharService {
    public abstract virtual VirtualCharSequence TryConvertToVirtualChars(SyntaxToken token);
    public abstract virtual bool TryGetEscapeCharacter(VirtualChar ch, Char& escapeChar);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualChar : ValueType {
    public Rune Rune;
    public char SurrogateChar;
    public TextSpan Span;
    public int Value { get; }
    public bool IsDigit { get; }
    public bool IsLetterOrDigit { get; }
    public bool IsWhiteSpace { get; }
    private VirtualChar(Rune rune, char surrogateChar, TextSpan span);
    public static VirtualChar Create(Rune rune, TextSpan span);
    public static VirtualChar Create(char surrogateChar, TextSpan span);
    public int get_Value();
    public bool get_IsDigit();
    public bool get_IsLetterOrDigit();
    public bool get_IsWhiteSpace();
    public static bool op_Equality(VirtualChar char1, VirtualChar char2);
    public static bool op_Inequality(VirtualChar char1, VirtualChar char2);
    public static bool op_Equality(VirtualChar ch1, char ch2);
    public static bool op_Inequality(VirtualChar ch1, char ch2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VirtualChar other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public void AppendTo(StringBuilder builder);
    public sealed virtual int CompareTo(VirtualChar other);
    public static bool op_LessThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThan(VirtualChar ch1, VirtualChar ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, VirtualChar ch2);
    public sealed virtual int CompareTo(char other);
    public static bool op_LessThan(VirtualChar ch1, char ch2);
    public static bool op_LessThanOrEqual(VirtualChar ch1, char ch2);
    public static bool op_GreaterThan(VirtualChar ch1, char ch2);
    public static bool op_GreaterThanOrEqual(VirtualChar ch1, char ch2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.EmbeddedLanguages.VirtualChars.VirtualCharSequence : ValueType {
    public static VirtualCharSequence Empty;
    private Chunk _leafCharacters;
    private TextSpan _span;
    public int Length { get; }
    public VirtualChar Item { get; }
    public bool IsDefault { get; }
    public bool IsEmpty { get; }
    public bool IsDefaultOrEmpty { get; }
    private VirtualCharSequence(Chunk sequence);
    private VirtualCharSequence(Chunk sequence, TextSpan span);
    private static VirtualCharSequence();
    [NullableContextAttribute("0")]
public static VirtualCharSequence Create(ImmutableSegmentedList`1<VirtualChar> virtualChars);
    public static VirtualCharSequence Create(int firstVirtualCharPosition, string underlyingData);
    public int get_Length();
    public VirtualChar get_Item(int index);
    public bool get_IsDefault();
    public bool get_IsEmpty();
    public bool get_IsDefaultOrEmpty();
    public VirtualCharSequence GetSubSequence(TextSpan span);
    public Enumerator GetEnumerator();
    public VirtualChar First();
    public VirtualChar Last();
    public Nullable`1<VirtualChar> Find(int position);
    public bool Contains(VirtualChar char);
    public int IndexOf(VirtualChar char);
    public Nullable`1<VirtualChar> FirstOrNull(Func`2<VirtualChar, bool> predicate);
    public Nullable`1<VirtualChar> LastOrNull(Func`2<VirtualChar, bool> predicate);
    public bool Any(Func`2<VirtualChar, bool> predicate);
    public bool All(Func`2<VirtualChar, bool> predicate);
    public VirtualCharSequence Skip(int count);
    public VirtualCharSequence SkipWhile(Func`2<VirtualChar, bool> predicate);
    public string CreateString();
    [ConditionalAttribute("DEBUG")]
public void AssertAdjacentTo(VirtualCharSequence virtualChars);
    public static VirtualCharSequence FromBounds(VirtualCharSequence chars1, VirtualCharSequence chars2);
}
internal interface Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService {
    public abstract virtual void LogException(object source, Exception exception);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService", "Default")]
[ExportAttribute("Microsoft.CodeAnalysis.ErrorLogger.IErrorLoggerService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.ErrorLogger.WorkspaceErrorLogger : object {
    public sealed virtual void LogException(object source, Exception exception);
    private static string ToLogFormat(Exception exception);
}
internal enum Microsoft.CodeAnalysis.ErrorReporting.ErrorSeverity : Enum {
    public int value__;
    public static ErrorSeverity Uncategorized;
    public static ErrorSeverity Diagnostic;
    public static ErrorSeverity General;
    public static ErrorSeverity Critical;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.ErrorReporting.FatalError : object {
    [NullableAttribute("2")]
private static ErrorReporterHandler s_handler;
    [NullableAttribute("2")]
private static Exception s_reportedException;
    [NullableAttribute("2")]
private static string s_reportedExceptionMessage;
    private static object s_reportedMarker;
    [NullableAttribute("2")]
public static ErrorReporterHandler Handler { get; public set; }
    private static FatalError();
    [NullableContextAttribute("2")]
public static ErrorReporterHandler get_Handler();
    [NullableContextAttribute("2")]
public static void set_Handler(ErrorReporterHandler value);
    [NullableContextAttribute("2")]
public static void OverwriteHandler(ErrorReporterHandler value);
    public static void CopyHandlerTo(Assembly assembly);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagate(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndPropagateUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportWithDumpAndCatch(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, ErrorSeverity severity);
    [DebuggerHiddenAttribute]
public static bool ReportAndCatchUnlessCanceled(Exception exception, CancellationToken contextCancellationToken, ErrorSeverity severity);
    private static void Report(Exception exception, ErrorSeverity severity, bool forceDump);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.ErrorReporting.IErrorReportingService {
    public string HostDisplayName { get; }
    public abstract virtual string get_HostDisplayName();
    public abstract virtual void ShowGlobalErrorInfo(string message, TelemetryFeatureName featureName, Exception exception, InfoBarUI[] items);
    public abstract virtual void ShowDetailedErrorInfo(Exception exception);
    public abstract virtual void ShowFeatureNotAvailableErrorInfo(string message, TelemetryFeatureName featureName, Exception exception);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ErrorReporting.InfoBarUI : ValueType {
    [NullableAttribute("2")]
public string Title;
    public UIKind Kind;
    [NullableAttribute("1")]
public Action Action;
    public bool CloseAfterAction;
    [MemberNotNullWhenAttribute("False", "Title")]
public bool IsDefault { get; }
    [NullableContextAttribute("1")]
public InfoBarUI(string title, UIKind kind, Action action, bool closeAfterAction);
    [MemberNotNullWhenAttribute("False", "Title")]
public bool get_IsDefault();
}
internal class Microsoft.CodeAnalysis.ErrorReporting.OperationCanceledIgnoringCallerTokenException : OperationCanceledException {
    [NullableContextAttribute("1")]
public OperationCanceledIgnoringCallerTokenException(Exception innerException);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.ExtensionOrderAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <After>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Before>k__BackingField;
    public string After { get; public set; }
    public string Before { get; public set; }
    [CompilerGeneratedAttribute]
public string get_After();
    [CompilerGeneratedAttribute]
public void set_After(string value);
    [CompilerGeneratedAttribute]
public string get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Extensions.AbstractExtensionManager : object {
    private ConcurrentSet`1<object> _disabledProviders;
    private ConcurrentSet`1<object> _ignoredProviders;
    protected void DisableProvider(object provider);
    protected void EnableProvider(object provider);
    protected void IgnoreProvider(object provider);
    public bool IsIgnored(object provider);
    public sealed virtual bool IsDisabled(object provider);
    public virtual bool CanHandleException(object provider, Exception exception);
    public virtual void HandleException(object provider, Exception exception);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Extensions.IExtensionManager {
    public abstract virtual bool IsDisabled(object provider);
    public abstract virtual bool CanHandleException(object provider, Exception exception);
    public abstract virtual void HandleException(object provider, Exception exception);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions : object {
    [ExtensionAttribute]
public static void PerformAction(IExtensionManager extensionManager, object extension, Action action);
    [ExtensionAttribute]
public static T PerformFunction(IExtensionManager extensionManager, object extension, Func`1<T> function, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformActionAsync>d__2")]
[ExtensionAttribute]
public static Task PerformActionAsync(IExtensionManager extensionManager, object extension, Func`1<Task> function);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManagerExtensions/<PerformFunctionAsync>d__3`1")]
[ExtensionAttribute]
public static Task`1<T> PerformFunctionAsync(IExtensionManager extensionManager, object extension, Func`1<Task`1<T>> function, T defaultValue);
    [ExtensionAttribute]
public static Func`2<SyntaxNode, ImmutableArray`1<TExtension>> CreateNodeExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, ImmutableArray`1<Type>> nodeTypeGetter);
    [ExtensionAttribute]
public static Func`2<SyntaxToken, ImmutableArray`1<TExtension>> CreateTokenExtensionGetter(IExtensionManager extensionManager, IEnumerable`1<TExtension> extensions, Func`2<TExtension, ImmutableArray`1<int>> tokenKindGetter);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Extensions.IExtensionManager", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Extensions.ServicesLayerExtensionManager : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaDocumentExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Task`1<SemanticModel> GetSemanticModelForNodeAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaEditDistanceWrapper : ValueType {
    private EditDistance _underlyingObject;
    public PythiaEditDistanceWrapper(string str);
    public double GetEditDistance(string target);
    public sealed virtual void Dispose();
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaObjectPool : object {
    [ObsoleteAttribute("Use specific GetInstance overloads")]
public static IDisposable GetInstance(T& instance);
    public static IDisposable GetInstance(Stack`1& instance);
    public static IDisposable GetInstance(HashSet`1& instance);
    private static ObjectPool`1<T> Default();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSemanticModelExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ISymbol GetEnclosingNamedTypeOrAssembly(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaSyntaxFactsServiceWrapper : ValueType {
    internal ISyntaxFactsService UnderlyingObject;
    internal PythiaSyntaxFactsServiceWrapper(ISyntaxFactsService underlyingObject);
    public static PythiaSyntaxFactsServiceWrapper Create(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.Pythia.Api.PythiaTypeInferenceServiceWrapper : ValueType {
    internal ITypeInferenceService UnderlyingObject;
    internal PythiaTypeInferenceServiceWrapper(ITypeInferenceService underlyingObject);
    public static PythiaTypeInferenceServiceWrapper Create(Document document);
    public ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string name, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingIncrementalAnalyzerImplementation {
    public abstract virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    public abstract virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeSyntaxAsync(Document document, UnitTestingInvocationReasonsWrapper reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, UnitTestingInvocationReasonsWrapper reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, UnitTestingInvocationReasonsWrapper reasons, CancellationToken cancellationToken);
    public abstract virtual void RemoveDocument(DocumentId documentId);
    public abstract virtual void RemoveProject(ProjectId projectId);
    [ObsoleteAttribute]
public abstract virtual bool NeedsReanalysisOnOptionChanged(object sender, UnitTestingOptionChangedEventArgsWrapper e);
}
internal interface Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.IUnitTestingIncrementalAnalyzerProviderImplementation {
    public abstract virtual IUnitTestingIncrementalAnalyzerImplementation CreateIncrementalAnalyzer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingChecksumWrapper : ValueType {
    [CompilerGeneratedAttribute]
private Checksum <UnderlyingObject>k__BackingField;
    private Checksum UnderlyingObject { get; }
    public UnitTestingChecksumWrapper(Checksum underlyingObject);
    [CompilerGeneratedAttribute]
private Checksum get_UnderlyingObject();
    public bool IsEqualTo(UnitTestingChecksumWrapper other);
}
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingEncodedStringTextAccessor : object {
    [NullableContextAttribute("1")]
public static SourceText Create(Stream stream, Encoding defaultEncoding);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingFatalErrorAccessor : object {
    [ExtensionAttribute]
public static bool ReportWithoutCrash(Exception e);
    [ExtensionAttribute]
public static bool ReportWithoutCrashUnlessCanceled(Exception e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[ObsoleteAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingIncrementalAnalyzerProviderMetadataWrapper : ValueType {
    [CompilerGeneratedAttribute]
private IncrementalAnalyzerProviderMetadata <UnderlyingObject>k__BackingField;
    internal IncrementalAnalyzerProviderMetadata UnderlyingObject { get; }
    public UnitTestingIncrementalAnalyzerProviderMetadataWrapper(string name, bool highPriorityForActiveFile, String[] workspaceKinds);
    internal UnitTestingIncrementalAnalyzerProviderMetadataWrapper(IncrementalAnalyzerProviderMetadata underlyingObject);
    [CompilerGeneratedAttribute]
internal IncrementalAnalyzerProviderMetadata get_UnderlyingObject();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingInvocationReasonsWrapper : ValueType {
    public static UnitTestingInvocationReasonsWrapper SemanticChanged;
    public static UnitTestingInvocationReasonsWrapper Reanalyze;
    public static UnitTestingInvocationReasonsWrapper ProjectConfigurationChanged;
    public static UnitTestingInvocationReasonsWrapper SyntaxChanged;
    public static UnitTestingInvocationReasonsWrapper PredefinedDocumentAdded;
    public static UnitTestingInvocationReasonsWrapper PredefinedReanalyze;
    public static UnitTestingInvocationReasonsWrapper PredefinedSemanticChanged;
    public static UnitTestingInvocationReasonsWrapper PredefinedSyntaxChanged;
    public static UnitTestingInvocationReasonsWrapper PredefinedProjectConfigurationChanged;
    public static UnitTestingInvocationReasonsWrapper PredefinedDocumentOpened;
    public static UnitTestingInvocationReasonsWrapper PredefinedDocumentRemoved;
    public static UnitTestingInvocationReasonsWrapper PredefinedDocumentClosed;
    public static UnitTestingInvocationReasonsWrapper PredefinedHighPriority;
    public static UnitTestingInvocationReasonsWrapper PredefinedProjectParseOptionsChanged;
    public static UnitTestingInvocationReasonsWrapper PredefinedSolutionRemoved;
    [CompilerGeneratedAttribute]
private InvocationReasons <UnderlyingObject>k__BackingField;
    internal InvocationReasons UnderlyingObject { get; }
    internal UnitTestingInvocationReasonsWrapper(InvocationReasons underlyingObject);
    [NullableContextAttribute("1")]
public UnitTestingInvocationReasonsWrapper(string reason);
    private static UnitTestingInvocationReasonsWrapper();
    [CompilerGeneratedAttribute]
internal InvocationReasons get_UnderlyingObject();
    public UnitTestingInvocationReasonsWrapper With(UnitTestingInvocationReasonsWrapper reason);
    public bool IsReanalyze();
    public bool HasSemanticChanged();
    public bool HasProjectConfigurationChanged();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[ObsoleteAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingOptionChangedEventArgsWrapper : ValueType {
    [CompilerGeneratedAttribute]
private OptionChangedEventArgs <UnderlyingObject>k__BackingField;
    internal OptionChangedEventArgs UnderlyingObject { get; }
    public UnitTestingOptionChangedEventArgsWrapper(OptionChangedEventArgs underlyingObject);
    [CompilerGeneratedAttribute]
internal OptionChangedEventArgs get_UnderlyingObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingProjectExtensions : object {
    [ExtensionAttribute]
public static string GetDebugName(ProjectId projectId);
    [ExtensionAttribute]
public static Task`1<bool> HasSuccessfullyLoadedAsync(Project project, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSolutionExtensions : object {
    [ExtensionAttribute]
public static int GetWorkspaceVersion(Solution solution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSolutionExtensions/<GetChecksumAsync>d__1")]
[ExtensionAttribute]
public static Task`1<UnitTestingChecksumWrapper> GetChecksumAsync(Solution solution, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingSymbolExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetSymbolKeyString(ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingTextDocumentEventArgsWrapper : ValueType {
    [CompilerGeneratedAttribute]
private TextDocumentEventArgs <UnderlyingObject>k__BackingField;
    internal TextDocumentEventArgs UnderlyingObject { get; }
    public TextDocument Document { get; }
    public UnitTestingTextDocumentEventArgsWrapper(TextDocumentEventArgs underlyingObject);
    [CompilerGeneratedAttribute]
internal TextDocumentEventArgs get_UnderlyingObject();
    public TextDocument get_Document();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.Api.UnitTestingWorkspaceExtensions : object {
    [ExtensionAttribute]
public static IDisposable RegisterTextDocumentOpenedEventHandler(Workspace workspace, Action`1<UnitTestingTextDocumentEventArgsWrapper> action);
    [ExtensionAttribute]
public static IDisposable RegisterTextDocumentClosedEventHandler(Workspace workspace, Action`1<UnitTestingTextDocumentEventArgsWrapper> action);
}
internal class Microsoft.CodeAnalysis.ExternalAccess.UnitTesting.UnitTestingIncrementalAnalyzer : object {
    private IUnitTestingIncrementalAnalyzerImplementation _implementation;
    public int Priority { get; }
    public UnitTestingIncrementalAnalyzer(IUnitTestingIncrementalAnalyzerImplementation implementation);
    public sealed virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual Task ActiveDocumentSwitchedAsync(TextDocument document, CancellationToken cancellationToken);
    public sealed virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    public sealed virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    public sealed virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentOpenAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentCloseAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public sealed virtual Task NonSourceDocumentResetAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public sealed virtual Task AnalyzeNonSourceDocumentAsync(TextDocument textDocument, InvocationReasons reasons, CancellationToken cancellationToken);
    public sealed virtual void LogAnalyzerCountSummary();
    public sealed virtual int get_Priority();
    public static BackgroundAnalysisScope GetBackgroundAnalysisScope(OptionSet _);
    public sealed virtual void Shutdown();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptCodeFixContextExtensions : object {
    [ExtensionAttribute]
public static bool IsBlocking(CodeFixContext context);
    [ExtensionAttribute]
public static bool IsBlocking(CodeRefactoringContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptDocumentationCommentWrapper : ValueType {
    private DocumentationComment _underlyingObject;
    public bool IsDefault { get; }
    [NullableAttribute("2")]
public string SummaryTextOpt { get; }
    public VSTypeScriptDocumentationCommentWrapper(DocumentationComment underlyingObject);
    public static VSTypeScriptDocumentationCommentWrapper FromXmlFragment(string xml);
    public bool get_IsDefault();
    [NullableContextAttribute("2")]
public string get_SummaryTextOpt();
    public string GetParameterTextOpt(string parameterName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExternalAccess.VSTypeScript.Api.VSTypeScriptTextExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Document> GetRelatedDocuments(SourceTextContainer container);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContextWithChanges(SourceText text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private CodeGenerationOptions <CodeGenerationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtractMethodOptions <ExtractOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AddImportPlacementOptions <AddImportOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private LineFormattingOptions <LineFormattingOptions>k__BackingField;
    [DataMemberAttribute]
public CodeGenerationOptions CodeGenerationOptions { get; public set; }
    [DataMemberAttribute]
public ExtractMethodOptions ExtractOptions { get; public set; }
    [DataMemberAttribute]
public AddImportPlacementOptions AddImportOptions { get; public set; }
    [DataMemberAttribute]
public LineFormattingOptions LineFormattingOptions { get; public set; }
    public ExtractMethodGenerationOptions(CodeGenerationOptions CodeGenerationOptions);
    [CompilerGeneratedAttribute]
public CodeGenerationOptions get_CodeGenerationOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CodeGenerationOptions(CodeGenerationOptions value);
    [CompilerGeneratedAttribute]
public ExtractMethodOptions get_ExtractOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ExtractOptions(ExtractMethodOptions value);
    [CompilerGeneratedAttribute]
public AddImportPlacementOptions get_AddImportOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AddImportOptions(AddImportPlacementOptions value);
    [CompilerGeneratedAttribute]
public LineFormattingOptions get_LineFormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LineFormattingOptions(LineFormattingOptions value);
    public static ExtractMethodGenerationOptions GetDefault(LanguageServices languageServices);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ExtractMethodGenerationOptions left, ExtractMethodGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ExtractMethodGenerationOptions left, ExtractMethodGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExtractMethodGenerationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(CodeGenerationOptions& CodeGenerationOptions);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodGenerationOptionsProviders : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodGenerationOptionsProviders/<GetExtractMethodGenerationOptionsAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<ExtractMethodGenerationOptions> GetExtractMethodGenerationOptionsAsync(Document document, Nullable`1<ExtractMethodGenerationOptions> fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ValueTask`1<ExtractMethodGenerationOptions> GetExtractMethodGenerationOptionsAsync(Document document, CodeActionOptionsProvider fallbackOptions, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ExtractMethod.ExtractMethodOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <DontPutOutOrRefOnStruct>k__BackingField;
    public static ExtractMethodOptions Default;
    [DataMemberAttribute]
public bool DontPutOutOrRefOnStruct { get; public set; }
    private static ExtractMethodOptions();
    [CompilerGeneratedAttribute]
public bool get_DontPutOutOrRefOnStruct();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DontPutOutOrRefOnStruct(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ExtractMethodOptions left, ExtractMethodOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ExtractMethodOptions left, ExtractMethodOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ExtractMethodOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FailFast : object {
    internal static ErrorReporterHandler Handler;
    private static FailFast();
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void OnFatalException(Exception exception);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
internal static void Fail(string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void DumpStackTrace(Exception exception, string message);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
[DebuggerHiddenAttribute]
internal static void Assert(bool condition, string message);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.FileTextLoader : TextLoader {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Encoding <DefaultEncoding>k__BackingField;
    public string Path { get; }
    [NullableAttribute("2")]
public Encoding DefaultEncoding { get; }
    internal int MaxFileLength { get; }
    internal string FilePath { get; }
    public FileTextLoader(string path, Encoding defaultEncoding);
    [CompilerGeneratedAttribute]
public string get_Path();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Encoding get_DefaultEncoding();
    internal virtual int get_MaxFileLength();
    internal sealed virtual string get_FilePath();
    protected virtual SourceText CreateText(Stream stream, Workspace workspace);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FileTextLoader/<LoadTextAndVersionAsync>d__12")]
public virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    internal virtual TextAndVersion LoadTextAndVersionSynchronously(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    private string GetDebuggerDisplay();
    private void ValidateFileLength(string path);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private FileStream <LoadTextAndVersionAsync>b__12_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private FileStream <LoadTextAndVersionSynchronously>b__13_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<Document, TIndex> s_documentToIndex;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<DocumentId, TIndex> s_documentIdToIndex;
    private static string s_persistenceName;
    private static Checksum s_serializationFormatChecksum;
    private static ConditionalWeakTable`2<ParseOptions, Checksum> s_ppDirectivesToChecksum;
    [NullableAttribute("2")]
public Checksum Checksum;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    [NullableContextAttribute("2")]
protected AbstractSyntaxIndex`1(Checksum checksum);
    private static AbstractSyntaxIndex`1();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<GetRequiredIndexAsync>d__5")]
protected static ValueTask`1<TIndex> GetRequiredIndexAsync(Document document, IndexReader<TIndex> read, IndexCreator<TIndex> create, CancellationToken cancellationToken);
    protected static ValueTask`1<TIndex> GetIndexAsync(Document document, IndexReader<TIndex> read, IndexCreator<TIndex> create, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<GetIndexAsync>d__7")]
protected static ValueTask`1<TIndex> GetIndexAsync(Document document, bool loadOnly, IndexReader<TIndex> read, IndexCreator<TIndex> create, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<GetIndexWorkerAsync>d__8")]
private static Task`1<TIndex> GetIndexWorkerAsync(Document document, bool loadOnly, IndexReader<TIndex> read, IndexCreator<TIndex> create, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<CreateIndexAsync>d__9")]
private static Task`1<TIndex> CreateIndexAsync(Document document, Checksum textChecksum, Checksum textAndDirectivesChecksum, IndexCreator<TIndex> create, CancellationToken cancellationToken);
    private static bool ContainsIfDirective(SyntaxNode node, int ifDirectiveKind);
    private static bool ContainsIfDirective(SyntaxToken token, int ifDirectiveKind);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<LoadAsync>d__16")]
protected static Task`1<TIndex> LoadAsync(Document document, Checksum textChecksum, Checksum textAndDirectivesChecksum, IndexReader<TIndex> read, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<LoadAsync>d__17")]
protected static Task`1<TIndex> LoadAsync(IChecksummedPersistentStorageService storageService, DocumentKey documentKey, Checksum checksum, StringTable stringTable, IndexReader<TIndex> read, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<GetChecksumsAsync>d__18")]
public static ValueTask`1<ValueTuple`2<Checksum, Checksum>> GetChecksumsAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.AbstractSyntaxIndex`1/<SaveAsync>d__19")]
private Task`1<bool> SaveAsync(Document document, CancellationToken cancellationToken);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public abstract virtual void WriteTo(ObjectWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder : object {
    private static SymbolDisplayFormat DottedNameFormat;
    private static DeclarationFinder();
    private static Task AddCompilationDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<ISymbol> list, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<AddCompilationDeclarationsWithNormalQueryAsync>d__1")]
private static Task AddCompilationDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<ISymbol> list, Compilation startingCompilation, IAssemblySymbol startingAssembly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<AddMetadataDeclarationsWithNormalQueryAsync>d__2")]
private static Task AddMetadataDeclarationsWithNormalQueryAsync(Project project, IAssemblySymbol assembly, PortableExecutableReference reference, SearchQuery query, SymbolFilter filter, ArrayBuilder`1<ISymbol> list, CancellationToken cancellationToken);
    internal static ImmutableArray`1<ISymbol> FilterByCriteria(ImmutableArray`1<ISymbol> symbols, SymbolFilter criteria);
    private static bool MeetCriteria(ISymbol symbol, SymbolFilter filter);
    private static bool IsNonTypeMember(ISymbol symbol);
    private static bool IsOn(SymbolFilter filter, SymbolFilter flag);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindAllDeclarationsWithNormalQueryAsync>d__7")]
public static Task`1<ImmutableArray`1<ISymbol>> FindAllDeclarationsWithNormalQueryAsync(Project project, SearchQuery query, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindAllDeclarationsWithNormalQueryInCurrentProcessAsync>d__8")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindAllDeclarationsWithNormalQueryInCurrentProcessAsync(Project project, SearchQuery query, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<RehydrateAsync>d__9")]
private static Task`1<ImmutableArray`1<ISymbol>> RehydrateAsync(Solution solution, IList`1<SerializableSymbolAndProjectId> array, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryAsync>d__10")]
public static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithNormalQueryAsync(Solution solution, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryAsync>d__11")]
public static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithNormalQueryAsync(Project project, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternAsync>d__12")]
public static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternAsync>d__13")]
public static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync>d__14")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync(Solution solution, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync>d__15")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithNormalQueryInCurrentProcessAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DeclarationFinder/<FindSourceDeclarationsWithPatternInCurrentProcessAsync>d__16")]
private static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(string pattern, Func`2<SearchQuery, Task`1<ImmutableArray`1<ISymbol>>> searchAsync);
    internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(Solution solution, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithPatternInCurrentProcessAsync(Project project, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    private static string GetContainer(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfo : ValueType {
    [DataMemberAttribute]
public string Name;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string NameSuffix;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string ContainerDisplayName;
    [DataMemberAttribute]
public string FullyQualifiedContainerName;
    [DataMemberAttribute]
public TextSpan Span;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <InheritanceNames>k__BackingField;
    [DataMemberAttribute]
private UInt32 _flags;
    private static UInt32 Lower4BitMask;
    private static UInt32 Lower5BitMask;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> InheritanceNames { get; }
    public DeclaredSymbolInfoKind Kind { get; }
    public Accessibility Accessibility { get; }
    public byte ParameterCount { get; }
    public byte TypeParameterCount { get; }
    public bool IsNestedType { get; }
    public bool IsPartial { get; }
    [ObsoleteAttribute("Do not call directly.  Only around for serialization.  Use Create instead")]
public DeclaredSymbolInfo(string name, string nameSuffix, string containerDisplayName, string fullyQualifiedContainerName, TextSpan span, ImmutableArray`1<string> inheritanceNames, UInt32 flags);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_InheritanceNames();
    public DeclaredSymbolInfoKind get_Kind();
    public Accessibility get_Accessibility();
    public byte get_ParameterCount();
    public byte get_TypeParameterCount();
    public bool get_IsNestedType();
    public bool get_IsPartial();
    public static DeclaredSymbolInfo Create(StringTable stringTable, string name, string nameSuffix, string containerDisplayName, string fullyQualifiedContainerName, bool isPartial, DeclaredSymbolInfoKind kind, Accessibility accessibility, TextSpan span, ImmutableArray`1<string> inheritanceNames, bool isNestedType, int parameterCount, int typeParameterCount);
    [NullableContextAttribute("2")]
public static string Intern(StringTable stringTable, string name);
    private static DeclaredSymbolInfoKind GetKind(UInt32 flags);
    private static Accessibility GetAccessibility(UInt32 flags);
    private static byte GetParameterCount(UInt32 flags);
    private static byte GetTypeParameterCount(UInt32 flags);
    private static bool GetIsNestedType(UInt32 flags);
    private static bool GetIsPartial(UInt32 flags);
    internal void WriteTo(ObjectWriter writer);
    internal static DeclaredSymbolInfo ReadFrom_ThrowsOnFailure(StringTable stringTable, ObjectReader reader);
    public ISymbol TryResolve(SemanticModel semanticModel, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DeclaredSymbolInfo other);
    public virtual int GetHashCode();
}
internal enum Microsoft.CodeAnalysis.FindSymbols.DeclaredSymbolInfoKind : Enum {
    public byte value__;
    public static DeclaredSymbolInfoKind Class;
    public static DeclaredSymbolInfoKind Constant;
    public static DeclaredSymbolInfoKind Constructor;
    public static DeclaredSymbolInfoKind Delegate;
    public static DeclaredSymbolInfoKind Enum;
    public static DeclaredSymbolInfoKind EnumMember;
    public static DeclaredSymbolInfoKind Event;
    public static DeclaredSymbolInfoKind ExtensionMethod;
    public static DeclaredSymbolInfoKind Field;
    public static DeclaredSymbolInfoKind Indexer;
    public static DeclaredSymbolInfoKind Interface;
    public static DeclaredSymbolInfoKind Method;
    public static DeclaredSymbolInfoKind Module;
    public static DeclaredSymbolInfoKind Namespace;
    public static DeclaredSymbolInfoKind Property;
    public static DeclaredSymbolInfoKind Record;
    public static DeclaredSymbolInfoKind RecordStruct;
    public static DeclaredSymbolInfoKind Struct;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsAsync>d__0")]
public static Task`1<ImmutableArray`1<Project>> GetDependentProjectsAsync(Solution solution, ImmutableArray`1<ISymbol> symbols, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<GetDependentProjectsWorkerAsync>d__1")]
private static Task`1<ImmutableArray`1<Project>> GetDependentProjectsWorkerAsync(Solution solution, ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static Dictionary`2<IAssemblySymbol, ValueTuple`2<Project, SymbolVisibility>> GetSymbolOriginations(Solution solution, ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<ComputeDependentProjectsAsync>d__3")]
private static Task`1<ImmutableArray`1<ValueTuple`2<Project, bool>>> ComputeDependentProjectsAsync(Solution solution, ValueTuple`2<IAssemblySymbol, Project> symbolOrigination, SymbolVisibility visibility, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentProjectsFinder/<AddSubmissionDependentProjectsAsync>d__4")]
private static Task AddSubmissionDependentProjectsAsync(Solution solution, Project sourceProject, HashSet`1<ValueTuple`2<Project, bool>> dependentProjects, CancellationToken cancellationToken);
    private static bool IsInternalsVisibleToAttribute(AttributeData attr);
    private static void AddNonSubmissionDependentProjects(Solution solution, ValueTuple`2<IAssemblySymbol, Project> symbolOrigination, HashSet`1<ValueTuple`2<Project, bool>> dependentProjects, CancellationToken cancellationToken);
    private static HashSet`1<string> GetInternalsVisibleToSet(IAssemblySymbol assembly);
    private static bool HasReferenceTo(ValueTuple`2<IAssemblySymbol, Project> symbolOrigination, Project project, CancellationToken cancellationToken);
    private static bool HasReferenceToAssembly(Project project, string assemblyName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder : object {
    private static Func`2<Location, bool> s_isInMetadata;
    private static Func`2<Location, bool> s_isInSource;
    private static Func`2<INamedTypeSymbol, bool> s_isInterface;
    private static Func`2<INamedTypeSymbol, bool> s_isNonSealedClass;
    private static Func`2<INamedTypeSymbol, bool> s_isInterfaceOrNonSealedClass;
    private static ObjectPool`1<PooledHashSet`1<INamedTypeSymbol>> s_symbolSetPool;
    private static DependentTypeFinder();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<DescendInheritanceTreeAsync>d__6")]
private static Task`1<ImmutableArray`1<INamedTypeSymbol>> DescendInheritanceTreeAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<DescendInheritanceTreeInProjectAsync>d__7")]
private static Task DescendInheritanceTreeInProjectAsync(bool searchInMetadata, HashSet`1<INamedTypeSymbol> result, HashSet`1<INamedTypeSymbol> currentMetadataTypes, HashSet`1<INamedTypeSymbol> currentSourceAndMetadataTypes, Project project, Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    [ConditionalAttribute("DEBUG")]
private static void AssertContents(HashSet`1<INamedTypeSymbol> foundTypes, Func`2<Location, bool> assert, string message);
    private static void AddRange(HashSet`1<INamedTypeSymbol> foundTypes, HashSet`1<INamedTypeSymbol> result);
    private static void AddRange(HashSet`1<INamedTypeSymbol> foundTypes, HashSet`1<INamedTypeSymbol> currentTypes, Func`2<INamedTypeSymbol, bool> shouldContinueSearching);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<GetProjectsThatCouldReferenceTypeAsync>d__11")]
private static Task`1<ISet`1<ProjectId>> GetProjectsThatCouldReferenceTypeAsync(INamedTypeSymbol type, Solution solution, bool searchInMetadata, CancellationToken cancellationToken);
    private static IEnumerable`1<ProjectId> GetProjectsThatCouldReferenceType(ProjectDependencyGraph dependencyGraph, Project project);
    private static ImmutableArray`1<Project> GetOrderedProjectsToExamine(Solution solution, IImmutableSet`1<Project> projects, IEnumerable`1<ProjectId> projectsThatCouldReferenceType);
    private static ImmutableArray`1<Project> OrderTopologically(Solution solution, IEnumerable`1<Project> projectsToExamine);
    private static ImmutableArray`1<Project> GetProjectsToExamineWorker(Solution solution, IImmutableSet`1<Project> projects, IEnumerable`1<ProjectId> projectsThatCouldReferenceType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddDescendantMetadataTypesInProjectAsync>d__16")]
private static Task AddDescendantMetadataTypesInProjectAsync(HashSet`1<INamedTypeSymbol> currentMetadataTypes, HashSet`1<INamedTypeSymbol> result, Project project, Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddMatchingMetadataTypesInMetadataReferenceAsync>d__17")]
private static Task AddMatchingMetadataTypesInMetadataReferenceAsync(HashSet`1<INamedTypeSymbol> metadataTypes, Project project, Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, Compilation compilation, PortableExecutableReference reference, HashSet`1<INamedTypeSymbol> result, CancellationToken cancellationToken);
    private static bool TypeHasBaseTypeInSet(INamedTypeSymbol type, HashSet`1<INamedTypeSymbol> set);
    private static bool TypeHasInterfaceInSet(INamedTypeSymbol type, HashSet`1<INamedTypeSymbol> set);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddDescendantSourceTypesInProjectAsync>d__20")]
private static Task AddDescendantSourceTypesInProjectAsync(HashSet`1<INamedTypeSymbol> currentSourceAndMetadataTypes, HashSet`1<INamedTypeSymbol> result, Project project, Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, Func`2<INamedTypeSymbol, bool> shouldContinueSearching, bool transitive, CancellationToken cancellationToken);
    private static void PropagateTemporaryResults(HashSet`1<INamedTypeSymbol> result, HashSet`1<INamedTypeSymbol> typesToSearchFor, HashSet`1<INamedTypeSymbol> tempBuffer, bool transitive, Func`2<INamedTypeSymbol, bool> shouldContinueSearching);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddSourceTypesThatDeriveFromNameAsync>d__22")]
private static Task AddSourceTypesThatDeriveFromNameAsync(Func`3<INamedTypeSymbol, HashSet`1<INamedTypeSymbol>, bool> typeMatches, ConcurrentSet`1<SemanticModel> cachedModels, HashSet`1<INamedTypeSymbol> typesToSearchFor, ProjectIndex index, HashSet`1<INamedTypeSymbol> result, string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<AddMatchingTypesAsync>d__23")]
private static Task AddMatchingTypesAsync(ConcurrentSet`1<SemanticModel> cachedModels, MultiDictionary`2<Document, DeclaredSymbolInfo> documentToInfos, HashSet`1<INamedTypeSymbol> result, Func`2<INamedTypeSymbol, bool> predicateOpt, CancellationToken cancellationToken);
    public static PooledDisposer`1<PooledHashSet`1<INamedTypeSymbol>> GetSymbolSet(HashSet`1& instance);
    private static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindDerivedClassesInCurrentProcessAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindDerivedInterfacesInCurrentProcessAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindImplementingTypesInCurrentProcessAsync>d__27")]
private static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindImplementingTypesInCurrentProcessAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTypesAsync>d__29")]
public static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindTypesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, DependentTypesKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<FindTypesInCurrentProcessAsync>d__30")]
public static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindTypesInCurrentProcessAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, bool transitive, DependentTypesKind kind, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.DependentTypeFinder/<RehydrateAsync>d__31")]
private static Task`1<ImmutableArray`1<INamedTypeSymbol>> RehydrateAsync(Solution solution, ImmutableArray`1<SerializableSymbolAndProjectId> values, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FindDerivedClassesInCurrentProcessAsync>g__TypeMatches|25_0(INamedTypeSymbol type, HashSet`1<INamedTypeSymbol> set);
    [CompilerGeneratedAttribute]
internal static bool <FindDerivedInterfacesInCurrentProcessAsync>g__TypeMatches|26_0(INamedTypeSymbol type, HashSet`1<INamedTypeSymbol> set);
    [CompilerGeneratedAttribute]
internal static bool <FindImplementingTypesInCurrentProcessAsync>g__TypeMatches|27_0(INamedTypeSymbol type, HashSet`1<INamedTypeSymbol> set);
}
internal enum Microsoft.CodeAnalysis.FindSymbols.DependentTypesKind : Enum {
    public int value__;
    public static DependentTypesKind DerivedClasses;
    public static DependentTypesKind DerivedInterfaces;
    public static DependentTypesKind ImplementingTypes;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.Extensions : object {
    public static string ComplexReceiverTypeName;
    public static string ComplexArrayReceiverTypeName;
    public static string ArrayReceiverTypeNameSuffix;
    [ExtensionAttribute]
internal static bool TextMatch(ISyntaxFactsService syntaxFacts, string text1, string text2);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    protected abstract virtual bool TokensMatch(FindReferencesDocumentState state, SyntaxToken token, string name);
    protected sealed virtual bool CanFind(TSymbol symbol);
    protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMemberScopedReferenceFinder`1/<FindReferencesInDocumentAsync>d__3")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(TSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static ISymbol GetContainer(ISymbol symbol);
    private ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInContainerAsync(TSymbol symbol, ISymbol container, FindReferencesDocumentState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1 : AbstractReferenceFinder`1<TSymbol> {
    protected static ImmutableArray`1<IMethodSymbol> GetReferencedAccessorSymbols(FindReferencesDocumentState state, IPropertySymbol property, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder : object {
    public static string ContainingTypeInfoPropertyName;
    public static string ContainingMemberInfoPropertyName;
    public abstract virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(ISymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static ValueTask`1<ValueTuple`2<bool, CandidateReason>> SymbolsMatchAsync(ISymbol symbol, FindReferencesDocumentState state, SyntaxToken token, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<SymbolsMatchAsync>d__7")]
protected static ValueTask`1<ValueTuple`2<bool, CandidateReason>> SymbolsMatchAsync(ISymbol searchSymbol, FindReferencesDocumentState state, SyntaxNode node, CancellationToken cancellationToken);
    protected static bool TryGetNameWithoutAttributeSuffix(string name, ISyntaxFactsService syntaxFacts, String& result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindDocumentsAsync>d__9`1")]
protected static Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> scope, Func`4<Document, T, CancellationToken, ValueTask`1<bool>> predicateAsync, T value, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken, String[] values);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsWithGlobalSuppressMessageAttributeAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedType predefinedType, CancellationToken cancellationToken);
    protected static bool IdentifiersMatch(ISyntaxFactsService syntaxFacts, string name, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInDocumentUsingIdentifierAsync>d__14")]
protected static ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentUsingIdentifierAsync(ISymbol symbol, string identifier, FindReferencesDocumentState state, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<SyntaxToken>> FindMatchingIdentifierTokensAsync(FindReferencesDocumentState state, string identifier, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInTokensAsync>d__16")]
protected static ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInTokensAsync(ISymbol symbol, FindReferencesDocumentState state, ImmutableArray`1<SyntaxToken> tokens, CancellationToken cancellationToken);
    protected static FinderLocation CreateFinderLocation(FindReferencesDocumentState state, SyntaxToken token, CandidateReason reason, CancellationToken cancellationToken);
    private static IAliasSymbol GetAliasSymbol(FindReferencesDocumentState state, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindLocalAliasReferencesAsync>d__19")]
protected static Task`1<ImmutableArray`1<FinderLocation>> FindLocalAliasReferencesAsync(ArrayBuilder`1<FinderLocation> initialReferences, ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindLocalAliasReferencesAsync>d__20")]
protected static Task`1<ImmutableArray`1<FinderLocation>> FindLocalAliasReferencesAsync(ArrayBuilder`1<FinderLocation> initialReferences, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static ImmutableArray`1<IAliasSymbol> GetLocalAliasSymbols(FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> initialReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesThroughLocalAliasSymbolsAsync>d__22")]
private static Task`1<ImmutableArray`1<FinderLocation>> FindReferencesThroughLocalAliasSymbolsAsync(ISymbol symbol, FindReferencesDocumentState state, ImmutableArray`1<IAliasSymbol> localAliasSymbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesThroughLocalAliasSymbolsAsync>d__23")]
private static Task`1<ImmutableArray`1<FinderLocation>> FindReferencesThroughLocalAliasSymbolsAsync(FindReferencesDocumentState state, ImmutableArray`1<IAliasSymbol> localAliasSymbols, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsWithPredicateAsync(Project project, IImmutableSet`1<Document> documents, Func`3<SyntaxTreeIndex, T, bool> predicate, T value, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsWithPredicateAsync(Project project, IImmutableSet`1<Document> documents, Func`2<SyntaxTreeIndex, bool> predicate, CancellationToken cancellationToken);
    protected static Task`1<ImmutableArray`1<Document>> FindDocumentsWithForEachStatementsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInDocumentAsync>d__28")]
protected static Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(FindReferencesDocumentState state, Func`2<SyntaxTreeIndex, bool> isRelevantDocument, CollectMatchingReferences collectMatchingReferences, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInForEachStatementsAsync(ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInDeconstructionAsync(ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInAwaitExpressionAsync(ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    protected Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInImplicitObjectCreationExpressionAsync(ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    protected static bool Matches(ISymbol symbol1, ISymbol notNullOriginalUnreducedSymbol2);
    protected static SymbolUsageInfo GetSymbolUsageInfo(SyntaxNode node, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static bool IsNodeOrAnyAncestorLeftSideOfDot(SyntaxNode node, ISyntaxFactsService syntaxFacts);
    internal static ImmutableDictionary`2<string, string> GetAdditionalFindUsagesProperties(SyntaxNode node, FindReferencesDocumentState state);
    internal static ImmutableDictionary`2<string, string> GetAdditionalFindUsagesProperties(ISymbol definition);
    private static bool TryGetAdditionalProperty(SyntaxNode node, string name, SemanticModel semanticModel, KeyValuePair`2& additionalProperty);
    private static bool TryGetAdditionalProperty(string propertyName, ISymbol symbol, KeyValuePair`2& additionalProperty);
    private static bool ShouldFindReferencesInGlobalSuppressions(ISymbol symbol, String& documentationCommentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder/<FindReferencesInDocumentInsideGlobalSuppressionsAsync>d__41")]
protected static ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentInsideGlobalSuppressionsAsync(ISymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private static bool TryGetExpectedDocumentationCommentId(string id, ReadOnlyMemory`1& docCommentId);
    [NullableContextAttribute("0")]
private static bool ValidateAndSplitDocumentationCommentId(string docCommentId, ReadOnlyMemory`1& prefix, ReadOnlyMemory`1& id);
    [NullableContextAttribute("0")]
private static void SplitIdAndArguments(ReadOnlyMemory`1<char> id, ReadOnlyMemory`1& idPartBeforeArguments, ReadOnlyMemory`1& arguments);
    [NullableContextAttribute("0")]
private static bool ValidateAndSplitDocumentationCommentId(string docCommentId, ReadOnlyMemory`1& prefix, ReadOnlyMemory`1& idPartBeforeArguments, ReadOnlyMemory`1& arguments);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInForEachStatementsAsync>g__IsRelevantDocument|29_0(SyntaxTreeIndex syntaxTreeInfo);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInDeconstructionAsync>g__IsRelevantDocument|30_0(SyntaxTreeIndex syntaxTreeInfo);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInAwaitExpressionAsync>g__IsRelevantDocument|31_0(SyntaxTreeIndex syntaxTreeInfo);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInImplicitObjectCreationExpressionAsync>g__IsRelevantDocument|32_0(SyntaxTreeIndex syntaxTreeInfo);
    [CompilerGeneratedAttribute]
internal static TypeOrNamespaceUsageInfo <GetSymbolUsageInfo>g__GetTypeOrNamespaceUsageInfo|34_0(<>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static SymbolUsageInfo <GetSymbolUsageInfo>g__GetSymbolUsageInfoCommon|34_1(<>c__DisplayClass34_0& );
    [CompilerGeneratedAttribute]
internal static bool <ShouldFindReferencesInGlobalSuppressions>g__SupportsGlobalSuppression|40_0(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInDocumentInsideGlobalSuppressionsAsync>g__IsCandidate|41_0(FindReferencesDocumentState state, SyntaxToken token, ReadOnlySpan`1<char> expectedDocCommentId, INamedTypeSymbol suppressMessageAttribute, CancellationToken cancellationToken, Int32& offsetOfReferenceInToken);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInDocumentInsideGlobalSuppressionsAsync>g__IsValidTargetOfGlobalSuppressionAttribute|41_1(SyntaxToken token, INamedTypeSymbol suppressMessageAttribute, SemanticModel semanticModel, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static ReferenceLocation <FindReferencesInDocumentInsideGlobalSuppressionsAsync>g__CreateReferenceLocation|41_2(int offsetOfReferenceInToken, SyntaxToken token, SyntaxNode root, Document document, ISyntaxFacts syntaxFacts);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1 : AbstractReferenceFinder {
    protected abstract virtual bool CanFind(TSymbol symbol);
    protected abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(TSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected abstract virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(TSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(TSymbol symbol, Project project, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(ISymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public sealed virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(TSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected static ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentUsingSymbolNameAsync(TSymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractReferenceFinder`1/<GetAllMatchingGlobalAliasNamesAsync>d__10")]
protected static Task`1<ImmutableArray`1<string>> GetAllMatchingGlobalAliasNamesAsync(Project project, string name, int arity, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractTypeParameterSymbolReferenceFinder : AbstractReferenceFinder`1<ITypeParameterSymbol> {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.AbstractTypeParameterSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__0")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(ITypeParameterSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInDocumentAsync>g__IsObjectCreationToken|0_1(SyntaxToken token, FindReferencesDocumentState state);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<FinderLocation> <FindReferencesInDocumentAsync>g__GetObjectCreationReferences|0_2(ImmutableArray`1<SyntaxToken> objectCreationTokens, <>c__DisplayClass0_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorInitializerSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__2")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInDocumentAsync>g__TokensMatch|2_1(FindReferencesDocumentState state, SyntaxToken token, string typeName, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    public static ConstructorSymbolReferenceFinder Instance;
    private static ConstructorSymbolReferenceFinder();
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(IMethodSymbol symbol, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentsWithImplicitObjectCreationExpressionAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<AddDocumentsAsync>d__6")]
private static Task AddDocumentsAsync(Project project, IImmutableSet`1<Document> documents, string typeName, ArrayBuilder`1<Document> result, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__8")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ConstructorSymbolReferenceFinder/<AddReferencesInDocumentWorkerAsync>d__9")]
private static Task AddReferencesInDocumentWorkerAsync(IMethodSymbol symbol, string name, FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> result, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindOrdinaryReferencesAsync(IMethodSymbol symbol, string name, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindPredefinedTypeReferencesAsync(IMethodSymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindAttributeReferencesAsync(IMethodSymbol symbol, string name, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<FinderLocation>> FindReferencesInImplicitObjectCreationExpressionAsync(IMethodSymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <FindReferencesInImplicitObjectCreationExpressionAsync>g__IsRelevantDocument|13_2(SyntaxTreeIndex syntaxTreeInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.DestructorSymbolReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol methodSymbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IEventSymbol> {
    protected virtual bool CanFind(IEventSymbol symbol);
    protected sealed virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IEventSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.EventSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IEventSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IEventSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ExplicitConversionSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    private static INamedTypeSymbol GetUnderlyingNamedType(ITypeSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ExplicitConversionSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static bool IsPotentialReference(ISyntaxFactsService syntaxFacts, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ExplicitInterfaceMethodReferenceFinder : AbstractReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.FieldSymbolReferenceFinder : AbstractReferenceFinder`1<IFieldSymbol> {
    protected virtual bool CanFind(IFieldSymbol symbol);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IFieldSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.FieldSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IFieldSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.FieldSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__3")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IFieldSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.FinderLocation : ValueType {
    public SyntaxNode Node;
    public ReferenceLocation Location;
    public FinderLocation(SyntaxNode node, ReferenceLocation location);
    public void Deconstruct(SyntaxNode& node, ReferenceLocation& location);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.Finders.ILanguageServiceReferenceFinder {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindSymbols.Finders.IReferenceFinder {
    public abstract virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ISymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ISymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(ISymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LabelSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILabelSymbol> {
    protected virtual bool TokensMatch(FindReferencesDocumentState state, SyntaxToken token, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.LocalSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<ILocalSymbol> {
    protected virtual bool TokensMatch(FindReferencesDocumentState state, SyntaxToken token, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.MethodTypeParameterSymbolReferenceFinder : AbstractTypeParameterSymbolReferenceFinder {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(ITypeParameterSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static string GetMemberNameWithoutInterfaceName(string fullName);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder : AbstractReferenceFinder`1<INamedTypeSymbol> {
    protected virtual bool CanFind(INamedTypeSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(INamedTypeSymbol symbol, Project project, CancellationToken cancellationToken);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(INamedTypeSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static void Add(ArrayBuilder`1<ISymbol> result, ImmutableArray`1<TSymbol> enumerable);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__4")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(INamedTypeSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<AddDocumentsToSearchAsync>d__5")]
private static Task AddDocumentsToSearchAsync(string throughName, Project project, IImmutableSet`1<Document> documents, ArrayBuilder`1<Document> result, CancellationToken cancellationToken);
    private static bool IsPotentialReference(PredefinedType predefinedType, ISyntaxFactsService syntaxFacts, SyntaxToken token);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__7")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(INamedTypeSymbol namedType, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<AddReferencesToTypeOrGlobalAliasToItAsync>d__8")]
internal static ValueTask AddReferencesToTypeOrGlobalAliasToItAsync(INamedTypeSymbol namedType, FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> nonAliasReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamedTypeSymbolReferenceFinder/<AddNonAliasReferencesAsync>d__9")]
private static ValueTask AddNonAliasReferencesAsync(INamedTypeSymbol symbol, string name, FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> nonAliasesReferences, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindOrdinaryReferencesAsync(INamedTypeSymbol namedType, string name, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindPredefinedTypeReferencesAsync(INamedTypeSymbol symbol, FindReferencesDocumentState state, CancellationToken cancellationToken);
    private static ValueTask`1<ImmutableArray`1<FinderLocation>> FindAttributeReferencesAsync(INamedTypeSymbol namedType, string name, FindReferencesDocumentState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder : AbstractReferenceFinder`1<INamespaceSymbol> {
    protected virtual bool CanFind(INamespaceSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<string>> DetermineGlobalAliasesAsync(INamespaceSymbol symbol, Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(INamespaceSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__3")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(INamespaceSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<AddNamedReferencesAsync>d__4")]
private static Task AddNamedReferencesAsync(INamespaceSymbol symbol, string name, FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> initialReferences, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.NamespaceSymbolReferenceFinder/<AddGlobalNamespaceReferencesAsync>d__5")]
private static Task AddGlobalNamespaceReferencesAsync(INamespaceSymbol symbol, FindReferencesDocumentState state, ArrayBuilder`1<FinderLocation> initialReferences, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OperatorSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OperatorSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__1")]
protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentsAsync(Project project, IImmutableSet`1<Document> documents, PredefinedOperator op, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OperatorSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__3")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static bool IsPotentialReference(ISyntaxFactsService syntaxFacts, PredefinedOperator op, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetOtherPartsOfPartial(IMethodSymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<DetermineDocumentsToSearchAsync>d__3")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol methodSymbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentsWithDeconstructionAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentsWithAwaitExpressionAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static bool IsForEachMethod(IMethodSymbol methodSymbol);
    private static bool IsDeconstructMethod(IMethodSymbol methodSymbol);
    private static bool IsGetAwaiterMethod(IMethodSymbol methodSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.OrdinaryMethodReferenceFinder/<FindReferencesInDocumentAsync>d__9")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder : AbstractReferenceFinder`1<IParameterSymbol> {
    protected virtual bool CanFind(IParameterSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IParameterSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IParameterSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<DetermineCascadedSymbolsAsync>d__3")]
protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IParameterSymbol parameter, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static void CascadeBetweenAnonymousDelegateParameters(IParameterSymbol parameter, ArrayBuilder`1<ISymbol> symbols);
    private static void CascadeBetweenPrimaryConstructorParameterAndProperties(IParameterSymbol parameter, ArrayBuilder`1<ISymbol> symbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.ParameterSymbolReferenceFinder/<CascadeBetweenAnonymousFunctionParametersAsync>d__6")]
private static ValueTask CascadeBetweenAnonymousFunctionParametersAsync(Solution solution, IParameterSymbol parameter, ArrayBuilder`1<ISymbol> results, CancellationToken cancellationToken);
    private static void CascadeBetweenAnonymousFunctionParameters(Document document, SemanticModel semanticModel, SyntaxNode container, IParameterSymbol parameter, ITypeSymbol convertedType1, ArrayBuilder`1<ISymbol> results, CancellationToken cancellationToken);
    private static bool ParameterNamesMatch(ISyntaxFactsService syntaxFacts, IMethodSymbol methodSymbol1, IMethodSymbol methodSymbol2);
    private static SyntaxNode GetContainer(SemanticModel semanticModel, SyntaxNode parameterNode, ISyntaxFactsService syntaxFactsService);
    private static void CascadeBetweenPropertyAndAccessorParameters(IParameterSymbol parameter, ArrayBuilder`1<ISymbol> results);
    private static void CascadeBetweenDelegateMethodParameters(IParameterSymbol parameter, ArrayBuilder`1<ISymbol> results);
    private static void AddParameterAtIndex(ArrayBuilder`1<ISymbol> results, int ordinal, Nullable`1<ImmutableArray`1<IParameterSymbol>> parameters);
    private static void CascadeBetweenPartialMethodParameters(IParameterSymbol parameter, ArrayBuilder`1<ISymbol> results);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IMethodSymbol> {
    protected virtual bool CanFind(IMethodSymbol symbol);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IMethodSymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__2")]
protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IMethodSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertyAccessorSymbolReferenceFinder/<FindReferencesInDocumentAsync>d__3")]
protected virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IMethodSymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder : AbstractMethodOrPropertyOrEventSymbolReferenceFinder`1<IPropertySymbol> {
    protected virtual bool CanFind(IPropertySymbol symbol);
    protected virtual ValueTask`1<ImmutableArray`1<ISymbol>> DetermineCascadedSymbolsAsync(IPropertySymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static void CascadeToBackingFields(IPropertySymbol symbol, ArrayBuilder`1<ISymbol> result);
    private static void CascadeToAccessors(IPropertySymbol symbol, ArrayBuilder`1<ISymbol> result);
    private static void CascadeToPrimaryConstructorParameters(IPropertySymbol property, ArrayBuilder`1<ISymbol> result, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<DetermineDocumentsToSearchAsync>d__5")]
protected sealed virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(IPropertySymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static bool IsForEachProperty(IPropertySymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindReferencesInDocumentAsync>d__7")]
protected sealed virtual ValueTask`1<ImmutableArray`1<FinderLocation>> FindReferencesInDocumentAsync(IPropertySymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentWithElementAccessExpressionsAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    private static Task`1<ImmutableArray`1<Document>> FindDocumentWithIndexerMemberCrefAsync(Project project, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<FindIndexerReferencesAsync>d__10")]
private static Task`1<ImmutableArray`1<FinderLocation>> FindIndexerReferencesAsync(IPropertySymbol symbol, FindReferencesDocumentState state, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    private static ValueTask`1<ValueTuple`3<bool, CandidateReason, SyntaxNode>> ComputeIndexerInformationAsync(IPropertySymbol symbol, FindReferencesDocumentState state, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<ComputeIndexerMemberCRefInformationAsync>d__12")]
private static ValueTask`1<ValueTuple`3<bool, CandidateReason, SyntaxNode>> ComputeIndexerMemberCRefInformationAsync(IPropertySymbol symbol, FindReferencesDocumentState state, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<ComputeConditionalAccessInformationAsync>d__13")]
private static ValueTask`1<ValueTuple`3<bool, CandidateReason, SyntaxNode>> ComputeConditionalAccessInformationAsync(IPropertySymbol symbol, SyntaxNode node, FindReferencesDocumentState state, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.Finders.PropertySymbolReferenceFinder/<ComputeElementAccessInformationAsync>d__14")]
private static ValueTask`1<ValueTuple`3<bool, CandidateReason, SyntaxNode>> ComputeElementAccessInformationAsync(IPropertySymbol symbol, SyntaxNode node, FindReferencesDocumentState state, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.RangeVariableSymbolReferenceFinder : AbstractMemberScopedReferenceFinder`1<IRangeVariableSymbol> {
    protected virtual bool TokensMatch(FindReferencesDocumentState state, SyntaxToken token, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FindSymbols.Finders.ReferenceFinders : object {
    public static IReferenceFinder Constructor;
    public static IReferenceFinder ConstructorInitializer;
    public static IReferenceFinder Destructor;
    public static IReferenceFinder ExplicitConversion;
    public static IReferenceFinder ExplicitInterfaceMethod;
    public static IReferenceFinder Event;
    public static IReferenceFinder Field;
    public static IReferenceFinder Label;
    public static IReferenceFinder Local;
    public static IReferenceFinder MethodTypeParameter;
    public static IReferenceFinder NamedType;
    public static IReferenceFinder Namespace;
    public static IReferenceFinder Operator;
    public static IReferenceFinder OrdinaryMethod;
    public static IReferenceFinder Parameter;
    public static IReferenceFinder Property;
    public static IReferenceFinder PropertyAccessor;
    public static IReferenceFinder RangeVariable;
    public static IReferenceFinder TypeParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ImmutableArray`1<IReferenceFinder> DefaultReferenceFinders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IReferenceFinder> DefaultRenameReferenceFinders;
    private static ReferenceFinders();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.Finders.TypeParameterSymbolReferenceFinder : AbstractTypeParameterSymbolReferenceFinder {
    protected virtual bool CanFind(ITypeParameterSymbol symbol);
    protected virtual Task`1<ImmutableArray`1<Document>> DetermineDocumentsToSearchAsync(ITypeParameterSymbol symbol, HashSet`1<string> globalAliases, Project project, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine : object {
    private Solution _solution;
    private IStreamingFindLiteralReferencesProgress _progress;
    private IStreamingProgressTracker _progressTracker;
    private object _value;
    [NullableAttribute("2")]
private string _stringValue;
    private long _longValue;
    private SearchKind _searchKind;
    public FindLiteralsSearchEngine(Solution solution, IStreamingFindLiteralReferencesProgress progress, object value);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<FindReferencesAsync>d__9")]
public Task FindReferencesAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<FindReferencesWorkerAsync>d__10")]
private Task FindReferencesWorkerAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<ProcessDocumentAsync>d__11")]
private Task ProcessDocumentAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<ProcessDocumentWorkerAsync>d__12")]
private Task ProcessDocumentWorkerAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindLiteralsSearchEngine/<SearchDocumentAsync>d__13")]
private Task SearchDocumentAsync(Document document, CancellationToken cancellationToken);
    private void ProcessNode(ISyntaxFactsService syntaxFacts, SyntaxNode node, ArrayBuilder`1<SyntaxToken> matches, CancellationToken cancellationToken);
    private void ProcessToken(ISyntaxFactsService syntaxFacts, SyntaxToken token, ArrayBuilder`1<SyntaxToken> matches);
    private void CheckToken(SyntaxToken token, ArrayBuilder`1<SyntaxToken> matches);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache : object {
    private static ConditionalWeakTable`2<SemanticModel, FindReferenceCache> s_cache;
    private SemanticModel _semanticModel;
    private ConcurrentDictionary`2<SyntaxNode, SymbolInfo> _symbolInfoCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConcurrentDictionary`2<string, ImmutableArray`1<SyntaxToken>> _identifierCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableHashSet`1<string> _aliasNameSet;
    [NullableAttribute("0")]
private ImmutableArray`1<SyntaxToken> _constructorInitializerCache;
    private FindReferenceCache(SemanticModel semanticModel);
    private static FindReferenceCache();
    public static FindReferenceCache GetCache(SemanticModel model);
    public SymbolInfo GetSymbolInfo(SyntaxNode node, CancellationToken cancellationToken);
    public IAliasSymbol GetAliasInfo(ISemanticFactsService semanticFacts, SyntaxToken token, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferenceCache/<FindMatchingIdentifierTokensAsync>d__10")]
public Task`1<ImmutableArray`1<SyntaxToken>> FindMatchingIdentifierTokensAsync(Document document, string identifier, CancellationToken cancellationToken);
    public IEnumerable`1<SyntaxToken> GetConstructorInitializerTokens(ISyntaxFactsService syntaxFacts, SyntaxNode root, CancellationToken cancellationToken);
    private static ImmutableArray`1<SyntaxToken> GetConstructorInitializerTokensWorker(ISyntaxFactsService syntaxFacts, SyntaxNode root, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.FindSymbols.FindReferences.BaseTypeFinder : object {
    public static ImmutableArray`1<INamedTypeSymbol> FindBaseTypesAndInterfaces(INamedTypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferences.BaseTypeFinder/<FindOverriddenAndImplementedMembersAsync>d__1")]
public static ValueTask`1<ImmutableArray`1<ISymbol>> FindOverriddenAndImplementedMembersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> FindBaseTypes(INamedTypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesDocumentState : object {
    private static HashSet`1<string> s_empty;
    public Document Document;
    public SemanticModel SemanticModel;
    public SyntaxNode Root;
    public FindReferenceCache Cache;
    public HashSet`1<string> GlobalAliases;
    public Solution Solution;
    public SyntaxTree SyntaxTree;
    public ISyntaxFactsService SyntaxFacts;
    public ISemanticFactsService SemanticFacts;
    public FindReferencesDocumentState(Document document, SemanticModel semanticModel, SyntaxNode root, FindReferenceCache cache, HashSet`1<string> globalAliases);
    private static FindReferencesDocumentState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine : object {
    private static ObjectPool`1<MetadataUnifyingSymbolHashSet> s_metadataUnifyingSymbolHashSetPool;
    private Solution _solution;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IImmutableSet`1<Document> _documents;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IReferenceFinder> _finders;
    private IStreamingProgressTracker _progressTracker;
    private IStreamingFindReferencesProgress _progress;
    private FindReferencesSearchOptions _options;
    private TaskScheduler _scheduler;
    private static TaskScheduler s_exclusiveScheduler;
    private ConcurrentDictionary`2<ISymbol, SymbolGroup> _symbolToGroup;
    public FindReferencesSearchEngine(Solution solution, IImmutableSet`1<Document> documents, ImmutableArray`1<IReferenceFinder> finders, IStreamingFindReferencesProgress progress, FindReferencesSearchOptions options);
    private static FindReferencesSearchEngine();
    public Task FindReferencesAsync(ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<FindReferencesAsync>d__13")]
public Task FindReferencesAsync(ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
    public Task CreateWorkAsync(Func`1<Task> createWorkAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ReportGroupsAsync>d__15")]
private Task ReportGroupsAsync(ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<Project>> GetProjectToSearchAsync(ImmutableArray`1<ISymbol> symbols, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessProjectAsync>d__17")]
private Task ProcessProjectAsync(Project project, ImmutableArray`1<ISymbol> allSymbols, CancellationToken cancellationToken);
    private static PooledHashSet`1<U> TryGet(Dictionary`2<T, PooledHashSet`1<U>> dictionary, T key);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchEngine/<ProcessDocumentAsync>d__19")]
private Task ProcessDocumentAsync(Document document, MetadataUnifyingSymbolHashSet symbols, Dictionary`2<ISymbol, PooledHashSet`1<string>> symbolToGlobalAliases, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static PooledHashSet`1<string> <ProcessProjectAsync>g__GetGlobalAliasesSet|17_0(PooledDictionary`2<T, PooledHashSet`1<string>> dictionary, T key);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static MetadataUnifyingSymbolHashSet <ProcessProjectAsync>g__GetSymbolSet|17_1(PooledDictionary`2<T, MetadataUnifyingSymbolHashSet> dictionary, T key);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.FindSymbols.FindReferencesSearchOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <AssociatePropertyReferencesWithSpecificAccessor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cascade>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Explicit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UnidirectionalHierarchyCascade>k__BackingField;
    public static FindReferencesSearchOptions Default;
    [DataMemberAttribute]
public bool AssociatePropertyReferencesWithSpecificAccessor { get; public set; }
    [DataMemberAttribute]
public bool Cascade { get; public set; }
    [DataMemberAttribute]
public bool Explicit { get; public set; }
    [DataMemberAttribute]
public bool UnidirectionalHierarchyCascade { get; public set; }
    public FindReferencesSearchOptions(bool AssociatePropertyReferencesWithSpecificAccessor, bool Cascade, bool Explicit, bool UnidirectionalHierarchyCascade);
    private static FindReferencesSearchOptions();
    [CompilerGeneratedAttribute]
public bool get_AssociatePropertyReferencesWithSpecificAccessor();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AssociatePropertyReferencesWithSpecificAccessor(bool value);
    [CompilerGeneratedAttribute]
public bool get_Cascade();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Cascade(bool value);
    [CompilerGeneratedAttribute]
public bool get_Explicit();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Explicit(bool value);
    [CompilerGeneratedAttribute]
public bool get_UnidirectionalHierarchyCascade();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UnidirectionalHierarchyCascade(bool value);
    [NullableContextAttribute("1")]
public static FindReferencesSearchOptions GetFeatureOptionsForStartingSymbol(ISymbol symbol);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(FindReferencesSearchOptions left, FindReferencesSearchOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(FindReferencesSearchOptions left, FindReferencesSearchOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(FindReferencesSearchOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& AssociatePropertyReferencesWithSpecificAccessor, Boolean& Cascade, Boolean& Explicit, Boolean& UnidirectionalHierarchyCascade);
}
internal interface Microsoft.CodeAnalysis.FindSymbols.IDeclaredSymbolInfoFactoryService {
    [NullableContextAttribute("1")]
public abstract virtual void AddDeclaredSymbolInfos(Document document, SyntaxNode root, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, Dictionary`2<string, ArrayBuilder`1<int>> extensionMethodInfo, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.FindSymbols.IFindReferencesProgress {
    public abstract virtual void OnStarted();
    public abstract virtual void OnCompleted();
    public abstract virtual void OnFindInDocumentStarted(Document document);
    public abstract virtual void OnFindInDocumentCompleted(Document document);
    public abstract virtual void OnDefinitionFound(ISymbol symbol);
    public abstract virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public abstract virtual void ReportProgress(int current, int maximum);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindSymbols.IRemoteDependentTypeFinderService {
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindTypesAsync(Checksum solutionChecksum, SerializableSymbolAndProjectId type, ImmutableArray`1<ProjectId> projectsOpt, bool transitive, DependentTypesKind kind, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindSymbols.IRemoteSymbolFinderService {
    public abstract virtual ValueTask FindReferencesAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectIdArg, ImmutableArray`1<DocumentId> documentArgs, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask FindLiteralReferencesAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, object value, TypeCode typeCode, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindAllDeclarationsWithNormalQueryAsync(Checksum solutionChecksum, ProjectId projectId, string name, SearchKind searchKind, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindSolutionSourceDeclarationsWithNormalQueryAsync(Checksum solutionChecksum, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindProjectSourceDeclarationsWithNormalQueryAsync(Checksum solutionChecksum, ProjectId projectId, string name, bool ignoreCase, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindSolutionSourceDeclarationsWithPatternAsync(Checksum solutionChecksum, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<SerializableSymbolAndProjectId>> FindProjectSourceDeclarationsWithPatternAsync(Checksum solutionChecksum, ProjectId projectId, string pattern, SymbolFilter criteria, CancellationToken cancellationToken);
    public abstract virtual ValueTask AnalyzeDocumentAsync(Checksum solutionChecksum, DocumentId documentId, bool isMethodBodyEdit, CancellationToken cancellationToken);
    public abstract virtual ValueTask AnalyzeProjectAsync(Checksum solutionChecksum, ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual ValueTask RemoveProjectAsync(ProjectId projectId, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindSymbols.IStreamingFindLiteralReferencesProgress {
    public IStreamingProgressTracker ProgressTracker { get; }
    public abstract virtual IStreamingProgressTracker get_ProgressTracker();
    public abstract virtual ValueTask OnReferenceFoundAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.FindSymbols.IStreamingFindReferencesProgress {
    public IStreamingProgressTracker ProgressTracker { get; }
    public abstract virtual IStreamingProgressTracker get_ProgressTracker();
    public abstract virtual ValueTask OnStartedAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask OnCompletedAsync(CancellationToken cancellationToken);
    public abstract virtual ValueTask OnFindInDocumentStartedAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnFindInDocumentCompletedAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnDefinitionFoundAsync(SymbolGroup group, CancellationToken cancellationToken);
    public abstract virtual ValueTask OnReferenceFoundAsync(SymbolGroup group, ISymbol symbol, ReferenceLocation location, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingEquivalenceComparer : object {
    public static IEqualityComparer`1<ISymbol> Instance;
    private static MetadataUnifyingEquivalenceComparer();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    public sealed virtual int GetHashCode(ISymbol obj);
    private static bool IsInSource(ISymbol symbol);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.MetadataUnifyingSymbolHashSet : HashSet`1<ISymbol> {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.NoOpFindReferencesProgress : object {
    public static IFindReferencesProgress Instance;
    private static NoOpFindReferencesProgress();
    public sealed virtual void ReportProgress(int current, int maximum);
    public sealed virtual void OnCompleted();
    public sealed virtual void OnStarted();
    public sealed virtual void OnDefinitionFound(ISymbol symbol);
    public sealed virtual void OnReferenceFound(ISymbol symbol, ReferenceLocation location);
    public sealed virtual void OnFindInDocumentStarted(Document document);
    public sealed virtual void OnFindInDocumentCompleted(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.NoOpStreamingFindReferencesProgress : object {
    public static IStreamingFindReferencesProgress Instance;
    [CompilerGeneratedAttribute]
private IStreamingProgressTracker <ProgressTracker>k__BackingField;
    public IStreamingProgressTracker ProgressTracker { get; }
    private static NoOpStreamingFindReferencesProgress();
    [CompilerGeneratedAttribute]
public sealed virtual IStreamingProgressTracker get_ProgressTracker();
    public sealed virtual ValueTask OnCompletedAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask OnStartedAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask OnDefinitionFoundAsync(SymbolGroup group, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnReferenceFoundAsync(SymbolGroup group, ISymbol symbol, ReferenceLocation location, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentStartedAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentCompletedAsync(Document document, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferencedSymbol : object {
    [CompilerGeneratedAttribute]
private ISymbol <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ReferenceLocation> <LocationsArray>k__BackingField;
    public ISymbol Definition { get; }
    internal ImmutableArray`1<ReferenceLocation> LocationsArray { get; }
    public IEnumerable`1<ReferenceLocation> Locations { get; }
    internal ReferencedSymbol(ISymbol definition, ImmutableArray`1<ReferenceLocation> locations);
    [CompilerGeneratedAttribute]
public ISymbol get_Definition();
    [CompilerGeneratedAttribute]
internal ImmutableArray`1<ReferenceLocation> get_LocationsArray();
    public IEnumerable`1<ReferenceLocation> get_Locations();
    private string GetDebuggerDisplay();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocation : ValueType {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IAliasSymbol <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsImplicit>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolUsageInfo <SymbolUsageInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableDictionary`2<string, string> <AdditionalProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private Location <ContainingStringLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    public Document Document { get; }
    [NullableAttribute("2")]
public IAliasSymbol Alias { get; }
    public Location Location { get; }
    public bool IsImplicit { get; }
    internal bool IsWrittenTo { get; }
    internal SymbolUsageInfo SymbolUsageInfo { get; }
    internal ImmutableDictionary`2<string, string> AdditionalProperties { get; }
    internal Location ContainingStringLocation { get; }
    public CandidateReason CandidateReason { get; }
    public bool IsCandidateLocation { get; }
    private ReferenceLocation(Document document, IAliasSymbol alias, Location location, bool isImplicit, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties, CandidateReason candidateReason, Location containingStringLocation);
    internal ReferenceLocation(Document document, IAliasSymbol alias, Location location, bool isImplicit, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties, CandidateReason candidateReason);
    internal ReferenceLocation(Document document, Location location, Location containingStringLocation);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IAliasSymbol get_Alias();
    [CompilerGeneratedAttribute]
public Location get_Location();
    [CompilerGeneratedAttribute]
public bool get_IsImplicit();
    internal bool get_IsWrittenTo();
    [CompilerGeneratedAttribute]
internal SymbolUsageInfo get_SymbolUsageInfo();
    [CompilerGeneratedAttribute]
internal ImmutableDictionary`2<string, string> get_AdditionalProperties();
    [CompilerGeneratedAttribute]
internal Location get_ContainingStringLocation();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public bool get_IsCandidateLocation();
    public static bool op_Equality(ReferenceLocation left, ReferenceLocation right);
    public static bool op_Inequality(ReferenceLocation left, ReferenceLocation right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceLocation other);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(ReferenceLocation other);
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.ReferenceLocationExtensions/<FindReferencingSymbolsAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Dictionary`2<ISymbol, List`1<Location>>> FindReferencingSymbolsAsync(IEnumerable`1<ReferenceLocation> referenceLocations, CancellationToken cancellationToken);
    private static void AddSymbols(SemanticModel semanticModel, IEnumerable`1<ReferenceLocation> references, Dictionary`2<ISymbol, List`1<Location>> result);
    private static ISymbol GetEnclosingMethodOrPropertyOrField(SemanticModel semanticModel, ReferenceLocation reference);
}
internal enum Microsoft.CodeAnalysis.FindSymbols.SearchKind : Enum {
    public int value__;
    public static SearchKind Exact;
    public static SearchKind ExactIgnoreCase;
    public static SearchKind Fuzzy;
    public static SearchKind Custom;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.SearchQuery : object {
    [NullableAttribute("2")]
public string Name;
    public SearchKind Kind;
    private Func`2<string, bool> _predicate;
    [NullableAttribute("2")]
private WordSimilarityChecker _wordSimilarityChecker;
    private SearchQuery(string name, SearchKind kind);
    private SearchQuery(Func`2<string, bool> predicate);
    public sealed virtual void Dispose();
    public static SearchQuery Create(string name, SearchKind kind);
    public static SearchQuery Create(string name, bool ignoreCase);
    public static SearchQuery CreateFuzzy(string name);
    public static SearchQuery CreateCustom(Func`2<string, bool> predicate);
    public Func`2<string, bool> GetPredicate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.StreamingFindReferencesProgressAdapter : object {
    private IFindReferencesProgress _progress;
    [CompilerGeneratedAttribute]
private IStreamingProgressTracker <ProgressTracker>k__BackingField;
    public IStreamingProgressTracker ProgressTracker { get; }
    public StreamingFindReferencesProgressAdapter(IFindReferencesProgress progress);
    [CompilerGeneratedAttribute]
public sealed virtual IStreamingProgressTracker get_ProgressTracker();
    public sealed virtual ValueTask OnCompletedAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentCompletedAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentStartedAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnDefinitionFoundAsync(SymbolGroup group, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnReferenceFoundAsync(SymbolGroup group, ISymbol symbol, ReferenceLocation location, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnStartedAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private ValueTask <.ctor>b__4_0(int current, int max, CancellationToken ct);
}
internal class Microsoft.CodeAnalysis.FindSymbols.StreamingProgressCollector : object {
    private object _gate;
    private IStreamingFindReferencesProgress _underlyingProgress;
    private Dictionary`2<ISymbol, List`1<ReferenceLocation>> _symbolToLocations;
    public IStreamingProgressTracker ProgressTracker { get; }
    public StreamingProgressCollector(IStreamingFindReferencesProgress underlyingProgress);
    public sealed virtual IStreamingProgressTracker get_ProgressTracker();
    public ImmutableArray`1<ReferencedSymbol> GetReferencedSymbols();
    public sealed virtual ValueTask OnStartedAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask OnCompletedAsync(CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentCompletedAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnFindInDocumentStartedAsync(Document document, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnDefinitionFoundAsync(SymbolGroup group, CancellationToken cancellationToken);
    public sealed virtual ValueTask OnReferenceFoundAsync(SymbolGroup group, ISymbol definition, ReferenceLocation location, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.FindSymbols.SymbolCallerInfo : ValueType {
    [CompilerGeneratedAttribute]
private ISymbol <CallingSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Location> <Locations>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbol <CalledSymbol>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDirect>k__BackingField;
    public ISymbol CallingSymbol { get; }
    public IEnumerable`1<Location> Locations { get; }
    public ISymbol CalledSymbol { get; }
    public bool IsDirect { get; }
    internal SymbolCallerInfo(ISymbol callingSymbol, ISymbol calledSymbol, IEnumerable`1<Location> locations, bool isDirect);
    [CompilerGeneratedAttribute]
public ISymbol get_CallingSymbol();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Location> get_Locations();
    [CompilerGeneratedAttribute]
public ISymbol get_CalledSymbol();
    [CompilerGeneratedAttribute]
public bool get_IsDirect();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.FindSymbols.SymbolFinder : object {
    [ObsoleteAttribute("Use FindSymbolAtPositionAsync instead.")]
public static ISymbol FindSymbolAtPosition(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    public static Task`1<ISymbol> FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSymbolAtPositionAsync>d__3")]
internal static Task`1<ISymbol> FindSymbolAtPositionAsync(SemanticModel semanticModel, int position, SolutionServices services, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<GetSemanticInfoAtPositionAsync>d__4")]
internal static Task`1<TokenSemanticInfo> GetSemanticInfoAtPositionAsync(SemanticModel semanticModel, int position, SolutionServices services, CancellationToken cancellationToken);
    private static Task`1<SyntaxToken> GetTokenAtPositionAsync(SemanticModel semanticModel, int position, SolutionServices services, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSymbolAtPositionAsync>d__6")]
public static Task`1<ISymbol> FindSymbolAtPositionAsync(Document document, int position, CancellationToken cancellationToken);
    public static Task`1<ISymbol> FindSourceDefinitionAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDefinitionWorkerAsync>d__8")]
private static Task`1<ISymbol> FindSourceDefinitionWorkerAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    private static bool InSource(ISymbol symbol);
    public static IEnumerable`1<TSymbol> FindSimilarSymbols(TSymbol symbol, Compilation compilation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindLinkedSymbolsAsync>d__11")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindLinkedSymbolsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindCallersAsync>d__15")]
public static Task`1<IEnumerable`1<SymbolCallerInfo>> FindCallersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindCallReferencesAsync>d__16")]
private static Task`1<ImmutableArray`1<ReferencedSymbol>> FindCallReferencesAsync(Solution solution, ISymbol symbol, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDeclarationsAsync>d__17")]
public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDeclarationsAsync>d__18")]
public static Task`1<IEnumerable`1<ISymbol>> FindDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__20")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithCustomQueryAsync>d__21")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithCustomQueryAsync(Solution solution, SearchQuery query, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__23")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithCustomQueryAsync>d__24")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindSourceDeclarationsWithCustomQueryAsync(Project project, SearchQuery query, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__26")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Solution solution, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsAsync>d__28")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsAsync(Project project, string name, bool ignoreCase, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithPatternAsync>d__30")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Solution solution, string pattern, SymbolFilter filter, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindSourceDeclarationsWithPatternAsync>d__32")]
public static Task`1<IEnumerable`1<ISymbol>> FindSourceDeclarationsWithPatternAsync(Project project, string pattern, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindLiteralReferencesAsync>d__33")]
internal static Task FindLiteralReferencesAsync(object value, TypeCode typeCode, Solution solution, IStreamingFindLiteralReferencesProgress progress, CancellationToken cancellationToken);
    internal static Task FindLiteralReferencesInCurrentProcessAsync(object value, Solution solution, IStreamingFindLiteralReferencesProgress progress, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__35")]
internal static Task FindReferencesAsync(ISymbol symbol, Solution solution, IStreamingFindReferencesProgress progress, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    internal static Task FindReferencesInCurrentProcessAsync(ISymbol symbol, Solution solution, IStreamingFindReferencesProgress progress, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__38")]
internal static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__40")]
public static Task`1<IEnumerable`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet`1<Document> documents, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindReferencesAsync>d__41")]
internal static Task`1<ImmutableArray`1<ReferencedSymbol>> FindReferencesAsync(ISymbol symbol, Solution solution, IFindReferencesProgress progress, IImmutableSet`1<Document> documents, FindReferencesSearchOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindRenamableReferencesAsync>d__43")]
internal static Task`1<ImmutableArray`1<ReferencedSymbol>> FindRenamableReferencesAsync(ImmutableArray`1<ISymbol> symbols, Solution solution, CancellationToken cancellationToken);
    private static bool IsAccessible(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<OriginalSymbolsMatchAsync>d__45")]
internal static Task`1<bool> OriginalSymbolsMatchAsync(Solution solution, ISymbol searchSymbol, ISymbol symbolToMatch, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<OriginalSymbolsMatchCoreAsync>d__46")]
private static Task`1<bool> OriginalSymbolsMatchCoreAsync(Solution solution, ISymbol searchSymbol, ISymbol symbolToMatch, CancellationToken cancellationToken);
    private static Task`1<bool> NamespaceSymbolsMatchAsync(Solution solution, INamespaceSymbol namespace1, INamespaceSymbol namespace2, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<VerifyForwardedTypesAsync>d__48")]
private static Task`1<bool> VerifyForwardedTypesAsync(Solution solution, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<VerifyForwardedTypeAsync>d__49")]
private static Task`1<bool> VerifyForwardedTypeAsync(Solution solution, INamedTypeSymbol candidate, INamedTypeSymbol forwardedTo, HashSet`1<Compilation> compilationSet, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetOridinalUnderlyingType(INamedTypeSymbol type);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindOverridesAsync>d__51")]
public static Task`1<IEnumerable`1<ISymbol>> FindOverridesAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindOverridesArrayAsync>d__52")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindOverridesArrayAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<IsOverrideAsync>d__53")]
internal static Task`1<bool> IsOverrideAsync(Solution solution, ISymbol member, ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementedInterfaceMembersAsync>d__54")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementedInterfaceMembersAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    internal static Task`1<ImmutableArray`1<ISymbol>> FindImplementedInterfaceMembersArrayAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementedInterfaceMembersArrayAsync>d__56")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindImplementedInterfaceMembersArrayAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDerivedClassesAsync>d__58")]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedClassesAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDerivedClassesArrayAsync>d__59")]
internal static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindDerivedClassesArrayAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDerivedInterfacesAsync>d__60")]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindDerivedInterfacesAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindDerivedInterfacesArrayAsync>d__61")]
internal static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindDerivedInterfacesArrayAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsAsync>d__62")]
public static Task`1<IEnumerable`1<INamedTypeSymbol>> FindImplementationsAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsArrayAsync>d__63")]
internal static Task`1<ImmutableArray`1<INamedTypeSymbol>> FindImplementationsArrayAsync(INamedTypeSymbol type, Solution solution, bool transitive, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindImplementationsAsync>d__64")]
public static Task`1<IEnumerable`1<ISymbol>> FindImplementationsAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolFinder/<FindMemberImplementationsArrayAsync>d__65")]
internal static Task`1<ImmutableArray`1<ISymbol>> FindMemberImplementationsArrayAsync(ISymbol symbol, Solution solution, IImmutableSet`1<Project> projects, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolGroup : object {
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ISymbol> <Symbols>k__BackingField;
    private int _hashCode;
    public ImmutableHashSet`1<ISymbol> Symbols { get; }
    public SymbolGroup(ImmutableArray`1<ISymbol> symbols);
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ISymbol> get_Symbols();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SymbolGroup group);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService : object {
    private ConcurrentDictionary`2<ProjectId, SymbolTreeInfo> _projectIdToInfo;
    private ConcurrentDictionary`2<MetadataId, MetadataInfo> _metadataIdToInfo;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<TryGetPotentiallyStaleMetadataSymbolTreeInfoAsync>d__3")]
public ValueTask`1<SymbolTreeInfo> TryGetPotentiallyStaleMetadataSymbolTreeInfoAsync(Solution solution, PortableExecutableReference reference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<TryGetPotentiallyStaleSourceSymbolTreeInfoAsync>d__4")]
public Task`1<SymbolTreeInfo> TryGetPotentiallyStaleSourceSymbolTreeInfoAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<AnalyzeDocumentAsync>d__5")]
public Task AnalyzeDocumentAsync(Document document, bool isMethodBodyEdit, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<AnalyzeProjectAsync>d__6")]
public Task AnalyzeProjectAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<UpdateSourceSymbolTreeInfoAsync>d__7")]
private Task UpdateSourceSymbolTreeInfoAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<UpdateReferencesAsync>d__8")]
private Task UpdateReferencesAsync(Project project, CancellationToken cancellationToken);
    public void RemoveProject(ProjectId projectId);
    private void RemoveMetadataReferences(ProjectId projectId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTree.SymbolTreeInfoCacheService/<<UpdateReferencesAsync>g__UpdateReferenceAsync|8_0>d")]
[CompilerGeneratedAttribute]
internal static Task <UpdateReferencesAsync>g__UpdateReferenceAsync|8_0(ConcurrentDictionary`2<MetadataId, MetadataInfo> metadataIdToInfo, Project project, PortableExecutableReference reference, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo : object {
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    [NullableAttribute("0")]
private ImmutableArray`1<Node> _nodes;
    private OrderPreservingMultiDictionary`2<int, int> _inheritanceMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private MultiDictionary`2<string, ExtensionMethodInfo> _receiverTypeNameToExtensionMethodMap;
    private SpellChecker _spellChecker;
    private static StringSliceComparer s_caseInsensitiveComparer;
    private static Comparison`1<string> s_totalComparer;
    private static ConditionalWeakTable`2<MetadataId, AsyncLazy`1<SymbolTreeInfo>> s_metadataIdToInfo;
    private static int RootNodeParentIndex;
    [NullableAttribute("0")]
private static string PrefixSymbolTreeInfo;
    [NullableAttribute("0")]
private static Checksum SerializationFormatChecksum;
    private static SimplePool`1<MultiDictionary`2<string, ISymbol>> s_symbolMapPool;
    private static ConditionalWeakTable`2<ProjectState, AsyncLazy`1<Checksum>> s_projectToSourceChecksum;
    private static Func`2<ISymbol, bool> s_useSymbolNoPrivate;
    private static Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> s_getMembersNoPrivate;
    public Checksum Checksum { get; }
    public bool ContainsExtensionMethod { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private SymbolTreeInfo(Checksum checksum, ImmutableArray`1<Node> sortedNodes, SpellChecker spellChecker, OrderPreservingMultiDictionary`2<string, string> inheritanceMap, MultiDictionary`2<string, ExtensionMethodInfo> receiverTypeNameToExtensionMethodMap);
    private SymbolTreeInfo(Checksum checksum, ImmutableArray`1<Node> sortedNodes, SpellChecker spellChecker, OrderPreservingMultiDictionary`2<int, int> inheritanceMap, MultiDictionary`2<string, ExtensionMethodInfo> receiverTypeNameToExtensionMethodMap);
    private static SymbolTreeInfo();
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    public ValueSet<string, ExtensionMethodInfo> GetExtensionMethodInfoForReceiverType(string typeName);
    public bool get_ContainsExtensionMethod();
    public static SymbolTreeInfo CreateEmpty(Checksum checksum);
    public SymbolTreeInfo WithChecksum(Checksum checksum);
    public Task`1<ImmutableArray`1<ISymbol>> FindAsync(SearchQuery query, IAssemblySymbol assembly, SymbolFilter filter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindAsync>d__17")]
public Task`1<ImmutableArray`1<ISymbol>> FindAsync(SearchQuery query, AsyncLazy`1<IAssemblySymbol> lazyAssembly, SymbolFilter filter, CancellationToken cancellationToken);
    private Task`1<ImmutableArray`1<ISymbol>> FindCoreAsync(SearchQuery query, AsyncLazy`1<IAssemblySymbol> lazyAssembly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FuzzyFindAsync>d__19")]
private Task`1<ImmutableArray`1<ISymbol>> FuzzyFindAsync(AsyncLazy`1<IAssemblySymbol> lazyAssembly, string name, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindAsync>d__20")]
private Task`1<ImmutableArray`1<ISymbol>> FindAsync(AsyncLazy`1<IAssemblySymbol> lazyAssembly, string name, bool ignoreCase, CancellationToken cancellationToken);
    private static StringSliceComparer GetComparer(bool ignoreCase);
    private IEnumerable`1<int> FindNodeIndices(string name, StringSliceComparer comparer);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<FindNodeIndices>d__23")]
private static IEnumerable`1<int> FindNodeIndices(ImmutableArray`1<Node> nodes, string name, StringSliceComparer comparer);
    [NullableContextAttribute("0")]
private static ReadOnlyMemory`1<char> GetNameSlice(ImmutableArray`1<Node> nodes, int nodeIndex);
    private int BinarySearch(string name);
    [NullableContextAttribute("0")]
private static int BinarySearch(ImmutableArray`1<Node> nodes, string name);
    private static SpellChecker CreateSpellChecker(Checksum checksum, ImmutableArray`1<Node> sortedNodes);
    [NullableContextAttribute("0")]
private static void SortNodes(ImmutableArray`1<BuilderNode> unsortedNodes, ImmutableArray`1& sortedNodes);
    [NullableContextAttribute("0")]
private static int CompareNodes(BuilderNode x, BuilderNode y, ImmutableArray`1<BuilderNode> nodeList);
    private void Bind(int index, INamespaceOrTypeSymbol rootContainer, TemporaryArray`1& results, CancellationToken cancellationToken);
    internal void AssertEquivalentTo(SymbolTreeInfo other);
    private static SymbolTreeInfo CreateSymbolTreeInfo(Checksum checksum, ImmutableArray`1<BuilderNode> unsortedNodes, OrderPreservingMultiDictionary`2<string, string> inheritanceMap, MultiDictionary`2<string, ExtensionMethodInfo> receiverTypeNameToExtensionMethodMap);
    private static OrderPreservingMultiDictionary`2<int, int> CreateIndexBasedInheritanceMap(ImmutableArray`1<Node> nodes, OrderPreservingMultiDictionary`2<string, string> inheritanceMap);
    public ImmutableArray`1<INamedTypeSymbol> GetDerivedMetadataTypes(string baseTypeName, Compilation compilation, CancellationToken cancellationToken);
    private static string GetMetadataNameWithoutBackticks(MetadataReader reader, StringHandle name);
    public static MetadataId GetMetadataIdNoThrow(PortableExecutableReference reference);
    private static Metadata GetMetadataNoThrow(PortableExecutableReference reference);
    public static ValueTask`1<SymbolTreeInfo> GetInfoForMetadataReferenceAsync(Solution solution, PortableExecutableReference reference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<GetInfoForMetadataReferenceAsync>d__47")]
private static ValueTask`1<SymbolTreeInfo> GetInfoForMetadataReferenceAsync(Solution solution, PortableExecutableReference reference, Checksum checksum, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<TryGetCachedInfoForMetadataReferenceIgnoreChecksumAsync>d__48")]
public static Task`1<SymbolTreeInfo> TryGetCachedInfoForMetadataReferenceIgnoreChecksumAsync(PortableExecutableReference reference, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<GetInfoForMetadataReferenceSlowAsync>d__49")]
private static Task`1<SymbolTreeInfo> GetInfoForMetadataReferenceSlowAsync(SolutionServices services, SolutionKey solutionKey, PortableExecutableReference reference, Metadata metadata, CancellationToken cancellationToken);
    public static Checksum GetMetadataChecksum(SolutionServices services, PortableExecutableReference reference, CancellationToken cancellationToken);
    private static Checksum GetMetadataChecksumSlow(SolutionServices services, PortableExecutableReference reference, CancellationToken cancellationToken);
    private static string GetMetadataKeySuffix(PortableExecutableReference reference);
    private static Task`1<SymbolTreeInfo> CreateMetadataSymbolTreeInfoAsync(SolutionServices services, SolutionKey solutionKey, PortableExecutableReference reference, CancellationToken cancellationToken);
    public static Task`1<SymbolTreeInfo> LoadAnyInfoForMetadataReferenceAsync(Solution solution, PortableExecutableReference reference, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<LoadOrCreateAsync>d__61")]
private static Task`1<SymbolTreeInfo> LoadOrCreateAsync(SolutionServices services, SolutionKey solutionKey, Func`1<ValueTask`1<Checksum>> getChecksumAsync, Func`2<Checksum, ValueTask`1<SymbolTreeInfo>> createAsync, string keySuffix, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<LoadAsync>d__62")]
private static Task`1<SymbolTreeInfo> LoadAsync(SolutionServices services, SolutionKey solutionKey, Checksum checksum, bool checksumMustMatch, string keySuffix, CancellationToken cancellationToken);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    [NullableContextAttribute("0")]
public sealed virtual void WriteTo(ObjectWriter writer);
    [NullableContextAttribute("0")]
private static SymbolTreeInfo TryReadSymbolTreeInfo(ObjectReader reader, Checksum checksum);
    private static MultiDictionary`2<string, ISymbol> AllocateSymbolMap();
    private static void FreeSymbolMap(MultiDictionary`2<string, ISymbol> symbolMap);
    private static string GetSourceKeySuffix(Project project);
    public static Task`1<SymbolTreeInfo> GetInfoForSourceAssemblyAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<LoadAnyInfoForSourceAssemblyAsync>d__73")]
public static Task`1<SymbolTreeInfo> LoadAnyInfoForSourceAssemblyAsync(Project project, CancellationToken cancellationToken);
    public static Task`1<Checksum> GetSourceSymbolsChecksumAsync(Project project, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<ComputeSourceSymbolsChecksumAsync>d__76")]
private static Task`1<Checksum> ComputeSourceSymbolsChecksumAsync(ProjectState projectState, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<CreateSourceSymbolTreeInfoAsync>d__77")]
internal static ValueTask`1<SymbolTreeInfo> CreateSourceSymbolTreeInfoAsync(Project project, Checksum checksum, CancellationToken cancellationToken);
    private static void GenerateSourceNodes(INamespaceSymbol globalNamespace, ArrayBuilder`1<BuilderNode> list, Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> lookup);
    private static void GenerateSourceNodes(string name, int parentIndex, ValueSet<string, ISymbol> symbolsWithSameName, ArrayBuilder`1<BuilderNode> list, Action`2<ISymbol, MultiDictionary`2<string, ISymbol>> lookup);
    private static void AddSymbol(ISymbol symbol, MultiDictionary`2<string, ISymbol> symbolMap, Func`2<ISymbol, bool> useSymbol);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FindSymbols.SymbolTreeInfo/<<WriteTo>g__GroupByName|65_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<ReadOnlyMemory`1<Node>> <WriteTo>g__GroupByName|65_0(ReadOnlyMemory`1<Node> sortedNodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.SyntaxTreeIndex : AbstractSyntaxIndex`1<SyntaxTreeIndex> {
    private LiteralInfo _literalInfo;
    private IdentifierInfo _identifierInfo;
    private ContextInfo _contextInfo;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ValueTuple`3<string, string, int>> _globalAliasInfo;
    private static double FalsePositiveProbability;
    public static ObjectPool`1<HashSet`1<string>> StringLiteralHashSetPool;
    public static ObjectPool`1<HashSet`1<long>> LongLiteralHashSetPool;
    private static ConditionalWeakTable`2<Project, StringTable> s_projectStringTable;
    public bool ContainsAwait { get; }
    public bool ContainsBaseConstructorInitializer { get; }
    public bool ContainsConversion { get; }
    public bool ContainsDeconstruction { get; }
    public bool ContainsElementAccessExpression { get; }
    public bool ContainsForEachStatement { get; }
    public bool ContainsGlobalKeyword { get; }
    public bool ContainsGlobalSuppressMessageAttribute { get; }
    public bool ContainsImplicitObjectCreation { get; }
    public bool ContainsIndexerMemberCref { get; }
    public bool ContainsLockStatement { get; }
    public bool ContainsQueryExpression { get; }
    public bool ContainsThisConstructorInitializer { get; }
    public bool ContainsTupleExpressionOrTupleType { get; }
    public bool ContainsUsingStatement { get; }
    [NullableContextAttribute("2")]
private SyntaxTreeIndex(Checksum checksum, LiteralInfo literalInfo, IdentifierInfo identifierInfo, ContextInfo contextInfo, HashSet`1<ValueTuple`3<string, string, int>> globalAliasInfo);
    private static SyntaxTreeIndex();
    public static ValueTask`1<SyntaxTreeIndex> GetRequiredIndexAsync(Document document, CancellationToken cancellationToken);
    public static ValueTask`1<SyntaxTreeIndex> GetIndexAsync(Document document, CancellationToken cancellationToken);
    public static ValueTask`1<SyntaxTreeIndex> GetIndexAsync(Document document, bool loadOnly, CancellationToken cancellationToken);
    private static SyntaxTreeIndex CreateIndex(Document document, SyntaxNode root, Checksum checksum, CancellationToken _);
    private static bool IsGlobalSuppressMessageAttribute(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    private static void TryAddGlobalAliasInfo(ISyntaxFactsService syntaxFacts, HashSet`1& globalAliasInfo, SyntaxNode node);
    public static StringTable GetStringTable(Project project);
    private static void GetIdentifierSet(bool ignoreCase, HashSet`1& identifiers, HashSet`1& escapedIdentifiers);
    private static void Free(bool ignoreCase, HashSet`1<string> identifiers, HashSet`1<string> escapedIdentifiers);
    public bool ProbablyContainsIdentifier(string identifier);
    public bool ProbablyContainsEscapedIdentifier(string identifier);
    public bool ContainsPredefinedType(PredefinedType type);
    public bool ContainsPredefinedOperator(PredefinedOperator op);
    public bool ProbablyContainsStringValue(string value);
    public bool ProbablyContainsInt64Value(long value);
    public bool get_ContainsAwait();
    public bool get_ContainsBaseConstructorInitializer();
    public bool get_ContainsConversion();
    public bool get_ContainsDeconstruction();
    public bool get_ContainsElementAccessExpression();
    public bool get_ContainsForEachStatement();
    public bool get_ContainsGlobalKeyword();
    public bool get_ContainsGlobalSuppressMessageAttribute();
    public bool get_ContainsImplicitObjectCreation();
    public bool get_ContainsIndexerMemberCref();
    public bool get_ContainsLockStatement();
    public bool get_ContainsQueryExpression();
    public bool get_ContainsThisConstructorInitializer();
    public bool get_ContainsTupleExpressionOrTupleType();
    public bool get_ContainsUsingStatement();
    public ImmutableArray`1<string> GetGlobalAliases(string name, int arity);
    public static Task`1<SyntaxTreeIndex> LoadAsync(IChecksummedPersistentStorageService storageService, DocumentKey documentKey, Checksum checksum, StringTable stringTable, CancellationToken cancellationToken);
    public virtual void WriteTo(ObjectWriter writer);
    private static SyntaxTreeIndex ReadIndex(StringTable stringTable, ObjectReader reader, Checksum checksum);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.FindSymbols.TopLevelSyntaxTreeIndex : AbstractSyntaxIndex`1<TopLevelSyntaxTreeIndex> {
    private DeclarationInfo _declarationInfo;
    private ExtensionMethodInfo _extensionMethodInfo;
    private Lazy`1<HashSet`1<DeclaredSymbolInfo>> _declaredSymbolInfoSet;
    [NullableAttribute("0")]
public ImmutableArray`1<DeclaredSymbolInfo> DeclaredSymbolInfos { get; }
    public HashSet`1<DeclaredSymbolInfo> DeclaredSymbolInfoSet { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<string, ImmutableArray`1<int>> ReceiverTypeNameToExtensionMethodMap { get; }
    public bool ContainsExtensionMethod { get; }
    [NullableContextAttribute("2")]
private TopLevelSyntaxTreeIndex(Checksum checksum, DeclarationInfo declarationInfo, ExtensionMethodInfo extensionMethodInfo);
    [NullableContextAttribute("0")]
public ImmutableArray`1<DeclaredSymbolInfo> get_DeclaredSymbolInfos();
    public HashSet`1<DeclaredSymbolInfo> get_DeclaredSymbolInfoSet();
    public ImmutableDictionary`2<string, ImmutableArray`1<int>> get_ReceiverTypeNameToExtensionMethodMap();
    public bool get_ContainsExtensionMethod();
    public static ValueTask`1<TopLevelSyntaxTreeIndex> GetRequiredIndexAsync(Document document, CancellationToken cancellationToken);
    public static ValueTask`1<TopLevelSyntaxTreeIndex> GetIndexAsync(Document document, CancellationToken cancellationToken);
    public static ValueTask`1<TopLevelSyntaxTreeIndex> GetIndexAsync(Document document, bool loadOnly, CancellationToken cancellationToken);
    private static TopLevelSyntaxTreeIndex CreateIndex(Document document, SyntaxNode root, Checksum checksum, CancellationToken cancellationToken);
    public static Task`1<TopLevelSyntaxTreeIndex> LoadAsync(IChecksummedPersistentStorageService storageService, DocumentKey documentKey, Checksum checksum, StringTable stringTable, CancellationToken cancellationToken);
    public virtual void WriteTo(ObjectWriter writer);
    private static TopLevelSyntaxTreeIndex ReadIndex(StringTable stringTable, ObjectReader reader, Checksum checksum);
    [CompilerGeneratedAttribute]
private HashSet`1<DeclaredSymbolInfo> <.ctor>b__3_0();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions : object {
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.FlowAnalysis.BasicBlockExtensions/<DescendantOperations>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(BasicBlock basicBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowGraphExtensions : object {
    [ExtensionAttribute]
public static BasicBlock EntryBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static BasicBlock ExitBlock(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<IOperation> DescendantOperations(ControlFlowGraph cfg);
    [ExtensionAttribute]
public static IEnumerable`1<T> DescendantOperations(ControlFlowGraph cfg, OperationKind operationKind);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.FlowAnalysis.ControlFlowRegionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static bool ContainsBlock(ControlFlowRegion region, int destinationOrdinal);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.CustomDataFlowAnalysis`1 : object {
    public static TBlockAnalysisData Run(ControlFlowGraph controlFlowGraph, DataFlowAnalyzer`1<TBlockAnalysisData> analyzer, CancellationToken cancellationToken);
    private static TBlockAnalysisData RunCore(ImmutableArray`1<BasicBlock> blocks, DataFlowAnalyzer`1<TBlockAnalysisData> analyzer, int firstBlockOrdinal, int lastBlockOrdinal, TBlockAnalysisData initialAnalysisData, ArrayBuilder`1<BasicBlock> unreachableBlocksToVisit, SortedSet`1<int> outOfRangeBlocksToVisit, PooledDictionary`2<ControlFlowRegion, bool> continueDispatchAfterFinally, PooledHashSet`1<ControlFlowRegion> dispatchedExceptionsFromRegions, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__FollowBranch|1_0(BasicBlock current, ControlFlowBranch branch, TBlockAnalysisData currentAnalsisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <RunCore>g__StepThroughFinally|1_1(ControlFlowRegion region, int destinationOrdinal, TBlockAnalysisData& currentAnalysisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static bool <RunCore>g__StepThroughSingleFinally|1_2(ControlFlowRegion finally, TBlockAnalysisData& currentAnalysisData, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__DispatchException|1_3(ControlFlowRegion fromRegion, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static void <RunCore>g__DispatchExceptionThroughCatches|1_4(ControlFlowRegion tryAndCatch, int startAt, <>c__DisplayClass1_0& );
}
internal abstract class Microsoft.CodeAnalysis.FlowAnalysis.DataFlowAnalyzer`1 : object {
    public bool AnalyzeUnreachableBlocks { get; }
    public abstract virtual TBlockAnalysisData GetCurrentAnalysisData(BasicBlock basicBlock);
    public abstract virtual TBlockAnalysisData GetEmptyAnalysisData();
    public abstract virtual void SetCurrentAnalysisData(BasicBlock basicBlock, TBlockAnalysisData data, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData AnalyzeBlock(BasicBlock basicBlock, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData AnalyzeNonConditionalBranch(BasicBlock basicBlock, TBlockAnalysisData currentAnalysisData, CancellationToken cancellationToken);
    public abstract virtual ValueTuple`2<TBlockAnalysisData, TBlockAnalysisData> AnalyzeConditionalBranch(BasicBlock basicBlock, TBlockAnalysisData currentAnalysisData, CancellationToken cancellationToken);
    public abstract virtual TBlockAnalysisData Merge(TBlockAnalysisData analysisData1, TBlockAnalysisData analysisData2, CancellationToken cancellationToken);
    public abstract virtual bool IsEqual(TBlockAnalysisData analysisData1, TBlockAnalysisData analysisData2);
    public abstract virtual bool get_AnalyzeUnreachableBlocks();
    public virtual void Dispose();
}
internal enum Microsoft.CodeAnalysis.FlowAnalysis.FlowCaptureKind : Enum {
    public int value__;
    public static FlowCaptureKind RValueCapture;
    public static FlowCaptureKind LValueCapture;
    public static FlowCaptureKind LValueAndRValueCapture;
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.LValueFlowCapturesProvider : object {
    public static ImmutableDictionary`2<CaptureId, FlowCaptureKind> CreateLValueFlowCaptures(ControlFlowGraph cfg);
}
internal static class Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageAnalysis : object {
    public static SymbolUsageResult Run(ControlFlowGraph cfg, ISymbol owningSymbol, CancellationToken cancellationToken);
    public static SymbolUsageResult Run(IOperation rootOperation, ISymbol owningSymbol, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.FlowAnalysis.SymbolUsageAnalysis.SymbolUsageResult : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> <SymbolWritesMap>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<ISymbol> <SymbolsRead>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> SymbolWritesMap { get; }
    public ImmutableHashSet`1<ISymbol> SymbolsRead { get; }
    public SymbolUsageResult(ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> symbolWritesMap, ImmutableHashSet`1<ISymbol> symbolsRead);
    [CompilerGeneratedAttribute]
public ImmutableDictionary`2<ValueTuple`2<ISymbol, IOperation>, bool> get_SymbolWritesMap();
    [CompilerGeneratedAttribute]
public ImmutableHashSet`1<ISymbol> get_SymbolsRead();
    public bool HasUnreadSymbolWrites();
    public IEnumerable`1<ValueTuple`2<ISymbol, IOperation>> GetUnreadSymbolWrites();
    public bool IsInitialParameterValueUsed(IParameterSymbol parameter);
    public int GetSymbolWriteCount(ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractAggregatedFormattingResult : object {
    protected SyntaxNode Node;
    private IList`1<AbstractFormattingResult> _formattingResults;
    [NullableAttribute("2")]
private SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> _formattingSpans;
    private CancellableLazy`1<IList`1<TextChange>> _lazyTextChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public bool ContainsChanges { get; }
    public AbstractAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> formattingResults, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> changeMap, CancellationToken cancellationToken);
    protected SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> GetFormattingSpans();
    public bool get_ContainsChanges();
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChangesWorker(CancellationToken cancellationToken);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <CreateTextChanges>b__12_0(TextChange s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormatEngine : object {
    private ChainedFormattingRules _formattingRules;
    private SyntaxNode _commonRoot;
    private SyntaxToken _startToken;
    private SyntaxToken _endToken;
    protected TextSpan SpanToFormat;
    internal SyntaxFormattingOptions Options;
    internal TreeData TreeData;
    internal IHeaderFacts HeaderFacts { get; }
    public AbstractFormatEngine(TreeData treeData, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    internal AbstractFormatEngine(TreeData treeData, SyntaxFormattingOptions options, ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken);
    internal abstract virtual IHeaderFacts get_HeaderFacts();
    protected abstract virtual AbstractTriviaDataFactory CreateTriviaFactory();
    protected abstract virtual AbstractFormattingResult CreateFormattingResult(TokenStream tokenStream);
    public AbstractFormattingResult Format(CancellationToken cancellationToken);
    protected virtual FormattingContext CreateFormattingContext(TokenStream tokenStream, CancellationToken cancellationToken);
    protected virtual NodeOperations CreateNodeOperations(CancellationToken cancellationToken);
    private static List`1<T> AddOperations(SegmentedList`1<SyntaxNode> nodes, Action`2<List`1<T>, SyntaxNode> addOperations, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private SegmentedArray`1<TokenPairWithOperations> CreateTokenOperation(TokenStream tokenStream, CancellationToken cancellationToken);
    private void ApplyTokenOperations(FormattingContext context, NodeOperations nodeOperations, SegmentedArray`1<TokenPairWithOperations> tokenOperations, CancellationToken cancellationToken);
    private void ApplyBeginningOfTreeTriviaOperation(FormattingContext context, CancellationToken cancellationToken);
    private void ApplyEndOfTreeTriviaOperation(FormattingContext context, CancellationToken cancellationToken);
    private void ApplyTriviaOperations(FormattingContext context, CancellationToken cancellationToken);
    private TextSpan GetSpanToFormat();
    private static void ApplySpecialOperations(FormattingContext context, NodeOperations nodeOperationsCollector, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplyAnchorOperations(FormattingContext context, SegmentedArray`1<TokenPairWithOperations> tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static bool AnchorOperationCandidate(TokenPairWithOperations pair);
    private static SyntaxToken FindCorrectBaseTokenOfRelativeIndentBlockOperation(IndentBlockOperation operation, TokenStream tokenStream);
    private static void ApplySpaceAndWrappingOperations(FormattingContext context, SegmentedArray`1<TokenPairWithOperations> tokenOperations, OperationApplier applier, CancellationToken cancellationToken);
    private static void ApplySpaceAndWrappingOperationsBody(FormattingContext context, TokenPairWithOperations operation, OperationApplier applier, CancellationToken cancellationToken);
    private static void BuildContext(FormattingContext context, NodeOperations nodeOperations, CancellationToken cancellationToken);
    private string FormatSummary();
    [CompilerGeneratedAttribute]
internal static void <ApplyBeginningOfTreeTriviaOperation>g__BeginningOfTreeTriviaInfoApplier|19_0(int i, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyEndOfTreeTriviaOperation>g__EndOfTreeTriviaInfoApplier|20_0(int i, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyTriviaOperations>g__RegularApplier|21_0(int tokenPairIndex, TokenStream ts, TriviaData info);
    [CompilerGeneratedAttribute]
internal static void <ApplyTriviaOperations>g__TriviaFormatter|21_1(int tokenPairIndex, FormattingContext ctx, ChainedFormattingRules formattingRules, CancellationToken ct);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingResult : object {
    protected TreeData TreeInfo;
    protected TokenStream TokenStream;
    private CancellableLazy`1<IList`1<TextChange>> _lazyChanges;
    private CancellableLazy`1<SyntaxNode> _lazyNode;
    public TextSpan FormattedSpan;
    internal AbstractFormattingResult(TreeData treeInfo, TokenStream tokenStream, TextSpan formattedSpan);
    protected abstract virtual SyntaxNode Rewriter(Dictionary`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData> map, CancellationToken cancellationToken);
    public sealed virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public sealed virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
    private IList`1<TextChange> CreateTextChanges(CancellationToken cancellationToken);
    private void AddTextChanges(List`1<TextChange> list, SyntaxToken token1, SyntaxToken token2, TriviaData data);
    private SyntaxNode CreateFormattedRoot(CancellationToken cancellationToken);
    internal IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetChanges(CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractFormattingService : object {
    [NullableContextAttribute("1")]
public sealed virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, LineFormattingOptions lineFormattingOptions, SyntaxFormattingOptions syntaxFormattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractSyntaxFormatting : object {
    private static Func`2<TextSpan, bool> s_notEmpty;
    public SyntaxFormattingOptions DefaultOptions { get; }
    private static AbstractSyntaxFormatting();
    public abstract virtual SyntaxFormattingOptions get_DefaultOptions();
    public abstract virtual SyntaxFormattingOptions GetFormattingOptions(AnalyzerConfigOptions options, SyntaxFormattingOptions fallbackOptions);
    public abstract virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    protected abstract virtual IFormattingResult CreateAggregatedFormattingResult(SyntaxNode node, IList`1<AbstractFormattingResult> results, SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> formattingSpans);
    protected abstract virtual AbstractFormattingResult Format(SyntaxNode node, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public sealed virtual IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaDataFactory : object {
    private static int SpaceCacheSize;
    private static int LineBreakCacheSize;
    private static int IndentationLevelCacheSize;
    protected TreeData TreeInfo;
    protected SyntaxFormattingOptions Options;
    private Whitespace[] _spaces;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Whitespace[0...,0...] _whitespaces;
    protected AbstractTriviaDataFactory(TreeData treeInfo, SyntaxFormattingOptions options);
    protected TriviaData GetSpaceTriviaData(int space, bool elastic);
    protected TriviaData GetWhitespaceTriviaData(int lineBreaks, int indentation, bool useTriviaAsItIs, bool elastic);
    private void EnsureWhitespaceTriviaInfo(int lineIndex, int indentationLevel);
    public abstract virtual TriviaData CreateLeadingTrivia(SyntaxToken token);
    public abstract virtual TriviaData CreateTrailingTrivia(SyntaxToken token);
    public abstract virtual TriviaData Create(SyntaxToken token1, SyntaxToken token2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.AbstractTriviaFormatter : object {
    private static String[] s_spaceCache;
    protected FormattingContext Context;
    protected ChainedFormattingRules FormattingRules;
    protected string OriginalString;
    protected int LineBreaks;
    protected int Spaces;
    protected LineColumn InitialLineColumn;
    protected SyntaxToken Token1;
    protected SyntaxToken Token2;
    private int _indentation;
    private bool _firstLineBlank;
    protected int StartPosition { get; }
    protected int EndPosition { get; }
    protected TreeData TreeInfo { get; }
    protected SyntaxFormattingOptions Options { get; }
    protected TokenStream TokenStream { get; }
    private static AbstractTriviaFormatter();
    public AbstractTriviaFormatter(FormattingContext context, ChainedFormattingRules formattingRules, SyntaxToken token1, SyntaxToken token2, string originalString, int lineBreaks, int spaces);
    protected abstract virtual bool Succeeded();
    protected abstract virtual bool IsWhitespace(SyntaxTrivia trivia);
    protected abstract virtual bool IsEndOfLine(SyntaxTrivia trivia);
    protected abstract virtual bool LineContinuationFollowedByWhitespaceComment(SyntaxTrivia previousTrivia, SyntaxTrivia nextTrivia);
    protected abstract virtual bool IsVisualBasicComment(SyntaxTrivia trivia);
    [NullableContextAttribute("2")]
protected bool IsNullOrWhitespace(string text);
    protected abstract virtual bool IsWhitespace(char ch);
    protected abstract virtual bool IsNewLine(char ch);
    protected abstract virtual SyntaxTrivia CreateWhitespace(string text);
    protected abstract virtual SyntaxTrivia CreateEndOfLine();
    protected abstract virtual LineColumnRule GetLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<SyntaxTrivia> changes, CancellationToken cancellationToken);
    protected abstract virtual LineColumnDelta Format(LineColumn lineColumn, SyntaxTrivia trivia, ArrayBuilder`1<TextChange> changes, CancellationToken cancellationToken);
    protected abstract virtual bool ContainsImplicitLineBreak(SyntaxTrivia trivia);
    protected int get_StartPosition();
    protected int get_EndPosition();
    protected TreeData get_TreeInfo();
    protected SyntaxFormattingOptions get_Options();
    protected TokenStream get_TokenStream();
    public SyntaxTriviaList FormatToSyntaxTrivia(CancellationToken cancellationToken);
    private static void AddRange(ArrayBuilder`1<SyntaxTrivia> result, SyntaxTriviaList triviaList);
    [NullableContextAttribute("0")]
public ImmutableArray`1<TextChange> FormatToTextChanges(CancellationToken cancellationToken);
    private LineColumn FormatTrivia(Formatter`1<T> formatter, WhitespaceAppender`1<T> whitespaceAdder, ArrayBuilder`1<T> changes, CancellationToken cancellationToken);
    private LineColumn FormatFirstTriviaAndWhitespaceAfter(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, Formatter`1<T> format, WhitespaceAppender`1<T> addWhitespaceTrivia, ArrayBuilder`1<T> changes, bool implicitLineBreak, CancellationToken cancellationToken);
    private LineColumnRule GetOverallLineColumnRuleBetween(SyntaxTrivia trivia1, LineColumnDelta existingWhitespaceBetween, bool implicitLineBreak, SyntaxTrivia trivia2);
    private void GetTokensAtEdgeOfStructureTrivia(SyntaxTrivia trivia1, SyntaxTrivia trivia2, SyntaxToken& token1, SyntaxToken& token2);
    private bool ContainsOnlyWhitespace(int start, int end);
    private bool FirstLineBlank();
    private LineColumnDelta Apply(LineColumn lineColumnBeforeTrivia1, SyntaxTrivia trivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private int GetRuleSpacesOrIndentation(LineColumn lineColumnBeforeTrivia1, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween, SyntaxTrivia trivia2, LineColumnRule rule);
    private static int GetRuleLines(LineColumnRule rule, LineColumn lineColumnAfterTrivia1, LineColumnDelta existingWhitespaceBetween);
    private int GetIndentation();
    private static int GetTrailingLinesAtEndOfTrivia1(LineColumn lineColumnAfterTrivia1);
    private void AddExtraLines(int linesBetweenTokens, ArrayBuilder`1<SyntaxTrivia> changes);
    private int GetInsertionIndex(ArrayBuilder`1<SyntaxTrivia> changes);
    private void AddExtraLines(int linesBetweenTokens, ArrayBuilder`1<TextChange> changes);
    private bool TryGetMatchingChangeIndex(ArrayBuilder`1<TextChange> changes, Int32& index);
    private TextSpan GetInsertionSpan(ArrayBuilder`1<TextChange> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, ArrayBuilder`1<SyntaxTrivia> changes);
    private void AddWhitespaceTrivia(LineColumn lineColumn, LineColumnDelta delta, TextSpan notUsed, ArrayBuilder`1<SyntaxTrivia> changes);
    private string GetWhitespaceString(LineColumn lineColumn, LineColumnDelta delta);
    private TextChange GetWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span);
    private void AddWhitespaceTextChange(LineColumn lineColumn, LineColumnDelta delta, TextSpan span, ArrayBuilder`1<TextChange> changes);
    private TextSpan GetTextSpan(SyntaxTrivia trivia1, SyntaxTrivia trivia2);
    private bool IsWhitespaceOrEndOfLine(SyntaxTrivia trivia);
    private LineColumnDelta GetLineColumnOfWhitespace(LineColumn lineColumn, SyntaxTrivia previousTrivia, SyntaxTrivia trivia1, LineColumnDelta whitespaceBetween, SyntaxTrivia trivia2);
    private LineColumn GetInitialLineColumn();
    protected LineColumn GetLineColumn(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(LineColumn lineColumn, SyntaxTrivia trivia);
    protected LineColumnDelta GetLineColumnDelta(int initialColumn, string text);
    protected int GetExistingIndentation(SyntaxTrivia trivia);
    private static string GetSpaces(int space);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.AutoFormattingOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <FormatOnReturn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnTyping>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnSemicolon>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FormatOnCloseBrace>k__BackingField;
    public static AutoFormattingOptions Default;
    [DataMemberAttribute]
public bool FormatOnReturn { get; public set; }
    [DataMemberAttribute]
public bool FormatOnTyping { get; public set; }
    [DataMemberAttribute]
public bool FormatOnSemicolon { get; public set; }
    [DataMemberAttribute]
public bool FormatOnCloseBrace { get; public set; }
    private static AutoFormattingOptions();
    [CompilerGeneratedAttribute]
public bool get_FormatOnReturn();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnReturn(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnTyping();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnTyping(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnSemicolon();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnSemicolon(bool value);
    [CompilerGeneratedAttribute]
public bool get_FormatOnCloseBrace();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormatOnCloseBrace(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(AutoFormattingOptions left, AutoFormattingOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(AutoFormattingOptions left, AutoFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(AutoFormattingOptions other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder : object {
    [NullableAttribute("2")]
private TokenStream _tokenStream;
    private ChainedFormattingRules _formattingRules;
    private int _tabSize;
    private int _indentationSize;
    private IHeaderFacts _headerFacts;
    public BottomUpBaseIndentationFinder(ChainedFormattingRules formattingRules, int tabSize, int indentationSize, TokenStream tokenStream, IHeaderFacts headerFacts);
    public Nullable`1<int> FromIndentBlockOperations(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public Nullable`1<int> FromAlignTokensOperations(SyntaxTree tree, SyntaxToken token);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxTree tree, SyntaxToken token, int position, int extraSpaces, CancellationToken cancellationToken);
    public int GetIndentationOfCurrentPosition(SyntaxNode root, IndentBlockOperation startingOperation, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private int GetIndentationOfCurrentPosition(SyntaxNode root, List`1<IndentBlockOperation> list, int position, int extraSpaces, Func`2<SyntaxToken, int> tokenColumnGetter, CancellationToken cancellationToken);
    private ValueTuple`2<int, IndentBlockOperation> GetIndentationRuleOfCurrentPosition(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
    private List`1<IndentBlockOperation> GetParentIndentBlockOperations(SyntaxToken token);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetParentNodes>d__14")]
private static IEnumerable`1<SyntaxNode> GetParentNodes(SyntaxToken token);
    private SyntaxToken GetAlignmentBaseTokenFor(SyntaxToken token);
    private IndentBlockOperation GetIndentationDataFor(SyntaxNode root, SyntaxToken token, int position);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.BottomUpBaseIndentationFinder/<GetIndentBlockOperationsFromSmallestSpan>d__17")]
private static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperationsFromSmallestSpan(SyntaxNode root, List`1<IndentBlockOperation> list, int position);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.ChainedFormattingRules : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConcurrentDictionary`2<ValueTuple`2<Type, string>, Type> s_typeImplementingMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private SyntaxFormattingOptions _options;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addSuppressOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addAnchorIndentationOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addIndentBlockOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _addAlignTokensOperationsRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _getAdjustNewLinesOperationRules;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _getAdjustSpacesOperationRules;
    public ChainedFormattingRules(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxFormattingOptions options);
    private static ChainedFormattingRules();
    public void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode currentNode);
    public void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode currentNode);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode currentNode);
    public void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode currentNode);
    [NullableContextAttribute("2")]
public AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    [NullableContextAttribute("2")]
public AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken previousToken, SyntaxToken currentToken);
    private static ImmutableArray`1<AbstractFormattingRule> FilterToRulesImplementingMethod(ImmutableArray`1<AbstractFormattingRule> rules, string name);
    private static Type GetTypeImplementingMethod(object obj, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Formatting.ContextIntervalTree`2 : SimpleIntervalTree`2<T, TIntrospector> {
    private Func`4<T, int, int, bool> _edgeExclusivePredicate;
    private Func`4<T, int, int, bool> _edgeInclusivePredicate;
    private Func`4<T, int, int, bool> _containPredicate;
    [NullableContextAttribute("0")]
public ContextIntervalTree`2(TIntrospector& introspector);
    [NullableContextAttribute("2")]
public T GetSmallestEdgeExclusivelyContainingInterval(int start, int length);
    [NullableContextAttribute("2")]
public T GetSmallestEdgeInclusivelyContainingInterval(int start, int length);
    [NullableContextAttribute("2")]
public T GetSmallestContainingInterval(int start, int length);
    private bool ContainsEdgeExclusive(T value, int start, int length);
    private bool ContainsEdgeInclusive(T value, int start, int length);
    private T GetSmallestContainingIntervalWorker(int start, int length, Func`4<T, int, int, bool> predicate);
    [CompilerGeneratedAttribute]
private bool <.ctor>b__3_0(T value, int start, int end);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptions : object {
    public static DocumentFormattingOptions Default;
    [CompilerGeneratedAttribute]
private string <FileHeaderTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InsertFinalNewLine>k__BackingField;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public string FileHeaderTemplate { get; public set; }
    [DataMemberAttribute]
public bool InsertFinalNewLine { get; public set; }
    [CompilerGeneratedAttribute]
private DocumentFormattingOptions(DocumentFormattingOptions original);
    private static DocumentFormattingOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_FileHeaderTemplate();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FileHeaderTemplate(string value);
    [CompilerGeneratedAttribute]
public bool get_InsertFinalNewLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InsertFinalNewLine(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentFormattingOptions left, DocumentFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(DocumentFormattingOptions left, DocumentFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentFormattingOptions other);
    [CompilerGeneratedAttribute]
public DocumentFormattingOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProviders : object {
    [ExtensionAttribute]
public static DocumentFormattingOptions GetDocumentFormattingOptions(AnalyzerConfigOptions options, DocumentFormattingOptions fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProviders/<GetDocumentFormattingOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<DocumentFormattingOptions> GetDocumentFormattingOptionsAsync(Document document, DocumentFormattingOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.DocumentFormattingOptionsProviders/<GetDocumentFormattingOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<DocumentFormattingOptions> GetDocumentFormattingOptionsAsync(Document document, DocumentFormattingOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Formatting.Formatter : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    private static Formatter();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    internal static ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules(Document document);
    internal static ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules(LanguageServices languageServices);
    public static Task`1<Document> FormatAsync(Document document, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<Document> FormatAsync(Document document, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, TextSpan span, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<Document> FormatAsync(Document document, TextSpan span, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__9")]
public static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__10")]
internal static Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet options, CancellationToken cancellationToken);
    internal static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__13")]
internal static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<FormatAsync>d__14")]
internal static Task`1<Document> FormatAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, Workspace workspace, OptionSet options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, SyntaxAnnotation annotation, SolutionServices services, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, TextSpan span, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    private static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static SyntaxNode Format(SyntaxNode node, IEnumerable`1<TextSpan> spans, SolutionServices services, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, SolutionServices services, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, TextSpan span, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    public static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, SolutionServices services, SyntaxFormattingOptions options, CancellationToken cancellationToken);
    private static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, Workspace workspace, OptionSet options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static IList`1<TextChange> GetFormattedTextChanges(SyntaxNode node, IEnumerable`1<TextSpan> spans, SolutionServices services, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
    internal static SyntaxFormattingOptions GetFormattingOptions(Workspace workspace, OptionSet optionSet, string language);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<GetFormattingOptionsAsync>d__37")]
internal static ValueTask`1<ValueTuple`2<SyntaxFormattingOptions, LineFormattingOptions>> GetFormattingOptionsAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<OrganizeImportsAsync>d__38")]
public static Task`1<Document> OrganizeImportsAsync(Document document, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.Formatter/<GetOrganizeImportsOptionsAsync>d__39")]
internal static ValueTask`1<OrganizeImportsOptions> GetOrganizeImportsOptionsAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.FormattingContext : object {
    private AbstractFormatEngine _engine;
    private TokenStream _tokenStream;
    private ContextIntervalTree`2<RelativeIndentationData, FormattingContextIntervalIntrospector> _relativeIndentationTree;
    private ContextIntervalTree`2<IndentationData, FormattingContextIntervalIntrospector> _indentationTree;
    private ContextIntervalTree`2<SuppressWrappingData, SuppressIntervalIntrospector> _suppressWrappingTree;
    private ContextIntervalTree`2<SuppressSpacingData, SuppressIntervalIntrospector> _suppressSpacingTree;
    private ContextIntervalTree`2<SuppressSpacingData, SuppressIntervalIntrospector> _suppressFormattingTree;
    private ContextIntervalTree`2<AnchorData, FormattingContextIntervalIntrospector> _anchorTree;
    private SegmentedDictionary`2<SyntaxToken, AnchorData> _anchorBaseTokenMap;
    private HashSet`1<TextSpan> _indentationMap;
    private HashSet`1<TextSpan> _suppressWrappingMap;
    private HashSet`1<TextSpan> _suppressSpacingMap;
    private HashSet`1<TextSpan> _suppressFormattingMap;
    private HashSet`1<TextSpan> _anchorMap;
    private List`1<IndentBlockOperation> _initialIndentBlockOperations;
    public SyntaxFormattingOptions Options { get; }
    public TreeData TreeData { get; }
    public TokenStream TokenStream { get; }
    public FormattingContext(AbstractFormatEngine engine, TokenStream tokenStream);
    public void Initialize(ChainedFormattingRules formattingRules, SyntaxToken startToken, SyntaxToken endToken, CancellationToken cancellationToken);
    public void AddIndentBlockOperations(List`1<IndentBlockOperation> operations, CancellationToken cancellationToken);
    public void AddIndentBlockOperation(IndentBlockOperation operation);
    public void AddInitialSuppressOperation(SuppressOperation operation);
    public void AddSuppressOperations(List`1<SuppressOperation> operations, CancellationToken cancellationToken);
    private void AddSuppressOperation(SuppressOperation operation, bool onSameLine);
    private void AddSpacingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    private void AddFormattingSuppressOperation(SuppressOperation operation);
    private void AddWrappingSuppressOperation(SuppressOperation operation, bool twoTokensOnSameLine);
    public void AddAnchorIndentationOperation(AnchorIndentationOperation operation);
    [NullableContextAttribute("0")]
[ConditionalAttribute("DEBUG")]
private static void DebugCheckEmpty(ContextIntervalTree`2<T, TIntrospector> tree, TextSpan textSpan);
    public int GetBaseIndentation(SyntaxToken token);
    public int GetBaseIndentation(int position);
    public IEnumerable`1<IndentBlockOperation> GetAllRelativeIndentBlockOperations();
    public bool TryGetEndTokenForRelativeIndentationSpan(SyntaxToken token, int maxChainDepth, SyntaxToken& endToken, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private AnchorData GetAnchorData(SyntaxToken token);
    public int GetAnchorDeltaFromOriginalColumn(SyntaxToken token);
    public SyntaxToken GetAnchorToken(SyntaxToken token);
    public int GetDeltaFromPreviousChangesMap(SyntaxToken token, Dictionary`2<SyntaxToken, int> previousChangesMap);
    public SyntaxToken GetEndTokenForAnchorSpan(TokenData tokenData);
    [NullableContextAttribute("2")]
private AnchorData FindAnchorSpanOnSameLineAfterToken(TokenData tokenData);
    public bool IsWrappingSuppressed(TextSpan textSpan, bool containsElasticTrivia);
    public bool IsSpacingSuppressed(TextSpan textSpan, bool containsElasticTrivia);
    public bool IsSpacingSuppressed(int pairIndex);
    public bool IsFormattingDisabled(TextSpan textSpan);
    public bool IsFormattingDisabled(int pairIndex);
    public SyntaxFormattingOptions get_Options();
    public TreeData get_TreeData();
    public TokenStream get_TokenStream();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingDiagnosticIds : object {
    public static string FormattingDiagnosticId;
    public static string FormatDocumentControlDiagnosticId;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingExtensions : object {
    private static Char[] s_trimChars;
    private static FormattingExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetParentWithBiggerSpan(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<AbstractFormattingRule> Concat(AbstractFormattingRule rule, IEnumerable`1<AbstractFormattingRule> rules);
    [ExtensionAttribute]
public static void AddRange(IList`1<T> list, IEnumerable`1<T> values);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static List`1<T> Combine(List`1<T> list1, List`1<T> list2);
    [ExtensionAttribute]
public static bool ContainsElasticTrivia(SuppressOperation operation, TokenStream tokenStream);
    [ExtensionAttribute]
public static bool HasAnyWhitespaceElasticTrivia(SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsOn(IndentBlockOption option, IndentBlockOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(IndentBlockOption option, IndentBlockOption mask);
    [ExtensionAttribute]
public static bool IsOn(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static bool IsMaskOn(SuppressOption option, SuppressOption mask);
    [ExtensionAttribute]
public static SuppressOption RemoveFlag(SuppressOption option, SuppressOption flag);
    [ExtensionAttribute]
public static string CreateIndentationString(int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static StringBuilder AppendIndentationString(StringBuilder sb, int desiredIndentation, bool useTab, int tabSize);
    [ExtensionAttribute]
public static void ProcessTextBetweenTokens(string text, TreeData treeInfo, SyntaxToken baseToken, int tabSize, Int32& lineBreaks, Int32& spaceOrIndentation);
    [ExtensionAttribute]
public static string AdjustIndentForXmlDocExteriorTrivia(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize);
    [ExtensionAttribute]
public static string ReindentStartOfXmlDocumentationComment(string triviaText, bool forceIndentation, int indentation, int indentationDelta, bool useTab, int tabSize, string newLine);
    [ExtensionAttribute]
private static int GetNewIndentationForComments(string line, int nonWhitespaceCharIndex, bool forceIndentation, int indentation, int indentationDelta, int tabSize);
    [ExtensionAttribute]
public static int GetFirstNonWhitespaceIndexInString(string text);
    [ExtensionAttribute]
public static TextChange SimpleDiff(TextChange textChange, string text);
    internal static IEnumerable`1<TextSpan> GetAnnotatedSpans(SyntaxNode node, SyntaxAnnotation annotation);
    internal static TextSpan GetSpan(SyntaxToken firstToken, SyntaxToken lastToken);
    internal static TextSpan GetElasticSpan(SyntaxToken token);
    private static IEnumerable`1<TextSpan> AggregateSpans(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
internal static int GetAdjustedIndentationDelta(IndentBlockOperation operation, IHeaderFacts headerFacts, SyntaxNode root, SyntaxToken indentationAnchor);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.FormattingExtensions/<<GetAnnotatedSpans>g__EnumerateAnnotatedSpans|20_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<TextSpan> <GetAnnotatedSpans>g__EnumerateAnnotatedSpans|20_0(SyntaxNode node, SyntaxAnnotation annotation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.FormattingOptionGroups : object {
    public static OptionGroup IndentationAndSpacing;
    public static OptionGroup NewLine;
    private static FormattingOptionGroups();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Formatting.FormattingOptions : object {
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<int> <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<string> <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<IndentStyle> <SmartIndent>k__BackingField;
    public static PerLanguageOption`1<bool> UseTabs { get; }
    public static PerLanguageOption`1<int> TabSize { get; }
    public static PerLanguageOption`1<int> IndentationSize { get; }
    public static PerLanguageOption`1<string> NewLine { get; }
    public static PerLanguageOption`1<IndentStyle> SmartIndent { get; }
    private static FormattingOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_UseTabs();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_TabSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<int> get_IndentationSize();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<string> get_NewLine();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<IndentStyle> get_SmartIndent();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.FormattingOptions2 : object {
    private static string FeatureName;
    public static PerLanguageOption2`1<bool> UseTabs;
    public static PerLanguageOption2`1<int> TabSize;
    public static PerLanguageOption2`1<int> IndentationSize;
    public static PerLanguageOption2`1<string> NewLine;
    internal static Option2`1<bool> InsertFinalNewLine;
    [CompilerGeneratedAttribute]
private static PerLanguageOption2`1<IndentStyle> <SmartIndent>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<IOption> Options;
    public static PerLanguageOption2`1<IndentStyle> SmartIndent { get; }
    private static FormattingOptions2();
    [CompilerGeneratedAttribute]
public static PerLanguageOption2`1<IndentStyle> get_SmartIndent();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingResult {
    public abstract virtual IList`1<TextChange> GetTextChanges(CancellationToken cancellationToken);
    public abstract virtual SyntaxNode GetFormattedRoot(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.IFormattingService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<Document> FormatAsync(Document document, IEnumerable`1<TextSpan> spans, LineFormattingOptions lineFormattingOptions, SyntaxFormattingOptions syntaxFormattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.ILegacyIndentationManagerWorkspaceService {
    public abstract virtual Nullable`1<bool> UseSpacesForWhitespace(SourceText text);
    public abstract virtual Nullable`1<int> GetTabSize(SourceText text);
    public abstract virtual Nullable`1<int> GetIndentSize(SourceText text);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.ISyntaxFormatting {
    public SyntaxFormattingOptions DefaultOptions { get; }
    public abstract virtual SyntaxFormattingOptions get_DefaultOptions();
    public abstract virtual SyntaxFormattingOptions GetFormattingOptions(AnalyzerConfigOptions options, SyntaxFormattingOptions fallbackOptions);
    public abstract virtual ImmutableArray`1<AbstractFormattingRule> GetDefaultFormattingRules();
    public abstract virtual IFormattingResult GetFormattingResult(SyntaxNode node, IEnumerable`1<TextSpan> spans, SyntaxFormattingOptions options, IEnumerable`1<AbstractFormattingRule> rules, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Formatting.ISyntaxFormattingService {
    public abstract virtual bool ShouldFormatOnTypedCharacter(ParsedDocument document, char typedChar, int caretPosition, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TextChange> GetFormattingChangesOnTypedCharacter(ParsedDocument document, int caretPosition, IndentationOptions indentationOptions, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TextChange> GetFormattingChangesOnPaste(ParsedDocument document, TextSpan textSpan, SyntaxFormattingOptions options, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumn : ValueType {
    public static LineColumn Default;
    public int Line;
    public int Column;
    public bool WhitespaceOnly;
    public LineColumn(int line, int column, bool whitespaceOnly);
    private static LineColumn();
    public LineColumn With(LineColumnDelta delta);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumnDelta : ValueType {
    public static LineColumnDelta Default;
    public int Lines;
    public int Spaces;
    public bool WhitespaceOnly;
    public bool ForceUpdate;
    public LineColumnDelta(int lines, int spaces);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly);
    public LineColumnDelta(int lines, int spaces, bool whitespaceOnly, bool forceUpdate);
    private static LineColumnDelta();
    internal LineColumnDelta With(LineColumnDelta delta);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineColumnRule : ValueType {
    public SpaceOperations SpaceOperation;
    public LineOperations LineOperation;
    public IndentationOperations IndentationOperation;
    public int Lines;
    public int Spaces;
    public int Indentation;
    public static LineColumnRule Preserve;
    public static LineColumnRule PreserveLinesWithFollowingPrecedingIndentation;
    public LineColumnRule(SpaceOperations spaceOperation, LineOperations lineOperation, IndentationOperations indentationOperation, int lines, int spaces, int indentation);
    private static LineColumnRule();
    public LineColumnRule With(Nullable`1<int> lines, Nullable`1<int> spaces, Nullable`1<int> indentation, Nullable`1<LineOperations> lineOperation, Nullable`1<SpaceOperations> spaceOperation, Nullable`1<IndentationOperations> indentationOperation);
    public static LineColumnRule PreserveWithGivenSpaces(int spaces);
    public static LineColumnRule PreserveLinesWithDefaultIndentation(int lines);
    public static LineColumnRule PreserveLinesWithGivenIndentation(int lines);
    public static LineColumnRule PreserveLinesWithAbsoluteIndentation(int lines, int indentation);
    public static LineColumnRule ForceSpaces(int spaces);
    public static LineColumnRule PreserveSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseDefaultIndentation(int spaces);
    public static LineColumnRule ForceSpacesOrUseFollowIndentation(int indentation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Formatting.LineFormattingOptions : object {
    public static LineFormattingOptions Default;
    [CompilerGeneratedAttribute]
private bool <UseTabs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TabSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    private Type EqualityContract { get; }
    [DataMemberAttribute]
public bool UseTabs { get; public set; }
    [DataMemberAttribute]
public int TabSize { get; public set; }
    [DataMemberAttribute]
public int IndentationSize { get; public set; }
    [DataMemberAttribute]
public string NewLine { get; public set; }
    [CompilerGeneratedAttribute]
private LineFormattingOptions(LineFormattingOptions original);
    private static LineFormattingOptions();
    [CompilerGeneratedAttribute]
private Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public bool get_UseTabs();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_UseTabs(bool value);
    [CompilerGeneratedAttribute]
public int get_TabSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_TabSize(int value);
    [CompilerGeneratedAttribute]
public int get_IndentationSize();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentationSize(int value);
    [CompilerGeneratedAttribute]
public string get_NewLine();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLine(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LineFormattingOptions left, LineFormattingOptions right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LineFormattingOptions left, LineFormattingOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(LineFormattingOptions other);
    [CompilerGeneratedAttribute]
public LineFormattingOptions <Clone>$();
}
internal interface Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProviders : object {
    [ExtensionAttribute]
public static LineFormattingOptions GetLineFormattingOptions(AnalyzerConfigOptions options, LineFormattingOptions fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProviders/<GetLineFormattingOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<LineFormattingOptions> GetLineFormattingOptionsAsync(Document document, LineFormattingOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.LineFormattingOptionsProviders/<GetLineFormattingOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<LineFormattingOptions> GetLineFormattingOptionsAsync(Document document, LineFormattingOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.NodeOperations : object {
    public static NodeOperations Empty;
    [CompilerGeneratedAttribute]
private List`1<IndentBlockOperation> <IndentBlockOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<SuppressOperation> <SuppressOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AlignTokensOperation> <AlignmentOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<AnchorIndentationOperation> <AnchorIndentationOperations>k__BackingField;
    public List`1<IndentBlockOperation> IndentBlockOperation { get; }
    public List`1<SuppressOperation> SuppressOperation { get; }
    public List`1<AlignTokensOperation> AlignmentOperation { get; }
    public List`1<AnchorIndentationOperation> AnchorIndentationOperations { get; }
    public NodeOperations(List`1<IndentBlockOperation> indentBlockOperation, List`1<SuppressOperation> suppressOperation, List`1<AnchorIndentationOperation> anchorIndentationOperations, List`1<AlignTokensOperation> alignmentOperation);
    private static NodeOperations();
    [CompilerGeneratedAttribute]
public List`1<IndentBlockOperation> get_IndentBlockOperation();
    [CompilerGeneratedAttribute]
public List`1<SuppressOperation> get_SuppressOperation();
    [CompilerGeneratedAttribute]
public List`1<AlignTokensOperation> get_AlignmentOperation();
    [CompilerGeneratedAttribute]
public List`1<AnchorIndentationOperation> get_AnchorIndentationOperations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.AbstractFormattingRule : object {
    public virtual AbstractFormattingRule WithOptions(SyntaxFormattingOptions options);
    public virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOperation : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOption <Option>k__BackingField;
    public int Line { get; }
    public AdjustNewLinesOption Option { get; }
    internal AdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustNewLinesOption : Enum {
    public int value__;
    public static AdjustNewLinesOption PreserveLines;
    public static AdjustNewLinesOption ForceLines;
    public static AdjustNewLinesOption ForceLinesIfOnSingleLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOperation : object {
    [CompilerGeneratedAttribute]
private int <Space>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOption <Option>k__BackingField;
    public int Space { get; }
    public AdjustSpacesOption Option { get; }
    internal AdjustSpacesOperation(int space, AdjustSpacesOption option);
    [CompilerGeneratedAttribute]
public int get_Space();
    [CompilerGeneratedAttribute]
public AdjustSpacesOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AdjustSpacesOption : Enum {
    public int value__;
    public static AdjustSpacesOption PreserveSpaces;
    public static AdjustSpacesOption DefaultSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpacesIfOnSingleLine;
    public static AdjustSpacesOption ForceSpaces;
    public static AdjustSpacesOption DynamicSpaceToIndentationIfOnSingleLine;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SyntaxToken> <Tokens>k__BackingField;
    [CompilerGeneratedAttribute]
private AlignTokensOption <Option>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public IEnumerable`1<SyntaxToken> Tokens { get; }
    public AlignTokensOption Option { get; }
    internal AlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<SyntaxToken> get_Tokens();
    [CompilerGeneratedAttribute]
public AlignTokensOption get_Option();
}
internal enum Microsoft.CodeAnalysis.Formatting.Rules.AlignTokensOption : Enum {
    public int value__;
    public static AlignTokensOption AlignIndentationOfTokensToBaseToken;
    public static AlignTokensOption AlignIndentationOfTokensToFirstTokenOfBaseTokenLine;
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.AnchorIndentationOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <AnchorToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public SyntaxToken AnchorToken { get; }
    public TextSpan TextSpan { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal AnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken, TextSpan textSpan);
    [CompilerGeneratedAttribute]
public SyntaxToken get_AnchorToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.Rules.BaseIndentationFormattingRule : AbstractFormattingRule {
    [NullableAttribute("2")]
private AbstractFormattingRule _vbHelperFormattingRule;
    private int _baseIndentation;
    private SyntaxToken _token1;
    private SyntaxToken _token2;
    [NullableAttribute("2")]
private SyntaxNode _commonNode;
    private TextSpan _span;
    public BaseIndentationFormattingRule(SyntaxNode root, TextSpan span, int baseIndentation, AbstractFormattingRule vbHelperFormattingRule);
    public virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    private void AddNextIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    private void AdjustIndentBlockOperation(List`1<IndentBlockOperation> list);
    private bool Myself(IndentBlockOperation operation);
    private IndentBlockOperation CloneAndAdjustFormattingOperation(IndentBlockOperation operation);
    private TextSpan AdjustTextSpan(TextSpan textSpan);
    private static void SetInnermostNodeForSpan(SyntaxNode root, TextSpan& span, SyntaxToken& token1, SyntaxToken& token2, SyntaxNode& commonNode);
    private static void GetTokens(SyntaxNode root, TextSpan span, SyntaxToken& token1, SyntaxToken& token2);
    private static TextSpan GetSpanFromTokens(TextSpan span, SyntaxToken token1, SyntaxToken token2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.Rules.CompatAbstractFormattingRule : AbstractFormattingRule {
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddSuppressOperations(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddAnchorIndentationOperations(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddIndentBlockOperations(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual void AddAlignTokensOperations(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual AdjustNewLinesOperation GetAdjustNewLinesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustNewLinesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("Do not call this method directly (it will Stack Overflow).", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual AdjustSpacesOperation GetAdjustSpacesOperation(SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) previousToken, SyntaxToken& modreq(System.Runtime.InteropServices.InAttribute) currentToken, NextGetAdjustSpacesOperation& modreq(System.Runtime.InteropServices.InAttribute) nextOperation);
    public virtual void AddSuppressOperationsSlow(List`1<SuppressOperation> list, SyntaxNode node, NextSuppressOperationAction& nextOperation);
    public virtual void AddAnchorIndentationOperationsSlow(List`1<AnchorIndentationOperation> list, SyntaxNode node, NextAnchorIndentationOperationAction& nextOperation);
    public virtual void AddIndentBlockOperationsSlow(List`1<IndentBlockOperation> list, SyntaxNode node, NextIndentBlockOperationAction& nextOperation);
    public virtual void AddAlignTokensOperationsSlow(List`1<AlignTokensOperation> list, SyntaxNode node, NextAlignTokensOperationAction& nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustNewLinesOperation GetAdjustNewLinesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustNewLinesOperation& nextOperation);
    [NullableContextAttribute("2")]
public virtual AdjustSpacesOperation GetAdjustSpacesOperationSlow(SyntaxToken& previousToken, SyntaxToken& currentToken, NextGetAdjustSpacesOperation& nextOperation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.DefaultFormattingRuleFactoryService : object {
    public sealed virtual bool ShouldNotFormatOrCommitOnPaste(DocumentId documentId);
    public sealed virtual bool ShouldUseBaseIndentation(DocumentId documentId);
    public sealed virtual AbstractFormattingRule CreateRule(ParsedDocument document, int position);
    public sealed virtual IEnumerable`1<TextChange> FilterFormattedChanges(DocumentId document, TextSpan span, IList`1<TextChange> changes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.Rules.FormattingOperations : object {
    private static AdjustNewLinesOperation s_preserveZeroLine;
    private static AdjustNewLinesOperation s_preserveOneLine;
    private static AdjustNewLinesOperation s_forceOneLine;
    private static AdjustNewLinesOperation s_forceIfSameLine;
    private static AdjustSpacesOperation s_defaultOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceOneSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroSpaceIfOnSingleLine;
    private static AdjustSpacesOperation s_forceZeroLineUsingSpaceForce;
    private static FormattingOperations();
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken);
    public static AnchorIndentationOperation CreateAnchorIndentationOperation(SyntaxToken anchorToken, SyntaxToken endToken, TextSpan textSpan);
    public static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, SuppressOption option);
    private static SuppressOperation CreateSuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateIndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, int indentationDelta, IndentBlockOption option);
    public static IndentBlockOperation CreateRelativeIndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    public static AlignTokensOperation CreateAlignTokensOperation(SyntaxToken baseToken, IEnumerable`1<SyntaxToken> tokens, AlignTokensOption option);
    public static AdjustNewLinesOperation CreateAdjustNewLinesOperation(int line, AdjustNewLinesOption option);
    public static AdjustSpacesOperation CreateAdjustSpacesOperation(int space, AdjustSpacesOption option);
    internal static IEnumerable`1<SuppressOperation> GetSuppressOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static IEnumerable`1<AnchorIndentationOperation> GetAnchorIndentationOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static IEnumerable`1<IndentBlockOperation> GetIndentBlockOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static IEnumerable`1<AlignTokensOperation> GetAlignTokensOperations(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxNode node, SyntaxFormattingOptions options);
    internal static AdjustNewLinesOperation GetAdjustNewLinesOperation(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, SyntaxFormattingOptions options);
    internal static AdjustSpacesOperation GetAdjustSpacesOperation(IEnumerable`1<AbstractFormattingRule> formattingRules, SyntaxToken previousToken, SyntaxToken currentToken, SyntaxFormattingOptions options);
}
[ObsoleteAttribute("This interface is no longer used")]
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IFormattingRule {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Formatting.Rules.IHostDependentFormattingRuleFactoryService {
    public abstract virtual bool ShouldNotFormatOrCommitOnPaste(DocumentId documentId);
    public abstract virtual bool ShouldUseBaseIndentation(DocumentId documentId);
    public abstract virtual AbstractFormattingRule CreateRule(ParsedDocument document, int position);
    public abstract virtual IEnumerable`1<TextChange> FilterFormattedChanges(DocumentId documentId, TextSpan span, IList`1<TextChange> changes);
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOperation : object {
    [CompilerGeneratedAttribute]
private SyntaxToken <BaseToken>k__BackingField;
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentBlockOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRelativeIndentation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndentationDeltaOrPosition>k__BackingField;
    public SyntaxToken BaseToken { get; }
    public TextSpan TextSpan { get; }
    public IndentBlockOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    public bool IsRelativeIndentation { get; }
    public int IndentationDeltaOrPosition { get; }
    internal IndentBlockOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    internal IndentBlockOperation(SyntaxToken baseToken, SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, int indentationDelta, IndentBlockOption option);
    [CompilerGeneratedAttribute]
public SyntaxToken get_BaseToken();
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public IndentBlockOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
    [CompilerGeneratedAttribute]
public bool get_IsRelativeIndentation();
    [CompilerGeneratedAttribute]
public int get_IndentationDeltaOrPosition();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.IndentBlockOption : Enum {
    public int value__;
    public static IndentBlockOption RelativeToFirstTokenOnBaseTokenLine;
    public static IndentBlockOption RelativePosition;
    public static IndentBlockOption AbsolutePosition;
    public static IndentBlockOption RelativePositionMask;
    public static IndentBlockOption PositionMask;
    public static IndentBlockOption IndentIfConditionOfAnchorToken;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAlignTokensOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private SyntaxNode _node;
    private List`1<AlignTokensOperation> _list;
    private NextAlignTokensOperationAction NextAction { get; }
    public NextAlignTokensOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<AlignTokensOperation> list);
    private NextAlignTokensOperationAction get_NextAction();
    public void Invoke();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextAnchorIndentationOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private SyntaxNode _node;
    private List`1<AnchorIndentationOperation> _list;
    private NextAnchorIndentationOperationAction NextAction { get; }
    public NextAnchorIndentationOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<AnchorIndentationOperation> list);
    private NextAnchorIndentationOperationAction get_NextAction();
    public void Invoke();
}
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustNewLinesOperation : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private NextGetAdjustNewLinesOperation NextOperation { get; }
    public NextGetAdjustNewLinesOperation(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index);
    private NextGetAdjustNewLinesOperation get_NextOperation();
    [NullableContextAttribute("2")]
public AdjustNewLinesOperation Invoke(SyntaxToken& previousToken, SyntaxToken& currentToken);
}
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextGetAdjustSpacesOperation : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private NextGetAdjustSpacesOperation NextOperation { get; }
    public NextGetAdjustSpacesOperation(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index);
    private NextGetAdjustSpacesOperation get_NextOperation();
    [NullableContextAttribute("2")]
public AdjustSpacesOperation Invoke(SyntaxToken& previousToken, SyntaxToken& currentToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextIndentBlockOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private SyntaxNode _node;
    private List`1<IndentBlockOperation> _list;
    private NextIndentBlockOperationAction NextAction { get; }
    public NextIndentBlockOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<IndentBlockOperation> list);
    private NextIndentBlockOperationAction get_NextAction();
    public void Invoke();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Formatting.Rules.NextSuppressOperationAction : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractFormattingRule> _formattingRules;
    private int _index;
    private SyntaxNode _node;
    private List`1<SuppressOperation> _list;
    private NextSuppressOperationAction NextAction { get; }
    public NextSuppressOperationAction(ImmutableArray`1<AbstractFormattingRule> formattingRules, int index, SyntaxNode node, List`1<SuppressOperation> list);
    private NextSuppressOperationAction get_NextAction();
    public void Invoke();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.NoOpFormattingRule : AbstractFormattingRule {
    [NullableAttribute("1")]
public static NoOpFormattingRule Instance;
    private static NoOpFormattingRule();
}
internal class Microsoft.CodeAnalysis.Formatting.Rules.SuppressOperation : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private SuppressOption <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <StartToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <EndToken>k__BackingField;
    public TextSpan TextSpan { get; }
    public SuppressOption Option { get; }
    public SyntaxToken StartToken { get; }
    public SyntaxToken EndToken { get; }
    internal SuppressOperation(SyntaxToken startToken, SyntaxToken endToken, TextSpan textSpan, SuppressOption option);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public SuppressOption get_Option();
    [CompilerGeneratedAttribute]
public SyntaxToken get_StartToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_EndToken();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Formatting.Rules.SuppressOption : Enum {
    public int value__;
    public static SuppressOption None;
    public static SuppressOption NoWrappingIfOnSingleLine;
    public static SuppressOption NoWrappingIfOnMultipleLine;
    public static SuppressOption NoWrapping;
    public static SuppressOption NoSpacingIfOnSingleLine;
    public static SuppressOption NoSpacingIfOnMultipleLine;
    public static SuppressOption NoSpacing;
    public static SuppressOption IgnoreElasticWrapping;
    public static SuppressOption DisableFormatting;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Formatting.StringBuilderPool : object {
    public static StringBuilder Allocate();
    public static void Free(StringBuilder builder);
    public static string ReturnAndFree(StringBuilder builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.SuppressIntervalIntrospector : ValueType {
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetStart(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressSpacingData>.GetLength(SuppressSpacingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetStart(SuppressWrappingData value);
    private sealed virtual override int Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector<Microsoft.CodeAnalysis.Formatting.SuppressWrappingData>.GetLength(SuppressWrappingData value);
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressSpacingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    public TextSpan TextSpan { get; }
    public SuppressSpacingData(TextSpan textSpan);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
}
internal class Microsoft.CodeAnalysis.Formatting.SuppressWrappingData : object {
    [CompilerGeneratedAttribute]
private TextSpan <TextSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreElastic>k__BackingField;
    public TextSpan TextSpan { get; }
    public bool IgnoreElastic { get; }
    public SuppressWrappingData(TextSpan textSpan, bool ignoreElastic);
    [CompilerGeneratedAttribute]
public TextSpan get_TextSpan();
    [CompilerGeneratedAttribute]
public bool get_IgnoreElastic();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptions : object {
    [CompilerGeneratedAttribute]
private CommonOptions <Common>k__BackingField;
    [DataMemberAttribute]
public CommonOptions Common { get; public set; }
    public bool UseTabs { get; }
    public int TabSize { get; }
    public int IndentationSize { get; }
    public LineFormattingOptions LineFormatting { get; }
    public string NewLine { get; }
    public bool SeparateImportDirectiveGroups { get; }
    public AccessibilityModifiersRequired AccessibilityModifiersRequired { get; }
    [CompilerGeneratedAttribute]
public CommonOptions get_Common();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Common(CommonOptions value);
    public abstract virtual SyntaxFormattingOptions With(LineFormattingOptions lineFormatting);
    public bool get_UseTabs();
    public int get_TabSize();
    public int get_IndentationSize();
    public LineFormattingOptions get_LineFormatting();
    public string get_NewLine();
    public bool get_SeparateImportDirectiveGroups();
    public AccessibilityModifiersRequired get_AccessibilityModifiersRequired();
    public static SyntaxFormattingOptions GetDefault(LanguageServices languageServices);
}
internal interface Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProviders : object {
    [ExtensionAttribute]
public static CommonOptions GetCommonSyntaxFormattingOptions(AnalyzerConfigOptions options, CommonOptions fallbackOptions);
    [ExtensionAttribute]
public static SyntaxFormattingOptions GetSyntaxFormattingOptions(AnalyzerConfigOptions options, SyntaxFormattingOptions fallbackOptions, LanguageServices languageServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProviders/<GetSyntaxFormattingOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxFormattingOptions> GetSyntaxFormattingOptionsAsync(Document document, SyntaxFormattingOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.SyntaxFormattingOptionsProviders/<GetSyntaxFormattingOptionsAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxFormattingOptions> GetSyntaxFormattingOptionsAsync(Document document, SyntaxFormattingOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.TokenData : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IndexInStream>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <Token>k__BackingField;
    [NullableAttribute("1")]
public TokenStream TokenStream { get; }
    public int IndexInStream { get; }
    public SyntaxToken Token { get; }
    [NullableContextAttribute("1")]
public TokenData(TokenStream tokenStream, int indexInStream, SyntaxToken token);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public int get_IndexInStream();
    [CompilerGeneratedAttribute]
public SyntaxToken get_Token();
    public TokenData GetPreviousTokenData();
    public TokenData GetNextTokenData();
    public sealed virtual bool Equals(TokenData x, TokenData y);
    public sealed virtual int GetHashCode(TokenData obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(TokenData other);
    public sealed virtual int Compare(TokenData x, TokenData y);
    public sealed virtual int CompareTo(TokenData other);
    [NullableContextAttribute("1")]
private static int Index(IEnumerable`1<SyntaxToken> tokens, SyntaxToken token);
    public static bool op_LessThan(TokenData left, TokenData right);
    public static bool op_GreaterThan(TokenData left, TokenData right);
    public static bool op_Equality(TokenData left, TokenData right);
    public static bool op_Inequality(TokenData left, TokenData right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Formatting.TokenPairWithOperations : ValueType {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private TokenStream <TokenStream>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustSpacesOperation <SpaceOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private AdjustNewLinesOperation <LineOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PairIndex>k__BackingField;
    [NullableAttribute("1")]
public TokenStream TokenStream { get; }
    public AdjustSpacesOperation SpaceOperation { get; }
    public AdjustNewLinesOperation LineOperation { get; }
    public int PairIndex { get; }
    public SyntaxToken Token1 { get; }
    public SyntaxToken Token2 { get; }
    public TokenPairWithOperations(TokenStream tokenStream, int tokenPairIndex, AdjustSpacesOperation spaceOperations, AdjustNewLinesOperation lineOperations);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public TokenStream get_TokenStream();
    [CompilerGeneratedAttribute]
public AdjustSpacesOperation get_SpaceOperation();
    [CompilerGeneratedAttribute]
public AdjustNewLinesOperation get_LineOperation();
    [CompilerGeneratedAttribute]
public int get_PairIndex();
    public SyntaxToken get_Token1();
    public SyntaxToken get_Token2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Formatting.TokenStream : object {
    private static int MagicTextLengthToTokensRatio;
    private SegmentedList`1<SyntaxToken> _tokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private SegmentedArray`1<TriviaData> _cachedOriginalTriviaInfo;
    private TreeData _treeData;
    private SyntaxFormattingOptions _options;
    private Changes _changes;
    private AbstractTriviaDataFactory _factory;
    private Func`3<TokenData, TokenData, TriviaData> _getTriviaData;
    private Func`3<TokenData, TokenData, TriviaData> _getOriginalTriviaData;
    public bool FormatBeginningOfTree { get; }
    public bool FormatEndOfTree { get; }
    public bool IsFormattingWholeDocument { get; }
    public TokenData FirstTokenInStream { get; }
    public TokenData LastTokenInStream { get; }
    public int TokenCount { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> TokenIterator { get; }
    public TokenStream(TreeData treeData, SyntaxFormattingOptions options, TextSpan spanToFormat, AbstractTriviaDataFactory factory);
    [ConditionalAttribute("DEBUG")]
private void DebugCheckTokenOrder();
    public bool get_FormatBeginningOfTree();
    public bool get_FormatEndOfTree();
    public bool get_IsFormattingWholeDocument();
    public TokenData get_FirstTokenInStream();
    public TokenData get_LastTokenInStream();
    public int get_TokenCount();
    public SyntaxToken GetToken(int index);
    public TokenData GetTokenData(SyntaxToken token);
    public TokenData GetPreviousTokenData(TokenData tokenData);
    public TokenData GetNextTokenData(TokenData tokenData);
    internal SyntaxToken FirstTokenOfBaseTokenLine(SyntaxToken token);
    public bool TwoTokensOriginallyOnSameLine(SyntaxToken token1, SyntaxToken token2);
    public bool TwoTokensOnSameLine(SyntaxToken token1, SyntaxToken token2);
    private bool TwoTokensOnSameLineWorker(SyntaxToken token1, SyntaxToken token2, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void ApplyBeginningOfTreeChange(TriviaData data);
    public void ApplyEndOfTreeChange(TriviaData data);
    public void ApplyChange(int pairIndex, TriviaData data);
    public int GetCurrentColumn(SyntaxToken token);
    public int GetCurrentColumn(TokenData tokenData);
    public int GetOriginalColumn(SyntaxToken token);
    private int GetColumn(TokenData tokenData, Func`3<TokenData, TokenData, TriviaData> triviaDataGetter);
    public void GetTokenLength(SyntaxToken token, Int32& length, Boolean& onMultipleLines);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Formatting.TokenStream/<GetTriviaDataWithTokenPair>d__40")]
public IEnumerable`1<ValueTuple`2<ValueTuple`2<SyntaxToken, SyntaxToken>, TriviaData>> GetTriviaDataWithTokenPair(CancellationToken cancellationToken);
    public TriviaData GetTriviaData(TokenData token1, TokenData token2);
    private TriviaData GetOriginalTriviaData(TokenData token1, TokenData token2);
    public TriviaData GetTriviaDataAtBeginningOfTree();
    public TriviaData GetTriviaDataAtEndOfTree();
    public TriviaData GetTriviaData(int pairIndex);
    private TriviaData GetOriginalTriviaData(int pairIndex);
    public bool IsFirstTokenOnLine(SyntaxToken token);
    private bool IsFirstTokenOnLine(TokenData tokenData1, TokenData tokenData2);
    private int GetTokenIndexInStream(SyntaxToken token);
    public IEnumerable`1<ValueTuple`3<int, SyntaxToken, SyntaxToken>> get_TokenIterator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.TreeData : object {
    private SyntaxNode _root;
    private SyntaxToken _firstToken;
    private SyntaxToken _lastToken;
    public SyntaxNode Root { get; }
    public int StartPosition { get; }
    public int EndPosition { get; }
    public TreeData(SyntaxNode root);
    public static TreeData Create(SyntaxNode root);
    public static TreeData Create(SyntaxTrivia trivia, int initialColumn);
    public abstract virtual string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public abstract virtual int GetOriginalColumn(int tabSize, SyntaxToken token);
    public SyntaxNode get_Root();
    public bool IsFirstToken(SyntaxToken token);
    public bool IsLastToken(SyntaxToken token);
    public int get_StartPosition();
    public int get_EndPosition();
    public IEnumerable`1<SyntaxToken> GetApplicableTokens(TextSpan textSpan);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaData : object {
    protected static int TokenPairIndexNotNeeded;
    private string _language;
    [CompilerGeneratedAttribute]
private SyntaxFormattingOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineBreaks>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Spaces>k__BackingField;
    protected SyntaxFormattingOptions Options { get; }
    protected string Language { get; }
    public int LineBreaks { get; protected set; }
    public int Spaces { get; protected set; }
    public bool SecondTokenIsFirstTokenOnLine { get; }
    public bool TreatAsElastic { get; }
    public bool IsWhitespaceOnlyTrivia { get; }
    public bool ContainsChanges { get; }
    protected TriviaData(SyntaxFormattingOptions options, string language);
    [CompilerGeneratedAttribute]
protected SyntaxFormattingOptions get_Options();
    protected string get_Language();
    [CompilerGeneratedAttribute]
public int get_LineBreaks();
    [CompilerGeneratedAttribute]
protected void set_LineBreaks(int value);
    [CompilerGeneratedAttribute]
public int get_Spaces();
    [CompilerGeneratedAttribute]
protected void set_Spaces(int value);
    public bool get_SecondTokenIsFirstTokenOnLine();
    public abstract virtual bool get_TreatAsElastic();
    public abstract virtual bool get_IsWhitespaceOnlyTrivia();
    public abstract virtual bool get_ContainsChanges();
    public abstract virtual IEnumerable`1<TextChange> GetTextChanges(TextSpan span);
    public abstract virtual TriviaData WithSpace(int space, FormattingContext context, ChainedFormattingRules formattingRules);
    public abstract virtual TriviaData WithLine(int line, int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual TriviaData WithIndentation(int indentation, FormattingContext context, ChainedFormattingRules formattingRules, CancellationToken cancellationToken);
    public abstract virtual void Format(FormattingContext context, ChainedFormattingRules formattingRules, Action`3<int, TokenStream, TriviaData> formattingResultApplier, CancellationToken cancellationToken, int tokenPairIndex);
}
internal abstract class Microsoft.CodeAnalysis.Formatting.TriviaDataWithList : TriviaData {
    [NullableContextAttribute("1")]
public TriviaDataWithList(SyntaxFormattingOptions options, string language);
    public abstract virtual SyntaxTriviaList GetTriviaList(CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Formatting.TriviaHelpers : object {
    public static SyntaxTriviaList CreateTriviaListFromTo(SyntaxTriviaList triviaList, int startIndex, int endIndex);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Formatting.TriviaList : ValueType {
    private SyntaxTriviaList _list1;
    private SyntaxTriviaList _list2;
    public int Count { get; }
    public SyntaxTrivia Item { get; }
    public TriviaList(SyntaxTriviaList list1, SyntaxTriviaList list2);
    public int get_Count();
    public SyntaxTrivia get_Item(int index);
    public Enumerator GetEnumerator();
}
internal abstract class Microsoft.CodeAnalysis.GeneratedCodeRecognition.AbstractGeneratedCodeRecognitionService : object {
    public sealed virtual bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.GeneratedCodeRecognition.AbstractGeneratedCodeRecognitionService/<IsGeneratedCodeAsync>d__1")]
public sealed virtual Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
    private static bool IsGeneratedCode(SyntaxTree syntaxTree, Document document, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.GeneratedCodeRecognition.IGeneratedCodeRecognitionService {
    public abstract virtual bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Host.AbstractPersistentStorage : object {
    [CompilerGeneratedAttribute]
private string <WorkingFolderPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SolutionFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DatabaseFile>k__BackingField;
    public string WorkingFolderPath { get; }
    public string SolutionFilePath { get; }
    public string DatabaseFile { get; }
    public string DatabaseDirectory { get; }
    protected AbstractPersistentStorage(string workingFolderPath, string solutionFilePath, string databaseFile);
    [CompilerGeneratedAttribute]
public string get_WorkingFolderPath();
    [CompilerGeneratedAttribute]
public string get_SolutionFilePath();
    [CompilerGeneratedAttribute]
public string get_DatabaseFile();
    public string get_DatabaseDirectory();
    public abstract virtual void Dispose();
    public abstract virtual ValueTask DisposeAsync();
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> ChecksumMatchesAsync(ProjectKey projectKey, Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> ChecksumMatchesAsync(DocumentKey documentKey, Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual Task`1<Stream> ReadStreamAsync(ProjectKey projectKey, Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected abstract virtual Task`1<Stream> ReadStreamAsync(DocumentKey documentKey, Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> WriteStreamAsync(ProjectKey projectKey, Project project, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    protected abstract virtual Task`1<bool> WriteStreamAsync(DocumentKey documentKey, Document document, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(ProjectKey projectKey, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(DocumentKey documentKey, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(ProjectKey projectKey, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(DocumentKey documentKey, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(ProjectKey projectKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(DocumentKey documentKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractSpanMappingService : object {
    public bool SupportsMappingImportDirectives { get; }
    public abstract virtual bool get_SupportsMappingImportDirectives();
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<string, TextChange>>> GetMappedTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<MappedSpanResult>> MapSpansAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
    protected static ImmutableArray`1<ValueTuple`2<string, TextChange>> MatchMappedSpansToTextChanges(ImmutableArray`1<TextChange> textChanges, ImmutableArray`1<MappedSpanResult> mappedSpanResults);
}
internal abstract class Microsoft.CodeAnalysis.Host.AbstractSyntaxTreeFactoryService : object {
    private Lazy`1<int> _minimumLengthForRecoverableTree;
    [CompilerGeneratedAttribute]
private SolutionServices <SolutionServices>k__BackingField;
    internal SolutionServices SolutionServices { get; }
    public AbstractSyntaxTreeFactoryService(SolutionServices services);
    [CompilerGeneratedAttribute]
internal SolutionServices get_SolutionServices();
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual ParseOptions GetDefaultParseOptionsWithLatestLanguageVersion();
    public abstract virtual bool OptionsDifferOnlyByPreprocessorDirectives(ParseOptions options1, ParseOptions options2);
    public abstract virtual ParseOptions TryParsePdbParseOptions(IReadOnlyDictionary`2<string, string> metadata);
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
    public virtual bool CanCreateRecoverableTree(SyntaxNode root);
    protected static SyntaxNode RecoverNode(SyntaxTree tree, TextSpan textSpan, int kind);
    [CompilerGeneratedAttribute]
private int <.ctor>b__6_0();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Host.AnalyzerAssemblyLoaderOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <ShadowCopy>k__BackingField;
    public bool ShadowCopy { get; }
    public AnalyzerAssemblyLoaderOptions(bool shadowCopy);
    [CompilerGeneratedAttribute]
public bool get_ShadowCopy();
}
[SharedAttribute]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IAnalyzerAssemblyLoaderProvider", "Default")]
internal class Microsoft.CodeAnalysis.Host.DefaultAnalyzerAssemblyLoaderService : object {
    [NullableAttribute("1")]
private DefaultAnalyzerAssemblyLoader _loader;
    [NullableAttribute("1")]
private ShadowCopyAnalyzerAssemblyLoader _shadowCopyLoader;
    [NullableContextAttribute("1")]
public IAnalyzerAssemblyLoader GetLoader(AnalyzerAssemblyLoaderOptions& options);
    private sealed virtual override IAnalyzerAssemblyLoader Microsoft.CodeAnalysis.Host.IAnalyzerAssemblyLoaderProvider.GetLoader(AnalyzerAssemblyLoaderOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IAnalyzerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DefaultAnalyzerService : object {
    private DefaultAnalyzerAssemblyLoader _loader;
    public sealed virtual IAnalyzerAssemblyLoader GetLoader();
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IPersistentStorageConfiguration", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DefaultPersistentStorageConfiguration : object {
    private static ImmutableArray`1<char> s_invalidPathChars;
    [NullableAttribute("1")]
private static string s_cacheDirectory;
    [NullableAttribute("1")]
private static string s_moduleFileName;
    public bool ThrowOnFailure { get; }
    private static DefaultPersistentStorageConfiguration();
    public sealed virtual bool get_ThrowOnFailure();
    [NullableContextAttribute("2")]
public sealed virtual string TryGetStorageLocation(SolutionKey solutionKey);
    [NullableContextAttribute("1")]
private static string SafeName(string fullPath);
    [NullableContextAttribute("1")]
private static string StripInvalidPathChars(string val);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IWorkspaceEventListenerService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DefaultWorkspaceEventListenerServiceFactory : object {
    private IEnumerable`1<Lazy`2<IEventListener, EventListenerMetadata>> _eventListeners;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public DefaultWorkspaceEventListenerServiceFactory(IEnumerable`1<Lazy`2<IEventListener, EventListenerMetadata>> eventListeners);
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.DirectMemoryAccessStreamReader : TextReaderWithLength {
    private Char* _position;
    private Char* _end;
    public DirectMemoryAccessStreamReader(Char* src, int length);
    public virtual int Peek();
    public virtual int Read();
    [NullableContextAttribute("1")]
public virtual int Read(Char[] buffer, int index, int count);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IDocumentationProviderService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.DocumentationProviderServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.DocumentPropertiesService : object {
    [NullableAttribute("1")]
public static DocumentPropertiesService Default;
    [NullableAttribute("2")]
public string DiagnosticsLspClientName { get; }
    private static DocumentPropertiesService();
    [NullableContextAttribute("2")]
public virtual string get_DiagnosticsLspClientName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.DynamicFileInfo : object {
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceCodeKind <SourceCodeKind>k__BackingField;
    [CompilerGeneratedAttribute]
private TextLoader <TextLoader>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DesignTimeOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentServiceProvider <DocumentServiceProvider>k__BackingField;
    public string FilePath { get; }
    public SourceCodeKind SourceCodeKind { get; }
    public TextLoader TextLoader { get; }
    public bool DesignTimeOnly { get; }
    public IDocumentServiceProvider DocumentServiceProvider { get; }
    public DynamicFileInfo(string filePath, SourceCodeKind sourceCodeKind, TextLoader textLoader, bool designTimeOnly, IDocumentServiceProvider documentServiceProvider);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public SourceCodeKind get_SourceCodeKind();
    [CompilerGeneratedAttribute]
public TextLoader get_TextLoader();
    [CompilerGeneratedAttribute]
public bool get_DesignTimeOnly();
    [CompilerGeneratedAttribute]
public IDocumentServiceProvider get_DocumentServiceProvider();
}
internal class Microsoft.CodeAnalysis.Host.EventListenerMetadata : WorkspaceKindMetadata {
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    public string Service { get; }
    public EventListenerMetadata(IDictionary`2<string, object> data);
    public EventListenerMetadata(string service, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public string get_Service();
}
internal class Microsoft.CodeAnalysis.Host.EventListenerTracker`1 : object {
    private HashSet`1<string> _eventListenerInitialized;
    private ImmutableArray`1<Lazy`2<IEventListener, EventListenerMetadata>> _eventListeners;
    public EventListenerTracker`1(IEnumerable`1<Lazy`2<IEventListener, EventListenerMetadata>> eventListeners, string kind);
    public void EnsureEventListener(Workspace workspace, TService serviceOpt);
    public static IEnumerable`1<IEventListener`1<TService>> GetListeners(Workspace workspace, IEnumerable`1<Lazy`2<IEventListener, EventListenerMetadata>> eventListeners);
    internal TestAccessor<TService> GetTestAccessor();
}
internal enum Microsoft.CodeAnalysis.Host.ExcerptMode : Enum {
    public int value__;
    public static ExcerptMode SingleLine;
    public static ExcerptMode Tooltip;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Host.ExcerptResult : ValueType {
    public SourceText Content;
    public TextSpan MappedSpan;
    public ImmutableArray`1<ClassifiedSpan> ClassifiedSpans;
    public Document Document;
    public TextSpan Span;
    public ExcerptResult(SourceText content, TextSpan mappedSpan, ImmutableArray`1<ClassifiedSpan> classifiedSpans, Document document, TextSpan span);
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Host.ExportEventListenerAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Service>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <WorkspaceKinds>k__BackingField;
    public string Service { get; }
    public IReadOnlyCollection`1<string> WorkspaceKinds { get; }
    public ExportEventListenerAttribute(string service, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public string get_Service();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_WorkspaceKinds();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Host.Extensions : object {
    [NullableAttribute("1")]
private static string RazorCSharpLspClientName;
    [ExtensionAttribute]
public static bool CanApplyChange(TextDocument document);
    [ExtensionAttribute]
public static bool CanApplyChange(TextDocumentState document);
    [ExtensionAttribute]
public static bool SupportsDiagnostics(TextDocument document);
    [ExtensionAttribute]
public static bool SupportsDiagnostics(TextDocumentState document);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsRazorDocument(TextDocument document);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsRazorDocument(TextDocumentState documentState);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.FrameworkAssemblyPathResolverFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Host.HostLanguageServices : object {
    [CompilerGeneratedAttribute]
private LanguageServices <LanguageServices>k__BackingField;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public LanguageServices LanguageServices { get; }
    [NullableAttribute("2")]
internal ICompilationFactoryService CompilationFactory { get; }
    [NullableAttribute("2")]
internal ISyntaxTreeFactoryService SyntaxTreeFactory { get; }
    public abstract virtual HostWorkspaceServices get_WorkspaceServices();
    public abstract virtual string get_Language();
    [CompilerGeneratedAttribute]
public LanguageServices get_LanguageServices();
    [NullableContextAttribute("0")]
public abstract virtual TLanguageService GetService();
    public TLanguageService GetRequiredService();
    [NullableContextAttribute("2")]
internal virtual ICompilationFactoryService get_CompilationFactory();
    [NullableContextAttribute("2")]
internal virtual ISyntaxTreeFactoryService get_SyntaxTreeFactory();
}
public abstract class Microsoft.CodeAnalysis.Host.HostServices : object {
    protected internal abstract virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Host.HostWorkspaceServices : object {
    [CompilerGeneratedAttribute]
private SolutionServices <SolutionServices>k__BackingField;
    public HostServices HostServices { get; }
    public Workspace Workspace { get; }
    internal SolutionServices SolutionServices { get; }
    [ObsoleteAttribute("Roslyn no longer exports a mechanism to perform persistence.", "True")]
public IPersistentStorageService PersistentStorage { get; }
    [ObsoleteAttribute("Roslyn no longer exports a mechanism to store arbitrary data in-memory.")]
public ITemporaryStorageService TemporaryStorage { get; }
    internal ITextFactoryService TextFactory { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public abstract virtual HostServices get_HostServices();
    public abstract virtual Workspace get_Workspace();
    [CompilerGeneratedAttribute]
internal SolutionServices get_SolutionServices();
    [NullableContextAttribute("0")]
public abstract virtual TWorkspaceService GetService();
    public TWorkspaceService GetRequiredService();
    public virtual IPersistentStorageService get_PersistentStorage();
    public virtual ITemporaryStorageService get_TemporaryStorage();
    internal virtual ITextFactoryService get_TextFactory();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    public abstract virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Host.HostWorkspaceServicesExtensions : object {
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(HostWorkspaceServices hostWorkspaceServices, string languageName);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(HostWorkspaceServices hostWorkspaceServices, string languageName);
    [ExtensionAttribute]
public static HostLanguageServices GetExtendedLanguageServices(HostWorkspaceServices hostWorkspaceServices, string languageName);
}
internal interface Microsoft.CodeAnalysis.Host.IAnalyzerAssemblyLoaderProvider {
    [NullableContextAttribute("1")]
public abstract virtual IAnalyzerAssemblyLoader GetLoader(AnalyzerAssemblyLoaderOptions& modreq(System.Runtime.InteropServices.InAttribute) options);
}
public interface Microsoft.CodeAnalysis.Host.IAnalyzerService {
    public abstract virtual IAnalyzerAssemblyLoader GetLoader();
}
internal interface Microsoft.CodeAnalysis.Host.ICachedObjectOwner {
    public object CachedObject { get; public set; }
    public abstract virtual object get_CachedObject();
    public abstract virtual void set_CachedObject(object value);
}
internal interface Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorage {
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(ProjectKey project, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> ChecksumMatchesAsync(DocumentKey document, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(ProjectKey project, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(DocumentKey document, string name, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(ProjectKey projectKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(DocumentKey documentKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IChecksummedPersistentStorageService {
    public abstract virtual ValueTask`1<IChecksummedPersistentStorage> GetStorageAsync(SolutionKey solutionKey, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ICommandLineParserService {
    public abstract virtual CommandLineArguments Parse(IEnumerable`1<string> arguments, string baseDirectory, bool isInteractive, string sdkDirectory);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.ICompilationFactoryService {
    public abstract virtual Compilation CreateCompilation(string assemblyName, CompilationOptions options);
    public abstract virtual Compilation CreateSubmissionCompilation(string assemblyName, CompilationOptions options, Type hostObjectType);
    public abstract virtual CompilationOptions GetDefaultCompilationOptions();
    public abstract virtual CompilationOptions TryParsePdbCompilationOptions(IReadOnlyDictionary`2<string, string> compilationOptionsMetadata);
    public abstract virtual GeneratorDriver CreateGeneratorDriver(ParseOptions parseOptions, ImmutableArray`1<ISourceGenerator> generators, AnalyzerConfigOptionsProvider optionsProvider, ImmutableArray`1<AdditionalText> additionalTexts);
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentationProviderService {
    public abstract virtual DocumentationProvider GetDocumentationProvider(string assemblyFullPath);
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentExcerptService {
    public abstract virtual Task`1<Nullable`1<ExcerptResult>> TryExcerptAsync(Document document, TextSpan span, ExcerptMode mode, ClassificationOptions classificationOptions, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentOperationService {
    public bool CanApplyChange { get; }
    public bool SupportDiagnostics { get; }
    public abstract virtual bool get_CanApplyChange();
    public abstract virtual bool get_SupportDiagnostics();
}
internal interface Microsoft.CodeAnalysis.Host.IDocumentService {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.IDocumentServiceProvider {
    public abstract virtual TService GetService();
}
internal interface Microsoft.CodeAnalysis.Host.IDynamicFileInfoProvider {
    public abstract virtual Task`1<DynamicFileInfo> GetDynamicFileInfoAsync(ProjectId projectId, string projectFilePath, string filePath, CancellationToken cancellationToken);
    public abstract virtual Task RemoveDynamicFileInfoAsync(ProjectId projectId, string projectFilePath, string filePath, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Updated(EventHandler`1<string> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Updated(EventHandler`1<string> value);
}
internal interface Microsoft.CodeAnalysis.Host.IEventListener {
}
internal interface Microsoft.CodeAnalysis.Host.IEventListener`1 {
    public abstract virtual void StartListening(Workspace workspace, TService serviceOpt);
}
internal interface Microsoft.CodeAnalysis.Host.IEventListenerStoppable {
    public abstract virtual void StopListening(Workspace workspace);
}
internal interface Microsoft.CodeAnalysis.Host.IFrameworkAssemblyPathResolver {
    [NullableContextAttribute("1")]
public abstract virtual string ResolveAssemblyPath(ProjectId projectId, string assemblyName, string fullyQualifiedName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.IHostWorkspaceProvider {
    public Workspace Workspace { get; }
    public abstract virtual Workspace get_Workspace();
}
public interface Microsoft.CodeAnalysis.Host.ILanguageService {
}
internal interface Microsoft.CodeAnalysis.Host.IMetadataService {
    public abstract virtual PortableExecutableReference GetReference(string resolvedPath, MetadataReferenceProperties properties);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.Host.IPersistentStorage {
    public abstract virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IPersistentStorageConfiguration {
    public bool ThrowOnFailure { get; }
    public abstract virtual bool get_ThrowOnFailure();
    [NullableContextAttribute("2")]
public abstract virtual string TryGetStorageLocation(SolutionKey solutionKey);
}
internal interface Microsoft.CodeAnalysis.Host.IPersistentStorageFaultInjector {
    public abstract virtual void OnNewConnection();
    public abstract virtual void OnFatalError(Exception ex);
}
[ObsoleteAttribute("Roslyn no longer exports a mechanism to perform persistence.", "True")]
public interface Microsoft.CodeAnalysis.Host.IPersistentStorageService {
    [NullableContextAttribute("1")]
[ObsoleteAttribute("Roslyn no longer exports a mechanism to perform persistence.", "True")]
public abstract virtual IPersistentStorage GetStorage(Solution solution);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheHostService {
    public int MinimumLengthForRecoverableTree { get; }
    public abstract virtual int get_MinimumLengthForRecoverableTree();
    [NullableContextAttribute("1")]
public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, object owner, T instance);
    [NullableContextAttribute("1")]
public abstract virtual T CacheObjectIfCachingEnabledForKey(ProjectId key, ICachedObjectOwner owner, T instance);
}
internal interface Microsoft.CodeAnalysis.Host.IProjectCacheService {
    [NullableContextAttribute("1")]
public abstract virtual IDisposable EnableCaching(ProjectId key);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.IRecoverableSyntaxTree {
    public string FilePath { get; }
    public bool ContainsDirectives { get; }
    public abstract virtual string get_FilePath();
    public abstract virtual bool get_ContainsDirectives();
    public abstract virtual SyntaxTree WithOptions(ParseOptions parseOptions);
}
internal interface Microsoft.CodeAnalysis.Host.IRecoverableSyntaxTree`1 {
    [NullableContextAttribute("1")]
public abstract virtual TRoot CloneNodeAsRoot(TRoot root);
}
internal interface Microsoft.CodeAnalysis.Host.ISolutionAnalyzerSetterWorkspaceService {
    public abstract virtual void SetAnalyzerReferences(ImmutableArray`1<AnalyzerReference> references);
}
internal interface Microsoft.CodeAnalysis.Host.ISpanMappingService {
    public bool SupportsMappingImportDirectives { get; }
    public abstract virtual bool get_SupportsMappingImportDirectives();
    public abstract virtual Task`1<ImmutableArray`1<ValueTuple`2<string, TextChange>>> GetMappedTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<MappedSpanResult>> MapSpansAsync(Document document, IEnumerable`1<TextSpan> spans, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.ISyntaxTreeFactoryService {
    public abstract virtual ParseOptions GetDefaultParseOptions();
    public abstract virtual ParseOptions GetDefaultParseOptionsWithLatestLanguageVersion();
    public abstract virtual ParseOptions TryParsePdbParseOptions(IReadOnlyDictionary`2<string, string> compilationOptionsMetadata);
    public abstract virtual bool OptionsDifferOnlyByPreprocessorDirectives(ParseOptions options1, ParseOptions options2);
    public abstract virtual SyntaxTree CreateSyntaxTree(string filePath, ParseOptions options, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxTree ParseSyntaxTree(string filePath, ParseOptions options, SourceText text, CancellationToken cancellationToken);
    public abstract virtual bool CanCreateRecoverableTree(SyntaxNode root);
    public abstract virtual SyntaxTree CreateRecoverableTree(ProjectId cacheKey, string filePath, ParseOptions options, ValueSource`1<TextAndVersion> text, Encoding encoding, SyntaxNode root);
    public abstract virtual SyntaxNode DeserializeNodeFrom(Stream stream, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.ITaskSchedulerProvider {
    public TaskScheduler CurrentContextScheduler { get; }
    public abstract virtual TaskScheduler get_CurrentContextScheduler();
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("API is no longer available")]
public interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService {
    public abstract virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public abstract virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStorageService2 {
    [NullableContextAttribute("1")]
public abstract virtual ITemporaryStreamStorageInternal AttachTemporaryStreamStorage(string storageName, long offset, long size);
    [NullableContextAttribute("1")]
public abstract virtual ITemporaryTextStorageInternal AttachTemporaryTextStorage(string storageName, long offset, long size, SourceHashAlgorithm checksumAlgorithm, Encoding encoding);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal {
    public abstract virtual ITemporaryStreamStorageInternal CreateTemporaryStreamStorage();
    public abstract virtual ITemporaryTextStorageInternal CreateTemporaryTextStorage();
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStorageWithName {
    public string Name { get; }
    public long Offset { get; }
    public long Size { get; }
    public abstract virtual string get_Name();
    public abstract virtual long get_Offset();
    public abstract virtual long get_Size();
}
[ObsoleteAttribute("Roslyn no longer exports a mechanism to store arbitrary data in-memory.")]
public interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorage {
    public abstract virtual Stream ReadStream(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteStream(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Host.ITemporaryStreamStorageExtensions : object {
    [ExtensionAttribute]
public static void WriteAllLines(ITemporaryStreamStorageInternal storage, ImmutableArray`1<string> values);
    [ExtensionAttribute]
public static ImmutableArray`1<string> ReadLines(ITemporaryStreamStorageInternal storage);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Host.ITemporaryStreamStorageExtensions/<EnumerateLines>d__2")]
private static IEnumerable`1<string> EnumerateLines(ITemporaryStreamStorageInternal storage);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryStreamStorageInternal {
    public abstract virtual Stream ReadStream(CancellationToken cancellationToken);
    public abstract virtual Task`1<Stream> ReadStreamAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteStream(Stream stream, CancellationToken cancellationToken);
    public abstract virtual Task WriteStreamAsync(Stream stream, CancellationToken cancellationToken);
}
[ObsoleteAttribute("Roslyn no longer exports a mechanism to store arbitrary data in-memory.")]
public interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorage {
    public abstract virtual SourceText ReadText(CancellationToken cancellationToken);
    public abstract virtual Task`1<SourceText> ReadTextAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteText(SourceText text, CancellationToken cancellationToken);
    public abstract virtual Task WriteTextAsync(SourceText text, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorageInternal {
    public abstract virtual SourceText ReadText(CancellationToken cancellationToken);
    public abstract virtual Task`1<SourceText> ReadTextAsync(CancellationToken cancellationToken);
    public abstract virtual void WriteText(SourceText text, CancellationToken cancellationToken);
    public abstract virtual Task WriteTextAsync(SourceText text, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.ITemporaryTextStorageWithName {
    public SourceHashAlgorithm ChecksumAlgorithm { get; }
    [NullableAttribute("2")]
public Encoding Encoding { get; }
    public abstract virtual SourceHashAlgorithm get_ChecksumAlgorithm();
    [NullableContextAttribute("2")]
public abstract virtual Encoding get_Encoding();
    public abstract virtual ImmutableArray`1<byte> GetChecksum();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.ITextFactoryService {
    public abstract virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    public abstract virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceAsynchronousOperationListenerProvider {
    [NullableContextAttribute("1")]
public abstract virtual IAsynchronousOperationListener GetListener();
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceCacheService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_CacheFlushRequested(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_CacheFlushRequested(EventHandler value);
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceConfigurationService {
    public WorkspaceConfigurationOptions Options { get; }
    public abstract virtual WorkspaceConfigurationOptions get_Options();
}
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceEventListenerService {
    public abstract virtual void EnsureListeners();
    public abstract virtual void Stop();
}
public interface Microsoft.CodeAnalysis.Host.IWorkspaceService {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Host.IWorkspaceStatusService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_StatusChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StatusChanged(EventHandler value);
    public abstract virtual Task WaitUntilFullyLoadedAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<bool> IsFullyLoadedAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Host.LanguageServices : object {
    private HostLanguageServices _services;
    public SolutionServices SolutionServices { get; }
    public string Language { get; }
    [ObsoleteAttribute("Do not call directly.  Use HostLanguageServices.ProjectServices to acquire an instance")]
internal LanguageServices(HostLanguageServices services);
    public SolutionServices get_SolutionServices();
    public string get_Language();
    [NullableContextAttribute("0")]
public TLanguageService GetService();
    public TLanguageService GetRequiredService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITemporaryStorageService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.LegacyTemporaryStorageService : object {
    public sealed virtual ITemporaryStreamStorage CreateTemporaryStreamStorage(CancellationToken cancellationToken);
    public sealed virtual ITemporaryTextStorage CreateTemporaryTextStorage(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Host.MappedSpanResult : ValueType {
    public string FilePath;
    public LinePositionSpan LinePositionSpan;
    public TextSpan Span;
    public bool IsDefault { get; }
    public MappedSpanResult(string filePath, LinePositionSpan linePositionSpan, TextSpan span);
    public bool get_IsDefault();
}
internal class Microsoft.CodeAnalysis.Host.Mef.CodeChangeProviderMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Languages>k__BackingField;
    public IEnumerable`1<string> Languages { get; }
    public CodeChangeProviderMetadata(IDictionary`2<string, object> data);
    public CodeChangeProviderMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before, String[] languages);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_Languages();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Host.Mef.ExportDynamicFileInfoProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Extensions>k__BackingField;
    public IEnumerable`1<string> Extensions { get; }
    public ExportDynamicFileInfoProviderAttribute(String[] extensions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Extensions();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportLanguageServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Language { get; }
    public string Layer { get; }
    public ExportLanguageServiceFactoryAttribute(Type type, string language, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
public class Microsoft.CodeAnalysis.Host.Mef.ExportWorkspaceServiceFactoryAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public ExportWorkspaceServiceFactoryAttribute(Type serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal class Microsoft.CodeAnalysis.Host.Mef.FileExtensionsMetadata : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Extensions>k__BackingField;
    public IEnumerable`1<string> Extensions { get; }
    public FileExtensionsMetadata(IDictionary`2<string, object> data);
    public FileExtensionsMetadata(String[] extensions);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Extensions();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguageMetadata {
    public string Language { get; }
    public abstract virtual string get_Language();
}
public interface Microsoft.CodeAnalysis.Host.Mef.ILanguageServiceFactory {
    public abstract virtual ILanguageService CreateLanguageService(HostLanguageServices languageServices);
}
internal interface Microsoft.CodeAnalysis.Host.Mef.ILanguagesMetadata {
    public IEnumerable`1<string> Languages { get; }
    public abstract virtual IEnumerable`1<string> get_Languages();
}
internal interface Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider {
    public abstract virtual IEnumerable`1<Lazy`2<TExtension, TMetadata>> GetExports();
    public abstract virtual IEnumerable`1<Lazy`1<TExtension>> GetExports();
}
public interface Microsoft.CodeAnalysis.Host.Mef.IWorkspaceServiceFactory {
    public abstract virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageMetadata : object {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public LanguageMetadata(IDictionary`2<string, object> data);
    public LanguageMetadata(string language);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
internal class Microsoft.CodeAnalysis.Host.Mef.LanguageServiceMetadata : LanguageMetadata {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, object> <Data>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public IReadOnlyDictionary`2<string, object> Data { get; }
    public LanguageServiceMetadata(IDictionary`2<string, object> data);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, object> get_Data();
}
internal static class Microsoft.CodeAnalysis.Host.Mef.MefConstruction : object {
    internal static string ImportingConstructorMessage;
    internal static string FactoryMethodMessage;
}
public class Microsoft.CodeAnalysis.Host.Mef.MefHostServices : HostServices {
    private static CreationHook s_creationHook;
    private CompositionContext _compositionContext;
    private static MefHostServices s_defaultHost;
    private static ImmutableArray`1<Assembly> s_defaultAssemblies;
    private static String[] s_defaultAssemblyNames;
    public static MefHostServices DefaultHost { get; }
    public static ImmutableArray`1<Assembly> DefaultAssemblies { get; }
    public MefHostServices(CompositionContext compositionContext);
    private static MefHostServices();
    public static MefHostServices Create(CompositionContext compositionContext);
    public static MefHostServices Create(IEnumerable`1<Assembly> assemblies);
    protected internal virtual HostWorkspaceServices CreateWorkspaceServices(Workspace workspace);
    private sealed virtual override IEnumerable`1<Lazy`1<TExtension>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    private sealed virtual override IEnumerable`1<Lazy`2<TExtension, TMetadata>> Microsoft.CodeAnalysis.Host.Mef.IMefHostExportProvider.GetExports();
    public static MefHostServices get_DefaultHost();
    public static ImmutableArray`1<Assembly> get_DefaultAssemblies();
    internal static bool IsDefaultAssembly(Assembly assembly);
    private static ImmutableArray`1<Assembly> LoadDefaultAssemblies();
}
internal static class Microsoft.CodeAnalysis.Host.Mef.MefHostServicesHelpers : object {
    public static ImmutableArray`1<Assembly> LoadNearbyAssemblies(IEnumerable`1<string> assemblyNames);
    private static Assembly TryLoadNearbyAssembly(string assemblySimpleName);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefLanguageServices : HostLanguageServices {
    private MefWorkspaceServices _workspaceServices;
    private string _language;
    private ImmutableArray`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<ILanguageService, LanguageServiceMetadata>> _serviceMap;
    public HostWorkspaceServices WorkspaceServices { get; }
    public string Language { get; }
    public bool HasServices { get; }
    public MefLanguageServices(MefWorkspaceServices workspaceServices, string language);
    public virtual HostWorkspaceServices get_WorkspaceServices();
    public virtual string get_Language();
    public bool get_HasServices();
    public virtual TLanguageService GetService();
    internal bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<ILanguageService, LanguageServiceMetadata> PickLanguageService(IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services);
    private static bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<ILanguageService, LanguageServiceMetadata>> services, Lazy`2& service);
    [CompilerGeneratedAttribute]
private Lazy`2<ILanguageService, LanguageServiceMetadata> <TryGetService>b__12_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices : HostWorkspaceServices {
    private IMefHostExportProvider _exportProvider;
    private Workspace _workspace;
    private ImmutableArray`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _services;
    private ImmutableDictionary`2<Type, Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> _serviceMap;
    private ImmutableDictionary`2<string, MefLanguageServices> _languageServicesMap;
    private IEnumerable`1<string> _languages;
    public HostServices HostServices { get; }
    internal IMefHostExportProvider HostExportProvider { get; }
    internal string WorkspaceKind { get; }
    public Workspace Workspace { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    public MefWorkspaceServices(IMefHostExportProvider host, Workspace workspace);
    public virtual HostServices get_HostServices();
    internal IMefHostExportProvider get_HostExportProvider();
    internal string get_WorkspaceKind();
    public virtual Workspace get_Workspace();
    public virtual TWorkspaceService GetService();
    private bool TryGetService(Type serviceType, Lazy`2& service);
    private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> PickWorkspaceService(IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services);
    private static bool TryGetServiceByLayer(string layer, IEnumerable`1<Lazy`2<IWorkspaceService, WorkspaceServiceMetadata>> services, Lazy`2& service);
    private IEnumerable`1<string> GetSupportedLanguages();
    public virtual IEnumerable`1<string> get_SupportedLanguages();
    public virtual bool IsSupported(string languageName);
    public virtual HostLanguageServices GetLanguageServices(string languageName);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Host.Mef.MefWorkspaceServices/<FindLanguageServices>d__24`1")]
public virtual IEnumerable`1<TLanguageService> FindLanguageServices(MetadataFilter filter);
    internal bool TryGetLanguageServices(string languageName, MefLanguageServices& languageServices);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <.ctor>b__5_0(Lazy`2<IWorkspaceServiceFactory, WorkspaceServiceMetadata> lz);
    [CompilerGeneratedAttribute]
private Lazy`2<IWorkspaceService, WorkspaceServiceMetadata> <TryGetService>b__15_0(Type svctype);
}
internal class Microsoft.CodeAnalysis.Host.Mef.OrderableLanguageMetadata : OrderableMetadata {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public string Language { get; }
    public OrderableLanguageMetadata(IDictionary`2<string, object> data);
    public OrderableLanguageMetadata(string name, string language, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Language();
}
public static class Microsoft.CodeAnalysis.Host.Mef.ServiceLayer : object {
    internal static string Test;
    public static string Host;
    public static string Editor;
    public static string Desktop;
    public static string Default;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.Mef.WorkspaceKindMetadata : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <WorkspaceKinds>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IReadOnlyCollection`1<string> WorkspaceKinds { get; }
    public WorkspaceKindMetadata(IDictionary`2<string, object> data);
    public WorkspaceKindMetadata(String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_WorkspaceKinds();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CodeAnalysis.Host.Mef.WorkspaceServiceMetadata : object {
    [CompilerGeneratedAttribute]
private string <ServiceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Layer>k__BackingField;
    public string ServiceType { get; }
    public string Layer { get; }
    public WorkspaceServiceMetadata(Type serviceType, string layer);
    public WorkspaceServiceMetadata(IDictionary`2<string, object> data);
    public WorkspaceServiceMetadata(string serviceType, string layer);
    [CompilerGeneratedAttribute]
public string get_ServiceType();
    [CompilerGeneratedAttribute]
public string get_Layer();
}
internal class Microsoft.CodeAnalysis.Host.MetadataReferenceCache : object {
    private ImmutableDictionary`2<string, ReferenceSet> _referenceSets;
    private Func`3<string, MetadataReferenceProperties, MetadataReference> _createReference;
    public MetadataReferenceCache(Func`3<string, MetadataReferenceProperties, MetadataReference> createReference);
    public MetadataReference GetReference(string path, MetadataReferenceProperties properties);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IMetadataService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.MetadataServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.NoOpPersistentStorage : object {
    private static IChecksummedPersistentStorage Instance;
    private static NoOpPersistentStorage();
    public static IChecksummedPersistentStorage GetOrThrow(bool throwOnFailure);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(ProjectKey project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> ChecksumMatchesAsync(DocumentKey document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(string name, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(ProjectKey project, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<Stream> ReadStreamAsync(DocumentKey document, string name, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Project project, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(Document document, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(ProjectKey projectKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> WriteStreamAsync(DocumentKey documentKey, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Host.NoOpPersistentStorageService : object {
    [NullableAttribute("1")]
private static IChecksummedPersistentStorageService Instance;
    private static NoOpPersistentStorageService();
    [NullableContextAttribute("1")]
public static IChecksummedPersistentStorageService GetOrThrow(IPersistentStorageConfiguration configuration);
    public sealed virtual ValueTask`1<IChecksummedPersistentStorage> GetStorageAsync(SolutionKey solutionKey, CancellationToken cancellationToken);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.Host.IProjectCacheService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.ProjectCacheServiceFactory : object {
    public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Host.SolutionServices : object {
    private HostWorkspaceServices _services;
    internal IMefHostExportProvider ExportProvider { get; }
    public IEnumerable`1<string> SupportedLanguages { get; }
    [ObsoleteAttribute("Do not call directly.  Use HostWorkspaceServices.SolutionServices to acquire an instance")]
internal SolutionServices(HostWorkspaceServices services);
    internal IMefHostExportProvider get_ExportProvider();
    [NullableContextAttribute("0")]
public TWorkspaceService GetService();
    public TWorkspaceService GetRequiredService();
    public IEnumerable`1<string> get_SupportedLanguages();
    public bool IsSupported(string languageName);
    public LanguageServices GetLanguageServices(string languageName);
    public TLanguageService GetRequiredLanguageService(string language);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITaskSchedulerProvider", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.TaskSchedulerProvider : object {
    [NullableAttribute("1")]
public TaskScheduler CurrentContextScheduler { get; }
    [NullableContextAttribute("1")]
public sealed virtual TaskScheduler get_CurrentContextScheduler();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Host.TemporaryStorageService : object {
    private static long SingleFileThreshold;
    private static long MultiFileBlockSize;
    [NullableAttribute("2")]
private IWorkspaceThreadingService _workspaceThreadingService;
    private ITextFactoryService _textFactory;
    private object _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference<MemoryMappedFile> _weakFileReference;
    [NullableAttribute("2")]
private string _name;
    private long _fileSize;
    private long _offset;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
private TemporaryStorageService(IWorkspaceThreadingService workspaceThreadingService, ITextFactoryService textFactory);
    public sealed virtual ITemporaryTextStorageInternal CreateTemporaryTextStorage();
    public sealed virtual ITemporaryTextStorageInternal AttachTemporaryTextStorage(string storageName, long offset, long size, SourceHashAlgorithm checksumAlgorithm, Encoding encoding);
    private sealed virtual override ITemporaryStreamStorageInternal Microsoft.CodeAnalysis.Host.ITemporaryStorageServiceInternal.CreateTemporaryStreamStorage();
    internal TemporaryStreamStorage CreateTemporaryStreamStorage();
    public sealed virtual ITemporaryStreamStorageInternal AttachTemporaryStreamStorage(string storageName, long offset, long size);
    private MemoryMappedInfo CreateTemporaryStorage(long size);
    public static string CreateUniqueName(long size);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.ITextFactoryService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.TextFactoryService : object {
    [NullableContextAttribute("1")]
public sealed virtual SourceText CreateText(Stream stream, Encoding defaultEncoding, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual SourceText CreateText(TextReader reader, Encoding encoding, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1 : ValueSource`1<T> {
    [NullableAttribute("2")]
private SemaphoreSlim _lazyGate;
    private bool _saved;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<T> _weakReference;
    private ValueSource`1<T> _recoverySource;
    private static Task s_latestTask;
    private static NonReentrantLock s_taskGuard;
    private SemaphoreSlim Gate { get; }
    public WeaklyCachedRecoverableValueSource`1(ValueSource`1<T> initialValue);
    public WeaklyCachedRecoverableValueSource`1(WeaklyCachedRecoverableValueSource`1<T> savedSource);
    private static WeaklyCachedRecoverableValueSource`1();
    protected abstract virtual Task SaveAsync(T instance, CancellationToken cancellationToken);
    protected abstract virtual Task`1<T> RecoverAsync(CancellationToken cancellationToken);
    protected abstract virtual T Recover(CancellationToken cancellationToken);
    private SemaphoreSlim get_Gate();
    [NullableContextAttribute("2")]
public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.WeaklyCachedRecoverableValueSource`1/<GetValueAsync>d__15")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    private void ResetRecoverySource(Task saveTask, T instance);
    private Task EnsureInstanceIsSavedAsync(T instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Host.WeaklyCachedValueSource`1 : ValueSource`1<T> {
    [NullableAttribute("2")]
private SemaphoreSlim _lazyGate;
    private ValueSource`1<T> _source;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<T> _weakReference;
    private SemaphoreSlim Gate { get; }
    public WeaklyCachedValueSource`1(ValueSource`1<T> source);
    private SemaphoreSlim get_Gate();
    [NullableContextAttribute("2")]
public virtual bool TryGetValue(T& value);
    public virtual T GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Host.WeaklyCachedValueSource`1/<GetValueAsync>d__8")]
public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Host.WellKnownEventListeners : object {
    public static string Workspace;
    public static string DiagnosticService;
    public static string TaskListProvider;
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IWorkspaceAsynchronousOperationListenerProvider", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.WorkspaceAsynchronousOperationListenerProvider : object {
    [NullableAttribute("1")]
private IAsynchronousOperationListener _listener;
    [NullableContextAttribute("1")]
[ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public WorkspaceAsynchronousOperationListenerProvider(IAsynchronousOperationListenerProvider listenerProvider);
    [NullableContextAttribute("1")]
public sealed virtual IAsynchronousOperationListener GetListener();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Host.WorkspaceConfigurationOptions : ValueType {
    [CompilerGeneratedAttribute]
private StorageDatabase <CacheStorage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableRecoverableTrees>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableProjectCacheService>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableOpeningSourceGeneratedFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableCloneWhenProducingSkeletonReferences>k__BackingField;
    public static WorkspaceConfigurationOptions Default;
    public static WorkspaceConfigurationOptions RemoteDefault;
    [DataMemberAttribute]
public StorageDatabase CacheStorage { get; public set; }
    [DataMemberAttribute]
public bool DisableRecoverableTrees { get; public set; }
    [DataMemberAttribute]
public bool DisableProjectCacheService { get; public set; }
    [DataMemberAttribute]
public bool EnableOpeningSourceGeneratedFiles { get; public set; }
    [DataMemberAttribute]
public bool DisableCloneWhenProducingSkeletonReferences { get; public set; }
    public WorkspaceConfigurationOptions(StorageDatabase CacheStorage, bool DisableRecoverableTrees, bool DisableProjectCacheService, bool EnableOpeningSourceGeneratedFiles, bool DisableCloneWhenProducingSkeletonReferences);
    private static WorkspaceConfigurationOptions();
    [CompilerGeneratedAttribute]
public StorageDatabase get_CacheStorage();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CacheStorage(StorageDatabase value);
    [CompilerGeneratedAttribute]
public bool get_DisableRecoverableTrees();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableRecoverableTrees(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableProjectCacheService();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableProjectCacheService(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableOpeningSourceGeneratedFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_EnableOpeningSourceGeneratedFiles(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableCloneWhenProducingSkeletonReferences();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DisableCloneWhenProducingSkeletonReferences(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(WorkspaceConfigurationOptions left, WorkspaceConfigurationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(WorkspaceConfigurationOptions left, WorkspaceConfigurationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(WorkspaceConfigurationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(StorageDatabase& CacheStorage, Boolean& DisableRecoverableTrees, Boolean& DisableProjectCacheService, Boolean& EnableOpeningSourceGeneratedFiles, Boolean& DisableCloneWhenProducingSkeletonReferences);
}
internal class Microsoft.CodeAnalysis.Host.WorkspaceMetadataFileReferenceResolver : MetadataReferenceResolver {
    private IMetadataService _metadataService;
    internal RelativePathResolver PathResolver;
    public WorkspaceMetadataFileReferenceResolver(IMetadataService metadataService, RelativePathResolver pathResolver);
    public virtual ImmutableArray`1<PortableExecutableReference> ResolveReference(string reference, string baseFilePath, MetadataReferenceProperties properties);
    public sealed virtual bool Equals(WorkspaceMetadataFileReferenceResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Host.IWorkspaceStatusService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Host.WorkspaceStatusService : object {
    private sealed virtual override void Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.add_StatusChanged(EventHandler value);
    private sealed virtual override void Microsoft.CodeAnalysis.Host.IWorkspaceStatusService.remove_StatusChanged(EventHandler value);
    public sealed virtual Task WaitUntilFullyLoadedAsync(CancellationToken cancellationToken);
    public sealed virtual Task`1<bool> IsFullyLoadedAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.IChecksummedObject {
    public Checksum Checksum { get; }
    public abstract virtual Checksum get_Checksum();
}
internal interface Microsoft.CodeAnalysis.IDocumentTextDifferencingService {
    public abstract virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<TextChange>> GetTextChangesAsync(Document oldDocument, Document newDocument, TextDifferenceTypes preferredDifferenceType, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.ILinkedFileMergeConflictCommentAdditionService {
}
internal interface Microsoft.CodeAnalysis.IMergeConflictHandler {
    public abstract virtual IEnumerable`1<TextChange> CreateEdits(SourceText originalSourceText, IEnumerable`1<UnmergedDocumentChanges> unmergedChanges);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ImmutableArrayExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(IEnumerable`1<T> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutable(T[] items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrNull(T[] items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> AsImmutableOrEmpty(T[] items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<byte> ToImmutable(MemoryStream stream);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`2<TItem, TResult> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`3<TItem, TArg, TResult> map, TArg arg);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> items, Func`4<TItem, int, TArg, TResult> map, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(ImmutableArray`1<TItem> array, Func`2<TItem, bool> predicate, Func`2<TItem, TResult> selector);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<SelectAsArrayAsync>d__11`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(ImmutableArray`1<TItem> array, Func`3<TItem, CancellationToken, ValueTask`1<TResult>> selector, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(ImmutableArray`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<ImmutableArray`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, Func`3<T1, T2, TResult> map);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> ZipAsArray(ImmutableArray`1<T1> self, ImmutableArray`1<T2> other, TArg arg, Func`5<T1, T2, int, TArg, TResult> map);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("2")]
private static ImmutableArray`1<T> WhereAsArrayImpl(ImmutableArray`1<T> array, Func`2<T, bool> predicateWithoutArg, Func`3<T, TArg, bool> predicateWithArg, TArg arg);
    [ExtensionAttribute]
public static bool Any(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static bool All(ImmutableArray`1<T> array, Func`3<T, TArg, bool> predicate, TArg arg);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__20`1")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<AnyAsync>d__21`2")]
[ExtensionAttribute]
public static Task`1<bool> AnyAsync(ImmutableArray`1<T> array, Func`3<T, TArg, Task`1<bool>> predicateAsync, TArg arg);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ImmutableArrayExtensions/<FirstOrDefaultAsync>d__22`1")]
[ExtensionAttribute]
public static ValueTask`1<T> FirstOrDefaultAsync(ImmutableArray`1<T> array, Func`2<T, Task`1<bool>> predicateAsync);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue FirstOrDefault(ImmutableArray`1<TValue> array, Func`3<TValue, TArg, bool> predicate, TArg arg);
    [ExtensionAttribute]
public static ImmutableArray`1<TBase> Cast(ImmutableArray`1<TDerived> items);
    [ExtensionAttribute]
public static bool SetEquals(ImmutableArray`1<T> array1, ImmutableArray`1<T> array2, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(ImmutableArray`1<T> array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> NullToEmpty(Nullable`1<ImmutableArray`1<T>> array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> Distinct(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static bool HasAnyErrors(ImmutableArray`1<T> diagnostics);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> ConditionallyDeOrder(ImmutableArray`1<T> array);
    [ExtensionAttribute]
internal static ImmutableArray`1<TValue> Flatten(Dictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, IComparer`1<TValue> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, ImmutableArray`1<T> second, ImmutableArray`1<T> third, ImmutableArray`1<T> fourth, ImmutableArray`1<T> fifth);
    [ExtensionAttribute]
internal static ImmutableArray`1<T> Concat(ImmutableArray`1<T> first, T second);
    [ExtensionAttribute]
internal static bool HasDuplicates(ImmutableArray`1<T> array, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int Count(ImmutableArray`1<T> items, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static int Sum(ImmutableArray`1<T> items, Func`2<T, int> selector);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(ImmutableArray`1<T> items, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [ExtensionAttribute]
internal static Location FirstOrNone(ImmutableArray`1<Location> items);
    [ExtensionAttribute]
internal static bool SequenceEqual(ImmutableArray`1<TElement> array1, ImmutableArray`1<TElement> array2, TArg arg, Func`4<TElement, TElement, TArg, bool> predicate);
    [ExtensionAttribute]
internal static int IndexOf(ImmutableArray`1<T> array, T item, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
internal static bool IsSorted(ImmutableArray`1<T> array, IComparer`1<T> comparer);
    [ExtensionAttribute]
internal static int BinarySearch(ImmutableArray`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [ExtensionAttribute]
internal static int BinarySearch(ReadOnlySpan`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
    [ExtensionAttribute]
internal static int BinarySearch(ImmutableSegmentedList`1<TElement> array, TValue value, Func`3<TElement, TValue, int> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ImplementType.ImplementTypeGenerationOptions : ValueType {
    [CompilerGeneratedAttribute]
private ImplementTypeOptions <ImplementTypeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private CleanCodeGenerationOptionsProvider <FallbackOptions>k__BackingField;
    public ImplementTypeOptions ImplementTypeOptions { get; public set; }
    public CleanCodeGenerationOptionsProvider FallbackOptions { get; public set; }
    public ImplementTypeGenerationOptions(ImplementTypeOptions ImplementTypeOptions, CleanCodeGenerationOptionsProvider FallbackOptions);
    [CompilerGeneratedAttribute]
public ImplementTypeOptions get_ImplementTypeOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ImplementTypeOptions(ImplementTypeOptions value);
    [CompilerGeneratedAttribute]
public CleanCodeGenerationOptionsProvider get_FallbackOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FallbackOptions(CleanCodeGenerationOptionsProvider value);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ImplementTypeGenerationOptions left, ImplementTypeGenerationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ImplementTypeGenerationOptions left, ImplementTypeGenerationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImplementTypeGenerationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(ImplementTypeOptions& ImplementTypeOptions, CleanCodeGenerationOptionsProvider& FallbackOptions);
}
internal enum Microsoft.CodeAnalysis.ImplementType.ImplementTypeInsertionBehavior : Enum {
    public int value__;
    public static ImplementTypeInsertionBehavior WithOtherMembersOfTheSameKind;
    public static ImplementTypeInsertionBehavior AtTheEnd;
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.ImplementType.ImplementTypeOptions : ValueType {
    [CompilerGeneratedAttribute]
private ImplementTypeInsertionBehavior <InsertionBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplementTypePropertyGenerationBehavior <PropertyGenerationBehavior>k__BackingField;
    public static ImplementTypeOptions Default;
    [DataMemberAttribute]
public ImplementTypeInsertionBehavior InsertionBehavior { get; public set; }
    [DataMemberAttribute]
public ImplementTypePropertyGenerationBehavior PropertyGenerationBehavior { get; public set; }
    private static ImplementTypeOptions();
    [CompilerGeneratedAttribute]
public ImplementTypeInsertionBehavior get_InsertionBehavior();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_InsertionBehavior(ImplementTypeInsertionBehavior value);
    [CompilerGeneratedAttribute]
public ImplementTypePropertyGenerationBehavior get_PropertyGenerationBehavior();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyGenerationBehavior(ImplementTypePropertyGenerationBehavior value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ImplementTypeOptions left, ImplementTypeOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ImplementTypeOptions left, ImplementTypeOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ImplementTypeOptions other);
}
internal enum Microsoft.CodeAnalysis.ImplementType.ImplementTypePropertyGenerationBehavior : Enum {
    public int value__;
    public static ImplementTypePropertyGenerationBehavior PreferThrowingProperties;
    public static ImplementTypePropertyGenerationBehavior PreferAutoProperties;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Indentation.AbstractIndentation`1 : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IHeaderFacts HeaderFacts { get; }
    protected ISyntaxFormatting SyntaxFormatting { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IHeaderFacts get_HeaderFacts();
    protected abstract virtual ISyntaxFormatting get_SyntaxFormatting();
    protected abstract virtual AbstractFormattingRule GetSpecializedIndentationFormattingRule(IndentStyle indentStyle);
    [NullableContextAttribute("0")]
protected abstract virtual bool ShouldUseTokenIndenter(Indenter<TSyntaxRoot> indenter, SyntaxToken& token);
    protected abstract virtual ISmartTokenFormatter CreateSmartTokenFormatter(TSyntaxRoot root, SourceText text, TextLine lineToBeIndented, IndentationOptions options, AbstractFormattingRule baseFormattingRule);
    [NullableContextAttribute("0")]
protected abstract virtual Nullable`1<IndentationResult> GetDesiredIndentationWorker(Indenter<TSyntaxRoot> indenter, Nullable`1<SyntaxToken> token, Nullable`1<SyntaxTrivia> trivia);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal abstract class Microsoft.CodeAnalysis.Indentation.AbstractIndentationService`1 : AbstractIndentation`1<TSyntaxRoot> {
    public sealed virtual IndentationResult GetIndentation(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
    private Indenter<TSyntaxRoot> GetIndenter(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Indentation.IIndentationService {
    public abstract virtual IndentationResult GetIndentation(ParsedDocument document, int lineNumber, IndentationOptions options, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Indentation.IIndentationServiceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetPreferredIndentation(SyntaxToken token, ParsedDocument document, IndentationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Indentation.IndentationOptions : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxFormattingOptions <FormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private AutoFormattingOptions <AutoFormattingOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IndentStyle <IndentStyle>k__BackingField;
    public static IndentStyle DefaultIndentStyle;
    [DataMemberAttribute]
public SyntaxFormattingOptions FormattingOptions { get; public set; }
    [DataMemberAttribute]
public AutoFormattingOptions AutoFormattingOptions { get; public set; }
    [DataMemberAttribute]
public IndentStyle IndentStyle { get; public set; }
    public IndentationOptions(SyntaxFormattingOptions FormattingOptions);
    [CompilerGeneratedAttribute]
public SyntaxFormattingOptions get_FormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FormattingOptions(SyntaxFormattingOptions value);
    [CompilerGeneratedAttribute]
public AutoFormattingOptions get_AutoFormattingOptions();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_AutoFormattingOptions(AutoFormattingOptions value);
    [CompilerGeneratedAttribute]
public IndentStyle get_IndentStyle();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IndentStyle(IndentStyle value);
    public static IndentationOptions GetDefault(LanguageServices languageServices);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(IndentationOptions left, IndentationOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(IndentationOptions left, IndentationOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(IndentationOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(SyntaxFormattingOptions& FormattingOptions);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Indentation.IndentationResult : ValueType {
    [CompilerGeneratedAttribute]
private int <BasePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int BasePosition { get; }
    public int Offset { get; }
    public IndentationResult(int basePosition, int offset);
    [CompilerGeneratedAttribute]
public int get_BasePosition();
    [CompilerGeneratedAttribute]
public int get_Offset();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Indentation.IndentationResultExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetIndentationString(IndentationResult indentationResult, SourceText sourceText, bool useTabs, int tabSize);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Indentation.ISmartTokenFormatter {
    public abstract virtual IList`1<TextChange> FormatToken(SyntaxToken token, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Internal.Log.AbstractLogAggregator`2 : object {
    private ConcurrentDictionary`2<object, TValue> _map;
    private Func`2<object, TValue> _createCounter;
    public bool IsEmpty { get; }
    protected abstract virtual TValue CreateCounter();
    public bool get_IsEmpty();
    public void Clear();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected TValue GetCounter(TKey key);
    protected bool TryGetCounter(TKey key, TValue& counter);
    [CompilerGeneratedAttribute]
private TValue <.ctor>b__2_0(object _);
}
internal class Microsoft.CodeAnalysis.Internal.Log.AggregateLogger : object {
    private ImmutableArray`1<ILogger> _loggers;
    private AggregateLogger(ImmutableArray`1<ILogger> loggers);
    public static AggregateLogger Create(ILogger[] loggers);
    public static ILogger AddOrReplace(ILogger newLogger, ILogger oldLogger, Func`2<ILogger, bool> predicate);
    public static ILogger Remove(ILogger logger, Func`2<ILogger, bool> predicate);
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Internal.Log.AnalyzerNameForTelemetry : object {
    [NullableContextAttribute("1")]
public static string ComputeSha256Hash(string name);
}
internal static class Microsoft.CodeAnalysis.Internal.Log.CorrelationIdFactory : object {
    private static int s_globalId;
    public static int GetNextId();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Internal.Log.CountLogAggregator`1 : AbstractLogAggregator`2<TKey, Counter<TKey>> {
    protected virtual Counter<TKey> CreateCounter();
    public void SetCount(TKey key, int count);
    public void IncreaseCount(TKey key);
    public void IncreaseCountBy(TKey key, int value);
    public int GetCount(TKey key);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogBlock : object {
    [NullableAttribute("1")]
public static EmptyLogBlock Instance;
    private static EmptyLogBlock();
    public sealed virtual void Dispose();
}
internal class Microsoft.CodeAnalysis.Internal.Log.EmptyLogger : object {
    public static EmptyLogger Instance;
    private static EmptyLogger();
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Internal.Log.EtwLogger : object {
    private Lazy`1<Func`2<FunctionId, bool>> _isEnabledPredicate;
    private RoslynEventSource _source;
    public EtwLogger(Func`2<FunctionId, bool> isEnabledPredicate);
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
    private bool IsVerbose();
    private string GetMessage(LogMessage logMessage);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.FunctionId : Enum {
    public int value__;
    public static FunctionId TestEvent_NotUsed;
    public static FunctionId WorkCoordinator_DocumentWorker_Enqueue;
    public static FunctionId WorkCoordinator_ProcessProjectAsync;
    public static FunctionId WorkCoordinator_ProcessDocumentAsync;
    public static FunctionId WorkCoordinator_SemanticChange_Enqueue;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromMember;
    public static FunctionId WorkCoordinator_SemanticChange_EnqueueFromType;
    public static FunctionId WorkCoordinator_SemanticChange_FullProjects;
    public static FunctionId WorkCoordinator_Project_Enqueue;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_LastItem;
    public static FunctionId WorkCoordinator_AsyncWorkItemQueue_FirstItem;
    public static FunctionId Diagnostics_SyntaxDiagnostic;
    public static FunctionId Diagnostics_SemanticDiagnostic;
    public static FunctionId Diagnostics_ProjectDiagnostic;
    public static FunctionId Diagnostics_DocumentReset;
    public static FunctionId Diagnostics_DocumentOpen;
    public static FunctionId Diagnostics_RemoveDocument;
    public static FunctionId Diagnostics_RemoveProject;
    public static FunctionId Diagnostics_DocumentClose;
    public static FunctionId Run_Environment;
    public static FunctionId Run_Environment_Options;
    public static FunctionId Tagger_AdornmentManager_OnLayoutChanged;
    public static FunctionId Tagger_AdornmentManager_UpdateInvalidSpans;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditorNow;
    public static FunctionId Tagger_BatchChangeNotifier_NotifyEditor;
    public static FunctionId Tagger_TagSource_RecomputeTags;
    public static FunctionId Tagger_TagSource_ProcessNewTags;
    public static FunctionId Tagger_SyntacticClassification_TagComputer_GetTags;
    public static FunctionId Tagger_SemanticClassification_TagProducer_ProduceTags;
    public static FunctionId Tagger_BraceHighlighting_TagProducer_ProduceTags;
    public static FunctionId Tagger_LineSeparator_TagProducer_ProduceTags;
    public static FunctionId Tagger_Outlining_TagProducer_ProduceTags;
    public static FunctionId Tagger_Highlighter_TagProducer_ProduceTags;
    public static FunctionId Tagger_ReferenceHighlighting_TagProducer_ProduceTags;
    public static FunctionId CaseCorrection_CaseCorrect;
    public static FunctionId CaseCorrection_ReplaceTokens;
    public static FunctionId CaseCorrection_AddReplacements;
    public static FunctionId CodeCleanup_CleanupAsync;
    public static FunctionId CodeCleanup_Cleanup;
    public static FunctionId CodeCleanup_IterateAllCodeCleanupProviders;
    public static FunctionId CodeCleanup_IterateOneCodeCleanup;
    public static FunctionId CommandHandler_GetCommandState;
    public static FunctionId CommandHandler_ExecuteHandlers;
    public static FunctionId CommandHandler_FormatCommand;
    public static FunctionId CommandHandler_CompleteStatement;
    public static FunctionId CommandHandler_ToggleBlockComment;
    public static FunctionId CommandHandler_ToggleLineComment;
    public static FunctionId Workspace_SourceText_GetChangeRanges;
    public static FunctionId Workspace_Recoverable_RecoverRootAsync;
    public static FunctionId Workspace_Recoverable_RecoverRoot;
    public static FunctionId Workspace_Recoverable_RecoverTextAsync;
    public static FunctionId Workspace_Recoverable_RecoverText;
    public static FunctionId Workspace_SkeletonAssembly_GetMetadataOnlyImage;
    public static FunctionId Workspace_SkeletonAssembly_EmitMetadataOnlyImage;
    public static FunctionId Workspace_Document_State_FullyParseSyntaxTree;
    public static FunctionId Workspace_Document_State_IncrementallyParseSyntaxTree;
    public static FunctionId Workspace_Document_GetSemanticModel;
    public static FunctionId Workspace_Document_GetSyntaxTree;
    public static FunctionId Workspace_Document_GetTextChanges;
    public static FunctionId Workspace_Project_GetCompilation;
    public static FunctionId Workspace_Project_CompilationTracker_BuildCompilationAsync;
    public static FunctionId Workspace_ApplyChanges;
    public static FunctionId Workspace_TryGetDocument;
    public static FunctionId Workspace_TryGetDocumentFromInProgressSolution;
    public static FunctionId Workspace_Solution_Info;
    public static FunctionId EndConstruct_DoStatement;
    public static FunctionId EndConstruct_XmlCData;
    public static FunctionId EndConstruct_XmlComment;
    public static FunctionId EndConstruct_XmlElement;
    public static FunctionId EndConstruct_XmlEmbeddedExpression;
    public static FunctionId EndConstruct_XmlProcessingInstruction;
    public static FunctionId FindReference_Rename;
    public static FunctionId FindReference_ChangeSignature;
    public static FunctionId FindReference;
    public static FunctionId FindReference_DetermineAllSymbolsAsync;
    public static FunctionId FindReference_CreateProjectMapAsync;
    public static FunctionId FindReference_CreateDocumentMapAsync;
    public static FunctionId FindReference_ProcessAsync;
    public static FunctionId FindReference_ProcessProjectAsync;
    public static FunctionId FindReference_ProcessDocumentAsync;
    public static FunctionId LineCommit_CommitRegion;
    public static FunctionId Formatting_TokenStreamConstruction;
    public static FunctionId Formatting_ContextInitialization;
    public static FunctionId Formatting_Format;
    public static FunctionId Formatting_ApplyResultToBuffer;
    public static FunctionId Formatting_IterateNodes;
    public static FunctionId Formatting_CollectIndentBlock;
    public static FunctionId Formatting_CollectSuppressOperation;
    public static FunctionId Formatting_CollectAlignOperation;
    public static FunctionId Formatting_CollectAnchorOperation;
    public static FunctionId Formatting_CollectTokenOperation;
    public static FunctionId Formatting_BuildContext;
    public static FunctionId Formatting_ApplySpaceAndLine;
    public static FunctionId Formatting_ApplyAnchorOperation;
    public static FunctionId Formatting_ApplyAlignOperation;
    public static FunctionId Formatting_AggregateCreateTextChanges;
    public static FunctionId Formatting_AggregateCreateFormattedRoot;
    public static FunctionId Formatting_CreateTextChanges;
    public static FunctionId Formatting_CreateFormattedRoot;
    public static FunctionId Formatting_Partitions;
    public static FunctionId SmartIndentation_Start;
    public static FunctionId SmartIndentation_OpenCurly;
    public static FunctionId SmartIndentation_CloseCurly;
    public static FunctionId Rename_InlineSession;
    public static FunctionId Rename_InlineSession_Session;
    public static FunctionId Rename_FindLinkedSpans;
    public static FunctionId Rename_GetSymbolRenameInfo;
    public static FunctionId Rename_OnTextBufferChanged;
    public static FunctionId Rename_ApplyReplacementText;
    public static FunctionId Rename_CommitCore;
    public static FunctionId Rename_CommitCoreWithPreview;
    public static FunctionId Rename_GetAsynchronousLocationsSource;
    public static FunctionId Rename_AllRenameLocations;
    public static FunctionId Rename_StartSearchingForSpansInAllOpenDocuments;
    public static FunctionId Rename_StartSearchingForSpansInOpenDocument;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocs;
    public static FunctionId Rename_CreateOpenTextBufferManagerForAllOpenDocument;
    public static FunctionId Rename_ReportSpan;
    public static FunctionId Rename_GetNoChangeConflictResolution;
    public static FunctionId Rename_Tracking_BufferChanged;
    public static FunctionId TPLTask_TaskScheduled;
    public static FunctionId TPLTask_TaskStarted;
    public static FunctionId TPLTask_TaskCompleted;
    public static FunctionId Get_QuickInfo_Async;
    public static FunctionId Completion_ModelComputer_DoInBackground;
    public static FunctionId Completion_ModelComputation_FilterModelInBackground;
    public static FunctionId Completion_ModelComputation_WaitForModel;
    public static FunctionId Completion_SymbolCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_KeywordCompletionProvider_GetItemsWorker;
    public static FunctionId Completion_SnippetCompletionProvider_GetItemsWorker_CSharp;
    public static FunctionId Completion_TypeImportCompletionProvider_GetCompletionItemsAsync;
    public static FunctionId Completion_ExtensionMethodImportCompletionProvider_GetCompletionItemsAsync;
    public static FunctionId SignatureHelp_ModelComputation_ComputeModelInBackground;
    public static FunctionId SignatureHelp_ModelComputation_UpdateModelInBackground;
    public static FunctionId Refactoring_CodeRefactoringService_GetRefactoringsAsync;
    public static FunctionId Refactoring_AddImport;
    public static FunctionId Refactoring_FullyQualify;
    public static FunctionId Refactoring_GenerateFromMembers_AddConstructorParametersFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateConstructorFromMembers;
    public static FunctionId Refactoring_GenerateFromMembers_GenerateEqualsAndGetHashCode;
    public static FunctionId Refactoring_GenerateMember_GenerateConstructor;
    public static FunctionId Refactoring_GenerateMember_GenerateDefaultConstructors;
    public static FunctionId Refactoring_GenerateMember_GenerateEnumMember;
    public static FunctionId Refactoring_GenerateMember_GenerateMethod;
    public static FunctionId Refactoring_GenerateMember_GenerateVariable;
    public static FunctionId Refactoring_ImplementAbstractClass;
    public static FunctionId Refactoring_ImplementInterface;
    public static FunctionId Refactoring_IntroduceVariable;
    public static FunctionId Refactoring_GenerateType;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_CSharp;
    public static FunctionId Refactoring_RemoveUnnecessaryImports_VisualBasic;
    public static FunctionId Snippet_OnBeforeInsertion;
    public static FunctionId Snippet_OnAfterInsertion;
    public static FunctionId Misc_NonReentrantLock_BlockingWait;
    public static FunctionId Misc_SaveEventsSink_OnBeforeSave;
    public static FunctionId TaskList_Refresh;
    public static FunctionId TaskList_NavigateTo;
    public static FunctionId WinformDesigner_GenerateXML;
    public static FunctionId NavigateTo_Search;
    public static FunctionId NavigationService_VSDocumentNavigationService_NavigateTo;
    public static FunctionId NavigationBar_ComputeModelAsync;
    public static FunctionId NavigationBar_ItemService_GetMembersInTypes_CSharp;
    public static FunctionId NavigationBar_ItemService_GetTypesInFile_CSharp;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForModel;
    public static FunctionId NavigationBar_UpdateDropDownsSynchronously_WaitForSelectedItemInfo;
    public static FunctionId EventHookup_Determine_If_Event_Hookup;
    public static FunctionId EventHookup_Generate_Handler;
    public static FunctionId EventHookup_Type_Char;
    public static FunctionId Cache_Created;
    public static FunctionId Cache_AddOrAccess;
    public static FunctionId Cache_Remove;
    public static FunctionId Cache_Evict;
    public static FunctionId Cache_EvictAll;
    public static FunctionId Cache_ItemRank;
    public static FunctionId TextStructureNavigator_GetExtentOfWord;
    public static FunctionId TextStructureNavigator_GetSpanOfEnclosing;
    public static FunctionId TextStructureNavigator_GetSpanOfFirstChild;
    public static FunctionId TextStructureNavigator_GetSpanOfNextSibling;
    public static FunctionId TextStructureNavigator_GetSpanOfPreviousSibling;
    public static FunctionId Debugging_LanguageDebugInfoService_GetDataTipSpanAndText;
    public static FunctionId Debugging_VsLanguageDebugInfo_ValidateBreakpointLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetProximityExpressions;
    public static FunctionId Debugging_VsLanguageDebugInfo_ResolveName;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetNameOfLocation;
    public static FunctionId Debugging_VsLanguageDebugInfo_GetDataTipText;
    public static FunctionId Debugging_EncSession;
    public static FunctionId Debugging_EncSession_EditSession;
    public static FunctionId Debugging_EncSession_EditSession_EmitDeltaErrorId;
    public static FunctionId Debugging_EncSession_EditSession_RudeEdit;
    public static FunctionId Simplifier_ReduceAsync;
    public static FunctionId Simplifier_ExpandNode;
    public static FunctionId Simplifier_ExpandToken;
    public static FunctionId ForegroundNotificationService_Processed;
    public static FunctionId ForegroundNotificationService_NotifyOnForeground;
    public static FunctionId BackgroundCompiler_BuildCompilationsAsync;
    public static FunctionId PersistenceService_ReadAsync;
    public static FunctionId PersistenceService_WriteAsync;
    public static FunctionId PersistenceService_ReadAsyncFailed;
    public static FunctionId PersistenceService_WriteAsyncFailed;
    public static FunctionId PersistenceService_Initialization;
    public static FunctionId TemporaryStorageServiceFactory_ReadText;
    public static FunctionId TemporaryStorageServiceFactory_WriteText;
    public static FunctionId TemporaryStorageServiceFactory_ReadStream;
    public static FunctionId TemporaryStorageServiceFactory_WriteStream;
    public static FunctionId PullMembersUpWarning_ChangeTargetToAbstract;
    public static FunctionId PullMembersUpWarning_ChangeOriginToPublic;
    public static FunctionId PullMembersUpWarning_ChangeOriginToNonStatic;
    public static FunctionId PullMembersUpWarning_UserProceedToFinish;
    public static FunctionId PullMembersUpWarning_UserGoBack;
    public static FunctionId SmartTags_RefreshSession;
    public static FunctionId SmartTags_SmartTagInitializeFixes;
    public static FunctionId SmartTags_ApplyQuickFix;
    public static FunctionId EditorTestApp_RefreshTask;
    public static FunctionId EditorTestApp_UpdateDiagnostics;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzers;
    public static FunctionId IncrementalAnalyzerProcessor_Analyzer;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzers;
    public static FunctionId IncrementalAnalyzerProcessor_ActiveFileAnalyzer;
    public static FunctionId IncrementalAnalyzerProcessor_Shutdown;
    public static FunctionId WorkCoordinatorRegistrationService_Register;
    public static FunctionId WorkCoordinatorRegistrationService_Unregister;
    public static FunctionId WorkCoordinatorRegistrationService_Reanalyze;
    public static FunctionId WorkCoordinator_PersistentStorageAdded;
    public static FunctionId WorkCoordinator_PersistentStorageRemoved;
    public static FunctionId WorkCoordinator_Shutdown;
    public static FunctionId DiagnosticAnalyzerService_Analyzers;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerCrash;
    public static FunctionId DiagnosticAnalyzerDriver_AnalyzerTypeCount;
    public static FunctionId StorageDatabase_Exceptions;
    public static FunctionId WorkCoordinator_ShutdownTimeout;
    public static FunctionId Diagnostics_HyperLink;
    public static FunctionId CodeFixes_FixAllOccurrencesSession;
    public static FunctionId CodeFixes_FixAllOccurrencesContext;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Diagnostics;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Fixes;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Document_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesComputation_Project_Merge;
    public static FunctionId CodeFixes_FixAllOccurrencesPreviewChanges;
    public static FunctionId CodeFixes_ApplyChanges;
    public static FunctionId SolutionExplorer_AnalyzerItemSource_GetItems;
    public static FunctionId SolutionExplorer_DiagnosticItemSource_GetItems;
    public static FunctionId WorkCoordinator_ActiveFileEnqueue;
    public static FunctionId SymbolFinder_FindDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Assembly_AddDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Name_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Solution_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Predicate_FindSourceDeclarationsAsync;
    public static FunctionId Tagger_Diagnostics_RecomputeTags;
    public static FunctionId Tagger_Diagnostics_Updated;
    public static FunctionId SuggestedActions_HasSuggestedActionsAsync;
    public static FunctionId SuggestedActions_GetSuggestedActions;
    public static FunctionId AnalyzerDependencyCheckingService_LogConflict;
    public static FunctionId AnalyzerDependencyCheckingService_LogMissingDependency;
    public static FunctionId VirtualMemory_MemoryLow;
    public static FunctionId Extension_Exception;
    public static FunctionId WorkCoordinator_WaitForHigherPriorityOperationsAsync;
    public static FunctionId CSharp_Interactive_Window;
    public static FunctionId VisualBasic_Interactive_Window;
    public static FunctionId NonFatalWatson;
    public static FunctionId CommandHandler_FindAllReference;
    public static FunctionId CodefixInfobar_Enable;
    public static FunctionId CodefixInfobar_EnableAndIgnoreFutureErrors;
    public static FunctionId CodefixInfobar_LeaveDisabled;
    public static FunctionId CodefixInfobar_ErrorIgnored;
    public static FunctionId Refactoring_NamingStyle;
    public static FunctionId SymbolTreeInfo_ExceptionInCacheRead;
    public static FunctionId SpellChecker_ExceptionInCacheRead;
    public static FunctionId BKTree_ExceptionInCacheRead;
    public static FunctionId IntellisenseBuild_Failed;
    public static FunctionId FileTextLoader_FileLengthThresholdExceeded;
    public static FunctionId MeasurePerformance_StartAction;
    public static FunctionId MeasurePerformance_StopAction;
    public static FunctionId Serializer_CreateChecksum;
    public static FunctionId Serializer_Serialize;
    public static FunctionId Serializer_Deserialize;
    public static FunctionId CodeAnalysisService_CalculateDiagnosticsAsync;
    public static FunctionId CodeAnalysisService_SerializeDiagnosticResultAsync;
    public static FunctionId CodeAnalysisService_GetReferenceCountAsync;
    public static FunctionId CodeAnalysisService_FindReferenceLocationsAsync;
    public static FunctionId CodeAnalysisService_FindReferenceMethodsAsync;
    public static FunctionId CodeAnalysisService_GetFullyQualifiedName;
    public static FunctionId CodeAnalysisService_GetTodoCommentsAsync;
    public static FunctionId CodeAnalysisService_GetDesignerAttributesAsync;
    public static FunctionId ServiceHubRemoteHostClient_CreateAsync;
    public static FunctionId RemoteHost_Connect;
    public static FunctionId RemoteHost_Disconnect;
    public static FunctionId RemoteHostService_SynchronizePrimaryWorkspaceAsync;
    public static FunctionId AssetStorage_CleanAssets;
    public static FunctionId AssetStorage_TryGetAsset;
    public static FunctionId AssetService_GetAssetAsync;
    public static FunctionId AssetService_SynchronizeAssetsAsync;
    public static FunctionId AssetService_SynchronizeSolutionAssetsAsync;
    public static FunctionId AssetService_SynchronizeProjectAssetsAsync;
    public static FunctionId CodeLens_GetReferenceCountAsync;
    public static FunctionId CodeLens_FindReferenceLocationsAsync;
    public static FunctionId CodeLens_FindReferenceMethodsAsync;
    public static FunctionId CodeLens_GetFullyQualifiedName;
    public static FunctionId SolutionState_ComputeChecksumsAsync;
    public static FunctionId ProjectState_ComputeChecksumsAsync;
    public static FunctionId DocumentState_ComputeChecksumsAsync;
    public static FunctionId SolutionChecksumUpdater_SynchronizePrimaryWorkspace;
    public static FunctionId JsonRpcSession_RequestAssetAsync;
    public static FunctionId SolutionService_GetSolutionAsync;
    public static FunctionId SolutionService_UpdatePrimaryWorkspaceAsync;
    public static FunctionId RemoteHostService_GetAssetsAsync;
    public static FunctionId SolutionCreator_AssetDifferences;
    public static FunctionId Extension_InfoBar;
    public static FunctionId FxCopAnalyzersInstall;
    public static FunctionId AssetStorage_ForceGC;
    public static FunctionId Intellisense_Completion;
    public static FunctionId MetadataOnlyImage_EmitFailure;
    public static FunctionId LiveTableDataSource_OnDiagnosticsUpdated;
    public static FunctionId Experiment_KeybindingsReset;
    public static FunctionId Diagnostics_GeneratePerformaceReport;
    public static FunctionId Diagnostics_BadAnalyzer;
    public static FunctionId CodeAnalysisService_ReportAnalyzerPerformance;
    public static FunctionId PerformanceTrackerService_AddSnapshot;
    public static FunctionId ExternalErrorDiagnosticUpdateSource_AddError;
    public static FunctionId DiagnosticIncrementalAnalyzer_SynchronizeWithBuildAsync;
    public static FunctionId Completion_ExecuteCommand_TypeChar;
    public static FunctionId RemoteHostService_SynchronizeTextAsync;
    public static FunctionId SymbolFinder_Solution_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId SymbolFinder_Project_Pattern_FindSourceDeclarationsAsync;
    public static FunctionId CodeCleanupInfobar_BarDisplayed;
    public static FunctionId CodeCleanupInfobar_ConfigureNow;
    public static FunctionId CodeCleanupInfobar_NeverShowCodeCleanupInfoBarAgain;
    public static FunctionId FormatDocument;
    public static FunctionId CodeCleanup_ApplyCodeFixesAsync;
    public static FunctionId CodeCleanup_RemoveUnusedImports;
    public static FunctionId CodeCleanup_SortImports;
    public static FunctionId CodeCleanup_Format;
    public static FunctionId CodeCleanupABTest_AssignedToOnByDefault;
    public static FunctionId CodeCleanupABTest_AssignedToOffByDefault;
    public static FunctionId Workspace_Events;
    public static FunctionId Refactoring_ExtractMethod_UnknownMatrixItem;
    public static FunctionId SyntaxTreeIndex_Precalculate;
    public static FunctionId SyntaxTreeIndex_Precalculate_Create;
    public static FunctionId SymbolTreeInfo_Create;
    public static FunctionId SymbolTreeInfo_TryLoadOrCreate;
    public static FunctionId CommandHandler_GoToImplementation;
    public static FunctionId GraphQuery_ImplementedBy;
    public static FunctionId GraphQuery_Implements;
    public static FunctionId GraphQuery_IsCalledBy;
    public static FunctionId GraphQuery_IsUsedBy;
    public static FunctionId GraphQuery_Overrides;
    public static FunctionId Intellisense_AsyncCompletion_Data;
    public static FunctionId Intellisense_CompletionProviders_Data;
    public static FunctionId RemoteHostService_IsExperimentEnabledAsync;
    public static FunctionId PartialLoad_FullyLoaded;
    public static FunctionId Liveshare_UnknownCodeAction;
    public static FunctionId CommandHandler_GoToBase;
    public static FunctionId DiagnosticAnalyzerService_GetDiagnosticsForSpanAsync;
    public static FunctionId CodeFixes_GetCodeFixesAsync;
    public static FunctionId LanguageServer_ActivateFailed;
    public static FunctionId LanguageServer_OnLoadedFailed;
    public static FunctionId CodeFixes_AddExplicitCast;
    public static FunctionId ToolsOptions_GenerateEditorconfig;
    public static FunctionId Renamer_RenameSymbolAsync;
    public static FunctionId Renamer_FindRenameLocationsAsync;
    public static FunctionId Renamer_ResolveConflictsAsync;
    public static FunctionId ChangeSignature_Data;
    public static FunctionId AbstractEncapsulateFieldService_EncapsulateFieldsAsync;
    public static FunctionId AbstractConvertTupleToStructCodeRefactoringProvider_ConvertToStructAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheDerivedClassesAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheDerivedInterfacesAsync;
    public static FunctionId DependentTypeFinder_FindAndCacheImplementingTypesAsync;
    public static FunctionId RemoteSemanticClassificationCacheService_ExceptionInCacheRead;
    public static FunctionId LSPCompletion_MissingLSPCompletionTriggerKind;
    public static FunctionId LSPCompletion_MissingLSPCompletionInvokeKind;
    public static FunctionId Workspace_Project_CompilationThrownAway;
    public static FunctionId CommandHandler_Paste_ImportsOnPaste;
    public static FunctionId RegisterWorkspace;
    public static FunctionId LSP_RequestCounter;
    public static FunctionId LSP_RequestDuration;
    public static FunctionId LSP_TimeInQueue;
    public static FunctionId Intellicode_UnknownIntent;
    public static FunctionId LSP_CompletionListCacheMiss;
    public static FunctionId InheritanceMargin_TargetsMenuOpen;
    public static FunctionId InheritanceMargin_NavigateToTarget;
    public static FunctionId VS_ErrorReportingService_ShowGlobalErrorInfo;
    public static FunctionId UnusedReferences_GetUnusedReferences;
    public static FunctionId ValueTracking_Command;
    public static FunctionId ValueTracking_TrackValueSource;
    public static FunctionId InheritanceMargin_GetInheritanceMemberItems;
    public static FunctionId LSP_FindDocumentInWorkspace;
    public static FunctionId SuggestedActions_GetSuggestedActionsAsync;
    public static FunctionId NavigateTo_CacheItemsMiss;
    public static FunctionId AssetService_Perf;
    public static FunctionId Inline_Hints_DoubleClick;
    public static FunctionId NavigateToExternalSources;
    public static FunctionId StackTraceToolWindow_ShowOnActivated;
    public static FunctionId CodeModel_FileCodeModel_Create;
    public static FunctionId Refactoring_FixAllOccurrencesSession;
    public static FunctionId Refactoring_FixAllOccurrencesContext;
    public static FunctionId Refactoring_FixAllOccurrencesComputation;
    public static FunctionId Refactoring_FixAllOccurrencesPreviewChanges;
    public static FunctionId LSP_UsedForkedSolution;
    public static FunctionId DocumentOutline_WindowOpen;
    public static FunctionId DocumentOutline_SortByName;
    public static FunctionId DocumentOutline_SortByOrder;
    public static FunctionId DocumentOutline_SortByType;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMatch_ApplicationSucceeded;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMatch_ApplicationFailed;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationSucceeded;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_IncompatibleSolutionChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_IncompatibleProjectChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_NoChangedDocument;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_NoTextChange;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_DocumentRemoved;
    public static FunctionId ApplyChangesOperation_WorkspaceVersionMismatch_ApplicationFailed_TextChangeConflict;
    public static FunctionId Completion_SemanticSnippets;
    public static FunctionId SpellCheckFixer_CouldNotFindDocument;
    public static FunctionId SpellCheckFixer_LanguageDoesNotSupportRename;
    public static FunctionId SpellCheckFixer_LanguageCouldNotGetRenameInfo;
    public static FunctionId SpellCheckFixer_RenameSpanNotWithinTokenSpan;
    public static FunctionId SpellCheckFixer_ReplacementTextInvalid;
    public static FunctionId SpellCheckFixer_TryApplyChangesFailure;
    public static FunctionId SourceGenerator_SolutionStatistics;
    public static FunctionId SourceGenerator_OtherWorkspaceSessionStatistics;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Internal.Log.FunctionIdExtensions : object {
    private static Lazy`1<ImmutableDictionary`2<FunctionId, string>> s_functionIdsToString;
    private static FunctionIdExtensions();
    [ExtensionAttribute]
public static string Convert(FunctionId functionId);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Internal.Log.HistogramLogAggregator`1 : AbstractLogAggregator`2<TKey, HistogramCounter<TKey>> {
    private int _bucketSize;
    private int _maxBucketValue;
    private int _bucketCount;
    public HistogramLogAggregator`1(int bucketSize, int maxBucketValue);
    protected virtual HistogramCounter<TKey> CreateCounter();
    public void IncreaseCount(TKey key, int value);
    public void LogTime(TKey key, TimeSpan timeSpan);
    public HistogramCounter<TKey> GetValue(TKey key);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Internal.Log.ILogger {
    public abstract virtual bool IsEnabled(FunctionId functionId);
    public abstract virtual void Log(FunctionId functionId, LogMessage logMessage);
    public abstract virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public abstract virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.InteractionClass : Enum {
    public int value__;
    public static InteractionClass Undefined;
    public static InteractionClass Instant;
    public static InteractionClass Fast;
    public static InteractionClass Typical;
    public static InteractionClass Responsive;
    public static InteractionClass Captive;
    public static InteractionClass Extended;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Internal.Log.KeyValueLogMessage : LogMessage {
    private static ObjectPool`1<KeyValueLogMessage> s_pool;
    public static KeyValueLogMessage NoProperty;
    private LogType _kind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, object> _lazyMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<Dictionary`2<string, object>> _propertySetter;
    public LogType Kind { get; }
    public bool ContainsProperty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<KeyValuePair`2<string, object>> Properties { get; }
    private static KeyValueLogMessage();
    public static KeyValueLogMessage Create(Action`1<Dictionary`2<string, object>> propertySetter, LogLevel logLevel);
    public static KeyValueLogMessage Create(LogType kind, LogLevel logLevel);
    public static KeyValueLogMessage Create(LogType kind, Action`1<Dictionary`2<string, object>> propertySetter, LogLevel logLevel);
    private void Initialize(LogType kind, Action`1<Dictionary`2<string, object>> propertySetter, LogLevel logLevel);
    public LogType get_Kind();
    public bool get_ContainsProperty();
    public IEnumerable`1<KeyValuePair`2<string, object>> get_Properties();
    protected virtual string CreateMessage();
    protected virtual void FreeCore();
    [MemberNotNullAttribute("_lazyMap")]
private void EnsureMap();
    [CompilerGeneratedAttribute]
internal static void <CreateMessage>g__Append|16_0(StringBuilder builder, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Internal.Log.Logger : object {
    [NullableAttribute("2")]
private static ILogger s_currentLogger;
    private static int s_lastUniqueBlockId;
    private static ObjectPool`1<RoslynLogBlock> s_pool;
    private static Logger();
    [NullableContextAttribute("2")]
public static ILogger SetLogger(ILogger logger);
    [NullableContextAttribute("2")]
public static ILogger GetLogger();
    [NullableContextAttribute("2")]
private static bool TryGetActiveLogger(FunctionId functionId, ILogger& activeLogger);
    [NullableContextAttribute("2")]
public static void Log(FunctionId functionId, string message, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`1<string> messageGetter, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, LogLevel logLevel);
    public static void Log(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, LogLevel logLevel);
    public static void Log(FunctionId functionId, LogMessage logMessage);
    private static int GetNextUniqueBlockId();
    public static IDisposable LogBlock(FunctionId functionId, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, string message, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`1<string> messageGetter, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`2<TArg, string> messageGetter, TArg arg, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, CancellationToken token, LogLevel logLevel);
    public static IDisposable LogBlock(FunctionId functionId, LogMessage logMessage, CancellationToken token);
    private static IDisposable CreateLogBlock(FunctionId functionId, LogMessage message, int blockId, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Internal.Log.LogLevel : Enum {
    public int value__;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Information;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
    public static LogLevel None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Internal.Log.LogMessage : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [NullableAttribute("2")]
private string _message;
    public LogLevel LogLevel { get; protected set; }
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
protected void set_LogLevel(LogLevel value);
    public static LogMessage Create(string message, LogLevel logLevel);
    public static LogMessage Create(Func`1<string> messageGetter, LogLevel logLevel);
    public static LogMessage Create(Func`2<TArg, string> messageGetter, TArg arg, LogLevel logLevel);
    public static LogMessage Create(Func`3<TArg0, TArg1, string> messageGetter, TArg0 arg0, TArg1 arg1, LogLevel logLevel);
    public static LogMessage Create(Func`4<TArg0, TArg1, TArg2, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, LogLevel logLevel);
    public static LogMessage Create(Func`5<TArg0, TArg1, TArg2, TArg3, string> messageGetter, TArg0 arg0, TArg1 arg1, TArg2 arg2, TArg3 arg3, LogLevel logLevel);
    protected abstract virtual string CreateMessage();
    protected abstract virtual void FreeCore();
    public string GetMessage();
    public void Free();
}
internal enum Microsoft.CodeAnalysis.Internal.Log.LogType : Enum {
    public int value__;
    public static LogType Trace;
    public static LogType UserAction;
}
[AttributeUsageAttribute("256")]
internal class Microsoft.CodeAnalysis.Internal.Log.PerfGoalAttribute : Attribute {
    private InteractionClass _interactionClass;
    public InteractionClass InteractionClass { get; }
    public PerfGoalAttribute(InteractionClass interactionClass);
    public InteractionClass get_InteractionClass();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Internal.Log.PiiValue : object {
    public object Value;
    public PiiValue(object value);
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[EventSourceAttribute]
internal class Microsoft.CodeAnalysis.Internal.Log.RoslynEventSource : EventSource {
    public static RoslynEventSource Instance;
    private bool _initialized;
    private static RoslynEventSource();
    [EventAttribute("1")]
public void Log(string message, FunctionId functionId);
    [EventAttribute("2")]
public void BlockStart(string message, FunctionId functionId, int blockId);
    [EventAttribute("3")]
public void BlockStop(FunctionId functionId, int tick, int blockId);
    [EventAttribute("4")]
public void SendFunctionDefinitions(string definitions);
    [EventAttribute("5")]
public void BlockCanceled(FunctionId functionId, int tick, int blockId);
    [NonEventAttribute]
protected virtual void OnEventCommand(EventCommandEventArgs command);
    [NonEventAttribute]
private static bool FunctionDefinitionRequested(EventCommandEventArgs command);
    [NonEventAttribute]
private void SendFunctionDefinitions();
    [NonEventAttribute]
public static string GenerateFunctionDefinitions();
    [NullableContextAttribute("1")]
public static LogBlock LogInformationalBlock(FunctionId functionId, object entity, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static LogBlock LogInformationalBlock(FunctionId functionId, string message, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[NonEventAttribute]
private void <OnEventCommand>g__FireAndForgetSendFunctionDefinitions|8_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Internal.Log.StatisticLogAggregator`1 : AbstractLogAggregator`2<TKey, StatisticCounter<TKey>> {
    protected virtual StatisticCounter<TKey> CreateCounter();
    public void AddDataPoint(TKey key, int value);
    public void AddDataPoint(TKey key, TimeSpan timeSpan);
    public StatisticResult GetStatisticResult(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Internal.Log.StatisticResult : ValueType {
    public int Maximum;
    public int Minimum;
    public double Mean;
    public Nullable`1<int> Mode;
    public int Range;
    public int Count;
    public StatisticResult(int max, int min, double mean, int range, Nullable`1<int> mode, int count);
    public static StatisticResult FromList(List`1<int> values);
    public void WriteTelemetryPropertiesTo(Dictionary`2<string, object> properties, string prefix);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Internal.Log.TraceLogger : object {
    public static TraceLogger Instance;
    [NullableAttribute("2")]
private Func`2<FunctionId, bool> _isEnabledPredicate;
    [NullableContextAttribute("2")]
public TraceLogger(Func`2<FunctionId, bool> isEnabledPredicate);
    private static TraceLogger();
    public sealed virtual bool IsEnabled(FunctionId functionId);
    public sealed virtual void Log(FunctionId functionId, LogMessage logMessage);
    public sealed virtual void LogBlockStart(FunctionId functionId, LogMessage logMessage, int uniquePairId, CancellationToken cancellationToken);
    public sealed virtual void LogBlockEnd(FunctionId functionId, LogMessage logMessage, int uniquePairId, int delta, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Internal.Strings : object {
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.ISupportedChangesService {
    public abstract virtual bool CanApplyChange(ApplyChangesKind kind);
    public abstract virtual bool CanApplyCompilationOptionChange(CompilationOptions oldOptions, CompilationOptions newOptions, Project project);
    public abstract virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project);
}
internal interface Microsoft.CodeAnalysis.ITextVersionable {
    public abstract virtual bool TryGetTextVersion(VersionStamp& version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractBlockFacts : object {
    [NullableContextAttribute("2")]
public abstract virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableBlock(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public abstract virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatementContainer(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractDeclaredSymbolInfoFactoryService`10 : object {
    private static ObjectPool`1<List`1<Dictionary`2<string, string>>> s_aliasMapListPool;
    private static ObjectPool`1<Dictionary`2<string, string>> s_aliasMapPool;
    private static AbstractDeclaredSymbolInfoFactoryService`10();
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetChildren(TCompilationUnitSyntax node);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetChildren(TNamespaceDeclarationSyntax node);
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetChildren(TTypeDeclarationSyntax node);
    protected abstract virtual IEnumerable`1<TMemberDeclarationSyntax> GetChildren(TEnumDeclarationSyntax node);
    protected abstract virtual SyntaxList`1<TUsingDirectiveSyntax> GetUsingAliases(TCompilationUnitSyntax node);
    protected abstract virtual SyntaxList`1<TUsingDirectiveSyntax> GetUsingAliases(TNamespaceDeclarationSyntax node);
    protected abstract virtual TNameSyntax GetName(TNamespaceDeclarationSyntax node);
    protected abstract virtual TNameSyntax GetLeft(TQualifiedNameSyntax node);
    protected abstract virtual TNameSyntax GetRight(TQualifiedNameSyntax node);
    protected abstract virtual SyntaxToken GetIdentifier(TIdentifierNameSyntax node);
    protected abstract virtual string GetContainerDisplayName(TMemberDeclarationSyntax namespaceDeclaration);
    protected abstract virtual string GetFullyQualifiedContainerName(TMemberDeclarationSyntax memberDeclaration, string rootNamespace);
    protected abstract virtual Nullable`1<DeclaredSymbolInfo> GetTypeDeclarationInfo(SyntaxNode container, TTypeDeclarationSyntax typeDeclaration, StringTable stringTable, string containerDisplayName, string fullyQualifiedContainerName);
    protected abstract virtual DeclaredSymbolInfo GetEnumDeclarationInfo(SyntaxNode container, TEnumDeclarationSyntax enumDeclaration, StringTable stringTable, string containerDisplayName, string fullyQualifiedContainerName);
    protected abstract virtual void AddMemberDeclarationInfos(SyntaxNode container, TMemberDeclarationSyntax memberDeclaration, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName);
    protected abstract virtual void AddLocalFunctionInfos(TMemberDeclarationSyntax memberDeclaration, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    protected abstract virtual void AddSynthesizedDeclaredSymbolInfos(SyntaxNode container, TMemberDeclarationSyntax memberDeclaration, StringTable stringTable, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    protected abstract virtual string GetReceiverTypeName(TMethodDeclarationSyntax node);
    protected abstract virtual bool TryGetAliasesFromUsingDirective(TUsingDirectiveSyntax node, ImmutableArray`1& aliases);
    protected abstract virtual string GetRootNamespace(CompilationOptions compilationOptions);
    protected static List`1<Dictionary`2<string, string>> AllocateAliasMapList();
    protected static string CreateReceiverTypeString(string typeName, bool isArray);
    protected static string CreateValueTupleTypeString(int elementCount);
    protected static void FreeAliasMapList(List`1<Dictionary`2<string, string>> list);
    protected static void FreeAliasMap(Dictionary`2<string, string> aliasMap);
    protected static Dictionary`2<string, string> AllocateAliasMap();
    protected static void Intern(StringTable stringTable, ArrayBuilder`1<string> builder);
    public sealed virtual void AddDeclaredSymbolInfos(Document document, SyntaxNode root, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, Dictionary`2<string, ArrayBuilder`1<int>> extensionMethodInfo, CancellationToken cancellationToken);
    private void AddDeclaredSymbolInfos(SyntaxNode container, TMemberDeclarationSyntax memberDeclaration, StringTable stringTable, string rootNamespace, ArrayBuilder`1<DeclaredSymbolInfo> declaredSymbolInfos, Dictionary`2<string, string> aliases, Dictionary`2<string, ArrayBuilder`1<int>> extensionMethodInfo, string containerDisplayName, string fullyQualifiedContainerName, CancellationToken cancellationToken);
    private static void AddAliases(Dictionary`2<string, string> allAliases, ImmutableArray`1<ValueTuple`2<string, string>> aliases);
    [CompilerGeneratedAttribute]
private string <AddDeclaredSymbolInfos>g__AddNamespaceDeclaredSymbolInfos|31_0(TNameSyntax name, string fullyQualifiedContainerName, <>c__DisplayClass31_0& );
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <AddDeclaredSymbolInfos>g__AddExtensionMethodInfo|31_1(TMethodDeclarationSyntax methodDeclaration, <>c__DisplayClass31_0& );
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractDocumentationCommentService`10 : object {
    public static string Ellipsis;
    private ISyntaxFacts _syntaxFacts;
    protected AbstractDocumentationCommentService`10(ISyntaxFacts syntaxFacts);
    private static void AddSpaceIfNotAlreadyThere(StringBuilder sb);
    private string GetDocumentationCommentPrefix(TDocumentationCommentTriviaSyntax documentationComment);
    public string GetBannerText(TDocumentationCommentTriviaSyntax documentationComment, int maxBannerLength, CancellationToken cancellationToken);
    private void HandleElement(TXmlElementSyntax summaryElement, StringBuilder sb);
    private void HandleNode(SyntaxNode node, StringBuilder sb);
    protected abstract virtual SyntaxToken GetIdentifier(TXmlNameAttributeSyntax xmlName);
    protected abstract virtual TCrefSyntax GetCref(TXmlCrefAttributeSyntax xmlCref);
    protected abstract virtual SyntaxList`1<TXmlAttributeSyntax> GetAttributes(TXmlEmptyElementSyntax xmlEmpty);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextSyntax xmlText);
    protected abstract virtual SyntaxTokenList GetTextTokens(TXmlTextAttributeSyntax xmlTextAttribute);
    protected abstract virtual SyntaxNode GetName(TXmlElementSyntax xmlElement);
    private static void AppendTextTokens(StringBuilder sb, SyntaxTokenList textTokens);
    private static bool HasLeadingWhitespace(string tokenText);
    private static bool HasTrailingWhitespace(string tokenText);
    public sealed virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GetBannerText>b__5_0(TXmlElementSyntax e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractFileBannerFacts : object {
    private Matcher`1<SyntaxTrivia> _oneOrMoreBlankLines;
    private Matcher`1<SyntaxTrivia> _bannerMatcher;
    private Matcher`1<SyntaxTrivia> _fileBannerMatcher;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected IDocumentationCommentService DocumentationCommentService { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual IDocumentationCommentService get_DocumentationCommentService();
    public sealed virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    [NullableContextAttribute("0")]
public ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public sealed virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractHeaderFacts : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public abstract virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public abstract virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public abstract virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public abstract virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public abstract virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public abstract virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public abstract virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public abstract virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
    public bool IsOnHeader(SyntaxNode root, int position, SyntaxNode ownerOfHeader, SyntaxNodeOrToken lastTokenOrNodeOfHeader);
    public bool IsOnHeader(SyntaxNode root, int position, SyntaxNode ownerOfHeader, SyntaxNodeOrToken lastTokenOrNodeOfHeader, ImmutableArray`1<THoleSyntax> holes);
    protected TNode TryGetAncestorForLocation(SyntaxNode root, int position);
    protected int GetStartOfNodeExcludingAttributes(SyntaxNode root, SyntaxNode node);
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractSelectedMembers`5 : object {
    protected abstract virtual SyntaxList`1<TMemberDeclarationSyntax> GetMembers(TTypeDeclarationSyntax containingType);
    protected abstract virtual ImmutableArray`1<ValueTuple`2<SyntaxNode, SyntaxToken>> GetDeclaratorsAndIdentifiers(TMemberDeclarationSyntax member);
    public Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedFieldsAndPropertiesAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    public Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedMembersAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LanguageService.AbstractSelectedMembers`5/<GetSelectedMembersAsync>d__4")]
private Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedMembersAsync(SyntaxTree tree, TextSpan textSpan, bool allowPartialSelection, Func`2<TMemberDeclarationSyntax, bool> membersToKeep, CancellationToken cancellationToken);
    private ImmutableArray`1<SyntaxNode> GetMembersInSpan(SyntaxNode root, SourceText text, TextSpan textSpan, TMemberDeclarationSyntax firstMember, bool allowPartialSelection, Func`2<TMemberDeclarationSyntax, bool> membersToKeep);
    private static bool IsBeforeOrAfterNodeOnSameLine(SourceText text, SyntaxNode root, SyntaxNode member, int position);
    private static bool IsFieldOrProperty(TMemberDeclarationSyntax member);
    [CompilerGeneratedAttribute]
private void <GetMembersInSpan>g__AddAllMembers|5_0(TMemberDeclarationSyntax member, <>c__DisplayClass5_0& );
    [CompilerGeneratedAttribute]
private void <GetMembersInSpan>g__AddSelectedMemberDeclarations|5_1(TMemberDeclarationSyntax member, Func`2<TMemberDeclarationSyntax, bool> membersToKeep, <>c__DisplayClass5_0& );
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.AbstractSemanticFactsService : object {
    private static Func`2<ISymbol, bool> s_LocalNameFilter;
    public ISyntaxFacts SyntaxFacts { get; }
    public IBlockFacts BlockFacts { get; }
    protected ISemanticFacts SemanticFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    private static AbstractSemanticFactsService();
    [NullableContextAttribute("1")]
public sealed virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual IBlockFacts get_BlockFacts();
    protected abstract virtual ISemanticFacts get_SemanticFacts();
    protected abstract virtual SyntaxToken ToIdentifierToken(string identifier);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    protected virtual IEnumerable`1<ISymbol> GetCollidableSymbols(SemanticModel semanticModel, SyntaxNode location, SyntaxNode container, CancellationToken cancellationToken);
    public SyntaxToken GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
    public sealed virtual bool get_SupportsImplicitInterfaceImplementation();
    public sealed virtual bool get_SupportsParameterizedProperties();
    public sealed virtual bool get_ExposesAnonymousFunctionParameterNames();
    public sealed virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public sealed virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public sealed virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public sealed virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public sealed virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public sealed virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    public sealed virtual bool IsPartial(ITypeSymbol typeSymbol, CancellationToken cancellationToken);
    public sealed virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, bool allowUncertainCandidates, CancellationToken cancellationToken);
    public sealed virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argumentNode, bool allowUncertainCandidates, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argumentNode, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public sealed virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public sealed virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private bool <GenerateUniqueName>b__13_0(SyntaxNode a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.LanguageService.ArityUtilities : object {
    private static string GenericTypeNameManglingString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_aritySuffixesOneToNine;
    private static ArityUtilities();
    public static string GetMetadataAritySuffix(int arity);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.LanguageService.DisplayNameOptions : Enum {
    public int value__;
    public static DisplayNameOptions None;
    public static DisplayNameOptions IncludeMemberKeyword;
    public static DisplayNameOptions IncludeNamespaces;
    public static DisplayNameOptions IncludeParameters;
    public static DisplayNameOptions IncludeType;
    public static DisplayNameOptions IncludeTypeParameters;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.ExternalSourceInfo : ValueType {
    public Nullable`1<int> StartLine;
    public bool Ends;
    public ExternalSourceInfo(Nullable`1<int> startLine, bool ends);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.ForEachSymbols : ValueType {
    public IMethodSymbol GetEnumeratorMethod;
    public IMethodSymbol MoveNextMethod;
    public IPropertySymbol CurrentProperty;
    public IMethodSymbol DisposeMethod;
    public ITypeSymbol ElementType;
    internal ForEachSymbols(IMethodSymbol getEnumeratorMethod, IMethodSymbol moveNextMethod, IPropertySymbol currentProperty, IMethodSymbol disposeMethod, ITypeSymbol elementType);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IAccessibilityFacts {
    public abstract virtual bool CanHaveAccessibility(SyntaxNode declaration, bool ignoreDeclarationModifiers);
    public abstract virtual Accessibility GetAccessibility(SyntaxNode declaration);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IBlockFacts {
    [NullableContextAttribute("2")]
public abstract virtual bool IsScopeBlock(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableBlock(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetExecutableBlockStatements(SyntaxNode node);
    public abstract virtual SyntaxNode FindInnermostCommonExecutableBlock(IEnumerable`1<SyntaxNode> nodes);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatementContainer(SyntaxNode node);
    public abstract virtual IReadOnlyList`1<SyntaxNode> GetStatementContainerStatements(SyntaxNode node);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IBlockFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SyntaxNode GetStatementContainer(IBlockFacts blockFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageService.IBlockFactsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.IDocumentationCommentService {
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int bannerLength, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IFileBannerFacts {
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxNode root);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetFileBanner(SyntaxToken firstToken);
    public abstract virtual string GetBannerText(SyntaxNode documentationCommentTriviaSyntax, int maxBannerLength, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBlankLines(SyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBlankLines(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<SyntaxTrivia> GetLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node);
    public abstract virtual TSyntaxNode GetNodeWithoutLeadingBannerAndPreprocessorDirectives(TSyntaxNode node, ImmutableArray`1& strippedTrivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxTrivia> GetTriviaAfterLeadingBlankLines(IFileBannerFacts bannerService, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageService.IFileBannerFactsService {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.IHeaderFacts {
    public abstract virtual bool IsOnTypeHeader(SyntaxNode root, int position, bool fullHeader, SyntaxNode& typeDeclaration);
    public abstract virtual bool IsOnPropertyDeclarationHeader(SyntaxNode root, int position, SyntaxNode& propertyDeclaration);
    public abstract virtual bool IsOnParameterHeader(SyntaxNode root, int position, SyntaxNode& parameter);
    public abstract virtual bool IsOnMethodHeader(SyntaxNode root, int position, SyntaxNode& method);
    public abstract virtual bool IsOnLocalFunctionHeader(SyntaxNode root, int position, SyntaxNode& localFunction);
    public abstract virtual bool IsOnLocalDeclarationHeader(SyntaxNode root, int position, SyntaxNode& localDeclaration);
    public abstract virtual bool IsOnIfStatementHeader(SyntaxNode root, int position, SyntaxNode& ifStatement);
    public abstract virtual bool IsOnWhileStatementHeader(SyntaxNode root, int position, SyntaxNode& whileStatement);
    public abstract virtual bool IsOnForeachHeader(SyntaxNode root, int position, SyntaxNode& foreachStatement);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.IHeaderFactsExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsOnTypeHeader(IHeaderFacts headerFacts, SyntaxNode root, int position, SyntaxNode& typeDeclaration);
}
internal interface Microsoft.CodeAnalysis.LanguageService.IHeaderFactsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISemanticFacts {
    public ISyntaxFacts SyntaxFacts { get; }
    public bool SupportsImplicitInterfaceImplementation { get; }
    public bool SupportsParameterizedProperties { get; }
    public bool ExposesAnonymousFunctionParameterNames { get; }
    public abstract virtual string GenerateNameForExpression(SemanticModel semanticModel, SyntaxNode expression, bool capitalize, CancellationToken cancellationToken);
    public abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual bool get_SupportsImplicitInterfaceImplementation();
    public abstract virtual bool get_SupportsParameterizedProperties();
    public abstract virtual bool get_ExposesAnonymousFunctionParameterNames();
    public abstract virtual bool IsWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsOnlyWrittenTo(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInOutContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInRefContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool IsInInContext(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual bool CanReplaceWithRValue(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    public abstract virtual ISymbol GetDeclaredSymbol(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool LastEnumValueHasInitializer(INamedTypeSymbol namedTypeSymbol);
    public abstract virtual bool TryGetSpeculativeSemanticModel(SemanticModel oldSemanticModel, SyntaxNode oldNode, SyntaxNode newNode, SemanticModel& speculativeModel);
    public abstract virtual ImmutableHashSet`1<string> GetAliasNameSet(SemanticModel model, CancellationToken cancellationToken);
    public abstract virtual ForEachSymbols GetForEachSymbols(SemanticModel semanticModel, SyntaxNode forEachStatement);
    public abstract virtual IMethodSymbol GetGetAwaiterMethod(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionAssignmentMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetDeconstructionForEachMethods(SemanticModel semanticModel, SyntaxNode node);
    public abstract virtual bool IsPartial(ITypeSymbol typeSymbol, CancellationToken cancellationToken);
    public abstract virtual IEnumerable`1<ISymbol> GetDeclaredSymbols(SemanticModel semanticModel, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol FindParameterForArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, CancellationToken cancellationToken);
    public abstract virtual IParameterSymbol FindParameterForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, bool allowUncertainCandidates, CancellationToken cancellationToken);
    public abstract virtual ISymbol FindFieldOrPropertyForArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    public abstract virtual ISymbol FindFieldOrPropertyForAttributeArgument(SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SemanticModel semanticModel, SyntaxNode node, SyntaxToken token, CancellationToken cancellationToken);
    public abstract virtual bool IsInsideNameOfExpression(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<IMethodSymbol> GetLocalFunctionSymbols(Compilation compilation, ISymbol symbol, CancellationToken cancellationToken);
    public abstract virtual bool IsInExpressionTree(SemanticModel semanticModel, SyntaxNode node, INamedTypeSymbol expressionTypeOpt, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.ISemanticFactsExtensions : object {
    [ExtensionAttribute]
public static bool IsSafeToChangeAssociativity(ISemanticFacts semanticFacts, TBinaryExpressionSyntax innerBinary, TBinaryExpressionSyntax parentBinary, SemanticModel semanticModel);
    private static bool AnySymbolIsUserDefinedOperator(SymbolInfo symbolInfo);
    [NullableContextAttribute("2")]
private static bool IsUserDefinedOperator(ISymbol symbol);
    private static bool IsFloatingPoint(TypeInfo typeInfo);
    [NullableContextAttribute("2")]
private static bool IsFloatingPoint(ITypeSymbol type);
    [ExtensionAttribute]
public static IParameterSymbol FindParameterForArgument(ISemanticFacts semanticFacts, SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IParameterSymbol FindParameterForAttributeArgument(ISemanticFacts semanticFacts, SemanticModel semanticModel, SyntaxNode argument, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <IsSafeToChangeAssociativity>g__IsArithmetic|0_0(IBinaryOperation op);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISemanticFactsService {
    public abstract virtual bool IsExpressionContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsNamespaceDeclarationNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsTypeDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsMemberDeclarationContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsGlobalStatementContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLabelContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsAttributeNameContext(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, Func`2<ISymbol, bool> filter, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueLocalName(SemanticModel semanticModel, SyntaxNode location, SyntaxNode containerOpt, string baseName, IEnumerable`1<string> usedNames, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken GenerateUniqueName(string baseName, IEnumerable`1<string> usedNames);
    public abstract virtual CommonConversion ClassifyConversion(SemanticModel semanticModel, SyntaxNode expression, ITypeSymbol destination);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISymbolDeclarationService {
    [NullableContextAttribute("1")]
public abstract virtual ImmutableArray`1<SyntaxReference> GetDeclarations(ISymbol symbol);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxFacts {
    public bool IsCaseSensitive { get; }
    public StringComparer StringComparer { get; }
    public SyntaxTrivia ElasticMarker { get; }
    public SyntaxTrivia ElasticCarriageReturnLineFeed { get; }
    public ISyntaxKinds SyntaxKinds { get; }
    public abstract virtual bool get_IsCaseSensitive();
    public abstract virtual StringComparer get_StringComparer();
    public abstract virtual SyntaxTrivia get_ElasticMarker();
    public abstract virtual SyntaxTrivia get_ElasticCarriageReturnLineFeed();
    public abstract virtual ISyntaxKinds get_SyntaxKinds();
    public abstract virtual bool SupportsIndexingInitializer(ParseOptions options);
    public abstract virtual bool SupportsLocalFunctionDeclaration(ParseOptions options);
    public abstract virtual bool SupportsNotPattern(ParseOptions options);
    public abstract virtual bool SupportsRecord(ParseOptions options);
    public abstract virtual bool SupportsRecordStruct(ParseOptions options);
    public abstract virtual bool SupportsThrowExpression(ParseOptions options);
    public abstract virtual bool SupportsTargetTypedConditionalExpression(ParseOptions options);
    public abstract virtual bool SupportsIsNotTypeExpression(ParseOptions options);
    public abstract virtual bool SupportsConstantInterpolatedStrings(ParseOptions options);
    public abstract virtual SyntaxToken ParseToken(string text);
    public abstract virtual SyntaxTriviaList ParseLeadingTrivia(string text);
    public abstract virtual string EscapeIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(SyntaxToken token);
    public abstract virtual bool IsOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token);
    public abstract virtual bool IsPredefinedOperator(SyntaxToken token, PredefinedOperator op);
    public abstract virtual bool IsPredefinedType(SyntaxToken token);
    public abstract virtual bool IsPredefinedType(SyntaxToken token, PredefinedType type);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPredefinedType(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPredefinedType(SyntaxNode node, PredefinedType type);
    public abstract virtual bool IsReservedKeyword(SyntaxToken token);
    public abstract virtual bool IsContextualKeyword(SyntaxToken token);
    public abstract virtual bool IsPreprocessorKeyword(SyntaxToken token);
    public abstract virtual bool IsPreProcessorDirectiveContext(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool IsLiteral(SyntaxToken token);
    public abstract virtual bool IsStringLiteralOrInterpolatedStringLiteral(SyntaxToken token);
    public abstract virtual bool IsNumericLiteral(SyntaxToken token);
    public abstract virtual bool IsVerbatimStringLiteral(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingOrExternOrImport(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalAssemblyAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalModuleAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeclaration(SyntaxNode node);
    public abstract virtual bool IsTypeDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingAliasDirective(SyntaxNode node);
    public abstract virtual bool IsRegularComment(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxTrivia trivia);
    public abstract virtual bool IsElastic(SyntaxTrivia trivia);
    public abstract virtual bool IsPragmaDirective(SyntaxTrivia trivia, Boolean& isDisable, Boolean& isActive, SeparatedSyntaxList`1& errorCodes);
    public abstract virtual bool IsPreprocessorDirective(SyntaxTrivia trivia);
    public abstract virtual bool IsDocumentationComment(SyntaxNode node);
    public abstract virtual string GetText(int kind);
    [NullableContextAttribute("2")]
public abstract virtual bool IsEntirelyWithinStringOrCharOrNumericLiteral(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual bool TryGetPredefinedType(SyntaxToken token, PredefinedType& type);
    public abstract virtual bool TryGetPredefinedOperator(SyntaxToken token, PredefinedOperator& op);
    [NullableContextAttribute("2")]
public abstract virtual bool TryGetExternalSourceInfo(SyntaxNode directive, ExternalSourceInfo& info);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeclarationExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsConversionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsCastExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExpressionOfForeach(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfForeachStatement(SyntaxNode node);
    public abstract virtual void GetPartsOfTupleExpression(SyntaxNode node, SyntaxToken& openParen, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParen);
    public abstract virtual bool IsVerbatimInterpolatedStringExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyAssignmentStatement(SyntaxNode statement);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleAssignmentStatement(SyntaxNode statement);
    public abstract virtual void GetPartsOfAssignmentStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfAssignmentExpressionOrStatement(SyntaxNode statement, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfAnyAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfCompoundAssignment(SyntaxNode node);
    public abstract virtual SyntaxNode GetRightHandSideOfAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInferredAnonymousObjectMemberDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsOperandOfIncrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsOperandOfIncrementOrDecrementExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetRightSideOfDot(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetLeftSideOfDot(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLeftSideOfExplicitInterfaceSpecifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfSimpleMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfAnyMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetStandaloneExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetRootConditionalAccessExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfMemberAccessExpression(SyntaxNode node, bool allowImplicitTarget);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetTargetOfMemberBinding(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPointerMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNamedArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfNamedArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetParameterList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsParameterList(SyntaxNode node);
    public abstract virtual bool IsDocumentationCommentExteriorTrivia(SyntaxTrivia trivia);
    public abstract virtual void GetPartsOfElementAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public abstract virtual SyntaxNode GetExpressionOfArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfAttributeArgument(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfInterpolation(SyntaxNode node);
    public abstract virtual SyntaxNode GetNameOfAttribute(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberBindingExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsPostfixUnaryExpression(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfSimpleName(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfTypeDeclaration(SyntaxNode node);
    public abstract virtual SyntaxToken GetIdentifierOfVariableDeclarator(SyntaxNode node);
    public abstract virtual SyntaxNode GetTypeOfVariableDeclarator(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsArgument(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAttributeArgument(SyntaxNode node);
    public abstract virtual RefKind GetRefKindOfArgument(SyntaxNode node);
    public abstract virtual void GetNameAndArityOfSimpleName(SyntaxNode node, String& name, Int32& arity);
    public abstract virtual bool LooksGeneric(SyntaxNode simpleName);
    [NullableContextAttribute("2")]
public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(SyntaxNode genericName);
    public abstract virtual SyntaxList`1<SyntaxNode> GetContentsOfInterpolatedString(SyntaxNode interpolatedString);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfObjectCreationExpression(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfArgumentList(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfAttributeArgumentList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUsingDirectiveName(SyntaxNode node);
    public abstract virtual bool IsAttributeName(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxList`1<SyntaxNode> GetAttributeLists(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAttributeNamedArgumentIdentifier(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberInitializerNamedAssignmentIdentifier(SyntaxNode node, SyntaxNode& initializedInstance);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyInitializerExpression(SyntaxNode node, SyntaxNode& creationExpression);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDirective(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsExecutableStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsGlobalStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetStatementOfGlobalStatement(SyntaxNode node);
    public abstract virtual bool AreStatementsInSameContainer(SyntaxNode firstStatement, SyntaxNode secondStatement);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeconstructionAssignment(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsDeconstructionForEachStatement(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMethodBody(SyntaxNode node);
    public abstract virtual bool IsDeclaratorOfLocalDeclarationStatement(SyntaxNode declarator, SyntaxNode localDeclarationStatement);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetVariablesOfLocalDeclarationStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetInitializerOfVariableDeclarator(SyntaxNode node);
    public abstract virtual bool IsThisConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsBaseConstructorInitializer(SyntaxToken token);
    public abstract virtual bool IsQueryKeyword(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsElementAccessExpression(SyntaxNode node);
    public abstract virtual bool IsIdentifierStartCharacter(char c);
    public abstract virtual bool IsIdentifierPartCharacter(char c);
    public abstract virtual bool IsIdentifierEscapeCharacter(char c);
    public abstract virtual bool IsStartOfUnicodeEscapeSequence(char c);
    public abstract virtual bool IsValidIdentifier(string identifier);
    public abstract virtual bool IsVerbatimIdentifier(string identifier);
    public abstract virtual bool IsTypeCharacter(char c);
    public abstract virtual bool IsBindableToken(SyntaxToken token);
    public abstract virtual bool IsInStaticContext(SyntaxNode node);
    public abstract virtual bool IsUnsafeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInNamespaceOrTypeContext(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBaseTypeList(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsInConstantContext(SyntaxNode node);
    public abstract virtual bool IsInConstructor(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMethodLevelMember(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsTopLevelNodeWithMembers(SyntaxNode node);
    public abstract virtual bool AreEquivalent(SyntaxToken token1, SyntaxToken token2);
    [NullableContextAttribute("2")]
public abstract virtual bool AreEquivalent(SyntaxNode node1, SyntaxNode node2);
    [NullableContextAttribute("2")]
public abstract virtual string GetDisplayName(SyntaxNode node, DisplayNameOptions options, string rootNamespace);
    public abstract virtual SyntaxNode GetContainingTypeDeclaration(SyntaxNode root, int position);
    public abstract virtual SyntaxNode GetContainingMemberDeclaration(SyntaxNode root, int position, bool useFullSpan);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetContainingVariableDeclaratorOfFieldDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode ConvertToSingleLine(SyntaxNode node, bool useElasticTrivia);
    public abstract virtual List`1<SyntaxNode> GetTopLevelAndMethodLevelMembers(SyntaxNode root);
    public abstract virtual List`1<SyntaxNode> GetMethodLevelMembers(SyntaxNode root);
    public abstract virtual SyntaxList`1<SyntaxNode> GetMembersOfTypeDeclaration(SyntaxNode typeDeclaration);
    [NullableContextAttribute("2")]
public abstract virtual bool ContainsInMemberBody(SyntaxNode node, TextSpan span);
    public abstract virtual TextSpan GetInactiveRegionSpanAroundPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
    public abstract virtual TextSpan GetMemberBodySpanForSpeculativeBinding(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode TryGetBindableParent(SyntaxToken token);
    public abstract virtual IEnumerable`1<SyntaxNode> GetConstructors(SyntaxNode root, CancellationToken cancellationToken);
    public abstract virtual string GetNameForArgument(SyntaxNode argument);
    public abstract virtual string GetNameForAttributeArgument(SyntaxNode argument);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNameOfSubpattern(SyntaxNode node);
    public abstract virtual bool IsPropertyPatternClause(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnyPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBinaryPattern(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsUnaryPattern(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfConstantPattern(SyntaxNode node);
    public abstract virtual SyntaxNode GetTypeOfTypePattern(SyntaxNode node);
    public abstract virtual void GetPartsOfParenthesizedPattern(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& pattern, SyntaxToken& closeParen);
    public abstract virtual void GetPartsOfBinaryPattern(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfDeclarationPattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& designation);
    [NullableContextAttribute("2")]
public abstract virtual void GetPartsOfRecursivePattern(SyntaxNode node, SyntaxNode& type, SyntaxNode& positionalPart, SyntaxNode& propertyPart, SyntaxNode& designation);
    public abstract virtual void GetPartsOfUnaryPattern(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& pattern);
    public abstract virtual bool ContainsInterleavedDirective(TextSpan span, SyntaxToken token, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxTokenList GetModifiers(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode WithModifiers(SyntaxNode node, SyntaxTokenList modifiers);
    public abstract virtual Location GetDeconstructionReferenceLocation(SyntaxNode node);
    public abstract virtual Nullable`1<SyntaxToken> GetDeclarationIdentifierIfOverride(SyntaxToken token);
    [NullableContextAttribute("2")]
public abstract virtual bool IsParameterNameXmlElementSyntax(SyntaxNode node);
    public abstract virtual SyntaxList`1<SyntaxNode> GetContentFromDocumentationCommentTriviaSyntax(SyntaxTrivia trivia);
    public abstract virtual bool IsInInactiveRegion(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual bool IsAnonymousFunctionExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBaseNamespaceDeclaration(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsBinaryExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsLiteralExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsMemberAccessExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsSimpleName(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsNamedMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsElementAccessInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsObjectMemberInitializer(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsObjectCollectionInitializer(SyntaxNode node);
    public abstract virtual void GetPartsOfAnyIsTypeExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& type);
    public abstract virtual void GetPartsOfArgumentList(SyntaxNode node, SyntaxToken& openParenToken, SeparatedSyntaxList`1& arguments, SyntaxToken& closeParenToken);
    public abstract virtual void GetPartsOfBaseNamespaceDeclaration(SyntaxNode node, SyntaxNode& name, SyntaxList`1& imports, SyntaxList`1& members);
    [NullableContextAttribute("2")]
public abstract virtual void GetPartsOfBaseObjectCreationExpression(SyntaxNode node, SyntaxNode& argumentList, SyntaxNode& initializer);
    public abstract virtual void GetPartsOfBinaryExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& operatorToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfCastExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& expression);
    public abstract virtual void GetPartsOfCompilationUnit(SyntaxNode node, SyntaxList`1& imports, SyntaxList`1& attributeLists, SyntaxList`1& members);
    public abstract virtual void GetPartsOfConditionalAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& whenNotNull);
    public abstract virtual void GetPartsOfConditionalExpression(SyntaxNode node, SyntaxNode& condition, SyntaxNode& whenTrue, SyntaxNode& whenFalse);
    public abstract virtual void GetPartsOfGenericName(SyntaxNode node, SyntaxToken& identifier, SeparatedSyntaxList`1& typeArguments);
    public abstract virtual void GetPartsOfInterpolationExpression(SyntaxNode node, SyntaxToken& stringStartToken, SyntaxList`1& contents, SyntaxToken& stringEndToken);
    public abstract virtual void GetPartsOfInvocationExpression(SyntaxNode node, SyntaxNode& expression, SyntaxNode& argumentList);
    public abstract virtual void GetPartsOfIsPatternExpression(SyntaxNode node, SyntaxNode& left, SyntaxToken& isToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfMemberAccessExpression(SyntaxNode node, SyntaxNode& expression, SyntaxToken& operatorToken, SyntaxNode& name);
    public abstract virtual void GetPartsOfNamedMemberInitializer(SyntaxNode node, SyntaxNode& name, SyntaxNode& expression);
    public abstract virtual void GetPartsOfObjectCreationExpression(SyntaxNode node, SyntaxNode& type, SyntaxNode& argumentList, SyntaxNode& initializer);
    public abstract virtual void GetPartsOfParameter(SyntaxNode node, SyntaxToken& identifier, SyntaxNode& default);
    public abstract virtual void GetPartsOfParenthesizedExpression(SyntaxNode node, SyntaxToken& openParen, SyntaxNode& expression, SyntaxToken& closeParen);
    public abstract virtual void GetPartsOfPrefixUnaryExpression(SyntaxNode node, SyntaxToken& operatorToken, SyntaxNode& operand);
    public abstract virtual void GetPartsOfQualifiedName(SyntaxNode node, SyntaxNode& left, SyntaxToken& dotToken, SyntaxNode& right);
    public abstract virtual void GetPartsOfUsingAliasDirective(SyntaxNode node, SyntaxToken& globalKeyword, SyntaxToken& alias, SyntaxNode& name);
    public abstract virtual SyntaxNode GetExpressionOfAwaitExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfExpressionStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfRefExpression(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfReturnStatement(SyntaxNode node);
    public abstract virtual SyntaxNode GetExpressionOfThrowExpression(SyntaxNode node);
    [NullableContextAttribute("2")]
public abstract virtual bool IsEqualsValueOfPropertyDeclaration(SyntaxNode node);
    public abstract virtual SyntaxNode GetValueOfEqualsValueClause(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetInitializersOfObjectMemberInitializer(SyntaxNode node);
    public abstract virtual SeparatedSyntaxList`1<SyntaxNode> GetExpressionsOfObjectCollectionInitializer(SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsExtensions : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>>> s_stackPool;
    private static ISyntaxFactsExtensions();
    [ExtensionAttribute]
public static bool IsMemberInitializerNamedAssignmentIdentifier(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxNode node, bool fullSpan);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, Stack`1<ValueTuple`3<SyntaxNodeOrToken, bool, bool>> stack);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxToken token, bool leading, bool trailing);
    private static bool IsOnSingleLine(ISyntaxFacts syntaxFacts, SyntaxTriviaList triviaList, bool checkTrivia);
    private static bool IsOnSingleLine(string value);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, ImmutableArray`1<SyntaxNode> nodes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsInterleavedDirective(ISyntaxFacts syntaxFacts, TextSpan span, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
private static bool SpansPreprocessorDirective(ISyntaxFacts syntaxFacts, SyntaxTriviaList list);
    [ExtensionAttribute]
public static bool IsLegalIdentifier(ISyntaxFacts syntaxFacts, string name);
    [ExtensionAttribute]
public static bool IsReservedOrContextualKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsWord(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsRegularOrDocumentationComment(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WalkDownParentheses(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode WalkUpParentheses(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static void GetPartsOfAssignmentStatement(ISyntaxFacts syntaxFacts, SyntaxNode statement, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode Unparenthesize(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
private static bool IsWordOrNumber(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts service, SyntaxNode node);
    [ExtensionAttribute]
public static bool SpansPreprocessorDirective(ISyntaxFacts service, SyntaxNode[] nodes);
    [ExtensionAttribute]
public static bool IsWhitespaceOrEndOfLineTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static void GetPartsOfBinaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& left, SyntaxNode& right);
    [ExtensionAttribute]
public static SyntaxNode GetPatternOfParenthesizedPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfBinaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAnonymousOrLocalFunction(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfElementAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfElementAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static void GetPartsOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& expression, SyntaxNode& name);
    [ExtensionAttribute]
public static void GetPartsOfConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node, SyntaxNode& expression, SyntaxNode& whenNotNull);
    [ExtensionAttribute]
public static TextSpan GetSpanWithoutAttributes(ISyntaxFacts syntaxFacts, SyntaxNode root, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetRootStandaloneExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<SyntaxNode> GetArgumentsOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetArgumentListOfObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetDefaultOfParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetExpressionOfParenthesizedExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfIdentifierName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetIdentifierOfParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetImportsOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetImportsOfCompilationUnit(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetInitializerOfBaseObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetMembersOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxList`1<SyntaxNode> GetMembersOfCompilationUnit(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetNameOfBaseNamespaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetNameOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetOperandOfPrefixUnaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxToken GetOperatorTokenOfPrefixUnaryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SeparatedSyntaxList`1<SyntaxNode> GetTypeArgumentsOfGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode GetTypeOfObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfAwaitExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionOfMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRightOfQualifiedName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeOfObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEndOfLineTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsMultiLineDocCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsShebangDirectiveTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSingleLineDocCommentTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsWhitespaceTrivia(ISyntaxFacts syntaxFacts, SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsSkippedTokensTrivia(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAwaitKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGlobalNamespaceKeyword(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsCharacterLiteral(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsStringLiteral(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsIdentifier(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsHashToken(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsInterpolatedStringTextToken(ISyntaxFacts syntaxFacts, SyntaxToken token);
    [ExtensionAttribute]
public static bool IsGenericName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIdentifierName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsQualifiedName(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTupleType(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsCharacterLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsDefaultLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFalseLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNumericLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNullLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsStringLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTrueLiteralExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsArrayCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAwaitExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsBaseExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConditionalAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsImplicitArrayCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsImplicitObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIndexExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolatedStringExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolation(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterpolatedStringText(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInvocationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsTypeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsNotTypeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIsPatternExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalAndExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalOrExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLogicalNotExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsObjectCreationExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParenthesizedExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsQueryExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRangeExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRefExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsSimpleMemberAccessExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThisExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThrowExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTupleExpression(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool ContainsGlobalStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAndPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsConstantPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsDeclarationPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsNotPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsOrPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParenthesizedPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsRecursivePattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypePattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsVarPattern(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsExpressionStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsForEachStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIfStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLocalDeclarationStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLocalFunctionStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsLockStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsReturnStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsThrowStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsUsingStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsYieldReturnStatement(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsAttribute(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsClassDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsGlobalAttribute(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsInterfaceDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsParameter(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeConstraint(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsVariableDeclarator(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsFieldDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsPropertyDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsStructDeclaration(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsTypeArgumentList(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsEqualsValueClause(ISyntaxFacts syntaxFacts, SyntaxNode node);
    [ExtensionAttribute]
public static bool IsIndexerMemberCref(ISyntaxFacts syntaxFacts, SyntaxNode node);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxFactsService {
    public abstract virtual bool IsInNonUserCode(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<SyntaxNode>> GetSelectedFieldsAndPropertiesAsync(SyntaxTree syntaxTree, TextSpan textSpan, bool allowPartialSelection, CancellationToken cancellationToken);
    public abstract virtual void AddFirstMissingCloseBrace(SyntaxNode root, TContextNode contextNode, SyntaxNode& newRoot, TContextNode& newContextNode);
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxKinds {
    public int ConflictMarkerTrivia { get; }
    public int DisabledTextTrivia { get; }
    public int EndOfLineTrivia { get; }
    public int SkippedTokensTrivia { get; }
    public int WhitespaceTrivia { get; }
    public int SingleLineCommentTrivia { get; }
    public Nullable`1<int> MultiLineCommentTrivia { get; }
    public int SingleLineDocCommentTrivia { get; }
    public Nullable`1<int> MultiLineDocCommentTrivia { get; }
    public Nullable`1<int> ShebangDirectiveTrivia { get; }
    public int IfDirectiveTrivia { get; }
    public int AwaitKeyword { get; }
    public int AsyncKeyword { get; }
    public int DelegateKeyword { get; }
    public int GlobalKeyword { get; }
    public int IfKeyword { get; }
    public Nullable`1<int> GlobalStatement { get; }
    public int TrueKeyword { get; }
    public int FalseKeyword { get; }
    public int CharacterLiteralToken { get; }
    public int StringLiteralToken { get; }
    public Nullable`1<int> SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> MultiLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8StringLiteralToken { get; }
    public Nullable`1<int> Utf8SingleLineRawStringLiteralToken { get; }
    public Nullable`1<int> Utf8MultiLineRawStringLiteralToken { get; }
    public int CloseBraceToken { get; }
    public int ColonToken { get; }
    public int DotToken { get; }
    public int EndOfFileToken { get; }
    public int HashToken { get; }
    public int IdentifierToken { get; }
    public int InterpolatedStringTextToken { get; }
    public int QuestionToken { get; }
    public int XmlTextLiteralToken { get; }
    public int GenericName { get; }
    public int IdentifierName { get; }
    public int QualifiedName { get; }
    public int TupleType { get; }
    public int CharacterLiteralExpression { get; }
    public int DefaultLiteralExpression { get; }
    public int FalseLiteralExpression { get; }
    public int NullLiteralExpression { get; }
    public int NumericLiteralExpression { get; }
    public int StringLiteralExpression { get; }
    public int TrueLiteralExpression { get; }
    public int AnonymousObjectCreationExpression { get; }
    public int ArrayCreationExpression { get; }
    public int AwaitExpression { get; }
    public int BaseExpression { get; }
    public int ConditionalAccessExpression { get; }
    public int ConditionalExpression { get; }
    public Nullable`1<int> ImplicitArrayCreationExpression { get; }
    public Nullable`1<int> ImplicitObjectCreationExpression { get; }
    public Nullable`1<int> IndexExpression { get; }
    public int InterpolatedStringExpression { get; }
    public int InvocationExpression { get; }
    public int IsTypeExpression { get; }
    public Nullable`1<int> IsNotTypeExpression { get; }
    public Nullable`1<int> IsPatternExpression { get; }
    public int LogicalAndExpression { get; }
    public int LogicalOrExpression { get; }
    public int LogicalNotExpression { get; }
    public int ObjectCreationExpression { get; }
    public int ParenthesizedExpression { get; }
    public int QueryExpression { get; }
    public Nullable`1<int> RangeExpression { get; }
    public Nullable`1<int> RefExpression { get; }
    public int ReferenceEqualsExpression { get; }
    public int ReferenceNotEqualsExpression { get; }
    public int SimpleMemberAccessExpression { get; }
    public int TernaryConditionalExpression { get; }
    public int ThisExpression { get; }
    public Nullable`1<int> ThrowExpression { get; }
    public int TupleExpression { get; }
    public Nullable`1<int> AndPattern { get; }
    public Nullable`1<int> ConstantPattern { get; }
    public Nullable`1<int> DeclarationPattern { get; }
    public Nullable`1<int> NotPattern { get; }
    public Nullable`1<int> OrPattern { get; }
    public Nullable`1<int> ParenthesizedPattern { get; }
    public Nullable`1<int> RecursivePattern { get; }
    public Nullable`1<int> TypePattern { get; }
    public Nullable`1<int> VarPattern { get; }
    public int ExpressionStatement { get; }
    public int ForEachStatement { get; }
    public int IfStatement { get; }
    public int LocalDeclarationStatement { get; }
    public Nullable`1<int> LocalFunctionStatement { get; }
    public int LockStatement { get; }
    public int ReturnStatement { get; }
    public int ThrowStatement { get; }
    public int UsingStatement { get; }
    public int YieldReturnStatement { get; }
    public int Attribute { get; }
    public int ClassDeclaration { get; }
    public int InterfaceDeclaration { get; }
    public Nullable`1<int> RecordDeclaration { get; }
    public Nullable`1<int> RecordStructDeclaration { get; }
    public Nullable`1<int> StructDeclaration { get; }
    public int Parameter { get; }
    public int TypeConstraint { get; }
    public int VariableDeclarator { get; }
    public int FieldDeclaration { get; }
    public int PropertyDeclaration { get; }
    public int IncompleteMember { get; }
    public int TypeArgumentList { get; }
    public int ParameterList { get; }
    public int EqualsValueClause { get; }
    public int Interpolation { get; }
    public int InterpolatedStringText { get; }
    public Nullable`1<int> IndexerMemberCref { get; }
    public abstract virtual TSyntaxKind Convert(int kind);
    public abstract virtual int get_ConflictMarkerTrivia();
    public abstract virtual int get_DisabledTextTrivia();
    public abstract virtual int get_EndOfLineTrivia();
    public abstract virtual int get_SkippedTokensTrivia();
    public abstract virtual int get_WhitespaceTrivia();
    public abstract virtual int get_SingleLineCommentTrivia();
    public abstract virtual Nullable`1<int> get_MultiLineCommentTrivia();
    public abstract virtual int get_SingleLineDocCommentTrivia();
    public abstract virtual Nullable`1<int> get_MultiLineDocCommentTrivia();
    public abstract virtual Nullable`1<int> get_ShebangDirectiveTrivia();
    public abstract virtual int get_IfDirectiveTrivia();
    public abstract virtual int get_AwaitKeyword();
    public abstract virtual int get_AsyncKeyword();
    public abstract virtual int get_DelegateKeyword();
    public abstract virtual int get_GlobalKeyword();
    public abstract virtual int get_IfKeyword();
    public abstract virtual Nullable`1<int> get_GlobalStatement();
    public abstract virtual int get_TrueKeyword();
    public abstract virtual int get_FalseKeyword();
    public abstract virtual int get_CharacterLiteralToken();
    public abstract virtual int get_StringLiteralToken();
    public abstract virtual Nullable`1<int> get_SingleLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_MultiLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8StringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8SingleLineRawStringLiteralToken();
    public abstract virtual Nullable`1<int> get_Utf8MultiLineRawStringLiteralToken();
    public abstract virtual int get_CloseBraceToken();
    public abstract virtual int get_ColonToken();
    public abstract virtual int get_DotToken();
    public abstract virtual int get_EndOfFileToken();
    public abstract virtual int get_HashToken();
    public abstract virtual int get_IdentifierToken();
    public abstract virtual int get_InterpolatedStringTextToken();
    public abstract virtual int get_QuestionToken();
    public abstract virtual int get_XmlTextLiteralToken();
    public abstract virtual int get_GenericName();
    public abstract virtual int get_IdentifierName();
    public abstract virtual int get_QualifiedName();
    public abstract virtual int get_TupleType();
    public abstract virtual int get_CharacterLiteralExpression();
    public abstract virtual int get_DefaultLiteralExpression();
    public abstract virtual int get_FalseLiteralExpression();
    public abstract virtual int get_NullLiteralExpression();
    public abstract virtual int get_NumericLiteralExpression();
    public abstract virtual int get_StringLiteralExpression();
    public abstract virtual int get_TrueLiteralExpression();
    public abstract virtual int get_AnonymousObjectCreationExpression();
    public abstract virtual int get_ArrayCreationExpression();
    public abstract virtual int get_AwaitExpression();
    public abstract virtual int get_BaseExpression();
    public abstract virtual int get_ConditionalAccessExpression();
    public abstract virtual int get_ConditionalExpression();
    public abstract virtual Nullable`1<int> get_ImplicitArrayCreationExpression();
    public abstract virtual Nullable`1<int> get_ImplicitObjectCreationExpression();
    public abstract virtual Nullable`1<int> get_IndexExpression();
    public abstract virtual int get_InterpolatedStringExpression();
    public abstract virtual int get_InvocationExpression();
    public abstract virtual int get_IsTypeExpression();
    public abstract virtual Nullable`1<int> get_IsNotTypeExpression();
    public abstract virtual Nullable`1<int> get_IsPatternExpression();
    public abstract virtual int get_LogicalAndExpression();
    public abstract virtual int get_LogicalOrExpression();
    public abstract virtual int get_LogicalNotExpression();
    public abstract virtual int get_ObjectCreationExpression();
    public abstract virtual int get_ParenthesizedExpression();
    public abstract virtual int get_QueryExpression();
    public abstract virtual Nullable`1<int> get_RangeExpression();
    public abstract virtual Nullable`1<int> get_RefExpression();
    public abstract virtual int get_ReferenceEqualsExpression();
    public abstract virtual int get_ReferenceNotEqualsExpression();
    public abstract virtual int get_SimpleMemberAccessExpression();
    public abstract virtual int get_TernaryConditionalExpression();
    public abstract virtual int get_ThisExpression();
    public abstract virtual Nullable`1<int> get_ThrowExpression();
    public abstract virtual int get_TupleExpression();
    public abstract virtual Nullable`1<int> get_AndPattern();
    public abstract virtual Nullable`1<int> get_ConstantPattern();
    public abstract virtual Nullable`1<int> get_DeclarationPattern();
    public abstract virtual Nullable`1<int> get_NotPattern();
    public abstract virtual Nullable`1<int> get_OrPattern();
    public abstract virtual Nullable`1<int> get_ParenthesizedPattern();
    public abstract virtual Nullable`1<int> get_RecursivePattern();
    public abstract virtual Nullable`1<int> get_TypePattern();
    public abstract virtual Nullable`1<int> get_VarPattern();
    public abstract virtual int get_ExpressionStatement();
    public abstract virtual int get_ForEachStatement();
    public abstract virtual int get_IfStatement();
    public abstract virtual int get_LocalDeclarationStatement();
    public abstract virtual Nullable`1<int> get_LocalFunctionStatement();
    public abstract virtual int get_LockStatement();
    public abstract virtual int get_ReturnStatement();
    public abstract virtual int get_ThrowStatement();
    public abstract virtual int get_UsingStatement();
    public abstract virtual int get_YieldReturnStatement();
    public abstract virtual int get_Attribute();
    public abstract virtual int get_ClassDeclaration();
    public abstract virtual int get_InterfaceDeclaration();
    public abstract virtual Nullable`1<int> get_RecordDeclaration();
    public abstract virtual Nullable`1<int> get_RecordStructDeclaration();
    public abstract virtual Nullable`1<int> get_StructDeclaration();
    public abstract virtual int get_Parameter();
    public abstract virtual int get_TypeConstraint();
    public abstract virtual int get_VariableDeclarator();
    public abstract virtual int get_FieldDeclaration();
    public abstract virtual int get_PropertyDeclaration();
    public abstract virtual int get_IncompleteMember();
    public abstract virtual int get_TypeArgumentList();
    public abstract virtual int get_ParameterList();
    public abstract virtual int get_EqualsValueClause();
    public abstract virtual int get_Interpolation();
    public abstract virtual int get_InterpolatedStringText();
    public abstract virtual Nullable`1<int> get_IndexerMemberCref();
}
internal interface Microsoft.CodeAnalysis.LanguageService.ISyntaxKindsService {
}
internal interface Microsoft.CodeAnalysis.LanguageService.ITypeInferenceService {
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.LanguageService.PredefinedOperator : Enum {
    public int value__;
    public static PredefinedOperator None;
    public static PredefinedOperator Addition;
    public static PredefinedOperator BitwiseAnd;
    public static PredefinedOperator BitwiseOr;
    public static PredefinedOperator Complement;
    public static PredefinedOperator Concatenate;
    public static PredefinedOperator Decrement;
    public static PredefinedOperator Division;
    public static PredefinedOperator Equality;
    public static PredefinedOperator ExclusiveOr;
    public static PredefinedOperator Exponent;
    public static PredefinedOperator GreaterThan;
    public static PredefinedOperator GreaterThanOrEqual;
    public static PredefinedOperator Increment;
    public static PredefinedOperator Inequality;
    public static PredefinedOperator IntegerDivision;
    public static PredefinedOperator LeftShift;
    public static PredefinedOperator LessThan;
    public static PredefinedOperator LessThanOrEqual;
    public static PredefinedOperator Like;
    public static PredefinedOperator Modulus;
    public static PredefinedOperator Multiplication;
    public static PredefinedOperator RightShift;
    public static PredefinedOperator Subtraction;
    public static PredefinedOperator UnsignedRightShift;
}
internal enum Microsoft.CodeAnalysis.LanguageService.PredefinedType : Enum {
    public int value__;
    public static PredefinedType None;
    public static PredefinedType Boolean;
    public static PredefinedType Byte;
    public static PredefinedType Char;
    public static PredefinedType DateTime;
    public static PredefinedType Decimal;
    public static PredefinedType Double;
    public static PredefinedType Int16;
    public static PredefinedType Int32;
    public static PredefinedType Int64;
    public static PredefinedType Object;
    public static PredefinedType SByte;
    public static PredefinedType Single;
    public static PredefinedType String;
    public static PredefinedType UInt16;
    public static PredefinedType UInt32;
    public static PredefinedType UInt64;
    public static PredefinedType Void;
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.LanguageService.TypeInferenceInfo : ValueType {
    [CompilerGeneratedAttribute]
private ITypeSymbol <InferredType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParams>k__BackingField;
    public ITypeSymbol InferredType { get; }
    public bool IsParams { get; }
    public TypeInferenceInfo(ITypeSymbol type);
    public TypeInferenceInfo(ITypeSymbol type, bool isParams);
    [CompilerGeneratedAttribute]
public ITypeSymbol get_InferredType();
    [CompilerGeneratedAttribute]
public bool get_IsParams();
}
internal abstract class Microsoft.CodeAnalysis.LanguageService.TypeInferenceService.AbstractTypeInferenceService : object {
    private static ImmutableArray`1<string> s_booleanPrefixes;
    private static AbstractTypeInferenceService();
    protected abstract virtual AbstractTypeInferrer CreateTypeInferrer(SemanticModel semanticModel, CancellationToken cancellationToken);
    private static ImmutableArray`1<ITypeSymbol> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<ITypeSymbol> result, string nameOpt);
    private static ImmutableArray`1<TypeInferenceInfo> InferTypeBasedOnNameIfEmpty(SemanticModel semanticModel, ImmutableArray`1<TypeInferenceInfo> result, string nameOpt);
    private static ImmutableArray`1<ITypeSymbol> InferTypeBasedOnName(SemanticModel semanticModel, string name);
    private static bool MatchesBoolean(string name);
    private static bool Matches(string name, string prefix);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<ITypeSymbol> InferTypes(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, int position, string nameOpt, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(SemanticModel semanticModel, SyntaxNode expression, string nameOpt, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.LinkedFileDiffMergingSession : object {
    private Solution _oldSolution;
    private Solution _newSolution;
    private SolutionChanges _solutionChanges;
    public LinkedFileDiffMergingSession(Solution oldSolution, Solution newSolution, SolutionChanges solutionChanges);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeDiffsAsync>d__4")]
internal Task`1<LinkedFileMergeSessionResult> MergeDiffsAsync(IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<MergeLinkedDocumentGroupAsync>d__5")]
private Task`1<LinkedFileMergeResult> MergeLinkedDocumentGroupAsync(IEnumerable`1<DocumentId> allLinkedDocuments, IEnumerable`1<DocumentId> linkedDocumentGroup, LinkedFileDiffMergingSessionInfo sessionInfo, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.LinkedFileDiffMergingSession/<AddDocumentMergeChangesAsync>d__6")]
private static Task`1<ImmutableArray`1<TextChange>> AddDocumentMergeChangesAsync(Document oldDocument, Document newDocument, List`1<TextChange> cumulativeChanges, List`1<UnmergedDocumentChanges> unmergedChanges, LinkedFileGroupSessionInfo groupSessionInfo, IDocumentTextDifferencingService textDiffService, CancellationToken cancellationToken);
    private static IEnumerable`1<TextChange> MergeChangesWithMergeFailComments(IEnumerable`1<TextChange> mergedChanges, IEnumerable`1<TextChange> commentChanges, IList`1<TextSpan> mergeConflictResolutionSpans, LinkedFileGroupSessionInfo groupSessionInfo);
    private static IEnumerable`1<TextChange> NormalizeChanges(IEnumerable`1<TextChange> changes);
    [CompilerGeneratedAttribute]
private string <MergeDiffsAsync>b__4_1(DocumentId d);
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<DocumentId> <DocumentIds>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <MergedSourceText>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextSpan> <MergeConflictResolutionSpans>k__BackingField;
    public IEnumerable`1<DocumentId> DocumentIds { get; internal set; }
    public SourceText MergedSourceText { get; internal set; }
    public IEnumerable`1<TextSpan> MergeConflictResolutionSpans { get; }
    public bool HasMergeConflicts { get; }
    public LinkedFileMergeResult(IEnumerable`1<DocumentId> documentIds, SourceText mergedSourceText, IEnumerable`1<TextSpan> mergeConflictResolutionSpans);
    [CompilerGeneratedAttribute]
public IEnumerable`1<DocumentId> get_DocumentIds();
    [CompilerGeneratedAttribute]
internal void set_DocumentIds(IEnumerable`1<DocumentId> value);
    [CompilerGeneratedAttribute]
public SourceText get_MergedSourceText();
    [CompilerGeneratedAttribute]
internal void set_MergedSourceText(SourceText value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextSpan> get_MergeConflictResolutionSpans();
    public bool get_HasMergeConflicts();
}
internal class Microsoft.CodeAnalysis.LinkedFileMergeSessionResult : object {
    [CompilerGeneratedAttribute]
private Solution <MergedSolution>k__BackingField;
    private Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> _mergeConflictCommentSpans;
    public Solution MergedSolution { get; }
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> MergeConflictCommentSpans { get; }
    public LinkedFileMergeSessionResult(Solution mergedSolution, IEnumerable`1<LinkedFileMergeResult> fileMergeResults);
    [CompilerGeneratedAttribute]
public Solution get_MergedSolution();
    public Dictionary`2<DocumentId, IEnumerable`1<TextSpan>> get_MergeConflictCommentSpans();
}
internal static class Microsoft.CodeAnalysis.Logging.SolutionLogger : object {
    private static CountLogAggregator`1<string> s_logAggregator;
    private static SolutionLogger();
    public static void UseExistingPartialProjectState();
    public static void UseExistingFullProjectState();
    public static void CreatePartialProjectState();
    public static void UseExistingPartialSolution();
    public static void CreatePartialSolution();
    public static void ReportTelemetry();
}
internal class Microsoft.CodeAnalysis.MetadataReferenceManager : object {
    private static ConditionalWeakTable`2<ProjectState, WeakReference`1<Compilation>> s_compilationReferenceMap;
    private static object s_guard;
    private static MetadataReferenceManager();
    internal static Compilation GetCompilationForMetadataReference(ProjectState projectState, Compilation compilation);
    internal static bool TryGetCompilationForMetadataReference(ProjectState projectState, Compilation& referenceCompilation);
}
internal abstract class Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4 : object {
    protected abstract virtual bool IsMeaningfulBlock(SyntaxNode node);
    protected abstract virtual bool CanMoveToBlock(ILocalSymbol localSymbol, SyntaxNode currentBlock, SyntaxNode destinationBlock);
    protected abstract virtual SyntaxNode GetVariableDeclaratorSymbolNode(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual bool IsValidVariableDeclarator(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual SyntaxToken GetIdentifierOfVariableDeclarator(TVariableDeclaratorSyntax variableDeclarator);
    protected abstract virtual Task`1<bool> TypesAreCompatibleAsync(Document document, ILocalSymbol localSymbol, TLocalDeclarationStatementSyntax declarationStatement, SyntaxNode right, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<CanMoveDeclarationNearReferenceAsync>d__6")]
public sealed virtual Task`1<bool> CanMoveDeclarationNearReferenceAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<ComputeStateAsync>d__7")]
private Task`1<State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax>> ComputeStateAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<MoveDeclarationNearReferenceAsync>d__8")]
public sealed virtual Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<MoveDeclarationToFirstReferenceAsync>d__9")]
private static Task MoveDeclarationToFirstReferenceAsync(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, SyntaxEditor editor, SyntaxAnnotation warningAnnotation, CancellationToken cancellationToken);
    private static void MergeDeclarationAndAssignment(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, SyntaxEditor editor, SyntaxAnnotation warningAnnotation);
    private static ImmutableArray`1<SyntaxTrivia> GetMergedTrivia(IFileBannerFactsService bannerService, TStatementSyntax statement1, TStatementSyntax statement2);
    private bool CrossesMeaningfulBlock(State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.MoveDeclarationNearReference.AbstractMoveDeclarationNearReferenceService`4/<CanMergeDeclarationAndAssignmentAsync>d__13")]
private Task`1<bool> CanMergeDeclarationAndAssignmentAsync(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state, CancellationToken cancellationToken);
    private static TLocalDeclarationStatementSyntax CreateMergedDeclarationStatement(Document document, State<TService, TStatementSyntax, TLocalDeclarationStatementSyntax, TVariableDeclaratorSyntax> state);
}
internal interface Microsoft.CodeAnalysis.MoveDeclarationNearReference.IMoveDeclarationNearReferenceService {
    public abstract virtual Task`1<bool> CanMoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> MoveDeclarationNearReferenceAsync(Document document, SyntaxNode localDeclarationStatement, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.NamingStyles.NamingStyle : ValueType {
    [CompilerGeneratedAttribute]
private Guid <ID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Suffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WordSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private Capitalization <CapitalizationScheme>k__BackingField;
    private static Func`3<string, TextSpan, bool> s_firstCharIsLowerCase;
    private static Func`3<string, TextSpan, bool> s_firstCharIsUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllUpperCase;
    private static Func`3<string, TextSpan, bool> s_wordIsAllLowerCase;
    [DataMemberAttribute]
public Guid ID { get; public set; }
    [DataMemberAttribute]
public string Name { get; public set; }
    [DataMemberAttribute]
public string Prefix { get; public set; }
    [DataMemberAttribute]
public string Suffix { get; public set; }
    [DataMemberAttribute]
public string WordSeparator { get; public set; }
    [DataMemberAttribute]
public Capitalization CapitalizationScheme { get; public set; }
    public bool ShouldReuseInSerialization { get; }
    public NamingStyle(Guid id, string name, string prefix, string suffix, string wordSeparator, Capitalization capitalizationScheme);
    private static NamingStyle();
    [CompilerGeneratedAttribute]
public Guid get_ID();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ID(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Prefix(string value);
    [CompilerGeneratedAttribute]
public string get_Suffix();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Suffix(string value);
    [CompilerGeneratedAttribute]
public string get_WordSeparator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_WordSeparator(string value);
    [CompilerGeneratedAttribute]
public Capitalization get_CapitalizationScheme();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_CapitalizationScheme(Capitalization value);
    public string CreateName(ImmutableArray`1<string> words);
    private IEnumerable`1<string> ApplyCapitalization(IEnumerable`1<string> words);
    private string CapitalizeFirstLetter(string word);
    private string DecapitalizeFirstLetter(string word);
    public bool IsNameCompliant(string name, String& failureReason);
    private WordSpanEnumerable GetWordSpans(string name, TextSpan nameSpan);
    private static string Substring(string name, TextSpan wordSpan);
    private bool CheckAllWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> wordCheck, string resourceId, String& reason);
    private bool CheckPascalCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllUpper(string name, TextSpan nameSpan, String& reason);
    private bool CheckAllLower(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstAndRestWords(string name, TextSpan nameSpan, Func`3<string, TextSpan, bool> firstWordCheck, Func`3<string, TextSpan, bool> restWordCheck, string firstResourceId, string restResourceId, String& reason);
    private bool CheckCamelCase(string name, TextSpan nameSpan, String& reason);
    private bool CheckFirstUpper(string name, TextSpan nameSpan, String& reason);
    private static bool DoesCharacterHaveCasing(char c);
    private string CreateCompliantNameDirectly(string name);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.NamingStyles.NamingStyle/<MakeCompliant>d__45")]
public IEnumerable`1<string> MakeCompliant(string name);
    private string CreateCompliantNameReusingPartialPrefixesAndSuffixes(string name);
    public static string StripCommonPrefixes(string name, String& prefix);
    private string FinishFixingName(string name);
    private string EnsureSuffix(string name);
    private string EnsurePrefix(string name);
    internal XElement CreateXElement();
    internal static NamingStyle FromXElement(XElement namingStyleElement);
    public sealed virtual bool get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    public static NamingStyle ReadFrom(ObjectReader reader);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NamingStyle left, NamingStyle right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NamingStyle left, NamingStyle right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NamingStyle other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Notification.GlobalOperationNotificationService : object {
    private object _gate;
    private HashSet`1<IDisposable> _registrations;
    private HashSet`1<string> _operations;
    private TaskQueue _eventQueue;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Started;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler Stopped;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public GlobalOperationNotificationService(IAsynchronousOperationListenerProvider listenerProvider);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_Started(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_Started(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void add_Stopped(EventHandler value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual void remove_Stopped(EventHandler value);
    private void RaiseGlobalOperationStarted();
    private void RaiseGlobalOperationStopped();
    public sealed virtual IDisposable Start(string operation);
    private void Done(GlobalOperationRegistration registration);
    protected virtual override void Finalize();
    [CompilerGeneratedAttribute]
private void <RaiseGlobalOperationStarted>b__11_0();
    [CompilerGeneratedAttribute]
private void <RaiseGlobalOperationStopped>b__12_0();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Notification.IGlobalOperationNotificationService {
    [CompilerGeneratedAttribute]
public abstract virtual void add_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Started(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_Stopped(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_Stopped(EventHandler value);
    public abstract virtual IDisposable Start(string operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.OperationExtensions : object {
    [ExtensionAttribute]
public static bool IsTargetOfObjectMemberInitializer(IOperation operation);
    [ExtensionAttribute]
public static ValueUsageInfo GetValueUsageInfo(IOperation operation, ISymbol containingSymbol);
    [ExtensionAttribute]
public static RefKind GetRefKind(IReturnOperation operation, ISymbol containingSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IMethodSymbol TryGetContainingAnonymousFunctionOrLocalFunction(IOperation operation);
    [ExtensionAttribute]
public static bool IsInLeftOfDeconstructionAssignment(IOperation operation, IDeconstructionAssignmentOperation& deconstructionAssignment);
    [ExtensionAttribute]
public static bool IsAnyCompoundAssignment(IOperation operation);
    [ExtensionAttribute]
public static bool IsInsideCatchRegion(IOperation operation, ControlFlowGraph cfg);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(IOperation operationBlock, Func`2<IOperation, bool> predicate, IOperation& foundOperation);
    [ExtensionAttribute]
public static bool HasAnyOperationDescendant(ImmutableArray`1<IOperation> operationBlocks, OperationKind kind);
    [ExtensionAttribute]
public static bool IsNumericLiteral(IOperation operation);
    [ExtensionAttribute]
public static bool IsNullLiteral(IOperation operand);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static IOperation WalkDownConversion(IOperation operation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Options.ClientSettingsStorageLocation : OptionStorageLocation2 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<string, string> _keyNameFromLanguageName;
    public bool IsMachineLocal { get; }
    public ClientSettingsStorageLocation(string keyName);
    public ClientSettingsStorageLocation(Func`2<string, string> keyNameFromLanguageName);
    public abstract virtual bool get_IsMachineLocal();
    public string GetKeyNameForLanguage(string languageName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Options.DocumentOptionSet : OptionSet {
    private OptionSet _underlyingOptions;
    [NullableAttribute("2")]
private StructuredAnalyzerConfigOptions _configOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<OptionKey, object> _values;
    private string _language;
    internal string Language { get; }
    internal DocumentOptionSet(StructuredAnalyzerConfigOptions configOptions, OptionSet underlyingOptions, string language);
    private DocumentOptionSet(StructuredAnalyzerConfigOptions configOptions, OptionSet underlyingOptions, string language, ImmutableDictionary`2<OptionKey, object> values);
    internal string get_Language();
    [NullableContextAttribute("2")]
private protected virtual object GetOptionCore(OptionKey optionKey);
    [NullableContextAttribute("2")]
private bool TryGetAnalyzerConfigOption(OptionKey option, Object& value);
    public T GetOption(PerLanguageOption`1<T> option);
    internal T GetOption(PerLanguageOption2`1<T> option);
    public virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    public DocumentOptionSet WithChangedOption(PerLanguageOption`1<T> option, T value);
    internal DocumentOptionSet WithChangedOption(PerLanguageOption2`1<T> option, T value);
    private protected virtual AnalyzerConfigOptions CreateAnalyzerConfigOptions(IEditorConfigOptionMappingService optionService, string language);
    internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Options.EditorConfigFileGenerator : object {
    public static string Generate(ImmutableArray`1<ValueTuple`2<string, ImmutableArray`1<IOption>>> groupedOptions, OptionSet optionSet, string language);
    private static void AppendOptionsToEditorConfig(OptionSet optionSet, string feature, ImmutableArray`1<IOption> options, string language, StringBuilder editorconfig);
    public static void AppendNamingStylePreferencesToEditorConfig(IEnumerable`1<NamingRule> namingRules, StringBuilder editorconfig, string language);
    public static void AppendNamingStylePreferencesToEditorConfig(NamingStylePreferences namingStylePreferences, string language, StringBuilder editorconfig);
    public static void AppendNamingStylePreferencesToEditorConfig(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles, ImmutableArray`1<SerializableNamingRule> serializableNamingRules, string language, StringBuilder editorconfig);
    [NullableContextAttribute("0")]
private static ImmutableDictionary`2<Guid, string> AssignNamesToNamingStyleElements(ImmutableArray`1<SymbolSpecification> symbolSpecifications, ImmutableArray`1<NamingStyle> namingStyles);
    private static ImmutableDictionary`2<SerializableNamingRule, string> AssignNamesToNamingStyleRules(ImmutableArray`1<SerializableNamingRule> namingRules, ImmutableDictionary`2<Guid, string> serializedNameMap);
    [CompilerGeneratedAttribute]
internal static string <AppendOptionsToEditorConfig>g__GetEditorConfigString|1_0(IOption option, IEditorConfigStorageLocation2 editorConfigLocation, <>c__DisplayClass1_0& );
    [CompilerGeneratedAttribute]
internal static string <AssignNamesToNamingStyleElements>g__ToSnakeCaseName|5_0(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Options.IEditorConfigOptionMappingService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.EditorConfigOptionMappingService : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<string, ValueTuple`2<IOption, IEditorConfigStorageLocation2>> s_emptyEditorConfigKeysToOptions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ValueTuple`2<IOption, IEditorConfigStorageLocation2>> _neutralEditorConfigKeysToOptions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ValueTuple`2<IOption, IEditorConfigStorageLocation2>> _csharpEditorConfigKeysToOptions;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ValueTuple`2<IOption, IEditorConfigStorageLocation2>> _visualBasicEditorConfigKeysToOptions;
    private ImmutableDictionary`2<string, Lazy`1<ImmutableHashSet`1<IOption>>> _serializableOptionsByLanguage;
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public EditorConfigOptionMappingService(IEnumerable`1<Lazy`2<IOptionProvider, LanguageMetadata>> optionProviders);
    private static EditorConfigOptionMappingService();
    private static ImmutableDictionary`2<string, Lazy`1<ImmutableHashSet`1<IOption>>> CreateLazySerializableOptionsByLanguage(IEnumerable`1<Lazy`2<IOptionProvider, LanguageMetadata>> optionProviders);
    internal static bool IsSolutionOptionProvider(IOptionProvider provider);
    [NullableContextAttribute("2")]
public sealed virtual bool TryMapEditorConfigKeyToOption(string key, string language, IEditorConfigStorageLocation2& storageLocation, OptionKey& optionKey);
    public ImmutableHashSet`1<IOption> GetRegisteredSerializableOptions(ImmutableHashSet`1<string> languages);
    [CompilerGeneratedAttribute]
internal static ImmutableHashSet`1<IOption> <CreateLazySerializableOptionsByLanguage>g__ComputeSerializableOptionsFromProviders|6_0(ImmutableArray`1<Lazy`2<IOptionProvider, LanguageMetadata>> lazyProvidersAndMetadata);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<IOption, IEditorConfigStorageLocation2> <TryMapEditorConfigKeyToOption>g__MapToOptionIgnorePerLanguage|8_0(EditorConfigOptionMappingService service, string key, string language);
    [CompilerGeneratedAttribute]
private ImmutableHashSet`1<IOption> <GetRegisteredSerializableOptions>g__GetSerializableOptionsForLanguage|9_0(string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<string, Optional`1<bool>> s_parseBool;
    private static Func`2<bool, string> s_getBoolEditorConfigStringForValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<string, Optional`1<int>> s_parseInt32;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`2<string, Optional`1<string>> s_parseString;
    private static Func`2<int, string> s_getInt32EditorConfigStringForValue;
    private static Func`2<string, string> s_getStringEditorConfigStringForValue;
    private static EditorConfigStorageLocation();
    public static EditorConfigStorageLocation`1<bool> ForBoolOption(string keyName);
    public static EditorConfigStorageLocation`1<int> ForInt32Option(string keyName);
    public static EditorConfigStorageLocation`1<string> ForStringOption(string keyName, string emptyStringRepresentation);
    public static EditorConfigStorageLocation`1<CodeStyleOption2`1<bool>> ForBoolCodeStyleOption(string keyName, CodeStyleOption2`1<bool> defaultValue);
    public static EditorConfigStorageLocation`1<CodeStyleOption2`1<string>> ForStringCodeStyleOption(string keyName, CodeStyleOption2`1<string> defaultValue);
    [NullableContextAttribute("0")]
private static Optional`1<bool> ParseBool(string str);
    private static string GetBoolEditorConfigStringForValue(bool value);
    [NullableContextAttribute("0")]
private static Optional`1<int> ParseInt32(string str);
    private static Optional`1<string> ParseString(string str);
    private static string GetInt32EditorConfigStringForValue(int value);
    private static string GetStringEditorConfigStringForValue(string value);
    private static Optional`1<CodeStyleOption2`1<bool>> ParseBoolCodeStyleOption(string str, CodeStyleOption2`1<bool> defaultValue);
    private static string GetBoolCodeStyleOptionEditorConfigStringForValue(CodeStyleOption2`1<bool> value, CodeStyleOption2`1<bool> defaultValue);
    private static Optional`1<CodeStyleOption2`1<string>> ParseStringCodeStyleOption(string str, CodeStyleOption2`1<string> defaultValue);
    private static string GetStringCodeStyleOptionEditorConfigStringForValue(CodeStyleOption2`1<string> value, CodeStyleOption2`1<string> defaultValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.EditorConfigStorageLocation`1 : OptionStorageLocation2 {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<string, Type, Optional`1<T>> _parseValue;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<T, OptionSet, string> _getEditorConfigStringForValue;
    public string KeyName { get; }
    public EditorConfigStorageLocation`1(string keyName, Func`2<string, Optional`1<T>> parseValue, Func`2<T, string> getEditorConfigStringForValue);
    public EditorConfigStorageLocation`1(string keyName, Func`2<string, Optional`1<T>> parseValue, Func`2<OptionSet, string> getEditorConfigStringForValue);
    private EditorConfigStorageLocation`1(string keyName, Func`2<string, Optional`1<T>> parseValue, Func`3<T, OptionSet, string> getEditorConfigStringForValue);
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyName();
    public sealed virtual bool TryGetOption(StructuredAnalyzerConfigOptions options, Type type, Object& result);
    internal bool TryGetOption(string value, Type type, T& result);
    public string GetEditorConfigStringValue(T value, OptionSet optionSet);
    private sealed virtual override string Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigString(object value, OptionSet optionSet);
    private sealed virtual override string Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2.GetEditorConfigStringValue(object value, OptionSet optionSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute("Microsoft.CodeAnalysis.Options.IGlobalOptionService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.GlobalOptionService : object {
    [NullableAttribute("2")]
private IWorkspaceThreadingService _workspaceThreadingService;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Lazy`1<IOptionPersisterProvider>> _optionPersisterProviders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<Workspace> _registeredWorkspaces;
    private object _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<OptionKey, object> _getOption;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IOptionPersister> _lazyOptionPersisters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<OptionKey, object> _currentValues;
    private ImmutableHashSet`1<OptionKey> _changedOptionKeys;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<OptionChangedEventArgs> OptionChanged;
    [ImportingConstructorAttribute]
public GlobalOptionService(IWorkspaceThreadingService workspaceThreadingService, IEnumerable`1<Lazy`1<IOptionPersisterProvider>> optionPersisters);
    private ImmutableArray`1<IOptionPersister> GetOptionPersisters();
    [NullableContextAttribute("2")]
private static object LoadOptionFromPersisterOrGetDefault(OptionKey optionKey, ImmutableArray`1<IOptionPersister> persisters);
    public sealed virtual T GetOption(Option2`1<T> option);
    public sealed virtual T GetOption(PerLanguageOption2`1<T> option, string language);
    [NullableContextAttribute("2")]
public sealed virtual object GetOption(OptionKey optionKey);
    [NullableContextAttribute("0")]
public sealed virtual ImmutableArray`1<object> GetOptions(ImmutableArray`1<OptionKey> optionKeys);
    [NullableContextAttribute("2")]
private object GetOption_NoLock(OptionKey optionKey, ImmutableArray`1<IOptionPersister> persisters);
    [NullableContextAttribute("2")]
private void SetOptionCore(OptionKey optionKey, object newValue);
    [NullableContextAttribute("2")]
public sealed virtual void SetGlobalOption(OptionKey optionKey, object value);
    [NullableContextAttribute("0")]
public sealed virtual void SetGlobalOptions(ImmutableArray`1<OptionKey> optionKeys, ImmutableArray`1<object> values);
    public sealed virtual void SetOptions(OptionSet optionSet, IEnumerable`1<OptionKey> optionKeys);
    [NullableContextAttribute("2")]
private static void PersistOption(ImmutableArray`1<IOptionPersister> persisters, OptionKey optionKey, object value);
    [NullableContextAttribute("2")]
public sealed virtual void RefreshOption(OptionKey optionKey, object newValue);
    private void UpdateRegisteredWorkspacesAndRaiseEvents(List`1<OptionChangedEventArgs> changedOptions);
    private void RaiseOptionChangedEvent(List`1<OptionChangedEventArgs> changedOptions);
    public sealed virtual void RegisterWorkspace(Workspace workspace);
    public sealed virtual void UnregisterWorkspace(Workspace workspace);
    [CompilerGeneratedAttribute]
public sealed virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static ImmutableArray`1<IOptionPersister> <GetOptionPersisters>g__GetOptionPersistersSlow|9_0(IWorkspaceThreadingService workspaceThreadingService, ImmutableArray`1<Lazy`1<IOptionPersisterProvider>> persisterProviders, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Options.GlobalOptionService/<<GetOptionPersisters>g__GetOptionPersistersAsync|9_1>d")]
[CompilerGeneratedAttribute]
internal static Task`1<ImmutableArray`1<IOptionPersister>> <GetOptionPersisters>g__GetOptionPersistersAsync|9_1(ImmutableArray`1<Lazy`1<IOptionPersisterProvider>> persisterProviders, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Options.IEditorConfigOptionMappingService {
    [NullableContextAttribute("2")]
public abstract virtual bool TryMapEditorConfigKeyToOption(string key, string language, IEditorConfigStorageLocation2& storageLocation, OptionKey& optionKey);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation {
    public abstract virtual bool TryGetOption(StructuredAnalyzerConfigOptions options, Type type, Object& value);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IEditorConfigStorageLocation2 {
    public string KeyName { get; }
    public abstract virtual string get_KeyName();
    public abstract virtual string GetEditorConfigString(object value, OptionSet optionSet);
    public abstract virtual string GetEditorConfigStringValue(object value, OptionSet optionSet);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.IGlobalOptionService {
    public abstract virtual T GetOption(Option2`1<T> option);
    public abstract virtual T GetOption(PerLanguageOption2`1<T> option, string languageName);
    [NullableContextAttribute("2")]
public abstract virtual object GetOption(OptionKey optionKey);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<object> GetOptions(ImmutableArray`1<OptionKey> optionKeys);
    public abstract virtual void SetOptions(OptionSet optionSet, IEnumerable`1<OptionKey> optionKeys);
    [NullableContextAttribute("2")]
public abstract virtual void SetGlobalOption(OptionKey optionKey, object value);
    [NullableContextAttribute("0")]
public abstract virtual void SetGlobalOptions(ImmutableArray`1<OptionKey> optionKeys, ImmutableArray`1<object> values);
    [CompilerGeneratedAttribute]
public abstract virtual void add_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OptionChanged(EventHandler`1<OptionChangedEventArgs> value);
    [NullableContextAttribute("2")]
public abstract virtual void RefreshOption(OptionKey optionKey, object newValue);
    public abstract virtual void RegisterWorkspace(Workspace workspace);
    public abstract virtual void UnregisterWorkspace(Workspace workspace);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.ILegacyGlobalOptionsWorkspaceService {
    public bool RazorUseTabs { get; }
    public int RazorTabSize { get; }
    public bool GenerateOverrides { get; public set; }
    public bool InlineHintsOptionsDisplayAllOverride { get; public set; }
    public CleanCodeGenerationOptionsProvider CleanCodeGenerationOptionsProvider { get; }
    public abstract virtual bool get_RazorUseTabs();
    public abstract virtual int get_RazorTabSize();
    public abstract virtual bool get_GenerateOverrides();
    public abstract virtual void set_GenerateOverrides(bool value);
    public abstract virtual bool get_InlineHintsOptionsDisplayAllOverride();
    public abstract virtual void set_InlineHintsOptionsDisplayAllOverride(bool value);
    public abstract virtual bool GetGenerateEqualsAndGetHashCodeFromMembersGenerateOperators(string language);
    public abstract virtual void SetGenerateEqualsAndGetHashCodeFromMembersGenerateOperators(string language, bool value);
    public abstract virtual bool GetGenerateEqualsAndGetHashCodeFromMembersImplementIEquatable(string language);
    public abstract virtual void SetGenerateEqualsAndGetHashCodeFromMembersImplementIEquatable(string language, bool value);
    public abstract virtual bool GetGenerateConstructorFromMembersOptionsAddNullChecks(string language);
    public abstract virtual void SetGenerateConstructorFromMembersOptionsAddNullChecks(string language, bool value);
    public abstract virtual CleanCodeGenerationOptionsProvider get_CleanCodeGenerationOptionsProvider();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Options.ILegacyWorkspaceOptionService {
    public IGlobalOptionService GlobalOptions { get; }
    public abstract virtual IGlobalOptionService get_GlobalOptions();
    public abstract virtual void RegisterWorkspace(Workspace workspace);
    public abstract virtual void UnregisterWorkspace(Workspace workspace);
    [NullableContextAttribute("2")]
public abstract virtual object GetOption(OptionKey key);
    public abstract virtual void SetOptions(OptionSet optionSet, IEnumerable`1<OptionKey> optionKeys);
}
[NullableContextAttribute("1")]
public interface Microsoft.CodeAnalysis.Options.IOption {
    public string Feature { get; }
    public string Name { get; }
    public Type Type { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    public bool IsPerLanguage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    public abstract virtual string get_Feature();
    public abstract virtual string get_Name();
    public abstract virtual Type get_Type();
    [NullableContextAttribute("2")]
public abstract virtual object get_DefaultValue();
    public abstract virtual bool get_IsPerLanguage();
    public abstract virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
}
internal interface Microsoft.CodeAnalysis.Options.IOption2 {
    public OptionDefinition OptionDefinition { get; }
    public abstract virtual OptionDefinition get_OptionDefinition();
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Options.IOptionPersister {
    public abstract virtual bool TryFetch(OptionKey optionKey, Object& value);
    public abstract virtual bool TryPersist(OptionKey optionKey, object value);
}
internal interface Microsoft.CodeAnalysis.Options.IOptionPersisterProvider {
    public abstract virtual ValueTask`1<IOptionPersister> GetOrCreatePersisterAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Options.IOptionWithGroup {
    [NullableAttribute("1")]
public OptionGroup Group { get; }
    [NullableContextAttribute("1")]
public abstract virtual OptionGroup get_Group();
}
internal interface Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption {
}
internal interface Microsoft.CodeAnalysis.Options.IPerLanguageValuedOption`1 {
}
internal interface Microsoft.CodeAnalysis.Options.ISingleValuedOption {
    [NullableAttribute("2")]
public string LanguageName { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_LanguageName();
}
internal interface Microsoft.CodeAnalysis.Options.ISingleValuedOption`1 {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.Options.ILegacyWorkspaceOptionService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Options.LegacyWorkspaceOptionService : object {
    [CompilerGeneratedAttribute]
private IGlobalOptionService <GlobalOptions>k__BackingField;
    public IGlobalOptionService GlobalOptions { get; }
    [ImportingConstructorAttribute]
[ObsoleteAttribute("This exported object must be obtained through the MEF export provider.", "True")]
public LegacyWorkspaceOptionService(IGlobalOptionService globalOptionService);
    [CompilerGeneratedAttribute]
public sealed virtual IGlobalOptionService get_GlobalOptions();
    public sealed virtual void RegisterWorkspace(Workspace workspace);
    public sealed virtual void UnregisterWorkspace(Workspace workspace);
    [NullableContextAttribute("2")]
public sealed virtual object GetOption(OptionKey key);
    public sealed virtual void SetOptions(OptionSet optionSet, IEnumerable`1<OptionKey> optionKeys);
}
internal class Microsoft.CodeAnalysis.Options.LocalClientSettingsStorageLocation : ClientSettingsStorageLocation {
    public bool IsMachineLocal { get; }
    [NullableContextAttribute("1")]
public LocalClientSettingsStorageLocation(string keyName);
    public LocalClientSettingsStorageLocation(Func`2<string, string> keyNameFromLanguageName);
    public virtual bool get_IsMachineLocal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.LocalUserProfileStorageLocation : OptionStorageLocation2 {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    public string KeyName { get; }
    public LocalUserProfileStorageLocation(string keyName);
    [CompilerGeneratedAttribute]
public string get_KeyName();
}
internal class Microsoft.CodeAnalysis.Options.NamingStylePreferenceEditorConfigStorageLocation : OptionStorageLocation2 {
    [NullableContextAttribute("1")]
public sealed virtual bool TryGetOption(StructuredAnalyzerConfigOptions options, Type type, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Options.Option`1 : object {
    private OptionDefinition _optionDefinition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation> <StorageLocations>k__BackingField;
    public string Feature { get; }
    internal OptionGroup Group { get; }
    public string Name { get; }
    public T DefaultValue { get; }
    public Type Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    private OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.OptionDefinition { get; }
    [NullableAttribute("2")]
private string Microsoft.CodeAnalysis.Options.ISingleValuedOption.LanguageName { get; }
    [ObsoleteAttribute("Use a constructor that specifies an explicit default value.")]
public Option`1(string feature, string name);
    public Option`1(string feature, string name, T defaultValue);
    public Option`1(string feature, string name, T defaultValue, OptionStorageLocation[] storageLocations);
    internal Option`1(string feature, string name, T defaultValue, OptionStorageLocation storageLocation);
    internal Option`1(string feature, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation> storageLocations);
    internal Option`1(string feature, OptionGroup group, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation> storageLocations);
    internal Option`1(OptionDefinition optionDefinition, ImmutableArray`1<OptionStorageLocation> storageLocations);
    public sealed virtual string get_Feature();
    internal OptionGroup get_Group();
    public sealed virtual string get_Name();
    public T get_DefaultValue();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
    private sealed virtual override OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.get_Group();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_OptionDefinition();
    [NullableContextAttribute("2")]
private sealed virtual override string Microsoft.CodeAnalysis.Options.ISingleValuedOption.get_LanguageName();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IEquatable<Microsoft.CodeAnalysis.Options.IOption2>.Equals(IOption2 other);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
private bool Equals(IOption2 other);
    public static OptionKey op_Implicit(Option`1<T> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.Option2`1 : object {
    [CompilerGeneratedAttribute]
private OptionDefinition <OptionDefinition>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation2> <StorageLocations>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    public OptionDefinition OptionDefinition { get; }
    public string Feature { get; }
    internal OptionGroup Group { get; }
    public string Name { get; }
    public T DefaultValue { get; }
    public Type Type { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<OptionStorageLocation2> StorageLocations { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<OptionStorageLocation> Microsoft.CodeAnalysis.Options.IOption.StorageLocations { get; }
    private OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.OptionDefinition { get; }
    [NullableAttribute("2")]
public string LanguageName { get; }
    public Option2`1(string feature, string name, T defaultValue);
    public Option2`1(string feature, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    public Option2`1(string feature, OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    public Option2`1(string feature, OptionGroup group, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation2> storageLocations);
    public Option2`1(string feature, OptionGroup group, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation2> storageLocations, string languageName);
    public static Option`1<T> op_Explicit(Option2`1<T> option);
    [CompilerGeneratedAttribute]
public OptionDefinition get_OptionDefinition();
    public sealed virtual string get_Feature();
    internal OptionGroup get_Group();
    public sealed virtual string get_Name();
    public T get_DefaultValue();
    public sealed virtual Type get_Type();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<OptionStorageLocation2> get_StorageLocations();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    private sealed virtual override ImmutableArray`1<OptionStorageLocation> Microsoft.CodeAnalysis.Options.IOption.get_StorageLocations();
    private sealed virtual override OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.get_Group();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_OptionDefinition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual string get_LanguageName();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IOption2 other);
    public static OptionKey2 op_Implicit(Option2`1<T> option);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.OptionChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private OptionKey <OptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public OptionKey OptionKey { get; }
    public object Value { get; }
    [NullableAttribute("1")]
public IOption Option { get; }
    public string Language { get; }
    internal OptionChangedEventArgs(OptionKey optionKey, object value);
    [CompilerGeneratedAttribute]
public OptionKey get_OptionKey();
    [CompilerGeneratedAttribute]
public object get_Value();
    [NullableContextAttribute("1")]
public IOption get_Option();
    public string get_Language();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionDefinition : ValueType {
    [CompilerGeneratedAttribute]
private string <Feature>k__BackingField;
    [CompilerGeneratedAttribute]
private OptionGroup <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private object <DefaultValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Feature { get; }
    internal OptionGroup Group { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    public Type Type { get; }
    public OptionDefinition(string feature, OptionGroup group, string name, object defaultValue, Type type);
    [CompilerGeneratedAttribute]
public string get_Feature();
    [CompilerGeneratedAttribute]
internal OptionGroup get_Group();
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public object get_DefaultValue();
    [CompilerGeneratedAttribute]
public Type get_Type();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptionDefinition other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OptionDefinition left, OptionDefinition right);
    public static bool op_Inequality(OptionDefinition left, OptionDefinition right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.OptionGroup : object {
    public static OptionGroup Default;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    public string Description { get; }
    public int Priority { get; }
    public OptionGroup(string description, int priority);
    private static OptionGroup();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public int get_Priority();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
public class Microsoft.CodeAnalysis.Options.OptionKey : ValueType {
    [CompilerGeneratedAttribute]
private IOption <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public IOption Option { get; }
    [NullableAttribute("2")]
public string Language { get; }
    public OptionKey(IOption option, string language);
    [CompilerGeneratedAttribute]
public IOption get_Option();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Language();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptionKey other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OptionKey left, OptionKey right);
    public static bool op_Inequality(OptionKey left, OptionKey right);
    [CompilerGeneratedAttribute]
internal static bool <Equals>g__OptionEqual|8_0(IOption thisOption, IOption otherOption);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonDefaultableAttribute]
internal class Microsoft.CodeAnalysis.Options.OptionKey2 : ValueType {
    [CompilerGeneratedAttribute]
private IOption2 <Option>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    public IOption2 Option { get; }
    [NullableAttribute("2")]
public string Language { get; }
    public OptionKey2(IPerLanguageValuedOption option, string language);
    public OptionKey2(ISingleValuedOption option);
    public static OptionKey op_Explicit(OptionKey2 optionKey);
    [CompilerGeneratedAttribute]
public IOption2 get_Option();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Language();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OptionKey2 other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static bool op_Equality(OptionKey2 left, OptionKey2 right);
    public static bool op_Inequality(OptionKey2 left, OptionKey2 right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Options.OptionSet : object {
    private static string NoLanguageSentinel;
    private static ImmutableDictionary`2<string, AnalyzerConfigOptions> s_emptyAnalyzerConfigOptions;
    private ImmutableDictionary`2<string, AnalyzerConfigOptions> _lazyAnalyzerConfigOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<OptionKey, object> _getOptionCore;
    private static OptionSet();
    [NullableContextAttribute("2")]
private protected abstract virtual object GetOptionCore(OptionKey optionKey);
    [NullableContextAttribute("2")]
public object GetOption(OptionKey optionKey);
    public T GetOption(OptionKey optionKey);
    [NullableContextAttribute("2")]
internal object GetOption(OptionKey2 optionKey);
    internal T GetOption(OptionKey2 optionKey);
    public T GetOption(Option`1<T> option);
    internal T GetOption(Option2`1<T> option);
    public T GetOption(PerLanguageOption`1<T> option, string language);
    internal T GetOption(PerLanguageOption2`1<T> option, string language);
    public abstract virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    internal OptionSet WithChangedOption(OptionKey2 optionAndLanguage, object value);
    public OptionSet WithChangedOption(Option`1<T> option, T value);
    internal OptionSet WithChangedOption(Option2`1<T> option, T value);
    public OptionSet WithChangedOption(PerLanguageOption`1<T> option, string language, T value);
    internal OptionSet WithChangedOption(PerLanguageOption2`1<T> option, string language, T value);
    internal AnalyzerConfigOptions AsAnalyzerConfigOptions(IEditorConfigOptionMappingService optionMappingService, string language);
    internal abstract virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
    private protected virtual AnalyzerConfigOptions CreateAnalyzerConfigOptions(IEditorConfigOptionMappingService optionMappingService, string language);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Options.OptionsExtensions : object {
    [ExtensionAttribute]
public static Option`1<CodeStyleOption`1<T>> ToPublicOption(Option2`1<CodeStyleOption2`1<T>> option);
    [ExtensionAttribute]
public static PerLanguageOption`1<CodeStyleOption`1<T>> ToPublicOption(PerLanguageOption2`1<CodeStyleOption2`1<T>> option);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Options.OptionsHelpers : object {
    public static T GetOption(Option`1<T> option, Func`2<OptionKey, object> getOption);
    public static T GetOption(Option2`1<T> option, Func`2<OptionKey, object> getOption);
    public static T GetOption(PerLanguageOption`1<T> option, string language, Func`2<OptionKey, object> getOption);
    public static T GetOption(PerLanguageOption2`1<T> option, string language, Func`2<OptionKey, object> getOption);
    public static T GetOption(OptionKey2 optionKey, Func`2<OptionKey, object> getOption);
    public static T GetOption(OptionKey optionKey, Func`2<OptionKey, object> getOption);
    [NullableContextAttribute("2")]
public static object GetPublicOption(OptionKey optionKey, Func`2<OptionKey, object> getOption);
}
public abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation : object {
}
internal abstract class Microsoft.CodeAnalysis.Options.OptionStorageLocation2 : OptionStorageLocation {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.OptionValueSet : OptionSet {
    public static OptionValueSet Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<OptionKey, object> _values;
    public OptionValueSet(ImmutableDictionary`2<OptionKey, object> values);
    private static OptionValueSet();
    [NullableContextAttribute("2")]
private protected virtual object GetOptionCore(OptionKey optionKey);
    public virtual OptionSet WithChangedOption(OptionKey optionAndLanguage, object value);
    internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Options.PerLanguageOption`1 : object {
    private OptionDefinition _optionDefinition;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation> <StorageLocations>k__BackingField;
    public string Feature { get; }
    internal OptionGroup Group { get; }
    public string Name { get; }
    public Type Type { get; }
    public T DefaultValue { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<OptionStorageLocation> StorageLocations { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.OptionDefinition { get; }
    private OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    public PerLanguageOption`1(string feature, string name, T defaultValue);
    public PerLanguageOption`1(string feature, string name, T defaultValue, OptionStorageLocation[] storageLocations);
    internal PerLanguageOption`1(string feature, string name, T defaultValue, OptionStorageLocation storageLocation);
    internal PerLanguageOption`1(string feature, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation> storageLocations);
    internal PerLanguageOption`1(string feature, OptionGroup group, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation> storageLocations);
    internal PerLanguageOption`1(OptionDefinition optionDefinition, ImmutableArray`1<OptionStorageLocation> storageLocations);
    public sealed virtual string get_Feature();
    internal OptionGroup get_Group();
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public T get_DefaultValue();
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<OptionStorageLocation> get_StorageLocations();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_OptionDefinition();
    private sealed virtual override OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.get_Group();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    [NullableContextAttribute("2")]
private sealed virtual override bool System.IEquatable<Microsoft.CodeAnalysis.Options.IOption2>.Equals(IOption2 other);
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
private bool Equals(IOption2 other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.PerLanguageOption2`1 : object {
    [CompilerGeneratedAttribute]
private OptionDefinition <OptionDefinition>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<OptionStorageLocation2> <StorageLocations>k__BackingField;
    public OptionDefinition OptionDefinition { get; }
    public string Feature { get; }
    internal OptionGroup Group { get; }
    public string Name { get; }
    public Type Type { get; }
    public T DefaultValue { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<OptionStorageLocation2> StorageLocations { get; }
    private OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.Group { get; }
    private OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.OptionDefinition { get; }
    [NullableAttribute("2")]
private object Microsoft.CodeAnalysis.Options.IOption.DefaultValue { get; }
    private bool Microsoft.CodeAnalysis.Options.IOption.IsPerLanguage { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<OptionStorageLocation> Microsoft.CodeAnalysis.Options.IOption.StorageLocations { get; }
    public PerLanguageOption2`1(string feature, string name, T defaultValue);
    public PerLanguageOption2`1(string feature, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    public PerLanguageOption2`1(string feature, string name, T defaultValue, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2, OptionStorageLocation2 storageLocation3);
    public PerLanguageOption2`1(string feature, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation2> storageLocations);
    public PerLanguageOption2`1(string feature, OptionGroup group, string name, T defaultValue);
    public PerLanguageOption2`1(string feature, OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation);
    public PerLanguageOption2`1(string feature, OptionGroup group, string name, T defaultValue, OptionStorageLocation2 storageLocation1, OptionStorageLocation2 storageLocation2);
    public PerLanguageOption2`1(string feature, OptionGroup group, string name, T defaultValue, ImmutableArray`1<OptionStorageLocation2> storageLocations);
    public static PerLanguageOption`1<T> op_Explicit(PerLanguageOption2`1<T> option);
    [CompilerGeneratedAttribute]
public OptionDefinition get_OptionDefinition();
    public sealed virtual string get_Feature();
    internal OptionGroup get_Group();
    public sealed virtual string get_Name();
    public sealed virtual Type get_Type();
    public T get_DefaultValue();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<OptionStorageLocation2> get_StorageLocations();
    private sealed virtual override OptionGroup Microsoft.CodeAnalysis.Options.IOptionWithGroup.get_Group();
    private sealed virtual override OptionDefinition Microsoft.CodeAnalysis.Options.IOption2.get_OptionDefinition();
    [NullableContextAttribute("2")]
private sealed virtual override object Microsoft.CodeAnalysis.Options.IOption.get_DefaultValue();
    private sealed virtual override bool Microsoft.CodeAnalysis.Options.IOption.get_IsPerLanguage();
    private sealed virtual override ImmutableArray`1<OptionStorageLocation> Microsoft.CodeAnalysis.Options.IOption.get_StorageLocations();
    public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(IOption2 other);
}
internal static class Microsoft.CodeAnalysis.Options.PredefinedDocumentOptionsProviderNames : object {
    [NullableAttribute("1")]
public static string EditorConfig;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal abstract class Microsoft.CodeAnalysis.Options.Providers.ExportOptionProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobal>k__BackingField;
    public string Language { get; }
    public bool IsGlobal { get; }
    public ExportOptionProviderAttribute(string language, bool isGlobal);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public bool get_IsGlobal();
}
internal class Microsoft.CodeAnalysis.Options.Providers.ExportSolutionOptionProviderAttribute : ExportOptionProviderAttribute {
    [NullableContextAttribute("1")]
public ExportSolutionOptionProviderAttribute(string language);
}
internal interface Microsoft.CodeAnalysis.Options.Providers.IOptionProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    public abstract virtual ImmutableArray`1<IOption> get_Options();
}
internal class Microsoft.CodeAnalysis.Options.RoamingProfileStorageLocation : ClientSettingsStorageLocation {
    public bool IsMachineLocal { get; }
    [NullableContextAttribute("1")]
public RoamingProfileStorageLocation(string keyName);
    public RoamingProfileStorageLocation(Func`2<string, string> keyNameFromLanguageName);
    public virtual bool get_IsMachineLocal();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Options.SolutionOptionSet : OptionSet {
    private ILegacyWorkspaceOptionService _globalOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<OptionKey, object> _values;
    private ImmutableHashSet`1<OptionKey> _changedOptionKeys;
    private SolutionOptionSet(ILegacyWorkspaceOptionService globalOptions, ImmutableDictionary`2<OptionKey, object> values, ImmutableHashSet`1<OptionKey> changedOptionKeys);
    internal SolutionOptionSet(ILegacyWorkspaceOptionService globalOptions);
    [NullableContextAttribute("2")]
private protected virtual object GetOptionCore(OptionKey optionKey);
    public virtual OptionSet WithChangedOption(OptionKey optionKey, object value);
    internal IEnumerable`1<OptionKey> GetChangedOptions();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Options.SolutionOptionSet/<GetChangedOptions>d__8")]
internal virtual IEnumerable`1<OptionKey> GetChangedOptions(OptionSet optionSet);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.OptionsProvider`1 {
    public abstract virtual ValueTask`1<TOptions> GetOptionsAsync(LanguageServices languageServices, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.OrderableMetadata : object {
    [CompilerGeneratedAttribute]
private object <After>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Before>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <AfterTyped>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private IEnumerable`1<string> <BeforeTyped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object After { get; }
    [DefaultValueAttribute("Mono.Cecil.CustomAttributeArgument")]
public object Before { get; }
    [NullableAttribute("1")]
internal IEnumerable`1<string> AfterTyped { get; internal set; }
    [NullableAttribute("1")]
internal IEnumerable`1<string> BeforeTyped { get; internal set; }
    public string Name { get; }
    [NullableContextAttribute("1")]
public OrderableMetadata(IDictionary`2<string, object> data);
    public OrderableMetadata(string name, IEnumerable`1<string> after, IEnumerable`1<string> before);
    [CompilerGeneratedAttribute]
public object get_After();
    [CompilerGeneratedAttribute]
public object get_Before();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_AfterTyped();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_AfterTyped(IEnumerable`1<string> value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_BeforeTyped();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal void set_BeforeTyped(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Name();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.OrganizeImports.IOrganizeImportsService {
    public string SortImportsDisplayStringWithAccelerator { get; }
    public string SortAndRemoveUnusedImportsDisplayStringWithAccelerator { get; }
    public abstract virtual Task`1<Document> OrganizeImportsAsync(Document document, OrganizeImportsOptions options, CancellationToken cancellationToken);
    public abstract virtual string get_SortImportsDisplayStringWithAccelerator();
    public abstract virtual string get_SortAndRemoveUnusedImportsDisplayStringWithAccelerator();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <PlaceSystemNamespaceFirst>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SeparateImportDirectiveGroups>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    public static OrganizeImportsOptions Default;
    [DataMemberAttribute]
public bool PlaceSystemNamespaceFirst { get; public set; }
    [DataMemberAttribute]
public bool SeparateImportDirectiveGroups { get; public set; }
    [NullableAttribute("1")]
[DataMemberAttribute]
public string NewLine { get; public set; }
    private static OrganizeImportsOptions();
    [CompilerGeneratedAttribute]
public bool get_PlaceSystemNamespaceFirst();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PlaceSystemNamespaceFirst(bool value);
    [CompilerGeneratedAttribute]
public bool get_SeparateImportDirectiveGroups();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SeparateImportDirectiveGroups(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_NewLine();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NewLine(string value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(OrganizeImportsOptions left, OrganizeImportsOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(OrganizeImportsOptions left, OrganizeImportsOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(OrganizeImportsOptions other);
}
internal interface Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptionsProvider {
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptionsProviders : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static OrganizeImportsOptions GetOrganizeImportsOptions(AnalyzerConfigOptions options, Nullable`1<OrganizeImportsOptions> fallbackOptions);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptionsProviders/<GetOrganizeImportsOptionsAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<OrganizeImportsOptions> GetOrganizeImportsOptionsAsync(Document document, Nullable`1<OrganizeImportsOptions> fallbackOptions, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.OrganizeImports.OrganizeImportsOptionsProviders/<GetOrganizeImportsOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<OrganizeImportsOptions> GetOrganizeImportsOptionsAsync(Document document, OrganizeImportsOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Packaging.IPackageInstallerService {
    public abstract virtual bool IsEnabled(ProjectId projectId);
    public abstract virtual bool IsInstalled(ProjectId projectId, string packageName);
    public abstract virtual Task`1<bool> TryInstallPackageAsync(Workspace workspace, DocumentId documentId, string source, string packageName, string version, bool includePrerelease, IProgressTracker progressTracker, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<string> GetInstalledVersions(string packageName);
    public abstract virtual ImmutableArray`1<Project> GetProjectsWithInstalledPackage(Solution solution, string packageName, string version);
    public abstract virtual bool CanShowManagePackagesDialog();
    public abstract virtual void ShowManagePackagesDialog(string packageName);
    [NullableContextAttribute("0")]
public abstract virtual ImmutableArray`1<PackageSource> TryGetPackageSources();
    [CompilerGeneratedAttribute]
public abstract virtual void add_PackageSourcesChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_PackageSourcesChanged(EventHandler value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Packaging.PackageSource : ValueType {
    [DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public string Source;
    public PackageSource(string name, string source);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageSource other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.ParsedDocument : ValueType {
    [CompilerGeneratedAttribute]
private DocumentId <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceText <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNode <Root>k__BackingField;
    [CompilerGeneratedAttribute]
private HostLanguageServices <HostLanguageServices>k__BackingField;
    public DocumentId Id { get; public set; }
    public SourceText Text { get; public set; }
    public SyntaxNode Root { get; public set; }
    public HostLanguageServices HostLanguageServices { get; public set; }
    public SyntaxTree SyntaxTree { get; }
    public LanguageServices LanguageServices { get; }
    public SolutionServices SolutionServices { get; }
    public ParsedDocument(DocumentId Id, SourceText Text, SyntaxNode Root, HostLanguageServices HostLanguageServices);
    [CompilerGeneratedAttribute]
public DocumentId get_Id();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Id(DocumentId value);
    [CompilerGeneratedAttribute]
public SourceText get_Text();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Text(SourceText value);
    [CompilerGeneratedAttribute]
public SyntaxNode get_Root();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Root(SyntaxNode value);
    [CompilerGeneratedAttribute]
public HostLanguageServices get_HostLanguageServices();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HostLanguageServices(HostLanguageServices value);
    public SyntaxTree get_SyntaxTree();
    public LanguageServices get_LanguageServices();
    public SolutionServices get_SolutionServices();
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ParsedDocument/<CreateAsync>d__23")]
public static ValueTask`1<ParsedDocument> CreateAsync(Document document, CancellationToken cancellationToken);
    public static ParsedDocument CreateSynchronously(Document document, CancellationToken cancellationToken);
    public ParsedDocument WithChangedText(SourceText text, CancellationToken cancellationToken);
    public ParsedDocument WithChangedRoot(SyntaxNode root, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(ParsedDocument left, ParsedDocument right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(ParsedDocument left, ParsedDocument right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(ParsedDocument other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentId& Id, SourceText& Text, SyntaxNode& Root, HostLanguageServices& HostLanguageServices);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.PatternMatching.PatternMatch : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsCaseSensitive>k__BackingField;
    [CompilerGeneratedAttribute]
private PatternMatchKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<TextSpan> <MatchedSpans>k__BackingField;
    private bool _punctuationStripped;
    public bool IsCaseSensitive { get; }
    public PatternMatchKind Kind { get; }
    public ImmutableArray`1<TextSpan> MatchedSpans { get; }
    internal PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive, Nullable`1<TextSpan> matchedSpan);
    internal PatternMatch(PatternMatchKind resultType, bool punctuationStripped, bool isCaseSensitive, ImmutableArray`1<TextSpan> matchedSpans);
    [CompilerGeneratedAttribute]
public bool get_IsCaseSensitive();
    [CompilerGeneratedAttribute]
public PatternMatchKind get_Kind();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<TextSpan> get_MatchedSpans();
    public PatternMatch WithMatchedSpans(ImmutableArray`1<TextSpan> matchedSpans);
    public sealed virtual int CompareTo(PatternMatch other);
    public int CompareTo(Nullable`1<PatternMatch> other, bool ignoreCase);
    public int CompareTo(PatternMatch other, bool ignoreCase);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.PatternMatching.PatternMatcher : object {
    private static Char[] s_dotCharacterArray;
    public static int NoBonus;
    public static int CamelCaseContiguousBonus;
    public static int CamelCaseMatchesFromStartBonus;
    public static int CamelCaseMaxWeight;
    private bool _includeMatchedSpans;
    private bool _allowFuzzyMatching;
    private CompareInfo _compareInfo;
    private TextInfo _textInfo;
    private bool _invalidPattern;
    protected PatternMatcher(bool includeMatchedSpans, CultureInfo culture, bool allowFuzzyMatching);
    private static PatternMatcher();
    [NullableContextAttribute("0")]
private static PatternMatchKind GetCamelCaseKind(CamelCaseResult result, TemporaryArray`1& candidateHumps);
    public virtual void Dispose();
    public static PatternMatcher CreatePatternMatcher(string pattern, CultureInfo culture, bool includeMatchedSpans, bool allowFuzzyMatching);
    public static PatternMatcher CreateContainerPatternMatcher(String[] patternParts, Char[] containerSplitCharacters, CultureInfo culture, bool allowFuzzyMatching);
    public static PatternMatcher CreateDotSeparatedContainerMatcher(string pattern, CultureInfo culture, bool allowFuzzyMatching);
    internal static ValueTuple`2<string, string> GetNameAndContainer(string pattern);
    [NullableContextAttribute("0")]
public abstract virtual bool AddMatches(string candidate, TemporaryArray`1& matches);
    [NullableContextAttribute("2")]
private bool SkipMatch(string candidate);
    private static bool ContainsUpperCaseLetter(string pattern);
    private Nullable`1<PatternMatch> MatchPatternChunk(string candidate, TextChunk& patternChunk, bool punctuationStripped, bool fuzzyMatch);
    private static Nullable`1<PatternMatch> FuzzyMatchPatternChunk(string candidate, TextChunk& patternChunk, bool punctuationStripped);
    private Nullable`1<PatternMatch> NonFuzzyMatchPatternChunk(string candidate, TextChunk& patternChunk, bool punctuationStripped);
    private Nullable`1<TextSpan> GetMatchedSpan(int start, int length);
    private static bool ContainsSpaceOrAsterisk(string text);
    [NullableContextAttribute("0")]
private bool MatchPatternSegment(string candidate, PatternSegment& segment, TemporaryArray`1& matches, bool fuzzyMatch);
    private static bool IsWordChar(char ch);
    private bool PartStartsWith(string candidate, TextSpan candidatePart, string pattern, TextSpan patternPart, CompareOptions compareOptions);
    private bool PartStartsWith(string candidate, TextSpan candidatePart, string pattern, CompareOptions compareOptions);
    [NullableContextAttribute("0")]
private Nullable`1<PatternMatch> TryCamelCaseMatch(string candidate, TextChunk& patternChunk, bool punctuationStripped, bool isLowercase, TemporaryArray`1& candidateHumps);
    [NullableContextAttribute("0")]
private Nullable`1<PatternMatchKind> TryAllLowerCamelCaseMatch(string candidate, TemporaryArray`1& candidateHumps, TextChunk& patternChunk, ImmutableArray`1& matchedSpans);
    [NullableContextAttribute("0")]
private Nullable`1<PatternMatchKind> TryUpperCaseCamelCaseMatch(string candidate, TemporaryArray`1& candidateHumps, TextChunk& patternChunk, CompareOptions compareOption, ImmutableArray`1& matchedSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PatternMatching.PatternMatcherExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<PatternMatch> GetFirstMatch(PatternMatcher matcher, string candidate);
    [ExtensionAttribute]
public static bool Matches(PatternMatcher matcher, string candidate);
}
internal enum Microsoft.CodeAnalysis.PatternMatching.PatternMatchKind : Enum {
    public int value__;
    public static PatternMatchKind Exact;
    public static PatternMatchKind Prefix;
    public static PatternMatchKind NonLowercaseSubstring;
    public static PatternMatchKind StartOfWordSubstring;
    public static PatternMatchKind CamelCaseExact;
    public static PatternMatchKind CamelCasePrefix;
    public static PatternMatchKind CamelCaseNonContiguousPrefix;
    public static PatternMatchKind CamelCaseSubstring;
    public static PatternMatchKind CamelCaseNonContiguousSubstring;
    public static PatternMatchKind Fuzzy;
    public static PatternMatchKind LowercaseSubstring;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObject`1 : ValueType {
    private Action`2<ObjectPool`1<T>, T> _releaser;
    private ObjectPool`1<T> _pool;
    private T _pooledObject;
    public T Object { get; }
    public PooledObject`1(ObjectPool`1<T> pool, Func`2<ObjectPool`1<T>, T> allocator, Action`2<ObjectPool`1<T>, T> releaser);
    public T get_Object();
    public sealed virtual void Dispose();
    public static PooledObject`1<StringBuilder> Create(ObjectPool`1<StringBuilder> pool);
    public static PooledObject`1<Stack`1<TItem>> Create(ObjectPool`1<Stack`1<TItem>> pool);
    public static PooledObject`1<Queue`1<TItem>> Create(ObjectPool`1<Queue`1<TItem>> pool);
    public static PooledObject`1<HashSet`1<TItem>> Create(ObjectPool`1<HashSet`1<TItem>> pool);
    public static PooledObject`1<Dictionary`2<TKey, TValue>> Create(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    public static PooledObject`1<List`1<TItem>> Create(ObjectPool`1<List`1<TItem>> pool);
    private static StringBuilder Allocator(ObjectPool`1<StringBuilder> pool);
    private static void Releaser(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    private static Stack`1<TItem> Allocator(ObjectPool`1<Stack`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Stack`1<TItem>> pool, Stack`1<TItem> obj);
    private static Queue`1<TItem> Allocator(ObjectPool`1<Queue`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<Queue`1<TItem>> pool, Queue`1<TItem> obj);
    private static HashSet`1<TItem> Allocator(ObjectPool`1<HashSet`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<HashSet`1<TItem>> pool, HashSet`1<TItem> obj);
    private static Dictionary`2<TKey, TValue> Allocator(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    private static void Releaser(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> obj);
    private static List`1<TItem> Allocator(ObjectPool`1<List`1<TItem>> pool);
    private static void Releaser(ObjectPool`1<List`1<TItem>> pool, List`1<TItem> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count,nq}")]
[DebuggerTypeProxyAttribute("Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1/DebuggerProxy")]
internal class Microsoft.CodeAnalysis.PooledObjects.ArrayBuilder`1 : object {
    private Builder<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<ArrayBuilder`1<T>> _pool;
    private static ObjectPool`1<ArrayBuilder`1<T>> s_poolInstance;
    public int Count { get; public set; }
    public T Item { get; public set; }
    public ArrayBuilder`1(int size);
    private ArrayBuilder`1(ObjectPool`1<ArrayBuilder`1<T>> pool);
    private static ArrayBuilder`1();
    public ImmutableArray`1<T> ToImmutable();
    public ImmutableArray`1<T> ToImmutableAndClear();
    public sealed virtual int get_Count();
    public void set_Count(int value);
    public sealed virtual T get_Item(int index);
    public void set_Item(int index, T value);
    public void SetItem(int index, T value);
    public void Add(T item);
    public void Insert(int index, T item);
    public void EnsureCapacity(int capacity);
    public void Clear();
    public bool Contains(T item);
    public int IndexOf(T item);
    public int IndexOf(T item, IEqualityComparer`1<T> equalityComparer);
    public int IndexOf(T item, int startIndex, int count);
    public int FindIndex(Predicate`1<T> match);
    public int FindIndex(int startIndex, Predicate`1<T> match);
    public int FindIndex(int startIndex, int count, Predicate`1<T> match);
    public int FindIndex(Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, Func`3<T, TArg, bool> match, TArg arg);
    public int FindIndex(int startIndex, int count, Func`3<T, TArg, bool> match, TArg arg);
    public bool Remove(T element);
    public void RemoveAt(int index);
    public void RemoveLast();
    public void ReverseContents();
    public void Sort();
    public void Sort(IComparer`1<T> comparer);
    public void Sort(Comparison`1<T> compare);
    public void Sort(int startIndex, IComparer`1<T> comparer);
    public T[] ToArray();
    public void CopyTo(T[] array, int start);
    public T Last();
    [NullableContextAttribute("2")]
internal T LastOrDefault();
    public T First();
    public bool Any();
    public ImmutableArray`1<T> ToImmutableOrNull();
    [NullableContextAttribute("0")]
public ImmutableArray`1<U> ToDowncastedImmutable();
    public ImmutableArray`1<T> ToImmutableAndFree();
    public T[] ToArrayAndFree();
    public sealed virtual void Free();
    public static ArrayBuilder`1<T> GetInstance();
    public static ArrayBuilder`1<T> GetInstance(int capacity);
    public static ArrayBuilder`1<T> GetInstance(int capacity, T fillWithValue);
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool();
    public static ObjectPool`1<ArrayBuilder`1<T>> CreatePool(int size);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    internal Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    public void AddRange(ArrayBuilder`1<T> items);
    public void AddRange(ArrayBuilder`1<U> items, Func`2<U, T> selector);
    public void AddRange(ArrayBuilder`1<U> items);
    public void AddRange(ArrayBuilder`1<U> items, int start, int length);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(ImmutableArray`1<T> items, int length);
    public void AddRange(ImmutableArray`1<T> items, int start, int length);
    public void AddRange(ImmutableArray`1<S> items);
    public void AddRange(T[] items, int start, int length);
    public void AddRange(IEnumerable`1<T> items);
    public void AddRange(T[] items);
    public void AddRange(T[] items, int length);
    public void Clip(int limit);
    public void ZeroInit(int count);
    public void AddMany(T item, int count);
    public void RemoveDuplicates();
    public void SortAndRemoveDuplicates(IComparer`1<T> comparer);
    public ImmutableArray`1<S> SelectDistinct(Func`2<T, S> selector);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(ArrayBuilder`1& instance);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, ArrayBuilder`1& instance);
    public static PooledDisposer`1<ArrayBuilder`1<T>> GetInstance(int capacity, T fillWithValue, ArrayBuilder`1& instance);
}
internal interface Microsoft.CodeAnalysis.PooledObjects.IPooled {
    public abstract virtual void Free();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.ObjectPool`1 : object {
    [NullableAttribute("2")]
private T _firstItem;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Element[] _items;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Factory<T> _factory;
    internal ObjectPool`1(Factory<T> factory);
    internal ObjectPool`1(Factory<T> factory, int size);
    internal ObjectPool`1(Func`2<ObjectPool`1<T>, T> factory, int size);
    private T CreateInstance();
    internal T Allocate();
    private T AllocateSlow();
    internal void Free(T obj);
    private void FreeSlow(T obj);
    [ConditionalAttribute("DEBUG")]
internal void ForgetTrackedObject(T old, T replacement);
    [ConditionalAttribute("DEBUG")]
private void Validate(object obj);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.PooledObjects.PooledDelegates : object {
    [NullableContextAttribute("1")]
private static Releaser GetPooledDelegate(TUnboundDelegate unboundDelegate, TArg argument, TBoundDelegate& boundDelegate);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`1<TArg> unboundAction, TArg argument, Action& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`2<T1, TArg> unboundAction, TArg argument, Action`1& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledAction(Action`3<T1, T2, TArg> unboundAction, TArg argument, Action`2& boundAction);
    public static Releaser GetPooledAction(Action`4<T1, T2, T3, TArg> unboundAction, TArg argument, Action`3& boundAction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledFunction(Func`2<TArg, TResult> unboundFunction, TArg argument, Func`1& boundFunction);
    [NullableContextAttribute("1")]
public static Releaser GetPooledFunction(Func`3<T1, TArg, TResult> unboundFunction, TArg argument, Func`2& boundFunction);
    public static Releaser GetPooledFunction(Func`4<T1, T2, TArg, TResult> unboundFunction, TArg argument, Func`3& boundFunction);
    public static Releaser GetPooledFunction(Func`5<T1, T2, T3, TArg, TResult> unboundFunction, TArg argument, Func`4& boundFunction);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDictionary`2 : Dictionary`2<K, V> {
    private ObjectPool`1<PooledDictionary`2<K, V>> _pool;
    private static ObjectPool`1<PooledDictionary`2<K, V>> s_poolInstance;
    private PooledDictionary`2(ObjectPool`1<PooledDictionary`2<K, V>> pool, IEqualityComparer`1<K> keyComparer);
    private static PooledDictionary`2();
    public ImmutableDictionary`2<K, V> ToImmutableDictionaryAndFree();
    public ImmutableDictionary`2<K, V> ToImmutableDictionary();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledDictionary`2<K, V>> CreatePool(IEqualityComparer`1<K> keyComparer);
    public static PooledDictionary`2<K, V> GetInstance();
    public static PooledDisposer`1<PooledDictionary`2<K, V>> GetInstance(PooledDictionary`2& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledDisposer`1 : ValueType {
    private TPoolable _pooledObject;
    public PooledDisposer`1(TPoolable instance);
    private sealed virtual override void System.IDisposable.Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledHashSet`1 : HashSet`1<T> {
    private ObjectPool`1<PooledHashSet`1<T>> _pool;
    private static ObjectPool`1<PooledHashSet`1<T>> s_poolInstance;
    private PooledHashSet`1(ObjectPool`1<PooledHashSet`1<T>> pool, IEqualityComparer`1<T> equalityComparer);
    private static PooledHashSet`1();
    public sealed virtual void Free();
    public static ObjectPool`1<PooledHashSet`1<T>> CreatePool(IEqualityComparer`1<T> equalityComparer);
    public static PooledHashSet`1<T> GetInstance();
    public static PooledDisposer`1<PooledHashSet`1<T>> GetInstance(PooledHashSet`1& instance);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.PooledObjects.PooledStringBuilder : object {
    public StringBuilder Builder;
    private ObjectPool`1<PooledStringBuilder> _pool;
    private static ObjectPool`1<PooledStringBuilder> s_poolInstance;
    public int Length { get; }
    private PooledStringBuilder(ObjectPool`1<PooledStringBuilder> pool);
    private static PooledStringBuilder();
    public int get_Length();
    public sealed virtual void Free();
    [ObsoleteAttribute("Consider calling ToStringAndFree instead.")]
public string ToString();
    public string ToStringAndFree();
    public string ToStringAndFree(int startIndex, int length);
    public static ObjectPool`1<PooledStringBuilder> CreatePool(int size);
    public static PooledStringBuilder GetInstance();
    public static StringBuilder op_Implicit(PooledStringBuilder obj);
    public static PooledDisposer`1<PooledStringBuilder> GetInstance(StringBuilder& instance);
}
internal abstract class Microsoft.CodeAnalysis.Precedence.AbstractPrecedenceService`2 : object {
    private sealed virtual override int Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetOperatorPrecedence(SyntaxNode expression);
    private sealed virtual override PrecedenceKind Microsoft.CodeAnalysis.Precedence.IPrecedenceService.GetPrecedenceKind(int operatorPrecedence);
    public abstract virtual TOperatorPrecedence GetOperatorPrecedence(TExpressionSyntax expression);
    public abstract virtual PrecedenceKind GetPrecedenceKind(TOperatorPrecedence operatorPrecedence);
}
internal interface Microsoft.CodeAnalysis.Precedence.IPrecedenceService {
    public abstract virtual PrecedenceKind GetPrecedenceKind(int operatorPrecedence);
    public abstract virtual int GetOperatorPrecedence(SyntaxNode expression);
}
internal enum Microsoft.CodeAnalysis.Precedence.PrecedenceKind : Enum {
    public int value__;
    public static PrecedenceKind Arithmetic;
    public static PrecedenceKind Shift;
    public static PrecedenceKind Relational;
    public static PrecedenceKind Equality;
    public static PrecedenceKind Bitwise;
    public static PrecedenceKind Logical;
    public static PrecedenceKind Coalesce;
    public static PrecedenceKind Other;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Precedence.PrecedenceServiceExtensions : object {
    [ExtensionAttribute]
public static PrecedenceKind GetPrecedenceKind(IPrecedenceService service, SyntaxNode expression);
}
public enum Microsoft.CodeAnalysis.PreservationMode : Enum {
    public int value__;
    public static PreservationMode PreserveValue;
    public static PreservationMode PreserveIdentity;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PreservationModeExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(PreservationMode mode);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.Project : object {
    private Solution _solution;
    private ProjectState _projectState;
    private ImmutableHashMap`2<DocumentId, Document> _idToDocumentMap;
    private ImmutableHashMap`2<DocumentId, SourceGeneratedDocument> _idToSourceGeneratedDocumentMap;
    private ImmutableHashMap`2<DocumentId, AdditionalDocument> _idToAdditionalDocumentMap;
    private ImmutableHashMap`2<DocumentId, AnalyzerConfigDocument> _idToAnalyzerConfigDocumentMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<DocumentId, Project, Document> s_tryCreateDocumentFunction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<DocumentId, Project, AdditionalDocument> s_tryCreateAdditionalDocumentFunction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<DocumentId, Project, AnalyzerConfigDocument> s_tryCreateAnalyzerConfigDocumentFunction;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`3<DocumentId, ValueTuple`2<SourceGeneratedDocumentState, Project>, SourceGeneratedDocument> s_createSourceGeneratedDocumentFunction;
    internal ProjectState State { get; }
    public Solution Solution { get; }
    public ProjectId Id { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    [NullableAttribute("2")]
public string OutputFilePath { get; }
    [NullableAttribute("2")]
public string OutputRefFilePath { get; }
    public CompilationOutputInfo CompilationOutputInfo { get; }
    [NullableAttribute("2")]
public string DefaultNamespace { get; }
    public bool SupportsCompilation { get; }
    [ObsoleteAttribute("Use Services instead.")]
public HostLanguageServices LanguageServices { get; }
    public LanguageServices Services { get; }
    public string Language { get; }
    public string AssemblyName { get; }
    public string Name { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IEnumerable`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<ProjectReference> AllProjectReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public AnalyzerOptions AnalyzerOptions { get; }
    [NullableAttribute("2")]
public CompilationOptions CompilationOptions { get; }
    [NullableAttribute("2")]
public ParseOptions ParseOptions { get; }
    public bool IsSubmission { get; }
    public bool HasDocuments { get; }
    public IReadOnlyList`1<DocumentId> DocumentIds { get; }
    public IReadOnlyList`1<DocumentId> AdditionalDocumentIds { get; }
    internal IReadOnlyList`1<DocumentId> AnalyzerConfigDocumentIds { get; }
    public IEnumerable`1<Document> Documents { get; }
    public IEnumerable`1<TextDocument> AdditionalDocuments { get; }
    public IEnumerable`1<AnalyzerConfigDocument> AnalyzerConfigDocuments { get; }
    public VersionStamp Version { get; }
    internal Project(Solution solution, ProjectState projectState);
    private static Project();
    internal ProjectState get_State();
    public Solution get_Solution();
    public ProjectId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    [NullableContextAttribute("2")]
public string get_OutputFilePath();
    [NullableContextAttribute("2")]
public string get_OutputRefFilePath();
    public CompilationOutputInfo get_CompilationOutputInfo();
    [NullableContextAttribute("2")]
public string get_DefaultNamespace();
    public bool get_SupportsCompilation();
    public HostLanguageServices get_LanguageServices();
    public LanguageServices get_Services();
    public string get_Language();
    public string get_AssemblyName();
    public string get_Name();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IEnumerable`1<ProjectReference> get_ProjectReferences();
    public IReadOnlyList`1<ProjectReference> get_AllProjectReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public AnalyzerOptions get_AnalyzerOptions();
    [NullableContextAttribute("2")]
public CompilationOptions get_CompilationOptions();
    [NullableContextAttribute("2")]
public ParseOptions get_ParseOptions();
    public bool get_IsSubmission();
    public bool get_HasDocuments();
    public IReadOnlyList`1<DocumentId> get_DocumentIds();
    public IReadOnlyList`1<DocumentId> get_AdditionalDocumentIds();
    internal IReadOnlyList`1<DocumentId> get_AnalyzerConfigDocumentIds();
    public IEnumerable`1<Document> get_Documents();
    public IEnumerable`1<TextDocument> get_AdditionalDocuments();
    public IEnumerable`1<AnalyzerConfigDocument> get_AnalyzerConfigDocuments();
    public bool ContainsDocument(DocumentId documentId);
    public bool ContainsAdditionalDocument(DocumentId documentId);
    public bool ContainsAnalyzerConfigDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    [NullableContextAttribute("2")]
public Document GetDocument(SyntaxTree syntaxTree);
    public Document GetDocument(DocumentId documentId);
    public TextDocument GetAdditionalDocument(DocumentId documentId);
    public AnalyzerConfigDocument GetAnalyzerConfigDocument(DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetDocumentAsync>d__73")]
internal ValueTask`1<Document> GetDocumentAsync(DocumentId documentId, bool includeSourceGenerated, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetTextDocumentAsync>d__74")]
internal ValueTask`1<TextDocument> GetTextDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetSourceGeneratedDocumentsAsync>d__75")]
public ValueTask`1<IEnumerable`1<SourceGeneratedDocument>> GetSourceGeneratedDocumentsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetAllRegularAndSourceGeneratedDocumentsAsync>d__76")]
internal ValueTask`1<IEnumerable`1<Document>> GetAllRegularAndSourceGeneratedDocumentsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<GetSourceGeneratedDocumentAsync>d__77")]
public ValueTask`1<SourceGeneratedDocument> GetSourceGeneratedDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    internal SourceGeneratedDocument GetOrCreateSourceGeneratedDocument(SourceGeneratedDocumentState state);
    internal SourceGeneratedDocument TryGetSourceGeneratedDocumentForAlreadyGeneratedId(DocumentId documentId);
    internal ValueTask`1<ImmutableArray`1<Diagnostic>> GetSourceGeneratorDiagnosticsAsync(CancellationToken cancellationToken);
    internal Task`1<bool> ContainsSymbolsWithNameAsync(string name, CancellationToken cancellationToken);
    internal Task`1<bool> ContainsSymbolsWithNameAsync(string name, SymbolFilter filter, CancellationToken cancellationToken);
    internal Task`1<bool> ContainsSymbolsWithNameAsync(Func`2<string, bool> predicate, SymbolFilter filter, CancellationToken cancellationToken);
    private Task`1<bool> ContainsSymbolsAsync(Func`3<SyntaxTreeIndex, CancellationToken, bool> predicate, CancellationToken cancellationToken);
    private Task`1<bool> ContainsDeclarationAsync(Func`3<TopLevelSyntaxTreeIndex, CancellationToken, bool> predicate, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Project/<ContainsAsync>d__86")]
private Task`1<bool> ContainsAsync(Func`2<Document, Task`1<bool>> predicateAsync);
    [NullableContextAttribute("2")]
public bool TryGetCompilation(Compilation& compilation);
    public Task`1<Compilation> GetCompilationAsync(CancellationToken cancellationToken);
    internal Task`1<bool> HasSuccessfullyLoadedAsync(CancellationToken cancellationToken);
    public ProjectChanges GetChanges(Project oldProject);
    public VersionStamp get_Version();
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentSemanticVersionAsync(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    internal Task`1<Checksum> GetDependentChecksumAsync(CancellationToken cancellationToken);
    public Project WithAssemblyName(string assemblyName);
    public Project WithDefaultNamespace(string defaultNamespace);
    public Project WithCompilationOptions(CompilationOptions options);
    public Project WithParseOptions(ParseOptions options);
    public Project AddProjectReference(ProjectReference projectReference);
    public Project AddProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project RemoveProjectReference(ProjectReference projectReference);
    public Project WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public Project AddMetadataReference(MetadataReference metadataReference);
    public Project AddMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project RemoveMetadataReference(MetadataReference metadataReference);
    public Project WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public Project AddAnalyzerReference(AnalyzerReference analyzerReference);
    public Project AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Project RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public Project WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferencs);
    public Document AddDocument(string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Document AddDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAdditionalDocument(string name, string text, IEnumerable`1<string> folders, string filePath);
    public TextDocument AddAnalyzerConfigDocument(string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Project RemoveDocument(DocumentId documentId);
    public Project RemoveDocuments(ImmutableArray`1<DocumentId> documentIds);
    public Project RemoveAdditionalDocument(DocumentId documentId);
    public Project RemoveAdditionalDocuments(ImmutableArray`1<DocumentId> documentIds);
    public Project RemoveAnalyzerConfigDocument(DocumentId documentId);
    public Project RemoveAnalyzerConfigDocuments(ImmutableArray`1<DocumentId> documentIds);
    private void CheckIdsContainedInProject(ImmutableArray`1<DocumentId> documentIds);
    internal Nullable`1<AnalyzerConfigData> GetAnalyzerConfigOptions();
    private string GetDebuggerDisplay();
    internal SkippedHostAnalyzersInfo GetSkippedAnalyzersInfo(DiagnosticAnalyzerInfoCache infoCache);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_ProjectReferences>b__38_0(ProjectReference pr);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private SourceGeneratedDocument <GetSourceGeneratedDocumentsAsync>b__75_0(SourceGeneratedDocumentState state);
    [CompilerGeneratedAttribute]
internal static bool <ContainsSymbolsWithNameAsync>g__FilterMatches|83_1(DeclaredSymbolInfo info, SymbolFilter filter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.ProjectChanges : ValueType {
    private Project _newProject;
    private Project _oldProject;
    public ProjectId ProjectId { get; }
    public Project OldProject { get; }
    public Project NewProject { get; }
    internal ProjectChanges(Project newProject, Project oldProject);
    public ProjectId get_ProjectId();
    public Project get_OldProject();
    public Project get_NewProject();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedProjectReferences>d__9")]
public IEnumerable`1<ProjectReference> GetAddedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedProjectReferences>d__10")]
public IEnumerable`1<ProjectReference> GetRemovedProjectReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedMetadataReferences>d__11")]
public IEnumerable`1<MetadataReference> GetAddedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedMetadataReferences>d__12")]
public IEnumerable`1<MetadataReference> GetRemovedMetadataReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetAddedAnalyzerReferences>d__13")]
public IEnumerable`1<AnalyzerReference> GetAddedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.ProjectChanges/<GetRemovedAnalyzerReferences>d__14")]
public IEnumerable`1<AnalyzerReference> GetRemovedAnalyzerReferences();
    public IEnumerable`1<DocumentId> GetAddedDocuments();
    public IEnumerable`1<DocumentId> GetAddedAdditionalDocuments();
    public IEnumerable`1<DocumentId> GetAddedAnalyzerConfigDocuments();
    public IEnumerable`1<DocumentId> GetChangedDocuments();
    public IEnumerable`1<DocumentId> GetChangedDocuments(bool onlyGetDocumentsWithTextChanges);
    internal IEnumerable`1<DocumentId> GetChangedDocuments(bool onlyGetDocumentsWithTextChanges, bool ignoreUnchangeableDocuments);
    public IEnumerable`1<DocumentId> GetChangedAdditionalDocuments();
    public IEnumerable`1<DocumentId> GetChangedAnalyzerConfigDocuments();
    public IEnumerable`1<DocumentId> GetRemovedDocuments();
    public IEnumerable`1<DocumentId> GetRemovedAdditionalDocuments();
    public IEnumerable`1<DocumentId> GetRemovedAnalyzerConfigDocuments();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.ProjectDependencyGraph : object {
    private ImmutableHashSet`1<ProjectId> _projectIds;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _referencesMap;
    private NonReentrantLock _dataLock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _lazyReverseReferencesMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ProjectId> _lazyTopologicallySortedProjects;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<IEnumerable`1<ProjectId>> _lazyDependencySets;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _transitiveReferencesMap;
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> _reverseTransitiveReferencesMap;
    internal static ProjectDependencyGraph Empty;
    internal ImmutableHashSet`1<ProjectId> ProjectIds { get; }
    internal ProjectDependencyGraph(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap);
    private ProjectDependencyGraph(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> reverseReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> transitiveReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> reverseTransitiveReferencesMap, ImmutableArray`1<ProjectId> topologicallySortedProjects, ImmutableArray`1<IEnumerable`1<ProjectId>> dependencySets);
    private static ProjectDependencyGraph();
    internal ImmutableHashSet`1<ProjectId> get_ProjectIds();
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> RemoveItemsWithEmptyValues(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> map);
    internal ProjectDependencyGraph WithProjectReferences(ProjectId projectId, IReadOnlyList`1<ProjectReference> projectReferences);
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectDirectlyDependsOn(ProjectId projectId);
    public IImmutableSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatDirectlyDependOnThisProject_NoLock(ProjectId projectId);
    private ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeReverseReferencesMap();
    internal ImmutableHashSet`1<ProjectId> TryGetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId);
    public IImmutableSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatThisProjectTransitivelyDependsOn_NoLock(ProjectId projectId);
    private void ComputeTransitiveReferences(ProjectId project, HashSet`1<ProjectId> result);
    public IEnumerable`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject(ProjectId projectId);
    private ImmutableHashSet`1<ProjectId> GetProjectsThatTransitivelyDependOnThisProject_NoLock(ProjectId projectId);
    private void ComputeReverseTransitiveReferences(ProjectId project, HashSet`1<ProjectId> results);
    public IEnumerable`1<ProjectId> GetTopologicallySortedProjects(CancellationToken cancellationToken);
    private void GetTopologicallySortedProjects_NoLock(CancellationToken cancellationToken);
    private void TopologicalSort(IEnumerable`1<ProjectId> projectIds, HashSet`1<ProjectId> seenProjects, List`1<ProjectId> resultList, CancellationToken cancellationToken);
    public IEnumerable`1<IEnumerable`1<ProjectId>> GetDependencySets(CancellationToken cancellationToken);
    private ImmutableArray`1<IEnumerable`1<ProjectId>> GetDependencySets_NoLock(CancellationToken cancellationToken);
    private void ComputeDependencySets(HashSet`1<ProjectId> seenProjects, List`1<IEnumerable`1<ProjectId>> results, CancellationToken cancellationToken);
    private void ComputedDependencySet(ProjectId project, HashSet`1<ProjectId> result);
    [ConditionalAttribute("DEBUG")]
private static void ValidateForwardReferences(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> referencesMap);
    [ConditionalAttribute("DEBUG")]
private static void ValidateReverseReferences(ImmutableHashSet`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> forwardReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> reverseReferencesMap);
    internal TestAccessor GetTestAccessor();
    internal bool DoesProjectTransitivelyDependOnProject(ProjectId id, ProjectId potentialDependency);
    internal ProjectDependencyGraph WithAdditionalProject(ProjectId projectId);
    internal ProjectDependencyGraph WithAdditionalProjectReferences(ProjectId projectId, IReadOnlyCollection`1<ProjectReference> projectReferences);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewTransitiveReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingTransitiveReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseTransitiveReferencesMapForAdditionalProjectReferences(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseTransitiveReferencesMap, ProjectId projectId, IReadOnlyList`1<ProjectId> referencedProjectIds);
    internal ProjectDependencyGraph WithProjectRemoved(ProjectId projectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReferencesMapForRemovedProject(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingForwardReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseReferencesMap, ProjectId removedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseReferencesMapForRemovedProject(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingForwardReferencesMap, ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseReferencesMap, ProjectId removedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewTransitiveReferencesMapForRemovedProject(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingTransitiveReferencesMap, ProjectId removedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseTransitiveReferencesMapForRemovedProject(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseTransitiveReferencesMap, ProjectId removedProjectId);
    internal ProjectDependencyGraph WithProjectReferenceRemoved(ProjectId projectId, ProjectId referencedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReferencesMapForRemovedProjectReference(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingForwardReferencesMap, ProjectId projectId, ProjectId referencedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseReferencesMapForRemovedProjectReference(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseReferencesMap, ProjectId projectId, ProjectId referencedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewTransitiveReferencesMapForRemovedProjectReference(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingTransitiveReferencesMap, ProjectId projectId, ProjectId referencedProjectId);
    private static ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> ComputeNewReverseTransitiveReferencesMapForRemovedProjectReference(ImmutableDictionary`2<ProjectId, ImmutableHashSet`1<ProjectId>> existingReverseTransitiveReferencesMap, ProjectId projectId, ProjectId referencedProjectId);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <WithProjectReferences>b__14_0(ProjectReference r);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <WithAdditionalProjectReferences>b__39_0(ProjectReference r);
}
public class Microsoft.CodeAnalysis.ProjectDiagnostic : WorkspaceDiagnostic {
    [CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    public ProjectId ProjectId { get; }
    public ProjectDiagnostic(WorkspaceDiagnosticKind kind, string message, ProjectId projectId);
    [CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.ProjectId : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [DataMemberAttribute]
private string _debugName;
    [DataMemberAttribute]
public Guid Id { get; }
    internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private ProjectId(Guid guid, string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [NullableContextAttribute("1")]
public static ProjectId CreateNewId(string debugName);
    [NullableContextAttribute("1")]
public static ProjectId CreateFromSerialized(Guid id, string debugName);
    internal string get_DebugName();
    [NullableContextAttribute("1")]
private string GetDebuggerDisplay();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectId other);
    public static bool op_Equality(ProjectId left, ProjectId right);
    public static bool op_Inequality(ProjectId left, ProjectId right);
    public virtual int GetHashCode();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    [NullableContextAttribute("1")]
private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    [NullableContextAttribute("1")]
internal static ProjectId ReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public class Microsoft.CodeAnalysis.ProjectInfo : object {
    [CompilerGeneratedAttribute]
private ProjectAttributes <Attributes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private CompilationOptions <CompilationOptions>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ParseOptions <ParseOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <Documents>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectReference> <ProjectReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<MetadataReference> <MetadataReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <AdditionalDocuments>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<DocumentInfo> <AnalyzerConfigDocuments>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Type <HostObjectType>k__BackingField;
    internal ProjectAttributes Attributes { get; }
    public ProjectId Id { get; }
    public VersionStamp Version { get; }
    public string Name { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueTuple`2<string, string> NameAndFlavor { get; }
    public string AssemblyName { get; }
    public string Language { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    [NullableAttribute("2")]
public string OutputFilePath { get; }
    [NullableAttribute("2")]
public string OutputRefFilePath { get; }
    public CompilationOutputInfo CompilationOutputInfo { get; }
    [NullableAttribute("2")]
internal string DefaultNamespace { get; }
    public bool IsSubmission { get; }
    internal bool HasAllInformation { get; }
    internal bool RunAnalyzers { get; }
    [NullableAttribute("2")]
public CompilationOptions CompilationOptions { get; }
    [NullableAttribute("2")]
public ParseOptions ParseOptions { get; }
    public IReadOnlyList`1<DocumentInfo> Documents { get; }
    public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    public IReadOnlyList`1<DocumentInfo> AdditionalDocuments { get; }
    public IReadOnlyList`1<DocumentInfo> AnalyzerConfigDocuments { get; }
    [NullableAttribute("2")]
public Type HostObjectType { get; }
    private ProjectInfo(ProjectAttributes attributes, CompilationOptions compilationOptions, ParseOptions parseOptions, IReadOnlyList`1<DocumentInfo> documents, IReadOnlyList`1<ProjectReference> projectReferences, IReadOnlyList`1<MetadataReference> metadataReferences, IReadOnlyList`1<AnalyzerReference> analyzerReferences, IReadOnlyList`1<DocumentInfo> additionalDocuments, IReadOnlyList`1<DocumentInfo> analyzerConfigDocuments, Type hostObjectType);
    [CompilerGeneratedAttribute]
internal ProjectAttributes get_Attributes();
    public ProjectId get_Id();
    public VersionStamp get_Version();
    public string get_Name();
    internal ValueTuple`2<string, string> get_NameAndFlavor();
    public string get_AssemblyName();
    public string get_Language();
    [NullableContextAttribute("2")]
public string get_FilePath();
    [NullableContextAttribute("2")]
public string get_OutputFilePath();
    [NullableContextAttribute("2")]
public string get_OutputRefFilePath();
    public CompilationOutputInfo get_CompilationOutputInfo();
    [NullableContextAttribute("2")]
internal string get_DefaultNamespace();
    public bool get_IsSubmission();
    internal bool get_HasAllInformation();
    internal bool get_RunAnalyzers();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public CompilationOptions get_CompilationOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ParseOptions get_ParseOptions();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_Documents();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_AdditionalDocuments();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<DocumentInfo> get_AnalyzerConfigDocuments();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Type get_HostObjectType();
    public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType);
    [NullableContextAttribute("2")]
public static ProjectInfo Create(ProjectId id, VersionStamp version, string name, string assemblyName, string language, string filePath, string outputFilePath, CompilationOptions compilationOptions, ParseOptions parseOptions, IEnumerable`1<DocumentInfo> documents, IEnumerable`1<ProjectReference> projectReferences, IEnumerable`1<MetadataReference> metadataReferences, IEnumerable`1<AnalyzerReference> analyzerReferences, IEnumerable`1<DocumentInfo> additionalDocuments, bool isSubmission, Type hostObjectType, string outputRefFilePath);
    internal ProjectInfo With(ProjectAttributes attributes, Optional`1<CompilationOptions> compilationOptions, Optional`1<ParseOptions> parseOptions, IReadOnlyList`1<DocumentInfo> documents, IReadOnlyList`1<ProjectReference> projectReferences, IReadOnlyList`1<MetadataReference> metadataReferences, IReadOnlyList`1<AnalyzerReference> analyzerReferences, IReadOnlyList`1<DocumentInfo> additionalDocuments, IReadOnlyList`1<DocumentInfo> analyzerConfigDocuments, Optional`1<Type> hostObjectType);
    public ProjectInfo WithVersion(VersionStamp version);
    public ProjectInfo WithName(string name);
    public ProjectInfo WithAssemblyName(string assemblyName);
    public ProjectInfo WithFilePath(string filePath);
    public ProjectInfo WithOutputFilePath(string outputFilePath);
    public ProjectInfo WithOutputRefFilePath(string outputRefFilePath);
    public ProjectInfo WithCompilationOutputInfo(CompilationOutputInfo& info);
    public ProjectInfo WithDefaultNamespace(string defaultNamespace);
    internal ProjectInfo WithHasAllInformation(bool hasAllInformation);
    internal ProjectInfo WithRunAnalyzers(bool runAnalyzers);
    public ProjectInfo WithCompilationOptions(CompilationOptions compilationOptions);
    public ProjectInfo WithParseOptions(ParseOptions parseOptions);
    public ProjectInfo WithDocuments(IEnumerable`1<DocumentInfo> documents);
    public ProjectInfo WithAdditionalDocuments(IEnumerable`1<DocumentInfo> additionalDocuments);
    public ProjectInfo WithAnalyzerConfigDocuments(IEnumerable`1<DocumentInfo> analyzerConfigDocuments);
    public ProjectInfo WithProjectReferences(IEnumerable`1<ProjectReference> projectReferences);
    public ProjectInfo WithMetadataReferences(IEnumerable`1<MetadataReference> metadataReferences);
    public ProjectInfo WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    internal ProjectInfo WithTelemetryId(Guid telemetryId);
    internal string GetDebuggerDisplay();
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
public class Microsoft.CodeAnalysis.ProjectReference : object {
    private ProjectId _projectId;
    private ImmutableArray`1<string> _aliases;
    private bool _embedInteropTypes;
    public ProjectId ProjectId { get; }
    public ImmutableArray`1<string> Aliases { get; }
    public bool EmbedInteropTypes { get; }
    public ProjectReference(ProjectId projectId, ImmutableArray`1<string> aliases, bool embedInteropTypes);
    public ProjectId get_ProjectId();
    public ImmutableArray`1<string> get_Aliases();
    public bool get_EmbedInteropTypes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ProjectReference reference);
    public static bool op_Equality(ProjectReference left, ProjectReference right);
    public static bool op_Inequality(ProjectReference left, ProjectReference right);
    public virtual int GetHashCode();
    private string GetDebuggerDisplay();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ProjectState : object {
    private ProjectInfo _projectInfo;
    private HostLanguageServices _languageServices;
    private HostWorkspaceServices _solutionServices;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TextDocumentStates`1<DocumentState> DocumentStates;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TextDocumentStates`1<AdditionalDocumentState> AdditionalDocumentStates;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public TextDocumentStates`1<AnalyzerConfigDocumentState> AnalyzerConfigDocumentStates;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentVersion;
    private AsyncLazy`1<VersionStamp> _lazyLatestDocumentTopLevelChangeVersion;
    private ValueSource`1<ProjectStateChecksums> _lazyChecksums;
    private ValueSource`1<AnalyzerConfigOptionsCache> _lazyAnalyzerConfigOptions;
    [NullableAttribute("2")]
private AnalyzerOptions _lazyAnalyzerOptions;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISourceGenerator> _lazySourceGenerators;
    public AnalyzerOptions AnalyzerOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public ProjectId Id { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public string FilePath { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public string OutputFilePath { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public string OutputRefFilePath { get; }
    [DebuggerBrowsableAttribute("2")]
public CompilationOutputInfo CompilationOutputInfo { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public string DefaultNamespace { get; }
    [DebuggerBrowsableAttribute("2")]
public HostLanguageServices LanguageServices { get; }
    [DebuggerBrowsableAttribute("2")]
public string Language { get; }
    [DebuggerBrowsableAttribute("2")]
public string Name { get; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DebuggerBrowsableAttribute("2")]
public ValueTuple`2<string, string> NameAndFlavor { get; }
    [DebuggerBrowsableAttribute("2")]
public bool IsSubmission { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public Type HostObjectType { get; }
    [DebuggerBrowsableAttribute("2")]
public bool SupportsCompilation { get; }
    [DebuggerBrowsableAttribute("2")]
public VersionStamp Version { get; }
    [DebuggerBrowsableAttribute("2")]
public ProjectInfo ProjectInfo { get; }
    [DebuggerBrowsableAttribute("2")]
public string AssemblyName { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public CompilationOptions CompilationOptions { get; }
    [NullableAttribute("2")]
[DebuggerBrowsableAttribute("2")]
public ParseOptions ParseOptions { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<MetadataReference> MetadataReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public IReadOnlyList`1<ProjectReference> ProjectReferences { get; }
    [DebuggerBrowsableAttribute("2")]
public bool HasAllInformation { get; }
    [DebuggerBrowsableAttribute("2")]
public bool RunAnalyzers { get; }
    private ProjectAttributes Attributes { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISourceGenerator> SourceGenerators { get; }
    private ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, HostWorkspaceServices solutionServices, TextDocumentStates`1<DocumentState> documentStates, TextDocumentStates`1<AdditionalDocumentState> additionalDocumentStates, TextDocumentStates`1<AnalyzerConfigDocumentState> analyzerConfigDocumentStates, AsyncLazy`1<VersionStamp> lazyLatestDocumentVersion, AsyncLazy`1<VersionStamp> lazyLatestDocumentTopLevelChangeVersion, ValueSource`1<AnalyzerConfigOptionsCache> lazyAnalyzerConfigSet);
    public ProjectState(ProjectInfo projectInfo, HostLanguageServices languageServices, HostWorkspaceServices solutionServices);
    private static ProjectInfo ClearAllDocumentsFromProjectInfo(ProjectInfo projectInfo);
    private ProjectInfo FixProjectInfo(ProjectInfo projectInfo);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentVersionAsync>d__16")]
private static Task`1<VersionStamp> ComputeLatestDocumentVersionAsync(TextDocumentStates`1<DocumentState> documentStates, TextDocumentStates`1<AdditionalDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    private AsyncLazy`1<VersionStamp> CreateLazyLatestDocumentTopLevelChangeVersion(TextDocumentState newDocument, TextDocumentStates`1<DocumentState> newDocumentStates, TextDocumentStates`1<AdditionalDocumentState> newAdditionalDocumentStates);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeTopLevelChangeTextVersionAsync>d__18")]
private static Task`1<VersionStamp> ComputeTopLevelChangeTextVersionAsync(VersionStamp oldVersion, TextDocumentState newDocument, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeLatestDocumentTopLevelChangeVersionAsync>d__19")]
private static Task`1<VersionStamp> ComputeLatestDocumentTopLevelChangeVersionAsync(TextDocumentStates`1<DocumentState> documentStates, TextDocumentStates`1<AdditionalDocumentState> additionalDocumentStates, CancellationToken cancellationToken);
    internal DocumentState CreateDocument(DocumentInfo documentInfo, ParseOptions parseOptions);
    public AnalyzerOptions get_AnalyzerOptions();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<GetAnalyzerOptionsForPathAsync>d__23")]
public Task`1<AnalyzerConfigData> GetAnalyzerOptionsForPathAsync(string path, CancellationToken cancellationToken);
    public AnalyzerConfigData GetAnalyzerOptionsForPath(string path, CancellationToken cancellationToken);
    public Nullable`1<AnalyzerConfigData> GetAnalyzerConfigOptions();
    private static ValueSource`1<AnalyzerConfigOptionsCache> ComputeAnalyzerConfigOptionsValueSource(TextDocumentStates`1<AnalyzerConfigDocumentState> analyzerConfigDocumentStates);
    public Task`1<VersionStamp> GetLatestDocumentVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<GetSemanticVersionAsync>d__33")]
public Task`1<VersionStamp> GetSemanticVersionAsync(CancellationToken cancellationToken);
    public ProjectId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    [NullableContextAttribute("2")]
public string get_OutputFilePath();
    [NullableContextAttribute("2")]
public string get_OutputRefFilePath();
    public CompilationOutputInfo get_CompilationOutputInfo();
    [NullableContextAttribute("2")]
public string get_DefaultNamespace();
    public HostLanguageServices get_LanguageServices();
    public string get_Language();
    public string get_Name();
    public ValueTuple`2<string, string> get_NameAndFlavor();
    public bool get_IsSubmission();
    [NullableContextAttribute("2")]
public Type get_HostObjectType();
    public bool get_SupportsCompilation();
    public VersionStamp get_Version();
    public ProjectInfo get_ProjectInfo();
    public string get_AssemblyName();
    [NullableContextAttribute("2")]
public CompilationOptions get_CompilationOptions();
    [NullableContextAttribute("2")]
public ParseOptions get_ParseOptions();
    public IReadOnlyList`1<MetadataReference> get_MetadataReferences();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public IReadOnlyList`1<ProjectReference> get_ProjectReferences();
    public bool get_HasAllInformation();
    public bool get_RunAnalyzers();
    [NullableContextAttribute("2")]
private ProjectState With(ProjectInfo projectInfo, Nullable`1<TextDocumentStates`1<DocumentState>> documentStates, Nullable`1<TextDocumentStates`1<AdditionalDocumentState>> additionalDocumentStates, Nullable`1<TextDocumentStates`1<AnalyzerConfigDocumentState>> analyzerConfigDocumentStates, AsyncLazy`1<VersionStamp> latestDocumentVersion, AsyncLazy`1<VersionStamp> latestDocumentTopLevelChangeVersion, ValueSource`1<AnalyzerConfigOptionsCache> analyzerConfigSet);
    private ProjectAttributes get_Attributes();
    private ProjectState WithAttributes(ProjectAttributes attributes);
    public ProjectState WithName(string name);
    public ProjectState WithFilePath(string filePath);
    public ProjectState WithAssemblyName(string assemblyName);
    public ProjectState WithOutputFilePath(string outputFilePath);
    public ProjectState WithOutputRefFilePath(string outputRefFilePath);
    public ProjectState WithCompilationOutputInfo(CompilationOutputInfo& info);
    public ProjectState WithDefaultNamespace(string defaultNamespace);
    public ProjectState WithHasAllInformation(bool hasAllInformation);
    public ProjectState WithRunAnalyzers(bool runAnalyzers);
    public ProjectState WithCompilationOptions(CompilationOptions options);
    public ProjectState WithParseOptions(ParseOptions options);
    public static bool IsSameLanguage(ProjectState project1, ProjectState project2);
    public bool ContainsReferenceToProject(ProjectId projectId);
    public ProjectState WithProjectReferences(IReadOnlyList`1<ProjectReference> projectReferences);
    public ProjectState WithMetadataReferences(IReadOnlyList`1<MetadataReference> metadataReferences);
    public ProjectState WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public ImmutableArray`1<ISourceGenerator> get_SourceGenerators();
    public ProjectState AddDocuments(ImmutableArray`1<DocumentState> documents);
    public ProjectState AddAdditionalDocuments(ImmutableArray`1<AdditionalDocumentState> documents);
    public ProjectState AddAnalyzerConfigDocuments(ImmutableArray`1<AnalyzerConfigDocumentState> documents);
    private ProjectState CreateNewStateForChangedAnalyzerConfigDocuments(TextDocumentStates`1<AnalyzerConfigDocumentState> newAnalyzerConfigDocumentStates);
    public ProjectState RemoveDocuments(ImmutableArray`1<DocumentId> documentIds);
    public ProjectState RemoveAdditionalDocuments(ImmutableArray`1<DocumentId> documentIds);
    public ProjectState RemoveAnalyzerConfigDocuments(ImmutableArray`1<DocumentId> documentIds);
    public ProjectState RemoveAllDocuments();
    public ProjectState UpdateDocument(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    public ProjectState UpdateAdditionalDocument(AdditionalDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    public ProjectState UpdateAnalyzerConfigDocument(AnalyzerConfigDocumentState newDocument);
    public ProjectState UpdateDocumentsOrder(ImmutableList`1<DocumentId> documentIds);
    private void GetLatestDependentVersions(TextDocumentStates`1<DocumentState> newDocumentStates, TextDocumentStates`1<AdditionalDocumentState> newAdditionalDocumentStates, TextDocumentState oldDocument, TextDocumentState newDocument, bool recalculateDependentVersions, bool textChanged, AsyncLazy`1& dependentDocumentVersion, AsyncLazy`1& dependentSemanticVersion);
    [NullableContextAttribute("0")]
public bool TryGetStateChecksums(ProjectStateChecksums& stateChecksums);
    [NullableContextAttribute("0")]
public Task`1<ProjectStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Checksum GetParseOptionsChecksum();
    [NullableContextAttribute("0")]
private Checksum GetParseOptionsChecksum(ISerializerService serializer);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ProjectState/<ComputeChecksumsAsync>d__120")]
private Task`1<ProjectStateChecksums> ComputeChecksumsAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private IEnumerable`1<ISourceGenerator> <get_SourceGenerators>b__101_0(AnalyzerReference a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.PublicContract : object {
    internal static IEnumerable`1<T> RequireNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static void RequireUniqueNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static IReadOnlyList`1<T> ToBoxedImmutableArrayWithNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    internal static IReadOnlyList`1<T> ToBoxedImmutableArrayWithDistinctNonNullItems(IEnumerable`1<T> sequence, string argumentName);
    [ExtensionAttribute]
private static int IndexOfNullOrDuplicateItem(IEnumerable`1<T> sequence);
    private static int EnumeratingIndexOfNullOrDuplicateItem(IEnumerable`1<T> sequence);
    [ExtensionAttribute]
private static int IndexOfNullOrDuplicateItem(IReadOnlyList`1<T> list);
    private static string MakeIndexedArgumentName(string argumentName, int index);
    [DoesNotReturnAttribute]
private static void ThrowArgumentItemNullOrDuplicateException(IEnumerable`1<T> sequence, string argumentName);
    [DoesNotReturnAttribute]
private static void ThrowArgumentItemNullException(IEnumerable`1<T> sequence, string argumentName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.ReassignedVariable.AbstractReassignedVariableService`4 : object {
    protected abstract virtual SyntaxNode GetParentScope(SyntaxNode localDeclaration);
    protected abstract virtual SyntaxNode GetMemberBlock(SyntaxNode methodOrPropertyDeclaration);
    protected abstract virtual bool HasInitializer(SyntaxNode variable);
    protected abstract virtual SyntaxToken GetIdentifierOfVariable(TVariableSyntax variable);
    protected abstract virtual SyntaxToken GetIdentifierOfSingleVariableDesignation(TSingleVariableDesignationSyntax variable);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.ReassignedVariable.AbstractReassignedVariableService`4/<GetLocationsAsync>d__5")]
public sealed virtual Task`1<ImmutableArray`1<TextSpan>> GetLocationsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static bool <GetLocationsAsync>g__AreEquivalent|5_10(ISymbol localOrParameter, ISymbol symbol);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetLocationsAsync>g__DefinitelyAssignedOnEntry|5_11(DataFlowAnalysis analysis, ISymbol localOrParameter);
}
internal interface Microsoft.CodeAnalysis.ReassignedVariable.IReassignedVariableService {
    [NullableContextAttribute("1")]
public abstract virtual Task`1<ImmutableArray`1<TextSpan>> GetLocationsAsync(Document document, TextSpan span, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Recommendations.AbstractRecommendationService`1 : object {
    protected abstract virtual AbstractRecommendationServiceRunner<TSyntaxContext> CreateRunner(TSyntaxContext context, bool filterOutOfScopeLocals, CancellationToken cancellationToken);
    public sealed virtual RecommendedSymbols GetRecommendedSymbolsInContext(SyntaxContext syntaxContext, RecommendationServiceOptions options, CancellationToken cancellationToken);
    protected static ISet`1<INamedTypeSymbol> ComputeOuterTypes(SyntaxContext context, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Recommendations.IRecommendationService {
    [NullableContextAttribute("1")]
public abstract virtual RecommendedSymbols GetRecommendedSymbolsInContext(SyntaxContext syntaxContext, RecommendationServiceOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Recommendations.RecommendationOptions : object {
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <HideAdvancedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <FilterOutOfScopeLocals>k__BackingField;
    public static PerLanguageOption`1<bool> HideAdvancedMembers { get; }
    public static PerLanguageOption`1<bool> FilterOutOfScopeLocals { get; }
    private static RecommendationOptions();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_FilterOutOfScopeLocals();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Recommendations.RecommendationServiceOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <FilterOutOfScopeLocals>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideAdvancedMembers>k__BackingField;
    public bool FilterOutOfScopeLocals { get; public set; }
    public bool HideAdvancedMembers { get; public set; }
    public RecommendationServiceOptions(bool FilterOutOfScopeLocals, bool HideAdvancedMembers);
    [CompilerGeneratedAttribute]
public bool get_FilterOutOfScopeLocals();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilterOutOfScopeLocals(bool value);
    [CompilerGeneratedAttribute]
public bool get_HideAdvancedMembers();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HideAdvancedMembers(bool value);
    [NullableContextAttribute("1")]
public static RecommendationServiceOptions From(Project project);
    [NullableContextAttribute("1")]
public static RecommendationServiceOptions From(OptionSet options, string language);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(RecommendationServiceOptions left, RecommendationServiceOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(RecommendationServiceOptions left, RecommendationServiceOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(RecommendationServiceOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& FilterOutOfScopeLocals, Boolean& HideAdvancedMembers);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Recommendations.RecommendedSymbols : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _namedSymbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _unnamedSymbols;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> NamedSymbols { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> UnnamedSymbols { get; }
    public RecommendedSymbols(ImmutableArray`1<ISymbol> namedSymbols);
    public RecommendedSymbols(ImmutableArray`1<ISymbol> namedSymbols, ImmutableArray`1<ISymbol> unnamedSymbols);
    public ImmutableArray`1<ISymbol> get_NamedSymbols();
    public ImmutableArray`1<ISymbol> get_UnnamedSymbols();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Recommendations.Recommender : object {
    [ObsoleteAttribute("Use GetRecommendedSymbolsAtPositionAsync(Document, ...)")]
public static IEnumerable`1<ISymbol> GetRecommendedSymbolsAtPosition(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use GetRecommendedSymbolsAtPositionAsync(Document, ...)")]
public static Task`1<IEnumerable`1<ISymbol>> GetRecommendedSymbolsAtPositionAsync(SemanticModel semanticModel, int position, Workspace workspace, OptionSet options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Recommendations.Recommender/<GetRecommendedSymbolsAtPositionAsync>d__2")]
public static Task`1<ImmutableArray`1<ISymbol>> GetRecommendedSymbolsAtPositionAsync(Document document, int position, OptionSet options, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.RecoverableTextAndVersion : ValueSource`1<TextAndVersion> {
    private SolutionServices _services;
    private object _initialSourceOrRecoverableText;
    [NullableAttribute("2")]
public ITemporaryTextStorageInternal Storage { get; }
    public RecoverableTextAndVersion(ValueSource`1<TextAndVersion> initialSource, SolutionServices services);
    [NullableContextAttribute("2")]
public ITemporaryTextStorageInternal get_Storage();
    public virtual bool TryGetValue(TextAndVersion& value);
    public sealed virtual bool TryGetTextVersion(VersionStamp& version);
    public virtual TextAndVersion GetValue(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RecoverableTextAndVersion/<GetValueAsync>d__8")]
public virtual Task`1<TextAndVersion> GetValueAsync(CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.RelativePathResolver : object {
    [CompilerGeneratedAttribute]
private ImmutableArray`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BaseDirectory>k__BackingField;
    public ImmutableArray`1<string> SearchPaths { get; }
    public string BaseDirectory { get; }
    public RelativePathResolver(ImmutableArray`1<string> searchPaths, string baseDirectory);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public string get_BaseDirectory();
    public string ResolvePath(string reference, string baseFilePath);
    protected virtual bool FileExists(string fullPath);
    public RelativePathResolver WithSearchPaths(ImmutableArray`1<string> searchPaths);
    public RelativePathResolver WithBaseDirectory(string baseDirectory);
    public sealed virtual bool Equals(RelativePathResolver other);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.Remote.ExportRemoteServiceCallbackDispatcherAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private Type <ServiceInterface>k__BackingField;
    public Type ServiceInterface { get; }
    public ExportRemoteServiceCallbackDispatcherAttribute(Type serviceInterface);
    [CompilerGeneratedAttribute]
public Type get_ServiceInterface();
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteHostClientProvider {
    public abstract virtual Task`1<RemoteHostClient> TryGetRemoteHostClientAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteHostClientShutdownCancellationService {
    public CancellationToken ShutdownToken { get; }
    public abstract virtual CancellationToken get_ShutdownToken();
}
internal interface Microsoft.CodeAnalysis.Remote.IRemoteProcessTelemetryService {
    public abstract virtual ValueTask EnableLoggingAsync(ImmutableArray`1<string> loggerTypeNames, ImmutableArray`1<FunctionId> functionIds, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public abstract virtual ValueTask InitializeTelemetrySessionAsync(int hostProcessId, string serializedSession, bool logDelta, CancellationToken cancellationToken);
    public abstract virtual ValueTask InitializeWorkspaceConfigurationOptionsAsync(WorkspaceConfigurationOptions options, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Remote.IRemoteServiceCallbackDispatcher {
    public abstract virtual Handle CreateHandle(object instance);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Remote.IRemoteServiceCallbackDispatcherProvider {
    public abstract virtual IRemoteServiceCallbackDispatcher GetDispatcher(Type serviceType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Remote.RemoteHostClient : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private EventHandler`1<bool> StatusChanged;
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void add_StatusChanged(EventHandler`1<bool> value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void remove_StatusChanged(EventHandler`1<bool> value);
    protected void Started();
    public virtual void Dispose();
    private void OnStatusChanged(bool started);
    public static Task`1<RemoteHostClient> TryGetClientAsync(Project project, CancellationToken cancellationToken);
    public static Task`1<RemoteHostClient> TryGetClientAsync(Workspace workspace, CancellationToken cancellationToken);
    public static Task`1<RemoteHostClient> TryGetClientAsync(SolutionServices services, CancellationToken cancellationToken);
    public abstract virtual RemoteServiceConnection`1<T> CreateConnection(object callbackTarget);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__10`1")]
public ValueTask`1<bool> TryInvokeAsync(Func`3<TService, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__11`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Func`3<TService, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__12`1")]
public ValueTask`1<bool> TryInvokeAsync(Func`4<TService, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, object callbackTarget, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__13`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Func`4<TService, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, object callbackTarget, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__14`1")]
public ValueTask`1<bool> TryInvokeAsync(Solution solution, Func`4<TService, Checksum, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__15`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Solution solution, Func`4<TService, Checksum, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__16`1")]
public ValueTask`1<bool> TryInvokeAsync(Project project, Func`4<TService, Checksum, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__17`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Project project, Func`4<TService, Checksum, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__18`1")]
public ValueTask`1<bool> TryInvokeAsync(Solution solution, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, object callbackTarget, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__19`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Solution solution, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, object callbackTarget, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__20`1")]
public ValueTask`1<bool> TryInvokeAsync(Project project, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, object callbackTarget, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteHostClient/<TryInvokeAsync>d__21`2")]
public ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Project project, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, object callbackTarget, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Remote.RemoteOptionsProvider`1 : object {
    private SolutionServices _services;
    private OptionsProvider`1<TOptions> _optionsProvider;
    public RemoteOptionsProvider`1(SolutionServices services, OptionsProvider`1<TOptions> optionsProvider);
    internal ValueTask`1<TOptions> GetOptionsAsync(string language, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackDispatcher : object {
    private int _callbackId;
    [NullableAttribute("1")]
private ConcurrentDictionary`2<RemoteServiceCallbackId, object> _callbackInstances;
    [NullableContextAttribute("2")]
public sealed virtual Handle CreateHandle(object instance);
    [NullableContextAttribute("1")]
public object GetCallback(RemoteServiceCallbackId callbackId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackDispatcherRegistry : object {
    private ImmutableDictionary`2<Type, Lazy`2<IRemoteServiceCallbackDispatcher, ExportMetadata>> _callbackDispatchers;
    public RemoteServiceCallbackDispatcherRegistry(IEnumerable`1<Lazy`2<IRemoteServiceCallbackDispatcher, ExportMetadata>> dispatchers);
    public sealed virtual IRemoteServiceCallbackDispatcher GetDispatcher(Type serviceType);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.RemoteServiceCallbackId : ValueType {
    [DataMemberAttribute]
public int Id;
    public RemoteServiceCallbackId(int id);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RemoteServiceCallbackId other);
    public virtual int GetHashCode();
    public static bool op_Equality(RemoteServiceCallbackId left, RemoteServiceCallbackId right);
    public static bool op_Inequality(RemoteServiceCallbackId left, RemoteServiceCallbackId right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Remote.RemoteServiceConnection`1 : object {
    public abstract virtual void Dispose();
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<bool> TryInvokeAsync(Func`3<TService, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Func`3<TService, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public abstract virtual ValueTask`1<bool> TryInvokeAsync(Func`4<TService, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Func`4<TService, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryInvokeAsync(Solution solution, Func`4<TService, Checksum, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Solution solution, Func`4<TService, Checksum, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryInvokeAsync(Project project, Func`4<TService, Checksum, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Project project, Func`4<TService, Checksum, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryInvokeAsync(Solution solution, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Solution solution, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> TryInvokeAsync(Project project, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask> invocation, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<Optional`1<TResult>> TryInvokeAsync(Project project, Func`5<TService, Checksum, RemoteServiceCallbackId, CancellationToken, ValueTask`1<TResult>> invocation, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Remote.RemoteSupportedLanguages : object {
    [ExtensionAttribute]
public static bool IsSupported(string language);
}
internal static class Microsoft.CodeAnalysis.Remote.RemoteUtilities : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteUtilities/<GetDocumentTextChangesAsync>d__0")]
public static ValueTask`1<ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>>> GetDocumentTextChangesAsync(Solution oldSolution, Solution newSolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.RemoteUtilities/<UpdateSolutionAsync>d__1")]
public static Task`1<Solution> UpdateSolutionAsync(Solution oldSolution, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> documentTextChanges, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation : ValueType {
    [DataMemberAttribute]
public DocumentId Document;
    [NullableAttribute("2")]
[DataMemberAttribute]
public SerializableSymbolAndProjectId Alias;
    [DataMemberAttribute]
public TextSpan Location;
    [DataMemberAttribute]
public bool IsImplicit;
    [DataMemberAttribute]
public SymbolUsageInfo SymbolUsageInfo;
    [DataMemberAttribute]
public ImmutableDictionary`2<string, string> AdditionalProperties;
    [DataMemberAttribute]
public CandidateReason CandidateReason;
    public SerializableReferenceLocation(DocumentId document, SerializableSymbolAndProjectId alias, TextSpan location, bool isImplicit, SymbolUsageInfo symbolUsageInfo, ImmutableDictionary`2<string, string> additionalProperties, CandidateReason candidateReason);
    public static SerializableReferenceLocation Dehydrate(ReferenceLocation referenceLocation, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation/<RehydrateAsync>d__9")]
public ValueTask`1<ReferenceLocation> RehydrateAsync(Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableReferenceLocation/<RehydrateAliasAsync>d__10")]
private Task`1<IAliasSymbol> RehydrateAliasAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId : object {
    [DataMemberAttribute]
public string SymbolKeyData;
    [DataMemberAttribute]
public ProjectId ProjectId;
    public SerializableSymbolAndProjectId(string symbolKeyData, ProjectId projectId);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SerializableSymbolAndProjectId other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static SerializableSymbolAndProjectId Dehydrate(IAliasSymbol alias, Document document, CancellationToken cancellationToken);
    public static SerializableSymbolAndProjectId Dehydrate(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    public static SerializableSymbolAndProjectId Create(ISymbol symbol, Project project, CancellationToken cancellationToken);
    public static bool TryCreate(ISymbol symbol, Solution solution, CancellationToken cancellationToken, SerializableSymbolAndProjectId& result);
    public static bool TryCreate(ISymbol symbol, Project project, CancellationToken cancellationToken, SerializableSymbolAndProjectId& result);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Remote.SerializableSymbolAndProjectId/<TryRehydrateAsync>d__11")]
public ValueTask`1<ISymbol> TryRehydrateAsync(Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Remote.SerializableSymbolGroup : object {
    [DataMemberAttribute]
public HashSet`1<SerializableSymbolAndProjectId> Symbols;
    private int _hashCode;
    public SerializableSymbolGroup(HashSet`1<SerializableSymbolAndProjectId> symbols);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(SerializableSymbolGroup other);
    public virtual int GetHashCode();
    public static SerializableSymbolGroup Dehydrate(Solution solution, SymbolGroup group, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsService`1 : object {
    protected IUnnecessaryImportsProvider`1<T> UnnecessaryImportsProvider { get; }
    protected abstract virtual IUnnecessaryImportsProvider`1<T> get_UnnecessaryImportsProvider();
    public sealed virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document fromDocument, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractRemoveUnnecessaryImportsService`1/<GetCommonUnnecessaryImportsOfAllContextAsync>d__4")]
protected Task`1<HashSet`1<T>> GetCommonUnnecessaryImportsOfAllContextAsync(Document document, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private sealed virtual override bool System.Collections.Generic.IEqualityComparer<T>.Equals(T x, T y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<T>.GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.RemoveUnnecessaryImports.AbstractUnnecessaryImportsProvider`1 : object {
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
    public sealed virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, CancellationToken cancellationToken);
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<TSyntaxNode>.Equals(TSyntaxNode x, TSyntaxNode y);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<TSyntaxNode>.GetHashCode(TSyntaxNode obj);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IRemoveUnnecessaryImportsService {
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document document, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> RemoveUnnecessaryImportsAsync(Document fromDocument, Func`2<SyntaxNode, bool> predicate, SyntaxFormattingOptions formattingOptions, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.RemoveUnnecessaryImports.IUnnecessaryImportsProvider`1 {
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<TSyntaxNode> GetUnnecessaryImports(SemanticModel model, Func`2<SyntaxNode, bool> predicate, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Rename.AbstractRenameRewriterLanguageService : object {
    public abstract virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
    public abstract virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    public abstract virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    public abstract virtual void TryAddPossibleNameConflicts(ISymbol symbol, string newName, ICollection`1<string> possibleNameConflicts);
    protected static void AddConflictingParametersOfProperties(IEnumerable`1<ISymbol> properties, string newPropertyName, ArrayBuilder`1<Location> conflicts);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ComplexifiedSpan : ValueType {
    [DataMemberAttribute]
public TextSpan OriginalSpan;
    [DataMemberAttribute]
public TextSpan NewSpan;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>> ModifiedSubSpans;
    public ComplexifiedSpan(TextSpan originalSpan, TextSpan newSpan, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>> modifiedSubSpans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictingIdentifierTracker : object {
    private Dictionary`2<string, List`1<SyntaxToken>> _currentIdentifiersInScope;
    private HashSet`1<SyntaxToken> _conflictingTokensToReport;
    private SyntaxToken _tokenBeingRenamed;
    public IEnumerable`1<SyntaxToken> ConflictingTokens { get; }
    public ConflictingIdentifierTracker(SyntaxToken tokenBeingRenamed, IEqualityComparer`1<string> identifierComparer);
    public IEnumerable`1<SyntaxToken> get_ConflictingTokens();
    public void AddIdentifier(SyntaxToken token);
    public void AddIdentifiers(IEnumerable`1<SyntaxToken> tokens);
    public void RemoveIdentifier(SyntaxToken token);
    public void RemoveIdentifiers(IEnumerable`1<SyntaxToken> tokens);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver : object {
    private static SymbolDisplayFormat s_metadataSymbolDisplayFormat;
    private static string s_metadataNameSeparators;
    private static ConflictResolver();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<ResolveLightweightConflictsAsync>d__2")]
internal static Task`1<ConflictResolution> ResolveLightweightConflictsAsync(ISymbol symbol, LightweightRenameLocations lightweightRenameLocations, string replacementText, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<ResolveSymbolicLocationConflictsInCurrentProcessAsync>d__3")]
internal static Task`1<ConflictResolution> ResolveSymbolicLocationConflictsInCurrentProcessAsync(SymbolicRenameLocations renameLocations, string replacementText, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    private static Task`1<MutableConflictResolution> ResolveMutableConflictsAsync(SymbolicRenameLocations renameLocationSet, Location renameSymbolDeclarationLocation, string replacementText, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> SymbolsForEnclosingInvocationExpressionWorker(SyntaxNode invocationExpression, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetExpansionTargetForLocationPerLanguage(SyntaxToken tokenOrNode, Document document);
    private static bool LocalVariableConflictPerLanguage(SyntaxToken tokenOrNode, Document document, ImmutableArray`1<ISymbol> newReferencedSymbols);
    private static bool IsIdentifierValid_Worker(Solution solution, string replacementText, IEnumerable`1<ProjectId> projectIds);
    private static bool IsRenameValid(MutableConflictResolution conflictResolution, ISymbol renamedSymbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<AddImplicitConflictsAsync>d__10")]
private static Task AddImplicitConflictsAsync(ISymbol renamedSymbol, ISymbol originalSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, MutableConflictResolution conflictResolution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<AddDeclarationConflictsAsync>d__11")]
private static Task AddDeclarationConflictsAsync(ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, MutableConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    private static void AddConflictingSymbolLocations(IEnumerable`1<ISymbol> conflictingSymbols, MutableConflictResolution conflictResolution, IDictionary`2<Location, Location> reverseMappedLocations);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<CreateDeclarationLocationAnnotationsAsync>d__13")]
public static Task`1<RenameDeclarationLocationReference[]> CreateDeclarationLocationAnnotationsAsync(Solution solution, IEnumerable`1<ISymbol> symbols, CancellationToken cancellationToken);
    private static string GetString(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.ConflictResolver/<GetSymbolLocationAsync>d__15")]
private static Task`1<Location> GetSymbolLocationAsync(Solution solution, ISymbol symbol, CancellationToken cancellationToken);
    private static bool HeuristicMetadataNameEquivalenceCheck(string oldMetadataName, string newMetadataName, string originalText, string replacementText);
    private static bool IsSubStringEqual(string str1, string str2, int index);
    private static bool IsWholeIdentifier(string metadataName, string searchText, int index);
    private static bool IsIdentifierSeparator(char element);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Rename.ConflictEngine.DeclarationConflictHelpers : object {
    public static ImmutableArray`1<Location> GetMembersWithConflictingSignatures(IMethodSymbol renamedMethod, bool trimOptionalParameters);
    public static ImmutableArray`1<Location> GetMembersWithConflictingSignatures(IPropertySymbol renamedProperty, bool trimOptionalParameters);
    private static ImmutableArray`1<Location> GetConflictLocations(ISymbol renamedMember, IEnumerable`1<ISymbol> potentiallyConflictingMembers, bool isMethod, Func`2<ISymbol, ImmutableArray`1<ImmutableArray`1<ITypeSymbol>>> getAllSignatures);
    private static ImmutableArray`1<ImmutableArray`1<ITypeSymbol>> GetAllSignatures(ImmutableArray`1<IParameterSymbol> parameters, bool trimOptionalParameters);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution : object {
    private RenamedSpansTracker _renamedSpansTracker;
    public List`1<RelatedLocation> RelatedLocations;
    public Solution OldSolution;
    public bool ReplacementTextValid;
    public string ReplacementText;
    [CompilerGeneratedAttribute]
private Solution <CurrentSolution>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2<DocumentId, string> _renamedDocument;
    public Solution CurrentSolution { get; private set; }
    public MutableConflictResolution(Solution oldSolution, RenamedSpansTracker renamedSpansTracker, string replacementText, bool replacementTextValid);
    [CompilerGeneratedAttribute]
public Solution get_CurrentSolution();
    [CompilerGeneratedAttribute]
private void set_CurrentSolution(Solution value);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    internal void UpdateCurrentSolution(Solution solution);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.MutableConflictResolution/<RemoveAllRenameAnnotationsAsync>d__13")]
internal Task`1<Solution> RemoveAllRenameAnnotationsAsync(Solution intermediateSolution, IEnumerable`1<DocumentId> documentWithRenameAnnotations, AnnotationTable`1<RenameAnnotation> annotationSet, CancellationToken cancellationToken);
    internal void RenameDocumentToMatchNewSymbol(Document document);
    public int GetAdjustedTokenStartingPosition(int startingPosition, DocumentId documentId);
    internal void AddRelatedLocation(RelatedLocation location);
    internal void AddOrReplaceRelatedLocation(RelatedLocation location);
    public ConflictResolution ToConflictResolution();
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocation : ValueType {
    [DataMemberAttribute]
public TextSpan ConflictCheckSpan;
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public RelatedLocationType Type;
    [DataMemberAttribute]
public bool IsReference;
    [DataMemberAttribute]
public TextSpan ComplexifiedTargetSpan;
    [NullableContextAttribute("1")]
public RelatedLocation(TextSpan conflictCheckSpan, DocumentId documentId, RelatedLocationType type, bool isReference, TextSpan complexifiedTargetSpan);
    public RelatedLocation WithType(RelatedLocationType type);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RelatedLocation other);
    public virtual int GetHashCode();
    public static bool op_Equality(RelatedLocation left, RelatedLocation right);
    public static bool op_Inequality(RelatedLocation left, RelatedLocation right);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.Rename.ConflictEngine.RelatedLocationType : Enum {
    public int value__;
    public static RelatedLocationType NoConflict;
    public static RelatedLocationType ResolvedReferenceConflict;
    public static RelatedLocationType ResolvedNonReferenceConflict;
    public static RelatedLocationType PossiblyResolvableConflict;
    public static RelatedLocationType UnresolvableConflict;
    public static RelatedLocationType UnresolvedConflict;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameActionAnnotation : RenameAnnotation {
    public TextSpan OriginalSpan;
    public bool IsRenameLocation;
    public bool IsOriginalTextLocation;
    public string Prefix;
    public string Suffix;
    public RenameDeclarationLocationReference[] RenameDeclarationLocationReferences;
    public bool IsNamespaceDeclarationReference;
    public bool IsMemberGroupReference;
    public bool IsInvocationExpression;
    public RenameActionAnnotation(TextSpan originalSpan, bool isRenameLocation, string prefix, string suffix, bool isOriginalTextLocation, RenameDeclarationLocationReference[] renameDeclarationLocations, bool isNamespaceDeclarationReference, bool isInvocationExpression, bool isMemberGroupReference);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameAnnotation : object {
    public static string Kind;
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameDeclarationLocationReference : object {
    public DocumentId DocumentId;
    public TextSpan TextSpan;
    public string Name;
    public int SymbolLocationsCount;
    public bool IsOverriddenFromMetadata;
    public bool IsSourceLocation { get; }
    public RenameDeclarationLocationReference(DocumentId documentId, TextSpan textSpan, bool overriddenFromMetadata, int declaringSyntaxReferencesCount);
    public RenameDeclarationLocationReference(string name, int declaringSyntaxReferencesCount);
    public bool get_IsSourceLocation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, List`1<ValueTuple`2<TextSpan, TextSpan>>> _documentToModifiedSpansMap;
    private Dictionary`2<DocumentId, List`1<MutableComplexifiedSpan>> _documentToComplexifiedSpansMap;
    public IEnumerable`1<DocumentId> DocumentIds { get; }
    internal bool IsDocumentChanged(DocumentId documentId);
    internal void AddModifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan);
    internal void AddComplexifiedSpan(DocumentId documentId, TextSpan oldSpan, TextSpan newSpan, List`1<ValueTuple`2<TextSpan, TextSpan>> modifiedSubSpans);
    internal int GetAdjustedPosition(int startingPosition, DocumentId documentId);
    internal void ClearDocuments(IEnumerable`1<DocumentId> conflictLocationDocumentIds);
    public IEnumerable`1<DocumentId> get_DocumentIds();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictEngine.RenamedSpansTracker/<SimplifyAsync>d__10")]
internal Task`1<Solution> SimplifyAsync(Solution solution, IEnumerable`1<DocumentId> documentIds, bool replacementTextValid, AnnotationTable`1<RenameAnnotation> renameAnnotations, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>>> GetDocumentToModifiedSpansMap();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ComplexifiedSpan>> GetDocumentToComplexifiedSpansMap();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameInvalidIdentifierAnnotation : RenameAnnotation {
    public static RenameInvalidIdentifierAnnotation Instance;
    private static RenameInvalidIdentifierAnnotation();
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameNodeSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
internal class Microsoft.CodeAnalysis.Rename.ConflictEngine.RenameTokenSimplificationAnnotation : RenameAnnotation {
    [CompilerGeneratedAttribute]
private TextSpan <OriginalTextSpan>k__BackingField;
    public TextSpan OriginalTextSpan { get; public set; }
    [CompilerGeneratedAttribute]
public TextSpan get_OriginalTextSpan();
    [CompilerGeneratedAttribute]
public void set_OriginalTextSpan(TextSpan value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Rename.ConflictResolution : ValueType {
    [CompilerGeneratedAttribute]
private bool <IsSuccessful>k__BackingField;
    [NullableAttribute("2")]
public string ErrorMessage;
    [NullableAttribute("2")]
private Solution _newSolutionWithoutRenamedDocument;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`2<DocumentId, string>> _renamedDocument;
    [NullableAttribute("2")]
public Solution OldSolution;
    [NullableAttribute("2")]
public Solution NewSolution;
    public Nullable`1<bool> ReplacementTextValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DocumentId> DocumentIds;
    [NullableAttribute("0")]
public ImmutableArray`1<RelatedLocation> RelatedLocations;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>>> _documentToModifiedSpansMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<ComplexifiedSpan>> _documentToComplexifiedSpansMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<RelatedLocation>> _documentToRelatedLocationsMap;
    [MemberNotNullWhenAttribute("False", "ErrorMessage")]
[MemberNotNullWhenAttribute("True", "_newSolutionWithoutRenamedDocument")]
[MemberNotNullWhenAttribute("True", "_renamedDocument")]
[MemberNotNullWhenAttribute("True", "OldSolution")]
[MemberNotNullWhenAttribute("True", "NewSolution")]
[MemberNotNullWhenAttribute("True", "ReplacementTextValid")]
public bool IsSuccessful { get; }
    public ConflictResolution(string errorMessage);
    public ConflictResolution(Solution oldSolution, Solution newSolutionWithoutRenamedDocument, bool replacementTextValid, ValueTuple`2<DocumentId, string> renamedDocument, ImmutableArray`1<DocumentId> documentIds, ImmutableArray`1<RelatedLocation> relatedLocations, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>>> documentToModifiedSpansMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ComplexifiedSpan>> documentToComplexifiedSpansMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<RelatedLocation>> documentToRelatedLocationsMap);
    [CompilerGeneratedAttribute]
[MemberNotNullWhenAttribute("False", "ErrorMessage")]
[MemberNotNullWhenAttribute("True", "_newSolutionWithoutRenamedDocument")]
[MemberNotNullWhenAttribute("True", "_renamedDocument")]
[MemberNotNullWhenAttribute("True", "OldSolution")]
[MemberNotNullWhenAttribute("True", "NewSolution")]
[MemberNotNullWhenAttribute("True", "ReplacementTextValid")]
public bool get_IsSuccessful();
    [NullableContextAttribute("0")]
public ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>> GetComplexifiedSpans(DocumentId documentId);
    public ImmutableDictionary`2<TextSpan, TextSpan> GetModifiedSpanMap(DocumentId documentId);
    [NullableContextAttribute("0")]
public ImmutableArray`1<RelatedLocation> GetRelatedLocationsForDocument(DocumentId documentId);
    internal TextSpan GetResolutionTextSpan(TextSpan originalSpan, DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.ConflictResolution/<DehydrateAsync>d__20")]
public Task`1<SerializableConflictResolution> DehydrateAsync(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.Rename.DocumentRenameOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <RenameMatchingTypeInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameMatchingTypeInComments>k__BackingField;
    [DataMemberAttribute]
public bool RenameMatchingTypeInStrings { get; public set; }
    [DataMemberAttribute]
public bool RenameMatchingTypeInComments { get; public set; }
    public DocumentRenameOptions(bool RenameMatchingTypeInStrings, bool RenameMatchingTypeInComments);
    [CompilerGeneratedAttribute]
public bool get_RenameMatchingTypeInStrings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameMatchingTypeInStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameMatchingTypeInComments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameMatchingTypeInComments(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(DocumentRenameOptions left, DocumentRenameOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(DocumentRenameOptions left, DocumentRenameOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(DocumentRenameOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& RenameMatchingTypeInStrings, Boolean& RenameMatchingTypeInComments);
}
internal interface Microsoft.CodeAnalysis.Rename.IRemoteRenameKeepAliveSession {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Rename.IRemoteRenamerService {
    public abstract virtual ValueTask KeepAliveAsync(Checksum solutionChecksum, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<SerializableConflictResolution> RenameSymbolAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, string replacementText, SymbolRenameOptions options, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<SerializableRenameLocations> FindRenameLocationsAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, SymbolRenameOptions options, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<SerializableConflictResolution> ResolveConflictsAsync(Checksum solutionChecksum, RemoteServiceCallbackId callbackId, SerializableSymbolAndProjectId symbolAndProjectId, SerializableRenameLocations renameLocationSet, string replacementText, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Rename.IRenameRewriterLanguageService {
    public abstract virtual SyntaxNode AnnotateAndRename(RenameRewriterParameters parameters);
    public abstract virtual void TryAddPossibleNameConflicts(ISymbol symbol, string newName, ICollection`1<string> possibleNameConflicts);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeDeclarationConflictsAsync(string replacementText, ISymbol renamedSymbol, ISymbol renameSymbol, IEnumerable`1<ISymbol> referencedSymbols, Solution baseSolution, Solution newSolution, IDictionary`2<Location, Location> reverseMappedLocations, CancellationToken cancellationToken);
    public abstract virtual Task`1<ImmutableArray`1<Location>> ComputeImplicitReferenceConflictsAsync(ISymbol renameSymbol, ISymbol renamedSymbol, IEnumerable`1<ReferenceLocation> implicitReferenceLocations, CancellationToken cancellationToken);
    public abstract virtual ImmutableArray`1<Location> ComputePossibleImplicitUsageConflicts(ISymbol renamedSymbol, SemanticModel semanticModel, Location originalDeclarationLocation, int newDeclarationLocationStartingPosition, CancellationToken cancellationToken);
    public abstract virtual bool LocalVariableConflict(SyntaxToken token, IEnumerable`1<ISymbol> newReferencedSymbols);
    public abstract virtual bool IsIdentifierValid(string replacementText, ISyntaxFactsService syntaxFactsService);
    [NullableContextAttribute("2")]
public abstract virtual SyntaxNode GetExpansionTargetForLocation(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.LightweightRenameLocations : object {
    public Solution Solution;
    public SymbolRenameOptions Options;
    public CodeCleanupOptionsProvider FallbackOptions;
    [NullableAttribute("0")]
public ImmutableArray`1<RenameLocation> Locations;
    [NullableAttribute("0")]
private ImmutableArray`1<SerializableReferenceLocation> _implicitLocations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<SerializableSymbolAndProjectId> _referencedSymbols;
    [NullableContextAttribute("0")]
private LightweightRenameLocations(Solution solution, SymbolRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, ImmutableArray`1<RenameLocation> locations, ImmutableArray`1<SerializableReferenceLocation> implicitLocations, ImmutableArray`1<SerializableSymbolAndProjectId> referencedSymbols);
    public SerializableRenameLocations Dehydrate();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.LightweightRenameLocations/<ToSymbolicLocationsAsync>d__8")]
public Task`1<SymbolicRenameLocations> ToSymbolicLocationsAsync(ISymbol symbol, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.LightweightRenameLocations/<FindRenameLocationsAsync>d__9")]
public static Task`1<LightweightRenameLocations> FindRenameLocationsAsync(ISymbol symbol, Solution solution, SymbolRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    public Task`1<ConflictResolution> ResolveConflictsAsync(ISymbol symbol, string replacementText, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    public LightweightRenameLocations Filter(Func`3<DocumentId, TextSpan, bool> filter);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.Rename.IRemoteRenamerService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Rename.RemoteRenamerServiceCallbackDispatcher : RemoteServiceCallbackDispatcher {
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<CodeCleanupOptions> GetOptionsAsync(RemoteServiceCallbackId callbackId, string language, CancellationToken cancellationToken);
}
public enum Microsoft.CodeAnalysis.Rename.RenameEntityKind : Enum {
    public int value__;
    public static RenameEntityKind BaseSymbol;
    public static RenameEntityKind OverloadedSymbols;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Rename.RenameLocation : ValueType {
    public Location Location;
    public DocumentId DocumentId;
    public CandidateReason CandidateReason;
    public bool IsRenamableAliasUsage;
    public bool IsRenamableAccessor;
    public TextSpan ContainingLocationForStringOrComment;
    public bool IsWrittenTo;
    public bool IsRenameInStringOrComment { get; }
    public RenameLocation(Location location, DocumentId documentId, CandidateReason candidateReason, bool isRenamableAliasUsage, bool isRenamableAccessor, bool isWrittenTo, TextSpan containingLocationForStringOrComment);
    public RenameLocation(ReferenceLocation referenceLocation, DocumentId documentId);
    public bool get_IsRenameInStringOrComment();
    public sealed virtual bool Equals(RenameLocation other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal static bool ShouldRename(RenameLocation location);
    internal static bool ShouldRename(CandidateReason candidateReason);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Use SymbolRenameOptions or DocumentRenameOptions instead")]
public static class Microsoft.CodeAnalysis.Rename.RenameOptions : object {
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <RenameInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreviewChanges>k__BackingField;
    public static Option`1<bool> RenameOverloads { get; }
    public static Option`1<bool> RenameInStrings { get; }
    public static Option`1<bool> RenameInComments { get; }
    public static Option`1<bool> PreviewChanges { get; }
    private static RenameOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameOverloads();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInStrings();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_RenameInComments();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreviewChanges();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Rename.Renamer : object {
    [ObsoleteAttribute]
private static SymbolRenameOptions GetSymbolRenameOptions(OptionSet optionSet);
    [ObsoleteAttribute]
private static DocumentRenameOptions GetDocumentRenameOptions(OptionSet optionSet);
    [ObsoleteAttribute("Use overload taking RenameOptions")]
public static Task`1<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameSymbolAsync>d__3")]
public static Task`1<Solution> RenameSymbolAsync(Solution solution, ISymbol symbol, SymbolRenameOptions options, string newName, CancellationToken cancellationToken);
    [ObsoleteAttribute("Use overload taking RenameOptions")]
public static Task`1<RenameDocumentActionSet> RenameDocumentAsync(Document document, string newDocumentName, IReadOnlyList`1<string> newDocumentFolders, OptionSet optionSet, CancellationToken cancellationToken);
    public static Task`1<RenameDocumentActionSet> RenameDocumentAsync(Document document, DocumentRenameOptions options, string newDocumentName, IReadOnlyList`1<string> newDocumentFolders, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameDocumentAsync>d__6")]
internal static Task`1<RenameDocumentActionSet> RenameDocumentAsync(Document document, DocumentRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, string newDocumentName, IReadOnlyList`1<string> newDocumentFolders, CancellationToken cancellationToken);
    internal static Task`1<LightweightRenameLocations> FindRenameLocationsAsync(Solution solution, ISymbol symbol, SymbolRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameSymbolAsync>d__8")]
internal static Task`1<ConflictResolution> RenameSymbolAsync(Solution solution, ISymbol symbol, string newName, SymbolRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.Renamer/<RenameSymbolInCurrentProcessAsync>d__9")]
private static Task`1<ConflictResolution> RenameSymbolInCurrentProcessAsync(Solution solution, ISymbol symbol, string newName, SymbolRenameOptions options, CodeCleanupOptionsProvider cleanupOptions, ImmutableArray`1<SymbolKey> nonConflictSymbolKeys, CancellationToken cancellationToken);
    internal static IRemoteRenameKeepAliveSession CreateRemoteKeepAliveSession(Solution solution, IAsynchronousOperationListener listener);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.RenameRewriterParameters : object {
    internal CancellationToken CancellationToken;
    internal ISet`1<TextSpan> ConflictLocationSpans;
    internal bool IsRenamingInStrings;
    internal bool IsRenamingInComments;
    internal Solution OriginalSolution;
    internal SyntaxTree OriginalSyntaxTree;
    internal string OriginalText;
    internal ICollection`1<string> PossibleNameConflicts;
    internal RenameAnnotation RenamedSymbolDeclarationAnnotation;
    internal Dictionary`2<TextSpan, RenameLocation> RenameLocations;
    internal RenamedSpansTracker RenameSpansTracker;
    internal ISymbol RenameSymbol;
    internal string ReplacementText;
    internal bool ReplacementTextValid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ImmutableDictionary`2<TextSpan, ImmutableSortedSet`1<TextSpan>> StringAndCommentTextSpans;
    internal SyntaxNode SyntaxRoot;
    internal Document Document;
    internal SemanticModel SemanticModel;
    internal AnnotationTable`1<RenameAnnotation> RenameAnnotations;
    public RenameRewriterParameters(RenameAnnotation renamedSymbolDeclarationAnnotation, Document document, SemanticModel semanticModel, SyntaxNode syntaxRoot, string replacementText, string originalText, ICollection`1<string> possibleNameConflicts, Dictionary`2<TextSpan, RenameLocation> renameLocations, ImmutableDictionary`2<TextSpan, ImmutableSortedSet`1<TextSpan>> stringAndCommentTextSpans, ISet`1<TextSpan> conflictLocationSpans, Solution originalSolution, ISymbol renameSymbol, bool replacementTextValid, RenamedSpansTracker renameSpansTracker, bool isRenamingInStrings, bool isRenamingInComments, AnnotationTable`1<RenameAnnotation> renameAnnotations, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Rename.RenameUtilities : object {
    internal static SyntaxToken UpdateAliasAnnotation(SyntaxToken token, ISymbol aliasSymbol, string replacementText);
    internal static ImmutableArray`1<ISymbol> GetSymbolsTouchingPosition(int position, SemanticModel semanticModel, SolutionServices services, CancellationToken cancellationToken);
    private static bool IsSymbolDefinedInsideMethod(ISymbol symbol);
    internal static IEnumerable`1<Document> GetDocumentsAffectedByRename(ISymbol symbol, Solution solution, IEnumerable`1<RenameLocation> renameLocations);
    private static bool ShouldRenameOnlyAffectDeclaringProject(ISymbol symbol);
    internal static TokenRenameInfo GetTokenRenameInfo(ISemanticFactsService semanticFacts, SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameUtilities/<GetOverloadedSymbols>d__6")]
public static IEnumerable`1<ISymbol> GetOverloadedSymbols(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameUtilities/<TryGetPropertyFromAccessorOrAnOverrideAsync>d__7")]
public static Task`1<ISymbol> TryGetPropertyFromAccessorOrAnOverrideAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    public static string ReplaceMatchingSubStrings(string replaceInsideString, string matchText, string replacementText, ImmutableSortedSet`1<TextSpan> subSpansToReplace);
    public static Regex GetRegexForMatch(string matchText);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameUtilities/<TryGetRenamableSymbolAsync>d__10")]
public static Task`1<ISymbol> TryGetRenamableSymbolAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.RenameUtilities/<FindDefinitionSymbolAsync>d__11")]
public static Task`1<ISymbol> FindDefinitionSymbolAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.SerializableConflictResolution : object {
    [DataMemberAttribute]
public string ErrorMessage;
    [DataMemberAttribute]
public SuccessfulConflictResolution Resolution;
    public SerializableConflictResolution(string errorMessage, SuccessfulConflictResolution resolution);
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SerializableConflictResolution/<RehydrateAsync>d__3")]
public Task`1<ConflictResolution> RehydrateAsync(Solution oldSolution, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.SerializableRenameLocation : ValueType {
    [DataMemberAttribute]
public TextSpan Location;
    [NullableAttribute("1")]
[DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public CandidateReason CandidateReason;
    [DataMemberAttribute]
public bool IsRenamableAliasUsage;
    [DataMemberAttribute]
public bool IsRenamableAccessor;
    [DataMemberAttribute]
public TextSpan ContainingLocationForStringOrComment;
    [DataMemberAttribute]
public bool IsWrittenTo;
    [NullableContextAttribute("1")]
public SerializableRenameLocation(TextSpan location, DocumentId documentId, CandidateReason candidateReason, bool isRenamableAliasUsage, bool isRenamableAccessor, TextSpan containingLocationForStringOrComment, bool isWrittenTo);
    public static SerializableRenameLocation Dehydrate(RenameLocation location);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SerializableRenameLocation/<RehydrateAsync>d__9")]
public ValueTask`1<RenameLocation> RehydrateAsync(Solution solution, CancellationToken cancellation);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.SerializableRenameLocations : object {
    [DataMemberAttribute]
public SymbolRenameOptions Options;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableRenameLocation> Locations;
    [DataMemberAttribute]
public ImmutableArray`1<SerializableReferenceLocation> ImplicitLocations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<SerializableSymbolAndProjectId> ReferencedSymbols;
    public SerializableRenameLocations(SymbolRenameOptions options, ImmutableArray`1<SerializableRenameLocation> locations, ImmutableArray`1<SerializableReferenceLocation> implicitLocations, ImmutableArray`1<SerializableSymbolAndProjectId> referencedSymbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SerializableRenameLocations/<RehydrateLocationsAsync>d__5")]
public ValueTask`1<ImmutableArray`1<RenameLocation>> RehydrateLocationsAsync(Solution solution, CancellationToken cancellationToken);
}
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Rename.SuccessfulConflictResolution : object {
    [DataMemberAttribute]
public bool ReplacementTextValid;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ValueTuple`2<DocumentId, string> RenamedDocument;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<DocumentId> DocumentIds;
    [DataMemberAttribute]
public ImmutableArray`1<RelatedLocation> RelatedLocations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> DocumentTextChanges;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>>> DocumentToModifiedSpansMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<ComplexifiedSpan>> DocumentToComplexifiedSpansMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<RelatedLocation>> DocumentToRelatedLocationsMap;
    public SuccessfulConflictResolution(bool replacementTextValid, ValueTuple`2<DocumentId, string> renamedDocument, ImmutableArray`1<DocumentId> documentIds, ImmutableArray`1<RelatedLocation> relatedLocations, ImmutableArray`1<ValueTuple`2<DocumentId, ImmutableArray`1<TextChange>>> documentTextChanges, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ValueTuple`2<TextSpan, TextSpan>>> documentToModifiedSpansMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<ComplexifiedSpan>> documentToComplexifiedSpansMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<RelatedLocation>> documentToRelatedLocationsMap);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations : object {
    public Solution Solution;
    public ISymbol Symbol;
    public SymbolRenameOptions Options;
    public CodeCleanupOptionsProvider FallbackOptions;
    [NullableAttribute("0")]
public ImmutableArray`1<RenameLocation> Locations;
    [NullableAttribute("0")]
public ImmutableArray`1<ReferenceLocation> ImplicitLocations;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> ReferencedSymbols;
    public SymbolicRenameLocations(ISymbol symbol, Solution solution, SymbolRenameOptions options, CodeCleanupOptionsProvider fallbackOptions, ImmutableArray`1<RenameLocation> locations, ImmutableArray`1<ReferenceLocation> implicitLocations, ImmutableArray`1<ISymbol> referencedSymbols);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations/<TryRehydrateAsync>d__0")]
internal static Task`1<SymbolicRenameLocations> TryRehydrateAsync(ISymbol symbol, Solution solution, CodeCleanupOptionsProvider fallbackOptions, SerializableRenameLocations serializableLocations, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations/<FindLocationsInCurrentProcessAsync>d__9")]
public static Task`1<SymbolicRenameLocations> FindLocationsInCurrentProcessAsync(ISymbol symbol, Solution solution, SymbolRenameOptions options, CodeCleanupOptionsProvider cleanupOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations/<GetOverloadsAsync>d__10")]
private static Task`1<ImmutableArray`1<SearchResult>> GetOverloadsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Rename.SymbolicRenameLocations/<AddLocationsReferenceSymbolsAsync>d__11")]
private static Task`1<SearchResult> AddLocationsReferenceSymbolsAsync(ISymbol symbol, Solution solution, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.Rename.SymbolRenameOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <RenameOverloads>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameInStrings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameInComments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RenameFile>k__BackingField;
    [DataMemberAttribute]
public bool RenameOverloads { get; public set; }
    [DataMemberAttribute]
public bool RenameInStrings { get; public set; }
    [DataMemberAttribute]
public bool RenameInComments { get; public set; }
    [DataMemberAttribute]
public bool RenameFile { get; public set; }
    public SymbolRenameOptions(bool RenameOverloads, bool RenameInStrings, bool RenameInComments, bool RenameFile);
    [CompilerGeneratedAttribute]
public bool get_RenameOverloads();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameOverloads(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameInStrings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameInStrings(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameInComments();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameInComments(bool value);
    [CompilerGeneratedAttribute]
public bool get_RenameFile();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_RenameFile(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SymbolRenameOptions left, SymbolRenameOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SymbolRenameOptions left, SymbolRenameOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SymbolRenameOptions other);
    [CompilerGeneratedAttribute]
public void Deconstruct(Boolean& RenameOverloads, Boolean& RenameInStrings, Boolean& RenameInComments, Boolean& RenameFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Rename.TokenRenameInfo : object {
    [CompilerGeneratedAttribute]
private bool <HasSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ISymbol> <Symbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMemberGroup>k__BackingField;
    public static TokenRenameInfo NoSymbolsTokenInfo;
    public bool HasSymbols { get; private set; }
    public IEnumerable`1<ISymbol> Symbols { get; private set; }
    public bool IsMemberGroup { get; private set; }
    public TokenRenameInfo(bool hasSymbols, IEnumerable`1<ISymbol> symbols, bool isMemberGroup);
    private static TokenRenameInfo();
    [CompilerGeneratedAttribute]
public bool get_HasSymbols();
    [CompilerGeneratedAttribute]
private void set_HasSymbols(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ISymbol> get_Symbols();
    [CompilerGeneratedAttribute]
private void set_Symbols(IEnumerable`1<ISymbol> value);
    [CompilerGeneratedAttribute]
public bool get_IsMemberGroup();
    [CompilerGeneratedAttribute]
private void set_IsMemberGroup(bool value);
    public static TokenRenameInfo CreateMemberGroupTokenInfo(IEnumerable`1<ISymbol> symbols);
    public static TokenRenameInfo CreateSingleSymbolTokenInfo(ISymbol symbol);
}
internal interface Microsoft.CodeAnalysis.ReplaceDiscardDeclarationsWithAssignments.IReplaceDiscardDeclarationsWithAssignmentsService {
    public abstract virtual Task`1<SyntaxNode> ReplaceAsync(Document document, SyntaxNode memberDeclaration, CancellationToken cancellationToken);
}
internal class Microsoft.CodeAnalysis.SemanticDocument : SyntacticDocument {
    public SemanticModel SemanticModel;
    private SemanticDocument(Document document, SourceText text, SyntaxNode root, SemanticModel semanticModel);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticDocument/<CreateAsync>d__2")]
public static Task`1<SemanticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.SemanticModelReuse.AbstractSemanticModelReuseLanguageService`4 : object {
    private static bool s_watsonReported;
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    public abstract virtual SyntaxNode TryGetContainingMethodBodyForSpeculation(SyntaxNode node);
    protected abstract virtual Task`1<SemanticModel> TryGetSpeculativeSemanticModelWorkerAsync(SemanticModel previousSemanticModel, SyntaxNode currentBodyNode, CancellationToken cancellationToken);
    protected abstract virtual SyntaxList`1<TAccessorDeclarationSyntax> GetAccessors(TBasePropertyDeclarationSyntax baseProperty);
    protected abstract virtual TBasePropertyDeclarationSyntax GetBasePropertyDeclaration(TAccessorDeclarationSyntax accessor);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.AbstractSemanticModelReuseLanguageService`4/<TryGetSpeculativeSemanticModelAsync>d__7")]
public sealed virtual Task`1<SemanticModel> TryGetSpeculativeSemanticModelAsync(SemanticModel previousSemanticModel, SyntaxNode currentBodyNode, CancellationToken cancellationToken);
    protected SyntaxNode GetPreviousBodyNode(SyntaxNode previousRoot, SyntaxNode currentRoot, SyntaxNode currentBodyNode);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseLanguageService {
    public abstract virtual SyntaxNode TryGetContainingMethodBodyForSpeculation(SyntaxNode node);
    public abstract virtual Task`1<SemanticModel> TryGetSpeculativeSemanticModelAsync(SemanticModel previousSemanticModel, SyntaxNode currentBodyNode, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService {
    [NullableContextAttribute("1")]
public abstract virtual ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseInfo : ValueType {
    public SemanticModel PreviousNonSpeculativeSemanticModel;
    public SemanticModel CurrentSemanticModel;
    public SyntaxNode BodyNode;
    public VersionStamp TopLevelSemanticVersion;
    public SemanticModelReuseInfo(SemanticModel previousNonSpeculativeSemanticModel, SemanticModel currentSemanticModel, SyntaxNode bodyNode, VersionStamp topLevelSementicVersion);
}
[ExportWorkspaceServiceFactoryAttribute("Microsoft.CodeAnalysis.SemanticModelReuse.ISemanticModelReuseWorkspaceService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SemanticModelReuse.SemanticModelReuseWorkspaceServiceFactory : object {
    [NullableContextAttribute("1")]
public sealed virtual IWorkspaceService CreateService(HostWorkspaceServices workspaceServices);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SerializableBytes : object {
    private static int ChunkSize;
    internal static PooledStream CreateReadableStream(Byte[] bytes);
    internal static PooledStream CreateReadableStream(Byte[] bytes, int length);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SerializableBytes/<CreateReadableStreamAsync>d__3")]
internal static Task`1<PooledStream> CreateReadableStreamAsync(Stream stream, CancellationToken cancellationToken);
    private static void BlowChunks(Byte[][] chunks);
    internal static PooledStream CreateWritableStream();
}
internal abstract class Microsoft.CodeAnalysis.Serialization.AbstractOptionsSerializationService : object {
    public abstract virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(ParseOptions options, ObjectWriter writer);
    public abstract virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    protected static void WriteCompilationOptionsTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    protected static void ReadCompilationOptionsFrom(ObjectReader reader, OutputKind& outputKind, Boolean& reportSuppressedDiagnostics, String& moduleName, String& mainTypeName, String& scriptClassName, OptimizationLevel& optimizationLevel, Boolean& checkOverflow, String& cryptoKeyContainer, String& cryptoKeyFile, ImmutableArray`1& cryptoPublicKey, Nullable`1& delaySign, Platform& platform, ReportDiagnostic& generalDiagnosticOption, Int32& warningLevel, IEnumerable`1& specificDiagnosticOptions, Boolean& concurrentBuild, Boolean& deterministic, Boolean& publicSign, MetadataImportOptions& metadataImportOptions, XmlReferenceResolver& xmlReferenceResolver, SourceReferenceResolver& sourceReferenceResolver, MetadataReferenceResolver& metadataReferenceResolver, AssemblyIdentityComparer& assemblyIdentityComparer, StrongNameProvider& strongNameProvider, CancellationToken cancellationToken);
    protected static void WriteParseOptionsTo(ParseOptions options, ObjectWriter writer);
    protected static void ReadParseOptionsFrom(ObjectReader reader, SourceCodeKind& kind, DocumentationMode& documentationMode, IEnumerable`1& features, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Serialization.ChecksumCache : object {
    private static ConditionalWeakTable`2<object, object> s_cache;
    private static ChecksumCache();
    public static IReadOnlyList`1<T> GetOrCreate(IReadOnlyList`1<T> unorderedList, CreateValueCallback<object, object> orderedListGetter);
    public static bool TryGetValue(object value, Checksum& checksum);
    public static Checksum GetOrCreate(object value, CreateValueCallback<object, object> checksumCreator);
    public static T GetOrCreate(object value, CreateValueCallback<object, object> checksumCreator);
}
[DefaultMemberAttribute("Item")]
internal class Microsoft.CodeAnalysis.Serialization.ChecksumCollection : ChecksumWithChildren {
    public int Count { get; }
    public Checksum Item { get; }
    public ChecksumCollection(ImmutableArray`1<Checksum> checksums);
    public ChecksumCollection(ImmutableArray`1<object> checksums);
    public sealed virtual int get_Count();
    public Checksum get_Item(int index);
    public sealed virtual IEnumerator`1<Checksum> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Serialization.ChecksumCollection/<FindAsync>d__8`1")]
internal static Task FindAsync(TextDocumentStates`1<TState> documentStates, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
    internal static void Find(IReadOnlyList`1<T> values, ChecksumWithChildren checksums, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Serialization.ChecksumWithChildren : object {
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<object> <Children>k__BackingField;
    public Checksum Checksum { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<object> Children { get; }
    public ChecksumWithChildren(ImmutableArray`1<object> children);
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<object> get_Children();
    private static Checksum CreateChecksum(ImmutableArray`1<object> children);
}
internal static class Microsoft.CodeAnalysis.Serialization.Creator : object {
    public static PooledObject`1<HashSet`1<Checksum>> CreateChecksumSet(IEnumerable`1<Checksum> checksums);
    public static PooledObject`1<List`1<T>> CreateList();
    public static PooledObject`1<Dictionary`2<Checksum, object>> CreateResultSet();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums : ChecksumWithChildren {
    public Checksum Info { get; }
    public Checksum Text { get; }
    public DocumentStateChecksums(Checksum infoChecksum, Checksum textChecksum);
    public DocumentStateChecksums(ImmutableArray`1<object> children);
    public Checksum get_Info();
    public Checksum get_Text();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Serialization.DocumentStateChecksums/<FindAsync>d__6")]
public Task FindAsync(TextDocumentState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Serialization.IOptionsSerializationService {
    public abstract virtual void WriteTo(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void WriteTo(ParseOptions options, ObjectWriter writer);
    public abstract virtual CompilationOptions ReadCompilationOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual ParseOptions ReadParseOptionsFrom(ObjectReader reader, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Serialization.ISerializerService {
    public abstract virtual void Serialize(object value, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    public abstract virtual void SerializeSourceText(SerializableSourceText text, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    public abstract virtual void SerializeCompilationOptions(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeParseOptions(ParseOptions options, ObjectWriter writer);
    public abstract virtual void SerializeProjectReference(ProjectReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeMetadataReference(MetadataReference reference, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    public abstract virtual void SerializeAnalyzerReference(AnalyzerReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public abstract virtual void SerializeChecksumWithChildren(ChecksumWithChildren checksums, ObjectWriter writer, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public abstract virtual T Deserialize(WellKnownSynchronizationKind kind, ObjectReader reader, CancellationToken cancellationToken);
    public abstract virtual Checksum CreateChecksum(object value, CancellationToken cancellationToken);
    public abstract virtual Checksum CreateParseOptionsChecksum(ParseOptions value);
}
internal interface Microsoft.CodeAnalysis.Serialization.ISupportTemporaryStorage {
    public abstract virtual IEnumerable`1<ITemporaryStreamStorageInternal> GetStorages();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Serialization.ObjectReaderExtensions : object {
    [ExtensionAttribute]
public static T[] ReadArray(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Serialization.ProjectStateChecksums : ChecksumWithChildren {
    public Checksum Info { get; }
    public Checksum CompilationOptions { get; }
    public Checksum ParseOptions { get; }
    public ChecksumCollection Documents { get; }
    public ChecksumCollection ProjectReferences { get; }
    public ChecksumCollection MetadataReferences { get; }
    public ChecksumCollection AnalyzerReferences { get; }
    public ChecksumCollection AdditionalDocuments { get; }
    public ChecksumCollection AnalyzerConfigDocuments { get; }
    public ProjectStateChecksums(Checksum infoChecksum, Checksum compilationOptionsChecksum, Checksum parseOptionsChecksum, ChecksumCollection documentChecksums, ChecksumCollection projectReferenceChecksums, ChecksumCollection metadataReferenceChecksums, ChecksumCollection analyzerReferenceChecksums, ChecksumCollection additionalDocumentChecksums, ChecksumCollection analyzerConfigDocumentChecksums);
    public ProjectStateChecksums(ImmutableArray`1<object> children);
    public Checksum get_Info();
    public Checksum get_CompilationOptions();
    public Checksum get_ParseOptions();
    public ChecksumCollection get_Documents();
    public ChecksumCollection get_ProjectReferences();
    public ChecksumCollection get_MetadataReferences();
    public ChecksumCollection get_AnalyzerReferences();
    public ChecksumCollection get_AdditionalDocuments();
    public ChecksumCollection get_AnalyzerConfigDocuments();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Serialization.ProjectStateChecksums/<FindAsync>d__20")]
public Task FindAsync(ProjectState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Serialization.SerializableSourceText : object {
    [NullableAttribute("2")]
private ITemporaryTextStorageWithName _storage;
    [NullableAttribute("2")]
private SourceText _text;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<SourceText> _computedText;
    public SerializableSourceText(ITemporaryTextStorageWithName storage);
    public SerializableSourceText(SourceText text);
    [NullableContextAttribute("2")]
private SerializableSourceText(ITemporaryTextStorageWithName storage, SourceText text);
    [NullableContextAttribute("2")]
private SourceText TryGetText();
    [NullableContextAttribute("0")]
public ImmutableArray`1<byte> GetChecksum();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Serialization.SerializableSourceText/<GetTextAsync>d__8")]
public ValueTask`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public SourceText GetText(CancellationToken cancellationToken);
    public static ValueTask`1<SerializableSourceText> FromTextDocumentStateAsync(TextDocumentState state, CancellationToken cancellationToken);
    public void Serialize(ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    public static SerializableSourceText Deserialize(ObjectReader reader, ITemporaryStorageServiceInternal storageService, ITextFactoryService textService, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Serialization.SerializationExtensions : object {
    [ExtensionAttribute]
public static WellKnownSynchronizationKind GetWellKnownSynchronizationKind(object value);
    [ExtensionAttribute]
public static CompilationOptions FixUpCompilationOptions(ProjectAttributes info, CompilationOptions compilationOptions);
    private static XmlFileResolver GetXmlResolver(string filePath);
    private static ImmutableArray`1<string> GetStrongNameKeyPaths(ProjectAttributes info);
}
internal enum Microsoft.CodeAnalysis.Serialization.SerializationKinds : Enum {
    public int value__;
    public static SerializationKinds Bits;
    public static SerializationKinds FilePath;
    public static SerializationKinds MemoryMapFile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Serialization.SerializerService : object {
    private static Func`2<WellKnownSynchronizationKind, string> s_logKind;
    private SolutionServices _workspaceServices;
    private ITemporaryStorageServiceInternal _storageService;
    private ITextFactoryService _textService;
    [NullableAttribute("2")]
private IDocumentationProviderService _documentationService;
    private IAnalyzerAssemblyLoaderProvider _analyzerLoaderProvider;
    private ConcurrentDictionary`2<string, IOptionsSerializationService> _lazyLanguageSerializationService;
    private static byte ChecksumKind;
    private static byte ChecksumWithChildrenKind;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableDictionary`2<WellKnownSynchronizationKind, Func`2<ImmutableArray`1<object>, ChecksumWithChildren>> s_creatorMap;
    private static int MetadataFailed;
    private static ConditionalWeakTable`2<Metadata, object> s_lifetimeMap;
    [ObsoleteAttribute("This factory method only provides services for the MEF export provider.", "True")]
private protected SerializerService(SolutionServices workspaceServices);
    private static SerializerService();
    public sealed virtual Checksum CreateChecksum(object value, CancellationToken cancellationToken);
    public sealed virtual void Serialize(object value, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public sealed virtual T Deserialize(WellKnownSynchronizationKind kind, ObjectReader reader, CancellationToken cancellationToken);
    private IOptionsSerializationService GetOptionsSerializationService(string languageName);
    public sealed virtual Checksum CreateParseOptionsChecksum(ParseOptions value);
    public sealed virtual void SerializeSourceText(SerializableSourceText text, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    private SourceText DeserializeSourceText(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeCompilationOptions(CompilationOptions options, ObjectWriter writer, CancellationToken cancellationToken);
    private CompilationOptions DeserializeCompilationOptions(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeParseOptions(ParseOptions options, ObjectWriter writer);
    private ParseOptions DeserializeParseOptions(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeProjectReference(ProjectReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private static ProjectReference DeserializeProjectReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeMetadataReference(MetadataReference reference, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    private MetadataReference DeserializeMetadataReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeAnalyzerReference(AnalyzerReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private AnalyzerReference DeserializeAnalyzerReference(ObjectReader reader, CancellationToken cancellationToken);
    public sealed virtual void SerializeChecksumWithChildren(ChecksumWithChildren checksums, ObjectWriter writer, CancellationToken cancellationToken);
    private ChecksumWithChildren DeserializeChecksumWithChildren(ObjectReader reader, CancellationToken cancellationToken);
    private static ImmutableDictionary`2<WellKnownSynchronizationKind, Func`2<ImmutableArray`1<object>, ChecksumWithChildren>> CreateCreatorMap();
    public static Checksum CreateChecksum(MetadataReference reference, CancellationToken cancellationToken);
    private static bool IsAnalyzerReferenceWithShadowCopyLoader(AnalyzerFileReference reference);
    public static Checksum CreateChecksum(AnalyzerReference reference, CancellationToken cancellationToken);
    public virtual void WriteMetadataReferenceTo(MetadataReference reference, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    public virtual MetadataReference ReadMetadataReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    public virtual void WriteAnalyzerReferenceTo(AnalyzerReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    public virtual AnalyzerReference ReadAnalyzerReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    protected static void WritePortableExecutableReferenceHeaderTo(PortableExecutableReference reference, SerializationKinds kind, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WritePortableExecutableReferencePropertiesTo(PortableExecutableReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private static Checksum CreatePortableExecutableReferenceChecksum(PortableExecutableReference reference, CancellationToken cancellationToken);
    private static void WriteMvidsTo(Metadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private static bool TryGetModules(AssemblyMetadata assemblyMetadata, ImmutableArray`1& modules);
    private static void WriteMvidTo(ModuleMetadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WritePortableExecutableReferenceTo(PortableExecutableReference reference, ObjectWriter writer, CancellationToken cancellationToken);
    private PortableExecutableReference ReadPortableExecutableReferenceFrom(ObjectReader reader, CancellationToken cancellationToken);
    private static void WriteTo(MetadataReferenceProperties properties, ObjectWriter writer, CancellationToken cancellationToken);
    private static MetadataReferenceProperties ReadMetadataReferencePropertiesFrom(ObjectReader reader, CancellationToken cancellationToken);
    private static void WriteTo(Metadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private static bool TryWritePortableExecutableReferenceBackedByTemporaryStorageTo(ISupportTemporaryStorage reference, ObjectWriter writer, SolutionReplicationContext context, CancellationToken cancellationToken);
    private Nullable`1<ValueTuple`2<Metadata, ImmutableArray`1<ITemporaryStreamStorageInternal>>> TryReadMetadataFrom(ObjectReader reader, SerializationKinds kind, CancellationToken cancellationToken);
    private ValueTuple`2<ModuleMetadata, ITemporaryStreamStorageInternal> ReadModuleMetadataFrom(ObjectReader reader, SerializationKinds kind, CancellationToken cancellationToken);
    private static ModuleMetadata ReadModuleMetadataFrom(ObjectReader reader, SerializationKinds kind);
    private void GetTemporaryStorage(ObjectReader reader, SerializationKinds kind, ITemporaryStreamStorageInternal& storage, Int64& length, CancellationToken cancellationToken);
    private static void GetMetadata(Stream stream, long length, ModuleMetadata& metadata, Object& lifeTimeObject);
    private static void CopyByteArrayToStream(ObjectReader reader, Stream stream, CancellationToken cancellationToken);
    private static void WriteTo(ModuleMetadata metadata, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WriteTo(MetadataReader reader, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WriteUnresolvedAnalyzerReferenceTo(AnalyzerReference reference, ObjectWriter writer);
    private static Metadata TryGetMetadata(PortableExecutableReference reference);
    [CompilerGeneratedAttribute]
private IOptionsSerializationService <GetOptionsSerializationService>b__12_0(string n);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Serialization.SolutionReplicationContext : ValueType {
    private static ObjectPool`1<ConcurrentSet`1<IDisposable>> s_pool;
    private ConcurrentSet`1<IDisposable> _resources;
    private static SolutionReplicationContext();
    public void AddResource(IDisposable resource);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Serialization.SolutionStateChecksums : ChecksumWithChildren {
    public Checksum Attributes { get; }
    public ChecksumCollection Projects { get; }
    public ChecksumCollection AnalyzerReferences { get; }
    public Checksum FrozenSourceGeneratedDocumentIdentity { get; }
    public Checksum FrozenSourceGeneratedDocumentText { get; }
    public SolutionStateChecksums(Checksum attributesChecksum, ChecksumCollection projectChecksums, ChecksumCollection analyzerReferenceChecksums, Checksum frozenSourceGeneratedDocumentIdentity, Checksum frozenSourceGeneratedDocumentText);
    public SolutionStateChecksums(ImmutableArray`1<object> children);
    public Checksum get_Attributes();
    public ChecksumCollection get_Projects();
    public ChecksumCollection get_AnalyzerReferences();
    public Checksum get_FrozenSourceGeneratedDocumentIdentity();
    public Checksum get_FrozenSourceGeneratedDocumentText();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Serialization.SolutionStateChecksums/<FindAsync>d__12")]
public Task FindAsync(SolutionState state, HashSet`1<Checksum> searchingChecksumsLeft, Dictionary`2<Checksum, object> result, CancellationToken cancellationToken);
}
internal enum Microsoft.CodeAnalysis.Serialization.WellKnownSynchronizationKind : Enum {
    public int value__;
    public static WellKnownSynchronizationKind Null;
    public static WellKnownSynchronizationKind SolutionState;
    public static WellKnownSynchronizationKind ProjectState;
    public static WellKnownSynchronizationKind DocumentState;
    public static WellKnownSynchronizationKind ChecksumCollection;
    public static WellKnownSynchronizationKind SolutionAttributes;
    public static WellKnownSynchronizationKind ProjectAttributes;
    public static WellKnownSynchronizationKind DocumentAttributes;
    public static WellKnownSynchronizationKind SourceGeneratedDocumentIdentity;
    public static WellKnownSynchronizationKind CompilationOptions;
    public static WellKnownSynchronizationKind ParseOptions;
    public static WellKnownSynchronizationKind ProjectReference;
    public static WellKnownSynchronizationKind MetadataReference;
    public static WellKnownSynchronizationKind AnalyzerReference;
    public static WellKnownSynchronizationKind SourceText;
    public static WellKnownSynchronizationKind SerializableSourceText;
    public static WellKnownSynchronizationKind SyntaxTreeIndex;
    public static WellKnownSynchronizationKind SymbolTreeInfo;
    public static WellKnownSynchronizationKind ProjectReferenceChecksumCollection;
    public static WellKnownSynchronizationKind MetadataReferenceChecksumCollection;
    public static WellKnownSynchronizationKind AnalyzerReferenceChecksumCollection;
    public static WellKnownSynchronizationKind TextDocumentChecksumCollection;
    public static WellKnownSynchronizationKind DocumentChecksumCollection;
    public static WellKnownSynchronizationKind AnalyzerConfigDocumentChecksumCollection;
    public static WellKnownSynchronizationKind ProjectChecksumCollection;
    public static WellKnownSynchronizationKind SolutionStateChecksums;
    public static WellKnownSynchronizationKind ProjectStateChecksums;
    public static WellKnownSynchronizationKind DocumentStateChecksums;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.ShadowCopyAnalyzerAssemblyLoader : DefaultAnalyzerAssemblyLoader {
    private string _baseDirectory;
    internal Task DeleteLeftoverDirectoriesTask;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Lazy`1<ValueTuple`2<string, Mutex>> _shadowCopyDirectoryAndMutex;
    private int _assemblyDirectoryId;
    [NullableContextAttribute("2")]
public ShadowCopyAnalyzerAssemblyLoader(string baseDirectory);
    private void DeleteLeftoverDirectories();
    protected virtual string GetPathToLoad(string fullPath);
    private static string CopyFileAndResources(string fullPath, string assemblyDirectory);
    private static void CopyFile(string originalPath, string shadowCopyPath);
    private static void ClearReadOnlyFlagOnFiles(string directoryPath);
    private static void ClearReadOnlyFlagOnFile(FileInfo fileInfo);
    private string CreateUniqueDirectoryForAssembly();
    private ValueTuple`2<string, Mutex> CreateUniqueDirectoryForProcess();
    [CompilerGeneratedAttribute]
private ValueTuple`2<string, Mutex> <.ctor>b__4_0();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Collections.IIntervalIntrospector`1 {
    public abstract virtual int GetStart(T value);
    public abstract virtual int GetLength(T value);
}
internal static class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree : object {
    public static IntervalTree`1<T> Create(TIntrospector& introspector, T[] values);
    public static IntervalTree`1<T> Create(TIntrospector& introspector, IEnumerable`1<T> values);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1 : object {
    [NullableAttribute("1")]
public static IntervalTree`1<T> Empty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Node<T> root;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ObjectPool`1<Stack`1<ValueTuple`2<Node<T>, bool>>> s_stackPool;
    private static IntervalTree`1();
    [NullableContextAttribute("1")]
public static IntervalTree`1<T> Create(TIntrospector& introspector, IEnumerable`1<T> values);
    protected static bool Contains(T value, int start, int length, TIntrospector& introspector);
    private static bool IntersectsWith(T value, int start, int length, TIntrospector& introspector);
    private static bool OverlapsWith(T value, int start, int length, TIntrospector& introspector);
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length, TIntrospector& introspector);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length, TIntrospector& introspector);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length, TIntrospector& introspector);
    public void FillWithIntervalsThatOverlapWith(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public void FillWithIntervalsThatIntersectWith(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public void FillWithIntervalsThatContain(int start, int length, TemporaryArray`1& builder, TIntrospector& introspector);
    public bool HasIntervalThatIntersectsWith(int position, TIntrospector& introspector);
    public bool HasIntervalThatIntersectsWith(int start, int length, TIntrospector& introspector);
    public bool HasIntervalThatOverlapsWith(int start, int length, TIntrospector& introspector);
    public bool HasIntervalThatContains(int start, int length, TIntrospector& introspector);
    private bool Any(int start, int length, TestInterval`1<T, TIntrospector> testInterval, TIntrospector& introspector);
    private ImmutableArray`1<T> GetIntervalsThatMatch(int start, int length, TestInterval`1<T, TIntrospector> testInterval, TIntrospector& introspector);
    private int FillWithIntervalsThatMatch(int start, int length, TestInterval`1<T, TIntrospector> testInterval, TemporaryArray`1& builder, TIntrospector& introspector, bool stopAfterFirst);
    private int FillWithIntervalsThatMatch(int start, int length, TestInterval`1<T, TIntrospector> testInterval, TemporaryArray`1& builder, TIntrospector& introspector, bool stopAfterFirst, Stack`1<ValueTuple`2<Node<T>, bool>> candidates);
    public bool IsEmpty();
    protected static Node<T> Insert(Node<T> root, Node<T> newNode, TIntrospector& introspector);
    private static Node<T> Insert(Node<T> root, Node<T> newNode, int newNodeStart, TIntrospector& introspector);
    private static Node<T> Balance(Node<T> node, TIntrospector& introspector);
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Collections.IntervalTree`1/<GetEnumerator>d__27")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    protected static int GetEnd(T value, TIntrospector& introspector);
    protected static int MaxEndValue(Node<T> node, TIntrospector& introspector);
    private static int Height(Node<T> node);
    private static int BalanceFactor(Node<T> node);
}
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree : object {
    public static SimpleIntervalTree`2<T, TIntrospector> Create(TIntrospector& introspector, T[] values);
    public static SimpleIntervalTree`2<T, TIntrospector> Create(TIntrospector& introspector, IEnumerable`1<T> values);
}
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.CodeAnalysis.Shared.Collections.SimpleIntervalTree`2 : IntervalTree`1<T> {
    private TIntrospector _introspector;
    [IsReadOnlyAttribute]
protected TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) Introspector { get; }
    public SimpleIntervalTree`2(TIntrospector& introspector, IEnumerable`1<T> values);
    protected TIntrospector& modreq(System.Runtime.InteropServices.InAttribute) get_Introspector();
    [NullableContextAttribute("1")]
public void AddIntervalInPlace(T value);
    public void ClearInPlace();
    public ImmutableArray`1<T> GetIntervalsThatOverlapWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatIntersectWith(int start, int length);
    public ImmutableArray`1<T> GetIntervalsThatContain(int start, int length);
    public void FillWithIntervalsThatOverlapWith(int start, int length, TemporaryArray`1& builder);
    public void FillWithIntervalsThatIntersectWith(int start, int length, TemporaryArray`1& builder);
    public void FillWithIntervalsThatContain(int start, int length, TemporaryArray`1& builder);
    public bool HasIntervalThatIntersectsWith(int position);
    public bool HasIntervalThatOverlapsWith(int start, int length);
    public bool HasIntervalThatIntersectsWith(int start, int length);
    public bool HasIntervalThatContains(int start, int length);
    [NullableContextAttribute("1")]
protected int MaxEndValue(Node<T> node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.TemporaryArray`1 : ValueType {
    private static int InlineCapacity;
    private T _item0;
    private T _item1;
    private T _item2;
    private T _item3;
    private int _count;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _builder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TemporaryArray`1<T> Empty { get; }
    public int Count { get; }
    public T Item { get; public set; }
    private TemporaryArray`1(TemporaryArray`1& array);
    public static TemporaryArray`1<T> get_Empty();
    [IsReadOnlyAttribute]
public int get_Count();
    [IsReadOnlyAttribute]
public T get_Item(int index);
    public void set_Item(int index, T value);
    public sealed virtual void Dispose();
    public void Add(T item);
    public void AddRange(ImmutableArray`1<T> items);
    public void AddRange(TemporaryArray`1& items);
    public void Clear();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public ImmutableArray`1<T> ToImmutableAndClear();
    [MemberNotNullAttribute("_builder")]
private void MoveInlineToBuilder();
    private static void ThrowIndexOutOfRangeException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Collections.TemporaryArrayExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TemporaryArray`1& AsRef(TemporaryArray`1& array);
    [ExtensionAttribute]
public static bool Any(TemporaryArray`1& array, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool All(TemporaryArray`1& array, Func`2<T, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(TemporaryArray`1& array, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(TemporaryArray`1& array, T value);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Collections.TextSpanIntervalIntrospector : ValueType {
    public sealed virtual int GetStart(TextSpan value);
    public sealed virtual int GetLength(TextSpan value);
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.AccessibilityUtilities : object {
    public static Accessibility Minimum(Accessibility accessibility1, Accessibility accessibility2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ArrayExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullOrEmpty(T[] array);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(T[] array, T item);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.BackgroundAnalysisScopeExtensions : object {
    [ExtensionAttribute]
public static CompilerDiagnosticsScope ToEquivalentCompilerDiagnosticsScope(BackgroundAnalysisScope backgroundAnalysisScope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ChildSyntaxListExtensions : object {
    [ExtensionAttribute]
public static SyntaxNodeOrToken First(ChildSyntaxList childSyntaxList, Func`2<SyntaxNodeOrToken, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNodeOrToken Last(ChildSyntaxList childSyntaxList, Func`2<SyntaxNodeOrToken, bool> predicate);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CodeActionExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.CodeActionExtensions/<GetRequiredChangedSolutionAsync>d__0")]
[ExtensionAttribute]
public static Task`1<Solution> GetRequiredChangedSolutionAsync(CodeAction codeAction, IProgressTracker progressTracker, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.CompilationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static INamedTypeSymbol GetBestTypeByMetadataName(Compilation compilation, string fullyQualifiedMetadataName);
}
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.ISyntaxContextService {
    [NullableContextAttribute("1")]
public abstract virtual SyntaxContext CreateContext(Document document, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Extensions.ContextQuery.SyntaxContext : object {
    [CompilerGeneratedAttribute]
private Document <Document>k__BackingField;
    [CompilerGeneratedAttribute]
private SemanticModel <SemanticModel>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxTree <SyntaxTree>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <LeftToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxToken <TargetToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAnyExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAtEndOfPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAtStartOfPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAttributeNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAwaitKeywordContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnumTypeMemberAccessContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGenericConstraintContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGlobalStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInImportsDirective>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInQuery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTaskLikeTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNameOfContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNamespaceDeclarationNameContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOnArgumentListBracketOrComma>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPossibleTupleContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorDirectiveContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPreProcessorExpressionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightOfNameSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRightSideOfNumericType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStatementContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTypeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWithinAsyncMethod>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<ITypeSymbol> <InferredTypes>k__BackingField;
    public Document Document { get; }
    public SemanticModel SemanticModel { get; }
    public SyntaxTree SyntaxTree { get; }
    public int Position { get; }
    public SyntaxToken LeftToken { get; }
    public SyntaxToken TargetToken { get; }
    public bool IsAnyExpressionContext { get; }
    public bool IsAtEndOfPattern { get; }
    public bool IsAtStartOfPattern { get; }
    public bool IsAttributeNameContext { get; }
    public bool IsAwaitKeywordContext { get; }
    public bool IsEnumTypeMemberAccessContext { get; }
    public bool IsGenericConstraintContext { get; }
    public bool IsGlobalStatementContext { get; }
    public bool IsInImportsDirective { get; }
    public bool IsInQuery { get; }
    public bool IsTaskLikeTypeContext { get; }
    public bool IsNameOfContext { get; }
    public bool IsNamespaceContext { get; }
    public bool IsNamespaceDeclarationNameContext { get; }
    public bool IsOnArgumentListBracketOrComma { get; }
    public bool IsPossibleTupleContext { get; }
    public bool IsPreProcessorDirectiveContext { get; }
    public bool IsPreProcessorExpressionContext { get; }
    public bool IsRightOfNameSeparator { get; }
    public bool IsRightSideOfNumericType { get; }
    public bool IsStatementContext { get; }
    public bool IsTypeContext { get; }
    public bool IsWithinAsyncMethod { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ITypeSymbol> InferredTypes { get; }
    protected SyntaxContext(Document document, SemanticModel semanticModel, int position, SyntaxToken leftToken, SyntaxToken targetToken, bool isAnyExpressionContext, bool isAtEndOfPattern, bool isAtStartOfPattern, bool isAttributeNameContext, bool isAwaitKeywordContext, bool isEnumTypeMemberAccessContext, bool isGenericConstraintContext, bool isGlobalStatementContext, bool isInImportsDirective, bool isInQuery, bool isTaskLikeTypeContext, bool isNameOfContext, bool isNamespaceContext, bool isNamespaceDeclarationNameContext, bool isOnArgumentListBracketOrComma, bool isPossibleTupleContext, bool isPreProcessorDirectiveContext, bool isPreProcessorExpressionContext, bool isRightOfNameSeparator, bool isRightSideOfNumericType, bool isStatementContext, bool isTypeContext, bool isWithinAsyncMethod, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Document get_Document();
    [CompilerGeneratedAttribute]
public SemanticModel get_SemanticModel();
    [CompilerGeneratedAttribute]
public SyntaxTree get_SyntaxTree();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public SyntaxToken get_LeftToken();
    [CompilerGeneratedAttribute]
public SyntaxToken get_TargetToken();
    [CompilerGeneratedAttribute]
public bool get_IsAnyExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsAtEndOfPattern();
    [CompilerGeneratedAttribute]
public bool get_IsAtStartOfPattern();
    [CompilerGeneratedAttribute]
public bool get_IsAttributeNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsAwaitKeywordContext();
    [CompilerGeneratedAttribute]
public bool get_IsEnumTypeMemberAccessContext();
    [CompilerGeneratedAttribute]
public bool get_IsGenericConstraintContext();
    [CompilerGeneratedAttribute]
public bool get_IsGlobalStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsInImportsDirective();
    [CompilerGeneratedAttribute]
public bool get_IsInQuery();
    [CompilerGeneratedAttribute]
public bool get_IsTaskLikeTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsNameOfContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceContext();
    [CompilerGeneratedAttribute]
public bool get_IsNamespaceDeclarationNameContext();
    [CompilerGeneratedAttribute]
public bool get_IsOnArgumentListBracketOrComma();
    [CompilerGeneratedAttribute]
public bool get_IsPossibleTupleContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorDirectiveContext();
    [CompilerGeneratedAttribute]
public bool get_IsPreProcessorExpressionContext();
    [CompilerGeneratedAttribute]
public bool get_IsRightOfNameSeparator();
    [CompilerGeneratedAttribute]
public bool get_IsRightSideOfNumericType();
    [CompilerGeneratedAttribute]
public bool get_IsStatementContext();
    [CompilerGeneratedAttribute]
public bool get_IsTypeContext();
    [CompilerGeneratedAttribute]
public bool get_IsWithinAsyncMethod();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ITypeSymbol> get_InferredTypes();
    public TService GetLanguageService();
    public TService GetRequiredLanguageService();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DiagnosticDescriptorExtensions : object {
    private static string DotnetAnalyzerDiagnosticPrefix;
    private static string DotnetDiagnosticPrefix;
    private static string CategoryPrefix;
    private static string SeveritySuffix;
    private static string DotnetAnalyzerDiagnosticSeverityKey;
    [ExtensionAttribute]
public static ImmutableArray`1<string> ImmutableCustomTags(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, CompilationOptions compilationOptions, ImmutableDictionary`2<string, string> analyzerOptions, ImmutableDictionary`2<string, ReportDiagnostic> treeOptions);
    [ExtensionAttribute]
public static bool IsDefinedInEditorConfig(DiagnosticDescriptor descriptor, AnalyzerConfigOptions analyzerConfigOptions);
    [ExtensionAttribute]
public static ReportDiagnostic GetEffectiveSeverity(DiagnosticDescriptor descriptor, AnalyzerConfigOptions analyzerConfigOptions);
    private static bool TryGetSeverityFromBulkConfiguration(DiagnosticDescriptor descriptor, ImmutableDictionary`2<string, string> analyzerOptions, ReportDiagnostic& severity);
    [ExtensionAttribute]
public static bool IsCompilationEnd(DiagnosticDescriptor descriptor);
    [ExtensionAttribute]
internal static Uri GetValidHelpLinkUri(DiagnosticDescriptor descriptor);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetSyntaxTreeIndexAsync>d__0")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxTreeIndex> GetSyntaxTreeIndexAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<SyntaxTreeIndex> GetSyntaxTreeIndexAsync(Document document, bool loadOnly, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetPartialSemanticModelAsync>d__2")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<Document, SemanticModel>> GetPartialSemanticModelAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static Document WithSolutionOptions(Document document, OptionSet options);
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Document document);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(Document document);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSemanticModelAsync>d__6")]
[ExtensionAttribute]
public static ValueTask`1<SemanticModel> GetRequiredSemanticModelAsync(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSyntaxTreeAsync>d__7")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxTree> GetRequiredSyntaxTreeAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxTree GetRequiredSyntaxTreeSynchronously(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetRequiredSyntaxRootAsync>d__9")]
[ExtensionAttribute]
public static ValueTask`1<SyntaxNode> GetRequiredSyntaxRootAsync(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode GetRequiredSyntaxRootSynchronously(Document document, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsOpen(TextDocument document);
    [ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, int position, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<ReuseExistingSpeculativeModelAsync>d__13")]
[ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<SemanticModel> ReuseExistingSpeculativeModelAsync(Document document, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsGeneratedCode(Document document, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<IsGeneratedCodeAsync>d__16")]
[ExtensionAttribute]
public static Task`1<bool> IsGeneratedCodeAsync(Document document, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.DocumentExtensions/<GetLinkedDocuments>d__17")]
[ExtensionAttribute]
public static IEnumerable`1<Document> GetLinkedDocuments(Document document);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.FileLinePositionSpanExtensions : object {
    [ExtensionAttribute]
public static TextSpan GetClampedTextSpan(FileLinePositionSpan span, SourceText text);
    [ExtensionAttribute]
public static LinePositionSpan GetClampedSpan(FileLinePositionSpan span, SourceText text);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IAssemblySymbolExtensions : object {
    private static string AttributeSuffix;
    [ExtensionAttribute]
public static bool ContainsNamespaceName(List`1<IAssemblySymbol> assemblies, string namespaceName);
    [ExtensionAttribute]
public static bool ContainsTypeName(List`1<IAssemblySymbol> assemblies, string typeName, bool tryWithAttributeSuffix);
    [ExtensionAttribute]
public static bool IsSameAssemblyOrHasFriendAccessTo(IAssemblySymbol assembly, IAssemblySymbol toAssembly);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IAsyncEnumerableExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.IAsyncEnumerableExtensions/<ToImmutableArrayAsync>d__0`1")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<T>> ToImmutableArrayAsync(IAsyncEnumerable`1<T> values, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICollectionExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<T> WhereAsArray(IEnumerable`1<T> values, Func`3<T, TState, bool> predicate, TState state);
    [ExtensionAttribute]
public static void RemoveRange(ICollection`1<T> collection, IEnumerable`1<T> items);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static void AddIfNotNull(ICollection`1<T> collection, Nullable`1<T> value);
    [ExtensionAttribute]
public static void AddIfNotNull(ICollection`1<T> collection, T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IComparerExtensions : object {
    [ExtensionAttribute]
public static IComparer`1<T> Inverse(IComparer`1<T> comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ICompilationExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Compilation> GetReferencedCompilations(Compilation compilation);
    [ExtensionAttribute]
public static ImmutableArray`1<IAssemblySymbol> GetReferencedAssemblySymbols(Compilation compilation, bool excludePreviousSubmissions);
    [ExtensionAttribute]
public static INamedTypeSymbol AttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DebuggerDisplayAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol StructLayoutAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerCategoryAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DesignerGeneratedAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol HideModuleNameAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ThreadStaticAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EventArgsType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotImplementedExceptionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EqualityComparerOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ActionType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ExpressionOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol EditorBrowsableStateType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTaskType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ValueTaskOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumerableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumerableOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IEnumeratorOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IAsyncEnumerableOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol IAsyncEnumeratorOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializableAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CoClassType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComAliasNameAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SuppressMessageAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol TupleElementNamesAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NativeIntegerAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DynamicAttributeType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol LazyOfTType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ISerializableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SerializationInfoType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol StreamingContextType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnDeserializingAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnDeserializedAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnSerializingAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol OnSerializedAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComRegisterFunctionAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ComUnregisterFunctionAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ConditionalAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol ObsoleteAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemCompositionImportingConstructorAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemComponentModelCompositionImportingConstructorAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol SystemIDisposableType(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol NotNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol MaybeNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol MaybeNullWhenAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol AllowNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DisallowNullAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DataMemberAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol DataContractAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol AsyncMethodBuilderAttribute(Compilation compilation);
    [ExtensionAttribute]
public static INamedTypeSymbol CancellationTokenType(Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IFindReferencesResultExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<Location> GetDefinitionLocationsToShow(ISymbol definition);
    [ExtensionAttribute]
public static ImmutableArray`1<ReferencedSymbol> FilterToItemsToShow(ImmutableArray`1<ReferencedSymbol> result, FindReferencesSearchOptions options);
    [ExtensionAttribute]
public static bool ShouldShow(ReferencedSymbol referencedSymbol, FindReferencesSearchOptions options);
    [ExtensionAttribute]
public static bool ShouldShowWithNoReferenceLocations(ISymbol definition, FindReferencesSearchOptions options, bool showMetadataSymbolsWithoutReferences);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ReferencedSymbol> FilterToAliasMatches(ImmutableArray`1<ReferencedSymbol> result, IAliasSymbol aliasSymbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ReferencedSymbol> FilterNonMatchingMethodNames(ImmutableArray`1<ReferencedSymbol> result, Solution solution, ISymbol symbol);
    private static ImmutableArray`1<ReferencedSymbol> FilterNonMatchingMethodNamesWorker(ImmutableArray`1<ReferencedSymbol> references, Solution solution, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageMetadataExtensions : object {
    [ExtensionAttribute]
public static TInterface ToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static IEnumerable`1<TInterface> FilterToSpecificLanguage(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services, string languageName);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMap(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
    [ExtensionAttribute]
public static ImmutableDictionary`2<string, ImmutableArray`1<Lazy`2<TInterface, TMetadata>>> ToPerLanguageMapWithMultipleLanguages(IEnumerable`1<Lazy`2<TInterface, TMetadata>> services);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ILanguageServiceProviderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IEnumerable`1<Lazy`2<T, TMetadata>> SelectMatchingExtensions(HostLanguageServices serviceProvider, IEnumerable`1<Lazy`2<T, TMetadata>> items);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IMethodSymbolExtensions : object {
    [ExtensionAttribute]
public static bool CompatibleSignatureToDelegate(IMethodSymbol method, INamedTypeSymbol delegateType);
    [ExtensionAttribute]
public static IMethodSymbol RenameTypeParameters(IMethodSymbol method, ImmutableArray`1<string> newNames);
    [ExtensionAttribute]
public static IMethodSymbol RenameParameters(IMethodSymbol method, ImmutableArray`1<string> parameterNames);
    private static ImmutableArray`1<ITypeParameterSymbol> RenameTypeParameters(ImmutableArray`1<ITypeParameterSymbol> typeParameters, ImmutableArray`1<string> newNames, ITypeGenerator typeGenerator);
    [ExtensionAttribute]
public static IMethodSymbol EnsureNonConflictingNames(IMethodSymbol method, INamedTypeSymbol containingType, ISyntaxFactsService syntaxFacts);
    [ExtensionAttribute]
public static IMethodSymbol RemoveInaccessibleAttributesAndAttributesOfTypes(IMethodSymbol method, ISymbol accessibleWithin, INamedTypeSymbol[] removeAttributeTypes);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMoreSpecificThan(IMethodSymbol method1, IMethodSymbol method2);
    [ExtensionAttribute]
public static ImmutableArray`1<IMethodSymbol> GetAllMethodSymbolsOfPartialParts(IMethodSymbol method);
    [ExtensionAttribute]
public static bool HasEventHandlerSignature(IMethodSymbol method, INamedTypeSymbol eventArgsType);
    [ExtensionAttribute]
public static bool TryGetPredefinedComparisonOperator(IMethodSymbol symbol, PredefinedOperator& op);
    [ExtensionAttribute]
public static PredefinedOperator GetPredefinedOperator(IMethodSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEntryPoint(IMethodSymbol methodSymbol, INamedTypeSymbol taskType, INamedTypeSymbol genericTaskType);
    [ExtensionAttribute]
public static bool IsAsyncReturningVoidTask(IMethodSymbol method, Compilation compilation);
    [CompilerGeneratedAttribute]
internal static bool <RemoveInaccessibleAttributesAndAttributesOfTypes>g__shouldRemoveAttribute|5_1(AttributeData a, ValueTuple`2<INamedTypeSymbol[], ISymbol> arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions : object {
    [ExtensionAttribute]
public static INamespaceOrTypeSymbol GenerateRootNamespaceOrType(INamedTypeSymbol namedType, String[] containers);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetBaseTypesAndThis>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypesAndThis(INamedTypeSymbol namedType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetAllTypeParameters(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetAllTypeArguments(INamedTypeSymbol symbol);
    private static Stack`1<INamedTypeSymbol> GetContainmentStack(INamedTypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsContainedWithin(INamedTypeSymbol symbol, INamedTypeSymbol outer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol FindImplementationForAbstractMember(INamedTypeSymbol type, ISymbol symbol);
    private static bool ImplementationExists(INamedTypeSymbol classOrStructType, ISymbol member);
    [ExtensionAttribute]
private static bool IsImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, CancellationToken cancellationToken);
    private static bool IsInterfacePropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol);
    private static bool IsAbstractPropertyImplemented(INamedTypeSymbol classOrStructType, IPropertySymbol propertySymbol);
    [ExtensionAttribute]
private static bool IsExplicitlyImplemented(INamedTypeSymbol classOrStructType, ISymbol member, Func`3<INamedTypeSymbol, ISymbol, bool> isValid, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool includeMembersRequiringExplicitImplementation, CancellationToken cancellationToken);
    private static bool IsImplementable(ISymbol m);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembersInThis(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedExplicitMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, CancellationToken cancellationToken);
    private static ImmutableArray`1<ISymbol> GetExplicitlyImplementableMembers(INamedTypeSymbol type, ISymbol within);
    private static bool IsPropertyWithInaccessibleImplementableAccessor(ISymbol member, ISymbol within);
    private static bool IsInaccessibleImplementableAccessor(IMethodSymbol accessor, ISymbol within);
    [ExtensionAttribute]
private static ImmutableArray`1<ValueTuple`2<INamedTypeSymbol, ImmutableArray`1<ISymbol>>> GetAllUnimplementedMembers(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetTypesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfacesOrAbstractClasses, bool allowReimplementation, CancellationToken cancellationToken);
    private static ImmutableArray`1<INamedTypeSymbol> GetAbstractClassesToImplement(IEnumerable`1<INamedTypeSymbol> abstractClasses);
    private static ImmutableArray`1<INamedTypeSymbol> GetInterfacesToImplement(INamedTypeSymbol classOrStructType, IEnumerable`1<INamedTypeSymbol> interfaces, bool allowReimplementation, CancellationToken cancellationToken);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetUnimplementedMembers(INamedTypeSymbol classOrStructType, INamedTypeSymbol interfaceType, Func`5<INamedTypeSymbol, ISymbol, Func`3<INamedTypeSymbol, ISymbol, bool>, CancellationToken, bool> isImplemented, Func`3<INamedTypeSymbol, ISymbol, bool> isValidImplementation, Func`3<INamedTypeSymbol, ISymbol, ImmutableArray`1<ISymbol>> interfaceMemberGetter, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamedTypeSymbolExtensions/<GetAttributeNamedParameters>d__25")]
[ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetAttributeNamedParameters(INamedTypeSymbol attributeSymbol, Compilation compilation, ISymbol within);
    private static ISymbol IsAttributeNamedParameter(ISymbol symbol, ISymbol within);
    private static ImmutableArray`1<ISymbol> GetMembers(INamedTypeSymbol type, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetOverridableMembers(INamedTypeSymbol containingType, CancellationToken cancellationToken);
    private static void AddOverridableMembers(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, INamedTypeSymbol type, Int32& index, CancellationToken cancellationToken);
    private static bool IsOverridable(ISymbol member, INamedTypeSymbol containingType);
    private static void RemoveOverriddenMembers(Dictionary`2<ISymbol, int> result, INamedTypeSymbol containingType, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static bool IsEqualsObjectOverride(ISymbol member);
    private static bool IsEqualsObject(ISymbol member);
    [ExtensionAttribute]
public static INamedTypeSymbol TryConstruct(INamedTypeSymbol type, ITypeSymbol[] typeArguments);
    [CompilerGeneratedAttribute]
internal static bool <IsInterfacePropertyImplemented>g__IsAccessorImplemented|9_0(IMethodSymbol accessor, INamedTypeSymbol classOrStructType);
    [CompilerGeneratedAttribute]
internal static ImmutableArray`1<ISymbol> <GetAllUnimplementedMembers>g__GetImplicitlyImplementableMembers|12_0(INamedTypeSymbol type, ISymbol within);
    [CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsPropertyWithNonPublicImplementableAccessor|12_1(ISymbol member);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsNonPublicImplementableAccessor|12_2(IMethodSymbol accessor);
    [CompilerGeneratedAttribute]
internal static bool <GetAllUnimplementedMembers>g__IsImplicitlyImplementable|12_3(ISymbol member, ISymbol within);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceOrTypeSymbol, List`1<string>> s_namespaceOrTypeToNameMap;
    private static SymbolDisplayFormat s_shortNameFormat;
    private static INamespaceOrTypeSymbolExtensions();
    [ExtensionAttribute]
public static string GetShortName(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetIndexers(INamespaceOrTypeSymbol symbol);
    [ExtensionAttribute]
public static IReadOnlyList`1<string> GetNameParts(INamespaceOrTypeSymbol symbol);
    public static int CompareNameParts(IReadOnlyList`1<string> names1, IReadOnlyList`1<string> names2, bool placeSystemNamespaceFirst);
    private static void GetNameParts(INamespaceOrTypeSymbol namespaceOrTypeSymbol, List`1<string> result);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceOrTypeSymbolExtensions/<GetAllTypes>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(INamespaceOrTypeSymbol namespaceOrTypeSymbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions : object {
    private static ConditionalWeakTable`2<INamespaceSymbol, List`1<string>> s_namespaceToNameMap;
    public static Comparison`1<INamespaceSymbol> CompareNamespaces;
    public static IEqualityComparer`1<INamespaceSymbol> EqualityComparer;
    private static INamespaceSymbolExtensions();
    private static List`1<string> GetNameParts(INamespaceSymbol namespaceSymbol);
    private static void GetNameParts(INamespaceSymbol namespaceSymbol, List`1<string> result);
    [ExtensionAttribute]
public static int CompareTo(INamespaceSymbol n1, INamespaceSymbol n2);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<GetAllNamespacesAndTypes>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceOrTypeSymbol> GetAllNamespacesAndTypes(INamespaceSymbol namespaceSymbol, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<GetAllNamespaces>d__8")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceSymbol> GetAllNamespaces(INamespaceSymbol namespaceSymbol, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetAllTypes(IEnumerable`1<INamespaceSymbol> namespaceSymbols, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.INamespaceSymbolExtensions/<FindNamespaces>d__10")]
[ExtensionAttribute]
public static IEnumerable`1<INamespaceSymbol> FindNamespaces(INamespaceSymbol namespaceSymbol, string namespaceName, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool ContainsAccessibleTypesOrNamespaces(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly);
    [ExtensionAttribute]
public static INamespaceSymbol GetQualifiedNamespace(INamespaceSymbol globalNamespace, string namespaceName);
    [ExtensionAttribute]
private static bool ContainsAccessibleTypesOrNamespacesWorker(INamespaceSymbol namespaceSymbol, IAssemblySymbol assembly, Queue`1<INamespaceOrTypeSymbol> namespaceQueue);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IObjectWritableExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void WriteTo(IObjectWritable object, ObjectWriter writer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static IParameterSymbol RenameParameter(IParameterSymbol parameter, string parameterName);
    [ExtensionAttribute]
public static IParameterSymbol WithAttributes(IParameterSymbol parameter, ImmutableArray`1<AttributeData> attributes);
    [ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> RenameParameters(IList`1<IParameterSymbol> parameters, ImmutableArray`1<string> parameterNames);
    [ExtensionAttribute]
public static IPropertySymbol GetAssociatedSynthesizedRecordProperty(IParameterSymbol parameter, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsRefOrOut(IParameterSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.IPropertySymbolExtensions : object {
    [ExtensionAttribute]
public static IPropertySymbol RenameParameters(IPropertySymbol property, ImmutableArray`1<string> parameterNames);
    [ExtensionAttribute]
public static IPropertySymbol RemoveInaccessibleAttributesAndAttributesOfTypes(IPropertySymbol property, ISymbol accessibleWithin, INamedTypeSymbol[] attributesToRemove);
    [ExtensionAttribute]
public static bool IsWritableInConstructor(IPropertySymbol property);
    [ExtensionAttribute]
public static IFieldSymbol GetBackingFieldIfAny(IPropertySymbol property);
    private static bool ContainsBackingField(IPropertySymbol property);
    [CompilerGeneratedAttribute]
internal static bool <RemoveInaccessibleAttributesAndAttributesOfTypes>g__shouldRemoveAttribute|1_2(AttributeData a, ValueTuple`2<INamedTypeSymbol[], ISymbol> arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetGlobalNamespacesAsync>d__0")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<INamespaceSymbol>> GetGlobalNamespacesAsync(Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Nullable`1<TextDocumentKind> GetDocumentKind(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static Solution WithTextDocumentText(Solution solution, DocumentId documentId, SourceText text, PreservationMode mode);
    [ExtensionAttribute]
public static ImmutableArray`1<DocumentId> FilterDocumentIdsByLanguage(Solution solution, ImmutableArray`1<DocumentId> documentIds, string language);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetChangedDocuments>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<DocumentId> GetChangedDocuments(Solution newSolution, Solution oldSolution);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TextDocument GetTextDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Solution solution, SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static Project GetRequiredProject(Solution solution, ProjectId projectId);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Solution solution, DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetRequiredDocumentAsync>d__9")]
[ExtensionAttribute]
public static Task`1<Document> GetRequiredDocumentAsync(Solution solution, DocumentId documentId, bool includeSourceGenerated, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ISolutionExtensions/<GetRequiredTextDocumentAsync>d__10")]
[ExtensionAttribute]
public static Task`1<TextDocument> GetRequiredTextDocumentAsync(Solution solution, DocumentId documentId, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TextDocument GetRequiredAdditionalDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredAnalyzerConfigDocument(Solution solution, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredTextDocument(Solution solution, DocumentId documentId);
    private static Exception CreateDocumentNotFoundException();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ISymbolExtensions : object {
    private static int TypeLibTypeFlagsFHidden;
    private static int TypeLibFuncFlagsFHidden;
    private static int TypeLibVarFlagsFHidden;
    [ExtensionAttribute]
public static DeclarationModifiers GetSymbolModifiers(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsEditorBrowsable(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, EditorBrowsableInfo editorBrowsableInfo);
    [ExtensionAttribute]
public static ValueTuple`2<bool, bool> IsEditorBrowsableWithState(ISymbol symbol, bool hideAdvancedMembers, Compilation compilation, EditorBrowsableInfo editorBrowsableInfo);
    [NullableContextAttribute("0")]
private static ValueTuple`2<bool, bool> IsBrowsingProhibited(ISymbol symbol, bool hideAdvancedMembers, EditorBrowsableInfo editorBrowsableInfo);
    private static bool IsBrowsingProhibitedByHideModuleNameAttribute(ISymbol symbol, INamedTypeSymbol hideModuleNameAttribute, ImmutableArray`1<AttributeData> attributes);
    [NullableContextAttribute("0")]
private static ValueTuple`2<bool, bool> IsBrowsingProhibitedByEditorBrowsableAttribute(ImmutableArray`1<AttributeData> attributes, bool hideAdvancedMembers, IMethodSymbol constructor);
    private static bool IsBrowsingProhibitedByTypeLibTypeAttribute(ImmutableArray`1<AttributeData> attributes, ImmutableArray`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibFuncAttribute(ImmutableArray`1<AttributeData> attributes, ImmutableArray`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibVarAttribute(ImmutableArray`1<AttributeData> attributes, ImmutableArray`1<IMethodSymbol> constructors);
    private static bool IsBrowsingProhibitedByTypeLibAttributeWorker(ImmutableArray`1<AttributeData> attributes, ImmutableArray`1<IMethodSymbol> attributeConstructors, int hiddenFlag);
    [ExtensionAttribute]
public static DocumentationComment GetDocumentationComment(ISymbol symbol, Compilation compilation, CultureInfo preferredCulture, bool expandIncludes, bool expandInheritdoc, CancellationToken cancellationToken);
    private static DocumentationComment GetDocumentationComment(ISymbol symbol, HashSet`1<ISymbol> visitedSymbols, Compilation compilation, CultureInfo preferredCulture, bool expandIncludes, bool expandInheritdoc, CancellationToken cancellationToken);
    private static XNode[] RewriteInheritdocElements(ISymbol symbol, HashSet`1<ISymbol> visitedSymbols, Compilation compilation, XNode node, CancellationToken cancellationToken);
    private static XNode[] RewriteMany(ISymbol symbol, HashSet`1<ISymbol> visitedSymbols, Compilation compilation, XNode[] nodes, CancellationToken cancellationToken);
    private static XNode[] RewriteInheritdocElement(ISymbol memberSymbol, HashSet`1<ISymbol> visitedSymbols, Compilation compilation, XElement element, CancellationToken cancellationToken);
    private static TNode Copy(TNode node, bool copyAttributeAnnotations);
    private static void CopyAnnotations(XObject source, XObject target);
    private static XNode[] TrySelectNodes(XNode node, string xpath);
    private static bool ElementNameIs(XElement element, string name);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
private static ImmutableArray`1<T> RemoveOverriddenSymbolsWithinSet(ImmutableArray`1<T> symbols);
    [ExtensionAttribute]
public static ImmutableArray`1<T> FilterToVisibleAndBrowsableSymbolsAndNotUnsafeSymbols(ImmutableArray`1<T> symbols, bool hideAdvancedMembers, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsImplicitValueParameter(ISymbol symbol);
    [ExtensionAttribute]
public static string ToNameDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static string ToSignatureDisplayString(ISymbol symbol);
    [ExtensionAttribute]
public static bool HasPublicResultantVisibility(ISymbol symbol);
    [ExtensionAttribute]
public static SymbolVisibility GetResultantVisibility(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetOverriddenMember(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ExplicitOrImplicitInterfaceImplementations(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> ImplicitInterfaceImplementations(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOverridable(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsImplementableMember(ISymbol symbol);
    [ExtensionAttribute]
public static INamedTypeSymbol GetContainingTypeOrThis(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsErrorType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsModuleType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInterfaceType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsArrayType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTupleType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind kind1, SymbolKind kind2, SymbolKind kind3);
    [ExtensionAttribute]
public static bool MatchesKind(ISymbol symbol, SymbolKind[] kinds);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsReducedExtension(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEnumMember(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsExtensionMethod(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousOrLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsModuleMember(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStaticConstructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDestructor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsUserDefinedOperator(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsConversion(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOrdinaryMethod(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsOrdinaryMethodOrLocalFunction(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNormalAnonymousType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousDelegateType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousTypeProperty(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsTupleField(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIndexer(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsWriteableFieldOrProperty(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsRequired(ISymbol symbol);
    [ExtensionAttribute]
public static ITypeSymbol GetMemberType(ISymbol symbol);
    [ExtensionAttribute]
public static int GetArity(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetOriginalUnreducedDefinition(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsFunctionValue(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsThisParameter(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol ConvertThisParameterToType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsParams(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<IParameterSymbol> GetParameters(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetTypeParameters(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeParameterSymbol> GetAllTypeParameters(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetTypeArguments(ISymbol symbol);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> GetAllTypeArguments(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAttribute(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool RequiresUnsafeModifier(ISymbol member);
    [ExtensionAttribute]
public static ITypeSymbol ConvertToType(ISymbol symbol, Compilation compilation, bool extensionUsedAsInstance);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStaticType(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNamespace(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsOrContainsAccessibleAttribute(ISymbol symbol, ISymbol withinType, IAssemblySymbol withinAssembly, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<IPropertySymbol> GetValidAnonymousTypeProperties(ISymbol symbol);
    [ExtensionAttribute]
public static Accessibility ComputeResultantAccessibility(ISymbol symbol, ITypeSymbol finalDestination);
    [ExtensionAttribute]
public static bool IsInaccessibleLocal(ISymbol symbol, int position);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAccessor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsPropertyAccessor(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEventAccessor(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsFromSource(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsNonImplicitAndFromSource(ISymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol GetSymbolType(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAwaitableNonDynamic(ISymbol symbol, SemanticModel semanticModel, int position);
    [ExtensionAttribute]
public static bool IsValidGetAwaiter(IMethodSymbol symbol);
    private static bool VerifyGetAwaiter(IMethodSymbol getAwaiter);
    [ExtensionAttribute]
public static bool IsValidGetEnumerator(IMethodSymbol symbol);
    private static bool VerifyGetEnumerator(IMethodSymbol getEnumerator);
    [ExtensionAttribute]
public static bool IsValidGetAsyncEnumerator(IMethodSymbol symbol);
    private static bool VerifyGetAsyncEnumerator(IMethodSymbol getAsyncEnumerator);
    [ExtensionAttribute]
public static bool IsKind(ISymbol symbol, SymbolKind kind, TSymbol& result);
    [ExtensionAttribute]
public static bool IsSymbolWithSpecialDiscardName(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsObsolete(ISymbol symbol);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, ISymbol within, ITypeSymbol throughType);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, IAssemblySymbol within, ITypeSymbol throughType);
    [ExtensionAttribute]
public static bool IsAccessibleWithin(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughType);
    private static bool IsSymbolAccessible(ISymbol symbol, INamedTypeSymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    private static bool IsSymbolAccessibleCore(ISymbol symbol, ISymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    private static bool IsNamedTypeAccessible(INamedTypeSymbol type, ISymbol within);
    private static bool IsNonNestedTypeAccessible(IAssemblySymbol assembly, Accessibility declaredAccessibility, ISymbol within);
    private static bool IsMemberAccessible(INamedTypeSymbol containingType, Accessibility declaredAccessibility, ISymbol within, ITypeSymbol throughType, Boolean& failedThroughTypeCheck);
    private static bool IsProtectedSymbolAccessible(INamedTypeSymbol withinType, IAssemblySymbol withinAssembly, ITypeSymbol throughType, INamedTypeSymbol originalContainingType, Boolean& failedThroughTypeCheck);
    private static bool IsPrivateSymbolAccessible(ISymbol within, INamedTypeSymbol originalContainingType);
    private static bool IsNestedWithinOriginalContainingType(INamedTypeSymbol withinType, INamedTypeSymbol originalContainingType);
    [CompilerGeneratedAttribute]
internal static bool <GetDocumentationComment>g__IsEligibleForAutomaticInheritdoc|14_0(ISymbol symbol);
    [CompilerGeneratedAttribute]
internal static ISymbol <RewriteInheritdocElement>g__GetCandidateSymbol|17_0(ISymbol memberSymbol);
    [CompilerGeneratedAttribute]
internal static bool <RewriteInheritdocElement>g__IsSameSignature|17_1(IMethodSymbol left, IMethodSymbol right);
    [CompilerGeneratedAttribute]
internal static string <RewriteInheritdocElement>g__BuildXPathForElement|17_2(XElement element);
    [CompilerGeneratedAttribute]
internal static bool <FilterToVisibleAndBrowsableSymbols>g__isSymbolDefinedInSource|22_0(Location l);
    [CompilerGeneratedAttribute]
internal static string <ConvertToType>g__WithArity|84_1(string typeName, int arity);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Extensions.ITypeGenerator {
    public abstract virtual ITypeSymbol CreateArrayTypeSymbol(ITypeSymbol elementType, int rank);
    public abstract virtual ITypeSymbol CreatePointerTypeSymbol(ITypeSymbol pointedAtType);
    public abstract virtual ITypeSymbol Construct(INamedTypeSymbol namedType, ITypeSymbol[] typeArguments);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeInferenceServiceExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<ITypeSymbol> InferTypes(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ImmutableArray`1<TypeInferenceInfo> GetTypeInferenceInfo(ITypeInferenceService service, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol InferDelegateType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    private static INamedTypeSymbol GetFirstDelegateType(SemanticModel semanticModel, ImmutableArray`1<ITypeSymbol> types);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, SyntaxNode expression, bool objectAsDefault, string name, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol InferType(ITypeInferenceService typeInferenceService, SemanticModel semanticModel, int position, bool objectAsDefault, string name, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeParameterSymbolExtensions : object {
    [ExtensionAttribute]
public static INamedTypeSymbol GetNamedTypeSymbolConstraint(ITypeParameterSymbol typeParameter);
    private static INamedTypeSymbol GetNamedTypeSymbol(ITypeSymbol type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions : object {
    public static string DefaultParameterName;
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<FindImplementationsForInterfaceMemberAsync>d__3")]
[ExtensionAttribute]
public static Task`1<ImmutableArray`1<ISymbol>> FindImplementationsForInterfaceMemberAsync(ITypeSymbol typeSymbol, ISymbol interfaceMember, Solution solution, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol FindImplementations(ITypeSymbol typeSymbol, ISymbol constructedInterfaceMember, SolutionServices services);
    [ExtensionAttribute]
private static ISymbol FindImplementations(ITypeSymbol typeSymbol, TSymbol constructedInterfaceMember, SolutionServices services);
    [ExtensionAttribute]
public static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, IEnumerable`1<ITypeParameterSymbol> availableTypeParameters);
    [ExtensionAttribute]
private static ITypeSymbol RemoveUnavailableTypeParameters(ITypeSymbol type, Compilation compilation, ISet`1<string> availableTypeParameterNames);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol RemoveAnonymousTypes(ITypeSymbol type, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol RemoveUnnamedErrorTypes(ITypeSymbol type, Compilation compilation);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedMethodTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static IList`1<ITypeParameterSymbol> GetReferencedTypeParameters(ITypeSymbol type, IList`1<ITypeParameterSymbol> result);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, Compilation compilation);
    [ExtensionAttribute]
public static ITypeSymbol SubstituteTypes(ITypeSymbol type, IDictionary`2<TType1, TType2> mapping, ITypeGenerator typeGenerator);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsIntegralType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSignedIntegralType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool CanAddNullCheck(ITypeSymbol type);
    [ExtensionAttribute]
public static IList`1<INamedTypeSymbol> GetAllInterfacesIncludingThis(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAbstractClass(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSystemVoid(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNonNullableValueType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNullable(ITypeSymbol symbol, ITypeSymbol& underlyingType);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsModuleType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsInterfaceType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDelegateType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsFunctionPointerType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsStructType(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsAnonymousType(INamedTypeSymbol symbol);
    [ExtensionAttribute]
private static HashSet`1<INamedTypeSymbol> GetOriginalInterfacesAndTheirBaseInterfaces(ITypeSymbol type, HashSet`1<INamedTypeSymbol> symbols);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypesAndThis>d__34")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetBaseTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetBaseTypes>d__35")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetBaseTypes(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypesAndThis>d__36")]
[ExtensionAttribute]
public static IEnumerable`1<ITypeSymbol> GetContainingTypesAndThis(ITypeSymbol type);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ITypeSymbolExtensions/<GetContainingTypes>d__37")]
[ExtensionAttribute]
public static IEnumerable`1<INamedTypeSymbol> GetContainingTypes(ITypeSymbol type);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType, bool includeInterfaces);
    [ExtensionAttribute]
public static bool InheritsFromOrEquals(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromOrImplementsOrEqualsIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool InheritsFromIgnoringConstruction(ITypeSymbol type, ITypeSymbol baseType);
    [ExtensionAttribute]
public static bool ImplementsIgnoringConstruction(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool Implements(ITypeSymbol type, ITypeSymbol interfaceType);
    [ExtensionAttribute]
public static bool IsAttribute(ITypeSymbol symbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsFormattableStringOrIFormattable(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool IsUnexpressibleTypeParameterConstraint(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsNumericType(ITypeSymbol type);
    [ExtensionAttribute]
public static Accessibility DetermineMinimalAccessibility(ITypeSymbol typeSymbol);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool ContainsAnonymousType(ITypeSymbol symbol);
    private static bool ContainsAnonymousType(INamedTypeSymbol type);
    [ExtensionAttribute]
public static string CreateParameterName(ITypeSymbol type, bool capitalize);
    private static string GetParameterName(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsSpecialType(ITypeSymbol symbol);
    [ExtensionAttribute]
public static bool CanSupportCollectionInitializer(ITypeSymbol typeSymbol, ISymbol within);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static INamedTypeSymbol GetDelegateType(ITypeSymbol typeSymbol, Compilation compilation);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAccessibleMembersInBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static ImmutableArray`1<T> GetAccessibleMembersInThisAndBaseTypes(ITypeSymbol containingType, ISymbol within);
    [ExtensionAttribute]
public static Nullable`1<bool> AreMoreSpecificThan(IList`1<ITypeSymbol> t1, IList`1<ITypeSymbol> t2);
    [ExtensionAttribute]
public static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, ISymbol within);
    [ExtensionAttribute]
private static IEnumerable`1<T> SelectAccessibleMembers(IEnumerable`1<ITypeSymbol> types, string memberName, ISymbol within);
    [ExtensionAttribute]
private static Nullable`1<bool> IsMoreSpecificThan(ITypeSymbol t1, ITypeSymbol t2);
    [ExtensionAttribute]
public static bool IsOrDerivesFromExceptionType(ITypeSymbol type, Compilation compilation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsEnumType(ITypeSymbol type, INamedTypeSymbol& enumType);
    [ExtensionAttribute]
public static Nullable`1<bool> IsMutableValueType(ITypeSymbol type);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool IsDisposable(ITypeSymbol type, ITypeSymbol iDisposableType);
    [ExtensionAttribute]
public static ITypeSymbol WithNullableAnnotationFrom(ITypeSymbol type, ITypeSymbol symbolForNullableAnnotation);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ITypeSymbol RemoveNullableIfPresent(ITypeSymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LinePositionSpanExtensions : object {
    [ExtensionAttribute]
public static TextSpan GetClampedTextSpan(LinePositionSpan span, SourceText text);
    [ExtensionAttribute]
public static LinePositionSpan GetClampedSpan(LinePositionSpan span, SourceText text);
}
internal class Microsoft.CodeAnalysis.Shared.Extensions.LineSpan : ValueType {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    public int Start { get; private set; }
    public int End { get; private set; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
private void set_Start(int value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
private void set_End(int value);
    public static LineSpan FromBounds(int start, int end);
    public sealed virtual bool Equals(LineSpan other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LinkedListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void AddRangeAtHead(LinkedList`1<T> list, IEnumerable`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ListExtensions : object {
    [ExtensionAttribute]
public static void RemoveOrTransformAll(List`1<T> list, Func`3<T, TArg, T> transform, TArg arg);
    [ExtensionAttribute]
public static bool TryRemoveFirst(IList`1<T> list, Func`3<T, TArg, bool> selector, TArg arg, T& removedItem);
    [ExtensionAttribute]
public static int IndexOf(IList`1<T> list, Func`2<T, bool> predicate);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.LocationExtensions : object {
    [ExtensionAttribute]
public static SyntaxTree GetSourceTreeOrThrow(Location location);
    [ExtensionAttribute]
public static SyntaxToken FindToken(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode FindNode(Location location, bool findInsideTrivia, bool getInnermostNodeForTie, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsVisibleSourceLocation(Location loc);
    [ExtensionAttribute]
public static bool IntersectsWith(Location loc1, Location loc2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.MethodKindExtensions : object {
    [ExtensionAttribute]
public static bool IsPropertyAccessor(MethodKind kind);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectExtensions : object {
    [ExtensionAttribute]
public static string GetTypeDisplayName(object obj);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TBaseType, TResult> defaultFunc);
    [ExtensionAttribute]
public static TResult TypeSwitch(TBaseType obj, Func`2<TDerivedType1, TResult> matchFunc1, Func`2<TDerivedType2, TResult> matchFunc2, Func`2<TDerivedType3, TResult> matchFunc3, Func`2<TDerivedType4, TResult> matchFunc4, Func`2<TDerivedType5, TResult> matchFunc5, Func`2<TDerivedType6, TResult> matchFunc6, Func`2<TDerivedType7, TResult> matchFunc7, Func`2<TDerivedType8, TResult> matchFunc8, Func`2<TDerivedType9, TResult> matchFunc9, Func`2<TDerivedType10, TResult> matchFunc10, Func`2<TDerivedType11, TResult> matchFunc11, Func`2<TDerivedType12, TResult> matchFunc12, Func`2<TDerivedType13, TResult> matchFunc13, Func`2<TDerivedType14, TResult> matchFunc14, Func`2<TDerivedType15, TResult> matchFunc15, Func`2<TDerivedType16, TResult> matchFunc16, Func`2<TDerivedType17, TResult> matchFunc17, Func`2<TDerivedType18, TResult> matchFunc18, Func`2<TDerivedType19, TResult> matchFunc19, Func`2<TDerivedType20, TResult> matchFunc20, Func`2<TDerivedType21, TResult> matchFunc21, Func`2<TDerivedType22, TResult> matchFunc22, Func`2<TDerivedType23, TResult> matchFunc23, Func`2<TDerivedType24, TResult> matchFunc24, Func`2<TDerivedType25, TResult> matchFunc25, Func`2<TDerivedType26, TResult> matchFunc26, Func`2<TDerivedType27, TResult> matchFunc27, Func`2<TDerivedType28, TResult> matchFunc28, Func`2<TDerivedType29, TResult> matchFunc29, Func`2<TDerivedType30, TResult> matchFunc30, Func`2<TDerivedType31, TResult> matchFunc31, Func`2<TDerivedType32, TResult> matchFunc32, Func`2<TDerivedType33, TResult> matchFunc33, Func`2<TDerivedType34, TResult> matchFunc34, Func`2<TDerivedType35, TResult> matchFunc35, Func`2<TDerivedType36, TResult> matchFunc36, Func`2<TDerivedType37, TResult> matchFunc37, Func`2<TDerivedType38, TResult> matchFunc38, Func`2<TDerivedType39, TResult> matchFunc39, Func`2<TDerivedType40, TResult> matchFunc40, Func`2<TBaseType, TResult> defaultFunc);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectReaderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ReadArray(ObjectReader reader, Func`2<ObjectReader, T> read);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ObjectWriterExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void WriteArray(ObjectWriter writer, ImmutableArray`1<T> values, Action`2<ObjectWriter, T> write);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.PredefinedTypeExtensions : object {
    [ExtensionAttribute]
public static SpecialType ToSpecialType(PredefinedType predefinedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions : object {
    [ExtensionAttribute]
internal static Project WithSolutionOptions(Project project, OptionSet options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TextDocument GetTextDocument(Project project, DocumentId documentId);
    [ExtensionAttribute]
internal static DocumentId GetDocumentForExternalLocation(Project project, Location location);
    [ExtensionAttribute]
internal static DocumentId GetDocumentForFile(Project project, AdditionalText additionalText);
    [ExtensionAttribute]
private static DocumentId GetDocumentIdWithFilePath(Project project, string filePath);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Project project, DocumentId documentId);
    [ExtensionAttribute]
public static Document GetRequiredDocument(Project project, SyntaxTree tree);
    [ExtensionAttribute]
public static TextDocument GetRequiredAdditionalDocument(Project project, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredAnalyzerConfigDocument(Project project, DocumentId documentId);
    [ExtensionAttribute]
public static TextDocument GetRequiredTextDocument(Project project, DocumentId documentId);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<GetRequiredSourceGeneratedDocumentAsync>d__10")]
[ExtensionAttribute]
public static ValueTask`1<Document> GetRequiredSourceGeneratedDocumentAsync(Project project, DocumentId documentId, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TLanguageService GetLanguageService(Project project);
    [ExtensionAttribute]
public static TLanguageService GetRequiredLanguageService(Project project);
    [ExtensionAttribute]
public static HostLanguageServices GetExtendedLanguageServices(Project project);
    [ExtensionAttribute]
public static string TryGetAnalyzerConfigPathForProjectConfiguration(Project project);
    [ExtensionAttribute]
public static string TryGetAnalyzerConfigPathForDiagnosticConfiguration(Project project, Diagnostic diagnostic);
    [NullableContextAttribute("2")]
private static string TryGetAnalyzerConfigPathForProjectOrDiagnosticConfiguration(Project project, Diagnostic diagnostic);
    [ExtensionAttribute]
public static AnalyzerConfigDocument TryGetExistingAnalyzerConfigDocumentAtPath(Project project, string analyzerConfigPath);
    [ExtensionAttribute]
public static AnalyzerConfigDocument GetOrCreateAnalyzerConfigDocument(Project project, string analyzerConfigPath);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.ProjectExtensions/<GetRequiredCompilationAsync>d__19")]
[ExtensionAttribute]
public static Task`1<Compilation> GetRequiredCompilationAsync(Project project, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SafeHandleLease Lease(SafeHandle handle);
}
[IsReadOnlyAttribute]
[NonCopyableAttribute]
internal class Microsoft.CodeAnalysis.Shared.Extensions.SafeHandleLease : ValueType {
    [NullableAttribute("2")]
private SafeHandle _handle;
    [NullableContextAttribute("1")]
internal SafeHandleLease(SafeHandle handle);
    public sealed virtual void Dispose();
}
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticEquivalence : object {
    public static bool AreEquivalent(SemanticModel semanticModel, SyntaxNode node1, SyntaxNode node2);
    public static bool AreEquivalent(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool AreSemanticallyEquivalentWorker(SemanticModel semanticModel1, SemanticModel semanticModel2, SyntaxNode node1, SyntaxNode node2, Func`2<SyntaxNode, bool> predicate);
    private static bool IsInstanceMemberReference(IOperation operation);
    private static bool AreEquals(SemanticModel semanticModel1, SemanticModel semanticModel2, SymbolInfo info1, SymbolInfo info2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SemanticModelExtensions : object {
    private static string DefaultBuildInParameterName;
    [ExtensionAttribute]
public static SemanticMap GetSemanticMap(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ITypeSymbol GetType(SemanticModel semanticModel, SyntaxNode expression, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
private static ISymbol MapSymbol(ISymbol symbol, ITypeSymbol type);
    [ExtensionAttribute]
public static TokenSemanticInfo GetSemanticInfo(SemanticModel semanticModel, SyntaxToken token, SolutionServices services, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GenerateNameFromType(SemanticModel semanticModel, ITypeSymbol type, ISyntaxFacts syntaxFacts, bool capitalize);
    [ExtensionAttribute]
private static bool ShouldPluralize(SemanticModel semanticModel, ITypeSymbol type);
    private static bool TryGeneratePluralizedNameFromTypeArgument(ISyntaxFacts syntaxFacts, ImmutableArray`1<ITypeSymbol> typeArguments, bool capitalize, String& parameterName);
    [ExtensionAttribute]
public static SymbolInfo GetSymbolInfo(SemanticModel semanticModel, SyntaxToken token, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeRequiredDataFlow(SemanticModel semanticModel, SyntaxNode statementOrExpression);
    [ExtensionAttribute]
public static DataFlowAnalysis AnalyzeRequiredDataFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeRequiredControlFlow(SemanticModel semanticModel, SyntaxNode statement);
    [ExtensionAttribute]
public static ControlFlowAnalysis AnalyzeRequiredControlFlow(SemanticModel semanticModel, SyntaxNode firstStatement, SyntaxNode lastStatement);
    [ExtensionAttribute]
public static ISymbol GetRequiredDeclaredSymbol(SemanticModel semanticModel, SyntaxNode declaration, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IOperation GetRequiredOperation(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetRequiredEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static TSymbol GetEnclosingSymbol(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ISymbol GetEnclosingNamedTypeOrAssembly(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamedTypeSymbol GetEnclosingNamedType(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static INamespaceSymbol GetEnclosingNamespace(SemanticModel semanticModel, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<ISymbol> GetExistingSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> descendInto);
    [ExtensionAttribute]
public static SemanticModel GetOriginalSemanticModel(SemanticModel semanticModel);
    [ExtensionAttribute]
public static HashSet`1<ISymbol> GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode container, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> filter);
    private static void GetAllDeclaredSymbols(SemanticModel semanticModel, SyntaxNode node, HashSet`1<ISymbol> symbols, CancellationToken cancellationToken, Func`2<SyntaxNode, bool> descendInto);
    [CompilerGeneratedAttribute]
internal static bool <GetAllDeclaredSymbols>g__ShouldDescendInto|23_0(SyntaxNode node, Func`2<SyntaxNode, bool> filter);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SimpleIntervalTreeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool HasIntervalThatIntersectsWith(SimpleIntervalTree`2<TextSpan, TextSpanIntervalIntrospector> tree, TextSpan span);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SourceTextExtensions : object {
    internal static int SourceTextLengthThreshold;
    [ExtensionAttribute]
public static void GetLineAndOffset(SourceText text, int position, Int32& lineNumber, Int32& offset);
    [ExtensionAttribute]
public static int GetOffset(SourceText text, int position);
    [ExtensionAttribute]
public static void GetLinesAndOffsets(SourceText text, TextSpan textSpan, Int32& startLineNumber, Int32& startOffset, Int32& endLineNumber, Int32& endOffset);
    [ExtensionAttribute]
public static TextChangeRange GetEncompassingTextChangeRange(SourceText newText, SourceText oldText);
    [ExtensionAttribute]
public static int IndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    [ExtensionAttribute]
public static int LastIndexOf(SourceText text, string value, int startIndex, bool caseSensitive);
    private static bool Match(char normalizedLeft, char right, bool caseSensitive);
    [ExtensionAttribute]
public static bool ContentEquals(SourceText text, int position, string value);
    [ExtensionAttribute]
public static int IndexOfNonWhiteSpace(SourceText text, int start, int length);
    [ExtensionAttribute]
public static void WriteTo(SourceText sourceText, ObjectWriter writer, CancellationToken cancellationToken);
    private static void WriteChunksTo(SourceText sourceText, ObjectWriter writer, int length, CancellationToken cancellationToken);
    public static SourceText ReadFrom(ITextFactoryService textService, ObjectReader reader, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string GetLeadingWhitespaceOfLineAtPosition(SourceText text, int position);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryOverlapsHiddenPosition(SourceText text, TextSpan span, Func`3<int, CancellationToken, bool> isPositionHidden, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool AreOnSameLine(SourceText text, SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool AreOnSameLine(SourceText text, int pos1, int pos2);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static PredefinedType ToPredefinedType(SpecialType specialType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StackExtensions : object {
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, HashSet`1<T> values);
    [ExtensionAttribute]
public static void Push(Stack`1<T> stack, ImmutableArray`1<T> values);
    [ExtensionAttribute]
internal static void PushReverse(Stack`1<T> stack, IList`1<U> range);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringBuilderExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringBuilder AppendJoinedValues(StringBuilder builder, string separator, ImmutableArray`1<T> values, Action`2<T, StringBuilder> append);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.StringExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static Nullable`1<int> GetLastNonWhitespaceOffset(string line);
    [ExtensionAttribute]
public static string GetLeadingWhitespace(string lineText);
    [ExtensionAttribute]
public static string GetTrailingWhitespace(string lineText);
    [ExtensionAttribute]
public static int GetTextColumn(string text, int tabSize, int initialColumn);
    [ExtensionAttribute]
public static int ConvertTabToSpace(string textSnippet, int tabSize, int initialColumn, int endPosition);
    [ExtensionAttribute]
public static int IndexOf(string text, Func`2<char, bool> predicate);
    [ExtensionAttribute]
public static string GetFirstLineText(string text);
    [ExtensionAttribute]
public static string GetLastLineText(string text);
    [ExtensionAttribute]
public static bool ContainsLineBreak(string text);
    [ExtensionAttribute]
public static int GetNumberOfLineBreaks(string text);
    [ExtensionAttribute]
public static bool ContainsTab(string text);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SymbolDisplayPart> ToSymbolDisplayParts(string text);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(string line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(string line, int endPosition, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(string line, int column, int tabSize);
    [ExtensionAttribute]
public static void AppendToAliasNameSet(string alias, Builder<string> builder);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayFormats : object {
    public static SymbolDisplayFormat NameFormat;
    public static SymbolDisplayFormat SignatureFormat;
    private static SymbolDisplayFormats();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolDisplayPartExtensions : object {
    [ExtensionAttribute]
public static string GetFullText(IEnumerable`1<SymbolDisplayPart> parts);
    [ExtensionAttribute]
public static void AddLineBreak(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddMethodName(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddPunctuation(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddSpace(IList`1<SymbolDisplayPart> parts, string text);
    [ExtensionAttribute]
public static void AddText(IList`1<SymbolDisplayPart> parts, string text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SymbolInfoExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetAllSymbols(SymbolInfo info);
    [ExtensionAttribute]
private static ImmutableArray`1<ISymbol> GetAllSymbolsWorker(SymbolInfo info);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ISymbol GetAnySymbol(SymbolInfo info);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> GetBestOrAllSymbols(SymbolInfo info);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions : object {
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, TNode> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyExpressionLevelSemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyMethodBodySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task ApplyMethodBodySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TNode> originalNodes, Func`3<SemanticModel, TNode, bool> canReplace, Func`4<SemanticModel, SyntaxNode, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxEditorExtensions/<ApplySemanticEditsAsync>d__5`2")]
[ExtensionAttribute]
private static Task ApplySemanticEditsAsync(SyntaxEditor editor, Document document, ImmutableArray`1<TType> originalNodes, Func`2<TType, ValueTuple`2<TNode, IEnumerable`1<TNode>>> selector, Func`3<ISyntaxFactsService, SyntaxNode, SyntaxNode> getSemanticBoundary, Func`4<SemanticModel, TType, TNode, bool> canReplace, Func`5<SemanticModel, SyntaxNode, TType, TNode, SyntaxNode> updateRoot, CancellationToken cancellationToken);
    private static SyntaxNode GetExpressionSemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
    private static SyntaxNode GetMethodBodySemanticBoundary(ISyntaxFactsService syntaxFacts, SyntaxNode node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions : object {
    [NullableAttribute("0")]
private static string EqualsName;
    [NullableAttribute("0")]
private static string DefaultName;
    [NullableAttribute("0")]
private static string ObjName;
    [NullableAttribute("0")]
public static string OtherName;
    private static string GetHashCodeName;
    private static ImmutableDictionary`2<BinaryOperatorKind, BinaryOperatorKind> s_negatedBinaryMap;
    private static SyntaxGeneratorExtensions();
    [ExtensionAttribute]
public static IMethodSymbol CreateBaseDelegatingConstructor(SyntaxGenerator factory, IMethodSymbol constructor, string typeName);
    [ExtensionAttribute]
public static ImmutableArray`1<ISymbol> CreateMemberDelegatingConstructor(SyntaxGenerator factory, SemanticModel semanticModel, string typeName, INamedTypeSymbol containingType, ImmutableArray`1<IParameterSymbol> parameters, Accessibility accessibility, ImmutableDictionary`2<string, ISymbol> parameterToExistingMemberMap, ImmutableDictionary`2<string, string> parameterToNewMemberMap, bool addNullChecks, bool preferThrowExpression, bool generateProperties, bool isContainedInUnsafeType);
    [NullableContextAttribute("2")]
private static bool ShouldGenerateThisConstructorCall(INamedTypeSymbol containingType, IDictionary`2<string, ISymbol> parameterToExistingFieldMap);
    public static ImmutableArray`1<ISymbol> CreateFieldsForParameters(ImmutableArray`1<IParameterSymbol> parameters, ImmutableDictionary`2<string, string> parameterToNewFieldMap, bool isContainedInUnsafeType);
    public static ImmutableArray`1<ISymbol> CreatePropertiesForParameters(ImmutableArray`1<IParameterSymbol> parameters, ImmutableDictionary`2<string, string> parameterToNewPropertyMap, bool isContainedInUnsafeType);
    private static bool TryGetValue(IDictionary`2<string, string> dictionary, string key, String& value);
    private static bool TryGetValue(IDictionary`2<string, ISymbol> dictionary, string key, String& value);
    [ExtensionAttribute]
public static SyntaxNode CreateThrowArgumentNullExpression(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter);
    private static SyntaxNode CreateNewArgumentNullException(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter);
    [ExtensionAttribute]
public static SyntaxNode CreateNullCheckAndThrowStatement(SyntaxGenerator factory, SemanticModel semanticModel, IParameterSymbol parameter);
    [ExtensionAttribute]
public static SyntaxNode CreateThrowArgumentNullExceptionStatement(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter);
    [ExtensionAttribute]
public static SyntaxNode CreateNullCheckExpression(SyntaxGenerator factory, SemanticModel semanticModel, string identifierName);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateAssignmentStatements(SyntaxGenerator factory, SemanticModel semanticModel, ImmutableArray`1<IParameterSymbol> parameters, IDictionary`2<string, ISymbol> parameterToExistingFieldMap, IDictionary`2<string, string> parameterToNewFieldMap, bool addNullChecks, bool preferThrowExpression);
    [ExtensionAttribute]
public static void AddAssignmentStatements(SyntaxGenerator factory, SemanticModel semanticModel, IParameterSymbol parameter, SyntaxNode fieldAccess, bool addNullChecks, bool preferThrowExpression, ArrayBuilder`1<SyntaxNode> nullCheckStatements, ArrayBuilder`1<SyntaxNode> assignStatements);
    [ExtensionAttribute]
public static SyntaxNode CreateAssignWithNullCheckStatement(SyntaxGenerator factory, Compilation compilation, IParameterSymbol parameter, SyntaxNode fieldAccess);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions/<OverridePropertyAsync>d__15")]
[ExtensionAttribute]
public static Task`1<IPropertySymbol> OverridePropertyAsync(SyntaxGenerator codeFactory, IPropertySymbol overriddenProperty, DeclarationModifiers modifiers, INamedTypeSymbol containingType, Document document, CancellationToken cancellationToken);
    private static SyntaxNode WrapWithRefIfNecessary(SyntaxGenerator codeFactory, IPropertySymbol overriddenProperty, SyntaxNode body);
    public static IEventSymbol OverrideEvent(IEventSymbol overriddenEvent, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions/<OverrideAsync>d__18")]
[ExtensionAttribute]
public static Task`1<ISymbol> OverrideAsync(SyntaxGenerator generator, ISymbol symbol, INamedTypeSymbol containingType, Document document, DeclarationModifiers extraDeclarationModifiers, CancellationToken cancellationToken);
    private static DeclarationModifiers GetOverrideModifiers(ISymbol symbol);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxGeneratorExtensions/<OverrideMethodAsync>d__20")]
[ExtensionAttribute]
private static Task`1<IMethodSymbol> OverrideMethodAsync(SyntaxGenerator codeFactory, IMethodSymbol overriddenMethod, DeclarationModifiers modifiers, INamedTypeSymbol newContainingType, Document newDocument, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode GenerateDelegateThroughMemberStatement(SyntaxGenerator generator, IMethodSymbol method, ISymbol throughMember);
    [ExtensionAttribute]
public static SyntaxNode CreateDelegateThroughExpression(SyntaxGenerator generator, ISymbol member, ISymbol throughMember);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> GetGetAccessorStatements(SyntaxGenerator generator, Compilation compilation, IPropertySymbol property, ISymbol throughMember, bool preferAutoProperties);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> GetSetAccessorStatements(SyntaxGenerator generator, Compilation compilation, IPropertySymbol property, ISymbol throughMember, bool preferAutoProperties);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IMethodSymbol CreateEqualsMethod(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ParseOptions parseOptions, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> symbols, string localNameOpt, SyntaxAnnotation statementAnnotation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IMethodSymbol CreateEqualsMethod(Compilation compilation, ImmutableArray`1<SyntaxNode> statements);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static IMethodSymbol CreateIEquatableEqualsMethod(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> symbols, INamedTypeSymbol constructedEquatableType, SyntaxAnnotation statementAnnotation);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SyntaxNode> CreateEqualsMethodStatements(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ParseOptions parseOptions, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, string localNameOpt);
    [NullableContextAttribute("0")]
private static void AddMemberChecks(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ImmutableArray`1<ISymbol> members, SyntaxNode localNameExpression, ArrayBuilder`1<SyntaxNode> expressions);
    [NullableContextAttribute("0")]
private static ImmutableArray`1<SyntaxNode> CreateIEquatableEqualsMethodStatements(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ParseOptions parseOptions, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members);
    [NullableContextAttribute("0")]
private static void AddReferenceNotNullCheck(SyntaxGenerator factory, Compilation compilation, ParseOptions parseOptions, SyntaxNode otherNameExpression, ArrayBuilder`1<SyntaxNode> expressions);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static string GetLocalName(ITypeSymbol containingType);
    [NullableContextAttribute("0")]
private static bool ImplementsIEquatable(ITypeSymbol memberType, INamedTypeSymbol iequatableType);
    [NullableContextAttribute("0")]
private static bool ShouldUseEqualityOperator(ITypeSymbol typeSymbol);
    [NullableContextAttribute("0")]
private static bool HasExistingBaseEqualsMethod(INamedTypeSymbol containingType);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementedStatement(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode CreateThrowNotImplementedExpression(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
private static SyntaxNode CreateNotImplementedException(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateThrowNotImplementedStatementBlock(SyntaxGenerator codeDefinitionFactory, Compilation compilation);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateArguments(SyntaxGenerator factory, ImmutableArray`1<IParameterSymbol> parameters);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
private static SyntaxNode CreateArgument(SyntaxGenerator factory, IParameterSymbol parameter);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode GetDefaultEqualityComparer(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ITypeSymbol type);
    [NullableContextAttribute("0")]
private static ITypeSymbol GetType(Compilation compilation, ISymbol symbol);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static SyntaxNode IsPatternExpression(SyntaxGeneratorInternal generator, SyntaxNode expression, SyntaxNode pattern);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> GetGetHashCodeComponents(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool justMemberReference);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateGetHashCodeStatementsUsingSystemHashCode(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, INamedTypeSymbol hashCodeType, ImmutableArray`1<SyntaxNode> memberReferences);
    [ExtensionAttribute]
public static ImmutableArray`1<SyntaxNode> CreateGetHashCodeMethodStatements(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, INamedTypeSymbol containingType, ImmutableArray`1<ISymbol> members, bool useInt64);
    [ExtensionAttribute]
private static SyntaxNode SimpleLocalDeclarationStatement(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, INamedTypeSymbol namedTypeSymbol, string name, SyntaxNode initializer);
    private static SyntaxNode CreateLiteralExpression(SyntaxGenerator factory, int value);
    public static IMethodSymbol GetBaseGetHashCodeMethod(INamedTypeSymbol containingType);
    private static SyntaxNode GetMemberForGetHashCode(SyntaxGenerator factory, SyntaxGeneratorInternal generatorInternal, Compilation compilation, ISymbol member, bool justMemberReference);
    [ExtensionAttribute]
public static SyntaxNode Negate(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SyntaxNode expression, SemanticModel semanticModel, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxNode Negate(SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SyntaxNode expressionOrPattern, SemanticModel semanticModel, bool negateBinary, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfBinaryExpression(SyntaxNode expressionNode, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfBinaryPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static SyntaxNode GetNegationOfIsPatternExpression(SyntaxNode isExpression, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, SemanticModel semanticModel, CancellationToken cancellationToken);
    private static bool IsLegalPattern(ISyntaxFacts syntaxFacts, SyntaxNode pattern, bool designatorsLegal);
    private static SyntaxNode NegateRelational(SyntaxGenerator generator, IBinaryOperation binaryOperation, SyntaxNode leftOperand, BinaryOperatorKind operationKind, SyntaxNode rightOperand);
    public static bool IsSpecialCaseBinaryExpression(IBinaryOperation binaryOperation, BinaryOperatorKind operationKind);
    private static IOperation RemoveImplicitConversion(IOperation operation);
    private static bool CanSimplifyToLengthEqualsZeroExpression(IOperation variableExpression, ILiteralOperation numericLiteralExpression);
    private static SyntaxNode GetNegationOfLiteralExpression(SyntaxNode expression, SyntaxGenerator generator, SemanticModel semanticModel);
    private static SyntaxNode GetNegationOfConstantPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal);
    private static SyntaxNode GetNegationOfLogicalNotExpression(SyntaxNode expression, ISyntaxFacts syntaxFacts);
    private static SyntaxNode GetNegationOfUnaryPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, ISyntaxFacts syntaxFacts);
    private static SyntaxNode GetNegationOfNotPattern(SyntaxNode pattern, SyntaxGenerator generator, SyntaxGeneratorInternal generatorInternal, ISyntaxFacts syntaxFacts);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <CreateDelegateThroughExpression>g__GenerateContainerName|22_0(SyntaxGenerator factory, ISymbol throughMember);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions : object {
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenForward;
    private static Func`3<SyntaxTriviaList, int, SyntaxToken> s_findSkippedTokenBackward;
    private static SyntaxNodeExtensions();
    [ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxNode node);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestors>d__3`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestors(SyntaxNode node);
    [ExtensionAttribute]
public static TNode GetAncestor(SyntaxNode node);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TNode GetAncestorOrThis(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<GetAncestorsOrThis>d__6`1")]
[ExtensionAttribute]
public static IEnumerable`1<TNode> GetAncestorsOrThis(SyntaxNode node);
    [ExtensionAttribute]
public static bool HasAncestor(SyntaxNode node);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<Traverse>d__8`1")]
[ExtensionAttribute]
public static IEnumerable`1<TSyntaxNode> Traverse(SyntaxNode node, TextSpan searchSpan, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxNode node, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static bool IsChildNode(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static bool IsFoundUnder(SyntaxNode node, Func`2<TParent, SyntaxNode> childGetter);
    [ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxNode node1, SyntaxNode node2);
    [ExtensionAttribute]
public static int Width(SyntaxNode node);
    [ExtensionAttribute]
public static int FullWidth(SyntaxNode node);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static SyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static TSyntaxNode FindInnermostCommonNode(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxToken, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static SyntaxNode AddAnnotations(SyntaxNode root, IEnumerable`1<Tuple`2<SyntaxNode, SyntaxAnnotation>> pairs);
    [ExtensionAttribute]
public static TextSpan GetContainedSpan(IEnumerable`1<SyntaxNode> nodes);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode node, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxNode declaration, SyntaxNode startNode, SyntaxNode endNode, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAnnotatedNodes(SyntaxNode node, SyntaxAnnotation syntaxAnnotation);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceNodesAsync(TRootNode root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRootNode> ReplaceTokensAsync(TRootNode root, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementAsync, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<TRoot> ReplaceTriviaAsync(TRoot root, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementAsync, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeExtensions/<ReplaceSyntaxAsync>d__28`1")]
[ExtensionAttribute]
public static Task`1<TRoot> ReplaceSyntaxAsync(TRoot root, IEnumerable`1<SyntaxNode> nodes, Func`4<SyntaxNode, SyntaxNode, CancellationToken, Task`1<SyntaxNode>> computeReplacementNodeAsync, IEnumerable`1<SyntaxToken> tokens, Func`4<SyntaxToken, SyntaxToken, CancellationToken, Task`1<SyntaxToken>> computeReplacementTokenAsync, IEnumerable`1<SyntaxTrivia> trivia, Func`4<SyntaxTrivia, SyntaxTrivia, CancellationToken, Task`1<SyntaxTrivia>> computeReplacementTriviaAsync, CancellationToken cancellationToken);
    private static SyntaxToken FindSkippedTokenForward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken FindSkippedTokenBackward(SyntaxTriviaList triviaList, int position);
    private static SyntaxToken GetInitialToken(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxNode root, int position, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithPrependedLeadingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static T WithAppendedTrailingTrivia(T node, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static T With(T node, IEnumerable`1<SyntaxTrivia> leadingTrivia, IEnumerable`1<SyntaxTrivia> trailingTrivia);
    [ExtensionAttribute]
public static SyntaxToken WithoutLeadingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrailingTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxNode GetParent(SyntaxNode node, bool ascendOutOfTrivia);
    [ExtensionAttribute]
public static TNode FirstAncestorOrSelfUntil(SyntaxNode node, Func`2<SyntaxNode, bool> predicate);
    [ExtensionAttribute]
public static ValueAncestorsAndSelfEnumerable ValueAncestorsAndSelf(SyntaxNode syntaxNode, bool ascendOutOfTrivia);
    [CompilerGeneratedAttribute]
internal static SyntaxNode <FindInnermostCommonNode>g__FindCommonAncestor|16_0(SyntaxNode node, HashSet`1<SyntaxNode> commonAncestorsSet);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxNodeOrTokenExtensions/<DepthFirstTraversal>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<SyntaxNodeOrToken> DepthFirstTraversal(SyntaxNodeOrToken node);
    public static SyntaxTrivia[] GetTrivia(SyntaxNodeOrToken[] nodesOrTokens);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode GetAncestor(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static T GetAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T GetRequiredAncestor(SyntaxToken token, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetAncestors(SyntaxToken token);
    [ExtensionAttribute]
public static IEnumerable`1<SyntaxNode> GetAncestors(SyntaxToken token, Func`2<SyntaxNode, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SyntaxNode GetCommonRoot(SyntaxToken token1, SyntaxToken token2);
    [ExtensionAttribute]
public static bool CheckParent(SyntaxToken token, Func`2<T, bool> valueChecker);
    [ExtensionAttribute]
public static int Width(SyntaxToken token);
    [ExtensionAttribute]
public static int FullWidth(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken FindTokenFromEnd(SyntaxNode root, int position, bool includeZeroWidth, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken GetNextTokenOrEndOfFile(SyntaxToken token, bool includeZeroWidth, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken WithoutTrivia(SyntaxToken token);
    [ExtensionAttribute]
public static SyntaxToken With(SyntaxToken token, SyntaxTriviaList leading, SyntaxTriviaList trailing);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, SyntaxTriviaList trivia);
    [ExtensionAttribute]
public static SyntaxToken WithPrependedLeadingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, SyntaxTrivia[] trivia);
    [ExtensionAttribute]
public static SyntaxToken WithAppendedTrailingTrivia(SyntaxToken token, IEnumerable`1<SyntaxTrivia> trivia);
    [ExtensionAttribute]
public static SyntaxTrivia[] GetTrivia(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static SyntaxNode GetRequiredParent(SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTokenListExtensions : object {
    [ExtensionAttribute]
public static SyntaxTokenList ToSyntaxTokenList(IEnumerable`1<SyntaxToken> tokens);
    [ExtensionAttribute]
public static SyntaxTokenList ToSyntaxTokenListAndFree(ArrayBuilder`1<SyntaxToken> tokens);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool OverlapsHiddenPosition(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsScript(SyntaxTree syntaxTree);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingWordAsync(SyntaxTree syntaxTree, int position, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTreeExtensions/<GetTouchingTokenAsync>d__4")]
[ExtensionAttribute]
public static Task`1<SyntaxToken> GetTouchingTokenAsync(SyntaxTree syntaxTree, int position, Predicate`1<SyntaxToken> predicate, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static bool IsEntirelyHidden(SyntaxTree tree, TextSpan span, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool IsBeforeFirstToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOrEndToken(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static SyntaxTrivia FindTriviaAndAdjustForEndOfFile(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool findInsideTrivia);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnRightOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static SyntaxToken FindTokenOnLeftOfPosition(SyntaxTree syntaxTree, int position, CancellationToken cancellationToken, bool includeSkipped, bool includeDirectives, bool includeDocumentationComments);
    [ExtensionAttribute]
public static bool IsGeneratedCode(SyntaxTree syntaxTree, AnalyzerOptions analyzerOptions, ISyntaxFacts syntaxFacts, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaExtensions : object {
    [ExtensionAttribute]
public static int Width(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static int FullWidth(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static bool IsElastic(SyntaxTrivia trivia);
    [ExtensionAttribute]
public static SyntaxTrivia AsElastic(SyntaxTrivia trivia);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.SyntaxTriviaListExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Nullable`1<SyntaxTrivia> FirstOrNull(SyntaxTriviaList triviaList, Func`2<SyntaxTrivia, bool> predicate);
    [ExtensionAttribute]
public static SyntaxTrivia LastOrDefault(SyntaxTriviaList triviaList);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TelemetryExtensions : object {
    [ExtensionAttribute]
public static Guid GetTelemetryId(Type type, short scope, string additionalSuffixString);
    [ExtensionAttribute]
public static Type GetTypeForTelemetry(Type type);
    [ExtensionAttribute]
public static short GetScopeIdForTelemetry(FixAllScope scope);
    [ExtensionAttribute]
public static string GetTelemetryDiagnosticID(Diagnostic diagnostic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextDocumentExtensions : object {
    [ExtensionAttribute]
public static TextDocument WithText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAdditionalDocumentText(TextDocument textDocument, SourceText text);
    [ExtensionAttribute]
public static TextDocument WithAnalyzerConfigDocumentText(TextDocument textDocument, SourceText text);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextLineExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<int> GetLastNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespacePosition(TextLine line);
    [ExtensionAttribute]
public static Nullable`1<int> GetFirstNonWhitespaceOffset(TextLine line);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetLeadingWhitespace(TextLine line);
    [ExtensionAttribute]
public static bool IsEmptyOrWhitespace(TextLine line);
    [ExtensionAttribute]
public static int GetColumnOfFirstNonWhitespaceCharacterOrEndOfLine(TextLine line, int tabSize);
    [ExtensionAttribute]
public static int GetColumnFromLineOffset(TextLine line, int lineOffset, int tabSize);
    [ExtensionAttribute]
public static int GetLineOffsetFromColumn(TextLine line, int column, int tabSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> ToNormalizedSpans(IEnumerable`1<TextSpan> spans);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ImmutableArray`1<TextSpan> ToNormalizedSpans(ImmutableArray`1<TextSpan> spans);
    [ExtensionAttribute]
public static TextSpan Collapse(IEnumerable`1<TextSpan> spans);
    [ExtensionAttribute]
public static bool IsAround(TextSpan span, SyntaxNodeOrToken node);
    [ExtensionAttribute]
public static bool IsAround(TextSpan span, SyntaxNodeOrToken startNode, SyntaxNodeOrToken endNode);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Extensions.TextSpanExtensions/<Subtract>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<TextSpan> Subtract(TextSpan span, TextSpan except);
    [ExtensionAttribute]
public static IEnumerable`1<TextSpan> Subtract(IEnumerable`1<TextSpan> spans, TextSpan except);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Shared.Extensions.TokenSemanticInfo : ValueType {
    public static TokenSemanticInfo Empty;
    public ISymbol DeclaredSymbol;
    public IAliasSymbol AliasSymbol;
    public ImmutableArray`1<ISymbol> ReferencedSymbols;
    public ITypeSymbol Type;
    public ITypeSymbol ConvertedType;
    public TextSpan Span;
    public TokenSemanticInfo(ISymbol declaredSymbol, IAliasSymbol aliasSymbol, ImmutableArray`1<ISymbol> referencedSymbols, ITypeSymbol type, ITypeSymbol convertedType, TextSpan span);
    private static TokenSemanticInfo();
    public ImmutableArray`1<ISymbol> GetSymbols(bool includeType);
    public ISymbol GetAnySymbol(bool includeType);
}
internal static class Microsoft.CodeAnalysis.Shared.Helpers.RemoveUnnecessaryImports.RemoveUnnecessaryImportsHelpers : object {
    [NullableContextAttribute("1")]
public static SyntaxToken StripNewLines(ISyntaxFacts syntaxFacts, SyntaxToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.NormalizedTextSpanCollection : ReadOnlyCollection`1<TextSpan> {
    public NormalizedTextSpanCollection(TextSpan span);
    public NormalizedTextSpanCollection(IEnumerable`1<TextSpan> spans);
    private NormalizedTextSpanCollection(OrderedSpanList normalizedSpans);
    public static NormalizedTextSpanCollection Union(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Overlap(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Intersection(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public static NormalizedTextSpanCollection Difference(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Equality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NormalizedTextSpanCollection left, NormalizedTextSpanCollection right);
    public bool OverlapsWith(NormalizedTextSpanCollection set);
    public bool OverlapsWith(TextSpan span);
    public bool IntersectsWith(NormalizedTextSpanCollection set);
    public bool IntersectsWith(TextSpan span);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual string ToString();
    private static IList`1<TextSpan> ListFromSpan(TextSpan span);
    private static void UpdateSpanUnion(TextSpan span, IList`1<TextSpan> spans, Int32& start, Int32& end);
    private static IList`1<TextSpan> NormalizeSpans(IEnumerable`1<TextSpan> spans);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener : object {
    private NonReentrantLock _gate;
    private string _featureName;
    private HashSet`1<TaskCompletionSource`1<bool>> _pendingTasks;
    private CancellationTokenSource _expeditedDelayCancellationTokenSource;
    private List`1<DiagnosticAsyncToken> _diagnosticTokenList;
    private int _counter;
    private bool _trackActiveTokens;
    public bool TrackActiveTokens { get; public set; }
    public bool HasPendingWork { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticAsyncToken> ActiveDiagnosticTokens { get; }
    public AsynchronousOperationListener(string featureName, bool enableDiagnosticTokens);
    public sealed virtual Task`1<bool> Delay(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual IAsyncToken BeginAsyncOperation(string name, object tag, string filePath, int lineNumber);
    private void Increment_NoLock();
    private void Decrement_NoLock(AsyncToken token);
    public sealed virtual Task ExpeditedWaitAsync();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListener/<WaitUntilConditionIsMetAsync>d__16")]
public Task WaitUntilConditionIsMetAsync(Func`2<IEnumerable`1<DiagnosticAsyncToken>, bool> condition);
    public sealed virtual bool get_TrackActiveTokens();
    public sealed virtual void set_TrackActiveTokens(bool value);
    public sealed virtual bool get_HasPendingWork();
    public sealed virtual ImmutableArray`1<DiagnosticAsyncToken> get_ActiveDiagnosticTokens();
    [CompilerGeneratedAttribute]
internal static Task`1<bool> <Delay>g__DelaySlow|11_0(Task delayTask, CancellationTokenSource cancellationTokenSourceToDispose, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[SharedAttribute]
[ExportAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider")]
[ExportAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider")]
internal class Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider : object {
    public static IAsynchronousOperationListenerProvider NullProvider;
    public static IAsynchronousOperationListener NullListener;
    public static Nullable`1<bool> s_enabled;
    private ConcurrentDictionary`2<string, AsynchronousOperationListener> _singletonListeners;
    private Func`2<string, AsynchronousOperationListener> _createCallback;
    private Nullable`1<bool> _enableDiagnosticTokens;
    private static Nullable`1<bool> s_enableDiagnosticTokens;
    internal static bool IsEnabled { get; }
    internal bool DiagnosticTokensEnabled { get; }
    private static AsynchronousOperationListenerProvider();
    public static void Enable(bool enable);
    public static void Enable(bool enable, Nullable`1<bool> diagnostics);
    public sealed virtual IAsynchronousOperationListener GetListener(string featureName);
    public void EnableDiagnosticTokens(bool enable);
    public IAsynchronousOperationWaiter GetWaiter(string featureName);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.TestHooks.AsynchronousOperationListenerProvider/<WaitAllAsync>d__15")]
public Task WaitAllAsync(Workspace workspace, String[] featureNames, Action eventProcessingAction, Nullable`1<TimeSpan> timeout);
    public bool HasPendingWaiter(String[] featureNames);
    public List`1<DiagnosticAsyncToken> GetTokens();
    internal static bool get_IsEnabled();
    internal bool get_DiagnosticTokensEnabled();
    private IEnumerable`1<IAsynchronousOperationWaiter> GetCandidateWaiters(String[] featureNames);
    [CompilerGeneratedAttribute]
private AsynchronousOperationListener <.ctor>b__11_0(string name);
}
internal class Microsoft.CodeAnalysis.Shared.TestHooks.EmptyAsyncToken : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private static IAsyncToken <Instance>k__BackingField;
    [NullableAttribute("1")]
public static IAsyncToken Instance { get; }
    private static EmptyAsyncToken();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public static IAsyncToken get_Instance();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.TestHooks.FeatureAttribute : object {
    public static string AutomaticEndConstructCorrection;
    public static string AutomaticPairCompletion;
    public static string BraceHighlighting;
    public static string CallHierarchy;
    public static string Classification;
    public static string CodeModel;
    public static string CodeDefinitionWindow;
    public static string CompletionSet;
    public static string DesignerAttributes;
    public static string DiagnosticService;
    public static string DocumentOutline;
    public static string EncapsulateField;
    public static string ErrorList;
    public static string ErrorSquiggles;
    public static string EventHookup;
    public static string ExtractMethod;
    public static string FindReferences;
    public static string GlobalOperation;
    public static string GoToBase;
    public static string GoToDefinition;
    public static string GoToImplementation;
    public static string GraphProvider;
    public static string InfoBar;
    public static string InlineDiagnostics;
    public static string InheritanceMargin;
    public static string InlineHints;
    public static string InlineRenameFlyout;
    public static string InteractiveEvaluator;
    public static string KeywordHighlighting;
    public static string LibraryManager;
    public static string LightBulb;
    public static string LineSeparators;
    public static string NavigableSymbols;
    public static string NavigateTo;
    public static string NavigationBar;
    public static string Outlining;
    public static string PackageInstaller;
    public static string PersistentStorage;
    public static string QuickInfo;
    public static string ReferenceHighlighting;
    public static string Rename;
    public static string RenameTracking;
    public static string SolutionChecksumUpdater;
    public static string SourceGenerators;
    public static string RuleSetEditor;
    public static string SignatureHelp;
    public static string Snippets;
    public static string SolutionCrawler;
    public static string StringIndentation;
    public static string TaskList;
    public static string Telemetry;
    public static string LanguageServer;
    public static string ValueTracking;
    public static string Workspace;
    public static string AddImportsOnPaste;
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListener {
    [NullableContextAttribute("1")]
public abstract virtual IAsyncToken BeginAsyncOperation(string name, object tag, string filePath, int lineNumber);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationListenerProvider {
    public abstract virtual IAsynchronousOperationListener GetListener(string featureName);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsynchronousOperationWaiter {
    public bool TrackActiveTokens { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticAsyncToken> ActiveDiagnosticTokens { get; }
    public bool HasPendingWork { get; }
    public abstract virtual bool get_TrackActiveTokens();
    public abstract virtual void set_TrackActiveTokens(bool value);
    public abstract virtual ImmutableArray`1<DiagnosticAsyncToken> get_ActiveDiagnosticTokens();
    public abstract virtual Task ExpeditedWaitAsync();
    public abstract virtual bool get_HasPendingWork();
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IAsyncToken {
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IExpeditableDelaySource {
    public abstract virtual Task`1<bool> Delay(TimeSpan delay, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.Shared.TestHooks.IRemoteAsynchronousOperationListenerService {
    public abstract virtual ValueTask EnableAsync(bool enable, bool diagnostics, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<bool> IsCompletedAsync(ImmutableArray`1<string> featureNames, CancellationToken cancellationToken);
    public abstract virtual ValueTask ExpeditedWaitAsync(ImmutableArray`1<string> featureNames, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.TestHooks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task CompletesAsyncOperation(Task task, IAsyncToken asyncToken);
    [ExtensionAttribute]
public static Task CompletesTrackingOperation(Task task, IDisposable token);
    [ExtensionAttribute]
public static NoThrowTaskAwaitable NoThrowAwaitableInternal(Task task, bool captureContext);
    [CompilerGeneratedAttribute]
internal static Task <CompletesTrackingOperation>g__CompletesTrackingOperationSlow|1_0(Task task, IDisposable token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.AbstractSpeculationAnalyzer`8 : object {
    private TExpressionSyntax _expression;
    private TExpressionSyntax _newExpressionForReplace;
    private SemanticModel _semanticModel;
    private CancellationToken _cancellationToken;
    private bool _skipVerificationForReplacedNode;
    private bool _failOnOverloadResolutionFailuresInOriginalCode;
    private bool _isNewSemanticModelSpeculativeModel;
    [NullableAttribute("2")]
private SyntaxNode _lazySemanticRootOfOriginalExpression;
    [NullableAttribute("2")]
private TExpressionSyntax _lazyReplacedExpression;
    [NullableAttribute("2")]
private SyntaxNode _lazySemanticRootOfReplacedExpression;
    [NullableAttribute("2")]
private SemanticModel _lazySpeculativeSemanticModel;
    protected ISyntaxFacts SyntaxFactsService { get; }
    public TExpressionSyntax OriginalExpression { get; }
    private SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.OriginalExpression { get; }
    public SyntaxNode SemanticRootOfOriginalExpression { get; }
    public SemanticModel OriginalSemanticModel { get; }
    public TExpressionSyntax ReplacedExpression { get; }
    private SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.ReplacedExpression { get; }
    public SyntaxNode SemanticRootOfReplacedExpression { get; }
    public SemanticModel SpeculativeSemanticModel { get; }
    public CancellationToken CancellationToken { get; }
    public AbstractSpeculationAnalyzer`8(TExpressionSyntax expression, TExpressionSyntax newExpression, SemanticModel semanticModel, CancellationToken cancellationToken, bool skipVerificationForReplacedNode, bool failOnOverloadResolutionFailuresInOriginalCode);
    protected abstract virtual ISyntaxFacts get_SyntaxFactsService();
    [NullableContextAttribute("2")]
protected abstract virtual bool CanAccessInstanceMemberThrough(TExpressionSyntax expression);
    public TExpressionSyntax get_OriginalExpression();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.get_OriginalExpression();
    public SyntaxNode get_SemanticRootOfOriginalExpression();
    public sealed virtual SemanticModel get_OriginalSemanticModel();
    public TExpressionSyntax get_ReplacedExpression();
    private sealed virtual override SyntaxNode Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer.get_ReplacedExpression();
    public SyntaxNode get_SemanticRootOfReplacedExpression();
    public sealed virtual SemanticModel get_SpeculativeSemanticModel();
    public CancellationToken get_CancellationToken();
    protected abstract virtual SyntaxNode GetSemanticRootForSpeculation(TExpressionSyntax expression);
    protected virtual SyntaxNode GetSemanticRootOfReplacedExpression(SyntaxNode semanticRootOfOriginalExpression, TExpressionSyntax annotatedReplacedExpression);
    [MemberNotNullAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private void EnsureReplacedExpressionAndSemanticRoot();
    [ConditionalAttribute("DEBUG")]
protected abstract virtual void ValidateSpeculativeSemanticModel(SemanticModel speculativeSemanticModel, SyntaxNode nodeToSpeculate);
    [MemberNotNullAttribute("_lazySpeculativeSemanticModel")]
private void EnsureSpeculativeSemanticModel();
    protected abstract virtual SemanticModel CreateSpeculativeSemanticModel(SyntaxNode originalNode, SyntaxNode nodeToSpeculate, SemanticModel semanticModel);
    protected virtual bool ReplacementIntroducesErrorType(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool TypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ConvertedTypesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    protected bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    private bool ImplicitConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected abstract virtual bool ConversionsAreCompatible(SemanticModel model1, TExpressionSyntax expression1, SemanticModel model2, TExpressionSyntax expression2);
    protected abstract virtual bool ConversionsAreCompatible(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType);
    protected bool SymbolsAreCompatible(SyntaxNode originalNode, SyntaxNode newNode, bool requireNonNullSymbols);
    public static bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool performEquivalenceCheck, bool requireNonNullSymbols);
    protected bool SymbolInfosAreCompatible(SymbolInfo originalSymbolInfo, SymbolInfo newSymbolInfo, bool requireNonNullSymbols);
    [NullableContextAttribute("2")]
protected bool SymbolsAreCompatible(ISymbol symbol, ISymbol newSymbol, bool requireNonNullSymbols);
    [NullableContextAttribute("2")]
private static bool SymbolsAreCompatibleCore(ISymbol symbol, ISymbol newSymbol, bool performEquivalenceCheck, bool requireNonNullSymbols);
    private static bool CompareAcrossSemanticModels(ISymbol symbol, ISymbol newSymbol);
    private static bool EnumTypesAreCompatible(INamedTypeSymbol type1, INamedTypeSymbol type2);
    public bool ReplacementChangesSemantics();
    [NullableContextAttribute("2")]
protected abstract virtual bool IsParenthesizedExpression(SyntaxNode node);
    protected bool ReplacementChangesSemantics(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode originalRoot, bool skipVerificationForCurrentNode);
    public bool SymbolsForOriginalAndReplacedNodesAreCompatible();
    protected abstract virtual bool ReplacementChangesSemanticsForNodeLanguageSpecific(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    private bool ReplacementChangesSemanticsForNode(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    [NullableContextAttribute("2")]
private bool MemberAccessesAreCompatible(TExpressionSyntax originalExpression, TExpressionSyntax newExpression);
    [NullableContextAttribute("2")]
private static bool IsStaticAccess(ISymbol symbol);
    [NullableContextAttribute("2")]
private bool InvocationsAreCompatible(TInvocationExpressionSyntax originalInvocation, TInvocationExpressionSyntax newInvocation);
    private bool ReplacementBreaksSystemObjectMethodResolution(SyntaxNode currentOriginalNode, SyntaxNode currentReplacedNode, SyntaxNode previousOriginalNode, SyntaxNode previousReplacedNode);
    [NullableContextAttribute("2")]
private static bool IsSymbolSystemObjectInstanceMethod(ISymbol symbol);
    private bool ReplacementBreaksAttribute(TAttributeSyntax attribute, TAttributeSyntax newAttribute);
    protected abstract virtual TExpressionSyntax GetForEachStatementExpression(TForEachStatementSyntax forEachStatement);
    protected abstract virtual bool IsForEachTypeInferred(TForEachStatementSyntax forEachStatement, SemanticModel semanticModel);
    private bool ReplacementBreaksForEachStatement(TForEachStatementSyntax forEachStatement, TForEachStatementSyntax newForEachStatement);
    protected abstract virtual bool ForEachConversionsAreCompatible(SemanticModel originalModel, TForEachStatementSyntax originalForEach, SemanticModel newModel, TForEachStatementSyntax newForEach);
    protected abstract virtual void GetForEachSymbols(SemanticModel model, TForEachStatementSyntax forEach, IMethodSymbol& getEnumeratorMethod, ITypeSymbol& elementType);
    private bool ReplacementBreaksForEachGetEnumerator(IMethodSymbol getEnumerator, IMethodSymbol newGetEnumerator, TExpressionSyntax newForEachStatementExpression);
    protected abstract virtual TExpressionSyntax GetThrowStatementExpression(TThrowStatementSyntax throwStatement);
    private bool ReplacementBreaksThrowStatement(TThrowStatementSyntax originalThrowStatement, TThrowStatementSyntax newThrowStatement);
    protected abstract virtual bool IsInNamespaceOrTypeContext(TExpressionSyntax node);
    private bool ReplacementBreaksTypeResolution(TTypeSyntax type, TTypeSyntax newType, bool useSpeculativeModel);
    [NullableContextAttribute("2")]
protected abstract virtual bool ExpressionMightReferenceMember(SyntaxNode node);
    private static bool IsDelegateInvoke(ISymbol symbol);
    private static bool IsAnonymousDelegateInvoke(ISymbol symbol);
    private bool ReplacementBreaksExpression(TExpressionSyntax expression, TExpressionSyntax newExpression);
    protected bool ReplacementBreaksCompoundAssignment(TExpressionSyntax originalLeft, TExpressionSyntax originalRight, TExpressionSyntax newLeft, TExpressionSyntax newRight);
    protected abstract virtual bool IsReferenceConversion(Compilation model, ITypeSymbol sourceType, ITypeSymbol targetType);
    private bool IsCompatibleInterfaceMemberImplementation(ISymbol symbol, ISymbol newSymbol, TExpressionSyntax originalExpression, TExpressionSyntax newExpression, SemanticModel speculativeSemanticModel);
    private bool IsReceiverNonUniquePossibleValueTypeParam(TExpressionSyntax invocation, SemanticModel semanticModel);
    private static bool IsReceiverUniqueInstance(TExpressionSyntax receiver, SemanticModel semanticModel);
    protected abstract virtual ImmutableArray`1<TArgumentSyntax> GetArguments(TExpressionSyntax expression);
    protected abstract virtual TExpressionSyntax GetReceiver(TExpressionSyntax expression);
    private bool SymbolsHaveCompatibleParameterLists(ISymbol originalSymbol, ISymbol newSymbol, TExpressionSyntax originalInvocation);
    protected abstract virtual bool IsNamedArgument(TArgumentSyntax argument);
    protected abstract virtual string GetNamedArgumentIdentifierValueText(TArgumentSyntax argument);
    private bool AreCompatibleParameterLists(ImmutableArray`1<TArgumentSyntax> specifiedArguments, ImmutableArray`1<IParameterSymbol> signature1Parameters, ImmutableArray`1<IParameterSymbol> signature2Parameters);
    protected void GetConversions(TExpressionSyntax originalExpression, ITypeSymbol originalTargetType, TExpressionSyntax newExpression, ITypeSymbol newTargetType, Nullable`1& originalConversion, Nullable`1& newConversion);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, TExpressionSyntax expression, ITypeSymbol targetType);
    protected abstract virtual TConversion ClassifyConversion(SemanticModel model, ITypeSymbol originalType, ITypeSymbol targetType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.AliasSymbolCache : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ConditionalWeakTable`2<Compilation, ConcurrentDictionary`2<ValueTuple`2<SyntaxTree, int>, ImmutableDictionary`2<INamespaceOrTypeSymbol, IAliasSymbol>>> s_treeAliasMap;
    private static AliasSymbolCache();
    public static bool TryGetAliasSymbol(SemanticModel semanticModel, int namespaceId, INamespaceOrTypeSymbol targetSymbol, IAliasSymbol& aliasSymbol);
    public static void AddAliasSymbols(SemanticModel semanticModel, int namespaceId, IEnumerable`1<IAliasSymbol> aliasSymbols);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.BloomFilter : object {
    private static UInt32 Compute_Hash_m;
    private static int Compute_Hash_r;
    private BitArray _bitArray;
    private int _hashFunctionCount;
    private bool _isCaseSensitive;
    private static string SerializationFormat;
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public BloomFilter(int expectedCount, double falsePositiveProbability, bool isCaseSensitive);
    public BloomFilter(double falsePositiveProbability, bool isCaseSensitive, ICollection`1<string> values);
    public BloomFilter(double falsePositiveProbability, ICollection`1<string> stringValues, ICollection`1<long> longValues);
    private BloomFilter(BitArray bitArray, int hashFunctionCount, bool isCaseSensitive);
    private static int ComputeM(int expectedCount, double falsePositiveProbability);
    private static int ComputeK(int expectedCount, double falsePositiveProbability);
    private int ComputeHash(string key, int seed);
    private static int ComputeHash(long key, int seed);
    private static UInt32 CombineLastCharacter(UInt32 h, UInt32 c);
    private static UInt32 FinalMix(UInt32 h);
    private static UInt32 CombineTwoCharacters(UInt32 h, UInt32 c1, UInt32 c2);
    private char GetCharacter(string key, int index);
    private static char GetCharacter(long key, int index);
    public void AddRange(IEnumerable`1<string> values);
    public void AddRange(IEnumerable`1<long> values);
    public void Add(string value);
    private int GetBitArrayIndex(string value, int i);
    public void Add(long value);
    private int GetBitArrayIndex(long value, int i);
    public bool ProbablyContains(string value);
    public bool ProbablyContains(long value);
    public bool IsEquivalent(BloomFilter filter);
    private static bool IsEquivalent(BitArray array1, BitArray array2);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    private static void WriteBitArray(ObjectWriter writer, BitArray bitArray);
    public static BloomFilter ReadFrom(ObjectReader reader);
    private static BitArray ReadBitArray(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers : object {
    public static Comparison`1<SuppressOperation> SuppressOperationComparer;
    public static Comparison`1<IndentBlockOperation> IndentBlockOperationComparer;
    private static CommonFormattingHelpers();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.CommonFormattingHelpers/<ConvertToTokenPairs>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<SyntaxToken, SyntaxToken>> ConvertToTokenPairs(SyntaxNode root, IReadOnlyList`1<TextSpan> spans);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static ValueTuple`2<SyntaxToken, SyntaxToken> ConvertToTokenPair(SyntaxNode root, TextSpan textSpan);
    [ExtensionAttribute]
public static bool IsInvalidTokenRange(SyntaxNode root, SyntaxToken startToken, SyntaxToken endToken);
    [ExtensionAttribute]
public static int GetTokenColumn(SyntaxTree tree, SyntaxToken token, int tabSize);
    [ExtensionAttribute]
public static string GetText(SourceText text, SyntaxToken token1, SyntaxToken token2);
    public static string GetTextBetween(SyntaxToken token1, SyntaxToken token2);
    public static void AppendTextBetween(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendTextBetweenTwoAdjacentTokens(SyntaxToken token1, SyntaxToken token2, StringBuilder builder);
    private static void AppendLeadingTriviaText(SyntaxToken token, StringBuilder builder);
    private static void AppendPartialLeadingTriviaText(SyntaxToken token, StringBuilder builder, int token1FullSpanEnd);
    private static void AppendTrailingTriviaText(SyntaxToken token, StringBuilder builder);
    public static TextSpan GetSpanIncludingTrailingAndLeadingTriviaOfAdjacentTokens(SyntaxToken startToken, SyntaxToken endToken);
    private static int GetEndPositionOfSpan(SyntaxToken token);
    public static int GetStartPositionOfSpan(SyntaxToken token);
    [NullableContextAttribute("2")]
private static SyntaxNode GetParentThatContainsGivenSpan(SyntaxNode node, int position, bool forward);
    public static bool HasAnyWhitespaceElasticTrivia(SyntaxToken previousToken, SyntaxToken currentToken);
    public static bool IsNull(T t);
    public static bool IsNotNull(T t);
    public static TextSpan GetFormattingSpan(SyntaxNode root, TextSpan span);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.DocumentationComment : object {
    [CompilerGeneratedAttribute]
private bool <HadXmlParseError>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <FullXmlFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExampleText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SummaryText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReturnsText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemarksText>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ParameterNames>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <TypeParameterNames>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <ExceptionTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompletionListCref>k__BackingField;
    [NullableAttribute("1")]
private static String[] s_NewLineAsStringArray;
    private static DocumentationComment modreq(System.Runtime.CompilerServices.IsVolatile) s_cacheLastXmlFragmentParse;
    [NullableAttribute("1")]
private Dictionary`2<string, string> _parameterTexts;
    [NullableAttribute("1")]
private Dictionary`2<string, string> _typeParameterTexts;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ImmutableArray`1<string>> _exceptionTexts;
    [NullableAttribute("1")]
public static DocumentationComment Empty;
    public bool HadXmlParseError { get; private set; }
    [NullableAttribute("1")]
public string FullXmlFragment { get; private set; }
    public string ExampleText { get; private set; }
    public string SummaryText { get; private set; }
    public string ReturnsText { get; private set; }
    public string ValueText { get; private set; }
    public string RemarksText { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> ParameterNames { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> TypeParameterNames { get; private set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> ExceptionTypes { get; private set; }
    public string CompletionListCref { get; private set; }
    [NullableContextAttribute("1")]
private DocumentationComment(string fullXmlFragment);
    private static DocumentationComment();
    [CompilerGeneratedAttribute]
public bool get_HadXmlParseError();
    [CompilerGeneratedAttribute]
private void set_HadXmlParseError(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_FullXmlFragment();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void set_FullXmlFragment(string value);
    [CompilerGeneratedAttribute]
public string get_ExampleText();
    [CompilerGeneratedAttribute]
private void set_ExampleText(string value);
    [CompilerGeneratedAttribute]
public string get_SummaryText();
    [CompilerGeneratedAttribute]
private void set_SummaryText(string value);
    [CompilerGeneratedAttribute]
public string get_ReturnsText();
    [CompilerGeneratedAttribute]
private void set_ReturnsText(string value);
    [CompilerGeneratedAttribute]
public string get_ValueText();
    [CompilerGeneratedAttribute]
private void set_ValueText(string value);
    [CompilerGeneratedAttribute]
public string get_RemarksText();
    [CompilerGeneratedAttribute]
private void set_RemarksText(string value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_TypeParameterNames();
    [CompilerGeneratedAttribute]
private void set_TypeParameterNames(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_ExceptionTypes();
    [CompilerGeneratedAttribute]
private void set_ExceptionTypes(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CompletionListCref();
    [CompilerGeneratedAttribute]
private void set_CompletionListCref(string value);
    [NullableContextAttribute("1")]
public static DocumentationComment FromXmlFragment(string xml);
    [NullableContextAttribute("1")]
public string GetParameterText(string parameterName);
    [NullableContextAttribute("1")]
public string GetTypeParameterText(string typeParameterName);
    [NullableContextAttribute("1")]
public ImmutableArray`1<string> GetExceptionTexts(string exceptionName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EditorBrowsableHelpers : object {
    public static IMethodSymbol GetSpecialEditorBrowsableAttributeConstructor(Compilation compilation);
    public static ImmutableArray`1<IMethodSymbol> GetSpecialTypeLibTypeAttributeConstructors(Compilation compilation);
    public static ImmutableArray`1<IMethodSymbol> GetSpecialTypeLibFuncAttributeConstructors(Compilation compilation);
    public static ImmutableArray`1<IMethodSymbol> GetSpecialTypeLibVarAttributeConstructors(Compilation compilation);
    private static ImmutableArray`1<IMethodSymbol> GetSpecialTypeLibAttributeConstructorsWorker(Compilation compilation, string attributeMetadataName, string flagsMetadataName);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.EnumValueUtilities : object {
    public static object GetNextEnumValue(INamedTypeSymbol enumType);
    private static object CreateOne(SpecialType specialType);
    private static IComparable Multiply(IComparable value, UInt32 number);
    private static IComparable Add(IComparable value, UInt32 number);
    private static bool GreaterThanOrEqualsZero(IComparable value);
    private static bool LooksLikeFlagsEnum(List`1<IComparable> existingConstants);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.ExtensionOrderer : object {
    [NullableContextAttribute("1")]
internal static IList`1<Lazy`2<TExtension, TMetadata>> Order(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
    [NullableContextAttribute("1")]
private static Graph`2<TExtension, TMetadata> GetGraph(IEnumerable`1<Lazy`2<TExtension, TMetadata>> extensions);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IntegerUtilities : object {
    public static int CountOfBitsSet(long v);
    [NullableContextAttribute("1")]
public static bool HasOneBitSet(IComparable value);
    public static bool HasOneBitSet(long v);
    public static int LogBase2(long v);
    public static long Convert(long v, SpecialType type);
    public static ulong ToUnsigned(long v);
    public static ulong ToUInt64(object o);
    public static long ToInt64(object o);
    public static bool IsIntegral(object value);
}
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IOUtilities : object {
    public static void PerformIO(Action action);
    public static T PerformIO(Func`1<T> function, T defaultValue);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.IOUtilities/<PerformIOAsync>d__2`1")]
public static Task`1<T> PerformIOAsync(Func`1<Task`1<T>> function, T defaultValue);
    public static bool IsNormalIOException(Exception e);
}
[NullableContextAttribute("2")]
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IProgressTracker {
    public string Description { get; public set; }
    public int CompletedItems { get; }
    public int TotalItems { get; }
    public abstract virtual string get_Description();
    public abstract virtual void set_Description(string value);
    public abstract virtual int get_CompletedItems();
    public abstract virtual int get_TotalItems();
    public abstract virtual void AddItems(int count);
    public abstract virtual void ItemCompleted();
    public abstract virtual void Clear();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IProgressTrackerExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ItemCompletedDisposer ItemCompletedScope(IProgressTracker tracker, string description);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Utilities.ISpeculationAnalyzer {
    public SyntaxNode OriginalExpression { get; }
    public SyntaxNode ReplacedExpression { get; }
    public SemanticModel OriginalSemanticModel { get; }
    public SemanticModel SpeculativeSemanticModel { get; }
    public abstract virtual SyntaxNode get_OriginalExpression();
    public abstract virtual SyntaxNode get_ReplacedExpression();
    public abstract virtual SemanticModel get_OriginalSemanticModel();
    public abstract virtual SemanticModel get_SpeculativeSemanticModel();
}
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTracker {
    public abstract virtual ValueTask AddItemsAsync(int count, CancellationToken cancellationToken);
    public abstract virtual ValueTask ItemsCompletedAsync(int count, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTrackerExtensions : object {
    [NullableContextAttribute("1")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.IStreamingProgressTrackerExtensions/<AddSingleItemAsync>d__0")]
[ExtensionAttribute]
public static Task`1<IAsyncDisposable> AddSingleItemAsync(IStreamingProgressTracker progressTracker, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ValueTask ItemCompletedAsync(IStreamingProgressTracker tracker, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IWorkspaceThreadingService {
    public bool IsOnMainThread { get; }
    public abstract virtual bool get_IsOnMainThread();
    public abstract virtual TResult Run(Func`1<Task`1<TResult>> asyncMethod);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Shared.Utilities.IWorkspaceThreadingServiceProvider {
    public IWorkspaceThreadingService Service { get; }
    public abstract virtual IWorkspaceThreadingService get_Service();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.Matcher : object {
    public static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    public static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    public static Matcher`1<T> Choice(Matcher`1[] matchers);
    public static Matcher`1<T> Sequence(Matcher`1[] matchers);
    public static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.Matcher`1 : object {
    public abstract virtual bool TryMatch(IList`1<T> sequence, Int32& index);
    internal static Matcher`1<T> Repeat(Matcher`1<T> matcher);
    internal static Matcher`1<T> OneOrMore(Matcher`1<T> matcher);
    internal static Matcher`1<T> Choice(Matcher`1[] matchers);
    internal static Matcher`1<T> Sequence(Matcher`1[] matchers);
    internal static Matcher`1<T> Single(Func`2<T, bool> predicate, string description);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.NameGenerator : object {
    public static string EnsureUniqueness(string baseName, IEnumerable`1<string> reservedNames, bool isCaseSensitive);
    public static ImmutableArray`1<string> EnsureUniqueness(ImmutableArray`1<string> names, Func`2<string, bool> canUse, bool isCaseSensitive);
    [NullableContextAttribute("0")]
public static ImmutableArray`1<string> EnsureUniqueness(ImmutableArray`1<string> names, ImmutableArray`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    public static void EnsureUniquenessInPlace(ArrayBuilder`1<string> names, ArrayBuilder`1<bool> isFixed, Func`2<string, bool> canUse, bool isCaseSensitive);
    private static void HandleCollisions(ArrayBuilder`1<string> names, ArrayBuilder`1<bool> isFixed, string name, Func`2<string, bool> canUse, bool isCaseSensitive, ArrayBuilder`1<int> collisionIndices);
    private static void FillCollisionIndices(ArrayBuilder`1<string> names, string name, bool isCaseSensitive, ArrayBuilder`1<int> collisionIndices);
    public static string GenerateUniqueName(string baseName, Func`2<string, bool> canUse);
    public static string GenerateUniqueName(string baseName, ISet`1<string> names, StringComparer comparer);
    public static string GenerateUniqueName(string baseName, string extension, Func`2<string, bool> canUse);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.NoOpProgressTracker : object {
    [NullableAttribute("1")]
public static IProgressTracker Instance;
    public string Description { get; public set; }
    public int CompletedItems { get; }
    public int TotalItems { get; }
    private static NoOpProgressTracker();
    public sealed virtual string get_Description();
    public sealed virtual void set_Description(string value);
    public sealed virtual int get_CompletedItems();
    public sealed virtual int get_TotalItems();
    public sealed virtual void AddItems(int count);
    public sealed virtual void Clear();
    public sealed virtual void ItemCompleted();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.PathMetadataUtilities : object {
    private static Char[] NamespaceSeparatorArray;
    private static PathMetadataUtilities();
    public static string TryBuildNamespaceFromFolders(IEnumerable`1<string> folders, ISyntaxFacts syntaxFacts, string rootNamespace);
    [NullableContextAttribute("2")]
public static ImmutableArray`1<string> BuildFoldersFromNamespace(string namespace, string rootNamespace);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.ProgressTracker : object {
    private string _description;
    private int _completedItems;
    private int _totalItems;
    private Action`3<string, int, int> _updateActionOpt;
    public string Description { get; public set; }
    public int CompletedItems { get; }
    public int TotalItems { get; }
    public ProgressTracker(Action`3<string, int, int> updateActionOpt);
    public sealed virtual string get_Description();
    public sealed virtual void set_Description(string value);
    public sealed virtual int get_CompletedItems();
    public sealed virtual int get_TotalItems();
    public sealed virtual void AddItems(int count);
    public sealed virtual void ItemCompleted();
    public sealed virtual void Clear();
    private void Update();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SemanticMap : object {
    private Dictionary`2<SyntaxNode, SymbolInfo> _expressionToInfoMap;
    private Dictionary`2<SyntaxToken, SymbolInfo> _tokenToInfoMap;
    public IEnumerable`1<ISymbol> AllReferencedSymbols { get; }
    internal static SemanticMap From(SemanticModel semanticModel, SyntaxNode node, CancellationToken cancellationToken);
    public IEnumerable`1<ISymbol> get_AllReferencedSymbols();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.SignatureComparer : object {
    public static SignatureComparer Instance;
    public static SignatureComparer IgnoreAssembliesInstance;
    private SymbolEquivalenceComparer _symbolEquivalenceComparer;
    private IEqualityComparer`1<IParameterSymbol> ParameterEquivalenceComparer { get; }
    private IEqualityComparer`1<ITypeSymbol> SignatureTypeEquivalenceComparer { get; }
    private SignatureComparer(SymbolEquivalenceComparer symbolEquivalenceComparer);
    private static SignatureComparer();
    private IEqualityComparer`1<IParameterSymbol> get_ParameterEquivalenceComparer();
    private IEqualityComparer`1<ITypeSymbol> get_SignatureTypeEquivalenceComparer();
    public bool HaveSameSignature(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private static bool HaveSameSignature(IEventSymbol event1, IEventSymbol event2, bool caseSensitive);
    public bool HaveSameSignature(IPropertySymbol property1, IPropertySymbol property2, bool caseSensitive);
    private static bool BadPropertyAccessor(IMethodSymbol method1, IMethodSymbol method2);
    public bool HaveSameSignature(IMethodSymbol method1, IMethodSymbol method2, bool caseSensitive, bool compareParameterName, bool isParameterCaseSensitive);
    private static bool IdentifiersMatch(string identifier1, string identifier2, bool caseSensitive);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2);
    public bool HaveSameSignature(IList`1<IParameterSymbol> parameters1, IList`1<IParameterSymbol> parameters2, bool compareParameterName, bool isCaseSensitive);
    public bool HaveSameSignatureAndConstraintsAndReturnTypeAndAccessors(ISymbol symbol1, ISymbol symbol2, bool caseSensitive);
    private static bool HaveSameAccessors(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameSignatureAndConstraintsAndReturnType(IMethodSymbol method1, IMethodSymbol method2);
    private bool HaveSameConstraints(ITypeParameterSymbol typeParameter1, ITypeParameterSymbol typeParameter2);
    private bool HaveSameReturnType(IPropertySymbol property1, IPropertySymbol property2);
    private bool HaveSameReturnType(IEventSymbol ev1, IEventSymbol ev2);
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.StreamingProgressTracker : object {
    private int _completedItems;
    private int _totalItems;
    [NullableAttribute("2")]
private Func`4<int, int, CancellationToken, ValueTask> _updateAction;
    [NullableContextAttribute("2")]
public StreamingProgressTracker(Func`4<int, int, CancellationToken, ValueTask> updateAction);
    public sealed virtual ValueTask AddItemsAsync(int count, CancellationToken cancellationToken);
    public sealed virtual ValueTask ItemsCompletedAsync(int count, CancellationToken cancellationToken);
    private ValueTask UpdateAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Shared.Utilities.StringBreaker : object {
    [NullableContextAttribute("0")]
public static void AddWordParts(string identifier, TemporaryArray`1& parts);
    [NullableContextAttribute("0")]
public static void AddCharacterParts(string identifier, TemporaryArray`1& parts);
    [NullableContextAttribute("0")]
public static void AddParts(string text, bool word, TemporaryArray`1& parts);
    public static TextSpan GenerateSpan(string identifier, int wordStart, bool word);
    private static TextSpan ScanCharacterRun(string identifier, int length, int wordStart);
    private static TextSpan ScanWordRun(string identifier, int length, int wordStart);
    private static TextSpan ScanLowerCaseRun(string identifier, int length, int wordStart);
    private static TextSpan ScanNumber(string identifier, int length, int wordStart);
    private static int SkipPunctuation(string identifier, int length, int wordStart);
    private static bool IsLower(char c);
    private static bool IsAscii(char v);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<EquivalenceVisitor> _equivalenceVisitors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<GetHashCodeVisitor> _getHashCodeVisitors;
    public static SymbolEquivalenceComparer Instance;
    public static SymbolEquivalenceComparer TupleNamesMustMatchInstance;
    public static SymbolEquivalenceComparer IgnoreAssembliesInstance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<IAssemblySymbol> _assemblyComparerOpt;
    private bool _tupleNamesMustMatch;
    private bool _ignoreNullableAnnotations;
    [CompilerGeneratedAttribute]
private ParameterSymbolEqualityComparer <ParameterEquivalenceComparer>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureTypeSymbolEquivalenceComparer <SignatureTypeEquivalenceComparer>k__BackingField;
    public ParameterSymbolEqualityComparer ParameterEquivalenceComparer { get; }
    public SignatureTypeSymbolEquivalenceComparer SignatureTypeEquivalenceComparer { get; }
    internal SymbolEquivalenceComparer(IEqualityComparer`1<IAssemblySymbol> assemblyComparerOpt, bool distinguishRefFromOut, bool tupleNamesMustMatch, bool ignoreNullableAnnotations);
    private static SymbolEquivalenceComparer();
    [CompilerGeneratedAttribute]
public ParameterSymbolEqualityComparer get_ParameterEquivalenceComparer();
    [CompilerGeneratedAttribute]
public SignatureTypeSymbolEquivalenceComparer get_SignatureTypeEquivalenceComparer();
    private EquivalenceVisitor GetEquivalenceVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private GetHashCodeVisitor GetGetHashCodeVisitor(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    private static int GetVisitorIndex(bool compareMethodTypeParametersByIndex, bool objectAndDynamicCompareEqually);
    public bool ReturnTypeEquals(IMethodSymbol x, IMethodSymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ISymbol x, ISymbol y);
    [NullableContextAttribute("2")]
public bool Equals(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
private bool EqualsCore(ISymbol x, ISymbol y, Dictionary`2<INamedTypeSymbol, INamedTypeSymbol> equivalentTypesWithDifferingAssemblies);
    [NullableContextAttribute("2")]
public sealed virtual int GetHashCode(ISymbol x);
    private static ISymbol UnwrapAlias(ISymbol symbol);
    private static SymbolKind GetKindAndUnwrapAlias(ISymbol& symbol);
    private static bool IsConstructedFromSelf(INamedTypeSymbol symbol);
    private static bool IsConstructedFromSelf(IMethodSymbol symbol);
    private static bool IsObjectType(ISymbol symbol);
    private static bool CheckContainingType(IMethodSymbol x);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.Shared.Utilities.SymbolEquivalenceComparer/<Unwrap>d__30")]
private static IEnumerable`1<INamedTypeSymbol> Unwrap(INamedTypeSymbol namedType);
    private static bool IsPartialMethodDefinitionPart(IMethodSymbol symbol);
    private static bool IsPartialMethodImplementationPart(IMethodSymbol symbol);
    private static TypeKind GetTypeKind(INamedTypeSymbol x);
    public static bool AreRefKindsEquivalent(RefKind rk1, RefKind rk2, bool distinguishRefFromOut);
}
internal enum Microsoft.CodeAnalysis.Shared.Utilities.SymbolVisibility : Enum {
    public int value__;
    public static SymbolVisibility Public;
    public static SymbolVisibility Internal;
    public static SymbolVisibility Private;
}
internal abstract class Microsoft.CodeAnalysis.Shared.Utilities.TextReaderWithLength : TextReader {
    [CompilerGeneratedAttribute]
private int <Length>k__BackingField;
    public int Length { get; }
    public TextReaderWithLength(int length);
    [CompilerGeneratedAttribute]
public int get_Length();
}
internal class Microsoft.CodeAnalysis.Shared.Utilities.XmlFragmentParser : object {
    private XmlReader _xmlReader;
    private Reader _textReader;
    private static ObjectPool`1<XmlFragmentParser> s_pool;
    private static XmlReaderSettings s_xmlSettings;
    private bool BeforeStart { get; }
    private bool ReachedEnd { get; }
    private static XmlFragmentParser();
    public static void ParseFragment(string xmlFragment, Action`2<XmlReader, TArg> callback, TArg arg);
    private void ParseInternal(string text, Action`2<XmlReader, TArg> callback, TArg arg);
    private bool get_BeforeStart();
    private bool get_ReachedEnd();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SharedPoolExtensions : object {
    private static int Threshold;
    [ExtensionAttribute]
public static PooledObject`1<StringBuilder> GetPooledObject(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static PooledObject`1<Stack`1<TItem>> GetPooledObject(ObjectPool`1<Stack`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Queue`1<TItem>> GetPooledObject(ObjectPool`1<Queue`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<HashSet`1<TItem>> GetPooledObject(ObjectPool`1<HashSet`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<Dictionary`2<TKey, TValue>> GetPooledObject(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool);
    [ExtensionAttribute]
public static PooledObject`1<List`1<TItem>> GetPooledObject(ObjectPool`1<List`1<TItem>> pool, List`1& list);
    [ExtensionAttribute]
public static PooledObject`1<T> GetPooledObject(ObjectPool`1<T> pool);
    [ExtensionAttribute]
public static StringBuilder AllocateAndClear(ObjectPool`1<StringBuilder> pool);
    [ExtensionAttribute]
public static Stack`1<T> AllocateAndClear(ObjectPool`1<Stack`1<T>> pool);
    [ExtensionAttribute]
public static Queue`1<T> AllocateAndClear(ObjectPool`1<Queue`1<T>> pool);
    [ExtensionAttribute]
public static HashSet`1<T> AllocateAndClear(ObjectPool`1<HashSet`1<T>> pool);
    [ExtensionAttribute]
public static Dictionary`2<TKey, TValue> AllocateAndClear(ObjectPool`1<Dictionary`2<TKey, TValue>> pool);
    [ExtensionAttribute]
public static List`1<T> AllocateAndClear(ObjectPool`1<List`1<T>> pool);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<StringBuilder> pool, StringBuilder sb);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<HashSet`1<T>> pool, HashSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<ConcurrentSet`1<T>> pool, ConcurrentSet`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Stack`1<T>> pool, Stack`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Queue`1<T>> pool, Queue`1<T> set);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<Dictionary`2<TKey, TValue>> pool, Dictionary`2<TKey, TValue> map);
    [ExtensionAttribute]
public static void ClearAndFree(ObjectPool`1<List`1<T>> pool, List`1<T> list);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SharedPools : object {
    public static ObjectPool`1<HashSet`1<string>> StringIgnoreCaseHashSet;
    public static ObjectPool`1<HashSet`1<string>> StringHashSet;
    public static ObjectPool`1<Byte[]> ByteArray;
    public static ObjectPool`1<Char[]> CharArray;
    public static int ByteBufferSize;
    private static int ByteBufferCount;
    private static int CharBufferCount;
    private static SharedPools();
    public static ObjectPool`1<T> BigDefault();
    public static ObjectPool`1<T> Default();
    public static ObjectPool`1<Dictionary`2<string, T>> StringIgnoreCaseDictionary();
}
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractReducer : object {
    private ObjectPool`1<IReductionRewriter> _pool;
    protected AbstractReducer(ObjectPool`1<IReductionRewriter> pool);
    public IReductionRewriter GetOrCreateRewriter();
    public abstract virtual bool IsApplicable(SimplifierOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractSimplification : object {
    public SimplifierOptions DefaultOptions { get; }
    public abstract virtual SimplifierOptions get_DefaultOptions();
    public abstract virtual SimplifierOptions GetSimplifierOptions(AnalyzerConfigOptions options, SimplifierOptions fallbackOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3 : object {
    protected static Func`2<SyntaxNode, bool> s_containsAnnotations;
    protected static Func`2<SyntaxNodeOrToken, bool> s_hasSimplifierAnnotation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<AbstractReducer> _reducers;
    public SimplifierOptions DefaultOptions { get; }
    protected AbstractSimplificationService`3(ImmutableArray`1<AbstractReducer> reducers);
    private static AbstractSimplificationService`3();
    protected abstract virtual ImmutableArray`1<NodeOrTokenToReduce> GetNodesAndTokensToReduce(SyntaxNode root, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpans);
    protected abstract virtual SemanticModel GetSpeculativeSemanticModel(SyntaxNode& nodeToSpeculate, SemanticModel originalSemanticModel, SyntaxNode originalNode);
    protected abstract virtual bool NodeRequiresNonSpeculativeSemanticModel(SyntaxNode node);
    public abstract virtual SimplifierOptions get_DefaultOptions();
    public abstract virtual SimplifierOptions GetSimplifierOptions(AnalyzerConfigOptions options, SimplifierOptions fallbackOptions);
    protected virtual SyntaxNode TransformReducedNode(SyntaxNode reducedNode, SyntaxNode originalNode);
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsync>d__13")]
public sealed virtual Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<TextSpan> spans, SimplifierOptions options, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceCoreAsync>d__14")]
private Task`1<Document> ReduceCoreAsync(Document document, ImmutableArray`1<TextSpan> spans, SimplifierOptions options, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<ReduceAsync>d__15")]
private Task ReduceAsync(Document document, SyntaxNode root, ImmutableArray`1<NodeOrTokenToReduce> nodesAndTokensToReduce, ImmutableArray`1<AbstractReducer> reducers, SimplifierOptions options, SemanticModel semanticModel, ConcurrentDictionary`2<SyntaxNode, SyntaxNode> reducedNodesMap, ConcurrentDictionary`2<SyntaxToken, SyntaxToken> reducedTokensMap, CancellationToken cancellationToken);
    private static SyntaxNode PrepareNamespaceImportsForRemovalIfUnused(Document document, SyntaxNode root, SyntaxAnnotation removeIfUnusedAnnotation, Func`2<SyntaxNodeOrToken, bool> isNodeOrTokenOutsideSimplifySpan);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.AbstractSimplificationService`3/<RemoveUnusedNamespaceImportsAsync>d__17")]
private Task`1<Document> RemoveUnusedNamespaceImportsAsync(Document document, SyntaxAnnotation removeIfUnusedAnnotation, CancellationToken cancellationToken);
    protected abstract virtual void GetUnusedNamespaceImports(SemanticModel model, HashSet`1<SyntaxNode> namespaceImports, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Simplification.AliasAnnotation : object {
    public static string Kind;
    public static string GetAliasName(SyntaxAnnotation annotation);
    public static SyntaxAnnotation Create(string aliasName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.DoNotAddImportsAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAddImportsAnnotation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.DoNotAllowVarAnnotation : object {
    public static SyntaxAnnotation Annotation;
    public static string Kind;
    private static DoNotAllowVarAnnotation();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Simplification.ISimplification {
    public SimplifierOptions DefaultOptions { get; }
    public abstract virtual SimplifierOptions get_DefaultOptions();
    public abstract virtual SimplifierOptions GetSimplifierOptions(AnalyzerConfigOptions options, SimplifierOptions fallbackOptions);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Simplification.ISimplificationService {
    public abstract virtual SyntaxNode Expand(SyntaxNode node, SemanticModel semanticModel, SyntaxAnnotation annotationForReplacedAliasIdentifier, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public abstract virtual SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public abstract virtual Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<TextSpan> spans, SimplifierOptions options, ImmutableArray`1<AbstractReducer> reducers, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Simplification.NodeOrTokenToReduce : ValueType {
    [CompilerGeneratedAttribute]
private SyntaxNodeOrToken <NodeOrToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SimplifyAllDescendants>k__BackingField;
    [CompilerGeneratedAttribute]
private SyntaxNodeOrToken <OriginalNodeOrToken>k__BackingField;
    public SyntaxNodeOrToken NodeOrToken { get; public set; }
    public bool SimplifyAllDescendants { get; public set; }
    public SyntaxNodeOrToken OriginalNodeOrToken { get; public set; }
    public NodeOrTokenToReduce(SyntaxNodeOrToken NodeOrToken, bool SimplifyAllDescendants, SyntaxNodeOrToken OriginalNodeOrToken);
    [CompilerGeneratedAttribute]
public SyntaxNodeOrToken get_NodeOrToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NodeOrToken(SyntaxNodeOrToken value);
    [CompilerGeneratedAttribute]
public bool get_SimplifyAllDescendants();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SimplifyAllDescendants(bool value);
    [CompilerGeneratedAttribute]
public SyntaxNodeOrToken get_OriginalNodeOrToken();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_OriginalNodeOrToken(SyntaxNodeOrToken value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(NodeOrTokenToReduce left, NodeOrTokenToReduce right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(NodeOrTokenToReduce left, NodeOrTokenToReduce right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(NodeOrTokenToReduce other);
    [CompilerGeneratedAttribute]
public void Deconstruct(SyntaxNodeOrToken& NodeOrToken, Boolean& SimplifyAllDescendants, SyntaxNodeOrToken& OriginalNodeOrToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Simplification.SimplificationHelpers : object {
    public static SyntaxAnnotation DontSimplifyAnnotation;
    public static SyntaxAnnotation SimplifyModuleNameAnnotation;
    private static SimplificationHelpers();
    public static TNode CopyAnnotations(SyntaxNode from, TNode to);
    public static SyntaxToken CopyAnnotations(SyntaxToken from, SyntaxToken to);
    internal static ISymbol GetOriginalSymbolInfo(SemanticModel semanticModel, SyntaxNode expression);
    [NullableContextAttribute("2")]
public static bool IsValidSymbolInfo(ISymbol symbol);
    public static bool IsNamespaceOrTypeOrThisParameter(SyntaxNode expression, SemanticModel semanticModel);
    internal static bool ShouldSimplifyThisOrMeMemberAccessExpression(SimplifierOptions options, ISymbol symbol);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Simplification.SimplificationOptions : object {
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferAliasToQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferOmittingModuleNamesInQualification>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInference>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <PreferImplicitTypeInLocalDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToGenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private static Option`1<bool> <AllowSimplificationToBaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyMemberAccessWithThisOrMe>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyFieldAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyPropertyAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyMethodAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <QualifyEventAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInDeclaration>k__BackingField;
    [CompilerGeneratedAttribute]
private static PerLanguageOption`1<bool> <PreferIntrinsicPredefinedTypeKeywordInMemberAccess>k__BackingField;
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> PreferAliasToQualification { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> PreferOmittingModuleNamesInQualification { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> PreferImplicitTypeInference { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> PreferImplicitTypeInLocalDeclaration { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> AllowSimplificationToGenericType { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static Option`1<bool> AllowSimplificationToBaseType { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> QualifyMemberAccessWithThisOrMe { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> QualifyFieldAccess { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> QualifyPropertyAccess { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> QualifyMethodAccess { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> QualifyEventAccess { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInDeclaration { get; }
    [ObsoleteAttribute("This option is no longer used")]
public static PerLanguageOption`1<bool> PreferIntrinsicPredefinedTypeKeywordInMemberAccess { get; }
    private static SimplificationOptions();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferAliasToQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferOmittingModuleNamesInQualification();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInference();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_PreferImplicitTypeInLocalDeclaration();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToGenericType();
    [CompilerGeneratedAttribute]
public static Option`1<bool> get_AllowSimplificationToBaseType();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyMemberAccessWithThisOrMe();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyFieldAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyPropertyAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyMethodAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_QualifyEventAccess();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInDeclaration();
    [CompilerGeneratedAttribute]
public static PerLanguageOption`1<bool> get_PreferIntrinsicPredefinedTypeKeywordInMemberAccess();
}
[ExportSolutionOptionProviderAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.Simplification.SimplificationOptionsProvider : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<IOption> <Options>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<IOption> Options { get; }
    [CompilerGeneratedAttribute]
public sealed virtual ImmutableArray`1<IOption> get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Simplification.Simplifier : object {
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <Annotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <SpecialTypeAnnotation>k__BackingField;
    [CompilerGeneratedAttribute]
private static SyntaxAnnotation <AddImportsAnnotation>k__BackingField;
    public static SyntaxAnnotation Annotation { get; }
    public static SyntaxAnnotation SpecialTypeAnnotation { get; }
    public static SyntaxAnnotation AddImportsAnnotation { get; }
    private static Simplifier();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_Annotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_SpecialTypeAnnotation();
    [CompilerGeneratedAttribute]
public static SyntaxAnnotation get_AddImportsAnnotation();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__9`1")]
public static Task`1<TNode> ExpandAsync(TNode node, Document document, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    public static TNode Expand(TNode node, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    internal static TNode Expand(TNode node, SemanticModel semanticModel, SolutionServices services, Func`2<SyntaxNode, bool> expandInsideNode, bool expandParameter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ExpandAsync>d__12")]
public static Task`1<SyntaxToken> ExpandAsync(SyntaxToken token, Document document, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    public static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, Workspace workspace, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    internal static SyntaxToken Expand(SyntaxToken token, SemanticModel semanticModel, SolutionServices services, Func`2<SyntaxNode, bool> expandInsideNode, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__15")]
public static Task`1<Document> ReduceAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__16")]
internal static Task`1<Document> ReduceAsync(Document document, SimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__17")]
public static Task`1<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, OptionSet optionSet, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__18")]
internal static Task`1<Document> ReduceAsync(Document document, SyntaxAnnotation annotation, SimplifierOptions options, CancellationToken cancellationToken);
    public static Task`1<Document> ReduceAsync(Document document, TextSpan span, OptionSet optionSet, CancellationToken cancellationToken);
    internal static Task`1<Document> ReduceAsync(Document document, TextSpan span, SimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__21")]
public static Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, OptionSet optionSet, CancellationToken cancellationToken);
    internal static Task`1<Document> ReduceAsync(Document document, IEnumerable`1<TextSpan> spans, SimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<ReduceAsync>d__23")]
internal static Task`1<Document> ReduceAsync(Document document, ImmutableArray`1<AbstractReducer> reducers, SimplifierOptions options, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.Simplifier/<GetOptionsAsync>d__24")]
internal static Task`1<SimplifierOptions> GetOptionsAsync(Document document, OptionSet optionSet, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Simplification.SimplifierOptions : object {
    public static CodeStyleOption2`1<bool> DefaultQualifyAccess;
    public static CodeStyleOption2`1<bool> DefaultPreferPredefinedTypeKeyword;
    [CompilerGeneratedAttribute]
private CommonOptions <Common>k__BackingField;
    public CommonOptions Common { get; public set; }
    public CodeStyleOption2`1<bool> QualifyFieldAccess { get; }
    public CodeStyleOption2`1<bool> QualifyPropertyAccess { get; }
    public CodeStyleOption2`1<bool> QualifyMethodAccess { get; }
    public CodeStyleOption2`1<bool> QualifyEventAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInMemberAccess { get; }
    public CodeStyleOption2`1<bool> PreferPredefinedTypeKeywordInDeclaration { get; }
    private static SimplifierOptions();
    [CompilerGeneratedAttribute]
public CommonOptions get_Common();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Common(CommonOptions value);
    public CodeStyleOption2`1<bool> get_QualifyFieldAccess();
    public CodeStyleOption2`1<bool> get_QualifyPropertyAccess();
    public CodeStyleOption2`1<bool> get_QualifyMethodAccess();
    public CodeStyleOption2`1<bool> get_QualifyEventAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInMemberAccess();
    public CodeStyleOption2`1<bool> get_PreferPredefinedTypeKeywordInDeclaration();
    [NullableContextAttribute("2")]
public bool TryGetQualifyMemberAccessOption(SymbolKind symbolKind, CodeStyleOption2`1& option);
    public static SimplifierOptions GetDefault(LanguageServices languageServices);
}
internal interface Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProvider {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProviders : object {
    [ExtensionAttribute]
internal static CommonOptions GetCommonSimplifierOptions(AnalyzerConfigOptions options, CommonOptions fallbackOptions);
    [ExtensionAttribute]
public static SimplifierOptions GetSimplifierOptions(AnalyzerConfigOptions options, SimplifierOptions fallbackOptions, LanguageServices languageServices);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProviders/<GetSimplifierOptionsAsync>d__2")]
[ExtensionAttribute]
public static ValueTask`1<SimplifierOptions> GetSimplifierOptionsAsync(Document document, SimplifierOptions fallbackOptions, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Simplification.SimplifierOptionsProviders/<GetSimplifierOptionsAsync>d__3")]
[ExtensionAttribute]
public static ValueTask`1<SimplifierOptions> GetSimplifierOptionsAsync(Document document, SimplifierOptionsProvider fallbackOptionsProvider, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Simplification.Simplifiers.AbstractMemberAccessExpressionSimplifier`3 : object {
    protected ISyntaxFacts SyntaxFacts { get; }
    protected abstract virtual ISyntaxFacts get_SyntaxFacts();
    protected abstract virtual ISpeculationAnalyzer GetSpeculationAnalyzer(SemanticModel semanticModel, TMemberAccessExpressionSyntax memberAccessExpression, CancellationToken cancellationToken);
    protected abstract virtual bool MayCauseParseDifference(TMemberAccessExpressionSyntax memberAccessExpression);
    public bool ShouldSimplifyThisMemberAccessExpression(TMemberAccessExpressionSyntax memberAccessExpression, SemanticModel semanticModel, SimplifierOptions simplifierOptions, TThisExpressionSyntax& thisExpression, ReportDiagnostic& severity, CancellationToken cancellationToken);
}
internal abstract class Microsoft.CodeAnalysis.Simplification.Simplifiers.AbstractSimplifier`3 : object {
    public abstract virtual bool TrySimplify(TSyntax syntax, SemanticModel semanticModel, TSimplifierOptions options, TSimplifiedSyntax& replacementNode, TextSpan& issueSpan, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.SpecialTypeAnnotation : object {
    public static string Kind;
    private static ConcurrentDictionary`2<SpecialType, string> s_fromSpecialTypes;
    private static ConcurrentDictionary`2<string, SpecialType> s_toSpecialTypes;
    private static SpecialTypeAnnotation();
    public static SyntaxAnnotation Create(SpecialType specialType);
    public static SpecialType GetSpecialType(SyntaxAnnotation annotation);
    private static string CreateFromSpecialTypes(SpecialType arg);
    private static SpecialType CreateToSpecialTypes(string arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Simplification.SymbolAnnotation : object {
    public static string Kind;
    public static SyntaxAnnotation Create(ISymbol symbol);
    public static ISymbol GetSymbol(SyntaxAnnotation annotation, Compilation compilation);
    public static ImmutableArray`1<ISymbol> GetSymbols(SyntaxAnnotation annotation, Compilation compilation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.Solution : object {
    private SolutionState _state;
    private ImmutableHashMap`2<ProjectId, Project> _projectIdToProjectMap;
    private static Func`3<ProjectId, Solution, Project> s_createProjectFunction;
    internal SolutionState State { get; }
    internal int WorkspaceVersion { get; }
    internal bool PartialSemanticsEnabled { get; }
    public SolutionServices Services { get; }
    [NullableAttribute("2")]
internal string WorkspaceKind { get; }
    public Workspace Workspace { get; }
    public SolutionId Id { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public VersionStamp Version { get; }
    public IReadOnlyList`1<ProjectId> ProjectIds { get; }
    public IEnumerable`1<Project> Projects { get; }
    public OptionSet Options { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    private Solution(SolutionState state);
    internal Solution(Workspace workspace, SolutionAttributes solutionAttributes, SolutionOptionSet options, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    private static Solution();
    internal SolutionState get_State();
    internal int get_WorkspaceVersion();
    internal bool get_PartialSemanticsEnabled();
    public SolutionServices get_Services();
    [NullableContextAttribute("2")]
internal string get_WorkspaceKind();
    internal ProjectState GetProjectState(ProjectId projectId);
    public Workspace get_Workspace();
    public SolutionId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public VersionStamp get_Version();
    public IReadOnlyList`1<ProjectId> get_ProjectIds();
    public IEnumerable`1<Project> get_Projects();
    public VersionStamp GetLatestProjectVersion();
    [NullableContextAttribute("2")]
public bool ContainsProject(ProjectId projectId);
    [NullableContextAttribute("2")]
public Project GetProject(ProjectId projectId);
    private static Project CreateProject(ProjectId projectId, Solution solution);
    public Project GetProject(IAssemblySymbol assemblySymbol, CancellationToken cancellationToken);
    internal ProjectId GetOriginatingProjectId(ISymbol symbol);
    internal Project GetOriginatingProject(ISymbol symbol);
    [NullableContextAttribute("2")]
public bool ContainsDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public bool ContainsAdditionalDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public bool ContainsAnalyzerConfigDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public DocumentId GetDocumentId(SyntaxTree syntaxTree);
    [NullableContextAttribute("2")]
public DocumentId GetDocumentId(SyntaxTree syntaxTree, ProjectId projectId);
    [NullableContextAttribute("2")]
public Document GetDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
internal ValueTask`1<Document> GetDocumentAsync(DocumentId documentId, bool includeSourceGenerated, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
internal ValueTask`1<TextDocument> GetTextDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TextDocument GetAdditionalDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public AnalyzerConfigDocument GetAnalyzerConfigDocument(DocumentId documentId);
    public ValueTask`1<SourceGeneratedDocument> GetSourceGeneratedDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Document GetDocument(SyntaxTree syntaxTree);
    [NullableContextAttribute("2")]
internal Document GetDocument(SyntaxTree syntaxTree, ProjectId projectId);
    public Project AddProject(string name, string assemblyName, string language);
    public Solution AddProject(ProjectId projectId, string name, string assemblyName, string language);
    public Solution AddProject(ProjectInfo projectInfo);
    public Solution RemoveProject(ProjectId projectId);
    public Solution WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public Solution WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public Solution WithProjectOutputRefFilePath(ProjectId projectId, string outputRefFilePath);
    public Solution WithProjectCompilationOutputInfo(ProjectId projectId, CompilationOutputInfo& info);
    public Solution WithProjectDefaultNamespace(ProjectId projectId, string defaultNamespace);
    public Solution WithProjectName(ProjectId projectId, string name);
    public Solution WithProjectFilePath(ProjectId projectId, string filePath);
    public Solution WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public Solution WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    internal Solution WithHasAllInformation(ProjectId projectId, bool hasAllInformation);
    internal Solution WithRunAnalyzers(ProjectId projectId, bool runAnalyzers);
    public Solution WithProjectDocumentsOrder(ProjectId projectId, ImmutableList`1<DocumentId> documentIds);
    public Solution AddProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution AddProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public Solution WithProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences);
    public Solution AddMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution AddMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public Solution WithProjectMetadataReferences(ProjectId projectId, IEnumerable`1<MetadataReference> metadataReferences);
    public Solution AddAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution AddAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Solution RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public Solution WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Solution AddAnalyzerReference(AnalyzerReference analyzerReference);
    public Solution AddAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    public Solution RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public Solution WithAnalyzerReferences(IEnumerable`1<AnalyzerReference> analyzerReferences);
    private static SourceCodeKind GetSourceCodeKind(ProjectState project);
    public Solution AddDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath, bool isGenerated);
    public Solution AddDocument(DocumentId documentId, string name, SyntaxNode syntaxRoot, IEnumerable`1<string> folders, string filePath, bool isGenerated, PreservationMode preservationMode);
    public Solution AddDocument(DocumentId documentId, string name, TextLoader loader, IEnumerable`1<string> folders);
    public Solution AddDocument(DocumentInfo documentInfo);
    public Solution AddDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, string text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAdditionalDocument(DocumentInfo documentInfo);
    public Solution AddAdditionalDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    public Solution AddAnalyzerConfigDocument(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    private DocumentInfo CreateDocumentInfo(DocumentId documentId, string name, SourceText text, IEnumerable`1<string> folders, string filePath);
    public Solution AddAnalyzerConfigDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    public Solution RemoveDocument(DocumentId documentId);
    public Solution RemoveDocuments(ImmutableArray`1<DocumentId> documentIds);
    private Solution RemoveDocumentsImpl(ImmutableArray`1<DocumentId> documentIds);
    public Solution RemoveAdditionalDocument(DocumentId documentId);
    public Solution RemoveAdditionalDocuments(ImmutableArray`1<DocumentId> documentIds);
    private Solution RemoveAdditionalDocumentsImpl(ImmutableArray`1<DocumentId> documentIds);
    public Solution RemoveAnalyzerConfigDocument(DocumentId documentId);
    public Solution RemoveAnalyzerConfigDocuments(ImmutableArray`1<DocumentId> documentIds);
    private Solution RemoveAnalyzerConfigDocumentsImpl(ImmutableArray`1<DocumentId> documentIds);
    public Solution WithDocumentName(DocumentId documentId, string name);
    public Solution WithDocumentFolders(DocumentId documentId, IEnumerable`1<string> folders);
    public Solution WithDocumentFilePath(DocumentId documentId, string filePath);
    public Solution WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithAnalyzerConfigDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public Solution WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithAnalyzerConfigDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public Solution WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode);
    public Solution WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public Solution WithDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    internal Solution UpdateDocumentTextLoader(DocumentId documentId, TextLoader loader, SourceText text, PreservationMode mode);
    public Solution WithAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    public Solution WithAnalyzerConfigDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    internal Solution WithFrozenPartialCompilationIncludingSpecificDocument(DocumentId documentId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Solution/<WithMergedLinkedFileChangesAsync>d__119")]
internal Task`1<Solution> WithMergedLinkedFileChangesAsync(Solution oldSolution, Nullable`1<SolutionChanges> solutionChanges, IMergeConflictHandler mergeConflictHandler, CancellationToken cancellationToken);
    internal ImmutableArray`1<DocumentId> GetRelatedDocumentIds(DocumentId documentId);
    internal Solution WithNewWorkspace(Workspace workspace, int workspaceVersion);
    [ObsoleteAttribute("This method no longer produces a Solution that does not share state and is no longer necessary to call.", "False")]
[EditorBrowsableAttribute("1")]
public Solution GetIsolatedSolution();
    public Solution WithDocumentText(IEnumerable`1<DocumentId> documentIds, SourceText text, PreservationMode mode);
    internal Document WithFrozenSourceGeneratedDocument(SourceGeneratedDocumentIdentity documentIdentity, SourceText text);
    internal Solution WithoutFrozenSourceGeneratedDocuments();
    internal Solution WithCachedSourceGeneratorState(ProjectId projectToUpdate, Project projectWithCachedGeneratorState);
    public SolutionChanges GetChanges(Solution oldSolution);
    [NullableContextAttribute("2")]
public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    public OptionSet get_Options();
    public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    public Solution WithOptions(OptionSet options);
    internal Solution WithOptions(SolutionOptionSet options);
    private void CheckContainsProject(ProjectId projectId);
    private void CheckContainsDocument(DocumentId documentId);
    private void CheckContainsDocuments(ImmutableArray`1<DocumentId> documentIds);
    private void CheckContainsAdditionalDocument(DocumentId documentId);
    private void CheckContainsAdditionalDocuments(ImmutableArray`1<DocumentId> documentIds);
    private void CheckContainsAnalyzerConfigDocument(DocumentId documentId);
    private void CheckContainsAnalyzerConfigDocuments(ImmutableArray`1<DocumentId> documentIds);
    private void CheckCircularProjectReferences(ProjectId projectId, IReadOnlyCollection`1<ProjectReference> projectReferences);
    private void CheckSubmissionProjectReferences(ProjectId projectId, IEnumerable`1<ProjectReference> projectReferences, bool ignoreExistingReferences);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private Project <get_Projects>b__26_0(ProjectId id);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <CheckSubmissionProjectReferences>b__144_0(ProjectReference p);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.SolutionChanges : ValueType {
    private Solution _newSolution;
    private Solution _oldSolution;
    internal SolutionChanges(Solution newSolution, Solution oldSolution);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetAddedProjects>d__3")]
public IEnumerable`1<Project> GetAddedProjects();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetProjectChanges>d__4")]
public IEnumerable`1<ProjectChanges> GetProjectChanges();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetRemovedProjects>d__5")]
public IEnumerable`1<Project> GetRemovedProjects();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetAddedAnalyzerReferences>d__6")]
public IEnumerable`1<AnalyzerReference> GetAddedAnalyzerReferences();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.SolutionChanges/<GetRemovedAnalyzerReferences>d__7")]
public IEnumerable`1<AnalyzerReference> GetRemovedAnalyzerReferences();
}
internal enum Microsoft.CodeAnalysis.SolutionCrawler.BackgroundAnalysisScope : Enum {
    public int value__;
    public static BackgroundAnalysisScope ActiveFile;
    public static BackgroundAnalysisScope OpenFiles;
    public static BackgroundAnalysisScope FullSolution;
    public static BackgroundAnalysisScope None;
    public static BackgroundAnalysisScope Minimal;
    public static BackgroundAnalysisScope Default;
}
internal enum Microsoft.CodeAnalysis.SolutionCrawler.CompilerDiagnosticsScope : Enum {
    public int value__;
    public static CompilerDiagnosticsScope None;
    public static CompilerDiagnosticsScope VisibleFilesAndFilesWithPreviouslyReportedDiagnostics;
    public static CompilerDiagnosticsScope OpenFiles;
    public static CompilerDiagnosticsScope FullSolution;
}
[MetadataAttributeAttribute]
[AttributeUsageAttribute("4")]
internal class Microsoft.CodeAnalysis.SolutionCrawler.ExportIncrementalAnalyzerProviderAttribute : ExportAttribute {
    [CompilerGeneratedAttribute]
private bool <HighPriorityForActiveFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <WorkspaceKinds>k__BackingField;
    public bool HighPriorityForActiveFile { get; }
    public string Name { get; }
    public String[] WorkspaceKinds { get; }
    public ExportIncrementalAnalyzerProviderAttribute(string name, String[] workspaceKinds);
    public ExportIncrementalAnalyzerProviderAttribute(bool highPriorityForActiveFile, string name, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public bool get_HighPriorityForActiveFile();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public String[] get_WorkspaceKinds();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzer {
    public int Priority { get; }
    public abstract virtual Task NewSolutionSnapshotAsync(Solution solution, CancellationToken cancellationToken);
    public abstract virtual Task DocumentOpenAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentCloseAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task ActiveDocumentSwitchedAsync(TextDocument document, CancellationToken cancellationToken);
    public abstract virtual Task DocumentResetAsync(Document document, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeSyntaxAsync(Document document, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeDocumentAsync(Document document, SyntaxNode bodyOpt, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeProjectAsync(Project project, bool semanticsChanged, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual Task RemoveDocumentAsync(DocumentId documentId, CancellationToken cancellationToken);
    public abstract virtual Task RemoveProjectAsync(ProjectId projectId, CancellationToken cancellationToken);
    public abstract virtual Task NonSourceDocumentOpenAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public abstract virtual Task NonSourceDocumentCloseAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public abstract virtual Task NonSourceDocumentResetAsync(TextDocument textDocument, CancellationToken cancellationToken);
    public abstract virtual Task AnalyzeNonSourceDocumentAsync(TextDocument textDocument, InvocationReasons reasons, CancellationToken cancellationToken);
    public abstract virtual void LogAnalyzerCountSummary();
    public abstract virtual int get_Priority();
    public abstract virtual void Shutdown();
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SolutionCrawler.IIncrementalAnalyzerProvider {
    public abstract virtual IIncrementalAnalyzer CreateIncrementalAnalyzer(Workspace workspace);
}
internal class Microsoft.CodeAnalysis.SolutionCrawler.IncrementalAnalyzerProviderMetadata : WorkspaceKindMetadata {
    [CompilerGeneratedAttribute]
private bool <HighPriorityForActiveFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool HighPriorityForActiveFile { get; }
    public string Name { get; }
    public IncrementalAnalyzerProviderMetadata(IDictionary`2<string, object> data);
    public IncrementalAnalyzerProviderMetadata(string name, bool highPriorityForActiveFile, String[] workspaceKinds);
    [CompilerGeneratedAttribute]
public bool get_HighPriorityForActiveFile();
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.InvocationReasons : ValueType {
    public static InvocationReasons Empty;
    private ImmutableHashSet`1<string> _reasons;
    public static InvocationReasons DocumentAdded;
    public static InvocationReasons DocumentRemoved;
    public static InvocationReasons ProjectParseOptionChanged;
    public static InvocationReasons ProjectConfigurationChanged;
    public static InvocationReasons SolutionRemoved;
    public static InvocationReasons DocumentOpened;
    public static InvocationReasons DocumentClosed;
    public static InvocationReasons DocumentChanged;
    public static InvocationReasons AdditionalDocumentChanged;
    public static InvocationReasons SyntaxChanged;
    public static InvocationReasons SemanticChanged;
    public static InvocationReasons Reanalyze;
    public static InvocationReasons ReanalyzeHighPriority;
    public static InvocationReasons ActiveDocumentSwitched;
    public bool IsEmpty { get; }
    public InvocationReasons(string reason);
    private InvocationReasons(ImmutableHashSet`1<string> reasons);
    private static InvocationReasons();
    public bool Contains(string reason);
    public InvocationReasons With(InvocationReasons invocationReasons);
    public InvocationReasons With(string reason);
    public bool get_IsEmpty();
    public Enumerator<string> GetEnumerator();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
internal interface Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService {
    public abstract virtual void Register(Workspace workspace);
    public abstract virtual void Unregister(Workspace workspace, bool blockingShutdown);
    public abstract virtual void AddAnalyzerProvider(IIncrementalAnalyzerProvider provider, IncrementalAnalyzerProviderMetadata metadata);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SolutionCrawler.ISolutionCrawlerRegistrationService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SolutionCrawler.NullSolutionCrawlerRegistrationService : object {
    public sealed virtual void Register(Workspace workspace);
    public sealed virtual void Unregister(Workspace workspace, bool blockingShutdown);
    public sealed virtual void AddAnalyzerProvider(IIncrementalAnalyzerProvider provider, IncrementalAnalyzerProviderMetadata metadata);
}
internal static class Microsoft.CodeAnalysis.SolutionCrawler.PredefinedInvocationReasons : object {
    public static string SolutionRemoved;
    public static string ProjectParseOptionsChanged;
    public static string ProjectConfigurationChanged;
    public static string DocumentAdded;
    public static string DocumentRemoved;
    public static string DocumentOpened;
    public static string DocumentClosed;
    public static string HighPriority;
    public static string SyntaxChanged;
    public static string SemanticChanged;
    public static string Reanalyze;
    public static string ActiveDocumentSwitched;
}
internal static class Microsoft.CodeAnalysis.SolutionCrawler.WellKnownSolutionCrawlerAnalyzers : object {
    public static string Diagnostic;
}
[DebuggerDisplayAttribute("{GetDebuggerDisplay(),nq}")]
[DataContractAttribute]
public class Microsoft.CodeAnalysis.SolutionId : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [DataMemberAttribute]
private string _debugName;
    [DataMemberAttribute]
public Guid Id { get; }
    internal string DebugName { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private SolutionId(Guid id, string debugName);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    public static SolutionId CreateNewId(string debugName);
    public static SolutionId CreateFromSerialized(Guid id, string debugName);
    internal string get_DebugName();
    private string GetDebuggerDisplay();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SolutionId other);
    public static bool op_Equality(SolutionId left, SolutionId right);
    public static bool op_Inequality(SolutionId left, SolutionId right);
    public virtual int GetHashCode();
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    internal static SolutionId ReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.SolutionInfo : object {
    [CompilerGeneratedAttribute]
private SolutionAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectInfo> <Projects>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    internal SolutionAttributes Attributes { get; }
    public SolutionId Id { get; }
    public VersionStamp Version { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public IReadOnlyList`1<ProjectInfo> Projects { get; }
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences { get; }
    private SolutionInfo(SolutionAttributes attributes, IReadOnlyList`1<ProjectInfo> projects, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    [CompilerGeneratedAttribute]
internal SolutionAttributes get_Attributes();
    public SolutionId get_Id();
    public VersionStamp get_Version();
    [NullableContextAttribute("2")]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectInfo> get_Projects();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<AnalyzerReference> get_AnalyzerReferences();
    [EditorBrowsableAttribute("1")]
public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath, IEnumerable`1<ProjectInfo> projects);
    public static SolutionInfo Create(SolutionId id, VersionStamp version, string filePath, IEnumerable`1<ProjectInfo> projects, IEnumerable`1<AnalyzerReference> analyzerReferences);
    internal SolutionInfo WithTelemetryId(Guid telemetryId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SolutionState : object {
    private int _workspaceVersion;
    private SolutionAttributes _solutionAttributes;
    private ImmutableDictionary`2<ProjectId, ProjectState> _projectIdToProjectStateMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> _filePathToDocumentIdsMap;
    private ProjectDependencyGraph _dependencyGraph;
    public IReadOnlyList`1<AnalyzerReference> AnalyzerReferences;
    private ImmutableDictionary`2<ProjectId, ICompilationTracker> _projectIdToTrackerMap;
    private ValueSource`1<SolutionStateChecksums> _lazyChecksums;
    private Dictionary`2<ProjectId, ValueSource`1<SolutionStateChecksums>> _lazyProjectChecksums;
    private Lazy`1<HostDiagnosticAnalyzers> _lazyAnalyzers;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConditionalWeakTable`2<ISymbol, ProjectId> _unrootedSymbolToProjectId;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Func`1<ConditionalWeakTable`2<ISymbol, ProjectId>> s_createTable;
    [NullableAttribute("2")]
private SourceGeneratedDocumentState _frozenSourceGeneratedDocumentState;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <WorkspaceKind>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PartialSemanticsEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private HostWorkspaceServices <Services>k__BackingField;
    [CompilerGeneratedAttribute]
private SolutionOptionSet <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ProjectId> <ProjectIds>k__BackingField;
    private static Func`3<ProjectId, SolutionState, CompilationTracker> s_createCompilationTrackerFunction;
    [NullableAttribute("2")]
private NonReentrantLock _stateLockBackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<SolutionState> _latestSolutionWithPartialCompilation;
    private DateTime _timeOfLatestSolutionWithPartialCompilation;
    [NullableAttribute("2")]
private DocumentId _documentIdOfLatestSolutionWithPartialCompilation;
    private static ConditionalWeakTable`2<ISymbol, ProjectId> s_assemblyOrModuleSymbolToProjectMap;
    public HostDiagnosticAnalyzers Analyzers { get; }
    public SolutionAttributes SolutionAttributes { get; }
    [NullableAttribute("2")]
public SourceGeneratedDocumentState FrozenSourceGeneratedDocumentState { get; }
    public ImmutableDictionary`2<ProjectId, ProjectState> ProjectStates { get; }
    [NullableAttribute("2")]
public string WorkspaceKind { get; }
    public bool PartialSemanticsEnabled { get; }
    public int WorkspaceVersion { get; }
    public HostWorkspaceServices Services { get; }
    public SolutionOptionSet Options { get; }
    public Workspace Workspace { get; }
    public SolutionId Id { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public VersionStamp Version { get; }
    public IReadOnlyList`1<ProjectId> ProjectIds { get; }
    private NonReentrantLock StateLock { get; }
    private SolutionState(string workspaceKind, int workspaceVersion, bool partialSemanticsEnabled, HostWorkspaceServices solutionServices, SolutionAttributes solutionAttributes, IReadOnlyList`1<ProjectId> projectIds, SolutionOptionSet options, IReadOnlyList`1<AnalyzerReference> analyzerReferences, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, ICompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> filePathToDocumentIdsMap, ProjectDependencyGraph dependencyGraph, Lazy`1<HostDiagnosticAnalyzers> lazyAnalyzers, SourceGeneratedDocumentState frozenSourceGeneratedDocument);
    public SolutionState(string workspaceKind, bool partialSemanticsEnabled, HostWorkspaceServices services, SolutionAttributes solutionAttributes, SolutionOptionSet options, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    private static SolutionState();
    public SolutionState WithNewWorkspace(Workspace workspace, int workspaceVersion);
    public HostDiagnosticAnalyzers get_Analyzers();
    public SolutionAttributes get_SolutionAttributes();
    [NullableContextAttribute("2")]
public SourceGeneratedDocumentState get_FrozenSourceGeneratedDocumentState();
    public ImmutableDictionary`2<ProjectId, ProjectState> get_ProjectStates();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_WorkspaceKind();
    [CompilerGeneratedAttribute]
public bool get_PartialSemanticsEnabled();
    public int get_WorkspaceVersion();
    [CompilerGeneratedAttribute]
public HostWorkspaceServices get_Services();
    [CompilerGeneratedAttribute]
public SolutionOptionSet get_Options();
    public Workspace get_Workspace();
    public SolutionId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ProjectId> get_ProjectIds();
    private void CheckInvariants();
    [NullableContextAttribute("2")]
private SolutionState Branch(SolutionAttributes solutionAttributes, IReadOnlyList`1<ProjectId> projectIds, SolutionOptionSet options, IReadOnlyList`1<AnalyzerReference> analyzerReferences, ImmutableDictionary`2<ProjectId, ProjectState> idToProjectStateMap, ImmutableDictionary`2<ProjectId, ICompilationTracker> projectIdToTrackerMap, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> filePathToDocumentIdsMap, ProjectDependencyGraph dependencyGraph, Optional`1<SourceGeneratedDocumentState> frozenSourceGeneratedDocument);
    private SolutionState CreatePrimarySolution(string workspaceKind, int workspaceVersion, HostWorkspaceServices services);
    public VersionStamp GetLatestProjectVersion();
    [NullableContextAttribute("2")]
public bool ContainsProject(ProjectId projectId);
    [NullableContextAttribute("2")]
public bool ContainsDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public bool ContainsAdditionalDocument(DocumentId documentId);
    [NullableContextAttribute("2")]
public bool ContainsAnalyzerConfigDocument(DocumentId documentId);
    private DocumentState GetRequiredDocumentState(DocumentId documentId);
    private AdditionalDocumentState GetRequiredAdditionalDocumentState(DocumentId documentId);
    private AnalyzerConfigDocumentState GetRequiredAnalyzerConfigDocumentState(DocumentId documentId);
    [NullableContextAttribute("2")]
internal DocumentState GetDocumentState(SyntaxTree syntaxTree, ProjectId projectId);
    public Task`1<VersionStamp> GetDependentVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetDependentSemanticVersionAsync(ProjectId projectId, CancellationToken cancellationToken);
    public Task`1<Checksum> GetDependentChecksumAsync(ProjectId projectId, CancellationToken cancellationToken);
    public ProjectState GetProjectState(ProjectId projectId);
    public ProjectState GetRequiredProjectState(ProjectId projectId);
    [NullableContextAttribute("2")]
public ProjectState GetProjectState(IAssemblySymbol assemblySymbol);
    private bool TryGetCompilationTracker(ProjectId projectId, ICompilationTracker& tracker);
    private static CompilationTracker CreateCompilationTracker(ProjectId projectId, SolutionState solution);
    private ICompilationTracker GetCompilationTracker(ProjectId projectId);
    private SolutionState AddProject(ProjectId projectId, ProjectState projectState);
    public SolutionState AddProject(ProjectInfo projectInfo);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateFilePathToDocumentIdsMapWithAddedDocuments(IEnumerable`1<TextDocumentState> documentStates);
    private static IEnumerable`1<TextDocumentState> GetDocumentStates(ProjectState projectState);
    public SolutionState RemoveProject(ProjectId projectId);
    private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateFilePathToDocumentIdsMapWithRemovedDocuments(IEnumerable`1<TextDocumentState> documentStates);
    [NullableContextAttribute("2")]
private ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> CreateFilePathToDocumentIdsMapWithFilePath(DocumentId documentId, string oldFilePath, string newFilePath);
    public SolutionState WithProjectAssemblyName(ProjectId projectId, string assemblyName);
    public SolutionState WithProjectOutputFilePath(ProjectId projectId, string outputFilePath);
    public SolutionState WithProjectOutputRefFilePath(ProjectId projectId, string outputRefFilePath);
    public SolutionState WithProjectCompilationOutputInfo(ProjectId projectId, CompilationOutputInfo& info);
    public SolutionState WithProjectDefaultNamespace(ProjectId projectId, string defaultNamespace);
    public SolutionState WithProjectName(ProjectId projectId, string name);
    public SolutionState WithProjectFilePath(ProjectId projectId, string filePath);
    public SolutionState WithProjectCompilationOptions(ProjectId projectId, CompilationOptions options);
    public SolutionState WithProjectParseOptions(ProjectId projectId, ParseOptions options);
    public SolutionState WithHasAllInformation(ProjectId projectId, bool hasAllInformation);
    public SolutionState WithRunAnalyzers(ProjectId projectId, bool runAnalyzers);
    public SolutionState AddProjectReferences(ProjectId projectId, IReadOnlyCollection`1<ProjectReference> projectReferences);
    public SolutionState RemoveProjectReference(ProjectId projectId, ProjectReference projectReference);
    public SolutionState WithProjectReferences(ProjectId projectId, IReadOnlyList`1<ProjectReference> projectReferences);
    public SolutionState WithProjectDocumentsOrder(ProjectId projectId, ImmutableList`1<DocumentId> documentIds);
    public SolutionState AddMetadataReferences(ProjectId projectId, IReadOnlyCollection`1<MetadataReference> metadataReferences);
    public SolutionState RemoveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    public SolutionState WithProjectMetadataReferences(ProjectId projectId, IReadOnlyList`1<MetadataReference> metadataReferences);
    public SolutionState AddAnalyzerReferences(ProjectId projectId, ImmutableArray`1<AnalyzerReference> analyzerReferences);
    public SolutionState RemoveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    public SolutionState WithProjectAnalyzerReferences(ProjectId projectId, IEnumerable`1<AnalyzerReference> analyzerReferences);
    public SolutionState AddDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    private SolutionState AddDocumentsToMultipleProjects(ImmutableArray`1<DocumentInfo> documentInfos, Func`3<DocumentInfo, ProjectState, T> createDocumentState, Func`3<ProjectState, ImmutableArray`1<T>, ValueTuple`2<ProjectState, CompilationAndGeneratorDriverTranslationAction>> addDocumentsToProjectState);
    public SolutionState AddAdditionalDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    public SolutionState AddAnalyzerConfigDocuments(ImmutableArray`1<DocumentInfo> documentInfos);
    public SolutionState RemoveAnalyzerConfigDocuments(ImmutableArray`1<DocumentId> documentIds);
    public SolutionState RemoveDocuments(ImmutableArray`1<DocumentId> documentIds);
    private SolutionState RemoveDocumentsFromMultipleProjects(ImmutableArray`1<DocumentId> documentIds, Func`3<ProjectState, DocumentId, T> getExistingTextDocumentState, Func`4<ProjectState, ImmutableArray`1<DocumentId>, ImmutableArray`1<T>, ValueTuple`2<ProjectState, CompilationAndGeneratorDriverTranslationAction>> removeDocumentsFromProjectState);
    public SolutionState RemoveAdditionalDocuments(ImmutableArray`1<DocumentId> documentIds);
    public SolutionState WithDocumentName(DocumentId documentId, string name);
    public SolutionState WithDocumentFolders(DocumentId documentId, IReadOnlyList`1<string> folders);
    public SolutionState WithDocumentFilePath(DocumentId documentId, string filePath);
    public SolutionState WithDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public SolutionState WithAdditionalDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public SolutionState WithAnalyzerConfigDocumentText(DocumentId documentId, SourceText text, PreservationMode mode);
    public SolutionState WithDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public SolutionState WithAdditionalDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public SolutionState WithAnalyzerConfigDocumentText(DocumentId documentId, TextAndVersion textAndVersion, PreservationMode mode);
    public SolutionState WithDocumentSyntaxRoot(DocumentId documentId, SyntaxNode root, PreservationMode mode);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<UpdateDocumentInCompilationAsync>d__119")]
private static Task`1<Compilation> UpdateDocumentInCompilationAsync(Compilation compilation, DocumentState oldDocument, DocumentState newDocument, CancellationToken cancellationToken);
    public SolutionState WithDocumentSourceCodeKind(DocumentId documentId, SourceCodeKind sourceCodeKind);
    public SolutionState UpdateDocumentTextLoader(DocumentId documentId, TextLoader loader, SourceText text, PreservationMode mode);
    public SolutionState UpdateAdditionalDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    public SolutionState UpdateAnalyzerConfigDocumentTextLoader(DocumentId documentId, TextLoader loader, PreservationMode mode);
    private SolutionState UpdateDocumentState(DocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private SolutionState UpdateAdditionalDocumentState(AdditionalDocumentState newDocument, bool textChanged, bool recalculateDependentVersions);
    private SolutionState UpdateAnalyzerConfigDocumentState(AnalyzerConfigDocumentState newDocument);
    private SolutionState ForkProject(ProjectState newProjectState, CompilationAndGeneratorDriverTranslationAction translate, ProjectDependencyGraph newDependencyGraph, ImmutableDictionary`2<string, ImmutableArray`1<DocumentId>> newFilePathToDocumentIdsMap, bool forkTracker);
    [NullableContextAttribute("2")]
public ImmutableArray`1<DocumentId> GetDocumentIdsWithFilePath(string filePath);
    private static ProjectDependencyGraph CreateDependencyGraph(IReadOnlyList`1<ProjectId> projectIds, ImmutableDictionary`2<ProjectId, ProjectState> projectStates);
    private ImmutableDictionary`2<ProjectId, ICompilationTracker> CreateCompilationTrackerMap(ProjectId changedProjectId, ProjectDependencyGraph dependencyGraph);
    public SolutionState WithOptions(SolutionOptionSet options);
    public SolutionState AddAnalyzerReferences(IReadOnlyCollection`1<AnalyzerReference> analyzerReferences);
    public SolutionState RemoveAnalyzerReference(AnalyzerReference analyzerReference);
    public SolutionState WithAnalyzerReferences(IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    private NonReentrantLock get_StateLock();
    public SolutionState WithFrozenPartialCompilationIncludingSpecificDocument(DocumentId documentId, CancellationToken cancellationToken);
    public SolutionState WithDocumentText(IEnumerable`1<DocumentId> documentIds, SourceText text, PreservationMode mode);
    public bool TryGetCompilation(ProjectId projectId, Compilation& compilation);
    private Task`1<Compilation> GetCompilationAsync(ProjectId projectId, CancellationToken cancellationToken);
    public Task`1<Compilation> GetCompilationAsync(ProjectState project, CancellationToken cancellationToken);
    public Task`1<bool> HasSuccessfullyLoadedAsync(ProjectState project, CancellationToken cancellationToken);
    public ValueTask`1<TextDocumentStates`1<SourceGeneratedDocumentState>> GetSourceGeneratedDocumentStatesAsync(ProjectState project, CancellationToken cancellationToken);
    public ValueTask`1<ImmutableArray`1<Diagnostic>> GetSourceGeneratorDiagnosticsAsync(ProjectState project, CancellationToken cancellationToken);
    public SourceGeneratedDocumentState TryGetSourceGeneratedDocumentStateForAlreadyGeneratedId(DocumentId documentId);
    public SolutionState WithFrozenSourceGeneratedDocument(SourceGeneratedDocumentIdentity documentIdentity, SourceText sourceText);
    public SolutionState WithoutFrozenSourceGeneratedDocuments();
    public SolutionState WithCachedSourceGeneratorState(ProjectId projectToUpdate, Project projectWithCachedGeneratorState);
    public Task`1<MetadataReference> GetMetadataReferenceAsync(ProjectReference projectReference, ProjectState fromProject, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetMetadataReferenceAsync>d__155")]
private Task`1<MetadataReference> GetMetadataReferenceAsync(ICompilationTracker tracker, ProjectState fromProject, ProjectReference projectReference, CancellationToken cancellationToken);
    private MetadataReference GetPartialMetadataReference(ProjectReference projectReference, ProjectState fromProject);
    public ProjectDependencyGraph GetProjectDependencyGraph();
    private void CheckNotContainsProject(ProjectId projectId);
    private void CheckContainsProject(ProjectId projectId);
    internal bool ContainsProjectReference(ProjectId projectId, ProjectReference projectReference);
    internal bool ContainsMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    internal bool ContainsAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    internal bool ContainsTransitiveReference(ProjectId fromProjectId, ProjectId toProjectId);
    internal TestAccessor GetTestAccessor();
    [NullableContextAttribute("2")]
public ProjectId GetOriginatingProjectId(ISymbol symbol);
    private ProjectId GetOriginatingProjectIdWorker(ISymbol symbol);
    private ProjectId GetProjectIdDirectly(ISymbol symbol, ConditionalWeakTable`2<ISymbol, ProjectId> unrootedSymbolToProjectId);
    [NullableContextAttribute("2")]
public bool TryGetStateChecksums(SolutionStateChecksums& stateChecksums);
    public bool TryGetStateChecksums(ProjectId projectId, SolutionStateChecksums& stateChecksums);
    public Task`1<SolutionStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetChecksumAsync>d__177")]
public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetStateChecksumsAsync>d__178")]
public Task`1<SolutionStateChecksums> GetStateChecksumsAsync(ProjectId projectId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<GetChecksumAsync>d__179")]
public Task`1<Checksum> GetChecksumAsync(ProjectId projectId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SolutionState/<ComputeChecksumsAsync>d__180")]
private Task`1<SolutionStateChecksums> ComputeChecksumsAsync(HashSet`1<ProjectId> projectsToInclude, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
private Task`1<SolutionStateChecksums> <.ctor>b__15_0(CancellationToken c);
    [CompilerGeneratedAttribute]
internal static Lazy`1<HostDiagnosticAnalyzers> <.ctor>g__CreateLazyHostDiagnosticAnalyzers|15_1(IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    [CompilerGeneratedAttribute]
private AdditionalDocumentState <AddAdditionalDocuments>b__103_0(DocumentInfo documentInfo, ProjectState project);
    [CompilerGeneratedAttribute]
private AnalyzerConfigDocumentState <AddAnalyzerConfigDocuments>b__104_0(DocumentInfo documentInfo, ProjectState project);
    [CompilerGeneratedAttribute]
internal static bool <CreateCompilationTrackerMap>g__CanReuse|130_0(ProjectId id, <>c__DisplayClass130_0& );
    [CompilerGeneratedAttribute]
private ProjectId <GetProjectIdDirectly>g__TryGetProjectId|172_0(ISymbol symbol, bool primary);
    [CompilerGeneratedAttribute]
private ValueSource`1<SolutionStateChecksums> <GetStateChecksumsAsync>g__Compute|178_0(ProjectId projectId);
    [CompilerGeneratedAttribute]
private void <GetStateChecksumsAsync>g__AddReferencedProjects|178_1(HashSet`1<ProjectId> result, ProjectId projectId);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SourceCodeKindExtensions : object {
    [ExtensionAttribute]
internal static SourceCodeKind MapSpecifiedToEffectiveKind(SourceCodeKind kind);
    [ExtensionAttribute]
internal static bool IsValid(SourceCodeKind value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.SourceGeneratedDocument : Document {
    private SourceGeneratedDocumentState State { get; }
    public string HintName { get; }
    internal SourceGeneratedDocumentIdentity Identity { get; }
    internal SourceGeneratedDocument(Project project, SourceGeneratedDocumentState state);
    private SourceGeneratedDocumentState get_State();
    public string get_HintName();
    internal SourceGeneratedDocumentIdentity get_Identity();
    internal virtual Document WithFrozenPartialSemantics(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SourceGeneratedDocumentIdentity : ValueType {
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HintName>k__BackingField;
    [CompilerGeneratedAttribute]
private SourceGeneratorIdentity <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public DocumentId DocumentId { get; public set; }
    public string HintName { get; public set; }
    public SourceGeneratorIdentity Generator { get; public set; }
    public string FilePath { get; public set; }
    public bool ShouldReuseInSerialization { get; }
    public SourceGeneratedDocumentIdentity(DocumentId DocumentId, string HintName, SourceGeneratorIdentity Generator, string FilePath);
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DocumentId(DocumentId value);
    [CompilerGeneratedAttribute]
public string get_HintName();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HintName(string value);
    [CompilerGeneratedAttribute]
public SourceGeneratorIdentity get_Generator();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Generator(SourceGeneratorIdentity value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FilePath(string value);
    public sealed virtual bool get_ShouldReuseInSerialization();
    public static SourceGeneratedDocumentIdentity Generate(ProjectId projectId, string hintName, ISourceGenerator generator, string filePath);
    public sealed virtual void WriteTo(ObjectWriter writer);
    internal static SourceGeneratedDocumentIdentity ReadFrom(ObjectReader reader);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SourceGeneratedDocumentIdentity left, SourceGeneratedDocumentIdentity right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SourceGeneratedDocumentIdentity left, SourceGeneratedDocumentIdentity right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceGeneratedDocumentIdentity other);
    [CompilerGeneratedAttribute]
public void Deconstruct(DocumentId& DocumentId, String& HintName, SourceGeneratorIdentity& Generator, String& FilePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SourceGeneratedDocumentState : DocumentState {
    [CompilerGeneratedAttribute]
private SourceGeneratedDocumentIdentity <Identity>k__BackingField;
    public SourceGeneratedDocumentIdentity Identity { get; }
    public string HintName { get; }
    public ParseOptions ParseOptions { get; }
    private SourceGeneratedDocumentState(SourceGeneratedDocumentIdentity documentIdentity, HostLanguageServices languageServices, HostWorkspaceServices solutionServices, IDocumentServiceProvider documentServiceProvider, DocumentAttributes attributes, ParseOptions options, ValueSource`1<TextAndVersion> textSource, ValueSource`1<TreeAndVersion> treeSource);
    [CompilerGeneratedAttribute]
public SourceGeneratedDocumentIdentity get_Identity();
    public string get_HintName();
    public static SourceGeneratedDocumentState Create(SourceGeneratedDocumentIdentity documentIdentity, SourceText generatedSourceText, ParseOptions parseOptions, HostLanguageServices languageServices, HostWorkspaceServices solutionServices);
    public ParseOptions get_ParseOptions();
    protected virtual TextDocumentState UpdateText(ValueSource`1<TextAndVersion> newTextSource, PreservationMode mode, bool incremental);
    public SourceGeneratedDocumentState WithUpdatedGeneratedContent(SourceText sourceText, ParseOptions parseOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SourceGeneratorIdentity : ValueType {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    public string AssemblyName { get; public set; }
    public Version AssemblyVersion { get; public set; }
    public string TypeName { get; public set; }
    public SourceGeneratorIdentity(string AssemblyName, Version AssemblyVersion, string TypeName);
    public SourceGeneratorIdentity(ISourceGenerator generator);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public void set_AssemblyName(string value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Version get_AssemblyVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyVersion(Version value);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public void set_TypeName(string value);
    public static string GetGeneratorAssemblyName(ISourceGenerator generator);
    public static string GetGeneratorTypeName(ISourceGenerator generator);
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SourceGeneratorIdentity left, SourceGeneratorIdentity right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SourceGeneratorIdentity left, SourceGeneratorIdentity right);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [IsReadOnlyAttribute]
[NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SourceGeneratorIdentity other);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public void Deconstruct(String& AssemblyName, Version& AssemblyVersion, String& TypeName);
}
internal interface Microsoft.CodeAnalysis.SourceGeneratorTelemetry.ISourceGeneratorTelemetryCollectorWorkspaceService {
    [NullableContextAttribute("1")]
public abstract virtual void CollectRunResult(GeneratorDriverRunResult driverRunResult, GeneratorDriverTimingInfo driverTimingInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SourceGeneratorTelemetry.SourceGeneratorTelemetryCollectorWorkspaceService : object {
    private ConditionalWeakTable`2<ISourceGenerator, GeneratorTelemetryKey> _generatorTelemetryKeys;
    private StatisticLogAggregator`1<GeneratorTelemetryKey> _elapsedTimeByGenerator;
    private StatisticLogAggregator`1<GeneratorTelemetryKey> _producedFilesByGenerator;
    private GeneratorTelemetryKey GetTelemetryKey(ISourceGenerator generator);
    public sealed virtual void CollectRunResult(GeneratorDriverRunResult driverRunResult, GeneratorDriverTimingInfo driverTimingInfo);
    public void ReportStatisticsAndClear(FunctionId functionId);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SpecialTypeExtensions : object {
    [ExtensionAttribute]
public static bool IsClrInteger(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsBlittable(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValueType(SpecialType specialType);
    [ExtensionAttribute]
public static int SizeInBytes(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsPrimitiveRecursiveStruct(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsValidEnumUnderlyingType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsNumericType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsUnsignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static bool IsSignedIntegralType(SpecialType specialType);
    [ExtensionAttribute]
public static int VBForToShiftBits(SpecialType specialType);
    [NullableContextAttribute("1")]
public static SpecialType FromRuntimeTypeOfLiteralValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SQLite.Interop.NativeMethods : object {
    public static SafeSqliteHandle sqlite3_open_v2(string filename, int flags, string vfs, Result& result);
    public static SafeSqliteStatementHandle sqlite3_prepare_v2(SafeSqliteHandle db, string sql, Result& result);
    public static SafeSqliteBlobHandle sqlite3_blob_open(SafeSqliteHandle db, utf8z sdb, utf8z table, utf8z col, long rowid, int flags, Result& result);
    public static string sqlite3_errmsg(SafeSqliteHandle db);
    public static string sqlite3_errstr(int rc);
    public static int sqlite3_extended_errcode(SafeSqliteHandle db);
    public static Result sqlite3_busy_timeout(SafeSqliteHandle db, int ms);
    public static long sqlite3_last_insert_rowid(SafeSqliteHandle db);
    public static int sqlite3_blob_bytes(SafeSqliteBlobHandle blob);
    [NullableContextAttribute("0")]
public static Result sqlite3_blob_read(SafeSqliteBlobHandle blob, Span`1<byte> bytes, int offset);
    public static Result sqlite3_reset(SafeSqliteStatementHandle stmt);
    public static Result sqlite3_step(SafeSqliteStatementHandle stmt);
    public static Result sqlite3_bind_text(SafeSqliteStatementHandle stmt, int index, string val);
    [NullableContextAttribute("0")]
public static Result sqlite3_bind_text(SafeSqliteStatementHandle stmt, int index, ReadOnlySpan`1<byte> val);
    public static Result sqlite3_bind_int64(SafeSqliteStatementHandle stmt, int index, long val);
    [NullableContextAttribute("0")]
public static Result sqlite3_bind_blob(SafeSqliteStatementHandle stmt, int index, ReadOnlySpan`1<byte> bytes);
    public static int sqlite3_column_int(SafeSqliteStatementHandle stmt, int index);
    public static long sqlite3_column_int64(SafeSqliteStatementHandle stmt, int index);
    public static string sqlite3_column_text(SafeSqliteStatementHandle stmt, int index);
    public static int sqlite3_clear_bindings(SafeSqliteStatementHandle stmt);
}
internal enum Microsoft.CodeAnalysis.SQLite.Interop.OpenFlags : Enum {
    public int value__;
    public static OpenFlags SQLITE_OPEN_READWRITE;
    public static OpenFlags SQLITE_OPEN_CREATE;
    public static OpenFlags SQLITE_OPEN_URI;
    public static OpenFlags SQLITE_OPEN_NOMUTEX;
    public static OpenFlags SQLITE_OPEN_SHAREDCACHE;
}
internal enum Microsoft.CodeAnalysis.SQLite.Interop.Result : Enum {
    public int value__;
    public static Result OK;
    public static Result ERROR;
    public static Result BUSY;
    public static Result LOCKED;
    public static Result NOMEM;
    public static Result IOERR;
    public static Result FULL;
    public static Result CONSTRAINT;
    public static Result ROW;
    public static Result DONE;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.Interop.SafeSqliteBlobHandle : SafeHandle {
    [NullableAttribute("2")]
private sqlite3_blob _wrapper;
    private SafeHandleLease _lease;
    private SafeHandleLease _sqliteLease;
    public bool IsInvalid { get; }
    public SafeSqliteBlobHandle(SafeSqliteHandle sqliteHandle, sqlite3_blob wrapper);
    public virtual bool get_IsInvalid();
    public sqlite3_blob DangerousGetWrapper();
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.Interop.SafeSqliteHandle : SafeHandle {
    private sqlite3 _wrapper;
    private SafeHandleLease _lease;
    public bool IsInvalid { get; }
    public SafeSqliteHandle(sqlite3 wrapper);
    public virtual bool get_IsInvalid();
    [NullableContextAttribute("1")]
public sqlite3 DangerousGetWrapper();
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.Interop.SafeSqliteStatementHandle : SafeHandle {
    [NullableAttribute("2")]
private sqlite3_stmt _wrapper;
    private SafeHandleLease _lease;
    private SafeHandleLease _sqliteLease;
    public bool IsInvalid { get; }
    public SafeSqliteStatementHandle(SafeSqliteHandle sqliteHandle, sqlite3_stmt wrapper);
    public virtual bool get_IsInvalid();
    public sqlite3_stmt DangerousGetWrapper();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.CodeAnalysis.SQLite.Interop.SqlException : Exception {
    public Result Result;
    [NullableContextAttribute("1")]
public SqlException(Result result, string message);
}
internal enum Microsoft.CodeAnalysis.SQLite.v2.Column : Enum {
    public int value__;
    public static Column Data;
    public static Column Checksum;
}
internal enum Microsoft.CodeAnalysis.SQLite.v2.Database : Enum {
    public int value__;
    public static Database Main;
    public static Database WriteCache;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SQLite.v2.DatabaseExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static string GetName(Database database);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SQLite.v2.Interop.ResettableSqlStatement : ValueType {
    public SqlStatement Statement;
    public ResettableSqlStatement(SqlStatement statement);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlConnection : object {
    private static Byte[] s_mainNameWithTrailingZero;
    private static Byte[] s_writeCacheNameWithTrailingZero;
    private static Byte[] s_solutionTableNameWithTrailingZero;
    private static Byte[] s_projectTableNameWithTrailingZero;
    private static Byte[] s_documentTableNameWithTrailingZero;
    private static Byte[] s_checksumColumnNameWithTrailingZero;
    private static Byte[] s_dataColumnNameWithTrailingZero;
    private SafeSqliteHandle _handle;
    private Dictionary`2<string, SqlStatement> _queryToStatement;
    [CompilerGeneratedAttribute]
private bool <IsInTransaction>k__BackingField;
    public bool IsInTransaction { get; private set; }
    private SqlConnection(SafeSqliteHandle handle, Dictionary`2<string, SqlStatement> queryToStatement);
    private static SqlConnection();
    private static Byte[] GetUtf8BytesWithTrailingZero(string value);
    [CompilerGeneratedAttribute]
public bool get_IsInTransaction();
    [CompilerGeneratedAttribute]
private void set_IsInTransaction(bool value);
    public static SqlConnection Create(IPersistentStorageFaultInjector faultInjector, string databasePath);
    internal void Close_OnlyForUseBySQLiteConnectionPool();
    public void ExecuteCommand(string command, bool throwOnError);
    public ResettableSqlStatement GetResettableStatement(string query);
    public void RunInTransaction(Action`1<TState> action, TState state);
    public TResult RunInTransaction(Func`2<TState, TResult> action, TState state);
    private void Rollback(bool throwOnError);
    public int LastInsertRowId();
    public Optional`1<Stream> ReadDataBlob_MustRunInTransaction(Database database, Table table, long rowId);
    [NullableContextAttribute("0")]
public Optional`1<HashData> ReadChecksum_MustRunInTransaction(Database database, Table table, long rowId);
    private Stream ReadBlob(SafeSqliteBlobHandle blob);
    private Stream ReadBlobIntoPooledStream(SafeSqliteBlobHandle blob, int length);
    [NullableContextAttribute("2")]
public Optional`1<T> ReadBlob_MustRunInTransaction(Database database, Table table, Column column, long rowId, Func`3<SqlConnection, SafeSqliteBlobHandle, Optional`1<T>> readBlob);
    public void ThrowIfNotOk(int result);
    public void ThrowIfNotOk(Result result);
    public static void ThrowIfNotOk(SafeSqliteHandle handle, Result result);
    public void Throw(Result result);
    public static void Throw(SafeSqliteHandle handle, Result result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SQLite.v2.Interop.SqlStatement : ValueType {
    private SqlConnection _connection;
    private SafeSqliteStatementHandle _rawStatement;
    public SqlStatement(SqlConnection connection, SafeSqliteStatementHandle statement);
    internal void Close_OnlyForUseBySqlConnection();
    public void ClearBindings();
    public void Reset();
    public Result Step(bool throwOnError);
    internal void BindStringParameter(int parameterIndex, string value);
    internal void BindInt64Parameter(int parameterIndex, long value);
    [NullableContextAttribute("0")]
internal void BindBlobParameter(int parameterIndex, ReadOnlySpan`1<byte> bytes);
    internal int GetInt32At(int columnIndex);
    internal long GetInt64At(int columnIndex);
    internal string GetStringAt(int columnIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.v2.SQLiteConnectionPool : object {
    private object _connectionGate;
    private Stack`1<SqlConnection> _connectionsPool;
    private CancellationTokenSource _shutdownTokenSource;
    private SQLiteConnectionPoolService _connectionPoolService;
    [NullableAttribute("2")]
private IPersistentStorageFaultInjector _faultInjector;
    private string _databasePath;
    private IDisposable _ownershipLock;
    public SQLiteConnectionPool(SQLiteConnectionPoolService connectionPoolService, IPersistentStorageFaultInjector faultInjector, string databasePath, IDisposable ownershipLock);
    internal void Initialize(Action`2<SqlConnection, CancellationToken> initializer, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    private void CloseWorker();
    internal PooledConnection GetPooledConnection(SqlConnection& connection);
    private PooledConnection GetPooledConnection(bool checkScheduler, SqlConnection& connection);
    private SqlConnection GetConnection();
    private void ReleaseConnection(SqlConnection connection);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExportAttribute]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SQLite.v2.SQLiteConnectionPoolService : object {
    private static string LockFile;
    private object _gate;
    private Dictionary`2<string, ReferenceCountedDisposable`1<SQLiteConnectionPool>> _connectionPools;
    [CompilerGeneratedAttribute]
private ConcurrentExclusiveSchedulerPair <Scheduler>k__BackingField;
    public ConcurrentExclusiveSchedulerPair Scheduler { get; }
    [CompilerGeneratedAttribute]
public ConcurrentExclusiveSchedulerPair get_Scheduler();
    public sealed virtual void Dispose();
    public ReferenceCountedDisposable`1<SQLiteConnectionPool> TryOpenDatabase(string databaseFilePath, IPersistentStorageFaultInjector faultInjector, Action`2<SqlConnection, CancellationToken> initializer, CancellationToken cancellationToken);
    private static IDisposable TryGetDatabaseOwnership(string databaseFilePath);
    private static void EnsureDirectory(string databaseFilePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage : AbstractPersistentStorage {
    private CancellationTokenSource _shutdownTokenSource;
    private SQLiteConnectionPoolService _connectionPoolService;
    private ReferenceCountedDisposable`1<SQLiteConnectionPool> _connectionPool;
    private Action _flushInMemoryDataToDisk;
    private SolutionAccessor _solutionAccessor;
    private ProjectAccessor _projectAccessor;
    private DocumentAccessor _documentAccessor;
    private string _insert_into_string_table_values_0;
    private string _select_star_from_string_table_where_0_limit_one;
    private ConcurrentDictionary`2<DocumentId, int> _documentIdToIdMap;
    private AsyncBatchingWorkQueue _flushQueue;
    private static int FlushAllDelayMS;
    internal static long MaxPooledByteArrayLength;
    private static int MaxPooledByteArrays;
    private static Stack`1<Byte[]> s_byteArrayPool;
    private ConcurrentDictionary`2<ProjectId, int> _projectIdToIdMap;
    private ConcurrentDictionary`2<string, int> _stringToIdMap;
    private SQLitePersistentStorage(SQLiteConnectionPoolService connectionPoolService, string workingFolderPath, string solutionFilePath, string databaseFile, IAsynchronousOperationListener asyncListener, IPersistentStorageFaultInjector faultInjector);
    private static SQLitePersistentStorage();
    public static SQLitePersistentStorage TryCreate(SQLiteConnectionPoolService connectionPoolService, string workingFolderPath, string solutionFilePath, string databaseFile, IAsynchronousOperationListener asyncListener, IPersistentStorageFaultInjector faultInjector);
    public virtual void Dispose();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage/<DisposeAsync>d__13")]
public virtual ValueTask DisposeAsync();
    private static void Initialize(SqlConnection connection, CancellationToken cancellationToken);
    private bool TryGetDocumentDataId(SqlConnection connection, DocumentKey documentKey, string name, bool allowWrite, Int64& dataId);
    private Nullable`1<int> TryGetDocumentId(SqlConnection connection, DocumentKey document, bool allowWrite);
    private Nullable`1<int> TryGetDocumentIdFromDatabase(SqlConnection connection, DocumentKey document, bool allowWrite);
    protected virtual Task`1<bool> ChecksumMatchesAsync(DocumentKey documentKey, Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected virtual Task`1<Stream> ReadStreamAsync(DocumentKey documentKey, Document document, string name, Checksum checksum, CancellationToken cancellationToken);
    protected virtual Task`1<bool> WriteStreamAsync(DocumentKey documentKey, Document document, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    private void EnqueueFlushTask();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage/<FlushInMemoryDataToDiskIfNotShutdownAsync>d__25")]
private ValueTask FlushInMemoryDataToDiskIfNotShutdownAsync(CancellationToken cancellationToken);
    private Task FlushWritesOnCloseAsync();
    private void FlushInMemoryDataToDisk();
    private static string GetProjectIdString(int projectPathId, int projectNameId);
    private static string GetDocumentIdString(int projectId, int documentPathId, int documentNameId);
    private static long CombineInt32ValuesToInt64(int v1, int v2);
    private static ValueTuple`3<Byte[], int, bool> GetBytes(Stream stream);
    private static void CopyTo(Stream stream, Byte[] bytes, int length);
    internal static Byte[] GetPooledBytes();
    internal static void ReturnPooledBytes(Byte[] bytes);
    private bool TryGetProjectDataId(SqlConnection connection, ProjectKey project, string name, bool allowWrite, Int64& dataId);
    private Nullable`1<int> TryGetProjectId(SqlConnection connection, ProjectKey project, bool allowWrite);
    private Nullable`1<int> TryGetProjectIdFromDatabase(SqlConnection connection, ProjectKey project, bool allowWrite);
    protected virtual Task`1<bool> ChecksumMatchesAsync(ProjectKey projectKey, Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
protected virtual Task`1<Stream> ReadStreamAsync(ProjectKey projectKey, Project project, string name, Checksum checksum, CancellationToken cancellationToken);
    protected virtual Task`1<bool> WriteStreamAsync(ProjectKey projectKey, Project project, string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    public virtual Task`1<bool> ChecksumMatchesAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public virtual Task`1<Stream> ReadStreamAsync(string name, Checksum checksum, CancellationToken cancellationToken);
    public virtual Task`1<bool> WriteStreamAsync(string name, Stream stream, Checksum checksum, CancellationToken cancellationToken);
    private Nullable`1<int> TryGetStringId(SqlConnection connection, string value, bool allowWrite);
    private Nullable`1<int> TryGetStringIdFromDatabase(SqlConnection connection, string value, bool allowWrite);
    private int InsertStringIntoDatabase_MustRunInTransaction(SqlConnection connection, string value);
    private Nullable`1<int> TryGetStringIdFromDatabaseWorker(SqlConnection connection, string value, bool canReturnNull);
    [NullableContextAttribute("0")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorage/<PerformTaskAsync>d__56`2")]
private static Task`1<TResult> PerformTaskAsync(Func`2<TArg, TResult> func, TArg arg, TaskScheduler scheduler, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private Task`1<TResult> PerformReadAsync(Func`2<TArg, TResult> func, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public Task`1<TResult> PerformWriteAsync(Func`2<TArg, TResult> func, TArg arg, CancellationToken cancellationToken);
    public Task PerformWriteAsync(Action action, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal static void <Initialize>g__EnsureTables|14_0(SqlConnection connection, Database database);
    [CompilerGeneratedAttribute]
private void <FlushWritesOnCloseAsync>b__26_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageConstants : object {
    private static string Version;
    public static string StringInfoTableName;
    public static string SolutionDataTableName;
    public static string ProjectDataTableName;
    public static string DocumentDataTableName;
    public static string DataIdColumnName;
    public static string ChecksumColumnName;
    public static string DataColumnName;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SQLite.v2.SQLitePersistentStorageService : AbstractPersistentStorageService {
    private static string StorageExtension;
    private static string PersistentStorageFileName;
    private static Lazy`1<bool> s_initialized;
    private SQLiteConnectionPoolService _connectionPoolService;
    private IAsynchronousOperationListener _asyncListener;
    [NullableAttribute("2")]
private IPersistentStorageFaultInjector _faultInjector;
    public SQLitePersistentStorageService(SQLiteConnectionPoolService connectionPoolService, IPersistentStorageConfiguration configuration, IAsynchronousOperationListener asyncListener);
    public SQLitePersistentStorageService(SQLiteConnectionPoolService connectionPoolService, IPersistentStorageConfiguration configuration, IAsynchronousOperationListener asyncListener, IPersistentStorageFaultInjector faultInjector);
    private static SQLitePersistentStorageService();
    private static bool TryInitializeLibraries();
    private static bool TryInitializeLibrariesLazy();
    protected virtual string GetDatabaseFilePath(string workingFolderPath);
    protected virtual ValueTask`1<IChecksummedPersistentStorage> TryOpenDatabaseAsync(SolutionKey solutionKey, string workingFolderPath, string databaseFilePath, CancellationToken cancellationToken);
    protected virtual bool ShouldDeleteDatabase(Exception exception);
}
internal enum Microsoft.CodeAnalysis.SQLite.v2.Table : Enum {
    public int value__;
    public static Table Document;
    public static Table Project;
    public static Table Solution;
}
internal static class Microsoft.CodeAnalysis.StackGuard : object {
    public static int MaxUncheckedRecursionDepth;
    [DebuggerStepThroughAttribute]
public static void EnsureSufficientExecutionStack(int recursionDepth);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService : object {
    protected IPersistentStorageConfiguration Configuration;
    private SemaphoreSlim _lock;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ReferenceCountedDisposable`1<IChecksummedPersistentStorage> _currentPersistentStorage;
    [NullableAttribute("2")]
private SolutionId _currentPersistentStorageSolutionId;
    protected AbstractPersistentStorageService(IPersistentStorageConfiguration configuration);
    protected abstract virtual string GetDatabaseFilePath(string workingFolderPath);
    protected abstract virtual ValueTask`1<IChecksummedPersistentStorage> TryOpenDatabaseAsync(SolutionKey solutionKey, string workingFolderPath, string databaseFilePath, CancellationToken cancellationToken);
    protected abstract virtual bool ShouldDeleteDatabase(Exception exception);
    public sealed virtual ValueTask`1<IChecksummedPersistentStorage> GetStorageAsync(SolutionKey solutionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService/<GetStorageWorkerAsync>d__9")]
internal ValueTask`1<IChecksummedPersistentStorage> GetStorageWorkerAsync(SolutionKey solutionKey, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService/<CreatePersistentStorageAsync>d__10")]
private ValueTask`1<IChecksummedPersistentStorage> CreatePersistentStorageAsync(SolutionKey solutionKey, string workingFolderPath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.Storage.AbstractPersistentStorageService/<TryCreatePersistentStorageAsync>d__11")]
private ValueTask`1<IChecksummedPersistentStorage> TryCreatePersistentStorageAsync(SolutionKey solutionKey, string workingFolderPath, CancellationToken cancellationToken);
    private void Shutdown();
    internal TestAccessor GetTestAccessor();
}
internal interface Microsoft.CodeAnalysis.Storage.CloudCache.ICloudCacheStorageService {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Storage.DocumentKey : ValueType {
    [DataMemberAttribute]
public ProjectKey Project;
    [DataMemberAttribute]
public DocumentId Id;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string FilePath;
    [DataMemberAttribute]
public string Name;
    public DocumentKey(ProjectKey project, DocumentId id, string filePath, string name);
    public static DocumentKey ToDocumentKey(Document document);
    public static DocumentKey ToDocumentKey(ProjectKey projectKey, TextDocumentState state);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(DocumentKey other);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(DocumentKey x, DocumentKey y);
    public sealed virtual int GetHashCode(DocumentKey obj);
}
[ObsoleteAttribute("Roslyn no longer exports a mechanism to perform persistence.", "True")]
internal class Microsoft.CodeAnalysis.Storage.LegacyPersistentStorageService : object {
    [NullableContextAttribute("1")]
public sealed virtual IPersistentStorage GetStorage(Solution solution);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Storage.PersistentStorageExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static IChecksummedPersistentStorageService GetPersistentStorageService(SolutionServices services);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Storage.ProjectKey : ValueType {
    [DataMemberAttribute]
public SolutionKey Solution;
    [DataMemberAttribute]
public ProjectId Id;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string FilePath;
    [DataMemberAttribute]
public string Name;
    [DataMemberAttribute]
public Checksum ParseOptionsChecksum;
    public ProjectKey(SolutionKey solution, ProjectId id, string filePath, string name, Checksum parseOptionsChecksum);
    public static ProjectKey ToProjectKey(Project project);
    public static ProjectKey ToProjectKey(SolutionState solutionState, ProjectState projectState);
    public static ProjectKey ToProjectKey(SolutionKey solutionKey, ProjectState projectState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.Storage.SolutionKey : ValueType {
    [DataMemberAttribute]
public SolutionId Id;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string FilePath;
    public SolutionKey(SolutionId id, string filePath);
    public static SolutionKey ToSolutionKey(Solution solution);
    public static SolutionKey ToSolutionKey(SolutionState solutionState);
}
internal enum Microsoft.CodeAnalysis.Storage.StorageDatabase : Enum {
    public int value__;
    public static StorageDatabase None;
    public static StorageDatabase SQLite;
    public static StorageDatabase CloudCache;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Storage.StorageDatabaseLogger : object {
    private static string Kind;
    private static string Reason;
    private static StorageDatabaseLogger Instance;
    [NullableAttribute("2")]
private Exception _reportedException;
    [NullableAttribute("2")]
private string _reportedExceptionMessage;
    private ConcurrentDictionary`2<Type, Exception> _set;
    private static StorageDatabaseLogger();
    internal static void LogException(Exception ex);
    private void LogExceptionWorker(Exception ex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SupportedChangesServiceExtensions : object {
    [ExtensionAttribute]
public static bool CanApplyChange(Solution solution, ApplyChangesKind kind);
    [ExtensionAttribute]
public static bool CanApplyParseOptionChange(Project project, ParseOptions oldOptions, ParseOptions newOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolKey : ValueType {
    internal static int FormatVersion;
    [DataMemberAttribute]
private string _symbolKeyData;
    public SymbolKey(string data);
    [NullableContextAttribute("2")]
public static SymbolKey Create(ISymbol symbol, CancellationToken cancellationToken);
    public static IEqualityComparer`1<SymbolKey> GetComparer(bool ignoreCase, bool ignoreAssemblyKeys);
    public static bool CanCreate(ISymbol symbol, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, bool ignoreAssemblyKey, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, String& failureReason, CancellationToken cancellationToken);
    public static SymbolKeyResolution ResolveString(string symbolKey, Compilation compilation, bool ignoreAssemblyKey, String& failureReason, CancellationToken cancellationToken);
    public static string CreateString(ISymbol symbol, CancellationToken cancellationToken);
    internal static string CreateStringWorker(int version, ISymbol symbol, CancellationToken cancellationToken);
    public SymbolKeyResolution Resolve(Compilation compilation, bool ignoreAssemblyKey, CancellationToken cancellationToken);
    public virtual string ToString();
    private static SymbolKeyResolution CreateResolution(PooledArrayBuilder`1<TSymbol> symbols, string reasonIfFailed, String& failureReason);
    private static T SafeGet(ImmutableArray`1<T> values, int index);
    [NullableContextAttribute("2")]
private static bool Equals(Compilation compilation, string name1, string name2);
    [NullableContextAttribute("2")]
private static bool Equals(bool isCaseSensitive, string name1, string name2);
    [NullableContextAttribute("0")]
private static bool ParameterRefKindsMatch(ImmutableArray`1<IParameterSymbol> parameters, PooledArrayBuilder`1<RefKind> refKinds);
    [NullableContextAttribute("0")]
private static PooledArrayBuilder`1<TSymbol> GetMembersOfNamedType(SymbolKeyResolution containingTypeResolution, string metadataName);
    public static bool IsBodyLevelSymbol(ISymbol symbol);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolKey other);
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static SymbolKey GetSymbolKey(ISymbol symbol, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.SymbolKeyResolution : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<ISymbol> _candidateSymbols;
    [CompilerGeneratedAttribute]
private ISymbol <Symbol>k__BackingField;
    [CompilerGeneratedAttribute]
private CandidateReason <CandidateReason>k__BackingField;
    internal int SymbolCount { get; }
    public ISymbol Symbol { get; }
    public CandidateReason CandidateReason { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ISymbol> CandidateSymbols { get; }
    internal SymbolKeyResolution(ISymbol symbol);
    internal SymbolKeyResolution(ImmutableArray`1<ISymbol> candidateSymbols, CandidateReason candidateReason);
    internal int get_SymbolCount();
    [CompilerGeneratedAttribute]
public ISymbol get_Symbol();
    [CompilerGeneratedAttribute]
public CandidateReason get_CandidateReason();
    public ImmutableArray`1<ISymbol> get_CandidateSymbols();
    public Enumerator`1<ISymbol> GetEnumerator();
    [NullableContextAttribute("0")]
internal Enumerable`1<TSymbol> OfType();
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SymbolKeyResolutionExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static ISymbol GetAnySymbol(SymbolKeyResolution resolution);
}
[ExportWorkspaceServiceAttribute("Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService", "Default")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.DefaultSymbolSearchService : object {
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public sealed virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.IRemoteSymbolSearchUpdateService {
    public abstract virtual ValueTask UpdateContinuouslyAsync(RemoteServiceCallbackId callbackId, string sourceName, string localSettingsDirectory, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string name, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchLogService {
    public abstract virtual ValueTask LogExceptionAsync(string exception, string text, CancellationToken cancellationToken);
    public abstract virtual ValueTask LogInfoAsync(string text, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchService {
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.SymbolSearch.ISymbolSearchUpdateEngine {
    public abstract virtual ValueTask UpdateContinuouslyAsync(string sourceName, string localSettingsDirectory, ISymbolSearchLogService logService, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithTypeResult>> FindPackagesWithTypeAsync(string source, string name, int arity, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<PackageWithAssemblyResult>> FindPackagesWithAssemblyAsync(string source, string assemblyName, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<ImmutableArray`1<ReferenceAssemblyWithTypeResult>> FindReferenceAssembliesWithTypeAsync(string name, int arity, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal abstract class Microsoft.CodeAnalysis.SymbolSearch.PackageResult : object {
    [DataMemberAttribute]
public string PackageName;
    [DataMemberAttribute]
public int Rank;
    protected PackageResult(string packageName, int rank);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.PackageWithAssemblyResult : PackageResult {
    [DataMemberAttribute]
public string Version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<Func`2<PackageWithAssemblyResult, IComparable>> s_comparers;
    [NullableContextAttribute("1")]
public PackageWithAssemblyResult(string packageName, int rank, string version);
    private static PackageWithAssemblyResult();
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PackageWithAssemblyResult other);
    public sealed virtual int CompareTo(PackageWithAssemblyResult other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.PackageWithTypeResult : PackageResult {
    [DataMemberAttribute]
public string TypeName;
    [NullableAttribute("2")]
[DataMemberAttribute]
public string Version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> ContainingNamespaceNames;
    public PackageWithTypeResult(string packageName, int rank, string typeName, string version, ImmutableArray`1<string> containingNamespaceNames);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.ReferenceAssemblyWithTypeResult : object {
    [DataMemberAttribute]
public string AssemblyName;
    [DataMemberAttribute]
public string TypeName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> ContainingNamespaceNames;
    public ReferenceAssemblyWithTypeResult(string assemblyName, string typeName, ImmutableArray`1<string> containingNamespaceNames);
}
[ExportRemoteServiceCallbackDispatcherAttribute("Microsoft.CodeAnalysis.SymbolSearch.IRemoteSymbolSearchUpdateService")]
[SharedAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchCallbackDispatcher : RemoteServiceCallbackDispatcher {
    private ISymbolSearchLogService GetLogService(RemoteServiceCallbackId callbackId);
    public sealed virtual ValueTask LogExceptionAsync(RemoteServiceCallbackId callbackId, string exception, string text, CancellationToken cancellationToken);
    public sealed virtual ValueTask LogInfoAsync(RemoteServiceCallbackId callbackId, string text, CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolSearch.SymbolSearchOptions : ValueType {
    [CompilerGeneratedAttribute]
private bool <SearchReferenceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SearchNuGetPackages>k__BackingField;
    public static SymbolSearchOptions Default;
    [DataMemberAttribute]
public bool SearchReferenceAssemblies { get; public set; }
    [DataMemberAttribute]
public bool SearchNuGetPackages { get; public set; }
    private static SymbolSearchOptions();
    [CompilerGeneratedAttribute]
public bool get_SearchReferenceAssemblies();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SearchReferenceAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_SearchNuGetPackages();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SearchNuGetPackages(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(SymbolSearchOptions left, SymbolSearchOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(SymbolSearchOptions left, SymbolSearchOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(SymbolSearchOptions other);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.SymbolUsageInfo : ValueType {
    public static SymbolUsageInfo None;
    [CompilerGeneratedAttribute]
private Nullable`1<ValueUsageInfo> <ValueUsageInfoOpt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TypeOrNamespaceUsageInfo> <TypeOrNamespaceUsageInfoOpt>k__BackingField;
    [DataMemberAttribute]
public Nullable`1<ValueUsageInfo> ValueUsageInfoOpt { get; }
    [DataMemberAttribute]
public Nullable`1<TypeOrNamespaceUsageInfo> TypeOrNamespaceUsageInfoOpt { get; }
    public SymbolUsageInfo(Nullable`1<ValueUsageInfo> valueUsageInfoOpt, Nullable`1<TypeOrNamespaceUsageInfo> typeOrNamespaceUsageInfoOpt);
    private static SymbolUsageInfo();
    [CompilerGeneratedAttribute]
public Nullable`1<ValueUsageInfo> get_ValueUsageInfoOpt();
    [CompilerGeneratedAttribute]
public Nullable`1<TypeOrNamespaceUsageInfo> get_TypeOrNamespaceUsageInfoOpt();
    public static SymbolUsageInfo Create(ValueUsageInfo valueUsageInfo);
    public static SymbolUsageInfo Create(TypeOrNamespaceUsageInfo typeOrNamespaceUsageInfo);
    public bool IsReadFrom();
    public bool IsWrittenTo();
    public bool IsNameOnly();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SymbolUsageInfo other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.SyntacticDocument : object {
    public Document Document;
    public SourceText Text;
    public SyntaxNode Root;
    public Project Project { get; }
    public SyntaxTree SyntaxTree { get; }
    protected SyntacticDocument(Document document, SourceText text, SyntaxNode root);
    public Project get_Project();
    public SyntaxTree get_SyntaxTree();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.SyntacticDocument/<CreateAsync>d__8")]
public static ValueTask`1<SyntacticDocument> CreateAsync(Document document, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.SyntaxTreeExtensions : object {
    [ExtensionAttribute]
[ConditionalAttribute("DEBUG")]
internal static void VerifySource(SyntaxTree tree, IEnumerable`1<TextChangeRange> changes);
    private static int FindFirstDifference(string s1, string s2);
    [ExtensionAttribute]
public static bool IsHiddenPosition(SyntaxTree tree, int position, CancellationToken cancellationToken);
}
internal static class Microsoft.CodeAnalysis.Tags.WellKnownTagArrays : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Assembly;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ClassPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ClassProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ClassPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ClassInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ConstantPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ConstantProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ConstantPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ConstantInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> DelegatePublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> DelegateProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> DelegatePrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> DelegateInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumMemberPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumMemberProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumMemberPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EnumMemberInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EventPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EventProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EventPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> EventInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ExtensionMethodPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ExtensionMethodProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ExtensionMethodPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ExtensionMethodInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> FieldPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> FieldProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> FieldPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> FieldInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> InterfacePublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> InterfaceProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> InterfacePrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> InterfaceInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Intrinsic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Keyword;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Label;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Local;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Namespace;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> MethodPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> MethodProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> MethodPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> MethodInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ModulePublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ModuleProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ModulePrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> ModuleInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Folder;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Operator;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Parameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> PropertyPublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> PropertyProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> PropertyPrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> PropertyInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> RangeVariable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Reference;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> StructurePublic;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> StructureProtected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> StructurePrivate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> StructureInternal;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> TypeParameter;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Snippet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Error;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> Warning;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> StatusInformation;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> AddReference;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> NuGet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> TargetTypeMatch;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> CSharpFile;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> VisualBasicFile;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> CSharpProject;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<string> VisualBasicProject;
    private static WellKnownTagArrays();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Microsoft.CodeAnalysis.Tags.WellKnownTags : object {
    public static string Public;
    public static string Protected;
    public static string Private;
    public static string Internal;
    public static string File;
    public static string Project;
    public static string Folder;
    public static string Assembly;
    public static string Class;
    public static string Constant;
    public static string Delegate;
    public static string Enum;
    public static string EnumMember;
    public static string Event;
    public static string ExtensionMethod;
    public static string Field;
    public static string Interface;
    public static string Intrinsic;
    public static string Keyword;
    public static string Label;
    public static string Local;
    public static string Namespace;
    public static string Method;
    public static string Module;
    public static string Operator;
    public static string Parameter;
    public static string Property;
    public static string RangeVariable;
    public static string Reference;
    public static string Structure;
    public static string TypeParameter;
    public static string Snippet;
    public static string Error;
    public static string Warning;
    internal static string StatusInformation;
    internal static string AddReference;
    internal static string NuGet;
    internal static string TargetTypeMatch;
}
internal interface Microsoft.CodeAnalysis.TaskList.IRemoteTaskListService {
    public abstract virtual ValueTask`1<ImmutableArray`1<TaskListItem>> GetTaskListItemsAsync(Checksum solutionChecksum, DocumentId documentId, ImmutableArray`1<TaskListItemDescriptor> descriptors, CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.TaskList.ITaskListListener {
    public abstract virtual ValueTask ReportTaskListItemsAsync(DocumentId documentId, ImmutableArray`1<TaskListItem> data, CancellationToken cancellationToken);
    public abstract virtual ValueTask`1<TaskListOptions> GetOptionsAsync(CancellationToken cancellationToken);
}
internal interface Microsoft.CodeAnalysis.TaskList.ITaskListService {
    public abstract virtual Task`1<ImmutableArray`1<TaskListItem>> GetTaskListItemsAsync(Document document, ImmutableArray`1<TaskListItemDescriptor> descriptors, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.TaskList.TaskListItem : ValueType {
    [DataMemberAttribute]
public int Priority;
    [DataMemberAttribute]
public string Message;
    [DataMemberAttribute]
public DocumentId DocumentId;
    [DataMemberAttribute]
public FileLinePositionSpan Span;
    [DataMemberAttribute]
public FileLinePositionSpan MappedSpan;
    public TaskListItem(int priority, string message, DocumentId documentId, FileLinePositionSpan span, FileLinePositionSpan mappedSpan);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public sealed virtual bool Equals(TaskListItem right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.TaskList.TaskListItemDescriptor : ValueType {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Priority>k__BackingField;
    [DataMemberAttribute]
public string Text { get; }
    [DataMemberAttribute]
public int Priority { get; }
    public TaskListItemDescriptor(string text, int priority);
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public int get_Priority();
    [NullableContextAttribute("0")]
public static ImmutableArray`1<TaskListItemDescriptor> Parse(ImmutableArray`1<string> items);
}
[IsReadOnlyAttribute]
[DataContractAttribute]
internal class Microsoft.CodeAnalysis.TaskList.TaskListOptions : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_defaultDescriptors;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <Descriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ComputeForClosedFiles>k__BackingField;
    public static TaskListOptions Default;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[DataMemberAttribute]
public ImmutableArray`1<string> Descriptors { get; public set; }
    [DataMemberAttribute]
public bool ComputeForClosedFiles { get; public set; }
    private static TaskListOptions();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_Descriptors();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Descriptors(ImmutableArray`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_ComputeForClosedFiles();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ComputeForClosedFiles(bool value);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TaskListOptions left, TaskListOptions right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TaskListOptions left, TaskListOptions right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TaskListOptions other);
}
[NullableContextAttribute("1")]
internal interface Microsoft.CodeAnalysis.Telemetry.IWorkspaceTelemetryService {
    public bool HasActiveSession { get; }
    public abstract virtual bool get_HasActiveSession();
    [NullableContextAttribute("2")]
public abstract virtual string SerializeCurrentSessionSettings();
    public abstract virtual void RegisterUnexpectedExceptionLogger(TraceSource logger);
    public abstract virtual void UnregisterUnexpectedExceptionLogger(TraceSource logger);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Telemetry.TelemetryFeatureName : ValueType {
    private static string LocalKind;
    private static string RemoteKind;
    private static string ExtensionKind;
    public static TelemetryFeatureName CodeFixProvider;
    public static TelemetryFeatureName InlineRename;
    public static TelemetryFeatureName LegacySuppressionFix;
    public static TelemetryFeatureName VirtualMemoryNotification;
    private string _name;
    private string _kind;
    private TelemetryFeatureName(string name, string kind);
    private static TelemetryFeatureName();
    private static TelemetryFeatureName GetClientFeatureName(string name);
    public static TelemetryFeatureName GetRemoteFeatureName(string componentName, string serviceName);
    public static TelemetryFeatureName GetExtensionName(Type type);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Text.EncodedStringText : object {
    private static int LargeObjectHeapLimitInChars;
    private static Encoding s_utf8Encoding;
    private static Lazy`1<Encoding> s_fallbackEncoding;
    private static EncodedStringText();
    internal static Encoding CreateFallbackEncoding();
    internal static SourceText Create(Stream stream, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    internal static SourceText Create(Stream stream, Lazy`1<Encoding> getEncoding, Encoding defaultEncoding, SourceHashAlgorithm checksumAlgorithm, bool canBeEmbedded);
    private static SourceText Decode(Stream data, Encoding encoding, SourceHashAlgorithm checksumAlgorithm, bool throwIfBinaryDetected, bool canBeEmbedded);
    [NullableContextAttribute("0")]
internal static bool TryGetBytesFromStream(Stream data, ArraySegment`1& bytes);
    [NullableContextAttribute("0")]
private static bool TryGetBytesFromFileStream(FileStream stream, ArraySegment`1& bytes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Text.TextExtensions : object {
    [ExtensionAttribute]
public static ImmutableArray`1<Document> GetRelatedDocumentsWithChanges(SourceText text);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContextWithChanges(SourceText text);
    [ExtensionAttribute]
public static ImmutableArray`1<Document> GetRelatedDocuments(SourceTextContainer container);
    [ExtensionAttribute]
public static Document GetOpenDocumentInCurrentContext(SourceTextContainer container);
    [ExtensionAttribute]
internal static Document GetDocumentWithFrozenPartialSemantics(SourceText text, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.TextAndVersion : object {
    [CompilerGeneratedAttribute]
private SourceText <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Diagnostic <LoadDiagnostic>k__BackingField;
    public SourceText Text { get; }
    public VersionStamp Version { get; }
    [ObsoleteAttribute("Use Document.FilePath instead", "False")]
public string FilePath { get; }
    [NullableAttribute("2")]
internal Diagnostic LoadDiagnostic { get; }
    [NullableContextAttribute("2")]
private TextAndVersion(SourceText text, VersionStamp version, string filePath, Diagnostic loadDiagnostic);
    [CompilerGeneratedAttribute]
public SourceText get_Text();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal Diagnostic get_LoadDiagnostic();
    public static TextAndVersion Create(SourceText text, VersionStamp version, string filePath);
    internal static TextAndVersion Create(SourceText text, VersionStamp version, Diagnostic loadDiagnostic);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TextDifferenceTypes : Enum {
    public int value__;
    public static TextDifferenceTypes Line;
    public static TextDifferenceTypes Word;
    public static TextDifferenceTypes Character;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.TextDocument : object {
    [CompilerGeneratedAttribute]
private TextDocumentState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private TextDocumentKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    internal TextDocumentState State { get; }
    internal TextDocumentKind Kind { get; }
    public Project Project { get; }
    public DocumentId Id { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public string Name { get; }
    public IReadOnlyList`1<string> Folders { get; }
    internal IDocumentServiceProvider Services { get; }
    internal TextDocument(Project project, TextDocumentState state, TextDocumentKind kind);
    [CompilerGeneratedAttribute]
internal TextDocumentState get_State();
    [CompilerGeneratedAttribute]
internal TextDocumentKind get_Kind();
    [CompilerGeneratedAttribute]
public Project get_Project();
    public DocumentId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public string get_Name();
    public IReadOnlyList`1<string> get_Folders();
    internal IDocumentServiceProvider get_Services();
    [NullableContextAttribute("2")]
public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    public Task`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    internal SourceText GetTextSynchronously(CancellationToken cancellationToken);
    public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    internal VersionStamp GetTextVersionSynchronously(CancellationToken cancellationToken);
    internal Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    internal virtual bool HasInfoChanged(TextDocument otherTextDocument);
    internal bool HasTextChanged(TextDocument otherTextDocument, bool ignoreUnchangeableDocument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.TextDocumentEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private TextDocument <Document>k__BackingField;
    public TextDocument Document { get; }
    public TextDocumentEventArgs(TextDocument document);
    [CompilerGeneratedAttribute]
public TextDocument get_Document();
}
public enum Microsoft.CodeAnalysis.TextDocumentKind : Enum {
    public int value__;
    public static TextDocumentKind Document;
    public static TextDocumentKind AdditionalDocument;
    public static TextDocumentKind AnalyzerConfigDocument;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.TextDocumentState : object {
    protected HostWorkspaceServices solutionServices;
    [NullableAttribute("2")]
protected SourceText sourceText;
    [CompilerGeneratedAttribute]
private ValueSource`1<TextAndVersion> <TextAndVersionSource>k__BackingField;
    private ValueSource`1<DocumentStateChecksums> _lazyChecksums;
    [CompilerGeneratedAttribute]
private DocumentAttributes <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDocumentServiceProvider <Services>k__BackingField;
    protected ValueSource`1<TextAndVersion> TextAndVersionSource { get; }
    public DocumentAttributes Attributes { get; }
    public IDocumentServiceProvider Services { get; }
    public DocumentId Id { get; }
    [NullableAttribute("2")]
public string FilePath { get; }
    public IReadOnlyList`1<string> Folders { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public ITemporaryTextStorageInternal Storage { get; }
    protected TextDocumentState(HostWorkspaceServices solutionServices, IDocumentServiceProvider documentServiceProvider, DocumentAttributes attributes, SourceText sourceText, ValueSource`1<TextAndVersion> textAndVersionSource);
    public TextDocumentState(DocumentInfo info, HostWorkspaceServices services);
    [CompilerGeneratedAttribute]
protected ValueSource`1<TextAndVersion> get_TextAndVersionSource();
    [CompilerGeneratedAttribute]
public DocumentAttributes get_Attributes();
    [CompilerGeneratedAttribute]
public IDocumentServiceProvider get_Services();
    public DocumentId get_Id();
    [NullableContextAttribute("2")]
public string get_FilePath();
    public IReadOnlyList`1<string> get_Folders();
    public string get_Name();
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextAndVersion text);
    protected static ValueSource`1<TextAndVersion> CreateStrongText(TextLoader loader, DocumentId documentId, HostWorkspaceServices services);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextAndVersion text, SolutionServices services);
    protected static ValueSource`1<TextAndVersion> CreateRecoverableText(TextLoader loader, DocumentId documentId, HostWorkspaceServices services);
    [NullableContextAttribute("2")]
public ITemporaryTextStorageInternal get_Storage();
    [NullableContextAttribute("2")]
public bool TryGetText(SourceText& text);
    public bool TryGetTextVersion(VersionStamp& version);
    [NullableContextAttribute("2")]
public bool TryGetTextAndVersion(TextAndVersion& textAndVersion);
    public ValueTask`1<SourceText> GetTextAsync(CancellationToken cancellationToken);
    public SourceText GetTextSynchronously(CancellationToken cancellationToken);
    public VersionStamp GetTextVersionSynchronously(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTextVersionAsync>d__34")]
public Task`1<VersionStamp> GetTextVersionAsync(CancellationToken cancellationToken);
    public TextDocumentState UpdateText(TextAndVersion newTextAndVersion, PreservationMode mode);
    public TextDocumentState UpdateText(SourceText newText, PreservationMode mode);
    public TextDocumentState UpdateText(TextLoader loader, PreservationMode mode);
    protected virtual TextDocumentState UpdateText(ValueSource`1<TextAndVersion> newTextSource, PreservationMode mode, bool incremental);
    private ValueTask`1<TextAndVersion> GetTextAndVersionAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetLoadDiagnosticAsync>d__40")]
internal virtual Task`1<Diagnostic> GetLoadDiagnosticAsync(CancellationToken cancellationToken);
    private VersionStamp GetNewerVersion();
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<GetTopLevelChangeTextVersionAsync>d__42")]
public virtual Task`1<VersionStamp> GetTopLevelChangeTextVersionAsync(CancellationToken cancellationToken);
    public bool HasTextChanged(TextDocumentState oldState, bool ignoreUnchangeableDocument);
    public bool HasInfoChanged(TextDocumentState oldState);
    [NullableContextAttribute("2")]
public bool TryGetStateChecksums(DocumentStateChecksums& stateChecksums);
    public Task`1<DocumentStateChecksums> GetStateChecksumsAsync(CancellationToken cancellationToken);
    public Task`1<Checksum> GetChecksumAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentState/<ComputeChecksumsAsync>d__48")]
private Task`1<DocumentStateChecksums> ComputeChecksumsAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.TextDocumentStates`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static TextDocumentStates`1<TState> Empty;
    private ImmutableList`1<DocumentId> _ids;
    private ImmutableSortedDictionary`2<DocumentId, TState> _map;
    public int Count { get; }
    public bool IsEmpty { get; }
    public IReadOnlyList`1<DocumentId> Ids { get; }
    public ImmutableSortedDictionary`2<DocumentId, TState> States { get; }
    private TextDocumentStates`1(ImmutableList`1<DocumentId> ids, ImmutableSortedDictionary`2<DocumentId, TState> map);
    public TextDocumentStates`1(IEnumerable`1<TState> states);
    public TextDocumentStates`1(IEnumerable`1<DocumentInfo> infos, Func`2<DocumentInfo, TState> stateConstructor);
    private static TextDocumentStates`1();
    public TextDocumentStates`1<TState> WithCompilationOrder(ImmutableList`1<DocumentId> ids);
    public int get_Count();
    public bool get_IsEmpty();
    public bool Contains(DocumentId id);
    public bool TryGetState(DocumentId documentId, TState& state);
    public TState GetState(DocumentId documentId);
    public TState GetRequiredState(DocumentId documentId);
    public IReadOnlyList`1<DocumentId> get_Ids();
    public ImmutableSortedDictionary`2<DocumentId, TState> get_States();
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentStates`1/<GetStatesInCompilationOrder>d__19")]
public IEnumerable`1<TState> GetStatesInCompilationOrder();
    public ImmutableArray`1<TValue> SelectAsArray(Func`2<TState, TValue> selector);
    public ImmutableArray`1<TValue> SelectAsArray(Func`3<TState, TArg, TValue> selector, TArg arg);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentStates`1/<SelectAsArrayAsync>d__22`2")]
public ValueTask`1<ImmutableArray`1<TValue>> SelectAsArrayAsync(Func`4<TState, TArg, CancellationToken, ValueTask`1<TValue>> selector, TArg arg, CancellationToken cancellationToken);
    public TextDocumentStates`1<TState> AddRange(ImmutableArray`1<TState> states);
    public TextDocumentStates`1<TState> RemoveRange(ImmutableArray`1<DocumentId> ids);
    internal TextDocumentStates`1<TState> SetState(DocumentId id, TState state);
    public TextDocumentStates`1<TState> UpdateStates(Func`3<TState, TArg, TState> transformation, TArg arg);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentStates`1/<GetChangedStateIds>d__27")]
public IEnumerable`1<DocumentId> GetChangedStateIds(TextDocumentStates`1<TState> oldStates, bool ignoreUnchangedContent, bool ignoreUnchangeableDocuments);
    public IEnumerable`1<DocumentId> GetAddedStateIds(TextDocumentStates`1<TState> oldStates);
    public IEnumerable`1<DocumentId> GetRemovedStateIds(TextDocumentStates`1<TState> oldStates);
    [IteratorStateMachineAttribute("Microsoft.CodeAnalysis.TextDocumentStates`1/<Except>d__30")]
private static IEnumerable`1<DocumentId> Except(IEnumerable`1<DocumentId> ids, ImmutableSortedDictionary`2<DocumentId, TState> map);
    public bool HasAnyStateChanges(TextDocumentStates`1<TState> oldStates);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.TextLoader : object {
    private static double MaxDelaySecs;
    private static int MaxRetries;
    internal static TimeSpan RetryDelay;
    [NullableAttribute("2")]
internal string FilePath { get; }
    private static TextLoader();
    [NullableContextAttribute("2")]
internal virtual string get_FilePath();
    public abstract virtual Task`1<TextAndVersion> LoadTextAndVersionAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    internal virtual TextAndVersion LoadTextAndVersionSynchronously(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.CodeAnalysis.TextLoader/<LoadTextAsync>d__7")]
internal Task`1<TextAndVersion> LoadTextAsync(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    internal TextAndVersion LoadTextSynchronously(Workspace workspace, DocumentId documentId, CancellationToken cancellationToken);
    private TextAndVersion CreateFailedText(Workspace workspace, DocumentId documentId, string message);
    public static TextLoader From(TextAndVersion textAndVersion);
    public static TextLoader From(SourceTextContainer container, VersionStamp version, string filePath);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.TreeAndVersion : object {
    [CompilerGeneratedAttribute]
private SyntaxTree <Tree>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionStamp <Version>k__BackingField;
    public SyntaxTree Tree { get; }
    public VersionStamp Version { get; }
    private TreeAndVersion(SyntaxTree tree, VersionStamp version);
    [CompilerGeneratedAttribute]
public SyntaxTree get_Tree();
    [CompilerGeneratedAttribute]
public VersionStamp get_Version();
    public static TreeAndVersion Create(SyntaxTree tree, VersionStamp version);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.TrivialTemporaryStorageService : object {
    public static TrivialTemporaryStorageService Instance;
    private static TrivialTemporaryStorageService();
    public sealed virtual ITemporaryStreamStorageInternal CreateTemporaryStreamStorage();
    public sealed virtual ITemporaryTextStorageInternal CreateTemporaryTextStorage();
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.TypeOrNamespaceUsageInfo : Enum {
    public int value__;
    public static TypeOrNamespaceUsageInfo None;
    public static TypeOrNamespaceUsageInfo Qualified;
    public static TypeOrNamespaceUsageInfo TypeArgument;
    public static TypeOrNamespaceUsageInfo TypeConstraint;
    public static TypeOrNamespaceUsageInfo Base;
    public static TypeOrNamespaceUsageInfo ObjectCreation;
    public static TypeOrNamespaceUsageInfo Import;
    public static TypeOrNamespaceUsageInfo NamespaceDeclaration;
}
internal class Microsoft.CodeAnalysis.UnmergedDocumentChanges : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<TextChange> <UnmergedChanges>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectName>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public IEnumerable`1<TextChange> UnmergedChanges { get; }
    public string ProjectName { get; }
    public DocumentId DocumentId { get; }
    public UnmergedDocumentChanges(IEnumerable`1<TextChange> unmergedChanges, string projectName, DocumentId documentId);
    [CompilerGeneratedAttribute]
public IEnumerable`1<TextChange> get_UnmergedChanges();
    [CompilerGeneratedAttribute]
public string get_ProjectName();
    [CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.Utilities.IReadOnlyListExtensions : object {
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToReadOnlyList(IList`1<T> list);
    [ExtensionAttribute]
public static T Last(IReadOnlyList`1<T> list);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, int startIndex);
}
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Utilities.ParameterName : ValueType {
    public string NameBasedOnArgument;
    public string BestNameForParameter;
    public ParameterName(string nameBasedOnArgument, bool isFixed);
    public ParameterName(string nameBasedOnArgument, bool isFixed, NamingRule parameterNamingRule);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ParameterName other);
    public virtual int GetHashCode();
}
internal abstract class Microsoft.CodeAnalysis.Utilities.StringSliceComparer : object {
    [NullableAttribute("1")]
public static StringSliceComparer Ordinal;
    [NullableAttribute("1")]
public static StringSliceComparer OrdinalIgnoreCase;
    private static StringSliceComparer();
    public abstract virtual int Compare(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y);
    public abstract virtual bool Equals(ReadOnlyMemory`1<char> x, ReadOnlyMemory`1<char> y);
    public abstract virtual int GetHashCode(ReadOnlyMemory`1<char> obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Microsoft.CodeAnalysis.Utilities.WorkspacePathUtilities : object {
    public static bool TypeNameMatchesDocumentName(Document document, string typeName);
    public static bool TypeNameMatchesDocumentName(Document document, SyntaxNode typeDeclaration, ISyntaxFacts syntaxFacts);
    public static string GetTypeNameFromDocumentName(Document document);
}
[FlagsAttribute]
internal enum Microsoft.CodeAnalysis.ValueUsageInfo : Enum {
    public int value__;
    public static ValueUsageInfo None;
    public static ValueUsageInfo Read;
    public static ValueUsageInfo Write;
    public static ValueUsageInfo Reference;
    public static ValueUsageInfo Name;
    public static ValueUsageInfo ReadWrite;
    public static ValueUsageInfo ReadableReference;
    public static ValueUsageInfo WritableReference;
    public static ValueUsageInfo ReadableWritableReference;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.ValueUsageInfoExtensions : object {
    [ExtensionAttribute]
public static bool IsReadFrom(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsWrittenTo(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsNameOnly(ValueUsageInfo valueUsageInfo);
    [ExtensionAttribute]
public static bool IsReference(ValueUsageInfo valueUsageInfo);
}
[IsReadOnlyAttribute]
public class Microsoft.CodeAnalysis.VersionStamp : ValueType {
    private static int GlobalVersionMarker;
    private static int InitialGlobalVersion;
    private static int s_globalVersion;
    private DateTime _utcLastModified;
    private int _localIncrement;
    private int _globalIncrement;
    public static VersionStamp Default { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    private VersionStamp(DateTime utcLastModified);
    private VersionStamp(DateTime utcLastModified, int localIncrement);
    private VersionStamp(DateTime utcLastModified, int localIncrement, int globalIncrement);
    private static VersionStamp();
    public static VersionStamp get_Default();
    public static VersionStamp Create();
    public static VersionStamp Create(DateTime utcTimeLastModified);
    public VersionStamp GetNewerVersion(VersionStamp version);
    public VersionStamp GetNewerVersion();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(VersionStamp version);
    public static bool op_Equality(VersionStamp left, VersionStamp right);
    public static bool op_Inequality(VersionStamp left, VersionStamp right);
    internal static bool CanReusePersistedVersion(VersionStamp baseVersion, VersionStamp persistedVersion);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    [NullableContextAttribute("1")]
private sealed virtual override void Roslyn.Utilities.IObjectWritable.WriteTo(ObjectWriter writer);
    [NullableContextAttribute("1")]
internal void WriteTo(ObjectWriter writer);
    [NullableContextAttribute("1")]
internal static VersionStamp ReadFrom(ObjectReader reader);
    private static int GetGlobalVersion(VersionStamp version);
    private static int GetNextGlobalVersion();
    internal TestAccessor GetTestAccessor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.CodeAnalysis.Workspace : object {
    [NullableAttribute("2")]
private string _workspaceKind;
    private HostWorkspaceServices _services;
    private ILegacyWorkspaceOptionService _legacyOptions;
    private SemaphoreSlim _serializationLock;
    private NonReentrantLock _stateLock;
    private Solution _latestSolution;
    private TaskQueue _taskQueue;
    internal static bool TestHookStandaloneProjectsDoNotHoldReferences;
    [CompilerGeneratedAttribute]
private bool <TestHookPartialSolutionsDisabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnchangeableDocumentsWhenApplyingChanges>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Action`1<string> _testMessageLogger;
    private Dictionary`2<ProjectId, HashSet`1<DocumentId>> _projectToOpenDocumentsMap;
    private Dictionary`2<SourceTextContainer, DocumentId> _bufferToDocumentInCurrentContextMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<SourceTextContainer, OneOrMany`1<DocumentId>> _bufferToAssociatedDocumentsMap;
    private Dictionary`2<DocumentId, TextTracker> _textTrackers;
    private Dictionary`2<DocumentId, SourceTextContainer> _documentToAssociatedBufferMap;
    private Dictionary`2<DocumentId, SourceGeneratedDocumentIdentity> _openSourceGeneratedDocumentIdentities;
    [NullableAttribute("0")]
private EventMap _eventMap;
    [NullableAttribute("0")]
private static string WorkspaceChangeEventName;
    [NullableAttribute("0")]
private static string WorkspaceFailedEventName;
    [NullableAttribute("0")]
private static string DocumentOpenedEventName;
    [NullableAttribute("0")]
private static string DocumentClosedEventName;
    [NullableAttribute("0")]
private static string DocumentActiveContextChangedName;
    [NullableAttribute("0")]
private static string TextDocumentOpenedEventName;
    [NullableAttribute("0")]
private static string TextDocumentClosedEventName;
    private static ConditionalWeakTable`2<SourceTextContainer, WorkspaceRegistration> s_bufferToWorkspaceRegistrationMap;
    internal bool TestHookPartialSolutionsDisabled { get; internal set; }
    internal bool IgnoreUnchangeableDocumentsWhenApplyingChanges { get; }
    public HostWorkspaceServices Services { get; }
    protected internal bool PartialSemanticsEnabled { get; }
    [NullableAttribute("2")]
public string Kind { get; }
    public Solution CurrentSolution { get; }
    public OptionSet Options { get; public set; }
    public bool CanOpenDocuments { get; }
    internal bool CanChangeActiveContextDocument { get; }
    protected Workspace(HostServices host, string workspaceKind);
    private static Workspace();
    [CompilerGeneratedAttribute]
internal bool get_TestHookPartialSolutionsDisabled();
    [CompilerGeneratedAttribute]
internal void set_TestHookPartialSolutionsDisabled(bool value);
    [CompilerGeneratedAttribute]
internal virtual bool get_IgnoreUnchangeableDocumentsWhenApplyingChanges();
    internal void LogTestMessage(Func`2<TArg, string> messageFactory, TArg state);
    internal void SetTestLogger(Action`1<string> writeLineMessageLogger);
    public HostWorkspaceServices get_Services();
    protected internal virtual bool get_PartialSemanticsEnabled();
    [NullableContextAttribute("2")]
public string get_Kind();
    protected internal Solution CreateSolution(SolutionInfo solutionInfo);
    private Solution CreateSolution(SolutionInfo solutionInfo, SolutionOptionSet options, IReadOnlyList`1<AnalyzerReference> analyzerReferences);
    protected internal Solution CreateSolution(SolutionId id);
    public Solution get_CurrentSolution();
    protected Solution SetCurrentSolution(Solution solution);
    [NullableContextAttribute("2")]
internal bool SetCurrentSolution(Func`2<Solution, Solution> transformation, WorkspaceChangeKind kind, ProjectId projectId, DocumentId documentId);
    public OptionSet get_Options();
    [ObsoleteAttribute("Workspace options should be set by invoking 'workspace.TryApplyChanges(workspace.CurrentSolution.WithOptions(newOptionSet))'")]
public void set_Options(OptionSet value);
    internal void UpdateCurrentSolutionOnOptionsChanged();
    protected internal Task ScheduleTask(Action action, string taskName);
    protected internal Task`1<T> ScheduleTask(Func`1<T> func, string taskName);
    protected virtual void OnDocumentTextChanged(Document document);
    protected virtual void OnDocumentClosing(DocumentId documentId);
    protected void ClearSolution();
    protected virtual void ClearSolutionData();
    protected virtual void ClearProjectData(ProjectId projectId);
    protected internal virtual void ClearDocumentData(DocumentId documentId);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool finalize);
    protected internal void OnSolutionAdded(SolutionInfo solutionInfo);
    protected internal void OnSolutionReloaded(SolutionInfo reloadedSolutionInfo);
    protected internal void OnSolutionRemoved();
    protected internal void OnProjectAdded(ProjectInfo projectInfo);
    private void OnProjectAdded(ProjectInfo projectInfo, bool silent);
    private void OnProjectAdded_NoLock(ProjectInfo projectInfo, bool silent);
    protected internal virtual void OnProjectReloaded(ProjectInfo reloadedProjectInfo);
    protected internal virtual void OnProjectRemoved(ProjectId projectId);
    protected virtual void CheckProjectCanBeRemoved(ProjectId projectId);
    protected internal void OnAssemblyNameChanged(ProjectId projectId, string assemblyName);
    protected internal void OnOutputFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnOutputRefFilePathChanged(ProjectId projectId, string outputFilePath);
    protected internal void OnProjectNameChanged(ProjectId projectId, string name, string filePath);
    internal void OnDefaultNamespaceChanged(ProjectId projectId, string defaultNamespace);
    protected internal void OnCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected internal void OnParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected internal void OnProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected internal void OnMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected internal void OnAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected internal void OnAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    internal void OnSolutionAnalyzerReferenceAdded(AnalyzerReference analyzerReference);
    internal void OnSolutionAnalyzerReferenceRemoved(AnalyzerReference analyzerReference);
    internal void OnHasAllInformationChanged(ProjectId projectId, bool hasAllInformation);
    internal void OnRunAnalyzersChanged(ProjectId projectId, bool runAnalyzers);
    protected internal void OnDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnDocumentsAdded(ImmutableArray`1<DocumentInfo> documentInfos);
    protected internal void OnDocumentReloaded(DocumentInfo newDocumentInfo);
    protected internal void OnDocumentRemoved(DocumentId documentId);
    protected virtual void CheckDocumentCanBeRemoved(DocumentId documentId);
    protected internal void OnDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnAdditionalDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnAnalyzerConfigDocumentTextLoaderChanged(DocumentId documentId, TextLoader loader);
    protected internal void OnDocumentInfoChanged(DocumentId documentId, DocumentInfo newInfo);
    protected internal void OnDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnAdditionalDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    protected internal void OnAnalyzerConfigDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode);
    private void OnAnyDocumentTextChanged(DocumentId documentId, SourceText newText, PreservationMode mode, Action`1<DocumentId> checkIsInCurrentSolution, Func`3<Solution, DocumentId, ImmutableArray`1<DocumentId>> getRelatedDocuments, Func`5<Solution, DocumentId, SourceText, PreservationMode, Solution> updateSolutionWithText, WorkspaceChangeKind changeKind, bool isCodeDocument);
    protected internal void OnDocumentSourceCodeKindChanged(DocumentId documentId, SourceCodeKind sourceCodeKind);
    protected internal void OnAdditionalDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnAdditionalDocumentRemoved(DocumentId documentId);
    protected internal void OnAnalyzerConfigDocumentAdded(DocumentInfo documentInfo);
    protected internal void OnAnalyzerConfigDocumentRemoved(DocumentId documentId);
    protected void UpdateReferencesAfterAdd();
    private static Solution UpdateReferencesAfterAdd(Solution solution);
    public virtual bool CanApplyChange(ApplyChangesKind feature);
    internal virtual bool CanAddProjectReference(ProjectId referencingProject, ProjectId referencedProject);
    public virtual bool TryApplyChanges(Solution newSolution);
    internal virtual bool TryApplyChanges(Solution newSolution, IProgressTracker progressTracker);
    internal virtual void ApplyMappedFileChanges(SolutionChanges solutionChanges);
    private void CheckAllowedSolutionChanges(SolutionChanges solutionChanges);
    private void CheckAllowedProjectChanges(ProjectChanges projectChanges);
    public virtual bool CanApplyCompilationOptionChange(CompilationOptions oldOptions, CompilationOptions newOptions, Project project);
    public virtual bool CanApplyParseOptionChange(ParseOptions oldOptions, ParseOptions newOptions, Project project);
    protected virtual void ApplyProjectChanges(ProjectChanges projectChanges);
    private void ApplyChangedDocument(ProjectChanges projectChanges, DocumentId documentId);
    [ConditionalAttribute("DEBUG")]
private static void CheckNoChanges(Solution oldSolution, Solution newSolution);
    private static ProjectInfo CreateProjectInfo(Project project);
    private static DocumentInfo CreateDocumentInfoWithText(TextDocument doc);
    internal static DocumentInfo CreateDocumentInfoWithoutText(TextDocument doc);
    protected virtual void ApplyProjectAdded(ProjectInfo project);
    protected virtual void ApplyProjectRemoved(ProjectId projectId);
    protected virtual void ApplyCompilationOptionsChanged(ProjectId projectId, CompilationOptions options);
    protected virtual void ApplyParseOptionsChanged(ProjectId projectId, ParseOptions options);
    protected virtual void ApplyProjectReferenceAdded(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyProjectReferenceRemoved(ProjectId projectId, ProjectReference projectReference);
    protected virtual void ApplyMetadataReferenceAdded(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyMetadataReferenceRemoved(ProjectId projectId, MetadataReference metadataReference);
    protected virtual void ApplyAnalyzerReferenceAdded(ProjectId projectId, AnalyzerReference analyzerReference);
    protected virtual void ApplyAnalyzerReferenceRemoved(ProjectId projectId, AnalyzerReference analyzerReference);
    internal void ApplySolutionAnalyzerReferenceAdded(AnalyzerReference analyzerReference);
    internal void ApplySolutionAnalyzerReferenceRemoved(AnalyzerReference analyzerReference);
    protected virtual void ApplyDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyDocumentInfoChanged(DocumentId id, DocumentInfo info);
    protected virtual void ApplyAdditionalDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyAdditionalDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyAdditionalDocumentTextChanged(DocumentId id, SourceText text);
    protected virtual void ApplyAnalyzerConfigDocumentAdded(DocumentInfo info, SourceText text);
    protected virtual void ApplyAnalyzerConfigDocumentRemoved(DocumentId documentId);
    protected virtual void ApplyAnalyzerConfigDocumentTextChanged(DocumentId id, SourceText text);
    protected void CheckSolutionIsEmpty();
    protected void CheckProjectIsInCurrentSolution(ProjectId projectId);
    protected void CheckProjectIsNotInCurrentSolution(ProjectId projectId);
    protected void CheckProjectHasProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveProjectReference(ProjectId fromProjectId, ProjectReference projectReference);
    protected void CheckProjectDoesNotHaveTransitiveProjectReference(ProjectId fromProjectId, ProjectId toProjectId);
    protected void CheckProjectHasMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectDoesNotHaveMetadataReference(ProjectId projectId, MetadataReference metadataReference);
    protected void CheckProjectHasAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    protected void CheckProjectDoesNotHaveAnalyzerReference(ProjectId projectId, AnalyzerReference analyzerReference);
    internal static void CheckSolutionHasAnalyzerReference(Solution solution, AnalyzerReference analyzerReference);
    internal static void CheckSolutionDoesNotHaveAnalyzerReference(Solution solution, AnalyzerReference analyzerReference);
    protected void CheckDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckAnalyzerConfigDocumentIsInCurrentSolution(DocumentId documentId);
    protected void CheckDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckAdditionalDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected void CheckAnalyzerConfigDocumentIsNotInCurrentSolution(DocumentId documentId);
    protected virtual string GetProjectName(ProjectId projectId);
    protected virtual string GetDocumentName(DocumentId documentId);
    protected virtual string GetAdditionalDocumentName(DocumentId documentId);
    protected virtual string GetAnalyzerConfigDocumentName(DocumentId documentId);
    public virtual bool get_CanOpenDocuments();
    internal virtual bool get_CanChangeActiveContextDocument();
    private protected void ClearOpenDocuments();
    private void ClearOpenDocuments(ProjectId projectId);
    protected void ClearOpenDocument(DocumentId documentId);
    [ObsoleteAttribute("The isSolutionClosing parameter is now obsolete. Please call the overload without that parameter.")]
protected void ClearOpenDocument(DocumentId documentId, bool isSolutionClosing);
    public virtual void OpenDocument(DocumentId documentId, bool activate);
    public virtual void CloseDocument(DocumentId documentId);
    public virtual void OpenAdditionalDocument(DocumentId documentId, bool activate);
    public virtual void CloseAdditionalDocument(DocumentId documentId);
    public virtual void OpenAnalyzerConfigDocument(DocumentId documentId, bool activate);
    public virtual void CloseAnalyzerConfigDocument(DocumentId documentId);
    protected void CheckCanOpenDocuments();
    protected void CheckProjectDoesNotContainOpenDocuments(ProjectId projectId);
    private bool ProjectHasOpenDocuments(ProjectId projectId);
    public virtual bool IsDocumentOpen(DocumentId documentId);
    public virtual IEnumerable`1<DocumentId> GetOpenDocumentIds(ProjectId projectId);
    public virtual IEnumerable`1<DocumentId> GetRelatedDocumentIds(SourceTextContainer container);
    public virtual DocumentId GetDocumentIdInCurrentContext(SourceTextContainer container);
    private DocumentId GetDocumentIdInCurrentContext_NoLock(SourceTextContainer container);
    internal DocumentId GetDocumentIdInCurrentContext(DocumentId documentId);
    private SourceTextContainer GetOpenDocumentSourceTextContainer_NoLock(DocumentId documentId);
    internal bool TryGetOpenSourceGeneratedDocumentIdentity(DocumentId id, SourceGeneratedDocumentIdentity& documentIdentity);
    internal virtual void SetDocumentContext(DocumentId documentId);
    protected internal void OnDocumentContextUpdated(DocumentId documentId);
    protected void CheckDocumentIsClosed(DocumentId documentId);
    protected void CheckDocumentIsOpen(DocumentId documentId);
    protected internal void OnDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    internal void OnSourceGeneratedDocumentOpened(SourceTextContainer textContainer, SourceGeneratedDocument document);
    internal void OnSourceGeneratedDocumentClosed(SourceGeneratedDocument document);
    private static TextAndVersion GetProperTextAndVersion(SourceText oldText, SourceText newText, VersionStamp version, string filePath);
    private void SignupForTextChanges(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext, Action`4<Workspace, DocumentId, SourceText, PreservationMode> onChangedHandler);
    private void AddToOpenDocumentMap(DocumentId documentId);
    protected internal void OnAdditionalDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    protected internal void OnAnalyzerConfigDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext);
    private void OnAdditionalOrAnalyzerConfigDocumentOpened(DocumentId documentId, SourceTextContainer textContainer, bool isCurrentContext, WorkspaceChangeKind workspaceChangeKind, Action`1<DocumentId> checkTextDocumentIsInCurrentSolution, Func`5<Solution, DocumentId, SourceText, PreservationMode, Solution> withDocumentText, Func`5<Solution, DocumentId, TextAndVersion, PreservationMode, Solution> withDocumentTextAndVersion, Action`4<Workspace, DocumentId, SourceText, PreservationMode> onDocumentTextChanged);
    protected internal void OnDocumentClosed(DocumentId documentId, TextLoader reloader, bool updateActiveContext);
    protected internal void OnAdditionalDocumentClosed(DocumentId documentId, TextLoader reloader);
    protected internal void OnAnalyzerConfigDocumentClosed(DocumentId documentId, TextLoader reloader);
    private void OnAdditionalOrAnalyzerConfigDocumentClosed(DocumentId documentId, TextLoader reloader, WorkspaceChangeKind workspaceChangeKind, Action`1<DocumentId> checkTextDocumentIsInCurrentSolution, Func`5<Solution, DocumentId, TextLoader, PreservationMode, Solution> withTextDocumentTextLoader);
    private void UpdateCurrentContextMapping_NoLock(SourceTextContainer textContainer, DocumentId id, bool isCurrentContext);
    private DocumentId RemoveDocumentFromCurrentContextMapping_NoLock(SourceTextContainer textContainer, DocumentId closedDocumentId);
    private SourceText GetOpenDocumentText(Solution solution, DocumentId documentId);
    protected virtual Solution AdjustReloadedSolution(Solution oldSolution, Solution reloadedSolution);
    protected virtual Project AdjustReloadedProject(Project oldProject, Project reloadedProject);
    [NullableContextAttribute("0")]
public void add_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_WorkspaceChanged(EventHandler`1<WorkspaceChangeEventArgs> value);
    [NullableContextAttribute("0")]
protected Task RaiseWorkspaceChangedEventAsync(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    [NullableContextAttribute("0")]
public void add_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_WorkspaceFailed(EventHandler`1<WorkspaceDiagnosticEventArgs> value);
    [NullableContextAttribute("0")]
protected internal virtual void OnWorkspaceFailed(WorkspaceDiagnostic diagnostic);
    [NullableContextAttribute("0")]
public void add_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_DocumentOpened(EventHandler`1<DocumentEventArgs> value);
    [NullableContextAttribute("0")]
protected Task RaiseDocumentOpenedEventAsync(Document document);
    [NullableContextAttribute("0")]
public void add_TextDocumentOpened(EventHandler`1<TextDocumentEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_TextDocumentOpened(EventHandler`1<TextDocumentEventArgs> value);
    [NullableContextAttribute("0")]
protected Task RaiseTextDocumentOpenedEventAsync(TextDocument document);
    [NullableContextAttribute("0")]
private Task RaiseTextDocumentOpenedOrClosedEventAsync(TDocument document, TDocumentEventArgs args, string eventName);
    [NullableContextAttribute("0")]
public void add_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_DocumentClosed(EventHandler`1<DocumentEventArgs> value);
    [NullableContextAttribute("0")]
protected Task RaiseDocumentClosedEventAsync(Document document);
    [NullableContextAttribute("0")]
public void add_TextDocumentClosed(EventHandler`1<TextDocumentEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_TextDocumentClosed(EventHandler`1<TextDocumentEventArgs> value);
    [NullableContextAttribute("0")]
protected Task RaiseTextDocumentClosedEventAsync(TextDocument document);
    [NullableContextAttribute("0")]
public void add_DocumentActiveContextChanged(EventHandler`1<DocumentActiveContextChangedEventArgs> value);
    [NullableContextAttribute("0")]
public void remove_DocumentActiveContextChanged(EventHandler`1<DocumentActiveContextChangedEventArgs> value);
    [NullableContextAttribute("0")]
[ObsoleteAttribute("This member is obsolete. Use the RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer, DocumentId, DocumentId) overload instead.", "True")]
protected Task RaiseDocumentActiveContextChangedEventAsync(Document document);
    [NullableContextAttribute("0")]
protected Task RaiseDocumentActiveContextChangedEventAsync(SourceTextContainer sourceTextContainer, DocumentId oldActiveContextDocumentId, DocumentId newActiveContextDocumentId);
    [NullableContextAttribute("0")]
private EventHandlerSet`1<EventHandler`1<T>> GetEventHandlers(string eventName);
    public static bool TryGetWorkspace(SourceTextContainer textContainer, Workspace& workspace);
    protected void RegisterText(SourceTextContainer textContainer);
    protected void UnregisterText(SourceTextContainer textContainer);
    public static WorkspaceRegistration GetWorkspaceRegistration(SourceTextContainer textContainer);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnSolutionAdded>b__46_0(ProjectInfo p);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <OnSolutionReloaded>b__47_0(ProjectInfo pi);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.WorkspaceChangeEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceChangeKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <OldSolution>k__BackingField;
    [CompilerGeneratedAttribute]
private Solution <NewSolution>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ProjectId <ProjectId>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private DocumentId <DocumentId>k__BackingField;
    public WorkspaceChangeKind Kind { get; }
    public Solution OldSolution { get; }
    public Solution NewSolution { get; }
    [NullableAttribute("2")]
public ProjectId ProjectId { get; }
    [NullableAttribute("2")]
public DocumentId DocumentId { get; }
    public WorkspaceChangeEventArgs(WorkspaceChangeKind kind, Solution oldSolution, Solution newSolution, ProjectId projectId, DocumentId documentId);
    [CompilerGeneratedAttribute]
public WorkspaceChangeKind get_Kind();
    [CompilerGeneratedAttribute]
public Solution get_OldSolution();
    [CompilerGeneratedAttribute]
public Solution get_NewSolution();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ProjectId get_ProjectId();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public DocumentId get_DocumentId();
}
public enum Microsoft.CodeAnalysis.WorkspaceChangeKind : Enum {
    public int value__;
    public static WorkspaceChangeKind SolutionChanged;
    public static WorkspaceChangeKind SolutionAdded;
    public static WorkspaceChangeKind SolutionRemoved;
    public static WorkspaceChangeKind SolutionCleared;
    public static WorkspaceChangeKind SolutionReloaded;
    public static WorkspaceChangeKind ProjectAdded;
    public static WorkspaceChangeKind ProjectRemoved;
    public static WorkspaceChangeKind ProjectChanged;
    public static WorkspaceChangeKind ProjectReloaded;
    public static WorkspaceChangeKind DocumentAdded;
    public static WorkspaceChangeKind DocumentRemoved;
    public static WorkspaceChangeKind DocumentReloaded;
    public static WorkspaceChangeKind DocumentChanged;
    public static WorkspaceChangeKind AdditionalDocumentAdded;
    public static WorkspaceChangeKind AdditionalDocumentRemoved;
    public static WorkspaceChangeKind AdditionalDocumentReloaded;
    public static WorkspaceChangeKind AdditionalDocumentChanged;
    public static WorkspaceChangeKind DocumentInfoChanged;
    public static WorkspaceChangeKind AnalyzerConfigDocumentAdded;
    public static WorkspaceChangeKind AnalyzerConfigDocumentRemoved;
    public static WorkspaceChangeKind AnalyzerConfigDocumentReloaded;
    public static WorkspaceChangeKind AnalyzerConfigDocumentChanged;
}
[ExtensionAttribute]
internal static class Microsoft.CodeAnalysis.WorkspaceChangeKindExtensions : object {
    [ExtensionAttribute]
public static bool IsValid(WorkspaceChangeKind kind);
}
public class Microsoft.CodeAnalysis.WorkspaceDiagnostic : object {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnosticKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public WorkspaceDiagnosticKind Kind { get; }
    public string Message { get; }
    public WorkspaceDiagnostic(WorkspaceDiagnosticKind kind, string message);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnosticKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Message();
    public virtual string ToString();
}
internal class Microsoft.CodeAnalysis.WorkspaceDiagnosticDescriptors : object {
    internal static DiagnosticDescriptor ErrorReadingFileContent;
    internal static string ErrorReadingFileContentId;
    private static WorkspaceDiagnosticDescriptors();
}
public class Microsoft.CodeAnalysis.WorkspaceDiagnosticEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private WorkspaceDiagnostic <Diagnostic>k__BackingField;
    public WorkspaceDiagnostic Diagnostic { get; }
    public WorkspaceDiagnosticEventArgs(WorkspaceDiagnostic diagnostic);
    [CompilerGeneratedAttribute]
public WorkspaceDiagnostic get_Diagnostic();
}
public enum Microsoft.CodeAnalysis.WorkspaceDiagnosticKind : Enum {
    public int value__;
    public static WorkspaceDiagnosticKind Failure;
    public static WorkspaceDiagnosticKind Warning;
}
internal static class Microsoft.CodeAnalysis.WorkspaceExtensionsResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string Supplied_diagnostic_cannot_be_null { get; }
    internal static string Fix_all_0 { get; }
    internal static string Fix_all_0_in_1 { get; }
    internal static string Fix_all_0_in_containing_member_for_1 { get; }
    internal static string Fix_all_0_in_containing_type_for_1 { get; }
    internal static string Fix_all_0_in_Solution { get; }
    internal static string Fix_all_0_in_Containing_member { get; }
    internal static string Fix_all_0_in_Containing_type { get; }
    internal static string Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0 { get; }
    internal static string SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0 { get; }
    internal static string Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution { get; }
    internal static string The_solution_does_not_contain_the_specified_document { get; }
    internal static string Warning_colon_Declaration_changes_scope_and_may_change_meaning { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_Supplied_diagnostic_cannot_be_null();
    internal static string get_Fix_all_0();
    internal static string get_Fix_all_0_in_1();
    internal static string get_Fix_all_0_in_containing_member_for_1();
    internal static string get_Fix_all_0_in_containing_type_for_1();
    internal static string get_Fix_all_0_in_Solution();
    internal static string get_Fix_all_0_in_Containing_member();
    internal static string get_Fix_all_0_in_Containing_type();
    internal static string get_Compilation_is_required_to_accomplish_the_task_but_is_not_supported_by_project_0();
    internal static string get_SyntaxTree_is_required_to_accomplish_the_task_but_is_not_supported_by_document_0();
    internal static string get_Project_of_ID_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_solution();
    internal static string get_The_solution_does_not_contain_the_specified_document();
    internal static string get_Warning_colon_Declaration_changes_scope_and_may_change_meaning();
}
public static class Microsoft.CodeAnalysis.WorkspaceKind : object {
    public static string Host;
    public static string Debugger;
    public static string Interactive;
    public static string MetadataAsSource;
    public static string MiscellaneousFiles;
    public static string Preview;
    public static string MSBuild;
    internal static string Custom;
    internal static string CloudEnvironmentClientWorkspace;
    internal static string RemoteWorkspace;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.CodeAnalysis.WorkspaceRegistration : object {
    [NullableAttribute("1")]
private object _gate;
    [CompilerGeneratedAttribute]
private Workspace <Workspace>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler WorkspaceChanged;
    public Workspace Workspace { get; private set; }
    [CompilerGeneratedAttribute]
public Workspace get_Workspace();
    [CompilerGeneratedAttribute]
private void set_Workspace(Workspace value);
    [CompilerGeneratedAttribute]
public void add_WorkspaceChanged(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_WorkspaceChanged(EventHandler value);
    internal void SetWorkspaceAndRaiseEvents(Workspace workspace);
    internal void SetWorkspace(Workspace workspace);
    internal void RaiseEvents();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResult : ValueType {
    public bool FromBuild;
    public ProjectId ProjectId;
    public VersionStamp Version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableHashSet`1<DocumentId> DocumentIds;
    public bool IsEmpty;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _syntaxLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _semanticLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> _nonLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<DiagnosticData> _others;
    public bool IsAggregatedForm { get; }
    public bool IsDefault { get; }
    public ImmutableHashSet`1<DocumentId> DocumentIdsOrEmpty { get; }
    private DiagnosticAnalysisResult(ProjectId projectId, VersionStamp version, ImmutableHashSet`1<DocumentId> documentIds, bool isEmpty, bool fromBuild);
    private DiagnosticAnalysisResult(ProjectId projectId, VersionStamp version, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> syntaxLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> semanticLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> nonLocals, ImmutableArray`1<DiagnosticData> others, ImmutableHashSet`1<DocumentId> documentIds, bool fromBuild);
    public static DiagnosticAnalysisResult CreateEmpty(ProjectId projectId, VersionStamp version);
    public static DiagnosticAnalysisResult CreateInitialResult(ProjectId projectId);
    public static DiagnosticAnalysisResult CreateFromBuild(Project project, ImmutableArray`1<DiagnosticData> diagnostics, IEnumerable`1<DocumentId> initialDocuments);
    public static DiagnosticAnalysisResult Create(Project project, VersionStamp version, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> syntaxLocalMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> semanticLocalMap, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> nonLocalMap, ImmutableArray`1<DiagnosticData> others, ImmutableHashSet`1<DocumentId> documentIds);
    public static DiagnosticAnalysisResult CreateFromBuilder(DiagnosticAnalysisResultBuilder builder);
    public bool get_IsAggregatedForm();
    public bool get_IsDefault();
    public ImmutableHashSet`1<DocumentId> get_DocumentIdsOrEmpty();
    private ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> GetMap(AnalysisKind kind);
    public ImmutableArray`1<DiagnosticData> GetAllDiagnostics();
    public ImmutableArray`1<DiagnosticData> GetDocumentDiagnostics(DocumentId documentId, AnalysisKind kind);
    public ImmutableArray`1<DiagnosticData> GetOtherDiagnostics();
    public DiagnosticAnalysisResult ToAggregatedForm();
    public DiagnosticAnalysisResult UpdateAggregatedResult(VersionStamp version, DocumentId documentId, bool fromBuild);
    public DiagnosticAnalysisResult Reset();
    public DiagnosticAnalysisResult DropExceptSyntax();
    private static ImmutableHashSet`1<DocumentId> GetDocumentIds(ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> syntaxLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> semanticLocals, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> nonLocals);
    [ConditionalAttribute("DEBUG")]
private static void VerifyDocumentMap(Project project, ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> map);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultBuilder : ValueType {
    public Project Project;
    public VersionStamp Version;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<DocumentId> _lazyDocumentsWithDiagnostics;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazySyntaxLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazySemanticLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<DocumentId, List`1<DiagnosticData>> _lazyNonLocals;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<DiagnosticData> _lazyOthers;
    public ImmutableHashSet`1<DocumentId> DocumentIds { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SyntaxLocals { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> SemanticLocals { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> NonLocals { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<DiagnosticData> Others { get; }
    public DiagnosticAnalysisResultBuilder(Project project, VersionStamp version);
    public ImmutableHashSet`1<DocumentId> get_DocumentIds();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SyntaxLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_SemanticLocals();
    public ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> get_NonLocals();
    public ImmutableArray`1<DiagnosticData> get_Others();
    public void AddExternalSyntaxDiagnostics(DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    public void AddExternalSemanticDiagnostics(DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    private void AddExternalDiagnostics(Dictionary`2& lazyLocals, DocumentId documentId, IEnumerable`1<Diagnostic> diagnostics);
    private void AddDocumentDiagnostic(Dictionary`2& map, TextDocument document, Diagnostic diagnostic);
    private void AddOtherDiagnostic(DiagnosticData data);
    public void AddSyntaxDiagnostics(SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    public void AddDiagnosticTreatedAsLocalSemantic(Diagnostic diagnostic);
    public void AddSemanticDiagnostics(SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    public void AddCompilationDiagnostics(IEnumerable`1<Diagnostic> diagnostics);
    private void AddDiagnostic(Dictionary`2& lazyLocals, SyntaxTree tree, Diagnostic diagnostic);
    private void AddDiagnostics(Dictionary`2& lazyLocals, SyntaxTree tree, IEnumerable`1<Diagnostic> diagnostics);
    private static ImmutableDictionary`2<DocumentId, ImmutableArray`1<DiagnosticData>> Convert(Dictionary`2<DocumentId, List`1<DiagnosticData>> map);
}
internal static class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap : object {
    [NullableContextAttribute("1")]
public static DiagnosticAnalysisResultMap`2<TKey, TValue> Create(ImmutableDictionary`2<TKey, TValue> analysisResult, ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> telemetryInfo);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Microsoft.CodeAnalysis.Workspaces.Diagnostics.DiagnosticAnalysisResultMap`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static DiagnosticAnalysisResultMap`2<TKey, TValue> Empty;
    public ImmutableDictionary`2<TKey, TValue> AnalysisResult;
    public ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> TelemetryInfo;
    public DiagnosticAnalysisResultMap`2(ImmutableDictionary`2<TKey, TValue> analysisResult, ImmutableDictionary`2<TKey, AnalyzerTelemetryInfo> telemetryInfo);
    private static DiagnosticAnalysisResultMap`2();
}
internal static class Microsoft.CodeAnalysis.WorkspacesResources : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string An_error_occurred_while_reading_the_specified_configuration_file_colon_0 { get; }
    internal static string Symbol_0_is_not_from_source { get; }
    internal static string Documentation_comment_id_must_start_with_E_F_M_N_P_or_T { get; }
    internal static string Cycle_detected_in_extensions { get; }
    internal static string Destination_type_must_be_a_0_but_given_one_is_1 { get; }
    internal static string Destination_type_must_be_a_0_or_a_1_but_given_one_is_2 { get; }
    internal static string Destination_type_must_be_a_0_1_or_2_but_given_one_is_3 { get; }
    internal static string Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4 { get; }
    internal static string Could_not_find_location_to_generation_symbol_into { get; }
    internal static string No_location_provided_to_add_statements_to { get; }
    internal static string Destination_location_was_not_in_source { get; }
    internal static string Destination_location_was_from_a_different_tree { get; }
    internal static string Node_is_of_the_wrong_type { get; }
    internal static string Location_must_be_null_or_from_source { get; }
    internal static string Duplicate_source_file_0_in_project_1 { get; }
    internal static string Removing_projects_is_not_supported { get; }
    internal static string Adding_projects_is_not_supported { get; }
    internal static string Workspace_error { get; }
    internal static string Error_reading_content_of_source_file_0_1 { get; }
    internal static string Workspace_is_not_empty { get; }
    internal static string _0_is_not_part_of_the_workspace { get; }
    internal static string _0_is_already_part_of_the_workspace { get; }
    internal static string _0_is_not_referenced { get; }
    internal static string _0_is_already_referenced { get; }
    internal static string Adding_project_reference_from_0_to_1_will_cause_a_circular_reference { get; }
    internal static string Metadata_is_not_referenced { get; }
    internal static string Metadata_is_already_referenced { get; }
    internal static string _0_is_not_present { get; }
    internal static string _0_is_already_present { get; }
    internal static string The_specified_document_is_not_a_version_of_this_document { get; }
    internal static string The_language_0_is_not_supported { get; }
    internal static string The_solution_already_contains_the_specified_project { get; }
    internal static string The_solution_does_not_contain_the_specified_project { get; }
    internal static string The_project_already_references_the_target_project { get; }
    internal static string The_project_already_contains_the_specified_reference { get; }
    internal static string A_project_may_not_reference_itself { get; }
    internal static string The_solution_already_contains_the_specified_document { get; }
    internal static string The_solution_already_contains_the_specified_reference { get; }
    internal static string Temporary_storage_cannot_be_written_more_than_once { get; }
    internal static string _0_is_not_open { get; }
    internal static string A_language_name_cannot_be_specified_for_this_option { get; }
    internal static string A_language_name_must_be_specified_for_this_option { get; }
    internal static string File_was_externally_modified_colon_0 { get; }
    internal static string Unrecognized_language_name { get; }
    internal static string Can_t_resolve_metadata_reference_colon_0 { get; }
    internal static string Can_t_resolve_analyzer_reference_colon_0 { get; }
    internal static string Invalid_project_block_expected_after_Project { get; }
    internal static string Invalid_project_block_expected_after_project_name { get; }
    internal static string Invalid_project_block_expected_after_project_path { get; }
    internal static string Expected_0 { get; }
    internal static string _0_must_be_a_non_null_and_non_empty_string { get; }
    internal static string Expected_header_colon_0 { get; }
    internal static string Expected_end_of_file { get; }
    internal static string Expected_0_line { get; }
    internal static string This_submission_already_references_another_submission_project { get; }
    internal static string Only_submission_project_can_reference_submission_projects { get; }
    internal static string _0_still_contains_open_documents { get; }
    internal static string _0_is_still_open { get; }
    internal static string Arrays_with_more_than_one_dimension_cannot_be_serialized { get; }
    internal static string Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer { get; }
    internal static string Specified_path_must_be_absolute { get; }
    internal static string Unknown_identifier { get; }
    internal static string Cannot_generate_code_for_unsupported_operator_0 { get; }
    internal static string Invalid_number_of_parameters_for_binary_operator { get; }
    internal static string Invalid_number_of_parameters_for_unary_operator { get; }
    internal static string Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language { get; }
    internal static string Cannot_open_project_0_because_the_language_1_is_not_supported { get; }
    internal static string Invalid_project_file_path_colon_0 { get; }
    internal static string Invalid_solution_file_path_colon_0 { get; }
    internal static string Project_file_not_found_colon_0 { get; }
    internal static string Solution_file_not_found_colon_0 { get; }
    internal static string Unmerged_change_from_project_0 { get; }
    internal static string Added_colon { get; }
    internal static string After_colon { get; }
    internal static string Before_colon { get; }
    internal static string Removed_colon { get; }
    internal static string Invalid_CodePage_value_colon_0 { get; }
    internal static string Adding_additional_documents_is_not_supported { get; }
    internal static string Adding_analyzer_config_documents_is_not_supported { get; }
    internal static string Adding_analyzer_references_is_not_supported { get; }
    internal static string Adding_documents_is_not_supported { get; }
    internal static string Adding_metadata_references_is_not_supported { get; }
    internal static string Adding_project_references_is_not_supported { get; }
    internal static string Changing_additional_documents_is_not_supported { get; }
    internal static string Changing_analyzer_config_documents_is_not_supported { get; }
    internal static string Changing_documents_is_not_supported { get; }
    internal static string Changing_project_properties_is_not_supported { get; }
    internal static string Removing_additional_documents_is_not_supported { get; }
    internal static string Removing_analyzer_config_documents_is_not_supported { get; }
    internal static string Removing_analyzer_references_is_not_supported { get; }
    internal static string Removing_documents_is_not_supported { get; }
    internal static string Removing_metadata_references_is_not_supported { get; }
    internal static string Removing_project_references_is_not_supported { get; }
    internal static string Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace { get; }
    internal static string At_least_one_diagnostic_must_be_supplied { get; }
    internal static string Diagnostic_must_have_span_0 { get; }
    internal static string Cannot_deserialize_type_0 { get; }
    internal static string Cannot_serialize_type_0 { get; }
    internal static string The_type_0_is_not_understood_by_the_serialization_binder { get; }
    internal static string Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1 { get; }
    internal static string Matching_nodes_0_and_1_must_have_the_same_label { get; }
    internal static string Node_0_must_be_contained_in_the_new_tree { get; }
    internal static string Node_0_must_be_contained_in_the_old_tree { get; }
    internal static string The_member_0_is_not_declared_within_the_declaration_of_the_symbol { get; }
    internal static string The_position_is_not_within_the_symbol_s_declaration { get; }
    internal static string The_symbol_0_cannot_be_located_within_the_current_solution { get; }
    internal static string Changing_compilation_options_is_not_supported { get; }
    internal static string Changing_parse_options_is_not_supported { get; }
    internal static string The_node_is_not_part_of_the_tree { get; }
    internal static string This_workspace_does_not_support_opening_and_closing_documents { get; }
    internal static string Exceptions_colon { get; }
    internal static string _0_returned_an_uninitialized_ImmutableArray { get; }
    internal static string Failure { get; }
    internal static string Warning { get; }
    internal static string Options_did_not_come_from_specified_Solution { get; }
    internal static string Enable { get; }
    internal static string Enable_and_ignore_future_errors { get; }
    internal static string _0_encountered_an_error_and_has_been_disabled { get; }
    internal static string Show_Stack_Trace { get; }
    internal static string Stream_is_too_long { get; }
    internal static string Deserialization_reader_for_0_read_incorrect_number_of_values { get; }
    internal static string Async_Method { get; }
    internal static string Error { get; }
    internal static string None { get; }
    internal static string Suggestion { get; }
    internal static string File_0_size_of_1_exceeds_maximum_allowed_size_of_2 { get; }
    internal static string Changing_document_property_is_not_supported { get; }
    internal static string Variables_captured_colon { get; }
    internal static string Refactoring_Only { get; }
    internal static string Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories { get; }
    internal static string Core_EditorConfig_Options { get; }
    internal static string CSharp_files { get; }
    internal static string dot_NET_Coding_Conventions { get; }
    internal static string Indentation_and_spacing { get; }
    internal static string New_line_preferences { get; }
    internal static string Visual_Basic_files { get; }
    internal static string Changing_document_0_is_not_supported { get; }
    internal static string DateTimeKind_must_be_Utc { get; }
    internal static string Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access { get; }
    internal static string Document_does_not_support_syntax_trees { get; }
    internal static string _0_is_in_a_different_project { get; }
    internal static string Project_does_not_contain_specified_reference { get; }
    internal static string Solution_does_not_contain_specified_reference { get; }
    internal static string Unknown { get; }
    internal static string Cannot_apply_action_that_is_not_in_0 { get; }
    internal static string Symbols_project_could_not_be_found_in_the_provided_solution { get; }
    internal static string The_contents_of_a_SourceGeneratedDocument_may_not_be_changed { get; }
    internal static string Rename_0_to_1 { get; }
    internal static string Sync_namespace_to_folder_structure { get; }
    internal static string CodeAction__0__did_not_produce_a_changed_solution { get; }
    internal static string Predefined_conversion_from_0_to_1 { get; }
    internal static string FixAllScope_ContainingType_and_FixAllScope_ContainingMember_are_not_supported_with_this_constructor { get; }
    internal static string FixAllScope_Custom_is_not_supported_with_this_API { get; }
    internal static string Failed_to_resolve_rename_conflicts { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_An_error_occurred_while_reading_the_specified_configuration_file_colon_0();
    internal static string get_Symbol_0_is_not_from_source();
    internal static string get_Documentation_comment_id_must_start_with_E_F_M_N_P_or_T();
    internal static string get_Cycle_detected_in_extensions();
    internal static string get_Destination_type_must_be_a_0_but_given_one_is_1();
    internal static string get_Destination_type_must_be_a_0_or_a_1_but_given_one_is_2();
    internal static string get_Destination_type_must_be_a_0_1_or_2_but_given_one_is_3();
    internal static string get_Destination_type_must_be_a_0_1_2_or_3_but_given_one_is_4();
    internal static string get_Could_not_find_location_to_generation_symbol_into();
    internal static string get_No_location_provided_to_add_statements_to();
    internal static string get_Destination_location_was_not_in_source();
    internal static string get_Destination_location_was_from_a_different_tree();
    internal static string get_Node_is_of_the_wrong_type();
    internal static string get_Location_must_be_null_or_from_source();
    internal static string get_Duplicate_source_file_0_in_project_1();
    internal static string get_Removing_projects_is_not_supported();
    internal static string get_Adding_projects_is_not_supported();
    internal static string get_Workspace_error();
    internal static string get_Error_reading_content_of_source_file_0_1();
    internal static string get_Workspace_is_not_empty();
    internal static string get__0_is_not_part_of_the_workspace();
    internal static string get__0_is_already_part_of_the_workspace();
    internal static string get__0_is_not_referenced();
    internal static string get__0_is_already_referenced();
    internal static string get_Adding_project_reference_from_0_to_1_will_cause_a_circular_reference();
    internal static string get_Metadata_is_not_referenced();
    internal static string get_Metadata_is_already_referenced();
    internal static string get__0_is_not_present();
    internal static string get__0_is_already_present();
    internal static string get_The_specified_document_is_not_a_version_of_this_document();
    internal static string get_The_language_0_is_not_supported();
    internal static string get_The_solution_already_contains_the_specified_project();
    internal static string get_The_solution_does_not_contain_the_specified_project();
    internal static string get_The_project_already_references_the_target_project();
    internal static string get_The_project_already_contains_the_specified_reference();
    internal static string get_A_project_may_not_reference_itself();
    internal static string get_The_solution_already_contains_the_specified_document();
    internal static string get_The_solution_already_contains_the_specified_reference();
    internal static string get_Temporary_storage_cannot_be_written_more_than_once();
    internal static string get__0_is_not_open();
    internal static string get_A_language_name_cannot_be_specified_for_this_option();
    internal static string get_A_language_name_must_be_specified_for_this_option();
    internal static string get_File_was_externally_modified_colon_0();
    internal static string get_Unrecognized_language_name();
    internal static string get_Can_t_resolve_metadata_reference_colon_0();
    internal static string get_Can_t_resolve_analyzer_reference_colon_0();
    internal static string get_Invalid_project_block_expected_after_Project();
    internal static string get_Invalid_project_block_expected_after_project_name();
    internal static string get_Invalid_project_block_expected_after_project_path();
    internal static string get_Expected_0();
    internal static string get__0_must_be_a_non_null_and_non_empty_string();
    internal static string get_Expected_header_colon_0();
    internal static string get_Expected_end_of_file();
    internal static string get_Expected_0_line();
    internal static string get_This_submission_already_references_another_submission_project();
    internal static string get_Only_submission_project_can_reference_submission_projects();
    internal static string get__0_still_contains_open_documents();
    internal static string get__0_is_still_open();
    internal static string get_Arrays_with_more_than_one_dimension_cannot_be_serialized();
    internal static string get_Value_too_large_to_be_represented_as_a_30_bit_unsigned_integer();
    internal static string get_Specified_path_must_be_absolute();
    internal static string get_Unknown_identifier();
    internal static string get_Cannot_generate_code_for_unsupported_operator_0();
    internal static string get_Invalid_number_of_parameters_for_binary_operator();
    internal static string get_Invalid_number_of_parameters_for_unary_operator();
    internal static string get_Cannot_open_project_0_because_the_file_extension_1_is_not_associated_with_a_language();
    internal static string get_Cannot_open_project_0_because_the_language_1_is_not_supported();
    internal static string get_Invalid_project_file_path_colon_0();
    internal static string get_Invalid_solution_file_path_colon_0();
    internal static string get_Project_file_not_found_colon_0();
    internal static string get_Solution_file_not_found_colon_0();
    internal static string get_Unmerged_change_from_project_0();
    internal static string get_Added_colon();
    internal static string get_After_colon();
    internal static string get_Before_colon();
    internal static string get_Removed_colon();
    internal static string get_Invalid_CodePage_value_colon_0();
    internal static string get_Adding_additional_documents_is_not_supported();
    internal static string get_Adding_analyzer_config_documents_is_not_supported();
    internal static string get_Adding_analyzer_references_is_not_supported();
    internal static string get_Adding_documents_is_not_supported();
    internal static string get_Adding_metadata_references_is_not_supported();
    internal static string get_Adding_project_references_is_not_supported();
    internal static string get_Changing_additional_documents_is_not_supported();
    internal static string get_Changing_analyzer_config_documents_is_not_supported();
    internal static string get_Changing_documents_is_not_supported();
    internal static string get_Changing_project_properties_is_not_supported();
    internal static string get_Removing_additional_documents_is_not_supported();
    internal static string get_Removing_analyzer_config_documents_is_not_supported();
    internal static string get_Removing_analyzer_references_is_not_supported();
    internal static string get_Removing_documents_is_not_supported();
    internal static string get_Removing_metadata_references_is_not_supported();
    internal static string get_Removing_project_references_is_not_supported();
    internal static string get_Service_of_type_0_is_required_to_accomplish_the_task_but_is_not_available_from_the_workspace();
    internal static string get_At_least_one_diagnostic_must_be_supplied();
    internal static string get_Diagnostic_must_have_span_0();
    internal static string get_Cannot_deserialize_type_0();
    internal static string get_Cannot_serialize_type_0();
    internal static string get_The_type_0_is_not_understood_by_the_serialization_binder();
    internal static string get_Label_for_node_0_is_invalid_it_must_be_within_bracket_0_1();
    internal static string get_Matching_nodes_0_and_1_must_have_the_same_label();
    internal static string get_Node_0_must_be_contained_in_the_new_tree();
    internal static string get_Node_0_must_be_contained_in_the_old_tree();
    internal static string get_The_member_0_is_not_declared_within_the_declaration_of_the_symbol();
    internal static string get_The_position_is_not_within_the_symbol_s_declaration();
    internal static string get_The_symbol_0_cannot_be_located_within_the_current_solution();
    internal static string get_Changing_compilation_options_is_not_supported();
    internal static string get_Changing_parse_options_is_not_supported();
    internal static string get_The_node_is_not_part_of_the_tree();
    internal static string get_This_workspace_does_not_support_opening_and_closing_documents();
    internal static string get_Exceptions_colon();
    internal static string get__0_returned_an_uninitialized_ImmutableArray();
    internal static string get_Failure();
    internal static string get_Warning();
    internal static string get_Options_did_not_come_from_specified_Solution();
    internal static string get_Enable();
    internal static string get_Enable_and_ignore_future_errors();
    internal static string get__0_encountered_an_error_and_has_been_disabled();
    internal static string get_Show_Stack_Trace();
    internal static string get_Stream_is_too_long();
    internal static string get_Deserialization_reader_for_0_read_incorrect_number_of_values();
    internal static string get_Async_Method();
    internal static string get_Error();
    internal static string get_None();
    internal static string get_Suggestion();
    internal static string get_File_0_size_of_1_exceeds_maximum_allowed_size_of_2();
    internal static string get_Changing_document_property_is_not_supported();
    internal static string get_Variables_captured_colon();
    internal static string get_Refactoring_Only();
    internal static string get_Remove_the_line_below_if_you_want_to_inherit_dot_editorconfig_settings_from_higher_directories();
    internal static string get_Core_EditorConfig_Options();
    internal static string get_CSharp_files();
    internal static string get_dot_NET_Coding_Conventions();
    internal static string get_Indentation_and_spacing();
    internal static string get_New_line_preferences();
    internal static string get_Visual_Basic_files();
    internal static string get_Changing_document_0_is_not_supported();
    internal static string get_DateTimeKind_must_be_Utc();
    internal static string get_Warning_adding_imports_will_bring_an_extension_method_into_scope_with_the_same_name_as_member_access();
    internal static string get_Document_does_not_support_syntax_trees();
    internal static string get__0_is_in_a_different_project();
    internal static string get_Project_does_not_contain_specified_reference();
    internal static string get_Solution_does_not_contain_specified_reference();
    internal static string get_Unknown();
    internal static string get_Cannot_apply_action_that_is_not_in_0();
    internal static string get_Symbols_project_could_not_be_found_in_the_provided_solution();
    internal static string get_The_contents_of_a_SourceGeneratedDocument_may_not_be_changed();
    internal static string get_Rename_0_to_1();
    internal static string get_Sync_namespace_to_folder_structure();
    internal static string get_CodeAction__0__did_not_produce_a_changed_solution();
    internal static string get_Predefined_conversion_from_0_to_1();
    internal static string get_FixAllScope_ContainingType_and_FixAllScope_ContainingMember_are_not_supported_with_this_constructor();
    internal static string get_FixAllScope_Custom_is_not_supported_with_this_API();
    internal static string get_Failed_to_resolve_rename_conflicts();
}
public abstract class Microsoft.CodeAnalysis.XmlDocumentationProvider : DocumentationProvider {
    private NonReentrantLock _gate;
    private Dictionary`2<string, string> _docComments;
    [CompilerGeneratedAttribute]
private static XmlDocumentationProvider <DefaultXmlDocumentationProvider>k__BackingField;
    private static XmlReaderSettings s_xmlSettings;
    private static XmlDocumentationProvider DefaultXmlDocumentationProvider { get; }
    private static XmlDocumentationProvider();
    protected abstract virtual Stream GetSourceStream(CancellationToken cancellationToken);
    public static XmlDocumentationProvider CreateFromBytes(Byte[] xmlDocCommentBytes);
    [CompilerGeneratedAttribute]
private static XmlDocumentationProvider get_DefaultXmlDocumentationProvider();
    public static XmlDocumentationProvider CreateFromFile(string xmlDocCommentFilePath);
    private XDocument GetXDocument(CancellationToken cancellationToken);
    protected virtual string GetDocumentationForSymbol(string documentationMemberID, CultureInfo preferredCulture, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
[DebuggerDisplayAttribute("Count = {Count}")]
[DebuggerTypeProxyAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/DebuggerProxy")]
internal class Roslyn.Collections.Immutable.ImmutableHashMap`2 : object {
    private static ImmutableHashMap`2<TKey, TValue> s_emptySingleton;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Bucket<TKey, TValue> _root;
    private IEqualityComparer`1<TKey> _keyComparer;
    private IEqualityComparer`1<TValue> _valueComparer;
    public static ImmutableHashMap`2<TKey, TValue> Empty { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public TValue Item { get; }
    private ImmutableHashMap`2(Bucket<TKey, TValue> root, IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    internal ImmutableHashMap`2(IEqualityComparer`1<TKey> comparer, IEqualityComparer`1<TValue> valueComparer);
    private static ImmutableHashMap`2();
    public static ImmutableHashMap`2<TKey, TValue> get_Empty();
    public ImmutableHashMap`2<TKey, TValue> Clear();
    public ImmutableHashMap`2<TKey, TValue> Add(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    public ImmutableHashMap`2<TKey, TValue> SetItem(TKey key, TValue value);
    public ImmutableHashMap`2<TKey, TValue> SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    public ImmutableHashMap`2<TKey, TValue> Remove(TKey key);
    public ImmutableHashMap`2<TKey, TValue> RemoveRange(IEnumerable`1<TKey> keys);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer, IEqualityComparer`1<TValue> valueComparer);
    public ImmutableHashMap`2<TKey, TValue> WithComparers(IEqualityComparer`1<TKey> keyComparer);
    public bool ContainsValue(TValue value);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<get_Keys>d__23")]
public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> keyValuePair);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TKey equalKey, TKey& actualKey);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    internal bool TryExchangeKey(TKey key, TKey& existingKey);
    private static bool TryCastToImmutableMap(IEnumerable`1<KeyValuePair`2<TKey, TValue>> sequence, ImmutableHashMap`2& other);
    private ImmutableHashMap`2<TKey, TValue> Wrap(Bucket<TKey, TValue> root);
    private ImmutableHashMap`2<TKey, TValue> AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs, bool overwriteOnCollision, bool avoidToHashMap);
    [IteratorStateMachineAttribute("Roslyn.Collections.Immutable.ImmutableHashMap`2/<GetValueBuckets>d__39")]
private IEnumerable`1<ValueBucket<TKey, TValue>> GetValueBuckets();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Clear();
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItem(TKey key, TValue value);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.SetItems(IEnumerable`1<KeyValuePair`2<TKey, TValue>> items);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.AddRange(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.RemoveRange(IEnumerable`1<TKey> keys);
    private sealed virtual override IImmutableDictionary`2<TKey, TValue> System.Collections.Immutable.IImmutableDictionary<TKey,TValue>.Remove(TKey key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.AnnotationTable`1 : object {
    private int _globalId;
    private Dictionary`2<TAnnotation, SyntaxAnnotation> _realAnnotationMap;
    private Dictionary`2<string, TAnnotation> _annotationMap;
    private string _annotationKind;
    public AnnotationTable`1(string annotationKind);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetOrCreateRealAnnotations>d__5")]
private IEnumerable`1<SyntaxAnnotation> GetOrCreateRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetOrCreateRealAnnotation(TAnnotation annotation);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetRealAnnotations>d__7")]
private IEnumerable`1<SyntaxAnnotation> GetRealAnnotations(TAnnotation[] annotations);
    private SyntaxAnnotation GetRealAnnotation(TAnnotation annotation);
    public TSyntaxNode WithAdditionalAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithAdditionalAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithAdditionalAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithAdditionalAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    public TSyntaxNode WithoutAnnotations(TSyntaxNode node, TAnnotation[] annotations);
    public SyntaxToken WithoutAnnotations(SyntaxToken token, TAnnotation[] annotations);
    public SyntaxTrivia WithoutAnnotations(SyntaxTrivia trivia, TAnnotation[] annotations);
    public SyntaxNodeOrToken WithoutAnnotations(SyntaxNodeOrToken nodeOrToken, TAnnotation[] annotations);
    [IteratorStateMachineAttribute("Roslyn.Utilities.AnnotationTable`1/<GetAnnotations>d__17")]
private IEnumerable`1<TAnnotation> GetAnnotations(IEnumerable`1<SyntaxAnnotation> realAnnotations);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNode node);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxToken token);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxTrivia trivia);
    public IEnumerable`1<TSpecificAnnotation> GetAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    public bool HasAnnotations(SyntaxToken token);
    public bool HasAnnotations(SyntaxTrivia trivia);
    public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotations(SyntaxNode node);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxToken token);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxTrivia trivia);
    [NullableContextAttribute("0")]
public bool HasAnnotations(SyntaxNodeOrToken nodeOrToken);
    public bool HasAnnotation(SyntaxNode node, TAnnotation annotation);
    public bool HasAnnotation(SyntaxToken token, TAnnotation annotation);
    public bool HasAnnotation(SyntaxTrivia trivia, TAnnotation annotation);
    public bool HasAnnotation(SyntaxNodeOrToken nodeOrToken, TAnnotation annotation);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    public IEnumerable`1<SyntaxNodeOrToken> GetAnnotatedNodesAndTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxNode> GetAnnotatedNodes(SyntaxNode node);
    public IEnumerable`1<SyntaxToken> GetAnnotatedTokens(SyntaxNode node);
    public IEnumerable`1<SyntaxTrivia> GetAnnotatedTrivia(SyntaxNode node);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedNodes>b__43_0(SyntaxNodeOrToken nt);
    [CompilerGeneratedAttribute]
private bool <GetAnnotatedTokens>b__44_0(SyntaxNodeOrToken nt);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ArrayExtensions : object {
    [ExtensionAttribute]
internal static T[] Copy(T[] array, int start, int length);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T item);
    [ExtensionAttribute]
internal static T[] InsertAt(T[] array, int position, T[] items);
    [ExtensionAttribute]
internal static T[] Append(T[] array, T[] items);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position);
    [ExtensionAttribute]
internal static T[] RemoveAt(T[] array, int position, int length);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, T item);
    [ExtensionAttribute]
internal static T[] ReplaceAt(T[] array, int position, int length, T[] items);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array);
    [ExtensionAttribute]
internal static void ReverseContents(T[] array, int start, int count);
    [ExtensionAttribute]
internal static int BinarySearch(Int32[] array, int value);
    [ExtensionAttribute]
internal static int BinarySearchUpperBound(Int32[] array, int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ArrayPool`1 : object {
    private static int MaxPooledArraySize;
    private static SimplePool`1<T[]> s_pool;
    private static ArrayPool`1();
    public static T[] GetArray(int size);
    public static void ReleaseArray(T[] array);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.AsyncBatchingWorkQueue : AsyncBatchingWorkQueue`1<VoidResult> {
    public AsyncBatchingWorkQueue(TimeSpan delay, Func`2<CancellationToken, ValueTask> processBatchAsync, IAsynchronousOperationListener asyncListener, CancellationToken cancellationToken);
    private static Func`3<ImmutableSegmentedList`1<VoidResult>, CancellationToken, ValueTask> Convert(Func`2<CancellationToken, ValueTask> processBatchAsync);
    public void AddWork(bool cancelExistingWork);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslyn.Utilities.AsyncBatchingWorkQueue`1 : AsyncBatchingWorkQueue`2<TItem, VoidResult> {
    public AsyncBatchingWorkQueue`1(TimeSpan delay, Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask> processBatchAsync, IAsynchronousOperationListener asyncListener, CancellationToken cancellationToken);
    public AsyncBatchingWorkQueue`1(TimeSpan delay, Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask> processBatchAsync, IEqualityComparer`1<TItem> equalityComparer, IAsynchronousOperationListener asyncListener, CancellationToken cancellationToken);
    private static Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask`1<VoidResult>> Convert(Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask> processBatchAsync);
    public Task WaitUntilCurrentBatchCompletesAsync();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.AsyncBatchingWorkQueue`2 : object {
    private TimeSpan _delay;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<TItem> _equalityComparer;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask`1<TResult>> _processBatchAsync;
    private IAsynchronousOperationListener _asyncListener;
    private CancellationToken _entireQueueCancellationToken;
    private CancellationSeries _cancellationSeries;
    private object _gate;
    private Builder<TItem> _nextBatch;
    private CancellationToken _nextBatchCancellationToken;
    private SegmentedHashSet`1<TItem> _uniqueItems;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<TResult> _updateTask;
    private bool _taskInFlight;
    public AsyncBatchingWorkQueue`2(TimeSpan delay, Func`3<ImmutableSegmentedList`1<TItem>, CancellationToken, ValueTask`1<TResult>> processBatchAsync, IEqualityComparer`1<TItem> equalityComparer, IAsynchronousOperationListener asyncListener, CancellationToken cancellationToken);
    public void CancelExistingWork();
    public void AddWork(TItem item, bool cancelExistingWork);
    public void AddWork(IEnumerable`1<TItem> items, bool cancelExistingWork);
    public Task`1<TResult> WaitUntilCurrentBatchCompletesAsync();
    [AsyncStateMachineAttribute("Roslyn.Utilities.AsyncBatchingWorkQueue`2/<ProcessNextBatchAsync>d__17")]
private ValueTask`1<TResult> ProcessNextBatchAsync();
    private ValueTuple`2<ImmutableSegmentedList`1<TItem>, CancellationToken> GetNextBatchAndResetQueue();
    [CompilerGeneratedAttribute]
private void <AddWork>g__AddItemsToBatch|15_0(IEnumerable`1<TItem> items);
    [AsyncStateMachineAttribute("Roslyn.Utilities.AsyncBatchingWorkQueue`2/<<AddWork>g__ContinueAfterDelay|15_1>d")]
[CompilerGeneratedAttribute]
private Task`1<TResult> <AddWork>g__ContinueAfterDelay|15_1(Task lastTask);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.AsyncLazy : object {
    public static AsyncLazy`1<T> Create(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, bool cacheResult);
    public static AsyncLazy`1<T> Create(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslyn.Utilities.AsyncLazy`1 : ValueSource`1<T> {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CancellationToken, Task`1<T>> _asynchronousComputeFunction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CancellationToken, T> _synchronousComputeFunction;
    private bool _cacheResult;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<T> _cachedResult;
    private static NonReentrantLock s_gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<Request<T>> _requests;
    [NullableAttribute("2")]
private CancellationTokenSource _asynchronousComputationCancellationSource;
    private bool _computationActive;
    public AsyncLazy`1(T value);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, bool cacheResult);
    public AsyncLazy`1(Func`2<CancellationToken, Task`1<T>> asynchronousComputeFunction, Func`2<CancellationToken, T> synchronousComputeFunction, bool cacheResult);
    private static AsyncLazy`1();
    [NullableContextAttribute("0")]
private WaitThatValidatesInvariants<T> TakeLock(CancellationToken cancellationToken);
    private void AssertInvariants_NoLock();
    public virtual bool TryGetValue(T& result);
    public virtual T GetValue(CancellationToken cancellationToken);
    private Request<T> CreateNewRequest_NoLock();
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
private AsynchronousComputationToStart<T> RegisterAsynchronousComputation_NoLock();
    [NullableContextAttribute("0")]
private void StartAsynchronousComputation(AsynchronousComputationToStart<T> computationToStart, Request<T> requestToCompleteSynchronously, CancellationToken callerCancellationToken);
    private void CompleteWithTask(Task`1<T> task, CancellationToken cancellationToken);
    private Task`1<T> GetCachedValueAndCacheThisValueIfNoneCached_NoLock(Task`1<T> task);
    [NullableContextAttribute("2")]
private void OnAsynchronousRequestCancelled(object state);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <StartAsynchronousComputation>b__20_0(Task`1<T> t, object s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.BidirectionalMap`2 : object {
    public static IBidirectionalMap`2<TKey, TValue> Empty;
    private ImmutableDictionary`2<TKey, TValue> _forwardMap;
    private ImmutableDictionary`2<TValue, TKey> _backwardMap;
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public bool IsEmpty { get; }
    public int Count { get; }
    public TValue Item { get; }
    public TKey Item { get; }
    public BidirectionalMap`2(IEnumerable`1<KeyValuePair`2<TKey, TValue>> pairs);
    private BidirectionalMap`2(ImmutableDictionary`2<TKey, TValue> forwardMap, ImmutableDictionary`2<TValue, TKey> backwardMap);
    private static BidirectionalMap`2();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    public sealed virtual bool TryGetKey(TValue value, TKey& key);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool ContainsValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public sealed virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public sealed virtual IEnumerable`1<TKey> get_Keys();
    public sealed virtual IEnumerable`1<TValue> get_Values();
    public sealed virtual bool get_IsEmpty();
    public int get_Count();
    public sealed virtual TValue GetValueOrDefault(TKey key);
    public sealed virtual TKey GetKeyOrDefault(TValue value);
    public TValue get_Item(TKey key);
    public TKey get_Item(TValue value);
}
internal static class Roslyn.Utilities.BitArithmeticUtilities : object {
    public static int CountBits(int v);
    public static int CountBits(UInt32 v);
    public static int CountBits(long v);
    public static int CountBits(ulong v);
    internal static UInt32 Align(UInt32 position, UInt32 alignment);
    internal static int Align(int position, int alignment);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.BKTree : object {
    public static BKTree Empty;
    private Char[] _concatenatedLowerCaseWords;
    [NullableAttribute("0")]
private ImmutableArray`1<Node> _nodes;
    [NullableAttribute("0")]
private ImmutableArray`1<Edge> _edges;
    [NullableContextAttribute("0")]
private BKTree(Char[] concatenatedLowerCaseWords, ImmutableArray`1<Node> nodes, ImmutableArray`1<Edge> edges);
    private static BKTree();
    public static BKTree Create(String[] values);
    public static BKTree Create(IEnumerable`1<ReadOnlyMemory`1<char>> values);
    public IList`1<string> Find(string value, Nullable`1<int> threshold);
    private void Lookup(Node currentNode, Char[] queryCharacters, int queryLength, int threshold, List`1<string> result, int recursionCount);
    internal void WriteTo(ObjectWriter writer);
    internal static BKTree ReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CancellableLazy : object {
    public static CancellableLazy`1<T> Create(T value);
    public static CancellableLazy`1<T> Create(Func`2<CancellationToken, T> valueFactory);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.CancellableLazy`1 : object {
    [NullableAttribute("2")]
private NonReentrantLock _gate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<CancellationToken, T> _valueFactory;
    [NullableAttribute("2")]
private T _value;
    public bool HasValue { get; }
    public CancellableLazy`1(Func`2<CancellationToken, T> valueFactory);
    public CancellableLazy`1(T value);
    public bool get_HasValue();
    public bool TryGetValue(T& value);
    public T GetValue(CancellationToken cancellationToken);
}
internal class Roslyn.Utilities.CancellationSeries : object {
    [NullableAttribute("2")]
private CancellationTokenSource _cts;
    private CancellationToken _superToken;
    public bool HasActiveToken { get; }
    public CancellationSeries(CancellationToken token);
    public bool get_HasActiveToken();
    public CancellationToken CreateNext(CancellationToken token);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ComparerWithState : object {
    public static int CompareTo(T first, T second, S state, ImmutableArray`1<Func`3<T, S, IComparable>> comparableMethods);
    public static int CompareTo(T first, T second, ImmutableArray`1<Func`2<T, IComparable>> comparableMethods);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.CompilerOptionParseUtilities : object {
    public static IList`1<string> ParseFeatureFromMSBuild(string features);
    public static void ParseFeatures(IDictionary`2<string, string> builder, List`1<string> values);
    private static void ParseFeatureCore(IDictionary`2<string, string> builder, string feature);
}
internal static class Roslyn.Utilities.CompilerPathUtilities : object {
    [NullableContextAttribute("1")]
internal static void RequireAbsolutePath(string path, string argumentName);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ConcatImmutableArray`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _first;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _second;
    public int Length { get; }
    public ConcatImmutableArray`1(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    public int get_Length();
    [NullableContextAttribute("1")]
public bool Any(Func`2<T, bool> predicate);
    public Enumerator<T> GetEnumerator();
    public ImmutableArray`1<T> ToImmutableArray();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ConcurrentDictionaryExtensions : object {
    [ExtensionAttribute]
public static void Add(ConcurrentDictionary`2<K, V> dict, K key, V value);
    [ExtensionAttribute]
public static TValue GetOrAdd(ConcurrentDictionary`2<TKey, TValue> dictionary, TKey key, Func`3<TKey, TArg, TValue> valueFactory, TArg factoryArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Roslyn.Utilities.ConcurrentSet`1 : object {
    private static int DefaultConcurrencyLevel;
    private static int DefaultCapacity;
    private ConcurrentDictionary`2<T, byte> _dictionary;
    public int Count { get; }
    public bool IsEmpty { get; }
    public bool IsReadOnly { get; }
    public ConcurrentSet`1(IEqualityComparer`1<T> equalityComparer);
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Contains(T value);
    public bool Add(T value);
    public void AddRange(IEnumerable`1<T> values);
    public sealed virtual bool Remove(T value);
    public sealed virtual void Clear();
    [NullableContextAttribute("0")]
public KeyEnumerator<T> GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.ConcurrentSet`1/<GetEnumeratorImpl>d__18")]
private IEnumerator`1<T> GetEnumeratorImpl();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ConfiguredYieldAwaitable : ValueType {
    private YieldAwaitable _awaitable;
    private bool _continueOnCapturedContext;
    public ConfiguredYieldAwaitable(YieldAwaitable awaitable, bool continueOnCapturedContext);
    public ConfiguredYieldAwaiter GetAwaiter();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ConsList`1 : object {
    public static ConsList`1<T> Empty;
    [NullableAttribute("2")]
private T _head;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ConsList`1<T> _tail;
    [DebuggerBrowsableAttribute("0")]
public T Head { get; }
    [DebuggerBrowsableAttribute("0")]
public ConsList`1<T> Tail { get; }
    public ConsList`1(T head, ConsList`1<T> tail);
    private static ConsList`1();
    public T get_Head();
    public ConsList`1<T> get_Tail();
    public bool Any();
    public ConsList`1<T> Push(T value);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Roslyn.Utilities.ConstantValueSource`1 : ValueSource`1<T> {
    private T _value;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Task`1<T> _task;
    public ConstantValueSource`1(T value);
    public virtual T GetValue(CancellationToken cancellationToken);
    public virtual bool TryGetValue(T& value);
    public virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Contract : object {
    public static void ThrowIfNull(T value, int lineNumber);
    [NullableContextAttribute("0")]
public static void ThrowIfNull(Nullable`1<T> value, int lineNumber);
    public static void ThrowIfNull(T value, string message, int lineNumber);
    public static void ThrowIfNull(T value, ThrowIfNullInterpolatedStringHandler`1<T> message, int lineNumber);
    public static void ThrowIfFalse(bool condition, int lineNumber);
    public static void ThrowIfFalse(bool condition, string message, int lineNumber);
    public static void ThrowIfFalse(bool condition, ThrowIfFalseInterpolatedStringHandler message, int lineNumber);
    public static void ThrowIfTrue(bool condition, int lineNumber);
    public static void ThrowIfTrue(bool condition, string message, int lineNumber);
    public static void ThrowIfTrue(bool condition, ThrowIfTrueInterpolatedStringHandler message, int lineNumber);
    [DebuggerHiddenAttribute]
[DoesNotReturnAttribute]
public static void Fail(string message, int lineNumber);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.DecimalUtilities : object {
    [ExtensionAttribute]
public static int GetScale(decimal value);
    [ExtensionAttribute]
public static void GetBits(decimal value, Boolean& isNegative, Byte& scale, UInt32& low, UInt32& mid, UInt32& high);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.DocumentationCommentXmlNames : object {
    public static string CElementName;
    public static string CodeElementName;
    public static string CompletionListElementName;
    public static string DescriptionElementName;
    public static string ExampleElementName;
    public static string ExceptionElementName;
    public static string IncludeElementName;
    public static string InheritdocElementName;
    public static string ItemElementName;
    public static string ListElementName;
    public static string ListHeaderElementName;
    public static string ParaElementName;
    public static string ParameterElementName;
    public static string ParameterReferenceElementName;
    public static string PermissionElementName;
    public static string PlaceholderElementName;
    public static string PreliminaryElementName;
    public static string RemarksElementName;
    public static string ReturnsElementName;
    public static string SeeElementName;
    public static string SeeAlsoElementName;
    public static string SummaryElementName;
    public static string TermElementName;
    public static string ThreadSafetyElementName;
    public static string TypeParameterElementName;
    public static string TypeParameterReferenceElementName;
    public static string ValueElementName;
    public static string CrefAttributeName;
    public static string HrefAttributeName;
    public static string FileAttributeName;
    public static string InstanceAttributeName;
    public static string LangwordAttributeName;
    public static string NameAttributeName;
    public static string PathAttributeName;
    public static string StaticAttributeName;
    public static string TypeAttributeName;
    public static bool ElementEquals(string name1, string name2, bool fromVb);
    public static bool AttributeEquals(string name1, string name2);
    public static bool Equals(object left, object right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.EditDistance : object {
    private static int Infinity;
    public static int BeyondThreshold;
    private string _source;
    private Char[] _sourceLowerCaseCharacters;
    private static int MaxMatrixPoolDimension;
    private static ThreadLocal`1<Int32[0...,0...]> t_matrixPool;
    private static int LastSeenIndexLength;
    private static ThreadLocal`1<Int32[]> t_lastSeenIndexPool;
    public EditDistance(string text);
    private static EditDistance();
    private static Char[] ConvertToLowercaseArray(string text);
    public sealed virtual void Dispose();
    public static int GetEditDistance(string source, string target, int threshold);
    public static int GetEditDistance(Char[] source, Char[] target, int threshold);
    public int GetEditDistance(string target, int threshold);
    private static Int32[0...,0...] GetMatrix(int width, int height);
    private static Int32[0...,0...] InitializeMatrix(Int32[0...,0...] matrix);
    [NullableContextAttribute("0")]
public static int GetEditDistance(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, int threshold);
    [NullableContextAttribute("0")]
private static int GetEditDistanceWorker(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> target, int threshold);
    private static string ToString(Int32[0...,0...] matrix, int width, int height);
    private static int GetValue(Dictionary`2<char, int> da, char c);
    private static int Min(int v1, int v2, int v3, int v4);
    private static void SetValue(Int32[0...,0...] matrix, int i, int j, int val);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.EncodingExtensions : object {
    [ExtensionAttribute]
internal static int GetMaxCharCountOrThrowIfHuge(Encoding encoding, Stream stream);
    [ExtensionAttribute]
internal static bool TryGetMaxCharCount(Encoding encoding, long length, Int32& maxCharCount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.EnumerableExtensions : object {
    private static Func`2<object, bool> s_notNullTest;
    private static EnumerableExtensions();
    [ExtensionAttribute]
public static IEnumerable`1<T> Do(IEnumerable`1<T> source, Action`1<T> action);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static IReadOnlyList`1<T> ToBoxedImmutableArray(IEnumerable`1<T> items);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> Concat(IEnumerable`1<T> source, T value);
    [IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<ConcatWorker>d__5`1")]
[ExtensionAttribute]
private static IEnumerable`1<T> ConcatWorker(IEnumerable`1<T> source, T value);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool SetEquals(IEnumerable`1<T> source1, IEnumerable`1<T> source2);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static ISet`1<T> ToSet(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<T> ToCollection(IEnumerable`1<T> sequence);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> FirstOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> LastOrNull(IEnumerable`1<T> source);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static Nullable`1<T> SingleOrNull(IEnumerable`1<T> source, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static bool IsSingle(IEnumerable`1<T> list);
    [ExtensionAttribute]
public static bool IsEmpty(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(IReadOnlyCollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(ICollection`1<T> source);
    [ExtensionAttribute]
public static bool IsEmpty(string source);
    [ExtensionAttribute]
public static bool IsEmpty(T[] source);
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> source);
    [ExtensionAttribute]
public static IEnumerable`1<T> WhereNotNull(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static T[] AsArray(IEnumerable`1<T> source);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IEnumerable`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static ImmutableArray`1<TResult> SelectAsArray(IReadOnlyCollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__27`2")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`2<TItem, ValueTask`1<TResult>> selector);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectAsArrayAsync>d__28`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<TResult>> selector, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyAsArrayAsync>d__29`3")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> SelectManyAsArrayAsync(IEnumerable`1<TItem> source, Func`4<TItem, TArg, CancellationToken, ValueTask`1<IEnumerable`1<TResult>>> selector, TArg arg, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<SelectManyInParallelAsync>d__30`2")]
[ExtensionAttribute]
public static ValueTask`1<IEnumerable`1<TResult>> SelectManyInParallelAsync(IEnumerable`1<TItem> sequence, Func`3<TItem, CancellationToken, Task`1<IEnumerable`1<TResult>>> selector, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool All(IEnumerable`1<bool> source);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value);
    [ExtensionAttribute]
public static int IndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
private static int EnumeratingIndexOf(IEnumerable`1<T> sequence, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int IndexOf(IReadOnlyList`1<T> list, T value, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static IEnumerable`1<T> Flatten(IEnumerable`1<IEnumerable`1<T>> sequence);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderBy(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> OrderByDescending(IEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> Order(IEnumerable`1<T> source);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source, Comparison`1<T> compare);
    [ExtensionAttribute]
public static IOrderedEnumerable`1<T> ThenBy(IOrderedEnumerable`1<T> source);
    [ExtensionAttribute]
public static bool IsSorted(IEnumerable`1<T> enumerable, IComparer`1<T> comparer);
    [ExtensionAttribute]
public static bool Contains(IEnumerable`1<T> sequence, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Contains(IEnumerable`1<string> sequence, string s);
    [ExtensionAttribute]
public static IComparer`1<T> ToComparer(Comparison`1<T> comparison);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, V> ToImmutableDictionaryOrEmpty(IEnumerable`1<KeyValuePair`2<K, V>> items, IEqualityComparer`1<K> keyComparer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
internal static IList`1<IList`1<T>> Transpose(IEnumerable`1<IEnumerable`1<T>> data);
    [NullableContextAttribute("0")]
[IteratorStateMachineAttribute("Roslyn.Utilities.EnumerableExtensions/<TransposeInternal>d__53`1")]
[ExtensionAttribute]
private static IEnumerable`1<IList`1<T>> TransposeInternal(IEnumerable`1<IEnumerable`1<T>> data);
    [ExtensionAttribute]
internal static Dictionary`2<K, ImmutableArray`1<T>> ToDictionary(IEnumerable`1<T> data, Func`2<T, K> keySelector, IEqualityComparer`1<K> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static TSource AsSingleton(IEnumerable`1<TSource> source);
}
internal static class Roslyn.Utilities.EnumUtilities : object {
    [NullableContextAttribute("1")]
internal static ulong ConvertEnumUnderlyingTypeToUInt64(object value, SpecialType specialType);
    internal static T[] GetValues();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.EventMap : object {
    private NonReentrantLock _guard;
    private Dictionary`2<string, object> _eventNameToRegistries;
    public void AddEventHandler(string eventName, TEventHandler eventHandler);
    public void RemoveEventHandler(string eventName, TEventHandler eventHandler);
    public EventHandlerSet`1<TEventHandler> GetEventHandlers(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries(string eventName);
    private ImmutableArray`1<Registry`1<TEventHandler>> GetRegistries_NoLock(string eventName);
    private void SetRegistries_NoLock(string eventName, ImmutableArray`1<Registry`1<TEventHandler>> registries);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.ExceptionUtilities : object {
    internal static Exception Unreachable { get; }
    internal static Exception UnexpectedValue(object o);
    internal static Exception get_Unreachable();
    internal static bool IsCurrentOperationBeingCancelled(Exception exception, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileNameUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    [NullableContextAttribute("0")]
private static int IndexOfExtension(ReadOnlySpan`1<char> path);
    internal static string GetExtension(string path);
    [NullableContextAttribute("0")]
internal static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    private static string RemoveExtension(string path);
    internal static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    internal static string GetFileName(string path, bool includeExtension);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.FileUtilities : object {
    private static Char[] s_invalidPathChars;
    private static FileUtilities();
    internal static string ResolveRelativePath(string path, string basePath, string baseDirectory, IEnumerable`1<string> searchPaths, Func`2<string, bool> fileExists);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string baseDirectory);
    [NullableContextAttribute("2")]
internal static string ResolveRelativePath(string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string ResolveRelativePath(PathKind kind, string path, string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
private static string GetBaseDirectory(string basePath, string baseDirectory);
    [NullableContextAttribute("2")]
internal static string NormalizeRelativePath(string path, string basePath, string baseDirectory);
    internal static string NormalizeAbsolutePath(string path);
    internal static string NormalizeDirectoryPath(string path);
    internal static string TryNormalizeAbsolutePath(string path);
    internal static Stream OpenRead(string fullPath);
    internal static Stream OpenAsyncRead(string fullPath);
    internal static T RethrowExceptionsAsIOException(Func`1<T> operation);
    internal static Stream CreateFileStreamChecked(Func`2<string, Stream> factory, string path, string paramName);
    internal static DateTime GetFileTimeStamp(string fullPath);
    internal static long GetFileLength(string fullPath);
}
internal static class Roslyn.Utilities.FlowControlHelper : object {
    public static AsyncFlowControlHelper TrySuppressFlow();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Functions`1 : object {
    public static Func`2<T, T> Identity;
    public static Func`2<T, bool> True;
    private static Functions`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.GeneratedCodeUtilities : object {
    private static String[] s_autoGeneratedStrings;
    private static GeneratedCodeUtilities();
    internal static bool IsGeneratedSymbolWithGeneratedCodeAttribute(ISymbol symbol, INamedTypeSymbol generatedCodeAttribute);
    internal static bool IsGeneratedCode(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    internal static bool IsGeneratedCode(string filePath, SyntaxNode root, Func`2<SyntaxTrivia, bool> isComment);
    [NullableContextAttribute("2")]
private static bool IsGeneratedCodeFile(string filePath);
    private static bool BeginsWithAutoGeneratedComment(SyntaxNode root, Func`2<SyntaxTrivia, bool> isComment);
    private static bool BeginsWithAutoGeneratedComment(SyntaxTree tree, Func`2<SyntaxTrivia, bool> isComment, CancellationToken cancellationToken);
    internal static GeneratedKind GetIsGeneratedCodeFromOptions(ImmutableDictionary`2<string, string> options);
    internal static Nullable`1<bool> GetIsGeneratedCodeFromOptions(AnalyzerConfigOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int Combine(T newKeyPart, int currentKey);
    [NullableContextAttribute("2")]
internal static int CombineValues(IEnumerable`1<T> values, int maxItemsToHash);
    internal static int CombineValues(ImmutableDictionary`2<TKey, TValue> values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(T[] values, int maxItemsToHash);
    [NullableContextAttribute("2")]
internal static int CombineValues(ImmutableArray`1<T> values, int maxItemsToHash);
    internal static int CombineValues(IEnumerable`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int CombineValues(ImmutableArray`1<string> values, StringComparer stringComparer, int maxItemsToHash);
    internal static int GetFNVHashCode(Byte[] data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<byte> data, Boolean& isAscii);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
    [NullableContextAttribute("0")]
internal static int GetFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start, int length);
    internal static int GetCaseInsensitiveFNVHashCode(string text);
    [NullableContextAttribute("0")]
internal static int GetCaseInsensitiveFNVHashCode(ReadOnlySpan`1<char> data);
    internal static int GetFNVHashCode(string text, int start);
    internal static int GetFNVHashCode(string text);
    internal static int GetFNVHashCode(StringBuilder text);
    internal static int GetFNVHashCode(Char[] text, int start, int length);
    internal static int GetFNVHashCode(char ch);
    internal static int CombineFNVHash(int hashCode, string text);
    internal static int CombineFNVHash(int hashCode, char ch);
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.IBidirectionalMap`2 {
    public bool IsEmpty { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual bool get_IsEmpty();
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
    public abstract virtual bool TryGetKey(TValue value, TKey& key);
    public abstract virtual TValue GetValueOrDefault(TKey key);
    public abstract virtual TKey GetKeyOrDefault(TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool ContainsValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveKey(TKey key);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> RemoveValue(TValue value);
    public abstract virtual IBidirectionalMap`2<TKey, TValue> Add(TKey key, TValue value);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.ICacheEntry`2 {
    public TKey Key { get; }
    public TValue Value { get; }
    public abstract virtual TKey get_Key();
    public abstract virtual TValue get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ICollectionExtensions : object {
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static void AddRange(ICollection`1<T> collection, ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.IDictionaryExtensions : object {
    [ExtensionAttribute]
public static V GetOrAdd(IDictionary`2<K, V> dictionary, K key, Func`2<K, V> function);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static TValue GetValueOrDefault(Dictionary`2<TKey, TValue> dictionary, TKey key, TValue defaultValue);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ArrayBuilder`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAddRange(IDictionary`2<TKey, ArrayBuilder`1<TValue>> dictionary, TKey key, IEnumerable`1<TValue> values);
    [ExtensionAttribute]
public static bool MultiAdd(IDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value, IEqualityComparer`1<TValue> comparer);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiAdd(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value, ImmutableArray`1<TValue> defaultArray);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, TCollection> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, ImmutableHashSet`1<TValue>> MultiRemove(ImmutableDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
private static void MultiRemoveSet(IDictionary`2<TKey, TSet> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableHashSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableSortedSet`1<TValue>> dictionary, TKey key, TValue value);
    [ExtensionAttribute]
public static void MultiRemove(IDictionary`2<TKey, ImmutableArray`1<TValue>> dictionary, TKey key, TValue value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.IGroupingExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Deconstruct(IGrouping`2<TKey, TElement> grouping, TKey& key, IEnumerable`1& values);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableArrayExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool Contains(ImmutableArray`1<T> items, T item, IEqualityComparer`1<T> equalityComparer);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToImmutableArrayOrEmpty(T[] items);
    [ExtensionAttribute]
public static ConcatImmutableArray`1<T> ConcatFast(ImmutableArray`1<T> first, ImmutableArray`1<T> second);
    [ExtensionAttribute]
public static ImmutableArray`1<T> TakeAsArray(ImmutableArray`1<T> array, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableDictionaryExtensions : object {
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> AddAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Add(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> RemoveAll(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, IEnumerable`1<K> keys, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableHashSet`1<V>> Remove(ImmutableDictionary`2<K, ImmutableHashSet`1<V>> map, K key, V value);
    [ExtensionAttribute]
public static ImmutableDictionary`2<TKey, TValue> ToImmutableDictionaryOrEmpty(IEnumerable`1<TSource> source, Func`2<TSource, TKey> keySelector, Func`2<TSource, TValue> elementSelector);
}
internal static class Roslyn.Utilities.ImmutableHashMapExtensions : object {
    [NullableContextAttribute("1")]
public static TValue GetOrAdd(ImmutableHashMap`2& location, TKey key, Func`3<TKey, TArg, TValue> valueProvider, TArg factoryArgument);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ImmutableListExtensions : object {
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(T[] items);
    [ExtensionAttribute]
internal static ImmutableList`1<T> ToImmutableListOrEmpty(IEnumerable`1<T> items);
}
internal interface Roslyn.Utilities.IObjectWritable {
    public bool ShouldReuseInSerialization { get; }
    public abstract virtual void WriteTo(ObjectWriter writer);
    public abstract virtual bool get_ShouldReuseInSerialization();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.IReadOnlyDictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetValueOrDefault(IReadOnlyDictionary`2<TKey, TValue> dictionary, TKey key);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetEnumerableMetadata(IReadOnlyDictionary`2<string, object> metadata, string name);
    [ExtensionAttribute]
public static IReadOnlyDictionary`2<TKey, TValue> AsNullable(IReadOnlyDictionary`2<TKey, TValue> dictionary);
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.IReadOnlySet`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool Contains(T item);
}
[NullableContextAttribute("1")]
internal interface Roslyn.Utilities.IReferenceCountedDisposable`1 {
    public T Target { get; }
    public abstract virtual T get_Target();
    public abstract virtual IReferenceCountedDisposable`1<T> TryAddReference();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ISetExtensions : object {
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool AddAll(ISet`1<T> set, ImmutableArray`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, IEnumerable`1<T> values);
    [ExtensionAttribute]
public static bool RemoveAll(ISet`1<T> set, ImmutableArray`1<T> values);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.KeyValuePairUtil : object {
    public static KeyValuePair`2<K, V> Create(K key, V value);
    [ExtensionAttribute]
public static void Deconstruct(KeyValuePair`2<TKey, TValue> keyValuePair, TKey& key, TValue& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static KeyValuePair`2<TKey, TValue> ToKeyValuePair(ValueTuple`2<TKey, TValue> tuple);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.LazyInitialization : object {
    internal static T InterlockedStore(T& target, T value);
    internal static int InterlockedStore(Int32& target, int uninitializedValue, int value);
    public static T EnsureInitialized(T& target, Func`1<T> valueFactory);
    public static T EnsureInitialized(T& target, Func`2<U, T> valueFactory, U state);
    public static int EnsureInitialized(Int32& target, int uninitializedValue, Func`2<U, int> valueFactory, U state);
    [NullableContextAttribute("2")]
public static T EnsureInitialized(StrongBox`1& target, Func`1<T> valueFactory);
    [NullableContextAttribute("2")]
public static T EnsureInitialized(StrongBox`1& target, Func`2<U, T> valueFactory, U state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.MultiDictionary`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<K, ValueSet<K, V>> _dictionary;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEqualityComparer`1<V> _valueComparer;
    [NullableAttribute("0")]
private ValueSet<K, V> _emptySet;
    public int Count { get; }
    public bool IsEmpty { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public KeyCollection<K, ValueSet<K, V>> Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueCollection<K, ValueSet<K, V>> Values { get; }
    [NullableAttribute("0")]
public ValueSet<K, V> Item { get; }
    public MultiDictionary`2(IEqualityComparer`1<K> comparer);
    public MultiDictionary`2(int capacity, IEqualityComparer`1<K> comparer, IEqualityComparer`1<V> valueComparer);
    public int get_Count();
    public bool get_IsEmpty();
    public KeyCollection<K, ValueSet<K, V>> get_Keys();
    public ValueCollection<K, ValueSet<K, V>> get_Values();
    [NullableContextAttribute("0")]
public ValueSet<K, V> get_Item(K k);
    public bool Add(K k, V v);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Enumerator<K, ValueSet<K, V>> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<K, ValueSet<K, V>>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<K,Roslyn.Utilities.MultiDictionary<K,V>.ValueSet>>.GetEnumerator();
    public bool ContainsKey(K k);
    internal void Clear();
    public void Remove(K key);
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonCopyableAttribute : Attribute {
}
[AttributeUsageAttribute("16392")]
internal class Roslyn.Utilities.NonDefaultableAttribute : Attribute {
}
internal class Roslyn.Utilities.NonReentrantLock : object {
    [NullableAttribute("1")]
private object _syncLock;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _owningThreadId;
    [NullableAttribute("1")]
public static Func`1<NonReentrantLock> Factory;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static Action`1<object> s_cancellationTokenCanceledEventHandler;
    private bool IsLocked { get; }
    private bool IsOwnedByMe { get; }
    public NonReentrantLock(bool useThisInstanceForSynchronization);
    private static NonReentrantLock();
    public void Wait(CancellationToken cancellationToken);
    public void Release();
    public bool LockHeldByMe();
    public void AssertHasLock();
    private bool get_IsLocked();
    private bool get_IsOwnedByMe();
    private void TakeOwnership();
    private void ReleaseOwnership();
    [NullableContextAttribute("2")]
private static void CancellationTokenCanceledEventHandler(object obj);
    public SemaphoreDisposer DisposableWait(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.NullableStructExtensions : object {
    [ExtensionAttribute]
public static void Deconstruct(Nullable`1<T> value, T& valueOrDefault, Boolean& hasValue);
}
internal static class Roslyn.Utilities.ObjectBinder : object {
    private static object s_gate;
    private static Nullable`1<ObjectBinderSnapshot> s_lastSnapshot;
    private static Dictionary`2<Type, int> s_typeToIndex;
    private static List`1<Type> s_types;
    private static List`1<Func`2<ObjectReader, IObjectWritable>> s_typeReaders;
    private static ObjectBinder();
    public static ObjectBinderSnapshot GetSnapshot();
    public static void RegisterTypeReader(Type type, Func`2<ObjectReader, IObjectWritable> typeReader);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ObjectBinderSnapshot : ValueType {
    private Dictionary`2<Type, int> _typeToIndex;
    private ImmutableArray`1<Type> _types;
    private ImmutableArray`1<Func`2<ObjectReader, IObjectWritable>> _typeReaders;
    public ObjectBinderSnapshot(Dictionary`2<Type, int> typeToIndex, List`1<Type> types, List`1<Func`2<ObjectReader, IObjectWritable>> typeReaders);
    public int GetTypeId(Type type);
    public Type GetTypeFromId(int typeId);
    public Func`2<ObjectReader, IObjectWritable> GetTypeReaderFromId(int typeId);
}
internal class Roslyn.Utilities.ObjectReader : object {
    internal static byte VersionByte1;
    internal static byte VersionByte2;
    private BinaryReader _reader;
    private CancellationToken _cancellationToken;
    private ReaderReferenceMap`1<object> _objectReferenceMap;
    private ReaderReferenceMap`1<string> _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    private static Encoding s_encodingUtf8;
    private static Encoding s_encodingUtf32_BE;
    private static Encoding s_encodingUtf32_BE_BOM;
    private static Encoding s_encodingUtf32_LE;
    private static Encoding s_encodingUnicode_BE;
    private static Encoding s_encodingUnicode_LE;
    private ObjectReader(Stream stream, bool leaveOpen, CancellationToken cancellationToken);
    private static ObjectReader();
    public static ObjectReader TryGetReader(Stream stream, bool leaveOpen, CancellationToken cancellationToken);
    public static ObjectReader GetReader(Stream stream, bool leaveOpen, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    public bool ReadBoolean();
    public byte ReadByte();
    public char ReadChar();
    public decimal ReadDecimal();
    public double ReadDouble();
    public float ReadSingle();
    public int ReadInt32();
    public long ReadInt64();
    public sbyte ReadSByte();
    public short ReadInt16();
    public UInt32 ReadUInt32();
    public ulong ReadUInt64();
    public ushort ReadUInt16();
    public string ReadString();
    public Guid ReadGuid();
    public object ReadValue();
    private object ReadValueWorker();
    internal UInt32 ReadCompressedUInt();
    private string ReadStringValue();
    private string ReadStringValue(EncodingKind kind);
    private string ReadStringLiteral(EncodingKind kind);
    private Array ReadArray(EncodingKind kind);
    private Array ReadPrimitiveTypeArrayElements(Type type, EncodingKind kind, int length);
    private Boolean[] ReadBooleanArrayElements(Boolean[] array);
    private static T[] CreateArray(int length);
    private String[] ReadStringArrayElements(String[] array);
    private SByte[] ReadInt8ArrayElements(SByte[] array);
    private Int16[] ReadInt16ArrayElements(Int16[] array);
    private Int32[] ReadInt32ArrayElements(Int32[] array);
    private Int64[] ReadInt64ArrayElements(Int64[] array);
    private UInt16[] ReadUInt16ArrayElements(UInt16[] array);
    private UInt32[] ReadUInt32ArrayElements(UInt32[] array);
    private UInt64[] ReadUInt64ArrayElements(UInt64[] array);
    private Decimal[] ReadDecimalArrayElements(Decimal[] array);
    private Single[] ReadFloat4ArrayElements(Single[] array);
    private Double[] ReadFloat8ArrayElements(Double[] array);
    public Type ReadType();
    private Type ReadTypeAfterTag();
    private object ReadObject();
    private static Exception DeserializationReadIncorrectNumberOfValuesException(string typeName);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationReaderException(string typeName);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private object <ReadValue>b__27_0();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ObjectWriter : object {
    private BinaryWriter _writer;
    private CancellationToken _cancellationToken;
    private WriterReferenceMap _objectReferenceMap;
    private WriterReferenceMap _stringReferenceMap;
    private ObjectBinderSnapshot _binderSnapshot;
    private int _recursionDepth;
    internal static int MaxRecursionDepth;
    internal static Dictionary`2<Type, EncodingKind> s_typeMap;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal static ImmutableArray`1<Type> s_reverseTypeMap;
    internal static byte ByteMarkerMask;
    internal static byte Byte1Marker;
    internal static byte Byte2Marker;
    internal static byte Byte4Marker;
    public ObjectWriter(Stream stream, bool leaveOpen, CancellationToken cancellationToken);
    private static ObjectWriter();
    private void WriteVersion();
    public sealed virtual void Dispose();
    public void WriteBoolean(bool value);
    public void WriteByte(byte value);
    public void WriteChar(char ch);
    public void WriteDecimal(decimal value);
    public void WriteDouble(double value);
    public void WriteSingle(float value);
    public void WriteInt32(int value);
    public void WriteInt64(long value);
    public void WriteSByte(sbyte value);
    public void WriteInt16(short value);
    public void WriteUInt32(UInt32 value);
    public void WriteUInt64(ulong value);
    public void WriteUInt16(ushort value);
    [NullableContextAttribute("2")]
public void WriteString(string value);
    public void WriteGuid(Guid guid);
    [NullableContextAttribute("2")]
public void WriteValue(object value);
    [NullableContextAttribute("0")]
public void WriteValue(ReadOnlySpan`1<byte> span);
    [NullableContextAttribute("2")]
public void WriteValue(IObjectWritable value);
    private void WriteEncodedInt32(int v);
    private void WriteEncodedUInt32(UInt32 v);
    internal void WriteCompressedUInt(UInt32 value);
    [NullableContextAttribute("2")]
private void WriteStringValue(string value);
    private void WriteArray(Array array);
    private void WriteArrayValues(Array array);
    private void WritePrimitiveTypeArrayElements(Type type, EncodingKind kind, Array instance);
    private void WriteBooleanArrayElements(Boolean[] array);
    private void WriteStringArrayElements(String[] array);
    private void WriteInt8ArrayElements(SByte[] array);
    private void WriteInt16ArrayElements(Int16[] array);
    private void WriteInt32ArrayElements(Int32[] array);
    private void WriteInt64ArrayElements(Int64[] array);
    private void WriteUInt16ArrayElements(UInt16[] array);
    private void WriteUInt32ArrayElements(UInt32[] array);
    private void WriteUInt64ArrayElements(UInt64[] array);
    private void WriteDecimalArrayElements(Decimal[] array);
    private void WriteFloat4ArrayElements(Single[] array);
    private void WriteFloat8ArrayElements(Double[] array);
    private void WritePrimitiveType(Type type, EncodingKind kind);
    public void WriteType(Type type);
    private void WriteKnownType(Type type);
    [NullableContextAttribute("2")]
public void WriteEncoding(Encoding encoding);
    [NullableContextAttribute("2")]
private static EncodingKind GetEncodingKind(Encoding encoding);
    private void WriteObject(object instance, IObjectWritable instanceAsWritable);
    private void WriteObjectWorker(IObjectWritable writable);
    private static Exception NoSerializationTypeException(string typeName);
    private static Exception NoSerializationWriterException(string typeName);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private object <WriteArray>b__34_0(object a);
    [CompilerGeneratedAttribute]
internal static bool <GetEncodingKind>g__HasPreamble|53_0(Encoding encoding);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private object <WriteObject>b__54_0(object obj);
}
internal static class Roslyn.Utilities.OneOrMany : object {
    [NullableContextAttribute("1")]
public static OneOrMany`1<T> Create(T one);
    [NullableContextAttribute("2")]
public static OneOrMany`1<T> Create(ImmutableArray`1<T> many);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OneOrMany`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static OneOrMany`1<T> Empty;
    [NullableAttribute("2")]
private T _one;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ImmutableArray`1<T> _many;
    [MemberNotNullWhenAttribute("True", "_one")]
private bool HasOne { get; }
    public T Item { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public OneOrMany`1(T one);
    public OneOrMany`1(ImmutableArray`1<T> many);
    private static OneOrMany`1();
    [MemberNotNullWhenAttribute("True", "_one")]
private bool get_HasOne();
    public T get_Item(int index);
    public int get_Count();
    public bool get_IsEmpty();
    public OneOrMany`1<T> Add(T one);
    public bool Contains(T item);
    public OneOrMany`1<T> RemoveAll(T item);
    public OneOrMany`1<TResult> Select(Func`2<T, TResult> selector);
    public OneOrMany`1<TResult> Select(Func`3<T, TArg, TResult> selector, TArg arg);
    public T FirstOrDefault(Func`2<T, bool> predicate);
    public T FirstOrDefault(Func`3<T, TArg, bool> predicate, TArg arg);
    [NullableContextAttribute("0")]
public Enumerator<T> GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.OrderedMultiDictionary`2 : object {
    private Dictionary`2<K, SetWithInsertionOrder`1<V>> _dictionary;
    private List`1<K> _keys;
    public int Count { get; }
    public IEnumerable`1<K> Keys { get; }
    public SetWithInsertionOrder`1<V> Item { get; }
    public int get_Count();
    public IEnumerable`1<K> get_Keys();
    public SetWithInsertionOrder`1<V> get_Item(K k);
    public void Add(K k, V v);
    public void AddRange(K k, IEnumerable`1<V> values);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Roslyn.Utilities.OrderedMultiDictionary`2/<GetEnumerator>d__12")]
public sealed virtual IEnumerator`1<KeyValuePair`2<K, SetWithInsertionOrder`1<V>>> GetEnumerator();
}
internal enum Roslyn.Utilities.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    public static string TrimTrailingSeparators(string s);
    public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    [NullableContextAttribute("0")]
public static ReadOnlyMemory`1<char> GetExtension(ReadOnlyMemory`1<char> path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path, bool includeExtension);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    [NullableContextAttribute("2")]
internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    [NullableContextAttribute("2")]
private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    [NullableContextAttribute("2")]
public static PathKind GetPathKind(string path);
    [NullableContextAttribute("2")]
public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePossiblyRelativeAndRelativePaths(string root, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    [NullableContextAttribute("2")]
public static string CombinePaths(string root, string path);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    [NullableContextAttribute("2")]
private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    [NullableContextAttribute("2")]
public static bool IsValidFilePath(string fullPath);
    public static string NormalizeWithForwardSlash(string p);
    public static string ExpandAbsolutePathWithRelativeParts(string p);
}
[ConditionalAttribute("EMIT_CODE_ANALYSIS_ATTRIBUTES")]
[AttributeUsageAttribute("480")]
internal class Roslyn.Utilities.PerformanceSensitiveAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Constraint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowCaptures>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitBoxing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowGenericEnumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowLocks>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OftenCompletesSynchronously>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParallelEntry>k__BackingField;
    public string Uri { get; }
    public string Constraint { get; public set; }
    public bool AllowCaptures { get; public set; }
    public bool AllowImplicitBoxing { get; public set; }
    public bool AllowGenericEnumeration { get; public set; }
    public bool AllowLocks { get; public set; }
    public bool OftenCompletesSynchronously { get; public set; }
    public bool IsParallelEntry { get; public set; }
    public PerformanceSensitiveAttribute(string uri);
    [CompilerGeneratedAttribute]
public string get_Uri();
    [CompilerGeneratedAttribute]
public string get_Constraint();
    [CompilerGeneratedAttribute]
public void set_Constraint(string value);
    [CompilerGeneratedAttribute]
public bool get_AllowCaptures();
    [CompilerGeneratedAttribute]
public void set_AllowCaptures(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowImplicitBoxing();
    [CompilerGeneratedAttribute]
public void set_AllowImplicitBoxing(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowGenericEnumeration();
    [CompilerGeneratedAttribute]
public void set_AllowGenericEnumeration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowLocks();
    [CompilerGeneratedAttribute]
public void set_AllowLocks(bool value);
    [CompilerGeneratedAttribute]
public bool get_OftenCompletesSynchronously();
    [CompilerGeneratedAttribute]
public void set_OftenCompletesSynchronously(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsParallelEntry();
    [CompilerGeneratedAttribute]
public void set_IsParallelEntry(bool value);
}
internal static class Roslyn.Utilities.PlatformInformation : object {
    public static bool IsWindows { get; }
    public static bool IsUnix { get; }
    public static bool IsRunningOnMono { get; }
    public static bool IsUsingMonoRuntime { get; }
    public static bool get_IsWindows();
    public static bool get_IsUnix();
    public static bool get_IsRunningOnMono();
    public static bool get_IsUsingMonoRuntime();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.PooledBuilderExtensions : object {
    [ExtensionAttribute]
public static Dictionary`2<K, V> ToDictionaryAndFree(PooledDictionary`2<K, V> builders);
    [ExtensionAttribute]
public static Dictionary`2<K, ImmutableArray`1<V>> ToMultiDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableDictionary`2<K, ImmutableArray`1<V>> ToImmutableMultiDictionaryAndFree(PooledDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static void FreeValues(IReadOnlyDictionary`2<K, ArrayBuilder`1<V>> builders);
    [ExtensionAttribute]
public static ImmutableArray`1<T> ToFlattenedImmutableArrayAndFree(ArrayBuilder`1<ArrayBuilder`1<T>> builders);
}
internal static class Roslyn.Utilities.Predicates`1 : object {
    [NullableAttribute("1")]
public static Predicate`1<T> True;
    private static Predicates`1();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReaderWriterLockSlimExtensions : object {
    [ExtensionAttribute]
internal static ReadLockExiter DisposableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static UpgradeableReadLockExiter DisposableUpgradeableRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static WriteLockExiter DisposableWrite(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanRead(ReaderWriterLockSlim lock);
    [ExtensionAttribute]
internal static void AssertCanWrite(ReaderWriterLockSlim lock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceCountedDisposable`1 : object {
    [NullableAttribute("2")]
private T _instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private BoxedReferenceCount<T> _boxedReferenceCount;
    public T Target { get; }
    public ReferenceCountedDisposable`1(T instance);
    private ReferenceCountedDisposable`1(T instance, BoxedReferenceCount<T> referenceCount);
    public sealed virtual T get_Target();
    public ReferenceCountedDisposable`1<T> TryAddReference();
    private sealed virtual override IReferenceCountedDisposable`1<T> Roslyn.Utilities.IReferenceCountedDisposable<T>.TryAddReference();
    [NullableContextAttribute("2")]
private static ReferenceCountedDisposable`1<T> TryAddReferenceImpl(T target, BoxedReferenceCount<T> referenceCount);
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
private T DisposeImpl();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceCountedDisposableCache`2 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, WeakReference<Entry<TKey, TValue>>> _cache;
    private object _gate;
    public IReferenceCountedDisposable`1<ICacheEntry`2<TKey, TValue>> GetOrCreate(TKey key, Func`3<TKey, TArg, TValue> valueCreator, TArg arg);
    public void Evict(TKey key);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.ReferenceEqualityComparer : object {
    [NullableAttribute("1")]
public static ReferenceEqualityComparer Instance;
    private static ReferenceEqualityComparer();
    private sealed virtual override bool System.Collections.Generic.IEqualityComparer<System.Object>.Equals(object a, object b);
    private sealed virtual override int System.Collections.Generic.IEqualityComparer<System.Object>.GetHashCode(object a);
    public static int GetHashCode(object a);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.ReferenceHolder`1 : ValueType {
    [NullableAttribute("2")]
private T _strongReference;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private WeakReference`1<T> _weakReference;
    private int _hashCode;
    private ReferenceHolder`1(T strongReference);
    private ReferenceHolder`1(WeakReference`1<T> weakReference, int hashCode);
    public static ReferenceHolder`1<T> Strong(T value);
    public static ReferenceHolder`1<T> Weak(T value);
    [NullableContextAttribute("2")]
public T TryGetTarget();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReferenceHolder`1<T> other);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.ReflectionUtilities : object {
    private static Type Missing;
    private static ReflectionUtilities();
    public static Type TryGetType(string assemblyQualifiedName);
    [NullableContextAttribute("2")]
public static Type TryGetType(Type& lazyType, string assemblyQualifiedName);
    public static Type GetTypeFromEither(string contractName, string desktopName);
    public static Type GetTypeFromEither(Type& lazyType, string contractName, string desktopName);
    public static T FindItem(IEnumerable`1<T> collection, Type[] paramTypes);
    [ExtensionAttribute]
internal static MethodInfo GetDeclaredMethod(TypeInfo typeInfo, string name, Type[] paramTypes);
    [ExtensionAttribute]
internal static ConstructorInfo GetDeclaredConstructor(TypeInfo typeInfo, Type[] paramTypes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T CreateDelegate(MethodInfo methodInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static object InvokeConstructor(ConstructorInfo constructorInfo, Object[] args);
    [ExtensionAttribute]
public static T Invoke(MethodInfo methodInfo, object obj, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynDebug : object {
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool b, string message);
    [ConditionalAttribute("DEBUG")]
public static void AssertNotNull(T value);
    [NullableContextAttribute("2")]
[ConditionalAttribute("DEBUG")]
internal static void AssertOrFailFast(bool condition, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.RoslynString : object {
    public static bool IsNullOrEmpty(string value);
    public static bool IsNullOrWhiteSpace(string value);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.SemaphoreSlimExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SemaphoreDisposer DisposableWait(SemaphoreSlim semaphore, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SemaphoreSlimExtensions/<DisposableWaitAsync>d__1")]
[ExtensionAttribute]
public static ValueTask`1<SemaphoreDisposer> DisposableWaitAsync(SemaphoreSlim semaphore, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.SemaphoreSlimFactory : object {
    [NullableAttribute("1")]
public static Func`1<SemaphoreSlim> Instance;
    private static SemaphoreSlimFactory();
}
internal static class Roslyn.Utilities.SerializationThreadPool : object {
    public static Task`1<object> RunOnBackgroundThreadAsync(Func`1<object> start);
    [NullableContextAttribute("2")]
public static Task`1<object> RunOnBackgroundThreadAsync(Func`2<object, object> start, object obj);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class Roslyn.Utilities.SetWithInsertionOrder`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<T> _set;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ArrayBuilder`1<T> _elements;
    public int Count { get; }
    public T Item { get; }
    public bool Add(T value);
    public bool Insert(int index, T value);
    public bool Remove(T value);
    public sealed virtual int get_Count();
    public sealed virtual bool Contains(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public ImmutableArray`1<T> AsImmutable();
    public T get_Item(int i);
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.SharedStopwatch : ValueType {
    private static Stopwatch s_stopwatch;
    private TimeSpan _started;
    public TimeSpan Elapsed { get; }
    private SharedStopwatch(TimeSpan started);
    private static SharedStopwatch();
    public TimeSpan get_Elapsed();
    public static SharedStopwatch StartNew();
    private static SharedStopwatch StartNewCore();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SimplePool`1 : object {
    private object _gate;
    private Stack`1<T> _values;
    private Func`1<T> _allocate;
    public SimplePool`1(Func`1<T> allocate);
    public T Allocate();
    public void Free(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SoftCrashException : OperationCanceledException {
    public SoftCrashException(string message);
    public SoftCrashException(CancellationToken token);
    public SoftCrashException(string message, Exception innerException);
    public SoftCrashException(string message, CancellationToken token);
    public SoftCrashException(string message, Exception innerException, CancellationToken token);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Roslyn.Utilities.SpecializedCollections : object {
    public static IEnumerator`1<T> EmptyEnumerator();
    public static IEnumerable`1<T> EmptyEnumerable();
    public static ICollection`1<T> EmptyCollection();
    public static IList`1<T> EmptyList();
    public static IReadOnlyList`1<T> EmptyBoxedImmutableArray();
    public static IReadOnlyList`1<T> EmptyReadOnlyList();
    public static ISet`1<T> EmptySet();
    public static IReadOnlySet`1<T> EmptyReadOnlySet();
    public static IDictionary`2<TKey, TValue> EmptyDictionary();
    public static IReadOnlyDictionary`2<TKey, TValue> EmptyReadOnlyDictionary();
    public static IEnumerable`1<T> SingletonEnumerable(T value);
    public static ICollection`1<T> SingletonCollection(T value);
    public static IEnumerator`1<T> SingletonEnumerator(T value);
    public static IReadOnlyList`1<T> SingletonReadOnlyList(T value);
    public static IList`1<T> SingletonList(T value);
    public static IEnumerable`1<T> ReadOnlyEnumerable(IEnumerable`1<T> values);
    public static ICollection`1<T> ReadOnlyCollection(ICollection`1<T> collection);
    public static ISet`1<T> ReadOnlySet(ISet`1<T> set);
    public static IReadOnlySet`1<T> StronglyTypedReadOnlySet(ISet`1<T> set);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.SpecializedTasks : object {
    public static Task`1<bool> True;
    public static Task`1<bool> False;
    [ObsoleteAttribute("Use Task.CompletedTask instead which is available in the framework.")]
public static Task EmptyTask;
    private static SpecializedTasks();
    [ExtensionAttribute]
public static Task`1<T> AsNullable(Task`1<T> task);
    [NullableContextAttribute("2")]
public static Task`1<T> Default();
    public static Task`1<T> Null();
    public static Task`1<IReadOnlyList`1<T>> EmptyReadOnlyList();
    public static Task`1<IList`1<T>> EmptyList();
    [NullableContextAttribute("2")]
public static Task`1<ImmutableArray`1<T>> EmptyImmutableArray();
    public static Task`1<IEnumerable`1<T>> EmptyEnumerable();
    public static Task`1<T> FromResult(T t);
    [NullableContextAttribute("2")]
public static ValueTask`1<T[]> WhenAll(IEnumerable`1<ValueTask`1<T>> tasks);
    [AsyncStateMachineAttribute("Roslyn.Utilities.SpecializedTasks/<WhenAll>d__12`1")]
[ExtensionAttribute]
public static ValueTask`1<ImmutableArray`1<TResult>> WhenAll(IReadOnlyCollection`1<Task`1<TResult>> tasks);
    [NullableContextAttribute("2")]
public static ValueTask`1<TResult> TransformWithoutIntermediateCancellationExceptionAsync(Func`3<TArg, CancellationToken, ValueTask`1<TIntermediate>> func, Func`3<TIntermediate, TArg, TResult> transform, TArg arg, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static ValueTask`1<TResult> <TransformWithoutIntermediateCancellationExceptionAsync>g__UnwrapAndTransformAsync|13_0(ValueTask`1<TIntermediate> intermediateResult, Func`3<TIntermediate, TArg, TResult> transform, TArg arg, CancellationToken cancellationToken);
}
internal class Roslyn.Utilities.SpellChecker : object {
    private static string SerializationFormat;
    [CompilerGeneratedAttribute]
private Checksum <Checksum>k__BackingField;
    private BKTree _bkTree;
    public Checksum Checksum { get; }
    private bool Roslyn.Utilities.IObjectWritable.ShouldReuseInSerialization { get; }
    public SpellChecker(Checksum checksum, BKTree bKTree);
    public SpellChecker(Checksum checksum, IEnumerable`1<ReadOnlyMemory`1<char>> corpus);
    [CompilerGeneratedAttribute]
public sealed virtual Checksum get_Checksum();
    public IList`1<string> FindSimilarWords(string value);
    public IList`1<string> FindSimilarWords(string value, bool substringsAreSimilar);
    private sealed virtual override bool Roslyn.Utilities.IObjectWritable.get_ShouldReuseInSerialization();
    public sealed virtual void WriteTo(ObjectWriter writer);
    internal static SpellChecker TryReadFrom(ObjectReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StreamExtensions : object {
    [ExtensionAttribute]
public static int TryReadAll(Stream stream, Byte[] buffer, int offset, int count);
    [ExtensionAttribute]
public static Byte[] ReadAllBytes(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringEscapeEncoder : object {
    [ExtensionAttribute]
public static string Escape(string text, char escapePrefix, Char[] prohibitedCharacters);
    [ExtensionAttribute]
public static string Unescape(string text, char escapePrefix);
    private static int ParseHex(string text, int start, int length);
    private static bool IsHexDigit(char ch);
    private static int GetHexValue(char ch);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.StringExtensions : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ImmutableArray`1<string> s_lazyNumerals;
    private static Func`2<char, char> s_toLower;
    private static Func`2<char, char> s_toUpper;
    private static string AttributeSuffix;
    private static StringExtensions();
    internal static string GetNumeral(int number);
    [ExtensionAttribute]
public static string Join(IEnumerable`1<string> source, string separator);
    [ExtensionAttribute]
public static bool LooksLikeInterfaceName(string name);
    [ExtensionAttribute]
public static bool LooksLikeTypeParameterName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToPascalCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static string ToCamelCase(string shortName, bool trimLeadingTypePrefix);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
private static string ConvertCase(string shortName, bool trimLeadingTypePrefix, Func`2<char, char> convert);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrTypeName(string name);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static bool IsValidClrNamespaceName(string name);
    [ExtensionAttribute]
internal static string GetWithSingleAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, String& result);
    [ExtensionAttribute]
internal static string GetWithoutAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool TryGetWithoutAttributeSuffix(string name, bool isCaseSensitive, String& result);
    [ExtensionAttribute]
internal static bool HasAttributeSuffix(string name, bool isCaseSensitive);
    [ExtensionAttribute]
internal static bool IsValidUnicodeString(string str);
    [ExtensionAttribute]
internal static string Unquote(string arg);
    [ExtensionAttribute]
internal static string Unquote(string arg, Boolean& quoted);
    [ExtensionAttribute]
internal static char First(string arg);
    [ExtensionAttribute]
internal static char Last(string arg);
    [ExtensionAttribute]
internal static bool All(string arg, Predicate`1<char> predicate);
    [ExtensionAttribute]
public static int GetCaseInsensitivePrefixLength(string string1, string string2);
    [ExtensionAttribute]
public static int GetCaseSensitivePrefixLength(string string1, string string2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.StringTable : object {
    private static int LocalSizeBits;
    private static int LocalSize;
    private static int LocalSizeMask;
    private static int SharedSizeBits;
    private static int SharedSize;
    private static int SharedSizeMask;
    private static int SharedBucketBits;
    private static int SharedBucketSize;
    private static int SharedBucketSizeMask;
    private Entry[] _localTable;
    private static Entry[] s_sharedTable;
    private int _localRandom;
    private static int s_sharedRandom;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ObjectPool`1<StringTable> _pool;
    private static ObjectPool`1<StringTable> s_staticPool;
    private StringTable(ObjectPool`1<StringTable> pool);
    private static StringTable();
    private static ObjectPool`1<StringTable> CreatePool();
    public static StringTable GetInstance();
    public void Free();
    internal string Add(Char[] chars, int start, int len);
    internal string Add(string chars, int start, int len);
    internal string Add(char chars);
    internal string Add(StringBuilder chars);
    internal string Add(string chars);
    private static string FindSharedEntry(Char[] chars, int start, int len, int hashCode);
    private static string FindSharedEntry(string chars, int start, int len, int hashCode);
    [NullableContextAttribute("0")]
private static string FindSharedEntryASCII(int hashCode, ReadOnlySpan`1<byte> asciiChars);
    [NullableContextAttribute("2")]
private static string FindSharedEntry(char chars, int hashCode);
    private static string FindSharedEntry(StringBuilder chars, int hashCode);
    private static string FindSharedEntry(string chars, int hashCode);
    private string AddItem(Char[] chars, int start, int len, int hashCode);
    private string AddItem(string chars, int start, int len, int hashCode);
    private string AddItem(char chars, int hashCode);
    private string AddItem(StringBuilder chars, int hashCode);
    private void AddCore(string chars, int hashCode);
    private void AddSharedEntry(int hashCode, string text);
    internal static string AddShared(StringBuilder chars);
    private static string AddSharedSlow(int hashCode, StringBuilder builder);
    [NullableContextAttribute("0")]
internal static string AddSharedUtf8(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("0")]
private static string AddSharedSlow(int hashCode, ReadOnlySpan`1<byte> utf8Bytes, bool isAscii);
    private static void AddSharedSlow(int hashCode, string text);
    private static int LocalIdxFromHash(int hash);
    private static int SharedIdxFromHash(int hash);
    private int LocalNextRandom();
    private static int SharedNextRandom();
    internal static bool TextEquals(string array, string text, int start, int length);
    internal static bool TextEquals(string array, StringBuilder text);
    [NullableContextAttribute("0")]
internal static bool TextEqualsASCII(string text, ReadOnlySpan`1<byte> ascii);
    [NullableContextAttribute("0")]
internal static bool TextEquals(string array, ReadOnlySpan`1<char> text);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.SyntaxPath : object {
    [NullableAttribute("1")]
private List`1<PathSegment> _segments;
    private int _kind;
    private bool _trackKinds;
    public SyntaxPath(SyntaxNodeOrToken nodeOrToken, bool trackKinds);
    private void AddSegment(SyntaxNodeOrToken nodeOrToken);
    public bool TryResolve(SyntaxNode root, SyntaxNodeOrToken& nodeOrToken);
    private SyntaxNodeOrToken FindChild(SyntaxNodeOrToken current, PathSegment segment);
    [NullableContextAttribute("1")]
public bool TryResolve(SyntaxTree syntaxTree, CancellationToken cancellationToken, TNode& node);
    public bool TryResolve(SyntaxNode root, TNode& node);
    public static bool op_Equality(SyntaxPath left, SyntaxPath right);
    public static bool op_Inequality(SyntaxPath left, SyntaxPath right);
    public virtual bool Equals(object obj);
    public bool Equals(SyntaxPath other);
    public virtual int GetHashCode();
    private int GetSegmentHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskExtensions : object {
    [ExtensionAttribute]
public static T WaitAndGetResult(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static T WaitAndGetResult_CanCallOnBackground(Task`1<T> task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task`1<TInput> task, Func`2<Task`1<TInput>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task`1<TInput> task, Action`1<Task`1<TInput>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWith(Task task, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWith(Task task, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeContinueWithFromAsync(Task task, Func`2<Task, Task`1<TResult>> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeContinueWithFromAsync(Task`1<TInput> task, Func`2<Task`1<TInput>, Task> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task ContinueWithAfterDelayFromAsync(Task task, Func`2<Task, Task> continuationFunction, CancellationToken cancellationToken, TimeSpan delay, IExpeditableDelaySource delaySource, TaskContinuationOptions taskContinuationOptions, TaskScheduler scheduler);
    internal static void ReportNonFatalError(Task task, object continuationFunction);
    private static void ReportNonFatalErrorWorker(Task task, object continuationFunction);
    [ExtensionAttribute]
public static Task ReportNonFatalErrorAsync(Task task);
    [ExtensionAttribute]
public static Task ReportNonFatalErrorUnlessCancelledAsync(Task task, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void VerifyCompleted(Task task);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static TResult <SafeContinueWith>g__outerFunction|5_0(Task t, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TaskFactoryExtensions : object {
    [ExtensionAttribute]
public static Task SafeStartNew(TaskFactory factory, Action action, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNew(TaskFactory factory, Func`1<TResult> func, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task SafeStartNewFromAsync(TaskFactory factory, Func`1<Task> actionAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
    [ExtensionAttribute]
public static Task`1<TResult> SafeStartNewFromAsync(TaskFactory factory, Func`1<Task`1<TResult>> funcAsync, CancellationToken cancellationToken, TaskScheduler scheduler);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.TaskQueue : object {
    [CompilerGeneratedAttribute]
private IAsynchronousOperationListener <Listener>k__BackingField;
    [CompilerGeneratedAttribute]
private TaskScheduler <Scheduler>k__BackingField;
    private object _gate;
    private Task _latestTask;
    public IAsynchronousOperationListener Listener { get; }
    public TaskScheduler Scheduler { get; }
    public Task LastScheduledTask { get; }
    public TaskQueue(IAsynchronousOperationListener operationListener, TaskScheduler taskScheduler);
    [CompilerGeneratedAttribute]
public IAsynchronousOperationListener get_Listener();
    [CompilerGeneratedAttribute]
public TaskScheduler get_Scheduler();
    public Task get_LastScheduledTask();
    private IAsyncToken BeginOperation(string taskName);
    private static TTask EndOperation(IAsyncToken token, TTask task);
    public Task ScheduleTask(string taskName, Action operation, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(string taskName, Func`1<T> operation, CancellationToken cancellationToken);
    public Task ScheduleTask(string taskName, Func`1<Task> operation, CancellationToken cancellationToken);
    public Task`1<T> ScheduleTask(string taskName, Func`1<Task`1<T>> operation, CancellationToken cancellationToken);
    private Task ScheduleTaskInProgress(Action operation, CancellationToken cancellationToken);
    private Task`1<T> ScheduleTaskInProgress(Func`1<T> operation, CancellationToken cancellationToken);
    private Task ScheduleTaskInProgress(Func`1<Task> operation, CancellationToken cancellationToken);
    private Task`1<T> ScheduleTaskInProgress(Func`1<Task`1<T>> operation, CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.TextChangeRangeExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Nullable`1<TextChangeRange> Accumulate(Nullable`1<TextChangeRange> accumulatedTextChangeSoFar, IEnumerable`1<TextChangeRange> changesInNextVersion);
    [ExtensionAttribute]
public static TextChangeRange ToTextChangeRange(TextChange textChange);
    public static ImmutableArray`1<TextChangeRange> Merge(ImmutableArray`1<TextChangeRange> oldChanges, ImmutableArray`1<TextChangeRange> newChanges);
    [ExtensionAttribute]
private static int NewEnd(TextChangeRange range);
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__tryGetNextOldChange|2_0(<>c__DisplayClass2_0& );
    [CompilerGeneratedAttribute]
internal static bool <Merge>g__tryGetNextNewChange|2_1(<>c__DisplayClass2_0& );
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__addAndAdjustOldDelta|2_2(ArrayBuilder`1<TextChangeRange> builder, Int32& oldDelta, TextChangeRange oldChange);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__adjustAndAddNewChange|2_3(ArrayBuilder`1<TextChangeRange> builder, int oldDelta, UnadjustedNewChange newChange);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static void <Merge>g__add|2_4(ArrayBuilder`1<TextChangeRange> builder, TextChangeRange change);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Roslyn.Utilities.TopologicalSorter : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore);
    [ExtensionAttribute]
public static IEnumerable`1<T> TopologicalSort(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
    private static void Visit(T item, Func`2<T, IEnumerable`1<T>> itemsBefore, List`1<T> result, HashSet`1<T> visited);
    private static Func`2<T, IEnumerable`1<T>> CreateCombinedItemsBefore(IEnumerable`1<T> items, Func`2<T, IEnumerable`1<T>> itemsBefore, Func`2<T, IEnumerable`1<T>> itemsAfter);
}
internal static class Roslyn.Utilities.UnicodeCharacterUtilities : object {
    public static bool IsIdentifierStartCharacter(char ch);
    public static bool IsIdentifierPartCharacter(char ch);
    [NullableContextAttribute("2")]
public static bool IsValidIdentifier(string name);
    private static bool IsLetterChar(UnicodeCategory cat);
    private static bool IsCombiningChar(UnicodeCategory cat);
    private static bool IsDecimalDigitChar(UnicodeCategory cat);
    private static bool IsConnectingChar(UnicodeCategory cat);
    internal static bool IsFormattingChar(char ch);
    private static bool IsFormattingChar(UnicodeCategory cat);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Roslyn.Utilities.ValueSource`1 : object {
    public abstract virtual bool TryGetValue(T& value);
    public abstract virtual T GetValue(CancellationToken cancellationToken);
    public abstract virtual Task`1<T> GetValueAsync(CancellationToken cancellationToken);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.ValueSourceExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static T GetValueOrNull(Optional`1<T> optional);
    [ExtensionAttribute]
internal static T GetValueOrDefault(Optional`1<T> optional);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static T GetValueOrNull(ValueSource`1<Optional`1<T>> optional, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static T GetValueOrDefault(ValueSource`1<Optional`1<T>> optional, CancellationToken cancellationToken);
}
internal static class Roslyn.Utilities.ValueTaskFactory : object {
    public static ValueTask CompletedTask { get; }
    [NullableContextAttribute("1")]
public static ValueTask`1<T> FromResult(T result);
    public static ValueTask get_CompletedTask();
}
[IsReadOnlyAttribute]
internal class Roslyn.Utilities.VoidResult : ValueType {
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(VoidResult other);
}
internal static class Roslyn.Utilities.WeakEventHandler`1 : object {
    [NullableContextAttribute("1")]
public static EventHandler`1<TArgs> Create(TTarget target, Action`3<TTarget, object, TArgs> invoker);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.WeakReferenceExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static T GetTarget(WeakReference`1<T> reference);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsNull(WeakReference`1<T> reference);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.WeakSet`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<ReferenceHolder`1<T>> _values;
    public bool Add(T value);
    public bool Contains(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Roslyn.Utilities.WordSimilarityChecker : object {
    private CacheResult _lastAreSimilarResult;
    private string _source;
    private EditDistance _editDistance;
    private int _threshold;
    private bool _substringsAreSimilar;
    private static object s_poolGate;
    private static Stack`1<WordSimilarityChecker> s_pool;
    private static WordSimilarityChecker();
    public static WordSimilarityChecker Allocate(string text, bool substringsAreSimilar);
    private void Initialize(string text, bool substringsAreSimilar);
    public void Free();
    public static bool AreSimilar(string originalText, string candidateText);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar);
    public static bool AreSimilar(string originalText, string candidateText, Double& similarityWeight);
    public static bool AreSimilar(string originalText, string candidateText, bool substringsAreSimilar, Double& similarityWeight);
    internal static int GetThreshold(string value);
    public bool AreSimilar(string candidateText);
    public bool AreSimilar(string candidateText, Double& similarityWeight);
    private bool AreSimilarWorker(string candidateText, Double& similarityWeight);
    private static double Penalty(string candidateText, string originalText);
}
[ExtensionAttribute]
internal static class Roslyn.Utilities.YieldAwaitableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredYieldAwaitable ConfigureAwait(YieldAwaitable awaitable, bool continueOnCapturedContext);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[IsReadOnlyAttribute]
internal class System.Index : ValueType {
    private int _value;
    public static Index Start { get; }
    public static Index End { get; }
    public int Value { get; }
    public bool IsFromEnd { get; }
    public Index(int value, bool fromEnd);
    private Index(int value);
    public static Index get_Start();
    public static Index get_End();
    public static Index FromStart(int value);
    public static Index FromEnd(int value);
    public int get_Value();
    public bool get_IsFromEnd();
    public int GetOffset(int length);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Index other);
    public virtual int GetHashCode();
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.EnumerableExtensions : object {
    [ExtensionAttribute]
public static bool SequenceEqual(IEnumerable`1<T> first, IEnumerable`1<T> second, Func`3<T, T, bool> comparer);
    [ExtensionAttribute]
public static T AggregateOrDefault(IEnumerable`1<T> source, Func`3<T, T, T> func);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class System.Linq.ImmutableSegmentedListExtensions : object {
    [ExtensionAttribute]
public static bool All(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static bool Any(Builder<T> builder);
    [ExtensionAttribute]
public static bool Any(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList);
    [ExtensionAttribute]
public static T Last(Builder<T> builder);
    [ExtensionAttribute]
public static T Last(ImmutableSegmentedList`1<T> immutableList, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static IEnumerable`1<TResult> Select(ImmutableSegmentedList`1<T> immutableList, Func`2<T, TResult> selector);
}
[ExtensionAttribute]
internal static class System.Linq.RoslynEnumerable : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static SegmentedList`1<TSource> ToSegmentedList(IEnumerable`1<TSource> source);
}
[IsReadOnlyAttribute]
internal class System.Range : ValueType {
    [CompilerGeneratedAttribute]
private Index <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private Index <End>k__BackingField;
    public Index Start { get; }
    public Index End { get; }
    public static Range All { get; }
    public Range(Index start, Index end);
    [CompilerGeneratedAttribute]
public Index get_Start();
    [CompilerGeneratedAttribute]
public Index get_End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static Range StartAt(Index start);
    public static Range EndAt(Index end);
    public static Range get_All();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <ToString>g__getFromEndSpecifier|10_0(Index index);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
internal static string <ToString>g__toString|10_1(Index index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Arguments>k__BackingField;
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    [CompilerGeneratedAttribute]
public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
internal class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
[EditorBrowsableAttribute("1")]
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
internal class System.Runtime.CompilerServices.RestrictedInternalsVisibleToAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ImmutableArray`1<string> <AllowedNamespaces>k__BackingField;
    public string AssemblyName { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<string> AllowedNamespaces { get; }
    public RestrictedInternalsVisibleToAttribute(string assemblyName, String[] allowedNamespaces);
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<string> get_AllowedNamespaces();
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class System.Text.Rune : ValueType {
    private static char HighSurrogateStart;
    private static char LowSurrogateStart;
    private static int HighSurrogateRange;
    private static byte IsWhiteSpaceFlag;
    private static byte IsLetterOrDigitFlag;
    private static byte UnicodeCategoryMask;
    private UInt32 _value;
    private static ReadOnlySpan`1<byte> AsciiCharInfo { get; }
    private string DebuggerDisplay { get; }
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    public Rune(UInt32 value);
    private Rune(UInt32 scalarValue, bool unused);
    private static ReadOnlySpan`1<byte> get_AsciiCharInfo();
    public static bool op_Equality(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    public static Rune op_Explicit(UInt32 value);
    public static Rune op_Explicit(int value);
    private string get_DebuggerDisplay();
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    private static Rune ChangeCaseCultureAware(Rune rune, CultureInfo culture, bool toUpper);
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    public static Rune GetRuneAt(string input, int index);
    public static bool IsValid(int value);
    public static bool IsValid(UInt32 value);
    internal static int ReadFirstRuneFromUtf16Buffer(ReadOnlySpan`1<char> input);
    private static int ReadRuneFromString(string input, int index);
    public virtual string ToString();
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    public static bool TryGetRuneAt(string input, int index, Rune& value);
    internal static Rune UnsafeCreate(UInt32 scalarValue);
    public static double GetNumericValue(Rune value);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    private static UnicodeCategory GetUnicodeCategoryNonAscii(Rune value);
    private static bool IsCategoryLetter(UnicodeCategory category);
    private static bool IsCategoryLetterOrDecimalDigit(UnicodeCategory category);
    private static bool IsCategoryNumber(UnicodeCategory category);
    private static bool IsCategoryPunctuation(UnicodeCategory category);
    private static bool IsCategorySeparator(UnicodeCategory category);
    private static bool IsCategorySymbol(UnicodeCategory category);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsWhiteSpace(Rune value);
    public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
}
internal static class System.Text.Unicode.Utf16Utility : object {
    internal static bool AllCharsInUInt32AreAscii(UInt32 value);
    internal static bool AllCharsInUInt64AreAscii(ulong value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToLowercase(UInt32 value);
    internal static UInt32 ConvertAllAsciiCharsInUInt32ToUppercase(UInt32 value);
    internal static bool UInt32ContainsAnyLowercaseAsciiChar(UInt32 value);
    internal static bool UInt32ContainsAnyUppercaseAsciiChar(UInt32 value);
    internal static bool UInt32OrdinalIgnoreCaseAscii(UInt32 valueA, UInt32 valueB);
    internal static bool UInt64OrdinalIgnoreCaseAscii(ulong valueA, ulong valueB);
}
internal static class System.Text.UnicodeDebug : object {
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsHighSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsLowSurrogateCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidCodePoint(UInt32 codePoint);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidScalar(UInt32 scalarValue);
    [ConditionalAttribute("DEBUG")]
internal static void AssertIsValidSupplementaryPlaneScalar(UInt32 scalarValue);
    private static string ToHexString(UInt32 codePoint);
}
internal static class System.Text.UnicodeUtility : object {
    public static UInt32 ReplacementChar;
    public static int GetPlane(UInt32 codePoint);
    public static UInt32 GetScalarFromUtf16SurrogatePair(UInt32 highSurrogateCodePoint, UInt32 lowSurrogateCodePoint);
    public static int GetUtf16SequenceLength(UInt32 value);
    public static void GetUtf16SurrogatesFromSupplementaryPlaneScalar(UInt32 value, Char& highSurrogateCodePoint, Char& lowSurrogateCodePoint);
    public static int GetUtf8SequenceLength(UInt32 value);
    public static bool IsAsciiCodePoint(UInt32 value);
    public static bool IsBmpCodePoint(UInt32 value);
    public static bool IsHighSurrogateCodePoint(UInt32 value);
    public static bool IsInRangeInclusive(UInt32 value, UInt32 lowerBound, UInt32 upperBound);
    public static bool IsLowSurrogateCodePoint(UInt32 value);
    public static bool IsSurrogateCodePoint(UInt32 value);
    public static bool IsValidCodePoint(UInt32 codePoint);
    public static bool IsValidUnicodeScalar(UInt32 value);
}
