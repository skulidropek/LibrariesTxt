internal static class FxResources.Microsoft.CSharp.SR : object {
}
internal enum Microsoft.CSharp.ExtentFlags : Enum {
    public int value__;
    public static ExtentFlags EF_FULL;
    public static ExtentFlags EF_SINGLESTMT;
    public static ExtentFlags EF_POSSIBLE_GENERIC_NAME;
    public static ExtentFlags EF_PREFER_LEFT_NODE;
    public static ExtentFlags EF_IGNORE_TOKEN_STREAM;
    public static ExtentFlags EF_POSSIBLE_EXPRESSION;
    public static ExtentFlags EF_TOPLEVELONLY;
}
[EditorBrowsableAttribute("1")]
public static class Microsoft.CSharp.RuntimeBinder.Binder : object {
    public static CallSiteBinder BinaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder Convert(CSharpBinderFlags flags, Type type, Type context);
    public static CallSiteBinder GetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder GetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder Invoke(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder InvokeMember(CSharpBinderFlags flags, string name, IEnumerable`1<Type> typeArguments, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder InvokeConstructor(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder IsEvent(CSharpBinderFlags flags, string name, Type context);
    public static CallSiteBinder SetIndex(CSharpBinderFlags flags, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder SetMember(CSharpBinderFlags flags, string name, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public static CallSiteBinder UnaryOperation(CSharpBinderFlags flags, ExpressionType operation, Type context, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
}
internal static class Microsoft.CSharp.RuntimeBinder.BinderHelper : object {
    internal static DynamicMetaObject Bind(DynamicMetaObjectBinder action, RuntimeBinder binder, IEnumerable`1<DynamicMetaObject> args, IEnumerable`1<CSharpArgumentInfo> arginfos, DynamicMetaObject onBindingError);
    private static bool IsTypeOfStaticCall(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload);
    private static bool IsComObject(object obj);
    internal static bool IsWindowsRuntimeObject(DynamicMetaObject obj);
    private static bool IsTransparentProxy(object obj);
    private static bool IsDynamicallyTypedRuntimeProxy(DynamicMetaObject argument, CSharpArgumentInfo info);
    private static BindingRestrictions DeduceArgumentRestriction(int parameterIndex, ICSharpInvokeOrInvokeMemberBinder callPayload, DynamicMetaObject argument, CSharpArgumentInfo info);
    private static Expression ConvertResult(Expression binding, DynamicMetaObjectBinder action);
    private static Type GetTypeForErrorMetaObject(DynamicMetaObjectBinder action, DynamicMetaObject arg0);
    private static bool IsIncrementOrDecrementActionOnLocal(DynamicMetaObjectBinder action);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.BinderHelper/<Cons>d__10`1")]
internal static IEnumerable`1<T> Cons(T sourceHead, IEnumerable`1<T> sourceTail);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.BinderHelper/<Cons>d__11`1")]
internal static IEnumerable`1<T> Cons(T sourceHead, IEnumerable`1<T> sourceMiddle, T sourceLast);
    internal static List`1<T> ToList(IEnumerable`1<T> source);
    internal static CallInfo CreateCallInfo(IEnumerable`1<CSharpArgumentInfo> argInfos, int discard);
}
[EditorBrowsableAttribute("1")]
public class Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfo : object {
    internal static CSharpArgumentInfo None;
    private CSharpArgumentInfoFlags _flags;
    private string _name;
    internal CSharpArgumentInfoFlags Flags { get; }
    internal string Name { get; }
    internal bool UseCompileTimeType { get; }
    internal bool LiteralConstant { get; }
    internal bool NamedArgument { get; }
    internal bool IsByRef { get; }
    internal bool IsOut { get; }
    internal bool IsStaticType { get; }
    private CSharpArgumentInfo(CSharpArgumentInfoFlags flags, string name);
    private static CSharpArgumentInfo();
    internal CSharpArgumentInfoFlags get_Flags();
    internal string get_Name();
    public static CSharpArgumentInfo Create(CSharpArgumentInfoFlags flags, string name);
    internal bool get_UseCompileTimeType();
    internal bool get_LiteralConstant();
    internal bool get_NamedArgument();
    internal bool get_IsByRef();
    internal bool get_IsOut();
    internal bool get_IsStaticType();
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags : Enum {
    public int value__;
    public static CSharpArgumentInfoFlags None;
    public static CSharpArgumentInfoFlags UseCompileTimeType;
    public static CSharpArgumentInfoFlags Constant;
    public static CSharpArgumentInfoFlags NamedArgument;
    public static CSharpArgumentInfoFlags IsRef;
    public static CSharpArgumentInfoFlags IsOut;
    public static CSharpArgumentInfoFlags IsStaticType;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationBinder : BinaryOperationBinder {
    private bool _isChecked;
    private CSharpBinaryOperationFlags _binopFlags;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    internal bool IsChecked { get; }
    internal bool IsLogicalOperation { get; }
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public CSharpBinaryOperationBinder(ExpressionType operation, bool isChecked, CSharpBinaryOperationFlags binaryOperationFlags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal bool get_IsChecked();
    internal bool get_IsLogicalOperation();
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public sealed virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
}
internal enum Microsoft.CSharp.RuntimeBinder.CSharpBinaryOperationFlags : Enum {
    public int value__;
    public static CSharpBinaryOperationFlags None;
    public static CSharpBinaryOperationFlags MemberAccess;
    public static CSharpBinaryOperationFlags LogicalOperation;
}
[FlagsAttribute]
[EditorBrowsableAttribute("1")]
public enum Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags : Enum {
    public int value__;
    public static CSharpBinderFlags None;
    public static CSharpBinderFlags CheckedContext;
    public static CSharpBinderFlags InvokeSimpleName;
    public static CSharpBinderFlags InvokeSpecialName;
    public static CSharpBinderFlags BinaryOperationLogical;
    public static CSharpBinderFlags ConvertExplicit;
    public static CSharpBinderFlags ConvertArrayIndex;
    public static CSharpBinderFlags ResultIndexed;
    public static CSharpBinderFlags ValueFromCompoundAssignment;
    public static CSharpBinderFlags ResultDiscarded;
}
internal enum Microsoft.CSharp.RuntimeBinder.CSharpCallFlags : Enum {
    public int value__;
    public static CSharpCallFlags None;
    public static CSharpCallFlags SimpleNameCall;
    public static CSharpCallFlags EventHookup;
    public static CSharpCallFlags ResultDiscarded;
}
internal enum Microsoft.CSharp.RuntimeBinder.CSharpConversionKind : Enum {
    public int value__;
    public static CSharpConversionKind ImplicitConversion;
    public static CSharpConversionKind ExplicitConversion;
    public static CSharpConversionKind ArrayCreationConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpConvertBinder : ConvertBinder {
    private CSharpConversionKind _conversionKind;
    private bool _isChecked;
    private Type _callingContext;
    private RuntimeBinder _binder;
    internal CSharpConversionKind ConversionKind { get; }
    internal bool IsChecked { get; }
    internal Type CallingContext { get; }
    public CSharpConvertBinder(Type type, CSharpConversionKind conversionKind, bool isChecked, Type callingContext);
    internal CSharpConversionKind get_ConversionKind();
    internal bool get_IsChecked();
    internal Type get_CallingContext();
    public virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetIndexBinder : GetIndexBinder {
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public CSharpGetIndexBinder(Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpGetMemberBinder : GetMemberBinder {
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private bool _bResultIndexed;
    private RuntimeBinder _binder;
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    private bool System.Dynamic.IInvokeOnGetBinder.InvokeOnGet { get; }
    internal bool ResultIndexed { get; }
    public CSharpGetMemberBinder(string name, bool resultIndexed, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    private sealed virtual override bool System.Dynamic.IInvokeOnGetBinder.get_InvokeOnGet();
    internal bool get_ResultIndexed();
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeBinder : InvokeBinder {
    private CSharpCallFlags _flags;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    private string Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.Name { get; }
    private IList`1<Type> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.TypeArguments { get; }
    private CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.Flags { get; }
    private Type Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.CallingContext { get; }
    private IList`1<CSharpArgumentInfo> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ArgumentInfo { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Name();
    private sealed virtual override IList`1<Type> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_TypeArguments();
    private sealed virtual override CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Flags();
    private sealed virtual override Type Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_CallingContext();
    private sealed virtual override IList`1<CSharpArgumentInfo> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ArgumentInfo();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeConstructorBinder : DynamicMetaObjectBinder {
    private CSharpCallFlags _flags;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    public CSharpCallFlags Flags { get; }
    public Type CallingContext { get; }
    public IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public bool StaticCall { get; }
    public IList`1<Type> TypeArguments { get; }
    public string Name { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeConstructorBinder(CSharpCallFlags flags, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    public sealed virtual CSharpCallFlags get_Flags();
    public sealed virtual Type get_CallingContext();
    public sealed virtual IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public sealed virtual bool get_StaticCall();
    public sealed virtual IList`1<Type> get_TypeArguments();
    public sealed virtual string get_Name();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpInvokeMemberBinder : InvokeMemberBinder {
    private CSharpCallFlags _flags;
    private Type _callingContext;
    private List`1<Type> _typeArguments;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.StaticCall { get; }
    private CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.Flags { get; }
    private Type Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.CallingContext { get; }
    private IList`1<Type> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.TypeArguments { get; }
    private IList`1<CSharpArgumentInfo> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ArgumentInfo { get; }
    private bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.ResultDiscarded { get; }
    public CSharpInvokeMemberBinder(CSharpCallFlags flags, string name, Type callingContext, IEnumerable`1<Type> typeArguments, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_StaticCall();
    private sealed virtual override CSharpCallFlags Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Flags();
    private sealed virtual override Type Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_CallingContext();
    private sealed virtual override IList`1<Type> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_TypeArguments();
    private sealed virtual override IList`1<CSharpArgumentInfo> Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ArgumentInfo();
    private sealed virtual override bool Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_ResultDiscarded();
    public virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    private sealed virtual override string Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder.get_Name();
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpIsEventBinder : DynamicMetaObjectBinder {
    private string _name;
    private Type _callingContext;
    private RuntimeBinder _binder;
    internal string Name { get; }
    internal Type CallingContext { get; }
    public Type ReturnType { get; }
    public CSharpIsEventBinder(string name, Type callingContext);
    internal string get_Name();
    internal Type get_CallingContext();
    public sealed virtual Type get_ReturnType();
    public sealed virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetIndexBinder : SetIndexBinder {
    private bool _bIsCompoundAssignment;
    private bool _isChecked;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    internal bool IsCompoundAssignment { get; }
    internal bool IsChecked { get; }
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public CSharpSetIndexBinder(bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal bool get_IsCompoundAssignment();
    internal bool get_IsChecked();
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpSetMemberBinder : SetMemberBinder {
    private bool _bIsCompoundAssignment;
    private bool _isChecked;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    internal bool IsCompoundAssignment { get; }
    internal bool IsChecked { get; }
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public CSharpSetMemberBinder(string name, bool isCompoundAssignment, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal bool get_IsCompoundAssignment();
    internal bool get_IsChecked();
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal class Microsoft.CSharp.RuntimeBinder.CSharpUnaryOperationBinder : UnaryOperationBinder {
    private bool _isChecked;
    private Type _callingContext;
    private List`1<CSharpArgumentInfo> _argumentInfo;
    private RuntimeBinder _binder;
    internal bool IsChecked { get; }
    internal Type CallingContext { get; }
    internal IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public CSharpUnaryOperationBinder(ExpressionType operation, bool isChecked, Type callingContext, IEnumerable`1<CSharpArgumentInfo> argumentInfo);
    internal bool get_IsChecked();
    internal Type get_CallingContext();
    internal IList`1<CSharpArgumentInfo> get_ArgumentInfo();
    public sealed virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
}
internal static class Microsoft.CSharp.RuntimeBinder.Error : object {
    internal static Exception InternalCompilerError();
    internal static Exception BindRequireArguments();
    internal static Exception BindCallFailedOverloadResolution();
    internal static Exception BindBinaryOperatorRequireTwoArguments();
    internal static Exception BindUnaryOperatorRequireOneArgument();
    internal static Exception BindBinaryAssignmentRequireTwoArguments();
    internal static Exception BindPropertyFailedMethodGroup(object p0);
    internal static Exception BindPropertyFailedEvent(object p0);
    internal static Exception BindInvokeFailedNonDelegate();
    internal static Exception BindImplicitConversionRequireOneArgument();
    internal static Exception BindExplicitConversionRequireOneArgument();
    internal static Exception BindBinaryAssignmentFailedNullReference();
    internal static Exception NullReferenceOnMemberException();
    internal static Exception BindCallToConditionalMethod(object p0);
    internal static Exception BindToVoidMethodButExpectResult();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Errors.CController : object {
    private CErrorFactory _errorFactory;
    public abstract virtual void SubmitError(CError pError);
    public CErrorFactory GetErrorFactory();
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.CError : object {
    private string _text;
    public string Text { get; }
    private static string ComputeString(ErrorCode code, String[] args);
    public void Initialize(ErrorCode code, String[] args);
    public string get_Text();
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.CErrorFactory : object {
    public CError CreateError(ErrorCode iErrorIndex, String[] args);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.CParameterizedError : object {
    private ErrorCode _errorNumber;
    private ErrArg[] _arguments;
    public void Initialize(ErrorCode errorNumber, ErrArg[] arguments);
    public int GetParameterCount();
    public ErrArg GetParameter(int index);
    public ErrorCode GetErrorNumber();
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArg : object {
    public ErrArgKind eak;
    public ErrArgFlags eaf;
    internal MessageID ids;
    internal int n;
    internal SYMKIND sk;
    internal PredefinedName pdn;
    internal Name name;
    internal Symbol sym;
    internal string psz;
    internal CType pType;
    internal MethPropWithInstMemo mpwiMemo;
    internal SymWithTypeMemo swtMemo;
    public ErrArg(int n);
    public ErrArg(SYMKIND sk);
    public ErrArg(Name name);
    public ErrArg(PredefinedName pdn);
    public ErrArg(string psz);
    public ErrArg(CType pType);
    public ErrArg(CType pType, ErrArgFlags eaf);
    public ErrArg(Symbol pSym);
    public ErrArg(Symbol pSym, ErrArgFlags eaf);
    public ErrArg(SymWithType swt);
    public ErrArg(MethPropWithInst mpwi);
    public static ErrArg op_Implicit(int n);
    public static ErrArg op_Implicit(SYMKIND sk);
    public static ErrArg op_Implicit(CType type);
    public static ErrArg op_Implicit(string psz);
    public static ErrArg op_Implicit(PredefinedName pdn);
    public static ErrArg op_Implicit(Name name);
    public static ErrArg op_Implicit(Symbol pSym);
    public static ErrArg op_Implicit(SymWithType swt);
    public static ErrArg op_Implicit(MethPropWithInst mpwi);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgFlags : Enum {
    public int value__;
    public static ErrArgFlags None;
    public static ErrArgFlags Ref;
    public static ErrArgFlags NoStr;
    public static ErrArgFlags RefOnly;
    public static ErrArgFlags Unique;
    public static ErrArgFlags UseGetErrorInfo;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgIds : ErrArgRef {
    public ErrArgIds(MessageID ids);
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.ErrArgKind : Enum {
    public int value__;
    public static ErrArgKind Int;
    public static ErrArgKind Hresult;
    public static ErrArgKind Ids;
    public static ErrArgKind SymKind;
    public static ErrArgKind Sym;
    public static ErrArgKind Type;
    public static ErrArgKind Name;
    public static ErrArgKind Str;
    public static ErrArgKind PredefName;
    public static ErrArgKind LocNode;
    public static ErrArgKind Ptr;
    public static ErrArgKind SymWithType;
    public static ErrArgKind MethWithInst;
    public static ErrArgKind Expr;
    public static ErrArgKind Lim;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgNoRef : ErrArgRef {
    public ErrArgNoRef(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgRef : ErrArg {
    public ErrArgRef(int n);
    public ErrArgRef(Name name);
    public ErrArgRef(string psz);
    public ErrArgRef(Symbol sym);
    public ErrArgRef(CType pType);
    public ErrArgRef(SymWithType swt);
    public ErrArgRef(MethPropWithInst mpwi);
    public ErrArgRef(CType pType, ErrArgFlags eaf);
    public static ErrArgRef op_Implicit(string s);
    public static ErrArgRef op_Implicit(Name name);
    public static ErrArgRef op_Implicit(int n);
    public static ErrArgRef op_Implicit(Symbol sym);
    public static ErrArgRef op_Implicit(CType type);
    public static ErrArgRef op_Implicit(SymWithType swt);
    public static ErrArgRef op_Implicit(MethPropWithInst mpwi);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgRefOnly : ErrArgRef {
    public ErrArgRefOnly(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrArgSymKind : ErrArgRef {
    public ErrArgSymKind(Symbol sym);
}
public enum Microsoft.CSharp.RuntimeBinder.Errors.ErrorCode : Enum {
    public int value__;
    public static ErrorCode ERR_BadBinaryOps;
    public static ErrorCode ERR_IntDivByZero;
    public static ErrorCode ERR_BadIndexLHS;
    public static ErrorCode ERR_BadIndexCount;
    public static ErrorCode ERR_BadUnaryOp;
    public static ErrorCode ERR_NoImplicitConv;
    public static ErrorCode ERR_NoExplicitConv;
    public static ErrorCode ERR_ConstOutOfRange;
    public static ErrorCode ERR_AmbigBinaryOps;
    public static ErrorCode ERR_AmbigUnaryOp;
    public static ErrorCode ERR_ValueCantBeNull;
    public static ErrorCode ERR_WrongNestedThis;
    public static ErrorCode ERR_NoSuchMember;
    public static ErrorCode ERR_ObjectRequired;
    public static ErrorCode ERR_AmbigCall;
    public static ErrorCode ERR_BadAccess;
    public static ErrorCode ERR_MethDelegateMismatch;
    public static ErrorCode ERR_AssgLvalueExpected;
    public static ErrorCode ERR_NoConstructors;
    public static ErrorCode ERR_BadDelegateConstructor;
    public static ErrorCode ERR_PropertyLacksGet;
    public static ErrorCode ERR_ObjectProhibited;
    public static ErrorCode ERR_AssgReadonly;
    public static ErrorCode ERR_RefReadonly;
    public static ErrorCode ERR_AssgReadonlyStatic;
    public static ErrorCode ERR_RefReadonlyStatic;
    public static ErrorCode ERR_AssgReadonlyProp;
    public static ErrorCode ERR_AbstractBaseCall;
    public static ErrorCode ERR_RefProperty;
    public static ErrorCode ERR_ManagedAddr;
    public static ErrorCode ERR_FixedNotNeeded;
    public static ErrorCode ERR_UnsafeNeeded;
    public static ErrorCode ERR_BadBoolOp;
    public static ErrorCode ERR_MustHaveOpTF;
    public static ErrorCode ERR_CheckedOverflow;
    public static ErrorCode ERR_ConstOutOfRangeChecked;
    public static ErrorCode ERR_AmbigMember;
    public static ErrorCode ERR_SizeofUnsafe;
    public static ErrorCode ERR_FieldInitRefNonstatic;
    public static ErrorCode ERR_CallingFinalizeDepracated;
    public static ErrorCode ERR_CallingBaseFinalizeDeprecated;
    public static ErrorCode ERR_BadCastInFixed;
    public static ErrorCode ERR_NoImplicitConvCast;
    public static ErrorCode ERR_InaccessibleGetter;
    public static ErrorCode ERR_InaccessibleSetter;
    public static ErrorCode ERR_BadArity;
    public static ErrorCode ERR_BadTypeArgument;
    public static ErrorCode ERR_TypeArgsNotAllowed;
    public static ErrorCode ERR_HasNoTypeVars;
    public static ErrorCode ERR_NewConstraintNotSatisfied;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedRefType;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableEnum;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedNullableInterface;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedTyVar;
    public static ErrorCode ERR_GenericConstraintNotSatisfiedValType;
    public static ErrorCode ERR_TypeVarCantBeNull;
    public static ErrorCode ERR_BadRetType;
    public static ErrorCode ERR_CantInferMethTypeArgs;
    public static ErrorCode ERR_MethGrpToNonDel;
    public static ErrorCode ERR_RefConstraintNotSatisfied;
    public static ErrorCode ERR_ValConstraintNotSatisfied;
    public static ErrorCode ERR_CircularConstraint;
    public static ErrorCode ERR_BaseConstraintConflict;
    public static ErrorCode ERR_ConWithValCon;
    public static ErrorCode ERR_AmbigUDConv;
    public static ErrorCode ERR_PredefinedTypeNotFound;
    public static ErrorCode ERR_PredefinedTypeBadType;
    public static ErrorCode ERR_BindToBogus;
    public static ErrorCode ERR_CantCallSpecialMethod;
    public static ErrorCode ERR_BogusType;
    public static ErrorCode ERR_MissingPredefinedMember;
    public static ErrorCode ERR_LiteralDoubleCast;
    public static ErrorCode ERR_UnifyingInterfaceInstantiations;
    public static ErrorCode ERR_ConvertToStaticClass;
    public static ErrorCode ERR_GenericArgIsStaticClass;
    public static ErrorCode ERR_PartialMethodToDelegate;
    public static ErrorCode ERR_IncrementLvalueExpected;
    public static ErrorCode ERR_NoSuchMemberOrExtension;
    public static ErrorCode ERR_ValueTypeExtDelegate;
    public static ErrorCode ERR_BadArgCount;
    public static ErrorCode ERR_BadArgTypes;
    public static ErrorCode ERR_BadArgType;
    public static ErrorCode ERR_RefLvalueExpected;
    public static ErrorCode ERR_BadProtectedAccess;
    public static ErrorCode ERR_BindToBogusProp2;
    public static ErrorCode ERR_BindToBogusProp1;
    public static ErrorCode ERR_BadDelArgCount;
    public static ErrorCode ERR_BadDelArgTypes;
    public static ErrorCode ERR_AssgReadonlyLocal;
    public static ErrorCode ERR_RefReadonlyLocal;
    public static ErrorCode ERR_ReturnNotLValue;
    public static ErrorCode ERR_BadArgExtraRef;
    public static ErrorCode ERR_BadArgRef;
    public static ErrorCode ERR_AssgReadonly2;
    public static ErrorCode ERR_RefReadonly2;
    public static ErrorCode ERR_AssgReadonlyStatic2;
    public static ErrorCode ERR_RefReadonlyStatic2;
    public static ErrorCode ERR_AssgReadonlyLocalCause;
    public static ErrorCode ERR_RefReadonlyLocalCause;
    public static ErrorCode ERR_ThisStructNotInAnonMeth;
    public static ErrorCode ERR_DelegateOnNullable;
    public static ErrorCode ERR_BadCtorArgCount;
    public static ErrorCode ERR_BadExtensionArgTypes;
    public static ErrorCode ERR_BadInstanceArgType;
    public static ErrorCode ERR_BadArgTypesForCollectionAdd;
    public static ErrorCode ERR_InitializerAddHasParamModifiers;
    public static ErrorCode ERR_NonInvocableMemberCalled;
    public static ErrorCode ERR_NamedArgumentSpecificationBeforeFixedArgument;
    public static ErrorCode ERR_BadNamedArgument;
    public static ErrorCode ERR_BadNamedArgumentForDelegateInvoke;
    public static ErrorCode ERR_DuplicateNamedArgument;
    public static ErrorCode ERR_NamedArgumentUsedInPositional;
}
internal static class Microsoft.CSharp.RuntimeBinder.Errors.ErrorFacts : object {
    public static string GetMessage(ErrorCode code);
    public static string GetMessage(MessageID id);
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.ErrorHandling : object {
    private IErrorSink _errorSink;
    private UserStringBuilder _userStringBuilder;
    private CErrorFactory _errorFactory;
    public ErrorHandling(UserStringBuilder strBldr, IErrorSink sink, CErrorFactory factory);
    public void Error(ErrorCode id, ErrArg[] args);
    public void ErrorRef(ErrorCode id, ErrArgRef[] args);
    public void SubmitError(CParameterizedError error);
    public void MakeErrorLocArgs(CParameterizedError& error, ErrorCode id, ErrArg[] prgarg);
    public virtual void AddRelatedSymLoc(CParameterizedError err, Symbol sym);
    public virtual void AddRelatedTypeLoc(CParameterizedError err, CType pType);
    private void MakeErrorTreeArgs(CParameterizedError& error, ErrorCode id, ErrArg[] prgarg);
    public void MakeError(CParameterizedError& error, ErrorCode id, ErrArg[] args);
    private CError CreateError(ErrorCode iErrorIndex, String[] args);
    private void ErrorTreeArgs(ErrorCode id, ErrArg[] prgarg);
    public CError RealizeError(CParameterizedError parameterizedError);
}
internal interface Microsoft.CSharp.RuntimeBinder.Errors.IErrorSink {
    public abstract virtual void SubmitError(CParameterizedError error);
    public abstract virtual int ErrorCount();
}
internal enum Microsoft.CSharp.RuntimeBinder.Errors.MessageID : Enum {
    public int value__;
    public static MessageID SK_METHOD;
    public static MessageID SK_CLASS;
    public static MessageID SK_NAMESPACE;
    public static MessageID SK_FIELD;
    public static MessageID SK_PROPERTY;
    public static MessageID SK_UNKNOWN;
    public static MessageID SK_VARIABLE;
    public static MessageID SK_EVENT;
    public static MessageID SK_TYVAR;
    public static MessageID SK_ALIAS;
    public static MessageID ERRORSYM;
    public static MessageID NULL;
    public static MessageID GlobalNamespace;
    public static MessageID MethodGroup;
    public static MessageID AnonMethod;
    public static MessageID Lambda;
    public static MessageID AnonymousType;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.MethPropWithInstMemo : object {
    public Symbol sym;
    public AggregateType ats;
    public TypeArray typeArgs;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.SymWithTypeMemo : object {
    public Symbol sym;
    public AggregateType ats;
}
internal class Microsoft.CSharp.RuntimeBinder.Errors.UserStringBuilder : object {
    protected bool fHadUndisplayableStringInError;
    protected bool m_buildingInProgress;
    protected GlobalSymbolContext m_globalSymbols;
    protected StringBuilder m_strBuilder;
    public UserStringBuilder(GlobalSymbolContext globalSymbols);
    protected void BeginString();
    protected void EndString(String& s);
    public bool HadUndisplayableString();
    public void ResetUndisplayableStringFlag();
    protected void ErrSK(String& psz, SYMKIND sk);
    protected void ErrAppendParamList(TypeArray params, bool isVarargs, bool isParamArray);
    public void ErrAppendString(string str);
    public void ErrAppendChar(char ch);
    public void ErrAppendPrintf(string format, Object[] args);
    public void ErrAppendName(Name name);
    protected void ErrAppendMethodParentSym(MethodSymbol sym, SubstContext pcxt, TypeArray& substMethTyParams);
    protected void ErrAppendParentSym(Symbol sym, SubstContext pctx);
    protected void ErrAppendParentType(CType pType, SubstContext pctx);
    protected void ErrAppendParentCore(Symbol parent, SubstContext pctx);
    protected void ErrAppendTypeParameters(TypeArray params, SubstContext pctx, bool forClass);
    protected void ErrAppendMethod(MethodSymbol meth, SubstContext pctx, bool fArgs);
    protected void ErrAppendIndexer(IndexerSymbol indexer, SubstContext pctx);
    protected void ErrAppendProperty(PropertySymbol prop, SubstContext pctx);
    protected void ErrAppendEvent(EventSymbol event, SubstContext pctx);
    public void ErrAppendId(MessageID id);
    public void ErrAppendSym(Symbol sym, SubstContext pctx);
    public void ErrAppendSym(Symbol sym, SubstContext pctx, bool fArgs);
    public void ErrAppendType(CType pType, SubstContext pCtx);
    public void ErrAppendType(CType pType, SubstContext pctx, bool fArgs);
    public bool ErrArgToString(String& psz, ErrArg parg, Boolean& fUserStrings);
    protected bool IsDisplayableName(Name name);
    protected void CheckDisplayableName(Name name);
    protected NameManager GetNameManager();
    protected TypeManager GetTypeManager();
    protected BSYMMGR getBSymmgr();
    protected int GetTypeID(CType type);
    public void ErrId(String& s, MessageID id);
}
internal class Microsoft.CSharp.RuntimeBinder.ExpressionTreeCallRewriter : ExprVisitorBase {
    private Dictionary`2<EXPRCALL, Expression> _DictionaryOfParameters;
    private IEnumerable`1<Expression> _ListOfParameters;
    private TypeManager _typeManager;
    private int _currentParameterIndex;
    protected ExpressionTreeCallRewriter(TypeManager typeManager, IEnumerable`1<Expression> listOfParameters);
    public static Expression Rewrite(TypeManager typeManager, EXPR pExpr, IEnumerable`1<Expression> listOfParameters);
    protected virtual EXPR VisitSAVE(EXPRBINOP pExpr);
    protected virtual EXPR VisitCAST(EXPRCAST pExpr);
    protected virtual EXPR VisitCALL(EXPRCALL pExpr);
    private ExpressionEXPR GenerateLambda(EXPRCALL pExpr);
    private ExpressionEXPR GenerateCall(EXPRCALL pExpr);
    private ExpressionEXPR GenerateArrayIndex(EXPRCALL pExpr);
    private ExpressionEXPR GenerateConvert(EXPRCALL pExpr);
    private ExpressionEXPR GenerateProperty(EXPRCALL pExpr);
    private ExpressionEXPR GenerateField(EXPRCALL pExpr);
    private ExpressionEXPR GenerateInvoke(EXPRCALL pExpr);
    private ExpressionEXPR GenerateNew(EXPRCALL pExpr);
    private ExpressionEXPR GenerateConstantType(EXPRCALL pExpr);
    private ExpressionEXPR GenerateAssignment(EXPRCALL pExpr);
    private ExpressionEXPR GenerateBinaryOperator(EXPRCALL pExpr);
    private ExpressionEXPR GenerateUserDefinedBinaryOperator(EXPRCALL pExpr);
    private ExpressionEXPR GenerateUnaryOperator(EXPRCALL pExpr);
    private ExpressionEXPR GenerateUserDefinedUnaryOperator(EXPRCALL pExpr);
    private Expression GetExpression(EXPR pExpr);
    private object GetObject(EXPR pExpr);
    private Expression[] GetArgumentsFromArrayInit(EXPRARRINIT arrinit);
    private MethodInfo GetMethodInfoFromExpr(EXPRMETHODINFO methinfo);
    private ConstructorInfo GetConstructorInfoFromExpr(EXPRMETHODINFO methinfo);
    private PropertyInfo GetPropertyInfoFromExpr(EXPRPropertyInfo propinfo);
    private bool TypesAreEqual(Type t1, Type t2);
}
internal interface Microsoft.CSharp.RuntimeBinder.ICSharpInvokeOrInvokeMemberBinder {
    public bool StaticCall { get; }
    public bool ResultDiscarded { get; }
    public Type CallingContext { get; }
    public CSharpCallFlags Flags { get; }
    public string Name { get; }
    public IList`1<Type> TypeArguments { get; }
    public IList`1<CSharpArgumentInfo> ArgumentInfo { get; }
    public abstract virtual bool get_StaticCall();
    public abstract virtual bool get_ResultDiscarded();
    public abstract virtual Type get_CallingContext();
    public abstract virtual CSharpCallFlags get_Flags();
    public abstract virtual string get_Name();
    public abstract virtual IList`1<Type> get_TypeArguments();
    public abstract virtual IList`1<CSharpArgumentInfo> get_ArgumentInfo();
}
internal class Microsoft.CSharp.RuntimeBinder.ResetBindException : Exception {
}
internal class Microsoft.CSharp.RuntimeBinder.RuntimeBinder : object {
    private static object s_singletonLock;
    private static RuntimeBinder modreq(System.Runtime.CompilerServices.IsVolatile) s_instance;
    private SymbolTable _symbolTable;
    private CSemanticChecker _semanticChecker;
    private ExprFactory _exprFactory;
    private OutputContext _outputContext;
    private NameGenerator _nameGenerator;
    private BindingContext _bindingContext;
    private ExpressionBinder _binder;
    private RuntimeBinderController _controller;
    private object _bindLock;
    private SymbolLoader SymbolLoader { get; }
    private static RuntimeBinder();
    public static RuntimeBinder GetInstance();
    private SymbolLoader get_SymbolLoader();
    private void Reset();
    public Expression Bind(DynamicMetaObjectBinder payload, IEnumerable`1<Expression> parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    private Expression BindCore(DynamicMetaObjectBinder payload, IEnumerable`1<Expression> parameters, DynamicMetaObject[] args, DynamicMetaObject& deferredBinding);
    private bool DeferBinding(DynamicMetaObjectBinder payload, ArgumentObject[] arguments, DynamicMetaObject[] args, Dictionary`2<int, LocalVariableSymbol> dictionary, DynamicMetaObject& deferredBinding);
    private void InitializeCallingContext(DynamicMetaObjectBinder payload);
    private Expression CreateExpressionTreeFromResult(IEnumerable`1<Expression> parameters, ArgumentObject[] arguments, Scope pScope, EXPR pResult);
    private ArgumentObject[] CreateArgumentArray(DynamicMetaObjectBinder payload, IEnumerable`1<Expression> parameters, DynamicMetaObject[] args);
    private bool IsBinderThatCanHaveRefReceiver(DynamicMetaObjectBinder binder);
    private void PopulateSymbolTableWithPayloadInformation(DynamicMetaObjectBinder payload, Type callingType, ArgumentObject[] arguments);
    private void AddConversionsForArguments(ArgumentObject[] arguments);
    private EXPR DispatchPayload(DynamicMetaObjectBinder payload, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private void PopulateLocalScope(DynamicMetaObjectBinder payload, Scope pScope, ArgumentObject[] arguments, IEnumerable`1<Expression> parameterExpressions, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPRBOUNDLAMBDA GenerateBoundLambda(ArgumentObject[] arguments, Scope pScope, EXPR call);
    private EXPR CreateLocal(Type type, bool bIsOut, LocalVariableSymbol local);
    private EXPR CreateArgumentListEXPR(ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary, int startIndex, int endIndex);
    private EXPR CreateArgumentEXPR(ArgumentObject argument, LocalVariableSymbol local);
    private EXPRMEMGRP CreateMemberGroupEXPR(string Name, IList`1<Type> typeArguments, EXPR callingObject, SYMKIND kind);
    private EXPR CreateProperty(SymWithType swt, EXPR callingObject, BindingFlag flags);
    private EXPR CreateIndexer(SymWithType swt, EXPR callingObject, EXPR arguments, BindingFlag bindFlags);
    private EXPR CreateArray(EXPR callingObject, EXPR optionalIndexerArguments);
    private EXPR CreateField(SymWithType swt, EXPR callingObject);
    private EXPREVENT CreateEvent(SymWithType swt, EXPR callingObject);
    private EXPR CreateCallingObjectForCall(ICSharpInvokeOrInvokeMemberBinder payload, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPR BindCall(ICSharpInvokeOrInvokeMemberBinder payload, EXPR callingObject, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPR BindWinRTEventAccessor(EventWithType ewt, EXPR callingObject, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary, bool isAddAccessor);
    private void CheckForConditionalMethodError(EXPR pExpr);
    private EXPR ReorderArgumentsForNamedAndOptional(EXPR callingObject, EXPR pResult);
    private EXPR StripNamedArgument(EXPR pArg);
    private EXPR StripNamedArguments(EXPR pArg);
    private EXPR BindUnaryOperation(CSharpUnaryOperationBinder payload, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPR BindBinaryOperation(CSharpBinaryOperationBinder payload, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private static OperatorKind GetOperatorKind(ExpressionType p);
    private static OperatorKind GetOperatorKind(ExpressionType p, bool bIsLogical);
    private static string GetCLROperatorName(ExpressionType p);
    private EXPR BindProperty(DynamicMetaObjectBinder payload, ArgumentObject argument, LocalVariableSymbol local, EXPR optionalIndexerArguments, bool fEventsPermitted);
    private EXPR BindImplicitConversion(ArgumentObject[] arguments, Type returnType, Dictionary`2<int, LocalVariableSymbol> dictionary, bool bIsArrayCreationConversion);
    private EXPR BindExplicitConversion(ArgumentObject[] arguments, Type returnType, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPR BindAssignment(DynamicMetaObjectBinder payload, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private EXPR BindIsEvent(CSharpIsEventBinder binder, ArgumentObject[] arguments, Dictionary`2<int, LocalVariableSymbol> dictionary);
    private string GetName(DynamicMetaObjectBinder payload);
    private BindingFlag GetBindingFlags(DynamicMetaObjectBinder payload);
    [CompilerGeneratedAttribute]
private Type <CreateArgumentArray>b__22_8(DynamicMetaObjectBinder p, CSharpArgumentInfo argInfo, Expression param, DynamicMetaObject arg, int index);
}
internal class Microsoft.CSharp.RuntimeBinder.RuntimeBinderController : CController {
    public virtual void SubmitError(CError pError);
}
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderException : Exception {
    public RuntimeBinderException(string message);
    public RuntimeBinderException(string message, Exception innerException);
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.RuntimeBinderExtensions : object {
    private static Func`3<MemberInfo, MemberInfo, bool> s_MemberEquivalence;
    private static RuntimeBinderExtensions();
    [ExtensionAttribute]
public static bool IsEquivalentTo(Type t1, Type t2);
    [ExtensionAttribute]
public static bool IsNullableType(Type type);
    [ExtensionAttribute]
public static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
public static bool IsEquivalentTo(MemberInfo mi1, MemberInfo mi2);
    [ExtensionAttribute]
private static bool IsEquivalentTo(ParameterInfo pi1, ParameterInfo pi2, MethodBase method1, MethodBase method2);
    [ExtensionAttribute]
private static bool IsGenericallyEqual(Type t1, Type t2);
    [ExtensionAttribute]
private static bool IsGenericallyEquivalentTo(Type t1, Type t2, MemberInfo member1, MemberInfo member2);
    [ExtensionAttribute]
private static bool IsTypeParameterEquivalentToTypeInst(Type typeParam, Type typeInst, MemberInfo member);
    [ExtensionAttribute]
public static bool HasSameMetadataDefinitionAs(MemberInfo mi1, MemberInfo mi2);
}
public class Microsoft.CSharp.RuntimeBinder.RuntimeBinderInternalCompilerException : Exception {
    public RuntimeBinderInternalCompilerException(string message);
    public RuntimeBinderInternalCompilerException(string message, Exception innerException);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESS : Enum {
    public int value__;
    public static ACCESS ACC_UNKNOWN;
    public static ACCESS ACC_PRIVATE;
    public static ACCESS ACC_INTERNAL;
    public static ACCESS ACC_PROTECTED;
    public static ACCESS ACC_INTERNALPROTECTED;
    public static ACCESS ACC_PUBLIC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ACCESSERROR : Enum {
    public int value__;
    public static ACCESSERROR ACCESSERROR_NOACCESS;
    public static ACCESSERROR ACCESSERROR_NOACCESSTHRU;
    public static ACCESSERROR ACCESSERROR_NOERROR;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggCastResult : Enum {
    public int value__;
    public static AggCastResult Success;
    public static AggCastResult Failure;
    public static AggCastResult Abort;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.AggKindEnum : Enum {
    public int value__;
    public static AggKindEnum Unknown;
    public static AggKindEnum Class;
    public static AggKindEnum Delegate;
    public static AggKindEnum Interface;
    public static AggKindEnum Struct;
    public static AggKindEnum Enum;
    public static AggKindEnum Lim;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateDeclaration : Declaration {
    public AggregateSymbol Agg();
    public InputFile getInputFile();
    public Assembly GetAssembly();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateSymbol : NamespaceOrAggregateSymbol {
    public Type AssociatedSystemType;
    public Assembly AssociatedAssembly;
    private InputFile _infile;
    private AggregateType _atsInst;
    private AggregateType _pBaseClass;
    private AggregateType _pUnderlyingType;
    private TypeArray _ifaces;
    private TypeArray _ifacesAll;
    private TypeArray _typeVarsThis;
    private TypeArray _typeVarsAll;
    private TypeManager _pTypeManager;
    private MethodSymbol _pConvFirst;
    private AggKindEnum _aggKind;
    private bool _isLayoutError;
    private bool _isSource;
    private bool _isPredefined;
    private PredefinedType _iPredef;
    private bool _isAbstract;
    private bool _isSealed;
    private bool _isUnmanagedStruct;
    private bool _isManagedStruct;
    private bool _hasPubNoArgCtor;
    private bool _hasExternReference;
    private bool _isSkipUDOps;
    private bool _isComImport;
    private bool _isAnonymousType;
    private Nullable`1<bool> _hasConversion;
    public NamespaceOrAggregateSymbol Parent { get; }
    public AggregateSymbol GetBaseAgg();
    public AggregateType getThisType();
    public void InitFromInfile(InputFile infile);
    public bool FindBaseAgg(AggregateSymbol agg);
    public NamespaceOrAggregateSymbol get_Parent();
    public AggregateDeclaration DeclFirst();
    public AggregateDeclaration DeclOnly();
    public bool InAlias(KAID aid);
    public KAID GetModuleID();
    public KAID GetAssemblyID();
    public bool IsUnresolved();
    public bool isNested();
    public AggregateSymbol GetOuterAgg();
    public bool isPredefAgg(PredefinedType pt);
    public AggKindEnum AggKind();
    public void SetAggKind(AggKindEnum aggKind);
    public bool IsClass();
    public bool IsDelegate();
    public bool IsInterface();
    public bool IsStruct();
    public bool IsEnum();
    public bool IsValueType();
    public bool IsRefType();
    public bool IsStatic();
    public bool IsAnonymousType();
    public void SetAnonymousType(bool isAnonymousType);
    public bool IsAbstract();
    public void SetAbstract(bool abstract);
    public bool IsPredefined();
    public void SetPredefined(bool predefined);
    public PredefinedType GetPredefType();
    public void SetPredefType(PredefinedType predef);
    public bool IsLayoutError();
    public void SetLayoutError(bool layoutError);
    public bool IsSealed();
    public void SetSealed(bool sealed);
    public bool HasConversion(SymbolLoader pLoader);
    public void SetHasConversion();
    public bool IsUnmanagedStruct();
    public void SetUnmanagedStruct(bool unmanagedStruct);
    public bool IsManagedStruct();
    public void SetManagedStruct(bool managedStruct);
    public bool IsKnownManagedStructStatus();
    public bool HasPubNoArgCtor();
    public void SetHasPubNoArgCtor(bool hasPubNoArgCtor);
    public bool HasExternReference();
    public void SetHasExternReference(bool hasExternReference);
    public bool IsSkipUDOps();
    public void SetSkipUDOps(bool skipUDOps);
    public void SetComImport(bool comImport);
    public bool IsSource();
    public TypeArray GetTypeVars();
    public void SetTypeVars(TypeArray typeVars);
    public TypeArray GetTypeVarsAll();
    public AggregateType GetBaseClass();
    public void SetBaseClass(AggregateType baseClass);
    public AggregateType GetUnderlyingType();
    public void SetUnderlyingType(AggregateType underlyingType);
    public TypeArray GetIfaces();
    public void SetIfaces(TypeArray ifaces);
    public TypeArray GetIfacesAll();
    public void SetIfacesAll(TypeArray ifacesAll);
    public TypeManager GetTypeManager();
    public void SetTypeManager(TypeManager typeManager);
    public MethodSymbol GetFirstUDConversion();
    public void SetFirstUDConversion(MethodSymbol conv);
    public bool InternalsVisibleTo(Assembly assembly);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AggregateType : CType {
    private TypeArray _pTypeArgsThis;
    private TypeArray _pTypeArgsAll;
    private AggregateSymbol _pOwningAggregate;
    private AggregateType _baseType;
    private TypeArray _ifacesAll;
    private TypeArray _winrtifacesAll;
    public bool fConstraintsChecked;
    public bool fConstraintError;
    public bool fAllHidden;
    public bool fDiffHidden;
    public AggregateType outerType;
    public void SetOwningAggregate(AggregateSymbol agg);
    public AggregateSymbol GetOwningAggregate();
    public AggregateType GetBaseClass();
    public void SetTypeArgsThis(TypeArray pTypeArgsThis);
    public void SetTypeArgsAll(TypeArray outerTypeArgs);
    public bool AreAllTypeArgumentsUnitTypes(TypeArray typeArray);
    public TypeArray GetTypeArgsThis();
    public TypeArray GetTypeArgsAll();
    public TypeArray GetIfacesAll();
    public TypeArray GetWinRTCollectionIfacesAll(SymbolLoader pSymbolLoader);
    public TypeArray GetDelegateParameters(SymbolLoader pSymbolLoader);
    public CType GetDelegateReturnType(SymbolLoader pSymbolLoader);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AidContainer : ValueType {
    internal static AidContainer NullAidContainer;
    private object _value;
    public AidContainer(FileRecord file);
    private static AidContainer();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgInfos : object {
    public int carg;
    public TypeArray types;
    public bool fHasExprs;
    public List`1<EXPR> prgexpr;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArgumentListType : CType {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ARRAYMETHOD : Enum {
    public int value__;
    public static ARRAYMETHOD ARRAYMETH_LOAD;
    public static ARRAYMETHOD ARRAYMETH_LOADADDR;
    public static ARRAYMETHOD ARRAYMETH_STORE;
    public static ARRAYMETHOD ARRAYMETH_CTOR;
    public static ARRAYMETHOD ARRAYMETH_GETAT;
    public static ARRAYMETHOD ARRAYMETH_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ArrayType : CType {
    public int rank;
    private CType _pElementType;
    public CType GetElementType();
    public void SetElementType(CType pType);
    public CType GetBaseElementType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.AssemblyQualifiedNamespaceSymbol : ParentSymbol {
    public sealed virtual bool IsType();
    public sealed virtual bool IsNamespace();
    public sealed virtual AssemblyQualifiedNamespaceSymbol AsNamespace();
    public sealed virtual CType AsType();
    public NamespaceSymbol GetNS();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BetterType : Enum {
    public int value__;
    public static BetterType Same;
    public static BetterType Left;
    public static BetterType Right;
    public static BetterType Neither;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.BindingContext : object {
    [CompilerGeneratedAttribute]
private SymbolLoader <SymbolLoader>k__BackingField;
    public Declaration m_pParentDecl;
    [CompilerGeneratedAttribute]
private KAID <m_aidExternAliasLookupContext>k__BackingField;
    protected ExprFactory m_ExprFactory;
    protected OutputContext m_outputContext;
    protected NameGenerator m_pNameGenerator;
    protected InputFile m_pInputFile;
    protected AggregateSymbol m_pContainingAgg;
    protected CType m_pCurrentSwitchType;
    protected FieldSymbol m_pOriginalConstantField;
    protected FieldSymbol m_pCurrentFieldSymbol;
    protected LocalVariableSymbol m_pImplicitlyTypedLocal;
    protected Scope m_pOuterScope;
    protected Scope m_pFinallyScope;
    protected Scope m_pTryScope;
    protected Scope m_pCatchScope;
    protected Scope m_pCurrentScope;
    protected Scope m_pSwitchScope;
    protected EXPRBLOCK m_pCurrentBlock;
    protected List`1<EXPRBOUNDLAMBDA> m_ppamis;
    protected EXPRBOUNDLAMBDA m_pamiCurrent;
    protected UNSAFESTATES m_UnsafeState;
    protected int m_FinallyNestingCount;
    protected bool m_bInsideTryOfCatch;
    protected bool m_bInFieldInitializer;
    protected bool m_bInBaseConstructorCall;
    protected bool m_bAllowUnsafeBlocks;
    protected bool m_bIsOptimizingSwitchAndArrayInit;
    protected bool m_bShowReachability;
    protected bool m_bWrapNonExceptionThrows;
    protected bool m_bInRefactoring;
    protected bool m_bInAttribute;
    protected bool m_bflushLocalVariableTypesForEachStatement;
    protected bool m_bRespectSemanticsAndReportErrors;
    protected CType m_pInitType;
    protected IErrorSink m_returnErrorSink;
    [CompilerGeneratedAttribute]
private CSemanticChecker <SemanticChecker>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckedNormal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckedConstant>k__BackingField;
    public SymbolLoader SymbolLoader { get; private set; }
    public KAID m_aidExternAliasLookupContext { get; private set; }
    public CSemanticChecker SemanticChecker { get; private set; }
    public bool CheckedNormal { get; public set; }
    public bool CheckedConstant { get; public set; }
    protected BindingContext(CSemanticChecker pSemanticChecker, ExprFactory exprFactory, OutputContext outputContext, NameGenerator nameGenerator, bool bflushLocalVariableTypesForEachStatement, bool bAllowUnsafeBlocks, bool bIsOptimizingSwitchAndArrayInit, bool bShowReachability, bool bWrapNonExceptionThrows, bool bInRefactoring, KAID aidLookupContext);
    protected BindingContext(BindingContext parent);
    public static BindingContext CreateInstance(CSemanticChecker pSemanticChecker, ExprFactory exprFactory, OutputContext outputContext, NameGenerator nameGenerator, bool bflushLocalVariableTypesForEachStatement, bool bAllowUnsafeBlocks, bool bIsOptimizingSwitchAndArrayInit, bool bShowReachability, bool bWrapNonExceptionThrows, bool bInRefactoring, KAID aidLookupContext);
    [CompilerGeneratedAttribute]
public SymbolLoader get_SymbolLoader();
    [CompilerGeneratedAttribute]
private void set_SymbolLoader(SymbolLoader value);
    public Declaration ContextForMemberLookup();
    public OutputContext GetOutputContext();
    public virtual void Dispose();
    public bool InMethod();
    public bool InStaticMethod();
    public bool InConstructor();
    public bool InAnonymousMethod();
    public bool InFieldInitializer();
    public bool IsThisPointer(EXPR expr);
    public bool RespectReadonly();
    public bool IsUnsafeContext();
    public bool ReportUnsafeErrors();
    public AggregateSymbol ContainingAgg();
    public LocalVariableSymbol GetThisPointer();
    public UNSAFESTATES GetUnsafeState();
    [CompilerGeneratedAttribute]
public KAID get_m_aidExternAliasLookupContext();
    [CompilerGeneratedAttribute]
private void set_m_aidExternAliasLookupContext(KAID value);
    [CompilerGeneratedAttribute]
public CSemanticChecker get_SemanticChecker();
    [CompilerGeneratedAttribute]
private void set_SemanticChecker(CSemanticChecker value);
    public ExprFactory GetExprFactory();
    [CompilerGeneratedAttribute]
public bool get_CheckedNormal();
    [CompilerGeneratedAttribute]
public void set_CheckedNormal(bool value);
    [CompilerGeneratedAttribute]
public bool get_CheckedConstant();
    [CompilerGeneratedAttribute]
public void set_CheckedConstant(bool value);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BindingFlag : Enum {
    public int value__;
    public static BindingFlag BIND_RVALUEREQUIRED;
    public static BindingFlag BIND_MEMBERSET;
    public static BindingFlag BIND_FIXEDVALUE;
    public static BindingFlag BIND_ARGUMENTS;
    public static BindingFlag BIND_BASECALL;
    public static BindingFlag BIND_USINGVALUE;
    public static BindingFlag BIND_STMTEXPRONLY;
    public static BindingFlag BIND_TYPEOK;
    public static BindingFlag BIND_MAYBECONFUSEDNEGATIVECAST;
    public static BindingFlag BIND_METHODNOTOK;
    public static BindingFlag BIND_DECLNOTOK;
    public static BindingFlag BIND_NOPARAMS;
    public static BindingFlag BIND_SPECULATIVELY;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpFuncKind : Enum {
    public int value__;
    public static BinOpFuncKind BoolBinOp;
    public static BinOpFuncKind BoolBitwiseOp;
    public static BinOpFuncKind DecBinOp;
    public static BinOpFuncKind DelBinOp;
    public static BinOpFuncKind EnumBinOp;
    public static BinOpFuncKind IntBinOp;
    public static BinOpFuncKind PtrBinOp;
    public static BinOpFuncKind PtrCmpOp;
    public static BinOpFuncKind RealBinOp;
    public static BinOpFuncKind RefCmpOp;
    public static BinOpFuncKind ShiftOp;
    public static BinOpFuncKind StrBinOp;
    public static BinOpFuncKind StrCmpOp;
    public static BinOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpKind : Enum {
    public int value__;
    public static BinOpKind Add;
    public static BinOpKind Sub;
    public static BinOpKind Mul;
    public static BinOpKind Shift;
    public static BinOpKind Equal;
    public static BinOpKind Compare;
    public static BinOpKind Bitwise;
    public static BinOpKind BitXor;
    public static BinOpKind Logical;
    public static BinOpKind Lim;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BinOpMask : Enum {
    public int value__;
    public static BinOpMask None;
    public static BinOpMask Add;
    public static BinOpMask Sub;
    public static BinOpMask Mul;
    public static BinOpMask Shift;
    public static BinOpMask Equal;
    public static BinOpMask Compare;
    public static BinOpMask Bitwise;
    public static BinOpMask BitXor;
    public static BinOpMask Logical;
    public static BinOpMask Integer;
    public static BinOpMask Real;
    public static BinOpMask BoolNorm;
    public static BinOpMask Delegate;
    public static BinOpMask Enum;
    public static BinOpMask EnumUnder;
    public static BinOpMask UnderEnum;
    public static BinOpMask Ptr;
    public static BinOpMask PtrNum;
    public static BinOpMask NumPtr;
    public static BinOpMask VoidPtr;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.BodyType : Enum {
    public int value__;
    public static BodyType NormalBlock;
    public static BodyType StatementExpression;
    public static BodyType ReturnedExpression;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.BoundLambdaType : CType {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.BSYMMGR : object {
    internal HashSet`1<KAID> bsetGlobalAssemblies;
    public PropertySymbol propNubValue;
    public MethodSymbol methNubCtor;
    private SymFactory _symFactory;
    private MiscSymFactory _miscSymFactory;
    private NamespaceSymbol _rootNS;
    protected List`1<AidContainer> ssetAssembly;
    protected NameManager m_nameTable;
    protected SYMTBL tableGlobal;
    protected Dictionary`2<TypeArrayKey, TypeArray> tableTypeArrays;
    private InputFile _infileUnres;
    private static int LOG2_SYMTBL_INITIAL_BUCKET_CNT;
    private static TypeArray s_taEmpty;
    public BSYMMGR(NameManager nameMgr, TypeManager typeManager);
    private static BSYMMGR();
    public void Init();
    public NameManager GetNameManager();
    public SYMTBL GetSymbolTable();
    public static TypeArray EmptyTypeArray();
    public AssemblyQualifiedNamespaceSymbol GetRootNsAid(KAID aid);
    public NamespaceSymbol GetRootNS();
    public KAID AidAlloc(InputFile sym);
    public BetterType CompareTypes(TypeArray ta1, TypeArray ta2);
    public SymFactory GetSymFactory();
    public MiscSymFactory GetMiscSymFactory();
    private void InitPreLoad();
    public Symbol LookupGlobalSymCore(Name name, ParentSymbol parent, symbmask_t kindmask);
    public Symbol LookupAggMember(Name name, AggregateSymbol agg, symbmask_t mask);
    public static Symbol LookupNextSym(Symbol sym, ParentSymbol parent, symbmask_t kindmask);
    public Name GetNameFromPtrs(object u1, object u2);
    public AssemblyQualifiedNamespaceSymbol GetNsAid(NamespaceSymbol ns, KAID aid);
    public TypeArray AllocParams(int ctype, CType[] prgtype);
    public TypeArray AllocParams(int ctype, TypeArray array, int offset);
    public TypeArray AllocParams(CType[] types);
    public TypeArray ConcatParams(CType[] prgtype1, CType[] prgtype2);
    public TypeArray ConcatParams(TypeArray pta1, TypeArray pta2);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CandidateFunctionMember : object {
    public MethPropWithInst mpwi;
    public TypeArray params;
    public byte ctypeLift;
    public bool fExpanded;
    public CandidateFunctionMember(MethPropWithInst mpwi, TypeArray params, byte ctypeLift, bool fExpanded);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.CConversions : object {
    public static bool FImpRefConv(SymbolLoader loader, CType typeSrc, CType typeDst);
    public static bool FExpRefConv(SymbolLoader loader, CType typeSrc, CType typeDst);
    public static bool HasGenericDelegateExplicitReferenceConversion(SymbolLoader loader, CType pSource, CType pTarget);
    public static bool FIsSameType(CType typeSrc, CType typeDst);
    public static bool FBoxingConv(SymbolLoader loader, CType typeSrc, CType typeDst);
    public static bool FWrappingConv(CType typeSrc, CType typeDst);
    public static bool FUnwrappingConv(CType typeSrc, CType typeDst);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckConstraintsFlags : Enum {
    public int value__;
    public static CheckConstraintsFlags None;
    public static CheckConstraintsFlags Outer;
    public static CheckConstraintsFlags NoDupErrors;
    public static CheckConstraintsFlags NoErrors;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CheckedContext : BindingContext {
    protected CheckedContext(BindingContext parentCtx, bool checkedNormal, bool checkedConstant);
    public static CheckedContext CreateInstance(BindingContext parentCtx, bool checkedNormal, bool checkedConstant);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CheckLvalueKind : Enum {
    public int value__;
    public static CheckLvalueKind Assignment;
    public static CheckLvalueKind OutParameter;
    public static CheckLvalueKind Increment;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CMemberLookupResults : object {
    [CompilerGeneratedAttribute]
private TypeArray <ContainingTypes>k__BackingField;
    private Name _pName;
    public TypeArray ContainingTypes { get; private set; }
    public CMemberLookupResults(TypeArray containingTypes, Name name);
    [CompilerGeneratedAttribute]
public TypeArray get_ContainingTypes();
    [CompilerGeneratedAttribute]
private void set_ContainingTypes(TypeArray value);
    public CMethodIterator GetMethodIterator(CSemanticChecker pChecker, SymbolLoader pSymLoader, CType pObject, CType pQualifyingType, Declaration pContext, bool allowBogusAndInaccessible, bool allowExtensionMethods, int arity, EXPRFLAG flags, symbmask_t mask);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CNullable : object {
    private SymbolLoader _pSymbolLoader;
    private ExprFactory _exprFactory;
    private ErrorHandling _pErrorContext;
    public CNullable(SymbolLoader symbolLoader, ErrorHandling errorContext, ExprFactory exprFactory);
    private SymbolLoader GetSymbolLoader();
    private ExprFactory GetExprFactory();
    private ErrorHandling GetErrorContext();
    public static bool IsNullableConstructor(EXPR expr);
    public static EXPR StripNullableConstructor(EXPR pExpr);
    public EXPR BindValue(EXPR exprSrc);
    public EXPRCALL BindNew(EXPR pExprSrc);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstantStringConcatenation : Enum {
    public int value__;
    public static ConstantStringConcatenation NotAString;
    public static ConstantStringConcatenation NotYetCalculated;
    public static ConstantStringConcatenation Calculated;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstCastResult : Enum {
    public int value__;
    public static ConstCastResult Success;
    public static ConstCastResult Failure;
    public static ConstCastResult CheckFailure;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CONSTRESKIND : Enum {
    public int value__;
    public static CONSTRESKIND ConstTrue;
    public static CONSTRESKIND ConstFalse;
    public static CONSTRESKIND ConstNotConst;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CONSTVAL : object {
    private object _value;
    public object objectVal { get; public set; }
    public bool boolVal { get; public set; }
    public sbyte sbyteVal { get; }
    public byte byteVal { get; }
    public short shortVal { get; }
    public ushort ushortVal { get; }
    public int iVal { get; public set; }
    public UInt32 uiVal { get; public set; }
    public long longVal { get; public set; }
    public ulong ulongVal { get; public set; }
    public float floatVal { get; public set; }
    public double doubleVal { get; public set; }
    public decimal decVal { get; public set; }
    public char cVal { get; }
    public string strVal { get; public set; }
    internal CONSTVAL(object value);
    public object get_objectVal();
    public void set_objectVal(object value);
    public bool get_boolVal();
    public void set_boolVal(bool value);
    public sbyte get_sbyteVal();
    public byte get_byteVal();
    public short get_shortVal();
    public ushort get_ushortVal();
    public int get_iVal();
    public void set_iVal(int value);
    public UInt32 get_uiVal();
    public void set_uiVal(UInt32 value);
    public long get_longVal();
    public void set_longVal(long value);
    public ulong get_ulongVal();
    public void set_ulongVal(ulong value);
    public float get_floatVal();
    public void set_floatVal(float value);
    public double get_doubleVal();
    public void set_doubleVal(double value);
    public decimal get_decVal();
    public void set_decVal(decimal value);
    public char get_cVal();
    public string get_strVal();
    public void set_strVal(string value);
    public bool IsNullRef();
    public bool IsZero(ConstValKind kind);
    private T SpecialUnbox(object o);
    private object SpecialBox(T x);
    private bool IsDefault(object o);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ConstValFactory : object {
    public CONSTVAL Copy(ConstValKind kind, CONSTVAL value);
    public static CONSTVAL GetDefaultValue(ConstValKind kind);
    public static CONSTVAL GetNullRef();
    public static CONSTVAL GetBool(bool value);
    public static CONSTVAL GetInt(int value);
    public static CONSTVAL GetUInt(UInt32 value);
    public CONSTVAL Create(decimal value);
    public CONSTVAL Create(string value);
    public CONSTVAL Create(float value);
    public CONSTVAL Create(double value);
    public CONSTVAL Create(long value);
    public CONSTVAL Create(ulong value);
    internal CONSTVAL Create(bool value);
    internal CONSTVAL Create(object p);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConstValKind : Enum {
    public int value__;
    public static ConstValKind Int;
    public static ConstValKind Double;
    public static ConstValKind Long;
    public static ConstValKind String;
    public static ConstValKind Decimal;
    public static ConstValKind IntPtr;
    public static ConstValKind Float;
    public static ConstValKind Boolean;
    public static ConstValKind Lim;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CONVERTTYPE : Enum {
    public int value__;
    public static CONVERTTYPE NOUDC;
    public static CONVERTTYPE STANDARD;
    public static CONVERTTYPE ISEXPLICIT;
    public static CONVERTTYPE CHECKOVERFLOW;
    public static CONVERTTYPE FORCECAST;
    public static CONVERTTYPE STANDARDANDNOUDC;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ConvKind : Enum {
    public int value__;
    public static ConvKind Identity;
    public static ConvKind Implicit;
    public static ConvKind Explicit;
    public static ConvKind Unknown;
    public static ConvKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CorAttributeTargets : Enum {
    public int value__;
    public static CorAttributeTargets catAssembly;
    public static CorAttributeTargets catModule;
    public static CorAttributeTargets catClass;
    public static CorAttributeTargets catStruct;
    public static CorAttributeTargets catEnum;
    public static CorAttributeTargets catConstructor;
    public static CorAttributeTargets catMethod;
    public static CorAttributeTargets catProperty;
    public static CorAttributeTargets catField;
    public static CorAttributeTargets catEvent;
    public static CorAttributeTargets catInterface;
    public static CorAttributeTargets catParameter;
    public static CorAttributeTargets catDelegate;
    public static CorAttributeTargets catGenericParameter;
    public static CorAttributeTargets catAll;
    public static CorAttributeTargets catClassMembers;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.CorElementType : Enum {
    public int value__;
    public static CorElementType ELEMENT_TYPE_U1;
    public static CorElementType ELEMENT_TYPE_I2;
    public static CorElementType ELEMENT_TYPE_I4;
    public static CorElementType ELEMENT_TYPE_I8;
    public static CorElementType ELEMENT_TYPE_R4;
    public static CorElementType ELEMENT_TYPE_R8;
    public static CorElementType ELEMENT_TYPE_CHAR;
    public static CorElementType ELEMENT_TYPE_BOOLEAN;
    public static CorElementType ELEMENT_TYPE_I1;
    public static CorElementType ELEMENT_TYPE_U2;
    public static CorElementType ELEMENT_TYPE_U4;
    public static CorElementType ELEMENT_TYPE_U8;
    public static CorElementType ELEMENT_TYPE_I;
    public static CorElementType ELEMENT_TYPE_U;
    public static CorElementType ELEMENT_TYPE_OBJECT;
    public static CorElementType ELEMENT_TYPE_STRING;
    public static CorElementType ELEMENT_TYPE_TYPEDBYREF;
    public static CorElementType ELEMENT_TYPE_CLASS;
    public static CorElementType ELEMENT_TYPE_VALUETYPE;
    public static CorElementType ELEMENT_TYPE_END;
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.CSemanticChecker : object {
    public SymbolLoader SymbolLoader { get; }
    private ErrorHandling ErrorContext { get; }
    public bool CheckForStaticClass(Symbol symCtx, CType CType, ErrorCode err);
    public virtual ACCESSERROR CheckAccess2(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    public virtual bool CheckTypeAccess(CType type, Symbol symWhere);
    public void ReportStaticClassError(Symbol symCtx, CType CType, ErrorCode err);
    public abstract virtual SymbolLoader get_SymbolLoader();
    public abstract virtual SymbolLoader GetSymbolLoader();
    private ErrorHandling get_ErrorContext();
    public ErrorHandling GetErrorContext();
    public NameManager GetNameManager();
    public TypeManager GetTypeManager();
    public BSYMMGR getBSymmgr();
    public SymFactory GetGlobalSymbolFactory();
    public MiscSymFactory GetGlobalMiscSymFactory();
    public PredefinedTypes getPredefTypes();
    protected ACCESSERROR CheckAccessCore(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
    public bool CheckBogus(Symbol sym);
    public bool CheckBogus(CType pType);
    public void ReportAccessError(SymWithType swtBad, Symbol symWhere, CType typeQual);
    public bool CheckAccess(Symbol symCheck, AggregateType atsCheck, Symbol symWhere, CType typeThru);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.CType : object {
    private TypeKind _typeKind;
    private Name _pName;
    private bool _fHasErrors;
    private bool _fUnres;
    private bool _isBogus;
    private bool _checkedBogus;
    private Type _associatedSystemType;
    public bool IsGenericParameter { get; }
    public Type AssociatedSystemType { get; }
    public AggregateType AsAggregateType();
    public ErrorType AsErrorType();
    public ArrayType AsArrayType();
    public PointerType AsPointerType();
    public ParameterModifierType AsParameterModifierType();
    public NullableType AsNullableType();
    public TypeParameterType AsTypeParameterType();
    public bool IsAggregateType();
    public bool IsVoidType();
    public bool IsNullType();
    public bool IsOpenTypePlaceholderType();
    public bool IsBoundLambdaType();
    public bool IsMethodGroupType();
    public bool IsErrorType();
    public bool IsArrayType();
    public bool IsPointerType();
    public bool IsParameterModifierType();
    public bool IsNullableType();
    public bool IsTypeParameterType();
    public bool IsWindowsRuntimeType();
    public bool IsCollectionType();
    public bool get_IsGenericParameter();
    public Type get_AssociatedSystemType();
    private static Type CalculateAssociatedSystemType(CType src);
    private static Type CalculateAssociatedSystemTypeForAggregate(AggregateType aggtype);
    public sealed virtual bool IsType();
    public sealed virtual bool IsNamespace();
    public sealed virtual AssemblyQualifiedNamespaceSymbol AsNamespace();
    public sealed virtual CType AsType();
    public TypeKind GetTypeKind();
    public void SetTypeKind(TypeKind kind);
    public Name GetName();
    public void SetName(Name pName);
    public bool checkBogus();
    public bool getBogus();
    public bool hasBogus();
    public void setBogus(bool isBogus);
    public bool computeCurrentBogusState();
    public CType GetBaseOrParameterOrElementType();
    public void InitFromParent();
    public bool HasErrors();
    public void SetErrors(bool fHasErrors);
    public bool IsUnresolved();
    public void SetUnresolved(bool fUnres);
    public FUNDTYPE fundType();
    public ConstValKind constValKind();
    public CType underlyingType();
    public CType GetNakedType(bool fStripNub);
    public AggregateSymbol GetNakedAgg();
    public AggregateSymbol GetNakedAgg(bool fStripNub);
    public AggregateSymbol getAggregate();
    public CType StripNubs();
    public CType StripNubs(Int32& pcnub);
    public bool isDelegateType();
    public bool isSimpleType();
    public bool isSimpleOrEnum();
    public bool isSimpleOrEnumOrString();
    public bool isPointerLike();
    public bool isNumericType();
    public bool isStructOrEnum();
    public bool isStructType();
    public bool isEnumType();
    public bool isInterfaceType();
    public bool isClassType();
    public AggregateType underlyingEnumType();
    public bool isUnsigned();
    public bool isUnsafe();
    public bool isPredefType(PredefinedType pt);
    public bool isPredefined();
    public PredefinedType getPredefType();
    public bool isSpecialByRefType();
    public bool isStaticClass();
    public bool computeManagedType(SymbolLoader symbolLoader);
    public CType GetDelegateTypeOfPossibleExpression();
    public bool IsValType();
    public bool IsNonNubValType();
    public bool IsRefType();
    public bool IsNeverSameType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.Declaration : ParentSymbol {
    public NamespaceOrAggregateSymbol bag;
    public Declaration declNext;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ErrorType : CType {
    public Name nameText;
    public TypeArray typeArgs;
    private CType _pParentType;
    private AssemblyQualifiedNamespaceSymbol _pParentNS;
    public bool HasParent();
    public bool HasTypeParent();
    public CType GetTypeParent();
    public void SetTypeParent(CType pType);
    public bool HasNSParent();
    public AssemblyQualifiedNamespaceSymbol GetNSParent();
    public void SetNSParent(AssemblyQualifiedNamespaceSymbol pNS);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EventSymbol : Symbol {
    public EventInfo AssociatedEventInfo;
    public bool isStatic;
    public bool isOverride;
    public CType type;
    public MethodSymbol methAdd;
    public MethodSymbol methRemove;
    public AggregateDeclaration declaration;
    [CompilerGeneratedAttribute]
private bool <IsWindowsRuntimeEvent>k__BackingField;
    public bool IsWindowsRuntimeEvent { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_IsWindowsRuntimeEvent();
    [CompilerGeneratedAttribute]
public void set_IsWindowsRuntimeEvent(bool value);
    public AggregateDeclaration containingDeclaration();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EventWithType : SymWithType {
    public EventWithType(EventSymbol event, AggregateType ats);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.EXPR : object {
    internal object RuntimeObject;
    internal CType RuntimeObjectActualType;
    public ExpressionKind kind;
    public EXPRFLAG flags;
    public bool IsError;
    public bool IsOptionalArgument;
    public string errorString;
    public CType type;
    protected static void RETAILVERIFY(bool f);
    public void SetInaccessibleBit();
    public void SetMismatchedStaticBit();
    public void setType(CType t);
    public void setAssignment();
    public bool isOK();
    public bool HasError();
    public void SetError();
    public bool HasObject();
    public EXPR getArgs();
    public void setArgs(EXPR args);
    public EXPR getObject();
    public void SetObject(EXPR pExpr);
    public SymWithType GetSymWithType();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRARRAYINDEX : EXPR {
    private EXPR _Array;
    private EXPR _Index;
    public EXPR GetArray();
    public void SetArray(EXPR value);
    public EXPR GetIndex();
    public void SetIndex(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRARRAYLENGTH : EXPR {
    private EXPR _Array;
    public EXPR GetArray();
    public void SetArray(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRARRINIT : EXPR {
    private EXPR _OptionalArguments;
    private EXPR _OptionalArgumentDimensions;
    public Int32[] dimSizes;
    public int dimSize;
    public bool GeneratedForParamArray;
    public EXPR GetOptionalArguments();
    public void SetOptionalArguments(EXPR value);
    public EXPR GetOptionalArgumentDimensions();
    public void SetOptionalArgumentDimensions(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRASSIGNMENT : EXPR {
    private EXPR _LHS;
    private EXPR _RHS;
    public EXPR GetLHS();
    public void SetLHS(EXPR value);
    public EXPR GetRHS();
    public void SetRHS(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRBINOP : EXPR {
    private EXPR _OptionalLeftChild;
    private EXPR _OptionalRightChild;
    private EXPR _OptionalUserDefinedCall;
    public MethWithInst predefinedMethodToCall;
    public bool isLifted;
    private MethPropWithInst _UserDefinedCallMethod;
    public EXPR GetOptionalLeftChild();
    public void SetOptionalLeftChild(EXPR value);
    public EXPR GetOptionalRightChild();
    public void SetOptionalRightChild(EXPR value);
    public EXPR GetOptionalUserDefinedCall();
    public void SetOptionalUserDefinedCall(EXPR value);
    public MethPropWithInst GetUserDefinedCallMethod();
    public void SetUserDefinedCallMethod(MethPropWithInst value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRBLOCK : EXPRSTMT {
    private EXPRSTMT _OptionalStatements;
    public Scope OptionalScopeSymbol;
    public EXPRSTMT GetOptionalStatements();
    public void SetOptionalStatements(EXPRSTMT value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRBOUNDLAMBDA : EXPR {
    public EXPRBLOCK OptionalBody;
    private Scope _argumentScope;
    public void Initialize(Scope argScope);
    public AggregateType DelegateType();
    public Scope ArgumentScope();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCALL : EXPR {
    private EXPR _OptionalArguments;
    private EXPRMEMGRP _MemberGroup;
    public MethWithInst mwi;
    public PREDEFMETH PredefinedMethod;
    public NullableCallLiftKind nubLiftKind;
    public EXPR pConversions;
    public EXPR castOfNonLiftedResultToLiftedType;
    public EXPR GetOptionalArguments();
    public void SetOptionalArguments(EXPR value);
    public EXPRMEMGRP GetMemberGroup();
    public void SetMemberGroup(EXPRMEMGRP value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCAST : EXPR {
    public EXPR Argument;
    public EXPRTYPEORNAMESPACE DestinationType;
    public EXPR GetArgument();
    public void SetArgument(EXPR expr);
    public EXPRTYPEORNAMESPACE GetDestinationType();
    public void SetDestinationType(EXPRTYPEORNAMESPACE expr);
    public bool IsBoxingCast();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCLASS : EXPRTYPEORNAMESPACE {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCONCAT : EXPR {
    public EXPR FirstArgument;
    public EXPR SecondArgument;
    public EXPR GetFirstArgument();
    public void SetFirstArgument(EXPR value);
    public EXPR GetSecondArgument();
    public void SetSecondArgument(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRCONSTANT : EXPR {
    public EXPR OptionalConstructorCall;
    private CONSTVAL _val;
    public bool IsZero { get; }
    public CONSTVAL Val { get; public set; }
    public long I64Value { get; }
    public EXPR GetOptionalConstructorCall();
    public void SetOptionalConstructorCall(EXPR value);
    public bool get_IsZero();
    public bool isZero();
    public CONSTVAL getVal();
    public void setVal(CONSTVAL newValue);
    public CONSTVAL get_Val();
    public void set_Val(CONSTVAL value);
    public ulong getU64Value();
    public long getI64Value();
    public long get_I64Value();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionBinder : object {
    private static Byte[][] s_betterConversionTable;
    private static ErrorCode[] s_ReadOnlyLocalErrors;
    private static ErrorCode[] s_ReadOnlyErrors;
    private static byte ID;
    private static byte IMP;
    private static byte EXP;
    private static byte NO;
    private static byte CONV_KIND_MASK;
    private static byte UDC;
    private static byte XUD;
    private static byte IUD;
    private static Byte[][] s_simpleTypeConversions;
    private static int NUM_SIMPLE_TYPES;
    private static int NUM_EXT_TYPES;
    private static byte same;
    private static byte left;
    private static byte right;
    private static byte neither;
    private static Byte[][] s_simpleTypeBetter;
    protected BindingContext Context;
    protected CNullable m_nullable;
    private static PredefinedType[] s_rgptIntOp;
    private static PredefinedName[] s_EK2NAME;
    protected BinOpSig[] g_binopSignatures;
    protected UnaOpSig[] g_rguos;
    protected SymbolLoader SymbolLoader { get; }
    protected CSemanticChecker SemanticChecker { get; }
    private ErrorHandling ErrorContext { get; }
    protected TypeManager TypeManager { get; }
    private ExprFactory ExprFactory { get; }
    protected CType VoidType { get; }
    public ExpressionBinder(BindingContext context);
    private static ExpressionBinder();
    protected BetterType WhichMethodIsBetterTieBreaker(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    private static int FindName(List`1<Name> names, Name name);
    private TypeArray RearrangeNamedArguments(TypeArray pta, MethPropWithInst mpwi, CType pTypeThrough, ArgInfos args);
    protected BetterType WhichMethodIsBetter(CandidateFunctionMember node1, CandidateFunctionMember node2, CType pTypeThrough, ArgInfos args);
    protected BetterType WhichConversionIsBetter(EXPR arg, CType argType, CType p1, CType p2);
    public BetterType WhichConversionIsBetter(CType argType, CType p1, CType p2);
    protected CandidateFunctionMember FindBestMethod(List`1<CandidateFunctionMember> list, CType pTypeThrough, ArgInfos args, CandidateFunctionMember& methAmbig1, CandidateFunctionMember& methAmbig2);
    protected void ReportLocalError(LocalVariableSymbol local, CheckLvalueKind kind, bool isNested);
    protected void ReportReadOnlyError(EXPRFIELD field, CheckLvalueKind kind, bool isNested);
    protected bool TryReportLvalueFailure(EXPR expr, CheckLvalueKind kind);
    public static void ReportTypeArgsNotAllowedError(SymbolLoader symbolLoader, int arity, ErrArgRef argName, ErrArgRef argKind);
    private static void RoundToFloat(double d, Single& f);
    private static long I64(long x);
    private static long I64(ulong x);
    private static void RETAILVERIFY(bool b);
    private static ConvKind GetConvKind(PredefinedType ptSrc, PredefinedType ptDst);
    private static bool isUserDefinedConversion(PredefinedType ptSrc, PredefinedType ptDst);
    private BetterType WhichSimpleConversionIsBetter(PredefinedType pt1, PredefinedType pt2);
    private BetterType WhichTypeIsBetter(PredefinedType pt1, PredefinedType pt2, CType typeGiven);
    private BetterType WhichTypeIsBetter(CType type1, CType type2, CType typeGiven);
    public bool canConvert(CType src, CType dest, CONVERTTYPE flags);
    public bool canConvert(CType src, CType dest);
    public bool canConvert(EXPR expr, CType dest);
    public bool canConvert(EXPR expr, CType dest, CONVERTTYPE flags);
    public EXPR mustConvertCore(EXPR expr, EXPRTYPEORNAMESPACE destExpr);
    public EXPR mustConvertCore(EXPR expr, EXPRTYPEORNAMESPACE destExpr, CONVERTTYPE flags);
    public EXPR tryConvert(EXPR expr, CType dest);
    public EXPR tryConvert(EXPR expr, CType dest, CONVERTTYPE flags);
    public EXPR mustConvert(EXPR expr, CType dest);
    public EXPR mustConvert(EXPR expr, CType dest, CONVERTTYPE flags);
    public EXPR mustConvert(EXPR expr, EXPRTYPEORNAMESPACE dest, CONVERTTYPE flags);
    private EXPR mustCastCore(EXPR expr, EXPRTYPEORNAMESPACE destExpr, CONVERTTYPE flags);
    private void CantConvert(EXPR expr, CType dest);
    public EXPR mustCast(EXPR expr, CType dest);
    public EXPR mustCast(EXPR expr, CType dest, CONVERTTYPE flags);
    private EXPR mustCastInUncheckedContext(EXPR expr, CType dest, CONVERTTYPE flags);
    private bool canCast(CType src, CType dest, CONVERTTYPE flags);
    public bool BindGrpConversion(EXPRMEMGRP grp, CType typeDst, bool fReportErrors);
    public bool BindGrpConversion(EXPRMEMGRP grp, CType typeDst, bool needDest, EXPRCALL& pexprDst, bool fReportErrors);
    private bool BindGrpConversionCore(MethPropWithInst& pmpwi, BindingFlag bindFlags, EXPRMEMGRP grp, TypeArray& args, AggregateType atsDelegate, bool fReportErrors, MethPropWithInst& pmpwiAmbig);
    private bool canConvertInstanceParamForExtension(EXPR exprSrc, CType typeDest);
    private bool canConvertInstanceParamForExtension(CType typeSrc, CType typeDest);
    private bool BindImplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, CONVERTTYPE flags);
    private bool BindImplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, EXPR& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindImplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, bool needsExprDest, EXPR& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, bool needsExprDest, EXPR& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, EXPR& ppDestinationExpr, CONVERTTYPE flags);
    private bool BindExplicitConversion(EXPR pSourceExpr, CType pSourceType, EXPRTYPEORNAMESPACE pDestinationTypeExpr, CType pDestinationTypeForLambdaErrorReporting, CONVERTTYPE flags);
    private bool bindUserDefinedConversion(EXPR exprSrc, CType typeSrc, CType typeDst, bool needExprDest, EXPR& pexprDst, bool fImplicitOnly);
    private EXPR HandleAmbiguity(EXPR exprSrc, CType typeSrc, CType typeDst, List`1<UdConvInfo> prguci, int iuciBestSrc, int iuciBestDst);
    private void MarkAsIntermediateConversion(EXPR pExpr);
    private EXPR BindUDConversionCore(EXPR pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest);
    private EXPR BindUDConversionCore(EXPR pFrom, CType pTypeFrom, CType pTypeTo, CType pTypeDestination, MethWithInst mwiBest, EXPR& ppTransformedArgument);
    private ConstCastResult bindConstantCast(EXPR exprSrc, EXPRTYPEORNAMESPACE exprTypeDest, bool needExprDest, EXPR& pexprDest, bool explicitConversion);
    private int CompareSrcTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    private int CompareDstTypesBased(CType type1, bool fImplicit1, CType type2, bool fImplicit2);
    private EXPR bindDecimalConstCast(EXPRTYPEORNAMESPACE exprDestType, CType srcType, EXPRCONSTANT src);
    private bool canExplicitConversionBeBoundInUncheckedContext(EXPR exprSrc, CType typeSrc, EXPRTYPEORNAMESPACE typeDest, CONVERTTYPE flags);
    public BindingContext GetContext();
    private static void VSFAIL(string s);
    protected SymbolLoader GetSymbolLoader();
    protected SymbolLoader get_SymbolLoader();
    protected CSemanticChecker get_SemanticChecker();
    public CSemanticChecker GetSemanticChecker();
    private ErrorHandling get_ErrorContext();
    private ErrorHandling GetErrorContext();
    protected BSYMMGR GetGlobalSymbols();
    protected TypeManager GetTypes();
    protected TypeManager get_TypeManager();
    private ExprFactory GetExprFactory();
    private ExprFactory get_ExprFactory();
    private ConstValFactory GetExprConstants();
    protected AggregateType GetReqPDT(PredefinedType pt);
    protected static AggregateType GetReqPDT(PredefinedType pt, SymbolLoader symbolLoader);
    protected AggregateType GetOptPDT(PredefinedType pt);
    protected AggregateType GetOptPDT(PredefinedType pt, bool WarnIfNotFound);
    protected CType get_VoidType();
    protected CType getVoidType();
    public EXPR GenerateAssignmentConversion(EXPR op1, EXPR op2, bool allowExplicit);
    public EXPR bindAssignment(EXPR op1, EXPR op2, bool allowExplicit);
    internal EXPR BindArrayIndexCore(BindingFlag bindFlags, EXPR pOp1, EXPR pOp2);
    protected EXPRUNARYOP bindPtrToString(EXPR string);
    protected EXPRQUESTIONMARK BindPtrToArray(EXPRLOCAL exprLoc, EXPR array);
    protected EXPR bindIndexer(EXPR pObject, EXPR args, BindingFlag bindFlags);
    public void bindSimpleCast(EXPR exprSrc, EXPRTYPEORNAMESPACE typeDest, EXPR& pexprDest);
    public void bindSimpleCast(EXPR exprSrc, EXPRTYPEORNAMESPACE exprTypeDest, EXPR& pexprDest, EXPRFLAG exprFlags);
    internal EXPRCALL BindToMethod(MethWithInst mwi, EXPR pArguments, EXPRMEMGRP pMemGroup, MemLookFlags flags);
    internal EXPR BindToField(EXPR pObject, FieldWithType fwt, BindingFlag bindFlags);
    internal EXPR BindToField(EXPR pOptionalObject, FieldWithType fwt, BindingFlag bindFlags, EXPR pOptionalLHS);
    internal EXPR BindToProperty(EXPR pObject, PropWithType pwt, BindingFlag bindFlags, EXPR args, AggregateType pOtherType, EXPRMEMGRP pMemGroup);
    internal EXPR bindUDUnop(ExpressionKind ek, EXPR arg);
    private EXPRCALL BindLiftedUDUnop(EXPR arg, CType typeArg, MethPropWithInst mpwi);
    private EXPRCALL BindUDUnopCall(EXPR arg, CType typeArg, MethPropWithInst mpwi);
    private bool BindMethodGroupToArgumentsCore(GroupToArgsBinderResult& pResults, BindingFlag bindFlags, EXPRMEMGRP grp, EXPR& args, int carg, bool bindingCollectionAdd, bool bHasNamedArgumentSpecifiers);
    internal EXPR BindMethodGroupToArguments(BindingFlag bindFlags, EXPRMEMGRP grp, EXPR args);
    private bool VerifyNamedArgumentsAfterFixed(EXPR args, Boolean& seenNamed);
    internal EXPRCALL BindPredefMethToArgs(PREDEFMETH predefMethod, EXPR obj, EXPR args, TypeArray clsTypeArgs, TypeArray methTypeArgs);
    protected EXPR BadOperatorTypesError(ExpressionKind ek, EXPR pOperand1, EXPR pOperand2);
    protected EXPR BadOperatorTypesError(ExpressionKind ek, EXPR pOperand1, EXPR pOperand2, CType pTypeErr);
    protected EXPR UnwrapExpression(EXPR pExpression);
    private static ErrorCode GetStandardLvalueError(CheckLvalueKind kind);
    protected void CheckLvalueProp(EXPRPROP prop);
    protected bool CheckPropertyAccess(MethWithType mwt, PropWithType pwtSlot, CType type);
    internal bool checkLvalue(EXPR expr, CheckLvalueKind kind);
    internal void PostBindMethod(bool fBaseCall, MethWithInst& pMWI, EXPR pObject);
    protected void PostBindProperty(bool fBaseCall, PropWithType pwt, EXPR pObject, MethWithType& pmwtGet, MethWithType& pmwtSet);
    private EXPR AdjustMemberObject(SymWithType swt, EXPR pObject, Boolean& pfConstrained, Boolean& pIsMatchingStatic);
    private bool IsMatchingStatic(SymWithType swt, EXPR pObject);
    private bool objectIsLvalue(EXPR pObject);
    public static void RemapToOverride(SymbolLoader symbolLoader, SymWithType pswt, CType typeObj);
    protected void verifyMethodArgs(EXPR call, CType callingObjectType);
    protected void AdjustCallArgumentsForParams(CType callingObjectType, CType type, MethodOrPropertySymbol mp, TypeArray pTypeArgs, EXPR argsPtr, EXPR& newArgs);
    protected void markFieldAssigned(EXPR expr);
    protected void SetExternalRef(CType type);
    internal CType chooseArrayIndexType(EXPR args);
    internal void FillInArgInfoFromArgList(ArgInfos argInfo, EXPR args);
    protected bool TryGetExpandedParams(TypeArray params, int count, TypeArray& ppExpandedParams);
    public static bool IsMethPropCallable(MethodOrPropertySymbol sym, bool requireUC);
    private bool isConvInTable(List`1<UdConvInfo> convTable, MethodSymbol meth, AggregateType ats, bool fSrc, bool fDst);
    public static bool isConstantInRange(EXPRCONSTANT exprSrc, CType typeDest);
    public static bool isConstantInRange(EXPRCONSTANT exprSrc, CType typeDest, bool realsOk);
    protected Name ekName(ExpressionKind ek);
    public void checkUnsafe(CType type);
    public void checkUnsafe(CType type, ErrorCode errCode, ErrArg pArg);
    protected bool InMethod();
    protected bool InStaticMethod();
    protected bool InConstructor();
    protected bool InAnonymousMethod();
    protected bool InFieldInitializer();
    private Declaration ContextForMemberLookup();
    protected AggregateSymbol ContainingAgg();
    protected bool isThisPointer(EXPR expr);
    protected bool RespectReadonly();
    protected bool isUnsafeContext();
    protected bool ReportUnsafeErrors();
    protected virtual void RecordUnsafeUsage();
    protected virtual EXPR WrapShortLivedExpression(EXPR expr);
    protected virtual EXPR GenerateOptimizedAssignment(EXPR op1, EXPR op2);
    public static void RecordUnsafeUsage(BindingContext context);
    internal static int CountArguments(EXPR args, Boolean& typeErrors);
    internal EXPR BindNubValue(EXPR exprSrc);
    private EXPRCALL BindNubNew(EXPR exprSrc);
    protected EXPR bindUserDefinedBinOp(ExpressionKind ek, BinOpArgInfo info);
    protected bool GetSpecialBinopSignatures(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    protected bool GetStandardAndLiftedBinopSignatures(List`1<BinOpFullSig> rgbofs, BinOpArgInfo info);
    protected int FindBestSignatureInList(List`1<BinOpFullSig> binopSignatures, BinOpArgInfo info);
    protected EXPRBINOP bindNullEqualityComparison(ExpressionKind ek, BinOpArgInfo info);
    public EXPR BindStandardBinop(ExpressionKind ek, EXPR arg1, EXPR arg2);
    protected EXPR BindStandardBinopCore(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    private EXPR BindLiftedStandardBinOp(BinOpArgInfo info, BinOpFullSig bofs, ExpressionKind ek, EXPRFLAG flags);
    private void LiftArgument(EXPR pArgument, CType pParameterType, bool bConvertBeforeLift, EXPR& ppLiftedArgument, EXPR& ppNonLiftedArgument);
    protected bool GetDelBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private bool CanConvertArg1(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    private bool CanConvertArg2(BinOpArgInfo info, CType typeDst, LiftFlags& pgrflt, CType& ptypeSig1, CType& ptypeSig2);
    private void RecordBinOpSigFromArgs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    protected bool GetEnumBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    protected bool GetPtrBinOpSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    protected bool GetRefEqualSigs(List`1<BinOpFullSig> prgbofs, BinOpArgInfo info);
    private int WhichBofsIsBetter(BinOpFullSig bofs1, BinOpFullSig bofs2, CType type1, CType type2);
    private static bool CalculateExprAndUnaryOpKinds(OperatorKind op, bool bChecked, ExpressionKind& ek, UnaOpKind& uok, EXPRFLAG& flags);
    public EXPR BindStandardUnaryOperator(OperatorKind op, EXPR pArgument);
    private UnaryOperatorSignatureFindResult PopulateSignatureList(EXPR pArgument, UnaOpKind unaryOpKind, UnaOpMask unaryOpMask, ExpressionKind exprKind, EXPRFLAG flags, List`1<UnaOpFullSig> pSignatures, EXPR& ppResult);
    private bool FindApplicableSignatures(EXPR pArgument, UnaOpMask unaryOpMask, List`1<UnaOpFullSig> pSignatures);
    private EXPR BindLiftedStandardUnop(ExpressionKind ek, EXPRFLAG flags, EXPR arg, UnaOpFullSig uofs);
    private int WhichUofsIsBetter(UnaOpFullSig uofs1, UnaOpFullSig uofs2, CType typeArg);
    private EXPR BindIntBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindIntUnaOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg);
    private EXPR BindRealBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindRealUnaOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg);
    private EXPR BindIncOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg, UnaOpFullSig uofs);
    private EXPR BindIncOpCore(ExpressionKind ek, EXPRFLAG flags, EXPR exprVal, CType type);
    private EXPR LScalar(ExpressionKind ek, EXPRFLAG flags, EXPR exprVal, CType type, CONSTVAL cv, EXPR pExprResult, CType typeTmp);
    private EXPRMULTI BindNonliftedIncOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg, UnaOpFullSig uofs);
    private EXPRMULTI BindLiftedIncOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg, UnaOpFullSig uofs);
    private EXPR BindDecBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindDecUnaOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg);
    private EXPR BindStrBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindShiftOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindBoolBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindBoolBitwiseOp(ExpressionKind ek, EXPRFLAG flags, EXPR expr1, EXPR expr2, BinOpFullSig bofs);
    private EXPR BindLiftedBoolBitwiseOp(ExpressionKind ek, EXPRFLAG flags, EXPR expr1, EXPR expr2);
    private EXPR BindBoolUnaOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg);
    private EXPR BindStrCmpOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindRefCmpOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindDelBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindEnumBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindEnumUnaOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg);
    private EXPR BindPtrBinOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private EXPR BindPtrCmpOp(ExpressionKind ek, EXPRFLAG flags, EXPR arg1, EXPR arg2);
    private bool GetBinopKindAndFlags(ExpressionKind ek, BinOpKind& pBinopKind, EXPRFLAG& flags);
    private static bool isDivByZero(ExpressionKind kind, EXPR op2);
    private EXPR FoldIntegerConstants(ExpressionKind kind, EXPRFLAG flags, EXPR op1, EXPR op2, PredefinedType ptOp);
    private EXPR BindIntOp(ExpressionKind kind, EXPRFLAG flags, EXPR op1, EXPR op2, PredefinedType ptOp);
    private EXPR BindIntegerNeg(EXPRFLAG flags, EXPR op, PredefinedType ptOp);
    private EXPR FoldConstI4Op(ExpressionKind kind, EXPR op1, EXPRCONSTANT opConst1, EXPR op2, EXPRCONSTANT opConst2, PredefinedType ptOp);
    private void EnsureChecked(bool b);
    private EXPR FoldConstI8Op(ExpressionKind kind, EXPR op1, EXPRCONSTANT opConst1, EXPR op2, EXPRCONSTANT opConst2, PredefinedType ptOp);
    private EXPR bindFloatOp(ExpressionKind kind, EXPRFLAG flags, EXPR op1, EXPR op2);
    private EXPR bindStringConcat(EXPR op1, EXPR op2);
    private EXPR ambiguousOperatorError(ExpressionKind ek, EXPR op1, EXPR op2);
    private EXPR BindUserBoolOp(ExpressionKind kind, EXPRCALL pCall);
    private AggregateType GetUserDefinedBinopArgumentType(CType type);
    private int GetUserDefinedBinopArgumentTypes(CType type1, CType type2, AggregateType[] rgats);
    private bool UserDefinedBinaryOperatorCanBeLifted(ExpressionKind ek, MethodSymbol method, AggregateType ats, TypeArray Params);
    private bool UserDefinedBinaryOperatorIsApplicable(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, MethodSymbol method, AggregateType ats, EXPR arg1, EXPR arg2, bool fDontLift);
    private bool GetApplicableUserDefinedBinaryOperatorCandidates(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, EXPR arg1, EXPR arg2, bool fDontLift);
    private AggregateType GetApplicableUserDefinedBinaryOperatorCandidatesInBaseTypes(List`1<CandidateFunctionMember> candidateList, ExpressionKind ek, AggregateType type, EXPR arg1, EXPR arg2, bool fDontLift, AggregateType atsStop);
    private EXPRCALL BindUDBinop(ExpressionKind ek, EXPR arg1, EXPR arg2, bool fDontLift, MethPropWithInst& ppmpwi);
    private EXPRCALL BindUDBinopCall(EXPR arg1, EXPR arg2, TypeArray Params, CType typeRet, MethPropWithInst mpwi);
    private EXPRCALL BindLiftedUDBinop(ExpressionKind ek, EXPR arg1, EXPR arg2, TypeArray Params, MethPropWithInst mpwi);
    private AggregateType GetEnumBinOpType(ExpressionKind ek, CType argType1, CType argType2, AggregateType& ppEnumType);
    private EXPRBINOP CreateBinopForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType RetType, EXPR arg1, EXPR arg2);
    private EXPRUNARYOP CreateUnaryOpForPredefMethodCall(ExpressionKind ek, PREDEFMETH predefMeth, CType pRetType, EXPR pArg);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionIterator : object {
    private EXPRLIST _pList;
    private EXPR _pCurrent;
    public ExpressionIterator(EXPR pExpr);
    public bool AtEnd();
    public EXPR Current();
    public void MoveNext();
    public static int Count(EXPR pExpr);
    private void Init(EXPR pExpr);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKind : Enum {
    public int value__;
    public static ExpressionKind EK_BLOCK;
    public static ExpressionKind EK_RETURN;
    public static ExpressionKind EK_NOOP;
    public static ExpressionKind EK_BINOP;
    public static ExpressionKind EK_UNARYOP;
    public static ExpressionKind EK_ASSIGNMENT;
    public static ExpressionKind EK_LIST;
    public static ExpressionKind EK_QUESTIONMARK;
    public static ExpressionKind EK_ARRAYINDEX;
    public static ExpressionKind EK_ARRAYLENGTH;
    public static ExpressionKind EK_ARGUMENTHANDLE;
    public static ExpressionKind EK_CALL;
    public static ExpressionKind EK_EVENT;
    public static ExpressionKind EK_FIELD;
    public static ExpressionKind EK_LOCAL;
    public static ExpressionKind EK_THISPOINTER;
    public static ExpressionKind EK_CONSTANT;
    public static ExpressionKind EK_TYPEARGUMENTS;
    public static ExpressionKind EK_TYPEORNAMESPACE;
    public static ExpressionKind EK_CLASS;
    public static ExpressionKind EK_ALIAS;
    public static ExpressionKind EK_FUNCPTR;
    public static ExpressionKind EK_PROP;
    public static ExpressionKind EK_MULTI;
    public static ExpressionKind EK_MULTIGET;
    public static ExpressionKind EK_WRAP;
    public static ExpressionKind EK_CONCAT;
    public static ExpressionKind EK_ARRINIT;
    public static ExpressionKind EK_CAST;
    public static ExpressionKind EK_USERDEFINEDCONVERSION;
    public static ExpressionKind EK_TYPEOF;
    public static ExpressionKind EK_ZEROINIT;
    public static ExpressionKind EK_USERLOGOP;
    public static ExpressionKind EK_MEMGRP;
    public static ExpressionKind EK_BOUNDLAMBDA;
    public static ExpressionKind EK_UNBOUNDLAMBDA;
    public static ExpressionKind EK_HOISTEDLOCALEXPR;
    public static ExpressionKind EK_FIELDINFO;
    public static ExpressionKind EK_METHODINFO;
    public static ExpressionKind EK_PROPERTYINFO;
    public static ExpressionKind EK_NamedArgumentSpecification;
    public static ExpressionKind EK_COUNT;
    public static ExpressionKind EK_EQUALS;
    public static ExpressionKind EK_FIRSTOP;
    public static ExpressionKind EK_COMPARE;
    public static ExpressionKind EK_TRUE;
    public static ExpressionKind EK_FALSE;
    public static ExpressionKind EK_INC;
    public static ExpressionKind EK_DEC;
    public static ExpressionKind EK_LOGNOT;
    public static ExpressionKind EK_EQ;
    public static ExpressionKind EK_RELATIONAL_MIN;
    public static ExpressionKind EK_NE;
    public static ExpressionKind EK_LT;
    public static ExpressionKind EK_LE;
    public static ExpressionKind EK_GT;
    public static ExpressionKind EK_GE;
    public static ExpressionKind EK_RELATIONAL_MAX;
    public static ExpressionKind EK_ADD;
    public static ExpressionKind EK_ARITH_MIN;
    public static ExpressionKind EK_SUB;
    public static ExpressionKind EK_MUL;
    public static ExpressionKind EK_DIV;
    public static ExpressionKind EK_MOD;
    public static ExpressionKind EK_NEG;
    public static ExpressionKind EK_UPLUS;
    public static ExpressionKind EK_ARITH_MAX;
    public static ExpressionKind EK_BITAND;
    public static ExpressionKind EK_BIT_MIN;
    public static ExpressionKind EK_BITOR;
    public static ExpressionKind EK_BITXOR;
    public static ExpressionKind EK_BITNOT;
    public static ExpressionKind EK_BIT_MAX;
    public static ExpressionKind EK_LSHIFT;
    public static ExpressionKind EK_RSHIFT;
    public static ExpressionKind EK_LOGAND;
    public static ExpressionKind EK_LOGOR;
    public static ExpressionKind EK_SEQUENCE;
    public static ExpressionKind EK_SEQREV;
    public static ExpressionKind EK_SAVE;
    public static ExpressionKind EK_SWAP;
    public static ExpressionKind EK_INDIR;
    public static ExpressionKind EK_ADDR;
    public static ExpressionKind EK_STRINGEQ;
    public static ExpressionKind EK_STRINGNE;
    public static ExpressionKind EK_DELEGATEEQ;
    public static ExpressionKind EK_DELEGATENE;
    public static ExpressionKind EK_DELEGATEADD;
    public static ExpressionKind EK_DELEGATESUB;
    public static ExpressionKind EK_DECIMALNEG;
    public static ExpressionKind EK_DECIMALINC;
    public static ExpressionKind EK_DECIMALDEC;
    public static ExpressionKind EK_MULTIOFFSET;
    public static ExpressionKind EK_ExprMin;
    public static ExpressionKind EK_StmtLim;
    public static ExpressionKind EK_TypeLim;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionKindExtensions : object {
    [ExtensionAttribute]
public static bool isRelational(ExpressionKind kind);
    [ExtensionAttribute]
public static bool isUnaryOperator(ExpressionKind kind);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExpressionTreeRewriter : ExprVisitorBase {
    protected ExprFactory expressionFactory;
    protected SymbolLoader symbolLoader;
    protected EXPRBOUNDLAMBDA currentAnonMeth;
    protected bool alwaysRewrite;
    protected ExpressionTreeRewriter(ExprFactory expressionFactory, SymbolLoader symbolLoader);
    public static EXPR Rewrite(EXPR expr, ExprFactory expressionFactory, SymbolLoader symbolLoader);
    protected ExprFactory GetExprFactory();
    protected SymbolLoader GetSymbolLoader();
    protected virtual EXPR Dispatch(EXPR expr);
    protected virtual EXPR VisitASSIGNMENT(EXPRASSIGNMENT assignment);
    protected virtual EXPR VisitMULTIGET(EXPRMULTIGET pExpr);
    protected virtual EXPR VisitMULTI(EXPRMULTI pExpr);
    protected virtual EXPR VisitBOUNDLAMBDA(EXPRBOUNDLAMBDA anonmeth);
    protected virtual EXPR VisitCONSTANT(EXPRCONSTANT expr);
    protected virtual EXPR VisitLOCAL(EXPRLOCAL local);
    protected virtual EXPR VisitTHISPOINTER(EXPRTHISPOINTER expr);
    protected virtual EXPR VisitFIELD(EXPRFIELD expr);
    protected virtual EXPR VisitUSERDEFINEDCONVERSION(EXPRUSERDEFINEDCONVERSION expr);
    protected virtual EXPR VisitCAST(EXPRCAST pExpr);
    protected virtual EXPR VisitCONCAT(EXPRCONCAT expr);
    protected virtual EXPR VisitBINOP(EXPRBINOP expr);
    protected virtual EXPR VisitUNARYOP(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitARRAYINDEX(EXPRARRAYINDEX pExpr);
    protected virtual EXPR VisitARRAYLENGTH(EXPRARRAYLENGTH pExpr);
    protected virtual EXPR VisitQUESTIONMARK(EXPRQUESTIONMARK pExpr);
    protected virtual EXPR VisitCALL(EXPRCALL expr);
    protected virtual EXPR VisitPROP(EXPRPROP expr);
    protected virtual EXPR VisitARRINIT(EXPRARRINIT expr);
    protected virtual EXPR VisitZEROINIT(EXPRZEROINIT expr);
    protected virtual EXPR VisitTYPEOF(EXPRTYPEOF expr);
    protected virtual EXPR GenerateQuestionMarkOperand(EXPR pExpr);
    protected virtual EXPR GenerateDelegateInvoke(EXPRCALL expr);
    protected virtual EXPR GenerateBuiltInBinaryOperator(EXPRBINOP expr);
    protected virtual EXPR GenerateBuiltInUnaryOperator(EXPRUNARYOP expr);
    protected virtual EXPR GenerateBuiltInUnaryOperator(PREDEFMETH pdm, EXPR pOriginalOperator, EXPR pOperator);
    protected virtual EXPR GenerateUserDefinedBinaryOperator(EXPRBINOP expr);
    protected virtual EXPR GenerateUserDefinedUnaryOperator(EXPRUNARYOP expr);
    protected virtual EXPR GenerateUserDefinedComparisonOperator(EXPRBINOP expr);
    protected EXPR RewriteLambdaBody(EXPRBOUNDLAMBDA anonmeth);
    protected EXPR RewriteLambdaParameters(EXPRBOUNDLAMBDA anonmeth);
    protected virtual EXPR GenerateConversion(EXPR arg, CType CType, bool bChecked);
    protected virtual EXPR GenerateConversionWithSource(EXPR pTarget, CType pType, bool bChecked);
    protected virtual EXPR GenerateValueAccessConversion(EXPR pArgument);
    protected virtual EXPR GenerateUserDefinedConversion(EXPR arg, CType type, MethWithInst method);
    protected virtual EXPR GenerateUserDefinedConversion(EXPR arg, CType CType, EXPR target, MethWithInst method);
    protected virtual EXPR GenerateUserDefinedConversion(EXPRUSERDEFINEDCONVERSION pExpr, EXPR pArgument);
    protected virtual EXPR GenerateParameter(string name, CType CType);
    protected MethodSymbol GetPreDefMethod(PREDEFMETH pdm);
    protected EXPRTYPEOF CreateTypeOf(CType CType);
    protected EXPR CreateWraps(EXPRBOUNDLAMBDA anonmeth);
    protected EXPR DestroyWraps(EXPRBOUNDLAMBDA anonmeth, EXPR sequence);
    protected virtual EXPR GenerateConstructor(EXPRCALL expr);
    protected virtual EXPR GenerateDelegateConstructor(EXPRCALL expr);
    protected virtual EXPR GenerateArgsList(EXPR oldArgs);
    protected virtual EXPR GenerateIndexList(EXPR oldIndices);
    protected virtual EXPR GenerateConstant(EXPR expr);
    protected EXPRCALL GenerateCall(PREDEFMETH pdm, EXPR arg1);
    protected EXPRCALL GenerateCall(PREDEFMETH pdm, EXPR arg1, EXPR arg2);
    protected EXPRCALL GenerateCall(PREDEFMETH pdm, EXPR arg1, EXPR arg2, EXPR arg3);
    protected EXPRCALL GenerateCall(PREDEFMETH pdm, EXPR arg1, EXPR arg2, EXPR arg3, EXPR arg4);
    protected virtual EXPRARRINIT GenerateParamsArray(EXPR args, PredefinedType pt);
    protected virtual EXPRARRINIT GenerateMembersArray(AggregateType anonymousType, PredefinedType pt);
    protected void FixLiftedUserDefinedBinaryOperators(EXPRBINOP expr, EXPR& pp1, EXPR& pp2);
    protected bool IsNullableValueType(CType pType);
    protected bool IsNullableValueAccess(EXPR pExpr, EXPR pObject);
    protected bool IsDelegateConstructorCall(EXPR pExpr);
    private static bool isEnumToDecimalConversion(CType argtype, CType desttype);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPREVENT : EXPR {
    public EXPR OptionalObject;
    public EventWithType ewt;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions : object {
    [ExtensionAttribute]
public static EXPR Map(EXPR expr, ExprFactory factory, Func`2<EXPR, EXPR> f);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.EXPRExtensions/<ToEnumerable>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<EXPR> ToEnumerable(EXPR expr);
    [ExtensionAttribute]
public static bool isSTMT(EXPR expr);
    [ExtensionAttribute]
public static EXPRSTMT asSTMT(EXPR expr);
    [ExtensionAttribute]
public static bool isBIN(EXPR expr);
    [ExtensionAttribute]
public static bool isUnaryOperator(EXPR expr);
    [ExtensionAttribute]
public static bool isLvalue(EXPR expr);
    [ExtensionAttribute]
public static bool isChecked(EXPR expr);
    [ExtensionAttribute]
public static EXPRBINOP asBIN(EXPR expr);
    [ExtensionAttribute]
public static EXPRUNARYOP asUnaryOperator(EXPR expr);
    [ExtensionAttribute]
public static bool isANYLOCAL(EXPR expr);
    [ExtensionAttribute]
public static EXPRLOCAL asANYLOCAL(EXPR expr);
    [ExtensionAttribute]
public static bool isANYLOCAL_OK(EXPR expr);
    [ExtensionAttribute]
public static bool isNull(EXPR expr);
    [ExtensionAttribute]
public static bool isZero(EXPR expr);
    [ExtensionAttribute]
public static EXPR GetSeqVal(EXPR expr);
    [ExtensionAttribute]
public static EXPR GetConst(EXPR expr);
    private static void RETAILVERIFY(bool f);
    [ExtensionAttribute]
public static EXPRRETURN asRETURN(EXPR expr);
    [ExtensionAttribute]
public static EXPRBINOP asBINOP(EXPR expr);
    [ExtensionAttribute]
public static EXPRLIST asLIST(EXPR expr);
    [ExtensionAttribute]
public static EXPRARRAYINDEX asARRAYINDEX(EXPR expr);
    [ExtensionAttribute]
public static EXPRCALL asCALL(EXPR expr);
    [ExtensionAttribute]
public static EXPREVENT asEVENT(EXPR expr);
    [ExtensionAttribute]
public static EXPRFIELD asFIELD(EXPR expr);
    [ExtensionAttribute]
public static EXPRCONSTANT asCONSTANT(EXPR expr);
    [ExtensionAttribute]
public static EXPRFUNCPTR asFUNCPTR(EXPR expr);
    [ExtensionAttribute]
public static EXPRPROP asPROP(EXPR expr);
    [ExtensionAttribute]
public static EXPRWRAP asWRAP(EXPR expr);
    [ExtensionAttribute]
public static EXPRARRINIT asARRINIT(EXPR expr);
    [ExtensionAttribute]
public static EXPRCAST asCAST(EXPR expr);
    [ExtensionAttribute]
public static EXPRUSERDEFINEDCONVERSION asUSERDEFINEDCONVERSION(EXPR expr);
    [ExtensionAttribute]
public static EXPRTYPEOF asTYPEOF(EXPR expr);
    [ExtensionAttribute]
public static EXPRZEROINIT asZEROINIT(EXPR expr);
    [ExtensionAttribute]
public static EXPRUSERLOGOP asUSERLOGOP(EXPR expr);
    [ExtensionAttribute]
public static EXPRMEMGRP asMEMGRP(EXPR expr);
    [ExtensionAttribute]
public static EXPRFIELDINFO asFIELDINFO(EXPR expr);
    [ExtensionAttribute]
public static EXPRMETHODINFO asMETHODINFO(EXPR expr);
    [ExtensionAttribute]
public static EXPRPropertyInfo asPropertyInfo(EXPR expr);
    [ExtensionAttribute]
public static EXPRNamedArgumentSpecification asNamedArgumentSpecification(EXPR expr);
    [ExtensionAttribute]
public static bool isCONSTANT_OK(EXPR expr);
    [ExtensionAttribute]
public static bool isRETURN(EXPR expr);
    [ExtensionAttribute]
public static bool isLIST(EXPR expr);
    [ExtensionAttribute]
public static bool isARRAYINDEX(EXPR expr);
    [ExtensionAttribute]
public static bool isCALL(EXPR expr);
    [ExtensionAttribute]
public static bool isFIELD(EXPR expr);
    [ExtensionAttribute]
public static bool isCONSTANT(EXPR expr);
    [ExtensionAttribute]
public static bool isCLASS(EXPR expr);
    [ExtensionAttribute]
public static bool isPROP(EXPR expr);
    [ExtensionAttribute]
public static bool isWRAP(EXPR expr);
    [ExtensionAttribute]
public static bool isARRINIT(EXPR expr);
    [ExtensionAttribute]
public static bool isCAST(EXPR expr);
    [ExtensionAttribute]
public static bool isUSERDEFINEDCONVERSION(EXPR expr);
    [ExtensionAttribute]
public static bool isTYPEOF(EXPR expr);
    [ExtensionAttribute]
public static bool isZEROINIT(EXPR expr);
    [ExtensionAttribute]
public static bool isMEMGRP(EXPR expr);
    [ExtensionAttribute]
public static bool isBOUNDLAMBDA(EXPR expr);
    [ExtensionAttribute]
public static bool isUNBOUNDLAMBDA(EXPR expr);
    [ExtensionAttribute]
public static bool isMETHODINFO(EXPR expr);
    [ExtensionAttribute]
public static bool isNamedArgumentSpecification(EXPR expr);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprFactory : object {
    private GlobalSymbolContext _globalSymbolContext;
    private ConstValFactory _constants;
    public ExprFactory(GlobalSymbolContext globalSymbolContext);
    public ConstValFactory GetExprConstants();
    private TypeManager GetTypes();
    private BSYMMGR GetGlobalSymbols();
    public EXPRCALL CreateCall(EXPRFLAG nFlags, CType pType, EXPR pOptionalArguments, EXPRMEMGRP pMemberGroup, MethWithInst MWI);
    public EXPRFIELD CreateField(EXPRFLAG nFlags, CType pType, EXPR pOptionalObject, UInt32 nOffset, FieldWithType FWT, EXPR pOptionalLHS);
    public EXPRFUNCPTR CreateFunctionPointer(EXPRFLAG nFlags, CType pType, EXPR pObject, MethWithInst MWI);
    public EXPRARRINIT CreateArrayInit(EXPRFLAG nFlags, CType pType, EXPR pOptionalArguments, EXPR pOptionalArgumentDimensions, Int32[] pDimSizes);
    public EXPRPROP CreateProperty(CType pType, EXPR pOptionalObject);
    public EXPRPROP CreateProperty(CType pType, EXPR pOptionalObjectThrough, EXPR pOptionalArguments, EXPRMEMGRP pMemberGroup, PropWithType pwtSlot, MethWithType mwtGet, MethWithType mwtSet);
    public EXPREVENT CreateEvent(CType pType, EXPR pOptionalObject, EventWithType EWT);
    public EXPRMEMGRP CreateMemGroup(EXPRFLAG nFlags, Name pName, TypeArray pTypeArgs, SYMKIND symKind, CType pTypePar, MethodOrPropertySymbol pMPS, EXPR pObject, CMemberLookupResults memberLookupResults);
    public EXPRMEMGRP CreateMemGroup(EXPR pObject, MethPropWithInst mwi);
    public EXPRUSERDEFINEDCONVERSION CreateUserDefinedConversion(EXPR arg, EXPR call, MethWithInst mwi);
    public EXPRCAST CreateCast(EXPRFLAG nFlags, CType pType, EXPR pArg);
    public EXPRCAST CreateCast(EXPRFLAG nFlags, EXPRTYPEORNAMESPACE pType, EXPR pArg);
    public EXPRRETURN CreateReturn(EXPRFLAG nFlags, Scope pCurrentScope, EXPR pOptionalObject);
    public EXPRRETURN CreateReturn(EXPRFLAG nFlags, Scope pCurrentScope, EXPR pOptionalObject, EXPR pOptionalOriginalObject);
    public EXPRLOCAL CreateLocal(EXPRFLAG nFlags, LocalVariableSymbol pLocal);
    public EXPRTHISPOINTER CreateThis(LocalVariableSymbol pLocal, bool fImplicit);
    public EXPRBOUNDLAMBDA CreateAnonymousMethod(AggregateType delegateType);
    public EXPRUNBOUNDLAMBDA CreateLambda();
    public EXPRHOISTEDLOCALEXPR CreateHoistedLocalInExpression(EXPRLOCAL localToHoist);
    public EXPRMETHODINFO CreateMethodInfo(MethPropWithInst mwi);
    public EXPRMETHODINFO CreateMethodInfo(MethodSymbol method, AggregateType methodType, TypeArray methodParameters);
    public EXPRPropertyInfo CreatePropertyInfo(PropertySymbol prop, AggregateType propertyType);
    public EXPRFIELDINFO CreateFieldInfo(FieldSymbol field, AggregateType fieldType);
    public EXPRTYPEOF CreateTypeOf(EXPRTYPEORNAMESPACE pSourceType);
    public EXPRTYPEOF CreateTypeOf(CType pSourceType);
    public EXPRUSERLOGOP CreateUserLogOp(CType pType, EXPR pCallTF, EXPRCALL pCallOp);
    public EXPRUSERLOGOP CreateUserLogOpError(CType pType, EXPR pCallTF, EXPRCALL pCallOp);
    public EXPRCONCAT CreateConcat(EXPR op1, EXPR op2);
    public EXPRCONSTANT CreateStringConstant(string str);
    public EXPRMULTIGET CreateMultiGet(EXPRFLAG nFlags, CType pType, EXPRMULTI pOptionalMulti);
    public EXPRMULTI CreateMulti(EXPRFLAG nFlags, CType pType, EXPR pLeft, EXPR pOp);
    public EXPR CreateZeroInit(CType pType);
    public EXPR CreateZeroInit(EXPRTYPEORNAMESPACE pTypeExpr);
    private EXPR CreateZeroInit(EXPRTYPEORNAMESPACE pTypeExpr, EXPR pOptionalOriginalConstructorCall, bool isConstructor);
    public EXPRCONSTANT CreateConstant(CType pType, CONSTVAL constVal);
    public EXPRCONSTANT CreateConstant(CType pType, CONSTVAL constVal, EXPR pOriginal);
    public EXPRCONSTANT CreateConstant(CType pType);
    public EXPRCONSTANT CreateIntegerConstant(int x);
    public EXPRCONSTANT CreateBoolConstant(bool b);
    public EXPRBLOCK CreateBlock(EXPRBLOCK pOptionalCurrentBlock, EXPRSTMT pOptionalStatements, Scope pOptionalScope);
    public EXPRQUESTIONMARK CreateQuestionMark(EXPR pTestExpression, EXPRBINOP pConsequence);
    public EXPRARRAYINDEX CreateArrayIndex(EXPR pArray, EXPR pIndex);
    public EXPRARRAYLENGTH CreateArrayLength(EXPR pArray);
    public EXPRBINOP CreateBinop(ExpressionKind exprKind, CType pType, EXPR p1, EXPR p2);
    public EXPRUNARYOP CreateUnaryOp(ExpressionKind exprKind, CType pType, EXPR pOperand);
    public EXPR CreateOperator(ExpressionKind exprKind, CType pType, EXPR pArg1, EXPR pOptionalArg2);
    public EXPRBINOP CreateUserDefinedBinop(ExpressionKind exprKind, CType pType, EXPR p1, EXPR p2, EXPR call, MethPropWithInst pmpwi);
    public EXPRUNARYOP CreateUserDefinedUnaryOperator(ExpressionKind exprKind, CType pType, EXPR pOperand, EXPR call, MethPropWithInst pmpwi);
    public EXPRUNARYOP CreateNeg(EXPRFLAG nFlags, EXPR pOperand);
    public EXPRBINOP CreateSequence(EXPR p1, EXPR p2);
    public EXPRBINOP CreateReverseSequence(EXPR p1, EXPR p2);
    public EXPRASSIGNMENT CreateAssignment(EXPR pLHS, EXPR pRHS);
    public EXPRNamedArgumentSpecification CreateNamedArgumentSpecification(Name pName, EXPR pValue);
    public EXPRWRAP CreateWrap(Scope pCurrentScope, EXPR pOptionalExpression);
    public EXPRWRAP CreateWrapNoAutoFree(Scope pCurrentScope, EXPR pOptionalWrap);
    public EXPRBINOP CreateSave(EXPRWRAP wrap);
    public EXPR CreateNull();
    public void AppendItemToList(EXPR newItem, EXPR& first, EXPR& last);
    public EXPRLIST CreateList(EXPR op1, EXPR op2);
    public EXPRLIST CreateList(EXPR op1, EXPR op2, EXPR op3);
    public EXPRLIST CreateList(EXPR op1, EXPR op2, EXPR op3, EXPR op4);
    public EXPRTYPEARGUMENTS CreateTypeArguments(TypeArray pTypeArray, EXPR pOptionalElements);
    public EXPRCLASS CreateClass(CType pType, EXPR pOptionalLHS, EXPRTYPEARGUMENTS pOptionalTypeArguments);
    public EXPRCLASS MakeClass(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFIELD : EXPR {
    public EXPR OptionalObject;
    public FieldWithType fwt;
    public EXPR GetOptionalObject();
    public void SetOptionalObject(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFIELDINFO : EXPR {
    private FieldSymbol _field;
    private AggregateType _fieldType;
    public FieldSymbol Field();
    public AggregateType FieldType();
    public void Init(FieldSymbol f, AggregateType ft);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFLAG : Enum {
    public int value__;
    public static EXPRFLAG EXF_BINOP;
    public static EXPRFLAG EXF_CTOR;
    public static EXPRFLAG EXF_NEEDSRET;
    public static EXPRFLAG EXF_ASLEAVE;
    public static EXPRFLAG EXF_ISFAULT;
    public static EXPRFLAG EXF_HASHTABLESWITCH;
    public static EXPRFLAG EXF_BOX;
    public static EXPRFLAG EXF_ARRAYCONST;
    public static EXPRFLAG EXF_MEMBERSET;
    public static EXPRFLAG EXF_OPENTYPE;
    public static EXPRFLAG EXF_LABELREFERENCED;
    public static EXPRFLAG EXF_GENERATEDQMARK;
    public static EXPRFLAG EXF_INDEXER;
    public static EXPRFLAG EXF_GOTOCASE;
    public static EXPRFLAG EXF_REMOVEFINALLY;
    public static EXPRFLAG EXF_UNBOX;
    public static EXPRFLAG EXF_ARRAYALLCONST;
    public static EXPRFLAG EXF_CTORPREAMBLE;
    public static EXPRFLAG EXF_USERLABEL;
    public static EXPRFLAG EXF_OPERATOR;
    public static EXPRFLAG EXF_ISPOSTOP;
    public static EXPRFLAG EXF_FINALLYBLOCKED;
    public static EXPRFLAG EXF_REFCHECK;
    public static EXPRFLAG EXF_WRAPASTEMP;
    public static EXPRFLAG EXF_LITERALCONST;
    public static EXPRFLAG EXF_BADGOTO;
    public static EXPRFLAG EXF_RETURNISYIELD;
    public static EXPRFLAG EXF_ISFINALLY;
    public static EXPRFLAG EXF_NEWOBJCALL;
    public static EXPRFLAG EXF_INDEXEXPR;
    public static EXPRFLAG EXF_REPLACEWRAP;
    public static EXPRFLAG EXF_UNREALIZEDGOTO;
    public static EXPRFLAG EXF_CONSTRAINED;
    public static EXPRFLAG EXF_FORCE_BOX;
    public static EXPRFLAG EXF_SIMPLENAME;
    public static EXPRFLAG EXF_ASFINALLYLEAVE;
    public static EXPRFLAG EXF_BASECALL;
    public static EXPRFLAG EXF_FORCE_UNBOX;
    public static EXPRFLAG EXF_ADDRNOCONV;
    public static EXPRFLAG EXF_GOTONOTBLOCKED;
    public static EXPRFLAG EXF_DELEGATE;
    public static EXPRFLAG EXF_STATIC_CAST;
    public static EXPRFLAG EXF_USERCALLABLE;
    public static EXPRFLAG EXF_UNBOXRUNTIME;
    public static EXPRFLAG EXF_NEWSTRUCTASSG;
    public static EXPRFLAG EXF_GENERATEDSTMT;
    public static EXPRFLAG EXF_IMPLICITSTRUCTASSG;
    public static EXPRFLAG EXF_MARKING;
    public static EXPRFLAG EXF_UNREACHABLEBEGIN;
    public static EXPRFLAG EXF_UNREACHABLEEND;
    public static EXPRFLAG EXF_USEORIGDEBUGINFO;
    public static EXPRFLAG EXF_LASTBRACEDEBUGINFO;
    public static EXPRFLAG EXF_NODEBUGINFO;
    public static EXPRFLAG EXF_IMPLICITTHIS;
    public static EXPRFLAG EXF_CANTBENULL;
    public static EXPRFLAG EXF_CHECKOVERFLOW;
    public static EXPRFLAG EXF_PUSH_OP_FIRST;
    public static EXPRFLAG EXF_ASSGOP;
    public static EXPRFLAG EXF_LVALUE;
    public static EXPRFLAG EXF_SAMENAMETYPE;
    public static EXPRFLAG EXF_MASK_ANY;
    public static EXPRFLAG EXF_CAST_ALL;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRFUNCPTR : EXPR {
    public MethWithInst mwi;
    public EXPR OptionalObject;
    public void SetOptionalObject(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRHOISTEDLOCALEXPR : EXPR {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRLIST : EXPR {
    public EXPR OptionalElement;
    public EXPR OptionalNextListNode;
    public EXPR GetOptionalElement();
    public void SetOptionalElement(EXPR value);
    public EXPR GetOptionalNextListNode();
    public void SetOptionalNextListNode(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRLOCAL : EXPR {
    public LocalVariableSymbol local;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRMEMGRP : EXPR {
    public Name name;
    public TypeArray typeArgs;
    public SYMKIND sk;
    public EXPR OptionalObject;
    public EXPR OptionalLHS;
    public CMemberLookupResults MemberLookupResults;
    public CType ParentType;
    public EXPR GetOptionalObject();
    public void SetOptionalObject(EXPR value);
    public EXPR GetOptionalLHS();
    public void SetOptionalLHS(EXPR lhs);
    public CMemberLookupResults GetMemberLookupResults();
    public void SetMemberLookupResults(CMemberLookupResults results);
    public CType GetParentType();
    public void SetParentType(CType type);
    public bool isDelegate();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRMETHODINFO : EXPR {
    public MethWithInst Method;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRMULTI : EXPR {
    public EXPR Left;
    public EXPR Operator;
    public EXPR GetLeft();
    public void SetLeft(EXPR value);
    public EXPR GetOperator();
    public void SetOperator(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRMULTIGET : EXPR {
    public EXPRMULTI OptionalMulti;
    public EXPRMULTI GetOptionalMulti();
    public void SetOptionalMulti(EXPRMULTI value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRNamedArgumentSpecification : EXPR {
    public Name Name;
    public EXPR Value;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRPROP : EXPR {
    public EXPR OptionalArguments;
    public EXPRMEMGRP MemberGroup;
    public EXPR OptionalObjectThrough;
    public PropWithType pwtSlot;
    public MethWithType mwtSet;
    public EXPR GetOptionalArguments();
    public void SetOptionalArguments(EXPR value);
    public EXPRMEMGRP GetMemberGroup();
    public void SetMemberGroup(EXPRMEMGRP value);
    public EXPR GetOptionalObjectThrough();
    public void SetOptionalObjectThrough(EXPR value);
    public bool isBaseCall();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRPropertyInfo : EXPR {
    public PropWithType Property;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRQUESTIONMARK : EXPR {
    public EXPR TestExpression;
    public EXPRBINOP Consequence;
    public EXPR GetTestExpression();
    public void SetTestExpression(EXPR value);
    public EXPRBINOP GetConsequence();
    public void SetConsequence(EXPRBINOP value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRRETURN : EXPRSTMT {
    public EXPR OptionalObject;
    public EXPR GetOptionalObject();
    public void SetOptionalObject(EXPR value);
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRSTMT : EXPR {
    private EXPRSTMT _NextStatement;
    public EXPRSTMT GetOptionalNextStatement();
    public void SetOptionalNextStatement(EXPRSTMT nextStatement);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRTHISPOINTER : EXPRLOCAL {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRTYPEARGUMENTS : EXPR {
    public EXPR OptionalElements;
    public EXPR GetOptionalElements();
    public void SetOptionalElements(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRTYPEOF : EXPR {
    public EXPRTYPEORNAMESPACE SourceType;
    public EXPRTYPEORNAMESPACE GetSourceType();
    public void SetSourceType(EXPRTYPEORNAMESPACE value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRTYPEORNAMESPACE : EXPR {
    public ITypeOrNamespace TypeOrNamespace;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRUNARYOP : EXPR {
    public EXPR Child;
    public EXPR OptionalUserDefinedCall;
    public MethWithInst predefinedMethodToCall;
    public MethPropWithInst UserDefinedCallMethod;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRUNBOUNDLAMBDA : EXPR {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRUSERDEFINEDCONVERSION : EXPR {
    public EXPR Argument;
    public EXPR UserDefinedCall;
    public MethWithInst UserDefinedCallMethod;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRUSERLOGOP : EXPR {
    public EXPR TrueFalseCall;
    public EXPRCALL OperatorCall;
    public EXPR FirstOperandToExamine;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ExprVisitorBase : object {
    public EXPR Visit(EXPR pExpr);
    protected EXPRSTMT DispatchStatementList(EXPRSTMT expr);
    protected bool IsCachedExpr(EXPR pExpr, EXPR& pTransformedExpr);
    protected EXPR CacheExprMapping(EXPR pExpr, EXPR pTransformedExpr);
    protected virtual EXPR Dispatch(EXPR pExpr);
    protected void VisitChildren(EXPR pExpr);
    protected virtual EXPR VisitEXPR(EXPR pExpr);
    protected virtual EXPR VisitBLOCK(EXPRBLOCK pExpr);
    protected virtual EXPR VisitTHISPOINTER(EXPRTHISPOINTER pExpr);
    protected virtual EXPR VisitRETURN(EXPRRETURN pExpr);
    protected virtual EXPR VisitCLASS(EXPRCLASS pExpr);
    protected virtual EXPR VisitSTMT(EXPRSTMT pExpr);
    protected virtual EXPR VisitBINOP(EXPRBINOP pExpr);
    protected virtual EXPR VisitLIST(EXPRLIST pExpr);
    protected virtual EXPR VisitASSIGNMENT(EXPRASSIGNMENT pExpr);
    protected virtual EXPR VisitQUESTIONMARK(EXPRQUESTIONMARK pExpr);
    protected virtual EXPR VisitARRAYINDEX(EXPRARRAYINDEX pExpr);
    protected virtual EXPR VisitARRAYLENGTH(EXPRARRAYLENGTH pExpr);
    protected virtual EXPR VisitUNARYOP(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitUSERLOGOP(EXPRUSERLOGOP pExpr);
    protected virtual EXPR VisitTYPEOF(EXPRTYPEOF pExpr);
    protected virtual EXPR VisitCAST(EXPRCAST pExpr);
    protected virtual EXPR VisitUSERDEFINEDCONVERSION(EXPRUSERDEFINEDCONVERSION pExpr);
    protected virtual EXPR VisitZEROINIT(EXPRZEROINIT pExpr);
    protected virtual EXPR VisitMEMGRP(EXPRMEMGRP pExpr);
    protected virtual EXPR VisitCALL(EXPRCALL pExpr);
    protected virtual EXPR VisitPROP(EXPRPROP pExpr);
    protected virtual EXPR VisitFIELD(EXPRFIELD pExpr);
    protected virtual EXPR VisitEVENT(EXPREVENT pExpr);
    protected virtual EXPR VisitLOCAL(EXPRLOCAL pExpr);
    protected virtual EXPR VisitCONSTANT(EXPRCONSTANT pExpr);
    protected virtual EXPR VisitTYPEARGUMENTS(EXPRTYPEARGUMENTS pExpr);
    protected virtual EXPR VisitTYPEORNAMESPACE(EXPRTYPEORNAMESPACE pExpr);
    protected virtual EXPR VisitFUNCPTR(EXPRFUNCPTR pExpr);
    protected virtual EXPR VisitMULTIGET(EXPRMULTIGET pExpr);
    protected virtual EXPR VisitMULTI(EXPRMULTI pExpr);
    protected virtual EXPR VisitWRAP(EXPRWRAP pExpr);
    protected virtual EXPR VisitCONCAT(EXPRCONCAT pExpr);
    protected virtual EXPR VisitARRINIT(EXPRARRINIT pExpr);
    protected virtual EXPR VisitBOUNDLAMBDA(EXPRBOUNDLAMBDA pExpr);
    protected virtual EXPR VisitUNBOUNDLAMBDA(EXPRUNBOUNDLAMBDA pExpr);
    protected virtual EXPR VisitHOISTEDLOCALEXPR(EXPRHOISTEDLOCALEXPR pExpr);
    protected virtual EXPR VisitFIELDINFO(EXPRFIELDINFO pExpr);
    protected virtual EXPR VisitMETHODINFO(EXPRMETHODINFO pExpr);
    protected virtual EXPR VisitEQUALS(EXPRBINOP pExpr);
    protected virtual EXPR VisitCOMPARE(EXPRBINOP pExpr);
    protected virtual EXPR VisitEQ(EXPRBINOP pExpr);
    protected virtual EXPR VisitNE(EXPRBINOP pExpr);
    protected virtual EXPR VisitLE(EXPRBINOP pExpr);
    protected virtual EXPR VisitGE(EXPRBINOP pExpr);
    protected virtual EXPR VisitADD(EXPRBINOP pExpr);
    protected virtual EXPR VisitSUB(EXPRBINOP pExpr);
    protected virtual EXPR VisitDIV(EXPRBINOP pExpr);
    protected virtual EXPR VisitBITAND(EXPRBINOP pExpr);
    protected virtual EXPR VisitBITOR(EXPRBINOP pExpr);
    protected virtual EXPR VisitLSHIFT(EXPRBINOP pExpr);
    protected virtual EXPR VisitLOGAND(EXPRBINOP pExpr);
    protected virtual EXPR VisitSEQUENCE(EXPRBINOP pExpr);
    protected virtual EXPR VisitSAVE(EXPRBINOP pExpr);
    protected virtual EXPR VisitINDIR(EXPRBINOP pExpr);
    protected virtual EXPR VisitSTRINGEQ(EXPRBINOP pExpr);
    protected virtual EXPR VisitDELEGATEEQ(EXPRBINOP pExpr);
    protected virtual EXPR VisitDELEGATEADD(EXPRBINOP pExpr);
    protected virtual EXPR VisitRANGE(EXPRBINOP pExpr);
    protected virtual EXPR VisitLT(EXPRBINOP pExpr);
    protected virtual EXPR VisitMUL(EXPRBINOP pExpr);
    protected virtual EXPR VisitBITXOR(EXPRBINOP pExpr);
    protected virtual EXPR VisitRSHIFT(EXPRBINOP pExpr);
    protected virtual EXPR VisitLOGOR(EXPRBINOP pExpr);
    protected virtual EXPR VisitSEQREV(EXPRBINOP pExpr);
    protected virtual EXPR VisitSTRINGNE(EXPRBINOP pExpr);
    protected virtual EXPR VisitDELEGATENE(EXPRBINOP pExpr);
    protected virtual EXPR VisitGT(EXPRBINOP pExpr);
    protected virtual EXPR VisitMOD(EXPRBINOP pExpr);
    protected virtual EXPR VisitSWAP(EXPRBINOP pExpr);
    protected virtual EXPR VisitDELEGATESUB(EXPRBINOP pExpr);
    protected virtual EXPR VisitTRUE(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitINC(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitLOGNOT(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitNEG(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitBITNOT(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitADDR(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitDECIMALNEG(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitDECIMALDEC(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitFALSE(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitDEC(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitUPLUS(EXPRUNARYOP pExpr);
    protected virtual EXPR VisitDECIMALINC(EXPRUNARYOP pExpr);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRWRAP : EXPR {
    public EXPR OptionalExpression;
    public EXPR GetOptionalExpression();
    public void SetOptionalExpression(EXPR value);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.EXPRZEROINIT : EXPR {
    public EXPR OptionalArgument;
    public EXPR OptionalConstructorCall;
    public bool IsConstructor;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldSymbol : VariableSymbol {
    public bool isStatic;
    public bool isReadOnly;
    public bool isEvent;
    public bool isAssigned;
    public FieldInfo AssociatedFieldInfo;
    public AggregateDeclaration declaration;
    public void SetType(CType pType);
    public CType GetType();
    public AggregateSymbol getClass();
    public AggregateDeclaration containingDeclaration();
    public EventSymbol getEvent(SymbolLoader symbolLoader);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FieldWithType : SymWithType {
    public FieldWithType(FieldSymbol field, AggregateType ats);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.FileRecord : object {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.ForeachKind : Enum {
    public int value__;
    public static ForeachKind Array;
    public static ForeachKind String;
    public static ForeachKind Enumerator;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.FUNDTYPE : Enum {
    public int value__;
    public static FUNDTYPE FT_NONE;
    public static FUNDTYPE FT_I1;
    public static FUNDTYPE FT_I2;
    public static FUNDTYPE FT_I4;
    public static FUNDTYPE FT_U1;
    public static FUNDTYPE FT_U2;
    public static FUNDTYPE FT_U4;
    public static FUNDTYPE FT_LASTNONLONG;
    public static FUNDTYPE FT_I8;
    public static FUNDTYPE FT_U8;
    public static FUNDTYPE FT_LASTINTEGRAL;
    public static FUNDTYPE FT_R4;
    public static FUNDTYPE FT_R8;
    public static FUNDTYPE FT_LASTNUMERIC;
    public static FUNDTYPE FT_REF;
    public static FUNDTYPE FT_STRUCT;
    public static FUNDTYPE FT_PTR;
    public static FUNDTYPE FT_VAR;
    public static FUNDTYPE FT_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.GlobalAttributeDeclaration : Symbol {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.GlobalSymbolContext : object {
    private PredefinedTypes _predefTypes;
    private NameManager _nameManager;
    [CompilerGeneratedAttribute]
private TypeManager <TypeManager>k__BackingField;
    [CompilerGeneratedAttribute]
private BSYMMGR <GlobalSymbols>k__BackingField;
    public TypeManager TypeManager { get; private set; }
    public BSYMMGR GlobalSymbols { get; private set; }
    public GlobalSymbolContext(NameManager namemgr);
    [CompilerGeneratedAttribute]
public TypeManager get_TypeManager();
    [CompilerGeneratedAttribute]
private void set_TypeManager(TypeManager value);
    public TypeManager GetTypes();
    [CompilerGeneratedAttribute]
public BSYMMGR get_GlobalSymbols();
    [CompilerGeneratedAttribute]
private void set_GlobalSymbols(BSYMMGR value);
    public BSYMMGR GetGlobalSymbols();
    public NameManager GetNameManager();
    public PredefinedTypes GetPredefTypes();
    public SymFactory GetGlobalSymbolFactory();
    public MiscSymFactory GetGlobalMiscSymFactory();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.IndexerSymbol : PropertySymbol {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.InitializerKind : Enum {
    public int value__;
    public static InitializerKind CollectionInitializer;
    public static InitializerKind ObjectInitializer;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.InputFile : FileRecord {
    private HashSet`1<KAID> _bsetFilter;
    private KAID _aid;
    public bool isSource;
    public void SetAssemblyID(KAID aid);
    public void AddToAlias(KAID aid);
    public void UnionAliasFilter(HashSet`1& bsetDst);
    public KAID GetAssemblyID();
    public bool InAlias(KAID aid);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.InterfaceImplementationMethodSymbol : MethodSymbol {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.IteratorFinallyMethodSymbol : MethodSymbol {
}
internal interface Microsoft.CSharp.RuntimeBinder.Semantics.ITypeOrNamespace {
    public abstract virtual bool IsType();
    public abstract virtual bool IsNamespace();
    public abstract virtual AssemblyQualifiedNamespaceSymbol AsNamespace();
    public abstract virtual CType AsType();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.KAID : Enum {
    public int value__;
    public static KAID kaidNil;
    public static KAID kaidGlobal;
    public static KAID kaidErrorAssem;
    public static KAID kaidThisAssembly;
    public static KAID kaidUnresolved;
    public static KAID kaidStartAssigning;
    public static KAID kaidMinModule;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.KeyPair`2 : ValueType {
    private Key1 _pKey1;
    private Key2 _pKey2;
    public KeyPair`2(Key1 pKey1, Key2 pKey2);
    public sealed virtual bool Equals(KeyPair`2<Key1, Key2> other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.LabelSymbol : Symbol {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.LambdaParams : Enum {
    public int value__;
    public static LambdaParams FromDelegate;
    public static LambdaParams FromLambda;
    public static LambdaParams Error;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.LangCompiler : CSemanticChecker {
    private SymbolLoader _symbolLoader;
    private CController _pController;
    private ErrorHandling _errorContext;
    private GlobalSymbolContext _globalSymbolContext;
    private UserStringBuilder _userStringBuilder;
    public SymbolLoader SymbolLoader { get; }
    public LangCompiler(CController pCtrl, NameManager pNameMgr);
    public ErrorHandling GetErrorContext();
    public virtual SymbolLoader get_SymbolLoader();
    public virtual SymbolLoader GetSymbolLoader();
    public sealed virtual void SubmitError(CParameterizedError error);
    public sealed virtual int ErrorCount();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.LiftFlags : Enum {
    public int value__;
    public static LiftFlags None;
    public static LiftFlags Lift1;
    public static LiftFlags Lift2;
    public static LiftFlags Convert1;
    public static LiftFlags Convert2;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.ListExtensions : object {
    [ExtensionAttribute]
public static bool IsEmpty(List`1<T> list);
    [ExtensionAttribute]
public static T Head(List`1<T> list);
    [ExtensionAttribute]
public static List`1<T> Tail(List`1<T> list);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.LocalVariableSymbol : VariableSymbol {
    public EXPRWRAP wrap;
    public bool isThis;
    public bool fUsedInAnonMeth;
    public void SetType(CType pType);
    public CType GetType();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.mdToken : Enum {
    public int value__;
    public static mdToken mdtModule;
    public static mdToken mdtTypeRef;
    public static mdToken mdtTypeDef;
    public static mdToken mdtFieldDef;
    public static mdToken mdtMethodDef;
    public static mdToken mdtParamDef;
    public static mdToken mdtInterfaceImpl;
    public static mdToken mdtMemberRef;
    public static mdToken mdtCustomAttribute;
    public static mdToken mdtPermission;
    public static mdToken mdtSignature;
    public static mdToken mdtEvent;
    public static mdToken mdtProperty;
    public static mdToken mdtModuleRef;
    public static mdToken mdtTypeSpec;
    public static mdToken mdtAssembly;
    public static mdToken mdtAssemblyRef;
    public static mdToken mdtFile;
    public static mdToken mdtExportedType;
    public static mdToken mdtManifestResource;
    public static mdToken mdtGenericParam;
    public static mdToken mdtMethodSpec;
    public static mdToken mdtGenericParamConstraint;
    public static mdToken mdtString;
    public static mdToken mdtName;
    public static mdToken mdtBaseType;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MemberLookup : object {
    private CSemanticChecker _pSemanticChecker;
    private SymbolLoader _pSymbolLoader;
    private CType _typeSrc;
    private EXPR _obj;
    private CType _typeQual;
    private ParentSymbol _symWhere;
    private Name _name;
    private int _arity;
    private MemLookFlags _flags;
    private CMemberLookupResults _results;
    private List`1<AggregateType> _rgtypeStart;
    private List`1<AggregateType> _prgtype;
    private int _csym;
    private SymWithType _swtFirst;
    private List`1<MethPropWithType> _methPropWithTypeList;
    private SymWithType _swtAmbig;
    private SymWithType _swtInaccess;
    private SymWithType _swtBad;
    private SymWithType _swtBogus;
    private SymWithType _swtBadArity;
    private SymWithType _swtAmbigWarn;
    private SymWithType _swtOverride;
    private bool _fMulti;
    private void RecordType(AggregateType type, Symbol sym);
    private bool SearchSingleType(AggregateType typeCur, Boolean& pfHideByName);
    private bool IsDynamicMember(Symbol sym);
    private bool LookupInClass(AggregateType typeStart, AggregateType& ptypeEnd);
    private bool LookupInInterfaces(AggregateType typeStart, TypeArray types);
    private SymbolLoader GetSymbolLoader();
    private CSemanticChecker GetSemanticChecker();
    private ErrorHandling GetErrorContext();
    private void ReportBogus(SymWithType swt);
    private void ReportBogusForEventsAndProperties(SymWithType swt, MethodSymbol meth1, MethodSymbol meth2);
    private bool IsDelegateType(CType pSrcType, AggregateType pAggType);
    public bool Lookup(CSemanticChecker checker, CType typeSrc, EXPR obj, ParentSymbol symWhere, Name name, int arity, MemLookFlags flags);
    public CMemberLookupResults GetResults();
    public bool FError();
    public Symbol SymFirst();
    public SymWithType SwtFirst();
    public SymWithType SwtInaccessible();
    public EXPR GetObject();
    public CType GetSourceType();
    public MemLookFlags GetFlags();
    public TypeArray GetAllTypes();
    public void ReportErrors();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MemLookFlags : Enum {
    public UInt32 value__;
    public static MemLookFlags None;
    public static MemLookFlags Ctor;
    public static MemLookFlags NewObj;
    public static MemLookFlags Operator;
    public static MemLookFlags Indexer;
    public static MemLookFlags UserCallable;
    public static MemLookFlags BaseCall;
    public static MemLookFlags MustBeInvocable;
    public static MemLookFlags TypeVarsAllowed;
    public static MemLookFlags ExtensionCall;
    public static MemLookFlags All;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodCallingConventionEnum : Enum {
    public int value__;
    public static MethodCallingConventionEnum Static;
    public static MethodCallingConventionEnum Virtual;
    public static MethodCallingConventionEnum Instance;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodGroupType : CType {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodKindEnum : Enum {
    public int value__;
    public static MethodKindEnum None;
    public static MethodKindEnum Constructor;
    public static MethodKindEnum Destructor;
    public static MethodKindEnum PropAccessor;
    public static MethodKindEnum EventAccessor;
    public static MethodKindEnum ExplicitConv;
    public static MethodKindEnum ImplicitConv;
    public static MethodKindEnum Anonymous;
    public static MethodKindEnum Invoke;
    public static MethodKindEnum BeginInvoke;
    public static MethodKindEnum EndInvoke;
    public static MethodKindEnum AnonymousTypeToString;
    public static MethodKindEnum AnonymousTypeEquals;
    public static MethodKindEnum AnonymousTypeGetHashCode;
    public static MethodKindEnum IteratorDispose;
    public static MethodKindEnum IteratorReset;
    public static MethodKindEnum IteratorGetEnumerator;
    public static MethodKindEnum IteratorGetEnumeratorDelegating;
    public static MethodKindEnum IteratorMoveNext;
    public static MethodKindEnum Latent;
    public static MethodKindEnum Actual;
    public static MethodKindEnum IteratorFinally;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodOrPropertySymbol : ParentSymbol {
    public UInt32 modOptCount;
    public bool isStatic;
    public bool isOverride;
    public bool useMethInstead;
    public bool isOperator;
    public bool isParamArray;
    public bool isHideByName;
    [CompilerGeneratedAttribute]
private List`1<Name> <ParameterNames>k__BackingField;
    private Boolean[] _optionalParameterIndex;
    private Boolean[] _defaultParameterIndex;
    private CONSTVAL[] _defaultParameters;
    private CType[] _defaultParameterConstValTypes;
    private Boolean[] _marshalAsIndex;
    private UnmanagedType[] _marshalAsBuffer;
    public SymWithType swtSlot;
    public ErrorType errExpImpl;
    public CType RetType;
    private TypeArray _Params;
    public AggregateDeclaration declaration;
    public List`1<Name> ParameterNames { get; private set; }
    public TypeArray Params { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<Name> get_ParameterNames();
    [CompilerGeneratedAttribute]
private void set_ParameterNames(List`1<Name> value);
    public TypeArray get_Params();
    public void set_Params(TypeArray value);
    public bool IsParameterOptional(int index);
    public void SetOptionalParameter(int index);
    public bool HasOptionalParameters();
    public bool HasDefaultParameterValue(int index);
    public void SetDefaultParameterValue(int index, CType type, CONSTVAL cv);
    public CONSTVAL GetDefaultParameterValue(int index);
    public CType GetDefaultParameterValueConstValType(int index);
    public bool IsMarshalAsParameter(int index);
    public void SetMarshalAsParameter(int index, UnmanagedType umt);
    public UnmanagedType GetMarshalAsParameterValue(int index);
    public bool MarshalAsObject(int index);
    public AggregateSymbol getClass();
    public bool IsExpImpl();
    public AggregateDeclaration containingDeclaration();
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodRequiredEnum : Enum {
    public int value__;
    public static MethodRequiredEnum Required;
    public static MethodRequiredEnum Optional;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.MethodSignatureEnum : Enum {
    public int value__;
    public static MethodSignatureEnum SIG_CLASS_TYVAR;
    public static MethodSignatureEnum SIG_METH_TYVAR;
    public static MethodSignatureEnum SIG_SZ_ARRAY;
    public static MethodSignatureEnum SIG_REF;
    public static MethodSignatureEnum SIG_OUT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodSymbol : MethodOrPropertySymbol {
    private MethodKindEnum _methKind;
    private bool _inferenceMustFail;
    private bool _checkedInfMustFail;
    private MethodSymbol _convNext;
    private PropertySymbol _prop;
    private EventSymbol _evt;
    public bool isExtension;
    public bool isExternal;
    public bool isVirtual;
    public bool isAbstract;
    public bool isVarargs;
    public MemberInfo AssociatedMemberInfo;
    public TypeArray typeVars;
    public bool InferenceMustFail();
    public bool IsExtension();
    public MethodKindEnum MethKind();
    public bool IsConstructor();
    public bool IsNullableConstructor();
    public bool IsDestructor();
    public bool isPropertyAccessor();
    public bool isEventAccessor();
    public bool isExplicit();
    public bool isImplicit();
    public bool isInvoke();
    public void SetMethKind(MethodKindEnum mk);
    public MethodSymbol ConvNext();
    public void SetConvNext(MethodSymbol conv);
    public PropertySymbol getProperty();
    public void SetProperty(PropertySymbol prop);
    public EventSymbol getEvent();
    public void SetEvent(EventSymbol evt);
    public bool isConversionOperator();
    public bool isUserCallable();
    public bool isAnyAccessor();
    public bool isSetAccessor();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethodTypeInferrer : object {
    private SymbolLoader _symbolLoader;
    private ExpressionBinder _binder;
    private TypeArray _pMethodTypeParameters;
    private TypeArray _pClassTypeArguments;
    private TypeArray _pMethodFormalParameterTypes;
    private ArgInfos _pMethodArguments;
    private List`1[] _pExactBounds;
    private List`1[] _pUpperBounds;
    private List`1[] _pLowerBounds;
    private CType[] _pFixedResults;
    private Dependency[][] _ppDependencies;
    private bool _dependenciesDirty;
    private MethodTypeInferrer(ExpressionBinder exprBinder, SymbolLoader symLoader, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray pMethodTypeParameters, TypeArray pClassTypeArguments);
    public static bool Infer(ExpressionBinder binder, SymbolLoader symbolLoader, MethodSymbol pMethod, TypeArray pClassTypeArguments, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments, TypeArray& ppInferredTypeArguments);
    private TypeArray GetResults();
    private bool IsUnfixed(int iParam);
    private bool IsUnfixed(TypeParameterType pParam);
    private bool AllFixed();
    private void AddLowerBound(TypeParameterType pParam, CType pBound);
    private void AddUpperBound(TypeParameterType pParam, CType pBound);
    private void AddExactBound(TypeParameterType pParam, CType pBound);
    private bool HasBound(int iParam);
    private TypeArray GetFixedDelegateParameters(AggregateType pDelegateType);
    private bool InferTypeArgs();
    private static bool IsReallyAType(CType pType);
    private void InferTypeArgsFirstPhase();
    private bool InferTypeArgsSecondPhase();
    private NewInferenceResult DoSecondPhase();
    private void MakeOutputTypeInferences();
    private NewInferenceResult FixNondependentParameters();
    private NewInferenceResult FixDependentParameters();
    private bool DoesInputTypeContain(EXPR pSource, CType pDest, TypeParameterType pParam);
    private bool HasUnfixedParamInInputType(EXPR pSource, CType pDest);
    private bool DoesOutputTypeContain(EXPR pSource, CType pDest, TypeParameterType pParam);
    private bool HasUnfixedParamInOutputType(EXPR pSource, CType pDest);
    private bool DependsDirectlyOn(int iParam, int jParam);
    private void InitializeDependencies();
    private bool DependsOn(int iParam, int jParam);
    private bool DependsTransitivelyOn(int iParam, int jParam);
    private void DeduceAllDependencies();
    private bool DeduceDependencies();
    private void SetUnknownsToNotDependent();
    private void SetIndirectsToUnknown();
    private void UpdateDependenciesAfterFix(int iParam);
    private bool DependsOnAny(int iParam);
    private bool AnyDependsOn(int iParam);
    private void OutputTypeInference(EXPR pExpr, CType pSource, CType pDest);
    private bool MethodGroupReturnTypeInference(EXPR pSource, CType pType);
    private void ExactInference(CType pSource, CType pDest);
    private bool ExactTypeParameterInference(CType pSource, CType pDest);
    private bool ExactArrayInference(CType pSource, CType pDest);
    private bool ExactNullableInference(CType pSource, CType pDest);
    private bool ExactConstructedInference(CType pSource, CType pDest);
    private void ExactTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private void LowerBoundInference(CType pSource, CType pDest);
    private bool LowerBoundTypeParameterInference(CType pSource, CType pDest);
    private bool LowerBoundArrayInference(CType pSource, CType pDest);
    private bool LowerBoundConstructedInference(CType pSource, CType pDest);
    private bool LowerBoundClassInference(CType pSource, AggregateType pDest);
    private bool LowerBoundInterfaceInference(CType pSource, AggregateType pDest);
    private void LowerBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private void UpperBoundInference(CType pSource, CType pDest);
    private bool UpperBoundTypeParameterInference(CType pSource, CType pDest);
    private bool UpperBoundArrayInference(CType pSource, CType pDest);
    private bool UpperBoundConstructedInference(CType pSource, CType pDest);
    private bool UpperBoundClassInference(AggregateType pSource, CType pDest);
    private bool UpperBoundInterfaceInference(AggregateType pSource, CType pDest);
    private void UpperBoundTypeArgumentInference(AggregateType pSource, AggregateType pDest);
    private bool Fix(int iParam);
    private bool InferForMethodGroupConversion();
    private SymbolLoader GetSymbolLoader();
    private TypeManager GetTypeManager();
    private BSYMMGR GetGlobalSymbols();
    public static bool CanObjectOfExtensionBeInferred(ExpressionBinder binder, SymbolLoader symbolLoader, MethodSymbol pMethod, TypeArray pClassTypeArguments, TypeArray pMethodFormalParameterTypes, ArgInfos pMethodArguments);
    private bool CanInferExtensionObject();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithInst : MethPropWithType {
    [CompilerGeneratedAttribute]
private TypeArray <TypeArgs>k__BackingField;
    public TypeArray TypeArgs { get; private set; }
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats);
    public MethPropWithInst(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
    [CompilerGeneratedAttribute]
public TypeArray get_TypeArgs();
    [CompilerGeneratedAttribute]
private void set_TypeArgs(TypeArray value);
    public virtual void Clear();
    public void Set(MethodOrPropertySymbol mps, AggregateType ats, TypeArray typeArgs);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethPropWithType : SymWithType {
    public MethPropWithType(MethodOrPropertySymbol mps, AggregateType ats);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithInst : MethPropWithInst {
    public MethWithInst(MethodSymbol meth, AggregateType ats);
    public MethWithInst(MethodSymbol meth, AggregateType ats, TypeArray typeArgs);
    public MethWithInst(MethPropWithInst mpwi);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MethWithType : MethPropWithType {
    public MethWithType(MethodSymbol meth, AggregateType ats);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.MiscSymFactory : SymFactoryBase {
    public MiscSymFactory(SYMTBL symtable);
    public InputFile CreateMDInfile(Name name, mdToken idLocalAssembly);
    public Scope CreateScope(Scope parent);
    public IndexerSymbol CreateIndexer(Name name, ParentSymbol parent, Name realName, AggregateDeclaration declaration);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NameGenerator : object {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceDeclaration : Declaration {
    public NamespaceSymbol Bag();
    public NamespaceSymbol NameSpace();
}
internal abstract class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceOrAggregateSymbol : ParentSymbol {
    private Declaration _declFirst;
    private Declaration _declLast;
    public Declaration DeclFirst();
    public void AddDecl(Declaration decl);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NamespaceSymbol : NamespaceOrAggregateSymbol {
    private HashSet`1<KAID> _bsetFilter;
    public bool InAlias(KAID aid);
    public void DeclAdded(NamespaceDeclaration decl);
    public void AddAid(KAID aid);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.NullableCallLiftKind : Enum {
    public int value__;
    public static NullableCallLiftKind NotLifted;
    public static NullableCallLiftKind Operator;
    public static NullableCallLiftKind EqualityOperator;
    public static NullableCallLiftKind InequalityOperator;
    public static NullableCallLiftKind UserDefinedConversion;
    public static NullableCallLiftKind NullableConversion;
    public static NullableCallLiftKind NullableConversionConstructor;
    public static NullableCallLiftKind NullableIntermediateConversion;
    public static NullableCallLiftKind NotLiftedIntermediateConversion;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullableType : CType {
    public AggregateType ats;
    public BSYMMGR symmgr;
    public TypeManager typeManager;
    public CType UnderlyingType;
    public AggregateType GetAts(ErrorHandling errorContext);
    public CType GetUnderlyingType();
    public void SetUnderlyingType(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.NullType : CType {
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.OpenTypePlaceholderType : CType {
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.Operators : object {
    private static Dictionary`2<OperatorKind, OPINFO> s_rgOpInfo;
    private static Operators();
    private static OPINFO GetInfo(OperatorKind op);
    public static OperatorKind OperatorOfMethodName(NameManager namemgr, Name name);
    public static bool HasMethodName(OperatorKind op);
    public static PredefinedName GetMethodName(OperatorKind op);
    public static Name GetMethodName(NameManager namemgr, OperatorKind op);
    public static bool HasDisplayName(OperatorKind op);
    public static string GetDisplayName(OperatorKind op);
    public static ExpressionKind GetExpressionKind(OperatorKind op);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.OpSigFlags : Enum {
    public int value__;
    public static OpSigFlags None;
    public static OpSigFlags Convert;
    public static OpSigFlags CanLift;
    public static OpSigFlags AutoLift;
    public static OpSigFlags Value;
    public static OpSigFlags Reference;
    public static OpSigFlags BoolBit;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.OutputContext : object {
    public LocalVariableSymbol m_pThisPointer;
    public MethodSymbol m_pCurrentMethodSymbol;
    public bool m_bUnsafeErrorGiven;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ParameterModifierType : CType {
    public bool isOut;
    private CType _pParameterType;
    public CType GetParameterType();
    public void SetParameterType(CType pType);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.ParentSymbol : Symbol {
    public Symbol firstChild;
    private Symbol _lastChild;
    public void AddToChildList(Symbol sym);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PointerType : CType {
    private CType _pReferentType;
    public CType GetReferentType();
    public void SetReferentType(CType pType);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFATTR : Enum {
    public int value__;
    public static PREDEFATTR PA_ATTRIBUTEUSAGE;
    public static PREDEFATTR PA_OBSOLETE;
    public static PREDEFATTR PA_CLSCOMPLIANT;
    public static PREDEFATTR PA_CONDITIONAL;
    public static PREDEFATTR PA_REQUIRED;
    public static PREDEFATTR PA_FIXED;
    public static PREDEFATTR PA_DEBUGGABLE;
    public static PREDEFATTR PA_ASSEMBLYFLAGS;
    public static PREDEFATTR PA_ASSEMBLYVERSION;
    public static PREDEFATTR PA_ASSEMBLYCULTURE;
    public static PREDEFATTR PA_NAME;
    public static PREDEFATTR PA_DLLIMPORT;
    public static PREDEFATTR PA_COMIMPORT;
    public static PREDEFATTR PA_GUID;
    public static PREDEFATTR PA_IN;
    public static PREDEFATTR PA_OUT;
    public static PREDEFATTR PA_STRUCTOFFSET;
    public static PREDEFATTR PA_STRUCTLAYOUT;
    public static PREDEFATTR PA_PARAMARRAY;
    public static PREDEFATTR PA_COCLASS;
    public static PREDEFATTR PA_DEFAULTCHARSET;
    public static PREDEFATTR PA_DEFAULTVALUE;
    public static PREDEFATTR PA_UNMANAGEDFUNCTIONPOINTER;
    public static PREDEFATTR PA_COMPILATIONRELAXATIONS;
    public static PREDEFATTR PA_RUNTIMECOMPATIBILITY;
    public static PREDEFATTR PA_FRIENDASSEMBLY;
    public static PREDEFATTR PA_KEYFILE;
    public static PREDEFATTR PA_KEYNAME;
    public static PREDEFATTR PA_DELAYSIGN;
    public static PREDEFATTR PA_DEFAULTMEMBER;
    public static PREDEFATTR PA_TYPEFORWARDER;
    public static PREDEFATTR PA_EXTENSION;
    public static PREDEFATTR PA_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMembers : object {
    private SymbolLoader _loader;
    internal SymbolTable RuntimeBinderSymbolTable;
    private MethodSymbol[] _methods;
    private PropertySymbol[] _properties;
    private static Int32[] s_DelegateCtorSignature1;
    private static Int32[] s_DelegateCtorSignature2;
    private static PredefinedPropertyInfo[] s_predefinedProperties;
    private static PredefinedMethodInfo[] s_predefinedMethods;
    public PredefinedMembers(SymbolLoader loader);
    private static PredefinedMembers();
    protected static void RETAILVERIFY(bool f);
    private Name GetMethName(PREDEFMETH method);
    private AggregateSymbol GetMethParent(PREDEFMETH method);
    private MethodSymbol FindDelegateConstructor(AggregateSymbol delegateType, Int32[] signature);
    private MethodSymbol FindDelegateConstructor(AggregateSymbol delegateType);
    public MethodSymbol FindDelegateConstructor(AggregateSymbol delegateType, bool fReportErrors);
    private PropertySymbol EnsureProperty(PREDEFPROP property);
    private PropertySymbol LoadProperty(PREDEFPROP property);
    private Name GetPropName(PREDEFPROP property);
    private PropertySymbol LoadProperty(PREDEFPROP predefProp, Name propertyName, PREDEFMETH propertyGetter, PREDEFMETH propertySetter);
    private SymbolLoader GetSymbolLoader();
    private ErrorHandling GetErrorContext();
    private NameManager GetNameManager();
    private TypeManager GetTypeManager();
    private BSYMMGR getBSymmgr();
    private Name GetPredefName(PredefinedName pn);
    private AggregateSymbol GetOptPredefAgg(PredefinedType pt);
    private CType LoadTypeFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    private TypeArray LoadTypeArrayFromSignature(Int32[] signature, Int32& indexIntoSignatures, TypeArray classTyVars);
    public PropertySymbol GetProperty(PREDEFPROP property);
    public MethodSymbol GetMethod(PREDEFMETH method);
    public MethodSymbol GetOptionalMethod(PREDEFMETH method);
    private MethodSymbol EnsureMethod(PREDEFMETH method);
    private MethodSymbol LoadMethod(AggregateSymbol type, Int32[] signature, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual);
    private MethodSymbol LookupMethodWhileLoading(AggregateSymbol type, int cMethodTyVars, Name methodName, ACCESS methodAccess, bool isStatic, bool isVirtual, CType returnType, TypeArray argumentTypes);
    private MethodSymbol LoadMethod(PREDEFMETH method);
    private void ReportError(PREDEFMETH method);
    private void ReportError(PredefinedType type, PredefinedName name);
    private static PredefinedName GetPropPredefName(PREDEFPROP property);
    private static PREDEFMETH GetPropGetter(PREDEFPROP property);
    private static PredefinedType GetPropPredefType(PREDEFPROP property);
    private static PREDEFMETH GetPropSetter(PREDEFPROP property);
    private void ReportError(PREDEFPROP property);
    public static PredefinedPropertyInfo GetPropInfo(PREDEFPROP property);
    public static PredefinedMethodInfo GetMethInfo(PREDEFMETH method);
    private static PredefinedName GetMethPredefName(PREDEFMETH method);
    private static PredefinedType GetMethPredefType(PREDEFMETH method);
    private static bool IsMethStatic(PREDEFMETH method);
    private static bool IsMethVirtual(PREDEFMETH method);
    private static ACCESS GetMethAccess(PREDEFMETH method);
    private static int GetMethTyVars(PREDEFMETH method);
    private static Int32[] GetMethSignature(PREDEFMETH method);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedMethodInfo : object {
    public PREDEFMETH method;
    public PredefinedType type;
    public PredefinedName name;
    public MethodCallingConventionEnum callingConvention;
    public ACCESS access;
    public int cTypeVars;
    public Int32[] signature;
    public PredefinedMethodInfo(PREDEFMETH method, MethodRequiredEnum required, PredefinedType type, PredefinedName name, MethodCallingConventionEnum callingConvention, ACCESS access, int cTypeVars, Int32[] signature);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedPropertyInfo : object {
    public PREDEFPROP property;
    public PredefinedName name;
    public PREDEFMETH getter;
    public PREDEFMETH setter;
    public PredefinedPropertyInfo(PREDEFPROP property, MethodRequiredEnum required, PredefinedName name, PREDEFMETH getter, PREDEFMETH setter);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypeFacts : object {
    private static PredefinedTypeInfo[] s_pdTypes;
    private static Dictionary`2<string, PredefinedType> s_pdTypeNames;
    private static PredefinedTypeFacts();
    internal static string GetName(PredefinedType type);
    internal static bool IsRequired(PredefinedType type);
    internal static FUNDTYPE GetFundType(PredefinedType type);
    internal static Type GetAssociatedSystemType(PredefinedType type);
    internal static bool IsSimpleType(PredefinedType type);
    internal static bool IsNumericType(PredefinedType type);
    internal static string GetNiceName(PredefinedType type);
    internal static bool IsPredefinedType(string name);
    internal static PredefinedType GetPredefTypeIndex(string name);
    private static Dictionary`2<string, PredefinedType> CreatePredefinedTypeFacts();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PredefinedTypes : object {
    private SymbolTable _runtimeBinderSymbolTable;
    private BSYMMGR _pBSymmgr;
    private AggregateSymbol[] _predefSyms;
    private KAID _aidMsCorLib;
    private static Char[] s_nameSeparators;
    public PredefinedTypes(BSYMMGR pBSymmgr);
    private static PredefinedTypes();
    private AggregateSymbol DelayLoadPredefSym(PredefinedType pt);
    internal static AggregateSymbol InitializePredefinedType(AggregateSymbol sym, PredefinedType pt);
    public bool Init(ErrorHandling errorContext, SymbolTable symtable);
    private AggregateSymbol FindPredefinedType(ErrorHandling errorContext, string pszType, KAID aid, AggKindEnum aggKind, int arity, bool isRequired);
    private AggregateSymbol FindPredefinedTypeCore(Name name, NamespaceOrAggregateSymbol bag, KAID aid, AggKindEnum aggKind, int arity, AggregateSymbol& paggAmbig, AggregateSymbol& paggBad);
    public void ReportMissingPredefTypeError(ErrorHandling errorContext, PredefinedType pt);
    public AggregateSymbol GetReqPredefAgg(PredefinedType pt);
    public AggregateSymbol GetOptPredefAgg(PredefinedType pt);
    public static string GetNiceName(PredefinedType pt);
    public static string GetNiceName(AggregateSymbol type);
    public static string GetFullName(PredefinedType pt);
    public static bool isRequired(PredefinedType pt);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFMETH : Enum {
    public int value__;
    public static PREDEFMETH PM_FIRST;
    public static PREDEFMETH PM_ARRAY_GETLENGTH;
    public static PREDEFMETH PM_DECIMAL_OPDECREMENT;
    public static PREDEFMETH PM_DECIMAL_OPDIVISION;
    public static PREDEFMETH PM_DECIMAL_OPEQUALITY;
    public static PREDEFMETH PM_DECIMAL_OPGREATERTHAN;
    public static PREDEFMETH PM_DECIMAL_OPGREATERTHANOREQUAL;
    public static PREDEFMETH PM_DECIMAL_OPINCREMENT;
    public static PREDEFMETH PM_DECIMAL_OPINEQUALITY;
    public static PREDEFMETH PM_DECIMAL_OPLESSTHAN;
    public static PREDEFMETH PM_DECIMAL_OPLESSTHANOREQUAL;
    public static PREDEFMETH PM_DECIMAL_OPMINUS;
    public static PREDEFMETH PM_DECIMAL_OPMODULUS;
    public static PREDEFMETH PM_DECIMAL_OPMULTIPLY;
    public static PREDEFMETH PM_DECIMAL_OPPLUS;
    public static PREDEFMETH PM_DECIMAL_OPUNARYMINUS;
    public static PREDEFMETH PM_DECIMAL_OPUNARYPLUS;
    public static PREDEFMETH PM_DELEGATE_COMBINE;
    public static PREDEFMETH PM_DELEGATE_OPEQUALITY;
    public static PREDEFMETH PM_DELEGATE_OPINEQUALITY;
    public static PREDEFMETH PM_DELEGATE_REMOVE;
    public static PREDEFMETH PM_EXPRESSION_ADD;
    public static PREDEFMETH PM_EXPRESSION_ADD_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED;
    public static PREDEFMETH PM_EXPRESSION_ADDCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_AND;
    public static PREDEFMETH PM_EXPRESSION_AND_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO;
    public static PREDEFMETH PM_EXPRESSION_ANDALSO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX;
    public static PREDEFMETH PM_EXPRESSION_ARRAYINDEX2;
    public static PREDEFMETH PM_EXPRESSION_ASSIGN;
    public static PREDEFMETH PM_EXPRESSION_CONDITION;
    public static PREDEFMETH PM_EXPRESSION_CONSTANT_OBJECT_TYPE;
    public static PREDEFMETH PM_EXPRESSION_CONVERT;
    public static PREDEFMETH PM_EXPRESSION_CONVERT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_CONVERTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE;
    public static PREDEFMETH PM_EXPRESSION_DIVIDE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EQUAL;
    public static PREDEFMETH PM_EXPRESSION_EQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR;
    public static PREDEFMETH PM_EXPRESSION_EXCLUSIVEOR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_FIELD;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_GREATERTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LAMBDA;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_LEFTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN;
    public static PREDEFMETH PM_EXPRESSION_LESSTHAN_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL;
    public static PREDEFMETH PM_EXPRESSION_LESSTHANOREQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MODULO;
    public static PREDEFMETH PM_EXPRESSION_MODULO_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLY_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED;
    public static PREDEFMETH PM_EXPRESSION_MULTIPLYCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL;
    public static PREDEFMETH PM_EXPRESSION_NOTEQUAL_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_OR;
    public static PREDEFMETH PM_EXPRESSION_OR_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_ORELSE;
    public static PREDEFMETH PM_EXPRESSION_ORELSE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_PARAMETER;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT;
    public static PREDEFMETH PM_EXPRESSION_RIGHTSHIFT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED;
    public static PREDEFMETH PM_EXPRESSION_SUBTRACTCHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_UNARYPLUS_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATE;
    public static PREDEFMETH PM_EXPRESSION_NEGATE_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED;
    public static PREDEFMETH PM_EXPRESSION_NEGATECHECKED_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_CALL;
    public static PREDEFMETH PM_EXPRESSION_NEW;
    public static PREDEFMETH PM_EXPRESSION_NEW_MEMBERS;
    public static PREDEFMETH PM_EXPRESSION_NEW_TYPE;
    public static PREDEFMETH PM_EXPRESSION_QUOTE;
    public static PREDEFMETH PM_EXPRESSION_ARRAYLENGTH;
    public static PREDEFMETH PM_EXPRESSION_NOT;
    public static PREDEFMETH PM_EXPRESSION_NOT_USER_DEFINED;
    public static PREDEFMETH PM_EXPRESSION_NEWARRAYINIT;
    public static PREDEFMETH PM_EXPRESSION_PROPERTY;
    public static PREDEFMETH PM_EXPRESSION_INVOKE;
    public static PREDEFMETH PM_METHODINFO_CREATEDELEGATE_TYPE_OBJECT;
    public static PREDEFMETH PM_G_OPTIONAL_CTOR;
    public static PREDEFMETH PM_G_OPTIONAL_GETHASVALUE;
    public static PREDEFMETH PM_G_OPTIONAL_GETVALUE;
    public static PREDEFMETH PM_G_OPTIONAL_GET_VALUE_OR_DEF;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_1;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_2;
    public static PREDEFMETH PM_STRING_CONCAT_OBJECT_3;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_1;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_2;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_3;
    public static PREDEFMETH PM_STRING_CONCAT_STRING_4;
    public static PREDEFMETH PM_STRING_CONCAT_SZ_OBJECT;
    public static PREDEFMETH PM_STRING_CONCAT_SZ_STRING;
    public static PREDEFMETH PM_STRING_GETCHARS;
    public static PREDEFMETH PM_STRING_GETLENGTH;
    public static PREDEFMETH PM_STRING_OPEQUALITY;
    public static PREDEFMETH PM_STRING_OPINEQUALITY;
    public static PREDEFMETH PM_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.PREDEFPROP : Enum {
    public int value__;
    public static PREDEFPROP PP_FIRST;
    public static PREDEFPROP PP_ARRAY_LENGTH;
    public static PREDEFPROP PP_G_OPTIONAL_VALUE;
    public static PREDEFPROP PP_COUNT;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropertySymbol : MethodOrPropertySymbol {
    public MethodSymbol methGet;
    public MethodSymbol methSet;
    public PropertyInfo AssociatedPropertyInfo;
    public bool isIndexer();
    public IndexerSymbol AsIndexerSymbol();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.PropWithType : MethPropWithType {
    public PropWithType(PropertySymbol prop, AggregateType ats);
    public PropWithType(SymWithType swt);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.Scope : ParentSymbol {
    public UInt32 nestingOrder;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SpecCons : Enum {
    public int value__;
    public static SpecCons None;
    public static SpecCons New;
    public static SpecCons Ref;
    public static SpecCons Val;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SubstContext : object {
    public CType[] prgtypeCls;
    public int ctypeCls;
    public CType[] prgtypeMeth;
    public int ctypeMeth;
    public SubstTypeFlags grfst;
    public SubstContext(TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public SubstContext(AggregateType type);
    public SubstContext(AggregateType type, TypeArray typeArgsMeth);
    public SubstContext(AggregateType type, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public SubstContext(CType[] prgtypeCls, int ctypeCls, CType[] prgtypeMeth, int ctypeMeth);
    public SubstContext(CType[] prgtypeCls, int ctypeCls, CType[] prgtypeMeth, int ctypeMeth, SubstTypeFlags grfst);
    public bool FNop();
    public void Init(TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SubstTypeFlags : Enum {
    public int value__;
    public static SubstTypeFlags NormNone;
    public static SubstTypeFlags NormClass;
    public static SubstTypeFlags NormMeth;
    public static SubstTypeFlags NormAll;
    public static SubstTypeFlags DenormClass;
    public static SubstTypeFlags DenormMeth;
    public static SubstTypeFlags DenormAll;
    public static SubstTypeFlags NoRefOutDifference;
}
[FlagsAttribute]
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.symbmask_t : Enum {
    public long value__;
    public static symbmask_t MASK_NamespaceSymbol;
    public static symbmask_t MASK_NamespaceDeclaration;
    public static symbmask_t MASK_AssemblyQualifiedNamespaceSymbol;
    public static symbmask_t MASK_AggregateSymbol;
    public static symbmask_t MASK_AggregateDeclaration;
    public static symbmask_t MASK_TypeParameterSymbol;
    public static symbmask_t MASK_FieldSymbol;
    public static symbmask_t MASK_LocalVariableSymbol;
    public static symbmask_t MASK_MethodSymbol;
    public static symbmask_t MASK_PropertySymbol;
    public static symbmask_t MASK_EventSymbol;
    public static symbmask_t MASK_TransparentIdentifierMemberSymbol;
    public static symbmask_t MASK_Scope;
    public static symbmask_t MASK_CachedNameSymbol;
    public static symbmask_t MASK_LabelSymbol;
    public static symbmask_t MASK_GlobalAttributeDeclaration;
    public static symbmask_t MASK_LambdaScope;
    public static symbmask_t MASK_ALL;
    public static symbmask_t LOOKUPMASK;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.Symbol : object {
    private SYMKIND _kind;
    private bool _isBogus;
    private bool _checkedBogus;
    private ACCESS _access;
    public Name name;
    public ParentSymbol parent;
    public Symbol nextChild;
    public Symbol nextSameName;
    public bool isStatic { get; }
    public ACCESS GetAccess();
    public void SetAccess(ACCESS access);
    public SYMKIND getKind();
    public void setKind(SYMKIND kind);
    public symbmask_t mask();
    public bool checkBogus();
    public bool getBogus();
    public bool hasBogus();
    public void setBogus(bool isBogus);
    public void initBogus();
    public bool computeCurrentBogusState();
    public bool IsNamespaceSymbol();
    public bool IsNamespaceDeclaration();
    public bool IsAggregateSymbol();
    public bool IsAggregateDeclaration();
    public bool IsFieldSymbol();
    public bool IsLocalVariableSymbol();
    public bool IsMethodSymbol();
    public bool IsPropertySymbol();
    public bool IsTypeParameterSymbol();
    public bool IsEventSymbol();
    public bool IsMethodOrPropertySymbol();
    public bool IsFMETHSYM();
    public CType getType();
    public bool get_isStatic();
    public Assembly GetAssembly();
    public bool InternalsVisibleTo(Assembly assembly);
    public bool SameAssemOrFriend(Symbol sym);
    public InputFile getInputFile();
    public bool IsVirtual();
    public bool IsOverride();
    public bool IsHideByName();
    public Symbol SymBaseVirtual();
    public bool isUserCallable();
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.SymbolExtensions/<Children>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<Symbol> Children(ParentSymbol symbol);
    [ExtensionAttribute]
internal static MethodSymbol AsFMETHSYM(Symbol symbol);
    [ExtensionAttribute]
internal static NamespaceOrAggregateSymbol AsNamespaceOrAggregateSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static NamespaceSymbol AsNamespaceSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static AssemblyQualifiedNamespaceSymbol AsAssemblyQualifiedNamespaceSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static NamespaceDeclaration AsNamespaceDeclaration(Symbol symbol);
    [ExtensionAttribute]
internal static AggregateSymbol AsAggregateSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static AggregateDeclaration AsAggregateDeclaration(Symbol symbol);
    [ExtensionAttribute]
internal static FieldSymbol AsFieldSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static LocalVariableSymbol AsLocalVariableSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static MethodSymbol AsMethodSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static PropertySymbol AsPropertySymbol(Symbol symbol);
    [ExtensionAttribute]
internal static MethodOrPropertySymbol AsMethodOrPropertySymbol(Symbol symbol);
    [ExtensionAttribute]
internal static Scope AsScope(Symbol symbol);
    [ExtensionAttribute]
internal static TypeParameterSymbol AsTypeParameterSymbol(Symbol symbol);
    [ExtensionAttribute]
internal static EventSymbol AsEventSymbol(Symbol symbol);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymbolLoader : object {
    private NameManager _nameManager;
    [CompilerGeneratedAttribute]
private PredefinedMembers <PredefinedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalSymbolContext <GlobalSymbolContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandling <ErrorContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SymbolTable <RuntimeBinderSymbolTable>k__BackingField;
    public PredefinedMembers PredefinedMembers { get; private set; }
    public GlobalSymbolContext GlobalSymbolContext { get; private set; }
    public ErrorHandling ErrorContext { get; private set; }
    public SymbolTable RuntimeBinderSymbolTable { get; private set; }
    public TypeManager TypeManager { get; }
    public SymbolLoader(GlobalSymbolContext globalSymbols, UserStringBuilder userStringBuilder, ErrorHandling errorContext);
    [CompilerGeneratedAttribute]
public PredefinedMembers get_PredefinedMembers();
    [CompilerGeneratedAttribute]
private void set_PredefinedMembers(PredefinedMembers value);
    [CompilerGeneratedAttribute]
public GlobalSymbolContext get_GlobalSymbolContext();
    [CompilerGeneratedAttribute]
private void set_GlobalSymbolContext(GlobalSymbolContext value);
    [CompilerGeneratedAttribute]
public ErrorHandling get_ErrorContext();
    [CompilerGeneratedAttribute]
private void set_ErrorContext(ErrorHandling value);
    [CompilerGeneratedAttribute]
public SymbolTable get_RuntimeBinderSymbolTable();
    [CompilerGeneratedAttribute]
private void set_RuntimeBinderSymbolTable(SymbolTable value);
    public ErrorHandling GetErrorContext();
    public GlobalSymbolContext GetGlobalSymbolContext();
    public MethodSymbol LookupInvokeMeth(AggregateSymbol pAggDel);
    public NameManager GetNameManager();
    public PredefinedTypes getPredefTypes();
    public TypeManager GetTypeManager();
    public TypeManager get_TypeManager();
    public PredefinedMembers getPredefinedMembers();
    public BSYMMGR getBSymmgr();
    public SymFactory GetGlobalSymbolFactory();
    public MiscSymFactory GetGlobalMiscSymFactory();
    public AggregateType GetReqPredefType(PredefinedType pt);
    public AggregateType GetReqPredefType(PredefinedType pt, bool fEnsureState);
    public AggregateSymbol GetOptPredefAgg(PredefinedType pt);
    public AggregateSymbol GetOptPredefAgg(PredefinedType pt, bool fEnsureState);
    public AggregateType GetOptPredefType(PredefinedType pt);
    public AggregateType GetOptPredefType(PredefinedType pt, bool fEnsureState);
    public AggregateType GetOptPredefTypeErr(PredefinedType pt, bool fEnsureState);
    public Symbol LookupAggMember(Name name, AggregateSymbol agg, symbmask_t mask);
    public Symbol LookupNextSym(Symbol sym, ParentSymbol parent, symbmask_t kindmask);
    public bool isManagedType(CType type);
    public AggregateType GetAggTypeSym(CType typeSym);
    public bool IsBaseInterface(CType pDerived, CType pBase);
    public bool IsBaseClassOfClass(CType pDerived, CType pBase);
    public bool IsBaseClass(CType pDerived, CType pBase);
    private bool HasCovariantArrayConversion(ArrayType pSource, ArrayType pDest);
    public bool HasIdentityOrImplicitReferenceConversion(CType pSource, CType pDest);
    protected bool AreTypesEqualForConversion(CType pType1, CType pType2);
    private bool HasArrayConversionToInterface(ArrayType pSource, CType pDest);
    public bool HasImplicitReferenceConversion(CType pSource, CType pDest);
    private bool HasImplicitReferenceTypeParameterConversion(TypeParameterType pSource, CType pDest);
    private bool HasAnyBaseInterfaceConversion(CType pDerived, CType pBase);
    private bool HasInterfaceConversion(AggregateType pSource, AggregateType pDest);
    private bool HasDelegateConversion(AggregateType pSource, AggregateType pDest);
    private bool HasVariantConversion(AggregateType pSource, AggregateType pDest);
    private bool HasImplicitBoxingTypeParameterConversion(TypeParameterType pSource, CType pDest);
    private bool HasImplicitTypeParameterBaseConversion(TypeParameterType pSource, CType pDest);
    public bool HasImplicitBoxingConversion(CType pSource, CType pDest);
    public bool HasBaseConversion(CType pSource, CType pDest);
    public bool FCanLift();
    public bool IsBaseAggregate(AggregateSymbol derived, AggregateSymbol base);
    internal void SetSymbolTable(SymbolTable symbolTable);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymFactory : SymFactoryBase {
    public SymFactory(SYMTBL symtable, NameManager namemgr);
    public NamespaceSymbol CreateNamespace(Name name, NamespaceSymbol parent);
    public AssemblyQualifiedNamespaceSymbol CreateNamespaceAid(Name name, ParentSymbol parent, KAID assemblyID);
    public AggregateSymbol CreateAggregate(Name name, NamespaceOrAggregateSymbol parent, InputFile infile, TypeManager typeManager);
    public AggregateDeclaration CreateAggregateDecl(AggregateSymbol agg, Declaration declOuter);
    public AggregateSymbol CreateUnresolvedAggregate(Name name, ParentSymbol parent, TypeManager typeManager);
    public FieldSymbol CreateMemberVar(Name name, ParentSymbol parent, AggregateDeclaration declaration, int iIteratorLocal);
    public LocalVariableSymbol CreateLocalVar(Name name, ParentSymbol parent, CType type);
    public MethodSymbol CreateMethod(Name name, ParentSymbol parent, AggregateDeclaration declaration);
    public PropertySymbol CreateProperty(Name name, ParentSymbol parent, AggregateDeclaration declaration);
    public EventSymbol CreateEvent(Name name, ParentSymbol parent, AggregateDeclaration declaration);
    public TypeParameterSymbol CreateMethodTypeParameter(Name pName, MethodSymbol pParent, int index, int indexTotal);
    public TypeParameterSymbol CreateClassTypeParameter(Name pName, AggregateSymbol pParent, int index, int indexTotal);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymFactoryBase : object {
    protected SYMTBL m_pSymTable;
    protected Name m_pMissingNameNode;
    protected Name m_pMissingNameSym;
    protected SymFactoryBase(SYMTBL symtable, NameManager namemgr);
    protected Symbol newBasicSym(SYMKIND kind, Name name, ParentSymbol parent);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SYMKIND : Enum {
    public int value__;
    public static SYMKIND SK_NamespaceSymbol;
    public static SYMKIND SK_NamespaceDeclaration;
    public static SYMKIND SK_AssemblyQualifiedNamespaceSymbol;
    public static SYMKIND SK_AggregateSymbol;
    public static SYMKIND SK_AggregateDeclaration;
    public static SYMKIND SK_TypeParameterSymbol;
    public static SYMKIND SK_FieldSymbol;
    public static SYMKIND SK_LocalVariableSymbol;
    public static SYMKIND SK_MethodSymbol;
    public static SYMKIND SK_PropertySymbol;
    public static SYMKIND SK_EventSymbol;
    public static SYMKIND SK_TransparentIdentifierMemberSymbol;
    public static SYMKIND SK_AliasSymbol;
    public static SYMKIND SK_ExternalAliasDefinitionSymbol;
    public static SYMKIND SK_Scope;
    public static SYMKIND SK_CachedNameSymbol;
    public static SYMKIND SK_LabelSymbol;
    public static SYMKIND SK_GlobalAttributeDeclaration;
    public static SYMKIND SK_LambdaScope;
    public static SYMKIND SK_UnresolvedAggregateSymbol;
    public static SYMKIND SK_InterfaceImplementationMethodSymbol;
    public static SYMKIND SK_IndexerSymbol;
    public static SYMKIND SK_ParentSymbol;
    public static SYMKIND SK_IteratorFinallyMethodSymbol;
    public static SYMKIND SK_LIM;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SYMTBL : object {
    private Dictionary`2<Key, Symbol> _dictionary;
    public Symbol LookupSym(Name name, ParentSymbol parent, symbmask_t kindmask);
    public void InsertChild(ParentSymbol parent, Symbol child);
    private void InsertChildNoGrow(Symbol child);
    private static Symbol FindCorrectKind(Symbol sym, symbmask_t kindmask);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.SymWithType : object {
    private AggregateType _ats;
    private Symbol _sym;
    public AggregateType Ats { get; }
    public Symbol Sym { get; }
    public SymWithType(Symbol sym, AggregateType ats);
    public virtual void Clear();
    public AggregateType get_Ats();
    public Symbol get_Sym();
    public AggregateType GetType();
    public static bool op_Equality(SymWithType swt1, SymWithType swt2);
    public static bool op_Inequality(SymWithType swt1, SymWithType swt2);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Implicit(SymWithType swt);
    public MethodOrPropertySymbol MethProp();
    public MethodSymbol Meth();
    public PropertySymbol Prop();
    public FieldSymbol Field();
    public EventSymbol Event();
    public void Set(Symbol sym, AggregateType ats);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.SynthAggKind : Enum {
    public int value__;
    public static SynthAggKind NotSynthesized;
    public static SynthAggKind AnonymousMethodDisplayClass;
    public static SynthAggKind IteratorClass;
    public static SynthAggKind FixedBufferStruct;
    public static SynthAggKind Lim;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TransparentIdentifierMemberSymbol : Symbol {
}
[DefaultMemberAttribute("EyeTim")]
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeArray : object {
    private CType[] _items;
    public int Size { get; }
    public int size { get; }
    public CType EyeTim { get; }
    public int Count { get; }
    public TypeArray(CType[] types);
    public int get_Size();
    public int get_size();
    public bool HasErrors();
    public CType Item(int i);
    public TypeParameterType ItemAsTypeParameterType(int i);
    public CType[] ToArray();
    public CType get_EyeTim(int i);
    public int get_Count();
    public void CopyItems(int i, int c, CType[] dest);
}
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.TypeBind : object {
    public static bool CheckConstraints(CSemanticChecker checker, ErrorHandling errHandling, CType type, CheckConstraintsFlags flags);
    public static void CheckMethConstraints(CSemanticChecker checker, ErrorHandling errCtx, MethWithInst mwi);
    private static bool CheckConstraintsCore(CSemanticChecker checker, ErrorHandling errHandling, Symbol symErr, TypeArray typeVars, TypeArray typeArgs, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    private static bool CheckSingleConstraint(CSemanticChecker checker, ErrorHandling errHandling, Symbol symErr, TypeParameterType var, CType arg, TypeArray typeArgsCls, TypeArray typeArgsMeth, CheckConstraintsFlags flags);
    private static bool SatisfiesBound(CSemanticChecker checker, CType arg, CType typeBnd);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeFactory : object {
    public AggregateType CreateAggregateType(Name name, AggregateSymbol parent, TypeArray typeArgsThis, AggregateType outerType);
    public TypeParameterType CreateTypeParameter(TypeParameterSymbol pSymbol);
    public VoidType CreateVoid();
    public NullType CreateNull();
    public OpenTypePlaceholderType CreateUnit();
    public BoundLambdaType CreateAnonMethod();
    public MethodGroupType CreateMethodGroup();
    public ArgumentListType CreateArgList();
    public ErrorType CreateError(Name name, CType parent, AssemblyQualifiedNamespaceSymbol pParentNS, Name nameText, TypeArray typeArgs);
    public ArrayType CreateArray(Name name, CType pElementType, int rank);
    public PointerType CreatePointer(Name name, CType pReferentType);
    public ParameterModifierType CreateParameterModifier(Name name, CType pParameterType);
    public NullableType CreateNullable(Name name, CType pUnderlyingType, BSYMMGR symmgr, TypeManager typeManager);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.TypeKind : Enum {
    public int value__;
    public static TypeKind TK_AggregateType;
    public static TypeKind TK_VoidType;
    public static TypeKind TK_NullType;
    public static TypeKind TK_OpenTypePlaceholderType;
    public static TypeKind TK_BoundLambdaType;
    public static TypeKind TK_UnboundLambdaType;
    public static TypeKind TK_MethodGroupType;
    public static TypeKind TK_ErrorType;
    public static TypeKind TK_NaturalIntegerType;
    public static TypeKind TK_ArgumentListType;
    public static TypeKind TK_ArrayType;
    public static TypeKind TK_PointerType;
    public static TypeKind TK_ParameterModifierType;
    public static TypeKind TK_NullableType;
    public static TypeKind TK_TypeParameterType;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeManager : object {
    private BSYMMGR _BSymmgr;
    private PredefinedTypes _predefTypes;
    private TypeFactory _typeFactory;
    private TypeTable _typeTable;
    private SymbolTable _symbolTable;
    private VoidType _voidType;
    private NullType _nullType;
    private OpenTypePlaceholderType _typeUnit;
    private BoundLambdaType _typeAnonMeth;
    private MethodGroupType _typeMethGrp;
    private ArgumentListType _argListType;
    private ErrorType _errorType;
    private StdTypeVarColl _stvcMethod;
    private StdTypeVarColl _stvcClass;
    private Dictionary`2<Tuple`2<Assembly, Assembly>, bool> _internalsVisibleToCalculated;
    public void InitTypeFactory(SymbolTable table);
    private void InitType(CType at);
    public static bool TypeContainsAnonymousTypes(CType type);
    public ArrayType GetArray(CType elementType, int args);
    public AggregateType GetAggregate(AggregateSymbol agg, AggregateType atsOuter, TypeArray typeArgs);
    public AggregateType GetAggregate(AggregateSymbol agg, TypeArray typeArgsAll);
    public PointerType GetPointer(CType baseType);
    public NullableType GetNullable(CType pUnderlyingType);
    public NullableType GetNubFromNullable(AggregateType ats);
    public ParameterModifierType GetParameterModifier(CType paramType, bool isOut);
    public ErrorType GetErrorType(CType pParentType, AssemblyQualifiedNamespaceSymbol pParentNS, Name nameText, TypeArray typeArgs);
    public VoidType GetVoid();
    public NullType GetNullType();
    public OpenTypePlaceholderType GetUnitType();
    public BoundLambdaType GetAnonMethType();
    public MethodGroupType GetMethGrpType();
    public ArgumentListType GetArgListType();
    public ErrorType GetErrorSym();
    public AggregateSymbol GetNullable();
    public CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public CType SubstType(CType typeSrc, TypeArray typeArgsCls);
    public CType SubstType(CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public TypeArray SubstTypeArray(TypeArray taSrc, SubstContext pctx);
    public TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth);
    public TypeArray SubstTypeArray(TypeArray taSrc, TypeArray typeArgsCls);
    private CType SubstTypeCore(CType type, SubstContext pctx);
    public bool SubstEqualTypes(CType typeDst, CType typeSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public bool SubstEqualTypeArrays(TypeArray taDst, TypeArray taSrc, TypeArray typeArgsCls, TypeArray typeArgsMeth, SubstTypeFlags grfst);
    public bool SubstEqualTypesCore(CType typeDst, CType typeSrc, SubstContext pctx);
    public void ReportMissingPredefTypeError(ErrorHandling errorContext, PredefinedType pt);
    public static bool TypeContainsType(CType type, CType typeFind);
    public static bool TypeContainsTyVars(CType type, TypeArray typeVars);
    public static bool ParametersContainTyVar(TypeArray params, TypeParameterType typeFind);
    public AggregateSymbol GetReqPredefAgg(PredefinedType pt);
    public AggregateSymbol GetOptPredefAgg(PredefinedType pt);
    public TypeArray CreateArrayOfUnitTypes(int cSize);
    public TypeArray ConcatenateTypeArrays(TypeArray pTypeArray1, TypeArray pTypeArray2);
    public TypeArray GetStdMethTyVarArray(int cTyVars);
    public CType SubstType(CType typeSrc, SubstContext pctx);
    public CType SubstType(CType typeSrc, AggregateType atsCls);
    public CType SubstType(CType typeSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public CType SubstType(CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls, TypeArray typeArgsMeth);
    public TypeArray SubstTypeArray(TypeArray taSrc, AggregateType atsCls);
    public bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls, TypeArray typeArgsMeth);
    public bool SubstEqualTypes(CType typeDst, CType typeSrc, CType typeCls);
    public TypeParameterType GetStdMethTypeVar(int iv);
    public TypeParameterType GetStdClsTypeVar(int iv);
    public TypeParameterType GetTypeParameter(TypeParameterSymbol pSymbol);
    internal void Init(BSYMMGR bsymmgr, PredefinedTypes predefTypes);
    internal bool GetBestAccessibleType(CSemanticChecker semanticChecker, BindingContext bindingContext, CType typeSrc, CType& typeDst);
    private bool TryVarianceAdjustmentToGetAccessibleType(CSemanticChecker semanticChecker, BindingContext bindingContext, AggregateType typeSrc, CType& typeDst);
    private bool TryArrayVarianceAdjustmentToGetAccessibleType(CSemanticChecker semanticChecker, BindingContext bindingContext, ArrayType typeSrc, CType& typeDst);
    internal bool InternalsVisibleTo(Assembly assemblyThatDefinesAttribute, Assembly assemblyToCheck);
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.TypeOrSimpleNameResolution : Enum {
    public int value__;
    public static TypeOrSimpleNameResolution Unknown;
    public static TypeOrSimpleNameResolution CType;
    public static TypeOrSimpleNameResolution SimpleName;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterSymbol : Symbol {
    private bool _bIsMethodTypeParameter;
    private bool _bHasRefBound;
    private bool _bHasValBound;
    private SpecCons _constraints;
    private TypeParameterType _pTypeParameterType;
    private int _nIndexInOwnParameters;
    private int _nIndexInTotalParameters;
    private TypeArray _pBounds;
    private TypeArray _pInterfaceBounds;
    private AggregateType _pEffectiveBaseClass;
    private CType _pDeducedBaseClass;
    public bool Covariant;
    public bool Contravariant;
    public bool Invariant { get; }
    public bool get_Invariant();
    public void SetTypeParameterType(TypeParameterType pType);
    public TypeParameterType GetTypeParameterType();
    public bool IsMethodTypeParameter();
    public void SetIsMethodTypeParameter(bool b);
    public int GetIndexInOwnParameters();
    public void SetIndexInOwnParameters(int index);
    public int GetIndexInTotalParameters();
    public void SetIndexInTotalParameters(int index);
    public TypeArray GetInterfaceBounds();
    public void SetBounds(TypeArray pBounds);
    public TypeArray GetBounds();
    public void SetConstraints(SpecCons constraints);
    public AggregateType GetEffectiveBaseClass();
    public bool IsValueType();
    public bool IsReferenceType();
    public bool IsNonNullableValueType();
    public bool HasNewConstraint();
    public bool HasRefConstraint();
    public bool HasValConstraint();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeParameterType : CType {
    private TypeParameterSymbol _pTypeParameterSymbol;
    public bool Covariant { get; }
    public bool Invariant { get; }
    public bool Contravariant { get; }
    public TypeParameterSymbol GetTypeParameterSymbol();
    public void SetTypeParameterSymbol(TypeParameterSymbol pTypePArameterSymbol);
    public ParentSymbol GetOwningSymbol();
    public bool DependsOn(TypeParameterType pType);
    public bool get_Covariant();
    public bool get_Invariant();
    public bool get_Contravariant();
    public bool IsValueType();
    public bool IsReferenceType();
    public bool IsNonNullableValueType();
    public bool HasNewConstraint();
    public bool HasRefConstraint();
    public bool HasValConstraint();
    public bool IsMethodTypeParameter();
    public int GetIndexInOwnParameters();
    public int GetIndexInTotalParameters();
    public TypeArray GetBounds();
    public TypeArray GetInterfaceBounds();
    public AggregateType GetEffectiveBaseClass();
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.TypeTable : object {
    private Dictionary`2<KeyPair`2<AggregateSymbol, Name>, AggregateType> _pAggregateTable;
    private Dictionary`2<KeyPair`2<CType, Name>, ErrorType> _pErrorWithTypeParentTable;
    private Dictionary`2<KeyPair`2<AssemblyQualifiedNamespaceSymbol, Name>, ErrorType> _pErrorWithNamespaceParentTable;
    private Dictionary`2<KeyPair`2<CType, Name>, ArrayType> _pArrayTable;
    private Dictionary`2<KeyPair`2<CType, Name>, ParameterModifierType> _pParameterModifierTable;
    private Dictionary`2<CType, PointerType> _pPointerTable;
    private Dictionary`2<CType, NullableType> _pNullableTable;
    private Dictionary`2<TypeParameterSymbol, TypeParameterType> _pTypeParameterTable;
    public AggregateType LookupAggregate(Name pName, AggregateSymbol pAggregate);
    public void InsertAggregate(Name pName, AggregateSymbol pAggregateSymbol, AggregateType pAggregate);
    public ErrorType LookupError(Name pName, CType pParentType);
    public ErrorType LookupError(Name pName, AssemblyQualifiedNamespaceSymbol pParentNS);
    public void InsertError(Name pName, CType pParentType, ErrorType pError);
    public void InsertError(Name pName, AssemblyQualifiedNamespaceSymbol pParentNS, ErrorType pError);
    public ArrayType LookupArray(Name pName, CType pElementType);
    public void InsertArray(Name pName, CType pElementType, ArrayType pArray);
    public ParameterModifierType LookupParameterModifier(Name pName, CType pElementType);
    public void InsertParameterModifier(Name pName, CType pElementType, ParameterModifierType pParameterModifier);
    public PointerType LookupPointer(CType pElementType);
    public void InsertPointer(CType pElementType, PointerType pPointer);
    public NullableType LookupNullable(CType pUnderlyingType);
    public void InsertNullable(CType pUnderlyingType, NullableType pNullable);
    public TypeParameterType LookupTypeParameter(TypeParameterSymbol pTypeParameterSymbol);
    public void InsertTypeParameter(TypeParameterSymbol pTypeParameterSymbol, TypeParameterType pTypeParameter);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.UdConvInfo : object {
    public MethWithType mwt;
    public bool fSrcImplicit;
    public bool fDstImplicit;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpFuncKind : Enum {
    public int value__;
    public static UnaOpFuncKind BoolUnaOp;
    public static UnaOpFuncKind DecUnaOp;
    public static UnaOpFuncKind EnumUnaOp;
    public static UnaOpFuncKind IntUnaOp;
    public static UnaOpFuncKind RealUnaOp;
    public static UnaOpFuncKind LiftedIncOpCore;
    public static UnaOpFuncKind None;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpKind : Enum {
    public int value__;
    public static UnaOpKind Plus;
    public static UnaOpKind Minus;
    public static UnaOpKind Tilde;
    public static UnaOpKind Bang;
    public static UnaOpKind IncDec;
    public static UnaOpKind Lim;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaOpMask : Enum {
    public int value__;
    public static UnaOpMask None;
    public static UnaOpMask Plus;
    public static UnaOpMask Minus;
    public static UnaOpMask Tilde;
    public static UnaOpMask Bang;
    public static UnaOpMask IncDec;
    public static UnaOpMask Signed;
    public static UnaOpMask Unsigned;
    public static UnaOpMask Real;
    public static UnaOpMask Bool;
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UnaryOperatorSignatureFindResult : Enum {
    public int value__;
    public static UnaryOperatorSignatureFindResult Match;
    public static UnaryOperatorSignatureFindResult Continue;
    public static UnaryOperatorSignatureFindResult Return;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.UnresolvedAggregateSymbol : AggregateSymbol {
}
internal enum Microsoft.CSharp.RuntimeBinder.Semantics.UNSAFESTATES : Enum {
    public int value__;
    public static UNSAFESTATES UNSAFESTATES_Unsafe;
    public static UNSAFESTATES UNSAFESTATES_Safe;
    public static UNSAFESTATES UNSAFESTATES_Unknown;
}
[ExtensionAttribute]
internal static class Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions/<InterfaceAndBases>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<AggregateType> InterfaceAndBases(AggregateType type);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions/<AllConstraintInterfaces>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<AggregateType> AllConstraintInterfaces(TypeArray constraints);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions/<TypeAndBaseClasses>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<AggregateType> TypeAndBaseClasses(AggregateType type);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions/<TypeAndBaseClassInterfaces>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<AggregateType> TypeAndBaseClassInterfaces(AggregateType type);
    [IteratorStateMachineAttribute("Microsoft.CSharp.RuntimeBinder.Semantics.UtilityTypeExtensions/<AllPossibleInterfaces>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<CType> AllPossibleInterfaces(CType type);
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.VariableSymbol : Symbol {
    protected CType type;
}
internal class Microsoft.CSharp.RuntimeBinder.Semantics.VoidType : CType {
}
internal static class Microsoft.CSharp.RuntimeBinder.SpecialNames : object {
    public static string ImplicitConversion;
    public static string ExplicitConversion;
    public static string Invoke;
    public static string Constructor;
    public static string Indexer;
    public static string CLR_Add;
    public static string CLR_Subtract;
    public static string CLR_Multiply;
    public static string CLR_Division;
    public static string CLR_Modulus;
    public static string CLR_LShift;
    public static string CLR_RShift;
    public static string CLR_LT;
    public static string CLR_GT;
    public static string CLR_LTE;
    public static string CLR_GTE;
    public static string CLR_Equality;
    public static string CLR_Inequality;
    public static string CLR_BitwiseAnd;
    public static string CLR_ExclusiveOr;
    public static string CLR_BitwiseOr;
    public static string CLR_LogicalNot;
    public static string CLR_InPlaceAdd;
    public static string CLR_InPlaceSubtract;
    public static string CLR_InPlaceMultiply;
    public static string CLR_InPlaceDivide;
    public static string CLR_InPlaceModulus;
    public static string CLR_InPlaceBitwiseAnd;
    public static string CLR_InPlaceExclusiveOr;
    public static string CLR_InPlaceBitwiseOr;
    public static string CLR_InPlaceLShift;
    public static string CLR_InPlaceRShift;
    public static string CLR_UnaryNegation;
    public static string CLR_UnaryPlus;
    public static string CLR_OnesComplement;
    public static string CLR_True;
    public static string CLR_False;
    public static string CLR_PreIncrement;
    public static string CLR_PostIncrement;
    public static string CLR_PreDecrement;
    public static string CLR_PostDecrement;
}
internal class Microsoft.CSharp.RuntimeBinder.SymbolTable : object {
    private HashSet`1<Type> _typesWithConversionsLoaded;
    private HashSet`1<NameHashKey> _namesLoadedForEachType;
    private SYMTBL _symbolTable;
    private SymFactory _symFactory;
    private NameManager _nameManager;
    private TypeManager _typeManager;
    private BSYMMGR _bsymmgr;
    private CSemanticChecker _semanticChecker;
    private NamespaceSymbol _rootNamespace;
    private InputFile _infile;
    private static Type s_Sentinel;
    private static Type s_EventRegistrationTokenType;
    private static Type s_WindowsRuntimeMarshal;
    private static Type s_EventRegistrationTokenTable;
    internal static Type EventRegistrationTokenType { get; }
    internal static Type WindowsRuntimeMarshalType { get; }
    private static Type EventRegistrationTokenTableType { get; }
    internal SymbolTable(SYMTBL symTable, SymFactory symFactory, NameManager nameManager, TypeManager typeManager, BSYMMGR bsymmgr, CSemanticChecker semanticChecker, InputFile infile);
    private static SymbolTable();
    internal void ClearCache();
    internal void PopulateSymbolTableWithName(string name, IEnumerable`1<Type> typeArguments, Type callingType);
    internal SymWithType LookupMember(string name, EXPR callingObject, ParentSymbol context, int arity, MemberLookup mem, bool allowSpecialNames, bool requireInvocable);
    private IEnumerable`1<MemberInfo> AddNamesOnType(NameHashKey key);
    private IEnumerable`1<MemberInfo> AddNamesInInheritanceHierarchy(string name, List`1<Type> inheritance);
    private List`1<Type> CreateInheritanceHierarchyList(Type type);
    private Name GetName(string p);
    private Name GetName(Type type);
    internal static Name GetName(string p, NameManager nameManager);
    private TypeArray GetMethodTypeParameters(MethodInfo method, MethodSymbol parent);
    private TypeArray GetAggregateTypeParameters(Type type, AggregateSymbol agg);
    private TypeParameterType LoadClassTypeParameter(AggregateSymbol parent, Type t);
    private bool AreTypeParametersEquivalent(Type t1, Type t2);
    private Type GetOriginalTypeParameterType(Type t);
    private TypeParameterType LoadMethodTypeParameter(MethodSymbol parent, Type t);
    private TypeParameterType AddTypeParameterToSymbolTable(AggregateSymbol agg, MethodSymbol meth, Type t, bool bIsAggregate);
    private CType LoadSymbolsFromType(Type originalType);
    private TypeParameterType ProcessMethodTypeParameter(MethodInfo methinfo, Type t, AggregateSymbol parent);
    private CType GetConstructedType(Type type, AggregateSymbol agg);
    private CType ProcessSpecialTypeInChain(NamespaceOrAggregateSymbol parent, Type t);
    private static List`1<object> BuildDeclarationChain(Type callingType);
    private AggregateSymbol FindSymWithMatchingArity(AggregateSymbol aggregateSymbol, Type type);
    private NamespaceSymbol AddNamespaceToSymbolTable(NamespaceOrAggregateSymbol parent, string sz);
    internal CType[] GetCTypeArrayFromTypes(IList`1<Type> types);
    internal CType GetCTypeFromType(Type t);
    private AggregateSymbol AddAggregateToSymbolTable(NamespaceOrAggregateSymbol parent, Type type);
    private void SetInterfacesOnAggregate(AggregateSymbol aggregate, Type type);
    private FieldSymbol AddFieldToSymbolTable(FieldInfo fieldInfo, AggregateSymbol aggregate);
    internal static Type get_EventRegistrationTokenType();
    internal static Type get_WindowsRuntimeMarshalType();
    private static Type get_EventRegistrationTokenTableType();
    private static Type GetTypeByName(Type& cachedResult, string name);
    private EventSymbol AddEventToSymbolTable(EventInfo eventInfo, AggregateSymbol aggregate, FieldSymbol addedField);
    internal void AddPredefinedPropertyToSymbolTable(AggregateSymbol type, Name property);
    private PropertySymbol AddPropertyToSymbolTable(PropertyInfo property, AggregateSymbol aggregate);
    internal void AddPredefinedMethodToSymbolTable(AggregateSymbol type, Name methodName);
    private MethodSymbol AddMethodToSymbolTable(MemberInfo member, AggregateSymbol callingAggregate, MethodKindEnum kind);
    private void SetParameterDataForMethProp(MethodOrPropertySymbol methProp, ParameterInfo[] parameters);
    private void SetParameterAttributes(MethodOrPropertySymbol methProp, ParameterInfo[] parameters, int i);
    private MethodSymbol FindMatchingMethod(MemberInfo method, AggregateSymbol callingAggregate);
    private UInt32 GetCountOfModOpts(ParameterInfo[] parameters);
    private TypeArray CreateParameterArray(MemberInfo associatedInfo, ParameterInfo[] parameters);
    private CType GetTypeOfParameter(ParameterInfo p, MemberInfo m);
    private bool DoesMethodHaveParameterArray(ParameterInfo[] parameters);
    private SymWithType GetSlotForOverride(MethodInfo method);
    private MethodSymbol FindMethodFromMemberInfo(MemberInfo baseMemberInfo);
    internal bool AggregateContainsMethod(AggregateSymbol agg, string szName, symbmask_t mask);
    internal void AddConversionsForType(Type type);
    private void AddConversionsForOneType(Type type);
    private bool IsOperator(MethodInfo method);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.Name : object {
    private string _text;
    public string Text { get; }
    public PredefinedName PredefinedName { get; }
    public Name(string text);
    public string get_Text();
    public virtual PredefinedName get_PredefinedName();
    public virtual string ToString();
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.NameManager : object {
    private static NameTable s_knownNames;
    private static KnownName[] s_predefinedNames;
    private static KnownName[] s_otherNames;
    private NameTable _names;
    internal NameManager(NameTable nameTable);
    private static NameManager();
    private void InitKnownNames();
    internal Name Add(string key);
    internal Name Lookup(string key);
    internal Name GetPredefinedName(PredefinedName id);
    internal Name GetPredefName(PredefinedName id);
}
internal class Microsoft.CSharp.RuntimeBinder.Syntax.NameTable : object {
    private Entry[] _entries;
    private int _count;
    private int _mask;
    private int _hashCodeRandomizer;
    public Name Add(string key);
    internal void Add(Name name);
    public Name Lookup(string key);
    private int ComputeHashCode(string key);
    private Name AddEntry(Name name, int hashCode);
    private void Grow();
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.OperatorKind : Enum {
    public UInt32 value__;
    public static OperatorKind OP_NONE;
    public static OperatorKind OP_ASSIGN;
    public static OperatorKind OP_ADDEQ;
    public static OperatorKind OP_SUBEQ;
    public static OperatorKind OP_MULEQ;
    public static OperatorKind OP_DIVEQ;
    public static OperatorKind OP_MODEQ;
    public static OperatorKind OP_ANDEQ;
    public static OperatorKind OP_XOREQ;
    public static OperatorKind OP_OREQ;
    public static OperatorKind OP_LSHIFTEQ;
    public static OperatorKind OP_RSHIFTEQ;
    public static OperatorKind OP_QUESTION;
    public static OperatorKind OP_VALORDEF;
    public static OperatorKind OP_LOGOR;
    public static OperatorKind OP_LOGAND;
    public static OperatorKind OP_BITOR;
    public static OperatorKind OP_BITXOR;
    public static OperatorKind OP_BITAND;
    public static OperatorKind OP_EQ;
    public static OperatorKind OP_NEQ;
    public static OperatorKind OP_LT;
    public static OperatorKind OP_LE;
    public static OperatorKind OP_GT;
    public static OperatorKind OP_GE;
    public static OperatorKind OP_IS;
    public static OperatorKind OP_AS;
    public static OperatorKind OP_LSHIFT;
    public static OperatorKind OP_RSHIFT;
    public static OperatorKind OP_ADD;
    public static OperatorKind OP_SUB;
    public static OperatorKind OP_MUL;
    public static OperatorKind OP_DIV;
    public static OperatorKind OP_MOD;
    public static OperatorKind OP_NOP;
    public static OperatorKind OP_UPLUS;
    public static OperatorKind OP_NEG;
    public static OperatorKind OP_BITNOT;
    public static OperatorKind OP_LOGNOT;
    public static OperatorKind OP_PREINC;
    public static OperatorKind OP_PREDEC;
    public static OperatorKind OP_TYPEOF;
    public static OperatorKind OP_CHECKED;
    public static OperatorKind OP_UNCHECKED;
    public static OperatorKind OP_MAKEREFANY;
    public static OperatorKind OP_REFVALUE;
    public static OperatorKind OP_REFTYPE;
    public static OperatorKind OP_ARGS;
    public static OperatorKind OP_CAST;
    public static OperatorKind OP_INDIR;
    public static OperatorKind OP_ADDR;
    public static OperatorKind OP_COLON;
    public static OperatorKind OP_THIS;
    public static OperatorKind OP_BASE;
    public static OperatorKind OP_NULL;
    public static OperatorKind OP_TRUE;
    public static OperatorKind OP_FALSE;
    public static OperatorKind OP_CALL;
    public static OperatorKind OP_DEREF;
    public static OperatorKind OP_PAREN;
    public static OperatorKind OP_POSTINC;
    public static OperatorKind OP_POSTDEC;
    public static OperatorKind OP_DOT;
    public static OperatorKind OP_IMPLICIT;
    public static OperatorKind OP_EXPLICIT;
    public static OperatorKind OP_EQUALS;
    public static OperatorKind OP_COMPARE;
    public static OperatorKind OP_DEFAULT;
    public static OperatorKind OP_LAST;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedName : Enum {
    public int value__;
    public static PredefinedName PN_CTOR;
    public static PredefinedName PN_DTOR;
    public static PredefinedName PN_STATCTOR;
    public static PredefinedName PN_PTR;
    public static PredefinedName PN_NUB;
    public static PredefinedName PN_OUTPARAM;
    public static PredefinedName PN_REFPARAM;
    public static PredefinedName PN_ARRAY0;
    public static PredefinedName PN_ARRAY1;
    public static PredefinedName PN_ARRAY2;
    public static PredefinedName PN_GARRAY0;
    public static PredefinedName PN_GARRAY1;
    public static PredefinedName PN_GARRAY2;
    public static PredefinedName PN_INVOKE;
    public static PredefinedName PN_LENGTH;
    public static PredefinedName PN_INDEXER;
    public static PredefinedName PN_INDEXERINTERNAL;
    public static PredefinedName PN_COMBINE;
    public static PredefinedName PN_REMOVE;
    public static PredefinedName PN_OPEXPLICITMN;
    public static PredefinedName PN_OPIMPLICITMN;
    public static PredefinedName PN_OPUNARYPLUS;
    public static PredefinedName PN_OPUNARYMINUS;
    public static PredefinedName PN_OPCOMPLEMENT;
    public static PredefinedName PN_OPINCREMENT;
    public static PredefinedName PN_OPDECREMENT;
    public static PredefinedName PN_OPPLUS;
    public static PredefinedName PN_OPMINUS;
    public static PredefinedName PN_OPMULTIPLY;
    public static PredefinedName PN_OPDIVISION;
    public static PredefinedName PN_OPMODULUS;
    public static PredefinedName PN_OPXOR;
    public static PredefinedName PN_OPBITWISEAND;
    public static PredefinedName PN_OPBITWISEOR;
    public static PredefinedName PN_OPLEFTSHIFT;
    public static PredefinedName PN_OPRIGHTSHIFT;
    public static PredefinedName PN_OPEQUALS;
    public static PredefinedName PN_OPCOMPARE;
    public static PredefinedName PN_OPEQUALITY;
    public static PredefinedName PN_OPINEQUALITY;
    public static PredefinedName PN_OPGREATERTHAN;
    public static PredefinedName PN_OPLESSTHAN;
    public static PredefinedName PN_OPGREATERTHANOREQUAL;
    public static PredefinedName PN_OPLESSTHANOREQUAL;
    public static PredefinedName PN_OPTRUE;
    public static PredefinedName PN_OPFALSE;
    public static PredefinedName PN_OPNEGATION;
    public static PredefinedName PN_CONCAT;
    public static PredefinedName PN_ADD;
    public static PredefinedName PN_GETLENGTH;
    public static PredefinedName PN_GETCHARS;
    public static PredefinedName PN_CREATEDELEGATE;
    public static PredefinedName PN_FIXEDELEMENT;
    public static PredefinedName PN_HASVALUE;
    public static PredefinedName PN_GETHASVALUE;
    public static PredefinedName PN_CAP_VALUE;
    public static PredefinedName PN_GETVALUE;
    public static PredefinedName PN_GET_VALUE_OR_DEF;
    public static PredefinedName PN_MISSING;
    public static PredefinedName PN_MISSINGSYM;
    public static PredefinedName PN_LAMBDA;
    public static PredefinedName PN_PARAMETER;
    public static PredefinedName PN_CONSTANT;
    public static PredefinedName PN_CONVERT;
    public static PredefinedName PN_CONVERTCHECKED;
    public static PredefinedName PN_ADDCHECKED;
    public static PredefinedName PN_DIVIDE;
    public static PredefinedName PN_MODULO;
    public static PredefinedName PN_MULTIPLY;
    public static PredefinedName PN_MULTIPLYCHECKED;
    public static PredefinedName PN_SUBTRACT;
    public static PredefinedName PN_SUBTRACTCHECKED;
    public static PredefinedName PN_AND;
    public static PredefinedName PN_OR;
    public static PredefinedName PN_EXCLUSIVEOR;
    public static PredefinedName PN_LEFTSHIFT;
    public static PredefinedName PN_RIGHTSHIFT;
    public static PredefinedName PN_ANDALSO;
    public static PredefinedName PN_ORELSE;
    public static PredefinedName PN_EQUAL;
    public static PredefinedName PN_NOTEQUAL;
    public static PredefinedName PN_GREATERTHANOREQUAL;
    public static PredefinedName PN_GREATERTHAN;
    public static PredefinedName PN_LESSTHAN;
    public static PredefinedName PN_LESSTHANOREQUAL;
    public static PredefinedName PN_ARRAYINDEX;
    public static PredefinedName PN_ASSIGN;
    public static PredefinedName PN_CONDITION;
    public static PredefinedName PN_CAP_FIELD;
    public static PredefinedName PN_CALL;
    public static PredefinedName PN_NEW;
    public static PredefinedName PN_QUOTE;
    public static PredefinedName PN_ARRAYLENGTH;
    public static PredefinedName PN_PLUS;
    public static PredefinedName PN_NEGATE;
    public static PredefinedName PN_NEGATECHECKED;
    public static PredefinedName PN_NOT;
    public static PredefinedName PN_NEWARRAYINIT;
    public static PredefinedName PN_EXPRESSION_PROPERTY;
    public static PredefinedName PN_ADDEVENTHANDLER;
    public static PredefinedName PN_REMOVEEVENTHANDLER;
    public static PredefinedName PN_INVOCATIONLIST;
    public static PredefinedName PN_GETORCREATEEVENTREGISTRATIONTOKENTABLE;
    public static PredefinedName PN_COUNT;
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.PredefinedType : Enum {
    public UInt32 value__;
    public static PredefinedType PT_BYTE;
    public static PredefinedType PT_SHORT;
    public static PredefinedType PT_INT;
    public static PredefinedType PT_LONG;
    public static PredefinedType PT_FLOAT;
    public static PredefinedType PT_DOUBLE;
    public static PredefinedType PT_DECIMAL;
    public static PredefinedType PT_CHAR;
    public static PredefinedType PT_BOOL;
    public static PredefinedType PT_SBYTE;
    public static PredefinedType PT_USHORT;
    public static PredefinedType PT_UINT;
    public static PredefinedType PT_ULONG;
    public static PredefinedType PT_INTPTR;
    public static PredefinedType PT_UINTPTR;
    public static PredefinedType PT_OBJECT;
    public static PredefinedType PT_STRING;
    public static PredefinedType PT_DELEGATE;
    public static PredefinedType PT_MULTIDEL;
    public static PredefinedType PT_ARRAY;
    public static PredefinedType PT_EXCEPTION;
    public static PredefinedType PT_TYPE;
    public static PredefinedType PT_MONITOR;
    public static PredefinedType PT_VALUE;
    public static PredefinedType PT_ENUM;
    public static PredefinedType PT_DATETIME;
    public static PredefinedType PT_DEBUGGABLEATTRIBUTE;
    public static PredefinedType PT_DEBUGGABLEATTRIBUTE_DEBUGGINGMODES;
    public static PredefinedType PT_IN;
    public static PredefinedType PT_OUT;
    public static PredefinedType PT_ATTRIBUTE;
    public static PredefinedType PT_ATTRIBUTEUSAGE;
    public static PredefinedType PT_ATTRIBUTETARGETS;
    public static PredefinedType PT_OBSOLETE;
    public static PredefinedType PT_CONDITIONAL;
    public static PredefinedType PT_CLSCOMPLIANT;
    public static PredefinedType PT_GUID;
    public static PredefinedType PT_DEFAULTMEMBER;
    public static PredefinedType PT_PARAMS;
    public static PredefinedType PT_COMIMPORT;
    public static PredefinedType PT_FIELDOFFSET;
    public static PredefinedType PT_STRUCTLAYOUT;
    public static PredefinedType PT_LAYOUTKIND;
    public static PredefinedType PT_MARSHALAS;
    public static PredefinedType PT_DLLIMPORT;
    public static PredefinedType PT_INDEXERNAME;
    public static PredefinedType PT_DECIMALCONSTANT;
    public static PredefinedType PT_DEFAULTVALUE;
    public static PredefinedType PT_UNMANAGEDFUNCTIONPOINTER;
    public static PredefinedType PT_CALLINGCONVENTION;
    public static PredefinedType PT_CHARSET;
    public static PredefinedType PT_TYPEHANDLE;
    public static PredefinedType PT_FIELDHANDLE;
    public static PredefinedType PT_METHODHANDLE;
    public static PredefinedType PT_G_DICTIONARY;
    public static PredefinedType PT_IASYNCRESULT;
    public static PredefinedType PT_ASYNCCBDEL;
    public static PredefinedType PT_IDISPOSABLE;
    public static PredefinedType PT_IENUMERABLE;
    public static PredefinedType PT_IENUMERATOR;
    public static PredefinedType PT_SYSTEMVOID;
    public static PredefinedType PT_RUNTIMEHELPERS;
    public static PredefinedType PT_VOLATILEMOD;
    public static PredefinedType PT_COCLASS;
    public static PredefinedType PT_ACTIVATOR;
    public static PredefinedType PT_G_IENUMERABLE;
    public static PredefinedType PT_G_IENUMERATOR;
    public static PredefinedType PT_G_OPTIONAL;
    public static PredefinedType PT_FIXEDBUFFER;
    public static PredefinedType PT_DEFAULTCHARSET;
    public static PredefinedType PT_COMPILATIONRELAXATIONS;
    public static PredefinedType PT_RUNTIMECOMPATIBILITY;
    public static PredefinedType PT_FRIENDASSEMBLY;
    public static PredefinedType PT_DEBUGGERHIDDEN;
    public static PredefinedType PT_TYPEFORWARDER;
    public static PredefinedType PT_KEYFILE;
    public static PredefinedType PT_KEYNAME;
    public static PredefinedType PT_DELAYSIGN;
    public static PredefinedType PT_NOTSUPPORTEDEXCEPTION;
    public static PredefinedType PT_COMPILERGENERATED;
    public static PredefinedType PT_UNSAFEVALUETYPE;
    public static PredefinedType PT_ASSEMBLYFLAGS;
    public static PredefinedType PT_ASSEMBLYVERSION;
    public static PredefinedType PT_ASSEMBLYCULTURE;
    public static PredefinedType PT_G_IQUERYABLE;
    public static PredefinedType PT_IQUERYABLE;
    public static PredefinedType PT_STRINGBUILDER;
    public static PredefinedType PT_G_ICOLLECTION;
    public static PredefinedType PT_G_ILIST;
    public static PredefinedType PT_EXTENSION;
    public static PredefinedType PT_G_EXPRESSION;
    public static PredefinedType PT_EXPRESSION;
    public static PredefinedType PT_LAMBDAEXPRESSION;
    public static PredefinedType PT_BINARYEXPRESSION;
    public static PredefinedType PT_UNARYEXPRESSION;
    public static PredefinedType PT_CONDITIONALEXPRESSION;
    public static PredefinedType PT_CONSTANTEXPRESSION;
    public static PredefinedType PT_PARAMETEREXPRESSION;
    public static PredefinedType PT_MEMBEREXPRESSION;
    public static PredefinedType PT_METHODCALLEXPRESSION;
    public static PredefinedType PT_NEWEXPRESSION;
    public static PredefinedType PT_BINDING;
    public static PredefinedType PT_MEMBERINITEXPRESSION;
    public static PredefinedType PT_LISTINITEXPRESSION;
    public static PredefinedType PT_TYPEBINARYEXPRESSION;
    public static PredefinedType PT_NEWARRAYEXPRESSION;
    public static PredefinedType PT_MEMBERASSIGNMENT;
    public static PredefinedType PT_MEMBERLISTBINDING;
    public static PredefinedType PT_MEMBERMEMBERBINDING;
    public static PredefinedType PT_INVOCATIONEXPRESSION;
    public static PredefinedType PT_FIELDINFO;
    public static PredefinedType PT_METHODINFO;
    public static PredefinedType PT_CONSTRUCTORINFO;
    public static PredefinedType PT_PROPERTYINFO;
    public static PredefinedType PT_METHODBASE;
    public static PredefinedType PT_MEMBERINFO;
    public static PredefinedType PT_DEBUGGERDISPLAY;
    public static PredefinedType PT_DEBUGGERBROWSABLE;
    public static PredefinedType PT_DEBUGGERBROWSABLESTATE;
    public static PredefinedType PT_G_EQUALITYCOMPARER;
    public static PredefinedType PT_ELEMENTINITIALIZER;
    public static PredefinedType PT_MISSING;
    public static PredefinedType PT_G_IREADONLYLIST;
    public static PredefinedType PT_G_IREADONLYCOLLECTION;
    public static PredefinedType PT_COUNT;
    public static PredefinedType PT_VOID;
    public static PredefinedType PT_UNDEFINEDINDEX;
}
internal static class Microsoft.CSharp.RuntimeBinder.Syntax.TokenFacts : object {
    internal static string GetText(TokenKind kind);
}
internal enum Microsoft.CSharp.RuntimeBinder.Syntax.TokenKind : Enum {
    public byte value__;
    public static TokenKind ArgList;
    public static TokenKind MakeRef;
    public static TokenKind RefType;
    public static TokenKind RefValue;
    public static TokenKind As;
    public static TokenKind Base;
    public static TokenKind Checked;
    public static TokenKind Explicit;
    public static TokenKind False;
    public static TokenKind Implicit;
    public static TokenKind Is;
    public static TokenKind Null;
    public static TokenKind This;
    public static TokenKind True;
    public static TokenKind TypeOf;
    public static TokenKind Unchecked;
    public static TokenKind Void;
    public static TokenKind Equal;
    public static TokenKind PlusEqual;
    public static TokenKind MinusEqual;
    public static TokenKind SplatEqual;
    public static TokenKind SlashEqual;
    public static TokenKind PercentEqual;
    public static TokenKind AndEqual;
    public static TokenKind HatEqual;
    public static TokenKind BarEqual;
    public static TokenKind LeftShiftEqual;
    public static TokenKind RightShiftEqual;
    public static TokenKind Question;
    public static TokenKind Colon;
    public static TokenKind ColonColon;
    public static TokenKind LogicalOr;
    public static TokenKind LogicalAnd;
    public static TokenKind Bar;
    public static TokenKind Hat;
    public static TokenKind Ampersand;
    public static TokenKind EqualEqual;
    public static TokenKind NotEqual;
    public static TokenKind LessThan;
    public static TokenKind LessThanEqual;
    public static TokenKind GreaterThan;
    public static TokenKind GreaterThanEqual;
    public static TokenKind LeftShift;
    public static TokenKind RightShift;
    public static TokenKind Plus;
    public static TokenKind Minus;
    public static TokenKind Splat;
    public static TokenKind Slash;
    public static TokenKind Percent;
    public static TokenKind Tilde;
    public static TokenKind Bang;
    public static TokenKind PlusPlus;
    public static TokenKind MinusMinus;
    public static TokenKind Dot;
    public static TokenKind QuestionQuestion;
    public static TokenKind Unknown;
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    private static string s_resourcesName;
    private static ResourceManager ResourceManager { get; }
    internal static string InternalCompilerError { get; }
    internal static string BindRequireArguments { get; }
    internal static string BindCallFailedOverloadResolution { get; }
    internal static string BindBinaryOperatorRequireTwoArguments { get; }
    internal static string BindUnaryOperatorRequireOneArgument { get; }
    internal static string BindPropertyFailedMethodGroup { get; }
    internal static string BindPropertyFailedEvent { get; }
    internal static string BindInvokeFailedNonDelegate { get; }
    internal static string BindImplicitConversionRequireOneArgument { get; }
    internal static string BindExplicitConversionRequireOneArgument { get; }
    internal static string BindBinaryAssignmentRequireTwoArguments { get; }
    internal static string BindBinaryAssignmentFailedNullReference { get; }
    internal static string NullReferenceOnMemberException { get; }
    internal static string BindCallToConditionalMethod { get; }
    internal static string BindToVoidMethodButExpectResult { get; }
    internal static string BadBinaryOps { get; }
    internal static string IntDivByZero { get; }
    internal static string BadIndexLHS { get; }
    internal static string BadIndexCount { get; }
    internal static string BadUnaryOp { get; }
    internal static string NoImplicitConv { get; }
    internal static string NoExplicitConv { get; }
    internal static string ConstOutOfRange { get; }
    internal static string AmbigBinaryOps { get; }
    internal static string AmbigUnaryOp { get; }
    internal static string ValueCantBeNull { get; }
    internal static string WrongNestedThis { get; }
    internal static string NoSuchMember { get; }
    internal static string ObjectRequired { get; }
    internal static string AmbigCall { get; }
    internal static string BadAccess { get; }
    internal static string MethDelegateMismatch { get; }
    internal static string AssgLvalueExpected { get; }
    internal static string NoConstructors { get; }
    internal static string BadDelegateConstructor { get; }
    internal static string PropertyLacksGet { get; }
    internal static string ObjectProhibited { get; }
    internal static string AssgReadonly { get; }
    internal static string RefReadonly { get; }
    internal static string AssgReadonlyStatic { get; }
    internal static string RefReadonlyStatic { get; }
    internal static string AssgReadonlyProp { get; }
    internal static string AbstractBaseCall { get; }
    internal static string RefProperty { get; }
    internal static string ManagedAddr { get; }
    internal static string FixedNotNeeded { get; }
    internal static string UnsafeNeeded { get; }
    internal static string BadBoolOp { get; }
    internal static string MustHaveOpTF { get; }
    internal static string CheckedOverflow { get; }
    internal static string ConstOutOfRangeChecked { get; }
    internal static string AmbigMember { get; }
    internal static string SizeofUnsafe { get; }
    internal static string FieldInitRefNonstatic { get; }
    internal static string CallingFinalizeDepracated { get; }
    internal static string CallingBaseFinalizeDeprecated { get; }
    internal static string BadCastInFixed { get; }
    internal static string NoImplicitConvCast { get; }
    internal static string InaccessibleGetter { get; }
    internal static string InaccessibleSetter { get; }
    internal static string BadArity { get; }
    internal static string BadTypeArgument { get; }
    internal static string TypeArgsNotAllowed { get; }
    internal static string HasNoTypeVars { get; }
    internal static string NewConstraintNotSatisfied { get; }
    internal static string GenericConstraintNotSatisfiedRefType { get; }
    internal static string GenericConstraintNotSatisfiedNullableEnum { get; }
    internal static string GenericConstraintNotSatisfiedNullableInterface { get; }
    internal static string GenericConstraintNotSatisfiedTyVar { get; }
    internal static string GenericConstraintNotSatisfiedValType { get; }
    internal static string TypeVarCantBeNull { get; }
    internal static string BadRetType { get; }
    internal static string CantInferMethTypeArgs { get; }
    internal static string MethGrpToNonDel { get; }
    internal static string RefConstraintNotSatisfied { get; }
    internal static string ValConstraintNotSatisfied { get; }
    internal static string CircularConstraint { get; }
    internal static string BaseConstraintConflict { get; }
    internal static string ConWithValCon { get; }
    internal static string AmbigUDConv { get; }
    internal static string PredefinedTypeNotFound { get; }
    internal static string PredefinedTypeBadType { get; }
    internal static string BindToBogus { get; }
    internal static string CantCallSpecialMethod { get; }
    internal static string BogusType { get; }
    internal static string MissingPredefinedMember { get; }
    internal static string LiteralDoubleCast { get; }
    internal static string UnifyingInterfaceInstantiations { get; }
    internal static string ConvertToStaticClass { get; }
    internal static string GenericArgIsStaticClass { get; }
    internal static string PartialMethodToDelegate { get; }
    internal static string IncrementLvalueExpected { get; }
    internal static string NoSuchMemberOrExtension { get; }
    internal static string ValueTypeExtDelegate { get; }
    internal static string BadArgCount { get; }
    internal static string BadArgTypes { get; }
    internal static string BadArgType { get; }
    internal static string RefLvalueExpected { get; }
    internal static string BadProtectedAccess { get; }
    internal static string BindToBogusProp2 { get; }
    internal static string BindToBogusProp1 { get; }
    internal static string BadDelArgCount { get; }
    internal static string BadDelArgTypes { get; }
    internal static string AssgReadonlyLocal { get; }
    internal static string RefReadonlyLocal { get; }
    internal static string ReturnNotLValue { get; }
    internal static string BadArgExtraRef { get; }
    internal static string BadArgRef { get; }
    internal static string AssgReadonly2 { get; }
    internal static string RefReadonly2 { get; }
    internal static string AssgReadonlyStatic2 { get; }
    internal static string RefReadonlyStatic2 { get; }
    internal static string AssgReadonlyLocalCause { get; }
    internal static string RefReadonlyLocalCause { get; }
    internal static string ThisStructNotInAnonMeth { get; }
    internal static string DelegateOnNullable { get; }
    internal static string BadCtorArgCount { get; }
    internal static string BadExtensionArgTypes { get; }
    internal static string BadInstanceArgType { get; }
    internal static string BadArgTypesForCollectionAdd { get; }
    internal static string InitializerAddHasParamModifiers { get; }
    internal static string NonInvocableMemberCalled { get; }
    internal static string NamedArgumentSpecificationBeforeFixedArgument { get; }
    internal static string BadNamedArgument { get; }
    internal static string BadNamedArgumentForDelegateInvoke { get; }
    internal static string DuplicateNamedArgument { get; }
    internal static string NamedArgumentUsedInPositional { get; }
    internal static Type ResourceType { get; }
    private static ResourceManager get_ResourceManager();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string get_InternalCompilerError();
    internal static string get_BindRequireArguments();
    internal static string get_BindCallFailedOverloadResolution();
    internal static string get_BindBinaryOperatorRequireTwoArguments();
    internal static string get_BindUnaryOperatorRequireOneArgument();
    internal static string get_BindPropertyFailedMethodGroup();
    internal static string get_BindPropertyFailedEvent();
    internal static string get_BindInvokeFailedNonDelegate();
    internal static string get_BindImplicitConversionRequireOneArgument();
    internal static string get_BindExplicitConversionRequireOneArgument();
    internal static string get_BindBinaryAssignmentRequireTwoArguments();
    internal static string get_BindBinaryAssignmentFailedNullReference();
    internal static string get_NullReferenceOnMemberException();
    internal static string get_BindCallToConditionalMethod();
    internal static string get_BindToVoidMethodButExpectResult();
    internal static string get_BadBinaryOps();
    internal static string get_IntDivByZero();
    internal static string get_BadIndexLHS();
    internal static string get_BadIndexCount();
    internal static string get_BadUnaryOp();
    internal static string get_NoImplicitConv();
    internal static string get_NoExplicitConv();
    internal static string get_ConstOutOfRange();
    internal static string get_AmbigBinaryOps();
    internal static string get_AmbigUnaryOp();
    internal static string get_ValueCantBeNull();
    internal static string get_WrongNestedThis();
    internal static string get_NoSuchMember();
    internal static string get_ObjectRequired();
    internal static string get_AmbigCall();
    internal static string get_BadAccess();
    internal static string get_MethDelegateMismatch();
    internal static string get_AssgLvalueExpected();
    internal static string get_NoConstructors();
    internal static string get_BadDelegateConstructor();
    internal static string get_PropertyLacksGet();
    internal static string get_ObjectProhibited();
    internal static string get_AssgReadonly();
    internal static string get_RefReadonly();
    internal static string get_AssgReadonlyStatic();
    internal static string get_RefReadonlyStatic();
    internal static string get_AssgReadonlyProp();
    internal static string get_AbstractBaseCall();
    internal static string get_RefProperty();
    internal static string get_ManagedAddr();
    internal static string get_FixedNotNeeded();
    internal static string get_UnsafeNeeded();
    internal static string get_BadBoolOp();
    internal static string get_MustHaveOpTF();
    internal static string get_CheckedOverflow();
    internal static string get_ConstOutOfRangeChecked();
    internal static string get_AmbigMember();
    internal static string get_SizeofUnsafe();
    internal static string get_FieldInitRefNonstatic();
    internal static string get_CallingFinalizeDepracated();
    internal static string get_CallingBaseFinalizeDeprecated();
    internal static string get_BadCastInFixed();
    internal static string get_NoImplicitConvCast();
    internal static string get_InaccessibleGetter();
    internal static string get_InaccessibleSetter();
    internal static string get_BadArity();
    internal static string get_BadTypeArgument();
    internal static string get_TypeArgsNotAllowed();
    internal static string get_HasNoTypeVars();
    internal static string get_NewConstraintNotSatisfied();
    internal static string get_GenericConstraintNotSatisfiedRefType();
    internal static string get_GenericConstraintNotSatisfiedNullableEnum();
    internal static string get_GenericConstraintNotSatisfiedNullableInterface();
    internal static string get_GenericConstraintNotSatisfiedTyVar();
    internal static string get_GenericConstraintNotSatisfiedValType();
    internal static string get_TypeVarCantBeNull();
    internal static string get_BadRetType();
    internal static string get_CantInferMethTypeArgs();
    internal static string get_MethGrpToNonDel();
    internal static string get_RefConstraintNotSatisfied();
    internal static string get_ValConstraintNotSatisfied();
    internal static string get_CircularConstraint();
    internal static string get_BaseConstraintConflict();
    internal static string get_ConWithValCon();
    internal static string get_AmbigUDConv();
    internal static string get_PredefinedTypeNotFound();
    internal static string get_PredefinedTypeBadType();
    internal static string get_BindToBogus();
    internal static string get_CantCallSpecialMethod();
    internal static string get_BogusType();
    internal static string get_MissingPredefinedMember();
    internal static string get_LiteralDoubleCast();
    internal static string get_UnifyingInterfaceInstantiations();
    internal static string get_ConvertToStaticClass();
    internal static string get_GenericArgIsStaticClass();
    internal static string get_PartialMethodToDelegate();
    internal static string get_IncrementLvalueExpected();
    internal static string get_NoSuchMemberOrExtension();
    internal static string get_ValueTypeExtDelegate();
    internal static string get_BadArgCount();
    internal static string get_BadArgTypes();
    internal static string get_BadArgType();
    internal static string get_RefLvalueExpected();
    internal static string get_BadProtectedAccess();
    internal static string get_BindToBogusProp2();
    internal static string get_BindToBogusProp1();
    internal static string get_BadDelArgCount();
    internal static string get_BadDelArgTypes();
    internal static string get_AssgReadonlyLocal();
    internal static string get_RefReadonlyLocal();
    internal static string get_ReturnNotLValue();
    internal static string get_BadArgExtraRef();
    internal static string get_BadArgRef();
    internal static string get_AssgReadonly2();
    internal static string get_RefReadonly2();
    internal static string get_AssgReadonlyStatic2();
    internal static string get_RefReadonlyStatic2();
    internal static string get_AssgReadonlyLocalCause();
    internal static string get_RefReadonlyLocalCause();
    internal static string get_ThisStructNotInAnonMeth();
    internal static string get_DelegateOnNullable();
    internal static string get_BadCtorArgCount();
    internal static string get_BadExtensionArgTypes();
    internal static string get_BadInstanceArgType();
    internal static string get_BadArgTypesForCollectionAdd();
    internal static string get_InitializerAddHasParamModifiers();
    internal static string get_NonInvocableMemberCalled();
    internal static string get_NamedArgumentSpecificationBeforeFixedArgument();
    internal static string get_BadNamedArgument();
    internal static string get_BadNamedArgumentForDelegateInvoke();
    internal static string get_DuplicateNamedArgument();
    internal static string get_NamedArgumentUsedInPositional();
    internal static Type get_ResourceType();
}
