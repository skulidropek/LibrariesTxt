public static class Microsoft.DotNet.Interactive.App.CommandLine.CommandLineParser : object {
    public static Parser Create(IServiceCollection services, StartServer startServer, Jupyter jupyter, StartKernelHost startKernelHost, StartNotebookParser startNotebookParser, StartHttp startHttp, Action onServerStarted, TelemetrySender telemetrySender);
    private static CompositeKernel CreateKernel(string defaultKernelName, FrontendEnvironment frontendEnvironment, StartupOptions startupOptions, TelemetrySender telemetrySender);
    public static void SetUpFormatters(FrontendEnvironment frontendEnvironment);
    [CompilerGeneratedAttribute]
internal static Task`1<int> <Create>g__JupyterInstallHandler|5_11(HttpPortRange httpPortRange, DirectoryInfo path, InvocationContext context);
    [CompilerGeneratedAttribute]
internal static HttpPortRange <Create>g__ParsePortRangeOption|5_7(ArgumentResult result);
}
public static class Microsoft.DotNet.Interactive.App.CommandLine.HttpCommand : object {
    public static Task`1<int> Do(StartupOptions startupOptions, IConsole console, StartServer startServer, InvocationContext context);
}
public static class Microsoft.DotNet.Interactive.App.CommandLine.JupyterCommand : object {
    public static Task`1<int> Do(StartupOptions startupOptions, IConsole console, StartServer startServer, InvocationContext context);
}
public class Microsoft.DotNet.Interactive.App.CommandLine.JupyterOptions : object {
    [CompilerGeneratedAttribute]
private FileInfo <ConnectionFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultKernel>k__BackingField;
    public FileInfo ConnectionFile { get; }
    public string DefaultKernel { get; }
    public JupyterOptions(FileInfo connectionFile, string defaultKernel);
    [CompilerGeneratedAttribute]
public FileInfo get_ConnectionFile();
    [CompilerGeneratedAttribute]
public string get_DefaultKernel();
}
public class Microsoft.DotNet.Interactive.App.CommandLine.KernelHttpOptions : object {
    [CompilerGeneratedAttribute]
private string <DefaultKernel>k__BackingField;
    public string DefaultKernel { get; }
    public KernelHttpOptions(string defaultKernel);
    [CompilerGeneratedAttribute]
public string get_DefaultKernel();
}
internal static class Microsoft.DotNet.Interactive.App.CommandLine.ParseNotebookCommand : object {
    public static Task RunParserServer(NotebookParserServer parserServer, DirectoryInfo logPath);
}
public class Microsoft.DotNet.Interactive.App.CommandLine.StartupOptions : object {
    [CompilerGeneratedAttribute]
private DirectoryInfo <LogPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Verbose>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpPort <HttpPort>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpPortRange <HttpPortRange>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <KernelHost>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectoryInfo <WorkingDir>k__BackingField;
    public DirectoryInfo LogPath { get; }
    public bool Verbose { get; }
    public HttpPort HttpPort { get; internal set; }
    public HttpPortRange HttpPortRange { get; internal set; }
    public Uri KernelHost { get; }
    public DirectoryInfo WorkingDir { get; internal set; }
    public bool EnableHttpApi { get; }
    public StartupOptions(DirectoryInfo logPath, bool verbose, HttpPortRange httpPortRange, HttpPort httpPort, Uri kernelHost, DirectoryInfo workingDir);
    [CompilerGeneratedAttribute]
public DirectoryInfo get_LogPath();
    [CompilerGeneratedAttribute]
public bool get_Verbose();
    [CompilerGeneratedAttribute]
public HttpPort get_HttpPort();
    [CompilerGeneratedAttribute]
internal void set_HttpPort(HttpPort value);
    [CompilerGeneratedAttribute]
public HttpPortRange get_HttpPortRange();
    [CompilerGeneratedAttribute]
internal void set_HttpPortRange(HttpPortRange value);
    [CompilerGeneratedAttribute]
public Uri get_KernelHost();
    [CompilerGeneratedAttribute]
public DirectoryInfo get_WorkingDir();
    [CompilerGeneratedAttribute]
internal void set_WorkingDir(DirectoryInfo value);
    public bool get_EnableHttpApi();
}
internal static class Microsoft.DotNet.Interactive.App.CommandLine.StdIoMode : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.CommandLine.StdIoMode/<Do>d__0")]
public static Task`1<int> Do(StartupOptions startupOptions, KernelHost kernelHost, IConsole console);
}
public class Microsoft.DotNet.Interactive.App.CommandLine.StdIOOptions : object {
    [CompilerGeneratedAttribute]
private string <DefaultKernel>k__BackingField;
    public string DefaultKernel { get; }
    public StdIOOptions(string defaultKernel);
    [CompilerGeneratedAttribute]
public string get_DefaultKernel();
}
public class Microsoft.DotNet.Interactive.App.Connection.ConnectStdIoCommand : ConnectKernelCommand {
    private static int _kernelHostAuthoritySuffix;
    private Uri _kernelHostUri;
    [CompilerGeneratedAttribute]
private Option`1<DirectoryInfo> <WorkingDirectoryOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<String[]> <CommandOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<string> <KernelHostUriOption>k__BackingField;
    public Option`1<DirectoryInfo> WorkingDirectoryOption { get; }
    public Option`1<String[]> CommandOption { get; }
    public Option`1<string> KernelHostUriOption { get; }
    public ConnectStdIoCommand(Uri kernelHostUri);
    private static ConnectStdIoCommand();
    private string CreateKernelHostAuthority();
    [CompilerGeneratedAttribute]
public Option`1<DirectoryInfo> get_WorkingDirectoryOption();
    [CompilerGeneratedAttribute]
public Option`1<String[]> get_CommandOption();
    [CompilerGeneratedAttribute]
public Option`1<string> get_KernelHostUriOption();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.Connection.ConnectStdIoCommand/<ConnectKernelsAsync>d__13")]
public virtual Task`1<IEnumerable`1<Kernel>> ConnectKernelsAsync(KernelInvocationContext context, InvocationContext commandLineContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.App.Connection.StdIoKernelConnector : object {
    private String[] _command;
    private string _rootProxyKernelLocalName;
    private Uri _kernelHostUri;
    private DirectoryInfo _workingDirectory;
    private ConcurrentDictionary`2<string, KernelInfo> _remoteKernelInfoCache;
    [NullableAttribute("2")]
private KernelCommandAndEventReceiver _receiver;
    [NullableAttribute("2")]
private KernelCommandAndEventSender _sender;
    [NullableAttribute("2")]
private Process _process;
    [NullableAttribute("2")]
private RefCountDisposable _refCountDisposable;
    public Nullable`1<int> ProcessId { get; }
    public StdIoKernelConnector(String[] command, string rootProxyKernelLocalName, Uri kernelHostUri, DirectoryInfo workingDirectory);
    public Nullable`1<int> get_ProcessId();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.Connection.StdIoKernelConnector/<CreateRootProxyKernelAsync>d__12")]
public Task`1<ProxyKernel> CreateRootProxyKernelAsync();
    private string GetCurrentCulture();
    private string GetCurrentUICulture();
    private void UpdateRemoteKernelInfoCache(IEnumerable`1<KernelInfo> infos);
    private void UpdateRemoteKernelInfoCache(KernelInfo info);
    private KernelInfo GetCachedKernelInfoForRemoteRoot();
    private bool TryGetCachedKernelInfoByRemoteName(string remoteName, KernelInfo& remoteInfo);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.Connection.StdIoKernelConnector/<CreateProxyKernelAsync>d__19")]
public Task`1<ProxyKernel> CreateProxyKernelAsync(string remoteName, string localNameOverride);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.Connection.StdIoKernelConnector/<CreateProxyKernelAsync>d__20")]
public Task`1<ProxyKernel> CreateProxyKernelAsync(KernelInfo remoteInfo, string localNameOverride);
    private void SendQuitCommand();
    private void KillRemoteKernelProcess();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <CreateRootProxyKernelAsync>b__12_5(KernelInfoProduced e);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetCachedKernelInfoForRemoteRoot>b__17_0(KernelInfo k);
}
public interface Microsoft.DotNet.Interactive.App.IJupyterKernelSpecInstaller {
    public abstract virtual Task`1<bool> TryInstallKernelAsync(DirectoryInfo kernelSpecPath, DirectoryInfo destination);
}
public class Microsoft.DotNet.Interactive.App.JupyterInstallCommand : object {
    private IConsole _console;
    private IJupyterKernelSpecInstaller _jupyterKernelSpecInstaller;
    private HttpPortRange _httpPortRange;
    private DirectoryInfo _path;
    private static JsonSerializerOptions JsonSerializerOptions;
    public JupyterInstallCommand(IConsole console, IJupyterKernelSpecInstaller jupyterKernelSpecInstaller, HttpPortRange httpPortRange, DirectoryInfo path);
    private static JupyterInstallCommand();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.JupyterInstallCommand/<InvokeAsync>d__6")]
public Task`1<int> InvokeAsync();
    private static void ComputeKernelSpecArgs(HttpPortRange httpPortRange, DirectoryInfo directory);
}
public class Microsoft.DotNet.Interactive.App.JupyterKernelSpecInstaller : object {
    private IConsole _console;
    private IJupyterKernelSpecModule _kernelSpecModule;
    public JupyterKernelSpecInstaller(IConsole console);
    public JupyterKernelSpecInstaller(IConsole console, IJupyterKernelSpecModule jupyterKernelSpecModule);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.JupyterKernelSpecInstaller/<TryInstallKernelAsync>d__4")]
public sealed virtual Task`1<bool> TryInstallKernelAsync(DirectoryInfo sourceDirectory, DirectoryInfo destination);
    private bool InstallKernelSpecToDirectory(DirectoryInfo sourceDirectory, DirectoryInfo destination, string kernelDisplayName);
    private string GetKernelDisplayName(DirectoryInfo directory);
    private bool CopyKernelSpecFiles(DirectoryInfo source, DirectoryInfo destination);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.App.KernelExtensionLoader : object {
    [ExtensionAttribute]
public static CompositeKernel UseNuGetExtensions(CompositeKernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.KernelExtensionLoader/<LoadExtensionsFromDirectoryAsync>d__1")]
[ExtensionAttribute]
public static Task LoadExtensionsFromDirectoryAsync(CompositeKernel kernel, DirectoryInfo extensionDir, KernelInvocationContext context);
    [ExtensionAttribute]
internal static bool CanBeInstantiated(Type type);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.App.KernelExtensions : object {
    [ExtensionAttribute]
public static CSharpKernel UseNugetDirective(CSharpKernel kernel, bool forceRestore);
    [ExtensionAttribute]
public static FSharpKernel UseNugetDirective(FSharpKernel kernel, bool forceRestore);
    [ExtensionAttribute]
public static T UseAboutMagicCommand(T kernel);
    [ExtensionAttribute]
public static CompositeKernel UseTelemetrySender(CompositeKernel kernel, TelemetrySender telemetrySender);
}
public class Microsoft.DotNet.Interactive.App.KernelSpecInstallResult : object {
    [CompilerGeneratedAttribute]
private bool <Succeeded>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public bool Succeeded { get; }
    public string Message { get; }
    public KernelSpecInstallResult(bool succeeded, string message);
    [CompilerGeneratedAttribute]
public bool get_Succeeded();
    [CompilerGeneratedAttribute]
public string get_Message();
}
internal static class Microsoft.DotNet.Interactive.App.LocalizationResources : object {
    internal static string Magics_about_Description();
    internal static string Cli_dotnet_interactive_jupyter_default_kernel_Description();
    internal static string Cli_dotnet_interactive_Description();
    internal static string Cli_dotnet_interactive_jupyter_connection_file_Description();
    internal static string Cli_dotnet_interactive_jupyter_install_http_port_range_Description();
    internal static string Cli_dotnet_interactive_jupyter_install_Description();
    internal static string Cli_dotnet_interactive_jupyter_Description();
    internal static string Cli_dotnet_interactive_log_path_Description();
    internal static string Cli_dotnet_interactive_notebook_parserDescription();
    internal static string Cli_ErrorMessageMustSpecifyPortRange();
    internal static string CliErrorMessageMustSpecifyPortRangeAsStartPortEndPort();
    internal static string CliErrorMessageStartPortMustBeLower();
    internal static string Cli_dotnet_interactive_jupyter_install_path_Description();
    internal static string Cli_dotnet_interactive_stdio_Description();
    internal static string Cli_dotnet_interactive_stdio_http_port_ErrorMessageCannotSpecifyBoth(string conflictingOption, string parsedOption);
    internal static string Cli_dotnet_interactive_stdio_http_port_ErrorMessageMustSpecifyPortNumber();
    internal static string Cli_dotnet_interactive_stdio_http_port_Description();
    internal static string Cli_dotnet_interactive_stdio_http_port_range_Description();
    internal static string Cli_dotnet_interactive_stdio_kernel_host_Description();
    internal static string Cli_dotnet_interactive_stdio_preview_Description();
    internal static string Cli_dotnet_interactive_stdio_working_directory_Description();
    internal static string Cli_dotnet_interactive_verbose_Description();
    private static string GetResourceString(string resourceString, Object[] formatArguments);
}
internal class Microsoft.DotNet.Interactive.App.PackageDirectoryExtensionLoader : object {
    private static string ExtensionScriptName;
    private HashSet`1<AssemblyName> _loadedAssemblies;
    private object _lock;
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.PackageDirectoryExtensionLoader/<LoadFromDirectoryAsync>d__3")]
public Task LoadFromDirectoryAsync(DirectoryInfo directory, Kernel kernel, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.PackageDirectoryExtensionLoader/<LoadFromDllsInDirectoryAsync>d__4")]
private Task LoadFromDllsInDirectoryAsync(DirectoryInfo directory, Kernel kernel, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.PackageDirectoryExtensionLoader/<LoadFromAssemblyFile>d__5")]
private Task LoadFromAssemblyFile(FileInfo assemblyFile, Kernel kernel, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.PackageDirectoryExtensionLoader/<LoadFromExtensionDibScriptAsync>d__6")]
private Task LoadFromExtensionDibScriptAsync(DirectoryInfo directory, Kernel kernel, KernelInvocationContext context);
}
public enum Microsoft.DotNet.Interactive.App.ParserServer.DocumentSerializationType : Enum {
    public int value__;
    public static DocumentSerializationType Dib;
    public static DocumentSerializationType Ipynb;
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.DotNet.Interactive.App.ParserServer.InteractiveDocumentConverter : JsonConverter`1<InteractiveDocument> {
    public virtual InteractiveDocument Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, InteractiveDocument document, JsonSerializerOptions options);
}
public abstract class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParseOrSerializeRequest : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private DocumentSerializationType <SerializationType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultLanguage>k__BackingField;
    public RequestType Type { get; }
    public string Id { get; }
    public DocumentSerializationType SerializationType { get; }
    public string DefaultLanguage { get; }
    private protected NotebookParseOrSerializeRequest(string id, DocumentSerializationType serializationType, string defaultLanguage);
    public abstract virtual RequestType get_Type();
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public DocumentSerializationType get_SerializationType();
    [CompilerGeneratedAttribute]
public string get_DefaultLanguage();
    public static NotebookParseOrSerializeRequest FromJson(string json);
}
public class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParseRequest : NotebookParseOrSerializeRequest {
    [CompilerGeneratedAttribute]
private Byte[] <RawData>k__BackingField;
    public RequestType Type { get; }
    public Byte[] RawData { get; }
    public NotebookParseRequest(string id, DocumentSerializationType serializationType, string defaultLanguage, Byte[] rawData);
    public virtual RequestType get_Type();
    [CompilerGeneratedAttribute]
public Byte[] get_RawData();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParseRequestConverter : JsonConverter`1<NotebookParseOrSerializeRequest> {
    public virtual NotebookParseOrSerializeRequest Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
public class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParseResponse : NotebookParserServerResponse {
    [CompilerGeneratedAttribute]
private InteractiveDocument <Document>k__BackingField;
    public InteractiveDocument Document { get; }
    public NotebookParseResponse(string id, InteractiveDocument document);
    [CompilerGeneratedAttribute]
public InteractiveDocument get_Document();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParseResponseConverter : JsonConverter`1<NotebookParserServerResponse> {
    public virtual NotebookParserServerResponse Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParserServer : object {
    private CancellationTokenSource _cancellationTokenSource;
    [CompilerGeneratedAttribute]
private TextReader <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private TextWriter <Output>k__BackingField;
    public static KernelInfoCollection WellKnownKernelInfos;
    public TextReader Input { get; }
    public TextWriter Output { get; }
    public NotebookParserServer(TextReader input, TextWriter output);
    private static NotebookParserServer();
    [CompilerGeneratedAttribute]
public TextReader get_Input();
    [CompilerGeneratedAttribute]
public TextWriter get_Output();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.ParserServer.NotebookParserServer/<RunAsync>d__9")]
public Task RunAsync();
    public static NotebookParserServerResponse HandleRequest(NotebookParseOrSerializeRequest request);
    public sealed virtual void Dispose();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParserServerExtensions : object {
    [ExtensionAttribute]
public static string ToJson(NotebookParserServerResponse response);
    [ExtensionAttribute]
public static string ToJson(NotebookParseOrSerializeRequest request);
}
public abstract class Microsoft.DotNet.Interactive.App.ParserServer.NotebookParserServerResponse : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    public string Id { get; }
    private protected NotebookParserServerResponse(string id);
    [CompilerGeneratedAttribute]
public string get_Id();
    public static NotebookParserServerResponse FromJson(string json);
}
public class Microsoft.DotNet.Interactive.App.ParserServer.NotebookSerializeRequest : NotebookParseOrSerializeRequest {
    [CompilerGeneratedAttribute]
private string <NewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private InteractiveDocument <Document>k__BackingField;
    public RequestType Type { get; }
    public string NewLine { get; }
    public InteractiveDocument Document { get; }
    public NotebookSerializeRequest(string id, DocumentSerializationType serializationType, string defaultLanguage, string newLine, InteractiveDocument document);
    public virtual RequestType get_Type();
    [CompilerGeneratedAttribute]
public string get_NewLine();
    [CompilerGeneratedAttribute]
public InteractiveDocument get_Document();
}
public class Microsoft.DotNet.Interactive.App.ParserServer.NotebookSerializeResponse : NotebookParserServerResponse {
    [CompilerGeneratedAttribute]
private Byte[] <RawData>k__BackingField;
    public Byte[] RawData { get; }
    public NotebookSerializeResponse(string id, Byte[] rawData);
    [CompilerGeneratedAttribute]
public Byte[] get_RawData();
}
public static class Microsoft.DotNet.Interactive.App.ParserServer.ParserServerSerializer : object {
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <JsonSerializerOptions>k__BackingField;
    public static JsonSerializerOptions JsonSerializerOptions { get; }
    private static ParserServerSerializer();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_JsonSerializerOptions();
}
public enum Microsoft.DotNet.Interactive.App.ParserServer.RequestType : Enum {
    public int value__;
    public static RequestType Parse;
    public static RequestType Serialize;
}
public class Microsoft.DotNet.Interactive.App.Program : object {
    private static ServiceCollection _serviceCollection;
    private static Assembly[] _assembliesEmittingPocketLoggerLogs;
    private static Program();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.App.Program/<Main>d__1")]
public static Task`1<int> Main(String[] args);
    public static void SetCultureFromEnvironmentVariables();
    internal static IDisposable StartToolLogging(DirectoryInfo logPath);
    public static IWebHostBuilder ConstructWebHostBuilder(StartupOptions options, IServiceCollection serviceCollection);
    public static IWebHost ConstructWebHost(StartupOptions options);
    private static int <Main>(String[] args);
    [CompilerGeneratedAttribute]
internal static HttpPort <ConstructWebHostBuilder>g__GetFreePort|5_1(StartupOptions startupOptions);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.DotNet.Interactive.App.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Cli_dotnet_interactive_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_connection_file_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_default_kernel_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_install_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_install_http_port_range_Description { get; }
    internal static string Cli_dotnet_interactive_jupyter_install_path_Description { get; }
    internal static string Cli_dotnet_interactive_log_path_Description { get; }
    internal static string Cli_dotnet_interactive_notebook_parser_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_http_port_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_http_port_ErrorMessageCannotSpecifyBoth { get; }
    internal static string Cli_dotnet_interactive_stdio_http_port_ErrorMessageMustSpecifyPortNumber { get; }
    internal static string Cli_dotnet_interactive_stdio_http_port_range_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_kernel_host_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_preview_Description { get; }
    internal static string Cli_dotnet_interactive_stdio_working_directory_Description { get; }
    internal static string Cli_dotnet_interactive_verbose_Description { get; }
    internal static string Cli_ErrorMessage_MustSpecifyPortRangeAsStartPortEndPort { get; }
    internal static string Cli_ErrorMessage_StartPortMustBeLower { get; }
    internal static string Cli_ErrorMessageMustSpecifyPortRange { get; }
    internal static string Magics_about_Description { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Cli_dotnet_interactive_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_connection_file_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_default_kernel_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_install_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_install_http_port_range_Description();
    internal static string get_Cli_dotnet_interactive_jupyter_install_path_Description();
    internal static string get_Cli_dotnet_interactive_log_path_Description();
    internal static string get_Cli_dotnet_interactive_notebook_parser_Description();
    internal static string get_Cli_dotnet_interactive_stdio_Description();
    internal static string get_Cli_dotnet_interactive_stdio_http_port_Description();
    internal static string get_Cli_dotnet_interactive_stdio_http_port_ErrorMessageCannotSpecifyBoth();
    internal static string get_Cli_dotnet_interactive_stdio_http_port_ErrorMessageMustSpecifyPortNumber();
    internal static string get_Cli_dotnet_interactive_stdio_http_port_range_Description();
    internal static string get_Cli_dotnet_interactive_stdio_kernel_host_Description();
    internal static string get_Cli_dotnet_interactive_stdio_preview_Description();
    internal static string get_Cli_dotnet_interactive_stdio_working_directory_Description();
    internal static string get_Cli_dotnet_interactive_verbose_Description();
    internal static string get_Cli_ErrorMessage_MustSpecifyPortRangeAsStartPortEndPort();
    internal static string get_Cli_ErrorMessage_StartPortMustBeLower();
    internal static string get_Cli_ErrorMessageMustSpecifyPortRange();
    internal static string get_Magics_about_Description();
}
internal class Microsoft.DotNet.Interactive.App.Startup : object {
    [CompilerGeneratedAttribute]
private IConfigurationRoot <Configuration>k__BackingField;
    [CompilerGeneratedAttribute]
private IHostEnvironment <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpOptions <HttpOptions>k__BackingField;
    protected IConfigurationRoot Configuration { get; }
    protected IHostEnvironment Environment { get; }
    public HttpOptions HttpOptions { get; }
    public Startup(IHostEnvironment env, HttpOptions httpOptions);
    [CompilerGeneratedAttribute]
protected IConfigurationRoot get_Configuration();
    [CompilerGeneratedAttribute]
protected IHostEnvironment get_Environment();
    [CompilerGeneratedAttribute]
public HttpOptions get_HttpOptions();
    public void ConfigureServices(IServiceCollection services);
    public void Configure(IApplicationBuilder app, IHostApplicationLifetime lifetime, IServiceProvider serviceProvider);
}
internal class Microsoft.DotNet.Interactive.Documents.Json.ByteArrayConverter : JsonConverter`1<Byte[]> {
    public virtual Byte[] Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, Byte[] value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Documents.JsonReaderExtensions : object {
    [ExtensionAttribute]
internal static T[] ReadArray(Utf8JsonReader& reader, JsonSerializerOptions options);
    [ExtensionAttribute]
internal static IDictionary`2<string, object> ReadDataDictionary(Utf8JsonReader& reader, JsonSerializerOptions options);
    [ExtensionAttribute]
internal static Nullable`1<int> ReadInt32(Utf8JsonReader& reader);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string ReadString(Utf8JsonReader& reader);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static string ReadArrayOrStringAsString(Utf8JsonReader& reader);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Http.AspNetExtensions : object {
    [ExtensionAttribute]
public static IServiceCollection AddKernel(IServiceCollection services, T kernel);
    [ExtensionAttribute]
public static IWebHostBuilder UseDotNetInteractiveHttpApi(IWebHostBuilder builder, bool enableHttpApi, HttpPort httpPort, HttpProbingSettings httpProbingSettings, IServiceCollection services);
    [ExtensionAttribute]
public static IServiceCollection AddDotnetInteractiveHttpApi(IServiceCollection services);
    [ExtensionAttribute]
public static IApplicationBuilder UseDotNetInteractiveHttpApi(IApplicationBuilder app, T kernel, Assembly staticResourceRoot, HttpProbingSettings httpProbingSettings, HttpPort httpPort);
}
public class Microsoft.DotNet.Interactive.Http.BrowserFrontendEnvironment : FrontendEnvironment {
}
internal class Microsoft.DotNet.Interactive.Http.ClientExecutionRouter : object {
    private HtmlNotebookFrontendEnvironment _frontendEnvironment;
    public ClientExecutionRouter(HtmlNotebookFrontendEnvironment frontendEnvironment);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.ClientExecutionRouter/<RouteAsync>d__3")]
public sealed virtual Task RouteAsync(RouteContext context);
}
public class Microsoft.DotNet.Interactive.Http.ConnectSignalRCommand : ConnectKernelCommand {
    [CompilerGeneratedAttribute]
private Option`1<Uri> <HubUrlOption>k__BackingField;
    public Option`1<Uri> HubUrlOption { get; }
    [CompilerGeneratedAttribute]
public Option`1<Uri> get_HubUrlOption();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.ConnectSignalRCommand/<ConnectKernelsAsync>d__4")]
public virtual Task`1<IEnumerable`1<Kernel>> ConnectKernelsAsync(KernelInvocationContext context, InvocationContext commandLineContext);
}
internal class Microsoft.DotNet.Interactive.Http.DiscoveryRouter : object {
    private HtmlNotebookFrontendEnvironment _frontendEnvironment;
    public DiscoveryRouter(HtmlNotebookFrontendEnvironment frontendEnvironment);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.DiscoveryRouter/<RouteAsync>d__3")]
public sealed virtual Task RouteAsync(RouteContext context);
}
public class Microsoft.DotNet.Interactive.Http.FileProvider : object {
    private EmbeddedFileProvider _root;
    private IDisposable _eventSubscription;
    private ConcurrentDictionary`2<string, EmbeddedFileProvider> _providers;
    public FileProvider(Kernel kernel, Assembly rootProviderAssembly);
    private void RegisterExtension(IKernelExtension kernelExtension);
    public sealed virtual IFileInfo GetFileInfo(string subpath);
    private ValueTuple`2<IFileProvider, string> GetProviderAndPath(string subpath);
    public sealed virtual IDirectoryContents GetDirectoryContents(string subpath);
    public sealed virtual IChangeToken Watch(string filter);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(KernelExtensionLoaded event);
    [CompilerGeneratedAttribute]
private string <GetProviderAndPath>g__ProcessPath|6_0(<>c__DisplayClass6_0& );
    [CompilerGeneratedAttribute]
private IFileProvider <GetProviderAndPath>g__SelectProvider|6_1(<>c__DisplayClass6_0& );
}
public class Microsoft.DotNet.Interactive.Http.HtmlNotebookFrontendEnvironment : BrowserFrontendEnvironment {
    private TimeSpan _getApiUriTimeout;
    private TaskCompletionSource`1<Uri> _completionSource;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ValueTuple`2<KernelInvocationContext, TaskCompletionSource>> _tokenToInvocationContext;
    [CompilerGeneratedAttribute]
private bool <RequiresAutomaticBootstrapping>k__BackingField;
    public bool RequiresAutomaticBootstrapping { get; public set; }
    public HtmlNotebookFrontendEnvironment(Nullable`1<TimeSpan> apiUriTimeout);
    public HtmlNotebookFrontendEnvironment(Uri apiUri);
    [CompilerGeneratedAttribute]
public bool get_RequiresAutomaticBootstrapping();
    [CompilerGeneratedAttribute]
public void set_RequiresAutomaticBootstrapping(bool value);
    public void SetApiUri(Uri apiUri);
    public Task`1<Uri> GetApiUriAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.HtmlNotebookFrontendEnvironment/<ExecuteClientScript>d__11")]
public virtual Task ExecuteClientScript(string code, KernelInvocationContext context);
    public void PublishEventFromCommand(string commandToken, Func`2<KernelCommand, KernelEvent> eventEnvelopeCreator);
    public void MarkExecutionComplete(string token);
}
internal static class Microsoft.DotNet.Interactive.Http.HttpApiBootstrapper : object {
    public static IHtmlContent GetHtmlInjection(Uri[] probingUris, string seed);
}
internal class Microsoft.DotNet.Interactive.Http.HttpApiTunnelingRouter : object {
    private HtmlNotebookFrontendEnvironment _frontendEnvironment;
    private ConcurrentDictionary`2<Uri, string> _bootstrapperScripts;
    public HttpApiTunnelingRouter(HtmlNotebookFrontendEnvironment frontendEnvironment);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.HttpApiTunnelingRouter/<RouteAsync>d__4")]
public sealed virtual Task RouteAsync(RouteContext context);
    private Task HandleGetVerb(RouteContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.HttpApiTunnelingRouter/<HandlePostVerb>d__6")]
private Task HandlePostVerb(RouteContext context);
    private string GenerateBootstrapperCode(Uri externalUri, string frontendType, string hash);
}
public class Microsoft.DotNet.Interactive.Http.HttpOptions : object {
    [CompilerGeneratedAttribute]
private bool <EnableHttpApi>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpPort <HttpPort>k__BackingField;
    public bool EnableHttpApi { get; }
    public HttpPort HttpPort { get; }
    public HttpOptions(bool enableHttpApi, HttpPort httpPort);
    [CompilerGeneratedAttribute]
public bool get_EnableHttpApi();
    [CompilerGeneratedAttribute]
public HttpPort get_HttpPort();
}
public class Microsoft.DotNet.Interactive.Http.HttpPort : object {
    [CompilerGeneratedAttribute]
private static HttpPort <Auto>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <PortNumber>k__BackingField;
    public static HttpPort Auto { get; }
    public Nullable`1<int> PortNumber { get; }
    public bool IsAuto { get; }
    public HttpPort(int portNumber);
    private static HttpPort();
    [CompilerGeneratedAttribute]
public static HttpPort get_Auto();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_PortNumber();
    public bool get_IsAuto();
}
public class Microsoft.DotNet.Interactive.Http.HttpPortRange : object {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private static HttpPortRange <Default>k__BackingField;
    public int Start { get; }
    public int End { get; }
    public static HttpPortRange Default { get; }
    public HttpPortRange(int start, int end);
    private static HttpPortRange();
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
public static HttpPortRange get_Default();
    public virtual string ToString();
}
internal class Microsoft.DotNet.Interactive.Http.HttpProbingSettings : object {
    [CompilerGeneratedAttribute]
private Uri[] <AddressList>k__BackingField;
    public Uri[] AddressList { get; private set; }
    [CompilerGeneratedAttribute]
public Uri[] get_AddressList();
    [CompilerGeneratedAttribute]
private void set_AddressList(Uri[] value);
    public static HttpProbingSettings Create(Nullable`1<int> port);
    private static Uri[] GetProbingAddressList(Nullable`1<int> httpPort);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Http.HttpRequestExtensions : object {
    private static string UnknownHostName;
    private static string MultipleHostName;
    private static string Comma;
    [ExtensionAttribute]
public static Uri GetUri(HttpRequest request);
}
internal class Microsoft.DotNet.Interactive.Http.KernelCommandAndEventSignalRHubConnectionSender : object {
    private HubConnection _hubConnection;
    [CompilerGeneratedAttribute]
private Uri <RemoteHostUri>k__BackingField;
    public Uri RemoteHostUri { get; }
    public KernelCommandAndEventSignalRHubConnectionSender(HubConnection sender);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelCommandAndEventSignalRHubConnectionSender/<SendAsync>d__2")]
public sealed virtual Task SendAsync(KernelCommand kernelCommand, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelCommandAndEventSignalRHubConnectionSender/<SendAsync>d__3")]
public sealed virtual Task SendAsync(KernelEvent kernelEvent, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_RemoteHostUri();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Http.KernelExtensions : object {
    [ExtensionAttribute]
public static T UseHttpApi(T kernel, HttpPort httpPort, HttpProbingSettings httpProbingSettings);
}
internal class Microsoft.DotNet.Interactive.Http.KernelHub : Hub {
    private KernelHubConnection _connection;
    public KernelHub(KernelHubConnection connection, IHubContext`1<KernelHub> hubContext);
    public Task SubmitCommand(string kernelCommandEnvelope);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelHub/<KernelCommandFromRemote>d__3")]
public Task KernelCommandFromRemote(string kernelCommandEnvelope);
    public Task KernelEvent(string kernelEventEnvelope);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelHub/<KernelEventFromRemote>d__5")]
public Task KernelEventFromRemote(string kernelEventEnvelope);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelHub/<Connect>d__6")]
public Task Connect();
}
internal class Microsoft.DotNet.Interactive.Http.KernelHubConnection : object {
    private CompositeDisposable _disposables;
    private SignalRBackchannelKernelClient _backchannelKernelClient;
    private bool _registered;
    [CompilerGeneratedAttribute]
private Kernel <Kernel>k__BackingField;
    public Kernel Kernel { get; }
    public KernelHubConnection(Kernel kernel, SignalRBackchannelKernelClient backchannelKernelClient);
    [CompilerGeneratedAttribute]
public Kernel get_Kernel();
    public void RegisterContext(IHubContext`1<KernelHub> hubContext);
    internal Task HandleKernelEventFromClientAsync(IKernelEventEnvelope envelope);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.KernelHubConnection/<PublishEventToContext>d__9")]
private Task PublishEventToContext(KernelEvent kernelEvent, IHubContext`1<KernelHub> hubContext);
    public sealed virtual void Dispose();
}
internal class Microsoft.DotNet.Interactive.Http.KernelsRouter : object {
    private Kernel _kernel;
    public KernelsRouter(Kernel kernel);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    public sealed virtual Task RouteAsync(RouteContext context);
}
internal class Microsoft.DotNet.Interactive.Http.PublishEventRouter : object {
    private HtmlNotebookFrontendEnvironment _frontendEnvironment;
    public PublishEventRouter(HtmlNotebookFrontendEnvironment frontendEnvironment);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.PublishEventRouter/<RouteAsync>d__3")]
public sealed virtual Task RouteAsync(RouteContext context);
}
internal class Microsoft.DotNet.Interactive.Http.SignalRBackchannelKernelClient : KernelClientBase {
    private IHubContext`1<KernelHub> _hubContext;
    private Subject`1<KernelEvent> _kernelEventsFromClient;
    public IObservable`1<KernelEvent> KernelEvents { get; }
    public virtual IObservable`1<KernelEvent> get_KernelEvents();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.SignalRBackchannelKernelClient/<SendAsync>d__4")]
public virtual Task SendAsync(KernelCommand command, string token);
    internal void SetContext(IHubContext`1<KernelHub> hubContext);
    internal Task HandleKernelEventFromClientAsync(IKernelEventEnvelope envelope);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.DotNet.Interactive.Http.SignalRKernelConnector : object {
    [CompilerGeneratedAttribute]
private Uri <HubUrl>k__BackingField;
    public Uri HubUrl { get; }
    public SignalRKernelConnector(Uri hubUrl);
    [CompilerGeneratedAttribute]
public Uri get_HubUrl();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.SignalRKernelConnector/<CreateKernelAsync>d__4")]
public Task`1<ProxyKernel> CreateKernelAsync(string kernelName);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Http.Utility.JsonElementExtensions : object {
    [ExtensionAttribute]
public static Nullable`1<JsonElement> GetPropertyFromPath(JsonElement source, String[] path);
}
internal class Microsoft.DotNet.Interactive.Http.VariableRouter : object {
    private static JsonSerializerOptions SerializerOptions;
    private Kernel _kernel;
    private static VariableRouter();
    public VariableRouter(Kernel kernel);
    public sealed virtual VirtualPathData GetVirtualPath(VirtualPathContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.VariableRouter/<RouteAsync>d__5")]
public sealed virtual Task RouteAsync(RouteContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.VariableRouter/<BatchVariableRequest>d__6")]
private Task BatchVariableRequest(RouteContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.VariableRouter/<GetValueAsync>d__7")]
private static Task`1<FormattedValue> GetValueAsync(Kernel targetKernel, string variableName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Http.VariableRouter/<SingleVariableRequest>d__8")]
private Task SingleVariableRequest(RouteContext context);
    private Kernel GetKernel(string kernelName);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.KernelDiagnostics : object {
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static T LogCommandsToPocketLogger(T kernel);
    [ExtensionAttribute]
[DebuggerStepThroughAttribute]
public static T LogEventsToPocketLogger(T kernel);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> getValue);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<string, object> dictionary, string key, Func`2<string, TValue> getValue);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Merge(IDictionary`2<TKey, TValue> dictionary1, IDictionary`2<TKey, TValue> dictionary2, bool replace, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static void MergeWith(IDictionary`2<TKey, TValue> target, IDictionary`2<TKey, TValue> source, bool replace);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.InvocationContextExtensions : object {
    [ExtensionAttribute]
public static T GetService(InvocationContext context);
}
[DebuggerStepThroughAttribute]
internal class Pocket.CompositeDisposable : object {
    private bool isDisposed;
    private List`1<IDisposable> disposables;
    public void Add(IDisposable disposable);
    public void Add(Action dispose);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerStepThroughAttribute]
internal class Pocket.ConfirmationLogger : OperationLogger {
    public ConfirmationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public void Fail(Exception exception, string message, Object[] args);
    public void Succeed(string message, Object[] args);
    public virtual void Dispose();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Pocket.Discover : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> Concrete(IEnumerable`1<Type> types);
    public static IEnumerable`1<Type> ConcreteTypes();
    [ExtensionAttribute]
public static IEnumerable`1<Type> DerivedFrom(IEnumerable`1<Type> types, Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ImplementingOpenGenericInterfaces(IEnumerable`1<Type> source, Type[] interfaces);
    public static IEnumerable`1<Type> Types();
    [ExtensionAttribute]
public static IEnumerable`1<Type> Types(IEnumerable`1<Assembly> assemblies);
}
[DebuggerStepThroughAttribute]
internal static class Pocket.Disposable : object {
    private static IDisposable empty;
    [CompilerGeneratedAttribute]
private static IDisposable <Empty>k__BackingField;
    public static IDisposable Empty { get; }
    private static Disposable();
    public static IDisposable Create(Action dispose);
    [CompilerGeneratedAttribute]
public static IDisposable get_Empty();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.For.ApplicationInsights.ApplicationInsightsExtensions : object {
    [ExtensionAttribute]
public static LoggerSubscription SubscribeToPocketLogger(TelemetryClient telemetryClient, Assembly[] onlySearchAssemblies);
    private static void WriteTelemetry(TelemetryClient telemetryClient, ValueTuple`8& e);
    [ExtensionAttribute]
private static void AddProperties(ISupportProperties telemetry, ValueTuple`2[]& properties);
    [ExtensionAttribute]
internal static T AttachActivity(T telemetry);
    [ExtensionAttribute]
internal static DependencyTelemetry ToDependencyTelemetry(ValueTuple`8& e);
    [ExtensionAttribute]
internal static EventTelemetry ToEventTelemetry(ValueTuple`8& e);
    [ExtensionAttribute]
internal static ExceptionTelemetry ToExceptionTelemetry(ValueTuple`8& e);
    [ExtensionAttribute]
internal static TraceTelemetry ToTraceTelemetry(ValueTuple`8& e);
    [ExtensionAttribute]
private static void AddCategory(ISupportProperties telemetry, string value);
    [ExtensionAttribute]
private static void AddDuration(ISupportProperties telemetry, Nullable`1<TimeSpan> duration);
    private static SeverityLevel MapSeverityLevel(LogLevel logLevel);
}
[ExtensionAttribute]
internal static class Pocket.Format : object {
    [ExtensionAttribute]
public static ValueTuple`2<string, ValueTuple`2[]> Evaluate(ValueTuple`8& e);
    [ExtensionAttribute]
public static string ToLogString(ValueTuple`8& e);
    private static void CustomizeLogString(object value, String& output);
    [ExtensionAttribute]
internal static string ToLogString(object value);
    [ExtensionAttribute]
private static string IfNotEmpty(string value, string prefix, string suffix);
    private static string LogLevelString(LogLevel logLevel, bool isStartOfOperation, bool isEndOfOperation, Nullable`1<bool> isOperationSuccessful, Nullable`1<TimeSpan> duration);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static void AppendLogString(TextWriter writer, KernelCommand command);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static void AppendLogString(TextWriter writer, KernelEvent event);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static void AppendProperties(TextWriter writer, ValueTuple`2[] properties);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static void AppendProperty(TextWriter writer, ValueTuple`2<string, string> property);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static void AppendProperty(TextWriter writer, string name, string value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
internal static string TruncateIfNeeded(string value, int maxLength);
    [CompilerGeneratedAttribute]
internal static string <LogLevelString>g__symbol|5_0(<>c__DisplayClass5_0& );
}
[DebuggerStepThroughAttribute]
internal class Pocket.Formatter : object {
    private static ConcurrentDictionary`2<string, Formatter> cache;
    private static bool stopCaching;
    private static int cacheCount;
    private static Regex tokenRegex;
    private string template;
    private List`1<Action`2<StringBuilder, object>> argumentFormatters;
    private List`1<string> tokens;
    [CompilerGeneratedAttribute]
private static int <CacheLimit>k__BackingField;
    public IReadOnlyList`1<string> Tokens { get; }
    public static int CacheCount { get; }
    public static int CacheLimit { get; public set; }
    private static Formatter();
    public Formatter(string template);
    public IReadOnlyList`1<string> get_Tokens();
    public FormatterResult Format(IReadOnlyList`1<object> args, IList`1<ValueTuple`2<string, object>> knownProperties);
    public FormatterResult Format(Object[] args);
    public static int get_CacheCount();
    [CompilerGeneratedAttribute]
public static int get_CacheLimit();
    [CompilerGeneratedAttribute]
public static void set_CacheLimit(int value);
    public static Formatter Parse(string template);
    [CompilerGeneratedAttribute]
internal static void <Format>g__TryAppendComma|11_0(<>c__DisplayClass11_0& , <>c__DisplayClass11_1& );
    [CompilerGeneratedAttribute]
internal static Formatter <Parse>g__CreateFormatter|19_0(string t);
}
[DebuggerStepThroughAttribute]
internal class Pocket.LogEntry : object {
    [CompilerGeneratedAttribute]
private bool <IsStartOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsOperationSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationLogger <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTemplate>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, object>> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public bool IsStartOfOperation { get; }
    public Nullable`1<bool> IsOperationSuccessful { get; }
    public bool IsEndOfOperation { get; }
    public Nullable`1<TimeSpan> OperationDuration { get; }
    public string OperationName { get; }
    public string Category { get; }
    public OperationLogger Operation { get; }
    public DateTime TimestampUtc { get; }
    public LogLevel LogLevel { get; }
    public Exception Exception { get; }
    public string OperationId { get; }
    public string MessageTemplate { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, object>> Properties { get; public set; }
    public Object[] Args { get; public set; }
    public LogEntry(LogLevel logLevel, string messageTemplate, Exception exception, string category, string operationName, OperationLogger operation, Object[] args);
    [CompilerGeneratedAttribute]
public bool get_IsStartOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsOperationSuccessful();
    [CompilerGeneratedAttribute]
public bool get_IsEndOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationDuration();
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public OperationLogger get_Operation();
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public string get_MessageTemplate();
    [CompilerGeneratedAttribute]
public void set_MessageTemplate(string value);
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<string, object>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<ValueTuple`2<string, object>> value);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(Object[] value);
    public void AddProperty(ValueTuple`2<string, object> property);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.LogEvents : object {
    public static IDisposable Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> onEnrich, Assembly[] searchInAssemblies);
    public static LoggerSubscription Subscribe(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> onEntryPosted, Assembly[] searchInAssemblies);
    private static void SubscribeLoggers(IEnumerable`1<Type> pocketLoggerTypes, LoggerSubscription subscription, Action`1<T> onEntryPosted);
    [ExtensionAttribute]
private static Action`1<T> Catch(Action`1<T> publish);
    [ExtensionAttribute]
private static IEnumerable`1<Type> PocketLoggers(IEnumerable`1<Type> types);
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<Action`1<ValueTuple`2<string, object>>> Enrich;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> Posted;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public string Category { get; }
    public static Logger Log { get; }
    public Logger(string category);
    private static Logger();
    [CompilerGeneratedAttribute]
public static void add_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void add_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    public virtual void Post(LogEntry entry);
    protected internal void Post(string message, LogLevel logLevel, string operationName, Exception exception, Object[] args, ValueTuple`2[]& properties);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger`1 : Logger {
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public static Logger Log { get; }
    private static Logger`1();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.LoggerExtensions : object {
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static void Event(Logger logger, string name);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] metrics);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] properties);
    [ExtensionAttribute]
public static void Event(Logger logger, ValueTuple`2[]& metrics, ValueTuple`2[]& properties, string name);
}
internal class Pocket.LoggerSubscription : object {
    private CompositeDisposable disposables;
    [CompilerGeneratedAttribute]
private List`1<Type> <DiscoveredLoggerTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, bool> <OnFormatLogEntry>k__BackingField;
    public List`1<Type> DiscoveredLoggerTypes { get; }
    public Action`2<string, bool> OnFormatLogEntry { get; public set; }
    public void Add(Type pocketLoggerType, IDisposable unsubscribe);
    [CompilerGeneratedAttribute]
public List`1<Type> get_DiscoveredLoggerTypes();
    [CompilerGeneratedAttribute]
public Action`2<string, bool> get_OnFormatLogEntry();
    [CompilerGeneratedAttribute]
public void set_OnFormatLogEntry(Action`2<string, bool> value);
    public sealed virtual void Dispose();
}
internal enum Pocket.LogLevel : Enum {
    public byte value__;
    public static LogLevel Telemetry;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Information;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
}
[DebuggerStepThroughAttribute]
internal class Pocket.OperationLogger : Logger {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<ValueTuple`2[]> exitArgs;
    private LogEntry initialEntry;
    private bool disposed;
    private Activity activity;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSuccessful>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public TimeSpan Duration { get; }
    public bool IsComplete { get; private set; }
    public bool IsStarting { get; }
    public Nullable`1<bool> IsSuccessful { get; protected set; }
    public OperationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public string get_Id();
    public string get_Name();
    public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
private void set_IsComplete(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStarting();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSuccessful();
    [CompilerGeneratedAttribute]
protected void set_IsSuccessful(Nullable`1<bool> value);
    public virtual void Post(LogEntry entry);
    protected void Complete(string message, Exception exception, Object[] args);
    public virtual void Dispose();
    protected virtual void Finalize();
}
[ExtensionAttribute]
public static class Recipes.EnvironmentExtensions : object {
    [ExtensionAttribute]
public static bool IsTest(IHostEnvironment hostingEnvironment);
    [ExtensionAttribute]
public static IWebHostBuilder UseTestEnvironment(IWebHostBuilder builder);
}
[ExtensionAttribute]
internal static class Recipes.LoggerExtensions : object {
    [ExtensionAttribute]
internal static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, Object[] properties, string name);
}
[ExtensionAttribute]
internal static class Recipes.TaskExtensions : object {
    [ExtensionAttribute]
internal static void DontAwait(Task task);
    [AsyncStateMachineAttribute("Recipes.TaskExtensions/<Timeout>d__1")]
[ExtensionAttribute]
public static Task Timeout(Task source, TimeSpan timeout);
}
