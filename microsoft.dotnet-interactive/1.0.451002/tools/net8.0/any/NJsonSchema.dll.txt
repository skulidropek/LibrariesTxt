[AttributeUsageAttribute("15296")]
public class NJsonSchema.Annotations.CanBeNullAttribute : Attribute {
}
public interface NJsonSchema.Annotations.IJsonSchemaExtensionDataAttribute {
    public string Key { get; }
    public object Value { get; }
    public abstract virtual string get_Key();
    public abstract virtual object get_Value();
}
[AttributeUsageAttribute("10624")]
public class NJsonSchema.Annotations.ItemsCanBeNullAttribute : Attribute {
}
[AttributeUsageAttribute("1028")]
public class NJsonSchema.Annotations.JsonSchemaAbstractAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <IsAbstract>k__BackingField;
    public bool IsAbstract { get; }
    public JsonSchemaAbstractAttribute(bool isAbstract);
    [CompilerGeneratedAttribute]
public bool get_IsAbstract();
}
[AttributeUsageAttribute("10380")]
public class NJsonSchema.Annotations.JsonSchemaAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ArrayItem>k__BackingField;
    public string Name { get; public set; }
    public JsonObjectType Type { get; private set; }
    public string Format { get; public set; }
    public Type ArrayItem { get; public set; }
    public JsonSchemaAttribute(string name);
    public JsonSchemaAttribute(JsonObjectType type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public JsonObjectType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(JsonObjectType value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public Type get_ArrayItem();
    [CompilerGeneratedAttribute]
public void set_ArrayItem(Type value);
}
public class NJsonSchema.Annotations.JsonSchemaDateAttribute : JsonSchemaAttribute {
}
[AttributeUsageAttribute("10372")]
public class NJsonSchema.Annotations.JsonSchemaExtensionDataAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public string Key { get; }
    public object Value { get; }
    public JsonSchemaExtensionDataAttribute(string key, object value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Key();
    [CompilerGeneratedAttribute]
public sealed virtual object get_Value();
}
[AttributeUsageAttribute("1028")]
public class NJsonSchema.Annotations.JsonSchemaFlattenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <Flatten>k__BackingField;
    public bool Flatten { get; }
    public JsonSchemaFlattenAttribute(bool flatten);
    [CompilerGeneratedAttribute]
public bool get_Flatten();
}
[AttributeUsageAttribute("132")]
public class NJsonSchema.Annotations.JsonSchemaIgnoreAttribute : Attribute {
}
[AttributeUsageAttribute("388")]
public class NJsonSchema.Annotations.JsonSchemaPatternPropertiesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <RegularExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string RegularExpression { get; }
    public Type Type { get; }
    public JsonSchemaPatternPropertiesAttribute(string regularExpression);
    public JsonSchemaPatternPropertiesAttribute(string regularExpression, Type type);
    [CompilerGeneratedAttribute]
public string get_RegularExpression();
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[AttributeUsageAttribute("4")]
public class NJsonSchema.Annotations.JsonSchemaProcessorAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    public Type Type { get; public set; }
    public Object[] Parameters { get; public set; }
    public JsonSchemaProcessorAttribute(Type type, Object[] parameters);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public Object[] get_Parameters();
    [CompilerGeneratedAttribute]
public void set_Parameters(Object[] value);
}
[AttributeUsageAttribute("10372")]
public class NJsonSchema.Annotations.JsonSchemaTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsNullableRaw>k__BackingField;
    public Type Type { get; }
    public bool IsNullable { get; public set; }
    public Nullable`1<bool> IsNullableRaw { get; internal set; }
    public JsonSchemaTypeAttribute(Type type);
    [CompilerGeneratedAttribute]
public Type get_Type();
    public bool get_IsNullable();
    public void set_IsNullable(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsNullableRaw();
    [CompilerGeneratedAttribute]
internal void set_IsNullableRaw(Nullable`1<bool> value);
}
[AttributeUsageAttribute("128")]
public class NJsonSchema.Annotations.MultipleOfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private decimal <MultipleOf>k__BackingField;
    public decimal MultipleOf { get; private set; }
    public MultipleOfAttribute(double multipleOf);
    public MultipleOfAttribute(decimal multipleOf);
    [CompilerGeneratedAttribute]
public decimal get_MultipleOf();
    [CompilerGeneratedAttribute]
private void set_MultipleOf(decimal value);
}
[AttributeUsageAttribute("15296")]
public class NJsonSchema.Annotations.NotNullAttribute : Attribute {
}
[DefaultMemberAttribute("Item")]
internal class NJsonSchema.Collections.ObservableDictionary`2 : object {
    private Dictionary`2<TKey, TValue> _dictionary;
    [CompilerGeneratedAttribute]
private bool <IsSynchronized>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private NotifyCollectionChangedEventHandler CollectionChanged;
    [CompilerGeneratedAttribute]
private PropertyChangedEventHandler PropertyChanged;
    public ICollection`1<TKey> Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public TValue Item { get; public set; }
    public bool IsFixedSize { get; }
    public int Count { get; }
    public bool IsSynchronized { get; private set; }
    public object SyncRoot { get; private set; }
    public bool IsReadOnly { get; }
    private object System.Collections.IDictionary.Item { get; private set; }
    public ObservableDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public ObservableDictionary`2(IEqualityComparer`1<TKey> comparer);
    public ObservableDictionary`2(int capacity);
    public ObservableDictionary`2(IDictionary`2<TKey, TValue> dictionary, IEqualityComparer`1<TKey> comparer);
    public ObservableDictionary`2(int capacity, IEqualityComparer`1<TKey> comparer);
    public void AddRange(IDictionary`2<TKey, TValue> items);
    private void Insert(TKey key, TValue value, bool add);
    private void OnPropertyChanged(string propertyName);
    private void OnCollectionChanged();
    private void OnCollectionChanged(NotifyCollectionChangedAction action, KeyValuePair`2<TKey, TValue> changedItem);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, KeyValuePair`2<TKey, TValue> newItem, KeyValuePair`2<TKey, TValue> oldItem);
    private void OnCollectionChanged(NotifyCollectionChangedAction action, IList newItems);
    private void OnPropertyChanged();
    public sealed virtual void Add(TKey key, TValue value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual ICollection`1<TKey> get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    public sealed virtual ICollection`1<TValue> get_Values();
    public sealed virtual TValue get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TValue value);
    public sealed virtual void Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    public sealed virtual void Clear();
    public void Initialize(IEnumerable`1<KeyValuePair`2<TKey, TValue>> keyValuePairs);
    public void Initialize(IEnumerable keyValuePairs);
    public sealed virtual bool Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    public sealed virtual void Remove(object key);
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TValue> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual void CopyTo(Array array, int index);
    public sealed virtual int get_Count();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsSynchronized();
    [CompilerGeneratedAttribute]
private void set_IsSynchronized(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_SyncRoot();
    [CompilerGeneratedAttribute]
private void set_SyncRoot(object value);
    public sealed virtual bool get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    public Enumerator<TKey, TValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public sealed virtual void add_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_CollectionChanged(NotifyCollectionChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void add_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_PropertyChanged(PropertyChangedEventHandler value);
    [CompilerGeneratedAttribute]
private bool <AddRange>b__7_0(TKey k);
}
public class NJsonSchema.ConversionUtilities : object {
    private static Char[] _whiteSpaceChars;
    private static Char[] _lineBreakTrimChars;
    private static ConversionUtilities();
    public static string ConvertToLowerCamelCase(string input, bool firstCharacterMustBeAlpha);
    public static string ConvertToUpperCamelCase(string input, bool firstCharacterMustBeAlpha);
    private static string Capitalize(string input);
    public static string ConvertToStringLiteral(string input);
    public static string ConvertToCamelCase(string input);
    public static string TrimWhiteSpaces(string text);
    public static string RemoveLineBreaks(string text);
    public static string Singularize(string word);
    public static string Tab(string input, int tabCount);
    public static void Tab(string input, int tabCount, TextWriter writer);
    private static void AddPrefixToBeginningOfNonEmptyLines(string input, string tabString, TextWriter writer);
    public static string ConvertCSharpDocs(string input, int tabCount);
    private static string CreateTabString(int tabCount);
    private static string ConvertDashesToCamelCase(string input);
}
public class NJsonSchema.Converters.JsonExceptionConverter : JsonConverter {
    private DefaultContractResolver _defaultContractResolver;
    private IDictionary`2<string, Assembly> _searchedNamespaces;
    private bool _hideStackTrace;
    public bool CanWrite { get; }
    public JsonExceptionConverter(bool hideStackTrace, IDictionary`2<string, Assembly> searchedNamespaces);
    public virtual bool get_CanWrite();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    private FieldInfo GetField(Type type, string fieldName);
    private IDictionary`2<PropertyInfo, string> GetExceptionProperties(Type exceptionType);
    private void SetExceptionFieldValue(JObject jObject, string propertyName, object value, string fieldName, IContractResolver resolver, JsonSerializer serializer);
}
[AttributeUsageAttribute("1028")]
public class NJsonSchema.Converters.JsonInheritanceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string Key { get; }
    public Type Type { get; }
    public JsonInheritanceAttribute(string key, Type type);
    [CompilerGeneratedAttribute]
public string get_Key();
    [CompilerGeneratedAttribute]
public Type get_Type();
}
public class NJsonSchema.Converters.JsonInheritanceConverter : JsonConverter {
    [CompilerGeneratedAttribute]
private static string <DefaultDiscriminatorName>k__BackingField;
    private Type _baseType;
    private string _discriminatorName;
    private bool _readTypeProperty;
    [ThreadStaticAttribute]
private static bool _isReading;
    [ThreadStaticAttribute]
private static bool _isWriting;
    public static string DefaultDiscriminatorName { get; }
    public string DiscriminatorName { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public JsonInheritanceConverter(string discriminatorName);
    public JsonInheritanceConverter(string discriminatorName, bool readTypeProperty);
    public JsonInheritanceConverter(Type baseType);
    public JsonInheritanceConverter(Type baseType, string discriminatorName);
    public JsonInheritanceConverter(Type baseType, string discriminatorName, bool readTypeProperty);
    private static JsonInheritanceConverter();
    [CompilerGeneratedAttribute]
public static string get_DefaultDiscriminatorName();
    public virtual string get_DiscriminatorName();
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual string GetDiscriminatorValue(Type type);
    protected virtual Type GetDiscriminatorType(JObject jObject, Type objectType, string discriminatorValue);
    private Type GetSubtypeFromKnownTypeAttributes(Type objectType, string discriminator);
    private static Type GetObjectSubtype(Type baseType, string discriminatorName);
    private static string GetSubtypeDiscriminator(Type objectType);
    [CompilerGeneratedAttribute]
private bool <ReadJson>b__22_0(JsonProperty p);
}
public class NJsonSchema.Converters.JsonReferenceConverter : JsonConverter {
    [ThreadStaticAttribute]
private static bool _isWriting;
    public bool CanWrite { get; }
    public virtual bool get_CanWrite();
    public virtual bool CanConvert(Type objectType);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
}
public class NJsonSchema.DefaultTypeNameGenerator : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ReservedTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <TypeNameMappings>k__BackingField;
    public IEnumerable`1<string> ReservedTypeNames { get; public set; }
    public IDictionary`2<string, string> TypeNameMappings { get; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ReservedTypeNames();
    [CompilerGeneratedAttribute]
public void set_ReservedTypeNames(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_TypeNameMappings();
    public virtual string Generate(JsonSchema schema, string typeNameHint, IEnumerable`1<string> reservedTypeNames);
    protected virtual string Generate(JsonSchema schema, string typeNameHint);
    private string GenerateAnonymousTypeName(string typeNameHint, IEnumerable`1<string> reservedTypeNames);
    private static string RemoveIllegalCharacters(string typeName);
    private static string DoRemoveIllegalCharacters(string typeName);
    private static bool IsEnglishLetterOrUnderScore(char c);
}
[ExtensionAttribute]
internal static class NJsonSchema.EnumExtensions : object {
    private static MethodImplOptions OptionAggressiveInlining;
    [ExtensionAttribute]
public static bool IsNull(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsNumber(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsObject(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsArray(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsInteger(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsString(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsBoolean(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsFile(JsonObjectType type);
    [ExtensionAttribute]
public static bool IsNone(JsonObjectType type);
}
internal class NJsonSchema.ExtensionDataDeserializationConverter : JsonConverter {
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    internal void DeserializeExtensionDataSchemas(IJsonExtensionObject extensionObject, JsonSerializer serializer);
    private object TryDeserializeValueSchemas(object value, JsonSerializer serializer);
}
public class NJsonSchema.Generation.DefaultReflectionService : object {
    public sealed virtual JsonTypeDescription GetDescription(ContextualType contextualType, JsonSchemaGeneratorSettings settings);
    public virtual JsonTypeDescription GetDescription(ContextualType contextualType, ReferenceTypeNullHandling defaultReferenceTypeNullHandling, JsonSchemaGeneratorSettings settings);
    public virtual bool IsNullable(ContextualType contextualType, ReferenceTypeNullHandling defaultReferenceTypeNullHandling);
    public virtual bool IsStringEnum(ContextualType contextualType, JsonSerializerSettings serializerSettings);
    protected virtual bool IsBinary(ContextualType contextualType);
    private bool IsIAsyncEnumerableType(ContextualType contextualType);
    protected virtual bool IsArrayType(ContextualType contextualType);
    protected virtual bool IsDictionaryType(ContextualType contextualType);
    private bool HasStringEnumConverter(ContextualType contextualType);
}
public class NJsonSchema.Generation.DefaultSchemaNameGenerator : object {
    public virtual string Generate(Type type);
    private static string GetName(CachedType cType);
    private static string GetNullableDisplayName(CachedType type, string actual);
    [CompilerGeneratedAttribute]
private string <Generate>b__0_0(CachedType a);
}
public enum NJsonSchema.Generation.EnumHandling : Enum {
    public int value__;
    public static EnumHandling Integer;
    public static EnumHandling String;
    public static EnumHandling CamelCaseString;
}
public interface NJsonSchema.Generation.IReflectionService {
    public abstract virtual JsonTypeDescription GetDescription(ContextualType contextualType, ReferenceTypeNullHandling defaultReferenceTypeNullHandling, JsonSchemaGeneratorSettings settings);
    public abstract virtual JsonTypeDescription GetDescription(ContextualType contextualType, JsonSchemaGeneratorSettings settings);
    public abstract virtual bool IsNullable(ContextualType contextualType, ReferenceTypeNullHandling defaultReferenceTypeNullHandling);
    public abstract virtual bool IsStringEnum(ContextualType contextualType, JsonSerializerSettings serializerSettings);
}
public interface NJsonSchema.Generation.ISchemaNameGenerator {
    public abstract virtual string Generate(Type type);
}
public interface NJsonSchema.Generation.ISchemaProcessor {
    public abstract virtual void Process(SchemaProcessorContext context);
}
public interface NJsonSchema.Generation.IXmlDocsSettings {
    public bool UseXmlDocumentation { get; }
    public bool ResolveExternalXmlDocumentation { get; }
    public XmlDocsFormattingMode XmlDocumentationFormatting { get; public set; }
    public abstract virtual bool get_UseXmlDocumentation();
    public abstract virtual bool get_ResolveExternalXmlDocumentation();
    public abstract virtual XmlDocsFormattingMode get_XmlDocumentationFormatting();
    public abstract virtual void set_XmlDocumentationFormatting(XmlDocsFormattingMode value);
}
public class NJsonSchema.Generation.JsonSchemaGenerator : object {
    private static Dictionary`2<string, string> DataTypeFormats;
    [CompilerGeneratedAttribute]
private JsonSchemaGeneratorSettings <Settings>k__BackingField;
    public JsonSchemaGeneratorSettings Settings { get; }
    public JsonSchemaGenerator(JsonSchemaGeneratorSettings settings);
    private static JsonSchemaGenerator();
    [CompilerGeneratedAttribute]
public JsonSchemaGeneratorSettings get_Settings();
    public JsonSchema Generate(Type type);
    public JsonSchema Generate(Type type, JsonSchemaResolver schemaResolver);
    public TSchemaType Generate(Type type, JsonSchemaResolver schemaResolver);
    public JsonSchema Generate(ContextualType contextualType, JsonSchemaResolver schemaResolver);
    public TSchemaType Generate(ContextualType contextualType, JsonSchemaResolver schemaResolver);
    public void Generate(TSchemaType schema, Type type, JsonSchemaResolver schemaResolver);
    public virtual void Generate(TSchemaType schema, ContextualType contextualType, JsonSchemaResolver schemaResolver);
    public TSchemaType GenerateWithReference(ContextualType contextualType, JsonSchemaResolver schemaResolver, Action`2<TSchemaType, JsonSchema> transformation);
    public TSchemaType GenerateWithReferenceAndNullability(ContextualType contextualType, JsonSchemaResolver schemaResolver, Action`2<TSchemaType, JsonSchema> transformation);
    public virtual TSchemaType GenerateWithReferenceAndNullability(ContextualType contextualType, bool isNullable, JsonSchemaResolver schemaResolver, Action`2<TSchemaType, JsonSchema> transformation);
    public virtual string GetPropertyName(JsonProperty jsonProperty, ContextualAccessorInfo accessorInfo);
    public virtual void ApplyDataAnnotations(JsonSchema schema, JsonTypeDescription typeDescription);
    public virtual object ConvertDefaultValue(ContextualType type, object defaultValue);
    public virtual object GenerateExample(ContextualType type);
    public virtual object GenerateExample(ContextualAccessorInfo accessorInfo);
    private object GenerateExample(string xmlDocs);
    protected virtual void GenerateObject(JsonSchema schema, JsonTypeDescription typeDescription, JsonSchemaResolver schemaResolver);
    protected virtual String[] GetTypeProperties(Type type);
    protected virtual void GenerateArray(TSchemaType schema, JsonTypeDescription typeDescription, JsonSchemaResolver schemaResolver);
    protected virtual void GenerateDictionary(TSchemaType schema, JsonTypeDescription typeDescription, JsonSchemaResolver schemaResolver);
    protected virtual void GenerateEnum(JsonSchema schema, JsonTypeDescription typeDescription);
    private TSchema GenerateDictionaryValueSchema(JsonSchemaResolver schemaResolver, ContextualType valueType);
    private void ApplyAdditionalProperties(TSchemaType schema, Type type, JsonSchemaResolver schemaResolver);
    private void ApplySchemaProcessors(JsonSchema schema, ContextualType contextualType, JsonSchemaResolver schemaResolver);
    private bool TryHandleSpecialTypes(TSchemaType schema, ContextualType contextualType, JsonSchemaResolver schemaResolver);
    private void GenerateEnum(TSchemaType schema, JsonTypeDescription typeDescription, JsonSchemaResolver schemaResolver);
    private void GenerateProperties(Type type, JsonSchema schema, JsonSchemaResolver schemaResolver);
    private bool IsAbstractProperty(ContextualMemberInfo memberInfo);
    private void GenerateKnownTypes(Type type, JsonSchemaResolver schemaResolver);
    private void AddKnownType(Type type, JsonSchemaResolver schemaResolver);
    private JsonSchema GenerateInheritance(ContextualType type, JsonSchema schema, JsonSchemaResolver schemaResolver);
    private void GenerateInheritanceDiscriminator(Type type, JsonSchema schema, JsonSchema typeSchema);
    private object TryGetInheritanceDiscriminatorConverter(Type type);
    private string TryGetInheritanceDiscriminatorName(object jsonInheritanceConverter);
    private void LoadPropertyOrField(JsonProperty jsonProperty, ContextualAccessorInfo accessorInfo, Type parentType, JsonSchema parentSchema, JsonSchemaResolver schemaResolver);
    protected virtual bool IsPropertyIgnored(ContextualAccessorInfo accessorInfo, Type parentType);
    private bool IsPropertyIgnoredBySettings(ContextualAccessorInfo accessorInfo);
    private object GetDataMemberAttribute(ContextualAccessorInfo accessorInfo, Type parentType);
    private bool HasDataContractAttribute(Type parentType);
    private void ApplyRangeAttribute(JsonSchema schema, IEnumerable`1<Attribute> parentAttributes);
    private void ApplyTypeExtensionDataAttributes(TSchemaType schema, ContextualType contextualType);
    private void ApplyPropertyExtensionDataAttributes(ContextualAccessorInfo accessorInfo, JsonSchemaProperty propertySchema);
}
public class NJsonSchema.Generation.JsonSchemaGeneratorSettings : object {
    private EnumHandling _defaultEnumHandling;
    private PropertyNameHandling _defaultPropertyNameHandling;
    private IContractResolver _contractResolver;
    private JsonSerializerSettings _serializerSettings;
    private object _serializerOptions;
    [CompilerGeneratedAttribute]
private ReferenceTypeNullHandling <DefaultReferenceTypeNullHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private ReferenceTypeNullHandling <DefaultDictionaryValueReferenceTypeNullHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateAbstractProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlattenInheritanceHierarchy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateAbstractSchemas>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateKnownTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateXmlObjects>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreObsoleteProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowReferencesWithProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateEnumMappingDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AlwaysAllowAdditionalObjectProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateExamples>k__BackingField;
    [CompilerGeneratedAttribute]
private SchemaType <SchemaType>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExcludedTypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ResolveExternalXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private XmlDocsFormattingMode <XmlDocumentationFormatting>k__BackingField;
    [CompilerGeneratedAttribute]
private ITypeNameGenerator <TypeNameGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private ISchemaNameGenerator <SchemaNameGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private IReflectionService <ReflectionService>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ITypeMapper> <TypeMappers>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<ISchemaProcessor> <SchemaProcessors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GenerateCustomNullableProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private IContractResolver <ActualContractResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSerializerSettings <ActualSerializerSettings>k__BackingField;
    public ReferenceTypeNullHandling DefaultReferenceTypeNullHandling { get; public set; }
    public ReferenceTypeNullHandling DefaultDictionaryValueReferenceTypeNullHandling { get; public set; }
    public bool GenerateAbstractProperties { get; public set; }
    public bool FlattenInheritanceHierarchy { get; public set; }
    public bool GenerateAbstractSchemas { get; public set; }
    public bool GenerateKnownTypes { get; public set; }
    public bool GenerateXmlObjects { get; public set; }
    public bool IgnoreObsoleteProperties { get; public set; }
    public bool AllowReferencesWithProperties { get; public set; }
    public bool GenerateEnumMappingDescription { get; public set; }
    public bool AlwaysAllowAdditionalObjectProperties { get; public set; }
    public bool GenerateExamples { get; public set; }
    public SchemaType SchemaType { get; public set; }
    [JsonIgnoreAttribute]
public JsonSerializerSettings SerializerSettings { get; public set; }
    [JsonIgnoreAttribute]
public object SerializerOptions { get; public set; }
    public String[] ExcludedTypeNames { get; public set; }
    public bool UseXmlDocumentation { get; public set; }
    public bool ResolveExternalXmlDocumentation { get; public set; }
    public XmlDocsFormattingMode XmlDocumentationFormatting { get; public set; }
    [JsonIgnoreAttribute]
public ITypeNameGenerator TypeNameGenerator { get; public set; }
    [JsonIgnoreAttribute]
public ISchemaNameGenerator SchemaNameGenerator { get; public set; }
    [JsonIgnoreAttribute]
public IReflectionService ReflectionService { get; public set; }
    [JsonIgnoreAttribute]
public ICollection`1<ITypeMapper> TypeMappers { get; public set; }
    [JsonIgnoreAttribute]
public ICollection`1<ISchemaProcessor> SchemaProcessors { get; }
    public bool GenerateCustomNullableProperties { get; public set; }
    [JsonIgnoreAttribute]
[ObsoleteAttribute("Use SerializerSettings directly instead. In NSwag.AspNetCore the property is set automatically.")]
public IContractResolver ContractResolver { get; public set; }
    [ObsoleteAttribute("Use SerializerSettings directly instead. In NSwag.AspNetCore the property is set automatically.")]
public PropertyNameHandling DefaultPropertyNameHandling { get; public set; }
    [ObsoleteAttribute("Use SerializerSettings directly instead. In NSwag.AspNetCore the property is set automatically.")]
public EnumHandling DefaultEnumHandling { get; public set; }
    [JsonIgnoreAttribute]
public IContractResolver ActualContractResolver { get; internal set; }
    [JsonIgnoreAttribute]
public JsonSerializerSettings ActualSerializerSettings { get; internal set; }
    [CompilerGeneratedAttribute]
public ReferenceTypeNullHandling get_DefaultReferenceTypeNullHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultReferenceTypeNullHandling(ReferenceTypeNullHandling value);
    [CompilerGeneratedAttribute]
public ReferenceTypeNullHandling get_DefaultDictionaryValueReferenceTypeNullHandling();
    [CompilerGeneratedAttribute]
public void set_DefaultDictionaryValueReferenceTypeNullHandling(ReferenceTypeNullHandling value);
    [CompilerGeneratedAttribute]
public bool get_GenerateAbstractProperties();
    [CompilerGeneratedAttribute]
public void set_GenerateAbstractProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_FlattenInheritanceHierarchy();
    [CompilerGeneratedAttribute]
public void set_FlattenInheritanceHierarchy(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateAbstractSchemas();
    [CompilerGeneratedAttribute]
public void set_GenerateAbstractSchemas(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateKnownTypes();
    [CompilerGeneratedAttribute]
public void set_GenerateKnownTypes(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateXmlObjects();
    [CompilerGeneratedAttribute]
public void set_GenerateXmlObjects(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreObsoleteProperties();
    [CompilerGeneratedAttribute]
public void set_IgnoreObsoleteProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowReferencesWithProperties();
    [CompilerGeneratedAttribute]
public void set_AllowReferencesWithProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateEnumMappingDescription();
    [CompilerGeneratedAttribute]
public void set_GenerateEnumMappingDescription(bool value);
    [CompilerGeneratedAttribute]
public bool get_AlwaysAllowAdditionalObjectProperties();
    [CompilerGeneratedAttribute]
public void set_AlwaysAllowAdditionalObjectProperties(bool value);
    [CompilerGeneratedAttribute]
public bool get_GenerateExamples();
    [CompilerGeneratedAttribute]
public void set_GenerateExamples(bool value);
    [CompilerGeneratedAttribute]
public SchemaType get_SchemaType();
    [CompilerGeneratedAttribute]
public void set_SchemaType(SchemaType value);
    public JsonSerializerSettings get_SerializerSettings();
    public void set_SerializerSettings(JsonSerializerSettings value);
    public object get_SerializerOptions();
    public void set_SerializerOptions(object value);
    [CompilerGeneratedAttribute]
public String[] get_ExcludedTypeNames();
    [CompilerGeneratedAttribute]
public void set_ExcludedTypeNames(String[] value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseXmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_UseXmlDocumentation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ResolveExternalXmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_ResolveExternalXmlDocumentation(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual XmlDocsFormattingMode get_XmlDocumentationFormatting();
    [CompilerGeneratedAttribute]
public sealed virtual void set_XmlDocumentationFormatting(XmlDocsFormattingMode value);
    [CompilerGeneratedAttribute]
public ITypeNameGenerator get_TypeNameGenerator();
    [CompilerGeneratedAttribute]
public void set_TypeNameGenerator(ITypeNameGenerator value);
    [CompilerGeneratedAttribute]
public ISchemaNameGenerator get_SchemaNameGenerator();
    [CompilerGeneratedAttribute]
public void set_SchemaNameGenerator(ISchemaNameGenerator value);
    [CompilerGeneratedAttribute]
public IReflectionService get_ReflectionService();
    [CompilerGeneratedAttribute]
public void set_ReflectionService(IReflectionService value);
    [CompilerGeneratedAttribute]
public ICollection`1<ITypeMapper> get_TypeMappers();
    [CompilerGeneratedAttribute]
public void set_TypeMappers(ICollection`1<ITypeMapper> value);
    [CompilerGeneratedAttribute]
public ICollection`1<ISchemaProcessor> get_SchemaProcessors();
    [CompilerGeneratedAttribute]
public bool get_GenerateCustomNullableProperties();
    [CompilerGeneratedAttribute]
public void set_GenerateCustomNullableProperties(bool value);
    public IContractResolver get_ContractResolver();
    public void set_ContractResolver(IContractResolver value);
    public PropertyNameHandling get_DefaultPropertyNameHandling();
    public void set_DefaultPropertyNameHandling(PropertyNameHandling value);
    public EnumHandling get_DefaultEnumHandling();
    public void set_DefaultEnumHandling(EnumHandling value);
    [CompilerGeneratedAttribute]
public IContractResolver get_ActualContractResolver();
    [CompilerGeneratedAttribute]
internal void set_ActualContractResolver(IContractResolver value);
    [CompilerGeneratedAttribute]
public JsonSerializerSettings get_ActualSerializerSettings();
    [CompilerGeneratedAttribute]
internal void set_ActualSerializerSettings(JsonSerializerSettings value);
    public JsonContract ResolveContract(Type type);
    public bool GetActualGenerateAbstractSchema(Type type);
    public bool GetActualFlattenInheritanceHierarchy(Type type);
    private void UpdateActualContractResolverAndSerializerSettings();
    private void UpdateActualSerializerSettings();
}
public class NJsonSchema.Generation.JsonSchemaResolver : JsonSchemaAppender {
    private Dictionary`2<string, JsonSchema> _mappings;
    private JsonSchemaGeneratorSettings _settings;
    public IEnumerable`1<JsonSchema> Schemas { get; }
    public JsonSchemaResolver(object rootObject, JsonSchemaGeneratorSettings settings);
    public bool HasSchema(Type type, bool isIntegerEnumeration);
    public JsonSchema GetSchema(Type type, bool isIntegerEnumeration);
    public virtual void AddSchema(Type type, bool isIntegerEnumeration, JsonSchema schema);
    public IEnumerable`1<JsonSchema> get_Schemas();
    protected virtual string GetTypeKey(Type type, bool isIntegerEnum);
}
public class NJsonSchema.Generation.JsonTypeDescription : object {
    [CompilerGeneratedAttribute]
private ContextualType <ContextualType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonObjectType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDictionary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEnum>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNullable>k__BackingField;
    public ContextualType ContextualType { get; }
    public JsonObjectType Type { get; private set; }
    public bool IsDictionary { get; private set; }
    public bool IsEnum { get; private set; }
    public string Format { get; private set; }
    public bool IsNullable { get; public set; }
    public bool IsComplexType { get; }
    public bool IsAny { get; }
    private JsonTypeDescription(ContextualType type, JsonObjectType jsonType, bool isNullable);
    public static JsonTypeDescription Create(ContextualType type, JsonObjectType jsonType, bool isNullable, string format);
    public static JsonTypeDescription CreateForDictionary(ContextualType type, JsonObjectType jsonType, bool isNullable);
    public static JsonTypeDescription CreateForEnumeration(ContextualType type, JsonObjectType jsonType, bool isNullable);
    [CompilerGeneratedAttribute]
public ContextualType get_ContextualType();
    [CompilerGeneratedAttribute]
public JsonObjectType get_Type();
    [CompilerGeneratedAttribute]
private void set_Type(JsonObjectType value);
    [CompilerGeneratedAttribute]
public bool get_IsDictionary();
    [CompilerGeneratedAttribute]
private void set_IsDictionary(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsEnum();
    [CompilerGeneratedAttribute]
private void set_IsEnum(bool value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
private void set_Format(string value);
    [CompilerGeneratedAttribute]
public bool get_IsNullable();
    [CompilerGeneratedAttribute]
public void set_IsNullable(bool value);
    public bool get_IsComplexType();
    public bool get_IsAny();
    public bool RequiresSchemaReference(IEnumerable`1<ITypeMapper> typeMappers);
    public void ApplyType(JsonSchema schema);
    [CompilerGeneratedAttribute]
private bool <RequiresSchemaReference>b__31_0(ITypeMapper m);
}
public enum NJsonSchema.Generation.PropertyNameHandling : Enum {
    public int value__;
    public static PropertyNameHandling Default;
    public static PropertyNameHandling CamelCase;
    public static PropertyNameHandling SnakeCase;
}
public enum NJsonSchema.Generation.ReferenceTypeNullHandling : Enum {
    public int value__;
    public static ReferenceTypeNullHandling Null;
    public static ReferenceTypeNullHandling NotNull;
}
public class NJsonSchema.Generation.SampleJsonDataGenerator : object {
    private SampleJsonDataGeneratorSettings _settings;
    public SampleJsonDataGenerator(SampleJsonDataGeneratorSettings settings);
    public JToken Generate(JsonSchema schema);
    private JToken Generate(JsonSchema schema, HashSet`1<JsonSchema> usedSchemas);
    private JToken HandleNumberType(JsonSchema schema);
    private JToken HandleIntegerType(JsonSchema schema);
    private JToken HandleStringType(JsonSchema schema, JsonSchemaProperty property);
    private IEnumerable`1<KeyValuePair`2<string, JsonSchemaProperty>> GetPropertiesToGenerate(IEnumerable`1<JsonSchema> schemas);
    private IEnumerable`1<KeyValuePair`2<string, JsonSchemaProperty>> GetPropertiesToGenerate(JsonSchema schema);
}
public class NJsonSchema.Generation.SampleJsonDataGeneratorSettings : object {
    [CompilerGeneratedAttribute]
private bool <GenerateOptionalProperties>k__BackingField;
    public bool GenerateOptionalProperties { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_GenerateOptionalProperties();
    [CompilerGeneratedAttribute]
public void set_GenerateOptionalProperties(bool value);
}
public class NJsonSchema.Generation.SampleJsonSchemaGenerator : object {
    public JsonSchema Generate(string json);
    public JsonSchema Generate(Stream stream);
    private void Generate(JToken token, JsonSchema schema, JsonSchema rootSchema, string typeNameHint);
    private void GenerateWithoutReference(JToken token, JsonSchema schema, JsonSchema rootSchema, string typeNameHint);
    private void GenerateObject(JToken token, JsonSchema schema, JsonSchema rootSchema);
    private void GenerateArray(JToken token, JsonSchema schema, JsonSchema rootSchema, string typeNameHint);
    private void MergeAndAssignItemSchemas(JsonSchema rootSchema, JsonSchema schema, List`1<JsonSchema> itemSchemas, string typeNameHint);
    private void AddSchemaDefinition(JsonSchema rootSchema, JsonSchema schema, string typeNameHint);
}
public class NJsonSchema.Generation.SchemaProcessorContext : object {
    [CompilerGeneratedAttribute]
private ContextualType <ContextualType>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaResolver <Resolver>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaGenerator <Generator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaGeneratorSettings <Settings>k__BackingField;
    [ObsoleteAttribute("Use ContextualType to obtain this instead.")]
public Type Type { get; }
    public ContextualType ContextualType { get; }
    public JsonSchema Schema { get; }
    public JsonSchemaResolver Resolver { get; }
    public JsonSchemaGenerator Generator { get; }
    public JsonSchemaGeneratorSettings Settings { get; }
    public SchemaProcessorContext(ContextualType contextualType, JsonSchema schema, JsonSchemaResolver resolver, JsonSchemaGenerator generator, JsonSchemaGeneratorSettings settings);
    public Type get_Type();
    [CompilerGeneratedAttribute]
public ContextualType get_ContextualType();
    [CompilerGeneratedAttribute]
public JsonSchema get_Schema();
    [CompilerGeneratedAttribute]
public JsonSchemaResolver get_Resolver();
    [CompilerGeneratedAttribute]
public JsonSchemaGenerator get_Generator();
    [CompilerGeneratedAttribute]
public JsonSchemaGeneratorSettings get_Settings();
}
public class NJsonSchema.Generation.SchemaProcessors.DiscriminatorSchemaProcessor : object {
    [CompilerGeneratedAttribute]
private Type <BaseType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Discriminator>k__BackingField;
    public Type BaseType { get; }
    public string Discriminator { get; }
    public DiscriminatorSchemaProcessor(Type baseType);
    public DiscriminatorSchemaProcessor(Type baseType, string discriminator);
    [CompilerGeneratedAttribute]
public Type get_BaseType();
    [CompilerGeneratedAttribute]
public string get_Discriminator();
    public sealed virtual void Process(SchemaProcessorContext context);
}
public static class NJsonSchema.Generation.SystemTextJsonUtilities : object {
    public static JsonSerializerSettings ConvertJsonOptionsToNewtonsoftSettings(object serializerOptions);
    private static bool IsCamelCaseEnumNamingPolicy(object jsonStringEnumConverter);
}
public interface NJsonSchema.Generation.TypeMappers.ITypeMapper {
    public Type MappedType { get; }
    public bool UseReference { get; }
    public abstract virtual Type get_MappedType();
    public abstract virtual bool get_UseReference();
    public abstract virtual void GenerateSchema(JsonSchema schema, TypeMapperContext context);
}
public class NJsonSchema.Generation.TypeMappers.ObjectTypeMapper : object {
    private Func`3<JsonSchemaGenerator, JsonSchemaResolver, JsonSchema> _schemaFactory;
    [CompilerGeneratedAttribute]
private Type <MappedType>k__BackingField;
    public Type MappedType { get; }
    public bool UseReference { get; }
    public ObjectTypeMapper(Type mappedType, JsonSchema schema);
    public ObjectTypeMapper(Type mappedType, Func`3<JsonSchemaGenerator, JsonSchemaResolver, JsonSchema> schemaFactory);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MappedType();
    public sealed virtual bool get_UseReference();
    public sealed virtual void GenerateSchema(JsonSchema schema, TypeMapperContext context);
}
public class NJsonSchema.Generation.TypeMappers.PrimitiveTypeMapper : object {
    private Action`1<JsonSchema> _transformer;
    [CompilerGeneratedAttribute]
private Type <MappedType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseReference>k__BackingField;
    public Type MappedType { get; }
    public bool UseReference { get; }
    public PrimitiveTypeMapper(Type mappedType, Action`1<JsonSchema> transformer);
    [CompilerGeneratedAttribute]
public sealed virtual Type get_MappedType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_UseReference();
    public sealed virtual void GenerateSchema(JsonSchema schema, TypeMapperContext context);
}
public class NJsonSchema.Generation.TypeMappers.TypeMapperContext : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaGenerator <JsonSchemaGenerator>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchemaResolver <JsonSchemaResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<Attribute> <ParentAttributes>k__BackingField;
    public Type Type { get; }
    public JsonSchemaGenerator JsonSchemaGenerator { get; }
    public JsonSchemaResolver JsonSchemaResolver { get; }
    public IEnumerable`1<Attribute> ParentAttributes { get; }
    public TypeMapperContext(Type type, JsonSchemaGenerator jsonSchemaGenerator, JsonSchemaResolver jsonSchemaResolver, IEnumerable`1<Attribute> parentAttributes);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public JsonSchemaGenerator get_JsonSchemaGenerator();
    [CompilerGeneratedAttribute]
public JsonSchemaResolver get_JsonSchemaResolver();
    [CompilerGeneratedAttribute]
public IEnumerable`1<Attribute> get_ParentAttributes();
}
[ExtensionAttribute]
internal static class NJsonSchema.Generation.XmlDocsSettingsExtensions : object {
    [ExtensionAttribute]
internal static XmlDocsOptions GetXmlDocsOptions(IXmlDocsSettings settings);
}
public interface NJsonSchema.IDocumentPathProvider {
    [JsonIgnoreAttribute]
public string DocumentPath { get; public set; }
    public abstract virtual string get_DocumentPath();
    public abstract virtual void set_DocumentPath(string value);
}
public interface NJsonSchema.IJsonExtensionObject {
    public IDictionary`2<string, object> ExtensionData { get; public set; }
    public abstract virtual IDictionary`2<string, object> get_ExtensionData();
    public abstract virtual void set_ExtensionData(IDictionary`2<string, object> value);
}
public class NJsonSchema.Infrastructure.CollectionProxy`2 : object {
    private ICollection`1<TImplementation> _collection;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public CollectionProxy`2(ICollection`1<TImplementation> collection);
    public sealed virtual IEnumerator`1<TInterface> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(TInterface item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(TInterface item);
    public sealed virtual void CopyTo(TInterface[] array, int arrayIndex);
    public sealed virtual bool Remove(TInterface item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
}
[DefaultMemberAttribute("Item")]
internal class NJsonSchema.Infrastructure.DictionaryProxy`3 : object {
    private IDictionary`2<TKey, TImplementation> _dictionary;
    public int Count { get; }
    public bool IsReadOnly { get; }
    public TInterface Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TInterface> Values { get; }
    public DictionaryProxy`3(IDictionary`2<TKey, TImplementation> dictionary);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TInterface>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Add(KeyValuePair`2<TKey, TInterface> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<TKey, TInterface> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual bool Remove(KeyValuePair`2<TKey, TInterface> item);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(TKey key, TInterface value);
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual bool Remove(TKey key);
    public sealed virtual bool TryGetValue(TKey key, TInterface& value);
    public sealed virtual TInterface get_Item(TKey key);
    public sealed virtual void set_Item(TKey key, TInterface value);
    public sealed virtual ICollection`1<TKey> get_Keys();
    public sealed virtual ICollection`1<TInterface> get_Values();
}
public static class NJsonSchema.Infrastructure.DynamicApis : object {
    private static Type XPathExtensionsType;
    private static Type FileType;
    private static Type DirectoryType;
    private static Type PathType;
    private static Type HttpClientHandlerType;
    private static Type HttpClientType;
    public static bool SupportsFileApis { get; }
    public static bool SupportsPathApis { get; }
    public static bool SupportsDirectoryApis { get; }
    public static bool SupportsXPathApis { get; }
    public static bool SupportsHttpClientApis { get; }
    private static DynamicApis();
    public static bool get_SupportsFileApis();
    public static bool get_SupportsPathApis();
    public static bool get_SupportsDirectoryApis();
    public static bool get_SupportsXPathApis();
    public static bool get_SupportsHttpClientApis();
    [AsyncStateMachineAttribute("NJsonSchema.Infrastructure.DynamicApis/<HttpGetAsync>d__17")]
public static Task`1<string> HttpGetAsync(string url, CancellationToken cancellationToken);
    public static string DirectoryGetCurrentDirectory();
    public static String[] DirectoryGetDirectories(string directory);
    public static String[] DirectoryGetFiles(string directory, string filter);
    public static string DirectoryGetParent(string path);
    public static void DirectoryCreateDirectory(string directory);
    public static bool DirectoryExists(string filePath);
    public static bool FileExists(string filePath);
    public static string FileReadAllText(string filePath);
    public static void FileWriteAllText(string filePath, string text);
    public static string PathCombine(string path1, string path2);
    public static string PathGetFileName(string filePath);
    public static string GetFullPath(string path);
    public static string PathGetDirectoryName(string filePath);
    public static object XPathEvaluate(XDocument document, string path);
    public static string HandleSubdirectoryRelativeReferences(string fullPath, string jsonPath);
    internal static Task`1<T> FromResult(T result);
    private static Type TryLoadType(String[] typeNames);
}
internal class NJsonSchema.Infrastructure.IgnoreEmptyCollectionsContractResolver : PropertyRenameAndIgnoreSerializerContractResolver {
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
}
public class NJsonSchema.Infrastructure.JsonSchemaSerialization : object {
    [ThreadStaticAttribute]
private static SchemaType _currentSchemaType;
    [ThreadStaticAttribute]
private static bool _isWriting;
    [ThreadStaticAttribute]
private static JsonSerializerSettings _currentSerializerSettings;
    public static SchemaType CurrentSchemaType { get; private set; }
    public static JsonSerializerSettings CurrentSerializerSettings { get; private set; }
    public static bool IsWriting { get; private set; }
    public static SchemaType get_CurrentSchemaType();
    private static void set_CurrentSchemaType(SchemaType value);
    public static JsonSerializerSettings get_CurrentSerializerSettings();
    private static void set_CurrentSerializerSettings(JsonSerializerSettings value);
    public static bool get_IsWriting();
    private static void set_IsWriting(bool value);
    public static string ToJson(object obj, SchemaType schemaType, IContractResolver contractResolver, Formatting formatting);
    [ObsoleteAttribute("Use FromJsonAsync with cancellation token instead.")]
public static Task`1<T> FromJsonAsync(string json, SchemaType schemaType, string documentPath, Func`2<T, JsonReferenceResolver> referenceResolverFactory, IContractResolver contractResolver);
    public static Task`1<T> FromJsonAsync(string json, SchemaType schemaType, string documentPath, Func`2<T, JsonReferenceResolver> referenceResolverFactory, IContractResolver contractResolver, CancellationToken cancellationToken);
    public static Task`1<T> FromJsonAsync(Stream stream, SchemaType schemaType, string documentPath, Func`2<T, JsonReferenceResolver> referenceResolverFactory, IContractResolver contractResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.Infrastructure.JsonSchemaSerialization/<FromJsonWithLoaderAsync>d__16`1")]
private static Task`1<T> FromJsonWithLoaderAsync(Func`1<T> loader, SchemaType schemaType, string documentPath, Func`2<T, JsonReferenceResolver> referenceResolverFactory, IContractResolver contractResolver, CancellationToken cancellationToken);
    public static T FromJson(string json, IContractResolver contractResolver);
    public static T FromJson(Stream stream, IContractResolver contractResolver);
    private static void UpdateCurrentSerializerSettings(IContractResolver contractResolver);
}
public class NJsonSchema.Infrastructure.PropertyRenameAndIgnoreSerializerContractResolver : DefaultContractResolver {
    private Dictionary`2<string, HashSet`1<string>> _ignores;
    private Dictionary`2<string, Dictionary`2<string, string>> _renames;
    public void IgnoreProperty(Type type, String[] jsonPropertyNames);
    public void RenameProperty(Type type, string propertyName, string newJsonPropertyName);
    protected virtual JsonProperty CreateProperty(MemberInfo member, MemberSerialization memberSerialization);
    private bool IsIgnored(Type type, string jsonPropertyName);
    private bool IsRenamed(Type type, string jsonPropertyName, String& newJsonPropertyName);
}
[ExtensionAttribute]
public static class NJsonSchema.Infrastructure.TypeExtensions : object {
    private static Dictionary`2<ContextualMemberInfo, string> _names;
    private static TypeExtensions();
    [ExtensionAttribute]
internal static string GetName(ContextualAccessorInfo accessorInfo);
    private static string GetNameWithoutCache(ContextualAccessorInfo accessorInfo);
    [ExtensionAttribute]
public static string GetDescription(CachedType type, IXmlDocsSettings xmlDocsSettings);
    [ExtensionAttribute]
public static string GetDescription(ContextualAccessorInfo accessorInfo, IXmlDocsSettings xmlDocsSettings);
    [ExtensionAttribute]
public static string GetDescription(ContextualParameterInfo parameter, IXmlDocsSettings xmlDocsSettings);
    private static string GetDescription(IEnumerable`1<Attribute> attributes);
}
[ExtensionAttribute]
public static class NJsonSchema.Infrastructure.XmlObjectExtension : object {
    [ExtensionAttribute]
public static void GenerateXmlObjectForType(JsonSchema schema, Type type);
    [ExtensionAttribute]
public static void GenerateXmlObjectForArrayType(JsonSchema schema);
    [ExtensionAttribute]
public static void GenerateXmlObjectForItemType(JsonSchema schema, CachedType type);
    [ExtensionAttribute]
public static void GenerateXmlObjectForProperty(JsonSchemaProperty propertySchema, ContextualType type, string propertyName);
    private static void GenerateXmlObject(string name, string namespace, bool wrapped, bool isAttribute, JsonSchema schema);
    private static string GetXmlItemName(Type type);
}
public interface NJsonSchema.ITypeNameGenerator {
    public abstract virtual string Generate(JsonSchema schema, string typeNameHint, IEnumerable`1<string> reservedTypeNames);
}
[JsonConverterAttribute("NJsonSchema.ExtensionDataDeserializationConverter")]
public class NJsonSchema.JsonExtensionObject : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ExtensionData>k__BackingField;
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> ExtensionData { get; public set; }
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ExtensionData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtensionData(IDictionary`2<string, object> value);
}
public static class NJsonSchema.JsonFormatStrings : object {
    public static string DateTime;
    public static string TimeSpan;
    public static string Duration;
    public static string Email;
    public static string Uri;
    public static string Guid;
    [ObsoleteAttribute("Now made redundant. Use "guid" instead.")]
public static string Uuid;
    public static string Integer;
    public static string Long;
    public static string Double;
    public static string Float;
    public static string Decimal;
    public static string IpV4;
    public static string IpV6;
    [ObsoleteAttribute("Now made redundant. Use "byte" instead.")]
public static string Base64;
    public static string Byte;
    public static string Binary;
    public static string Hostname;
    public static string Phone;
    public static string Date;
    public static string Time;
}
[FlagsAttribute]
public enum NJsonSchema.JsonObjectType : Enum {
    public int value__;
    [JsonPropertyAttribute("none")]
public static JsonObjectType None;
    [JsonPropertyAttribute("array")]
public static JsonObjectType Array;
    [JsonPropertyAttribute("boolean")]
public static JsonObjectType Boolean;
    [JsonPropertyAttribute("integer")]
public static JsonObjectType Integer;
    [JsonPropertyAttribute("null")]
public static JsonObjectType Null;
    [JsonPropertyAttribute("number")]
public static JsonObjectType Number;
    [JsonPropertyAttribute("object")]
public static JsonObjectType Object;
    [JsonPropertyAttribute("string")]
public static JsonObjectType String;
    [JsonPropertyAttribute("file")]
public static JsonObjectType File;
}
public static class NJsonSchema.JsonPathUtilities : object {
    public static string GetJsonPath(object rootObject, object searchedObject);
    public static string GetJsonPath(object rootObject, object searchedObject, IContractResolver contractResolver);
    public static IReadOnlyDictionary`2<object, string> GetJsonPaths(object rootObject, IEnumerable`1<object> searchedObjects, IContractResolver contractResolver);
    private static bool FindJsonPaths(object obj, Dictionary`2<object, string> searchedObjects, string basePath, HashSet`1<object> checkedObjects, IContractResolver contractResolver);
}
public class NJsonSchema.JsonReferenceResolver : object {
    private JsonSchemaAppender _schemaAppender;
    private Dictionary`2<string, IJsonReference> _resolvedObjects;
    public JsonReferenceResolver(JsonSchemaAppender schemaAppender);
    public static Func`2<JsonSchema, JsonReferenceResolver> CreateJsonReferenceResolverFactory(ITypeNameGenerator typeNameGenerator);
    public void AddDocumentReference(string documentPath, IJsonReference schema);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveReferenceAsync>d__5")]
public Task`1<IJsonReference> ResolveReferenceAsync(object rootObject, string jsonPath, Type targetType, IContractResolver contractResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveReferenceWithoutAppendAsync>d__6")]
public Task`1<IJsonReference> ResolveReferenceWithoutAppendAsync(object rootObject, string jsonPath, Type targetType, IContractResolver contractResolver, CancellationToken cancellationToken);
    public virtual IJsonReference ResolveDocumentReference(object rootObject, string jsonPath, Type targetType, IContractResolver contractResolver);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveFileReferenceAsync>d__8")]
public virtual Task`1<IJsonReference> ResolveFileReferenceAsync(string filePath, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveUrlReferenceAsync>d__9")]
public virtual Task`1<IJsonReference> ResolveUrlReferenceAsync(string url, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveReferenceAsync>d__10")]
private Task`1<IJsonReference> ResolveReferenceAsync(object rootObject, string jsonPath, Type targetType, IContractResolver contractResolver, bool append, CancellationToken cancellationToken);
    public virtual string ResolveFilePath(string documentPath, string jsonPath);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveFileReferenceWithAlreadyResolvedCheckAsync>d__12")]
private Task`1<IJsonReference> ResolveFileReferenceWithAlreadyResolvedCheckAsync(string filePath, Type targetType, IContractResolver contractResolver, string jsonPath, bool append, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonReferenceResolver/<ResolveUrlReferenceWithAlreadyResolvedCheckAsync>d__13")]
private Task`1<IJsonReference> ResolveUrlReferenceWithAlreadyResolvedCheckAsync(string fullJsonPath, string jsonPath, Type targetType, IContractResolver contractResolver, bool append, CancellationToken cancellationToken);
    private IJsonReference ResolveDocumentReference(object obj, List`1<string> segments, Type targetType, IContractResolver contractResolver, HashSet`1<object> checkedObjects);
    private IJsonReference ResolveDocumentReferenceWithoutDereferencing(object obj, List`1<string> segments, Type targetType, IContractResolver contractResolver, HashSet`1<object> checkedObjects);
    [CompilerGeneratedAttribute]
private JsonReferenceResolver <ResolveFileReferenceAsync>b__8_0(JsonSchema schema);
    [CompilerGeneratedAttribute]
private JsonReferenceResolver <ResolveUrlReferenceAsync>b__9_0(JsonSchema schema);
}
[JsonConverterAttribute("NJsonSchema.ExtensionDataDeserializationConverter")]
public class NJsonSchema.JsonSchema : JsonReferenceBase`1<JsonSchema> {
    internal static HashSet`1<string> JsonSchemaPropertiesCache;
    private static SchemaType SerializationSchemaType;
    private static Lazy`1<PropertyRenameAndIgnoreSerializerContractResolver> ContractResolver;
    private ObservableDictionary`2<string, JsonSchemaProperty> _properties;
    private ObservableDictionary`2<string, JsonSchemaProperty> _patternProperties;
    private ObservableDictionary`2<string, JsonSchema> _definitions;
    internal ObservableCollection`1<JsonSchema> _allOf;
    internal ObservableCollection`1<JsonSchema> _anyOf;
    internal ObservableCollection`1<JsonSchema> _oneOf;
    private JsonSchema _not;
    private JsonSchema _dictionaryKey;
    private JsonObjectType _type;
    private JsonSchema _item;
    internal ObservableCollection`1<JsonSchema> _items;
    private bool _allowAdditionalItems;
    private JsonSchema _additionalItemsSchema;
    private bool _allowAdditionalProperties;
    private JsonSchema _additionalPropertiesSchema;
    private static string version;
    [CompilerGeneratedAttribute]
private string <SchemaVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Default>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <MultipleOf>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <Maximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <ExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExclusiveMaximum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <Minimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<decimal> <ExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExclusiveMinimum>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaxLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinItems>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UniqueItems>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MinProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDeprecated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeprecatedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAbstract>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsNullableRaw>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Example>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFlagEnumerable>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<object> <Enumeration>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <RequiredProperties>k__BackingField;
    [JsonIgnoreAttribute]
private JsonXmlObject _xmlObject;
    private static JsonObjectType[] _jsonObjectTypeValues;
    private NotifyCollectionChangedEventHandler _initializeSchemaCollectionEventHandler;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <ExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private OpenApiDiscriminator <DiscriminatorObject>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <EnumerationNames>k__BackingField;
    private Lazy`1<object> _typeRaw;
    public static string ToolchainVersion { get; }
    [JsonIgnoreAttribute]
public bool IsBinary { get; }
    [JsonIgnoreAttribute]
public JsonSchema InheritedSchema { get; }
    [JsonIgnoreAttribute]
public JsonSchema InheritedTypeSchema { get; }
    [JsonIgnoreAttribute]
public IReadOnlyCollection`1<JsonSchema> AllInheritedSchemas { get; }
    [JsonIgnoreAttribute]
public OpenApiDiscriminator ResponsibleDiscriminatorObject { get; }
    [JsonIgnoreAttribute]
public bool HasActualProperties { get; }
    [JsonIgnoreAttribute]
public IReadOnlyDictionary`2<string, JsonSchemaProperty> ActualProperties { get; }
    [JsonPropertyAttribute("$schema")]
public string SchemaVersion { get; public set; }
    [JsonPropertyAttribute("id")]
public string Id { get; public set; }
    [JsonPropertyAttribute("title")]
public string Title { get; public set; }
    [JsonIgnoreAttribute]
public bool HasTypeNameTitle { get; }
    [JsonPropertyAttribute("description")]
public string Description { get; public set; }
    [JsonIgnoreAttribute]
public JsonObjectType Type { get; public set; }
    [JsonIgnoreAttribute]
public JsonSchema ParentSchema { get; }
    [JsonIgnoreAttribute]
public object Parent { get; public set; }
    [JsonPropertyAttribute("format")]
public string Format { get; public set; }
    [JsonPropertyAttribute("default")]
public object Default { get; public set; }
    [JsonPropertyAttribute("multipleOf")]
public Nullable`1<decimal> MultipleOf { get; public set; }
    [JsonPropertyAttribute("maximum")]
public Nullable`1<decimal> Maximum { get; public set; }
    [JsonIgnoreAttribute]
public Nullable`1<decimal> ExclusiveMaximum { get; public set; }
    [JsonIgnoreAttribute]
public bool IsExclusiveMaximum { get; public set; }
    [JsonPropertyAttribute("minimum")]
public Nullable`1<decimal> Minimum { get; public set; }
    [JsonIgnoreAttribute]
public Nullable`1<decimal> ExclusiveMinimum { get; public set; }
    [JsonIgnoreAttribute]
public bool IsExclusiveMinimum { get; public set; }
    [JsonPropertyAttribute("maxLength")]
public Nullable`1<int> MaxLength { get; public set; }
    [JsonPropertyAttribute("minLength")]
public Nullable`1<int> MinLength { get; public set; }
    [JsonPropertyAttribute("pattern")]
public string Pattern { get; public set; }
    [JsonPropertyAttribute("maxItems")]
public int MaxItems { get; public set; }
    [JsonPropertyAttribute("minItems")]
public int MinItems { get; public set; }
    [JsonPropertyAttribute("uniqueItems")]
public bool UniqueItems { get; public set; }
    [JsonPropertyAttribute("maxProperties")]
public int MaxProperties { get; public set; }
    [JsonPropertyAttribute("minProperties")]
public int MinProperties { get; public set; }
    [JsonPropertyAttribute("x-deprecated")]
public bool IsDeprecated { get; public set; }
    [JsonPropertyAttribute("x-deprecatedMessage")]
public string DeprecatedMessage { get; public set; }
    [JsonPropertyAttribute("x-abstract")]
public bool IsAbstract { get; public set; }
    [JsonPropertyAttribute("x-nullable")]
public Nullable`1<bool> IsNullableRaw { get; public set; }
    [JsonPropertyAttribute("x-example")]
public object Example { get; public set; }
    [JsonPropertyAttribute("x-enumFlags")]
public bool IsFlagEnumerable { get; public set; }
    [JsonIgnoreAttribute]
public ICollection`1<object> Enumeration { get; internal set; }
    [JsonIgnoreAttribute]
public bool IsEnumeration { get; }
    [JsonIgnoreAttribute]
public ICollection`1<string> RequiredProperties { get; internal set; }
    [JsonPropertyAttribute("x-dictionaryKey")]
public JsonSchema DictionaryKey { get; public set; }
    [JsonIgnoreAttribute]
public IDictionary`2<string, JsonSchemaProperty> Properties { get; internal set; }
    [JsonPropertyAttribute("xml")]
public JsonXmlObject Xml { get; public set; }
    [JsonIgnoreAttribute]
public IDictionary`2<string, JsonSchemaProperty> PatternProperties { get; internal set; }
    [JsonIgnoreAttribute]
public JsonSchema Item { get; public set; }
    [JsonIgnoreAttribute]
public ICollection`1<JsonSchema> Items { get; internal set; }
    [JsonPropertyAttribute("not")]
public JsonSchema Not { get; public set; }
    [JsonIgnoreAttribute]
public IDictionary`2<string, JsonSchema> Definitions { get; internal set; }
    [JsonIgnoreAttribute]
public ICollection`1<JsonSchema> AllOf { get; internal set; }
    [JsonIgnoreAttribute]
public ICollection`1<JsonSchema> AnyOf { get; internal set; }
    [JsonIgnoreAttribute]
public ICollection`1<JsonSchema> OneOf { get; internal set; }
    [JsonIgnoreAttribute]
public bool AllowAdditionalItems { get; public set; }
    [JsonIgnoreAttribute]
public JsonSchema AdditionalItemsSchema { get; public set; }
    [JsonIgnoreAttribute]
public bool AllowAdditionalProperties { get; public set; }
    [JsonIgnoreAttribute]
public JsonSchema AdditionalPropertiesSchema { get; public set; }
    [JsonIgnoreAttribute]
public bool IsObject { get; }
    [JsonIgnoreAttribute]
public bool IsArray { get; }
    [JsonIgnoreAttribute]
public bool IsTuple { get; }
    [JsonIgnoreAttribute]
public bool IsDictionary { get; }
    [JsonIgnoreAttribute]
public bool IsAnyType { get; }
    [JsonIgnoreAttribute]
public JsonSchema ActualSchema { get; }
    [JsonIgnoreAttribute]
public JsonSchema ActualTypeSchema { get; }
    [JsonIgnoreAttribute]
public bool HasReference { get; }
    [JsonIgnoreAttribute]
public bool HasAllOfSchemaReference { get; }
    [JsonIgnoreAttribute]
public bool HasOneOfSchemaReference { get; }
    [JsonIgnoreAttribute]
public bool HasAnyOfSchemaReference { get; }
    [JsonIgnoreAttribute]
private IJsonReference NJsonSchema.References.IJsonReference.ActualObject { get; }
    [JsonIgnoreAttribute]
private object NJsonSchema.References.IJsonReference.PossibleRoot { get; }
    [JsonIgnoreAttribute]
public JsonSchema Reference { get; public set; }
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> ExtensionData { get; public set; }
    [JsonIgnoreAttribute]
public string ActualDiscriminator { get; }
    [JsonIgnoreAttribute]
public string Discriminator { get; public set; }
    [JsonIgnoreAttribute]
public OpenApiDiscriminator ActualDiscriminatorObject { get; }
    [JsonIgnoreAttribute]
public OpenApiDiscriminator DiscriminatorObject { get; public set; }
    [JsonPropertyAttribute("discriminator")]
internal object DiscriminatorRaw { get; internal set; }
    [JsonIgnoreAttribute]
public Collection`1<string> EnumerationNames { get; public set; }
    [JsonPropertyAttribute("exclusiveMaximum")]
internal object ExclusiveMaximumRaw { get; internal set; }
    [JsonPropertyAttribute("exclusiveMinimum")]
internal object ExclusiveMinimumRaw { get; internal set; }
    [JsonPropertyAttribute("additionalItems")]
internal object AdditionalItemsRaw { get; internal set; }
    [JsonPropertyAttribute("additionalProperties")]
internal object AdditionalPropertiesRaw { get; internal set; }
    [JsonPropertyAttribute("items")]
internal object ItemsRaw { get; internal set; }
    [JsonPropertyAttribute("type")]
internal object TypeRaw { get; internal set; }
    [JsonPropertyAttribute("required")]
internal ICollection`1<string> RequiredPropertiesRaw { get; internal set; }
    [JsonPropertyAttribute("properties")]
internal IDictionary`2<string, JsonSchemaProperty> PropertiesRaw { get; internal set; }
    [JsonPropertyAttribute("patternProperties")]
internal IDictionary`2<string, JsonSchemaProperty> PatternPropertiesRaw { get; internal set; }
    [JsonPropertyAttribute("definitions")]
internal IDictionary`2<string, JsonSchema> DefinitionsRaw { get; internal set; }
    [JsonPropertyAttribute("x-enumNames")]
internal Collection`1<string> EnumerationNamesRaw { get; internal set; }
    [JsonPropertyAttribute("enum")]
internal ICollection`1<object> EnumerationRaw { get; internal set; }
    [JsonPropertyAttribute("allOf")]
internal ICollection`1<JsonSchema> AllOfRaw { get; internal set; }
    [JsonPropertyAttribute("anyOf")]
internal ICollection`1<JsonSchema> AnyOfRaw { get; internal set; }
    [JsonPropertyAttribute("oneOf")]
internal ICollection`1<JsonSchema> OneOfRaw { get; internal set; }
    private static JsonSchema();
    public static JsonSchema CreateAnySchema();
    public static TSchemaType CreateAnySchema();
    public static string get_ToolchainVersion();
    public static JsonSchema FromType();
    public static JsonSchema FromType(Type type);
    public static JsonSchema FromType(JsonSchemaGeneratorSettings settings);
    public static JsonSchema FromType(Type type, JsonSchemaGeneratorSettings settings);
    public static JsonSchema FromSampleJson(string data);
    public static JsonSchema FromSampleJson(Stream stream);
    public static Task`1<JsonSchema> FromFileAsync(string filePath, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromFileAsync(string filePath, Func`2<JsonSchema, JsonReferenceResolver> referenceResolverFactory, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromUrlAsync(string url, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonSchema/<FromUrlAsync>d__33")]
public static Task`1<JsonSchema> FromUrlAsync(string url, Func`2<JsonSchema, JsonReferenceResolver> referenceResolverFactory, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromJsonAsync(string data, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromJsonAsync(Stream stream, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromJsonAsync(string data, string documentPath, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromJsonAsync(string data, string documentPath, Func`2<JsonSchema, JsonReferenceResolver> referenceResolverFactory, CancellationToken cancellationToken);
    public static Task`1<JsonSchema> FromJsonAsync(Stream stream, string documentPath, Func`2<JsonSchema, JsonReferenceResolver> referenceResolverFactory, CancellationToken cancellationToken);
    internal static JsonSchema FromJsonWithCurrentSettings(object obj);
    public bool get_IsBinary();
    public JsonSchema get_InheritedSchema();
    public JsonSchema get_InheritedTypeSchema();
    public IReadOnlyCollection`1<JsonSchema> get_AllInheritedSchemas();
    public bool Inherits(JsonSchema schema);
    public OpenApiDiscriminator get_ResponsibleDiscriminatorObject();
    public bool get_HasActualProperties();
    public IReadOnlyDictionary`2<string, JsonSchemaProperty> get_ActualProperties();
    [CompilerGeneratedAttribute]
public string get_SchemaVersion();
    [CompilerGeneratedAttribute]
public void set_SchemaVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    public bool get_HasTypeNameTitle();
    [CompilerGeneratedAttribute]
public virtual string get_Description();
    [CompilerGeneratedAttribute]
public virtual void set_Description(string value);
    public JsonObjectType get_Type();
    public void set_Type(JsonObjectType value);
    public JsonSchema get_ParentSchema();
    [CompilerGeneratedAttribute]
public virtual object get_Parent();
    [CompilerGeneratedAttribute]
public virtual void set_Parent(object value);
    [CompilerGeneratedAttribute]
public string get_Format();
    [CompilerGeneratedAttribute]
public void set_Format(string value);
    [CompilerGeneratedAttribute]
public object get_Default();
    [CompilerGeneratedAttribute]
public void set_Default(object value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_MultipleOf();
    [CompilerGeneratedAttribute]
public void set_MultipleOf(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_Maximum();
    [CompilerGeneratedAttribute]
public void set_Maximum(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_ExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMaximum(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public bool get_IsExclusiveMaximum();
    [CompilerGeneratedAttribute]
public void set_IsExclusiveMaximum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_Minimum();
    [CompilerGeneratedAttribute]
public void set_Minimum(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public Nullable`1<decimal> get_ExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_ExclusiveMinimum(Nullable`1<decimal> value);
    [CompilerGeneratedAttribute]
public bool get_IsExclusiveMinimum();
    [CompilerGeneratedAttribute]
public void set_IsExclusiveMinimum(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaxLength();
    [CompilerGeneratedAttribute]
public void set_MaxLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MinLength();
    [CompilerGeneratedAttribute]
public void set_MinLength(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public string get_Pattern();
    [CompilerGeneratedAttribute]
public void set_Pattern(string value);
    [CompilerGeneratedAttribute]
public int get_MaxItems();
    [CompilerGeneratedAttribute]
public void set_MaxItems(int value);
    [CompilerGeneratedAttribute]
public int get_MinItems();
    [CompilerGeneratedAttribute]
public void set_MinItems(int value);
    [CompilerGeneratedAttribute]
public bool get_UniqueItems();
    [CompilerGeneratedAttribute]
public void set_UniqueItems(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxProperties();
    [CompilerGeneratedAttribute]
public void set_MaxProperties(int value);
    [CompilerGeneratedAttribute]
public int get_MinProperties();
    [CompilerGeneratedAttribute]
public void set_MinProperties(int value);
    [CompilerGeneratedAttribute]
public bool get_IsDeprecated();
    [CompilerGeneratedAttribute]
public void set_IsDeprecated(bool value);
    [CompilerGeneratedAttribute]
public string get_DeprecatedMessage();
    [CompilerGeneratedAttribute]
public void set_DeprecatedMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAbstract();
    [CompilerGeneratedAttribute]
public void set_IsAbstract(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsNullableRaw();
    [CompilerGeneratedAttribute]
public void set_IsNullableRaw(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public object get_Example();
    [CompilerGeneratedAttribute]
public void set_Example(object value);
    [CompilerGeneratedAttribute]
public bool get_IsFlagEnumerable();
    [CompilerGeneratedAttribute]
public void set_IsFlagEnumerable(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<object> get_Enumeration();
    [CompilerGeneratedAttribute]
internal void set_Enumeration(ICollection`1<object> value);
    public bool get_IsEnumeration();
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_RequiredProperties();
    [CompilerGeneratedAttribute]
internal void set_RequiredProperties(ICollection`1<string> value);
    public JsonSchema get_DictionaryKey();
    public void set_DictionaryKey(JsonSchema value);
    public IDictionary`2<string, JsonSchemaProperty> get_Properties();
    internal void set_Properties(IDictionary`2<string, JsonSchemaProperty> value);
    public JsonXmlObject get_Xml();
    public void set_Xml(JsonXmlObject value);
    public IDictionary`2<string, JsonSchemaProperty> get_PatternProperties();
    internal void set_PatternProperties(IDictionary`2<string, JsonSchemaProperty> value);
    public JsonSchema get_Item();
    public void set_Item(JsonSchema value);
    public ICollection`1<JsonSchema> get_Items();
    internal void set_Items(ICollection`1<JsonSchema> value);
    public JsonSchema get_Not();
    public void set_Not(JsonSchema value);
    public IDictionary`2<string, JsonSchema> get_Definitions();
    internal void set_Definitions(IDictionary`2<string, JsonSchema> value);
    public ICollection`1<JsonSchema> get_AllOf();
    internal void set_AllOf(ICollection`1<JsonSchema> value);
    public ICollection`1<JsonSchema> get_AnyOf();
    internal void set_AnyOf(ICollection`1<JsonSchema> value);
    public ICollection`1<JsonSchema> get_OneOf();
    internal void set_OneOf(ICollection`1<JsonSchema> value);
    public bool get_AllowAdditionalItems();
    public void set_AllowAdditionalItems(bool value);
    public JsonSchema get_AdditionalItemsSchema();
    public void set_AdditionalItemsSchema(JsonSchema value);
    public bool get_AllowAdditionalProperties();
    public void set_AllowAdditionalProperties(bool value);
    public JsonSchema get_AdditionalPropertiesSchema();
    public void set_AdditionalPropertiesSchema(JsonSchema value);
    public bool get_IsObject();
    public bool get_IsArray();
    public bool get_IsTuple();
    public bool get_IsDictionary();
    public bool get_IsAnyType();
    public virtual bool IsNullable(SchemaType schemaType);
    public string ToJson();
    public string ToJson(Formatting formatting);
    public JToken ToSampleJson();
    public bool InheritsSchema(JsonSchema parentSchema);
    public ICollection`1<ValidationError> Validate(string jsonData, JsonSchemaValidatorSettings settings);
    public ICollection`1<ValidationError> Validate(JToken token, JsonSchemaValidatorSettings settings);
    public ICollection`1<ValidationError> Validate(string jsonData, SchemaType schemaType, JsonSchemaValidatorSettings settings);
    public ICollection`1<ValidationError> Validate(JToken token, SchemaType schemaType, JsonSchemaValidatorSettings settings);
    private static JsonObjectType ConvertStringToJsonObjectType(string value);
    private void Initialize();
    private static ObservableCollection`1<T> ToObservableCollection(ICollection`1<T> value);
    private static ObservableDictionary`2<string, T> ToObservableDictionary(IDictionary`2<string, T> value);
    public virtual JsonSchema get_ActualSchema();
    public virtual JsonSchema get_ActualTypeSchema();
    public bool get_HasReference();
    public bool get_HasAllOfSchemaReference();
    public bool get_HasOneOfSchemaReference();
    public bool get_HasAnyOfSchemaReference();
    private JsonSchema GetActualSchema(List`1<JsonSchema> checkedSchemas);
    private JsonSchema GetActualSchemaReferences(List`1<JsonSchema> checkedSchemas);
    private sealed virtual override IJsonReference NJsonSchema.References.IJsonReference.get_ActualObject();
    private sealed virtual override object NJsonSchema.References.IJsonReference.get_PossibleRoot();
    public virtual JsonSchema get_Reference();
    public virtual void set_Reference(JsonSchema value);
    public static PropertyRenameAndIgnoreSerializerContractResolver CreateJsonSerializerContractResolver(SchemaType schemaType);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, object> get_ExtensionData();
    [CompilerGeneratedAttribute]
public sealed virtual void set_ExtensionData(IDictionary`2<string, object> value);
    [OnDeserializedAttribute]
internal void OnDeserialized(StreamingContext ctx);
    public string get_ActualDiscriminator();
    public string get_Discriminator();
    public void set_Discriminator(string value);
    public OpenApiDiscriminator get_ActualDiscriminatorObject();
    [CompilerGeneratedAttribute]
public OpenApiDiscriminator get_DiscriminatorObject();
    [CompilerGeneratedAttribute]
public void set_DiscriminatorObject(OpenApiDiscriminator value);
    internal object get_DiscriminatorRaw();
    internal void set_DiscriminatorRaw(object value);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_EnumerationNames();
    [CompilerGeneratedAttribute]
public void set_EnumerationNames(Collection`1<string> value);
    internal object get_ExclusiveMaximumRaw();
    internal void set_ExclusiveMaximumRaw(object value);
    internal object get_ExclusiveMinimumRaw();
    internal void set_ExclusiveMinimumRaw(object value);
    internal object get_AdditionalItemsRaw();
    internal void set_AdditionalItemsRaw(object value);
    internal object get_AdditionalPropertiesRaw();
    internal void set_AdditionalPropertiesRaw(object value);
    internal object get_ItemsRaw();
    internal void set_ItemsRaw(object value);
    internal object get_TypeRaw();
    internal void set_TypeRaw(object value);
    private void ResetTypeRaw();
    internal ICollection`1<string> get_RequiredPropertiesRaw();
    internal void set_RequiredPropertiesRaw(ICollection`1<string> value);
    internal IDictionary`2<string, JsonSchemaProperty> get_PropertiesRaw();
    internal void set_PropertiesRaw(IDictionary`2<string, JsonSchemaProperty> value);
    internal IDictionary`2<string, JsonSchemaProperty> get_PatternPropertiesRaw();
    internal void set_PatternPropertiesRaw(IDictionary`2<string, JsonSchemaProperty> value);
    internal IDictionary`2<string, JsonSchema> get_DefinitionsRaw();
    internal void set_DefinitionsRaw(IDictionary`2<string, JsonSchema> value);
    internal Collection`1<string> get_EnumerationNamesRaw();
    internal void set_EnumerationNamesRaw(Collection`1<string> value);
    internal ICollection`1<object> get_EnumerationRaw();
    internal void set_EnumerationRaw(ICollection`1<object> value);
    internal ICollection`1<JsonSchema> get_AllOfRaw();
    internal void set_AllOfRaw(ICollection`1<JsonSchema> value);
    internal ICollection`1<JsonSchema> get_AnyOfRaw();
    internal void set_AnyOfRaw(ICollection`1<JsonSchema> value);
    internal ICollection`1<JsonSchema> get_OneOfRaw();
    internal void set_OneOfRaw(ICollection`1<JsonSchema> value);
    private void RegisterProperties(ObservableDictionary`2<string, JsonSchemaProperty> oldCollection, ObservableDictionary`2<string, JsonSchemaProperty> newCollection);
    private void RegisterSchemaDictionary(ObservableDictionary`2<string, T> oldCollection, ObservableDictionary`2<string, T> newCollection);
    private void RegisterSchemaCollection(ObservableCollection`1<JsonSchema> oldCollection, ObservableCollection`1<JsonSchema> newCollection);
    private void InitializeSchemaCollection(object sender, NotifyCollectionChangedEventArgs e);
    [CompilerGeneratedAttribute]
private bool <get_ActualProperties>b__54_0(JsonSchema s);
    [CompilerGeneratedAttribute]
internal static void <GetActualSchema>g__ThrowInvalidOperationException|265_0(string message);
    [CompilerGeneratedAttribute]
private object <ResetTypeRaw>b__319_0();
    [CompilerGeneratedAttribute]
private bool <ResetTypeRaw>b__319_1(JsonObjectType v);
}
public class NJsonSchema.JsonSchemaAppender : object {
    private ITypeNameGenerator _typeNameGenerator;
    [CompilerGeneratedAttribute]
private object <RootObject>k__BackingField;
    public object RootObject { get; }
    protected JsonSchema RootSchema { get; }
    public JsonSchemaAppender(object rootObject, ITypeNameGenerator typeNameGenerator);
    [CompilerGeneratedAttribute]
public object get_RootObject();
    protected JsonSchema get_RootSchema();
    public virtual void AppendSchema(JsonSchema schema, string typeNameHint);
}
public class NJsonSchema.JsonSchemaProperty : JsonSchema {
    private object _parent;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InitialIsRequired>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWriteOnly>k__BackingField;
    [JsonIgnoreAttribute]
public string Name { get; internal set; }
    [JsonIgnoreAttribute]
public object Parent { get; public set; }
    [JsonIgnoreAttribute]
public bool IsRequired { get; public set; }
    [JsonIgnoreAttribute]
internal bool InitialIsRequired { get; internal set; }
    [DefaultValueAttribute("False")]
[JsonPropertyAttribute("x-readOnly")]
public bool IsReadOnly { get; public set; }
    [DefaultValueAttribute("False")]
[JsonPropertyAttribute("x-writeOnly")]
public bool IsWriteOnly { get; public set; }
    [JsonIgnoreAttribute]
public bool IsInheritanceDiscriminator { get; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    public virtual object get_Parent();
    public virtual void set_Parent(object value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    [CompilerGeneratedAttribute]
internal bool get_InitialIsRequired();
    [CompilerGeneratedAttribute]
internal void set_InitialIsRequired(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadOnly();
    [CompilerGeneratedAttribute]
public void set_IsReadOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsWriteOnly();
    [CompilerGeneratedAttribute]
public void set_IsWriteOnly(bool value);
    public bool get_IsInheritanceDiscriminator();
    public virtual bool IsNullable(SchemaType schemaType);
}
public static class NJsonSchema.JsonSchemaReferenceUtilities : object {
    public static Task UpdateSchemaReferencesAsync(object rootObject, JsonReferenceResolver referenceResolver, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.JsonSchemaReferenceUtilities/<UpdateSchemaReferencesAsync>d__1")]
public static Task UpdateSchemaReferencesAsync(object rootObject, JsonReferenceResolver referenceResolver, IContractResolver contractResolver, CancellationToken cancellationToken);
    public static void UpdateSchemaReferencePaths(object rootObject);
    public static void UpdateSchemaReferencePaths(object rootObject, bool removeExternalReferences, IContractResolver contractResolver);
}
public class NJsonSchema.JsonXmlObject : object {
    [CompilerGeneratedAttribute]
private JsonSchema <ParentSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Wrapped>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Namespace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Attribute>k__BackingField;
    [JsonIgnoreAttribute]
public JsonSchema ParentSchema { get; internal set; }
    [JsonPropertyAttribute("name")]
public string Name { get; internal set; }
    [JsonPropertyAttribute("wrapped")]
public bool Wrapped { get; internal set; }
    [JsonPropertyAttribute("namespace")]
public string Namespace { get; internal set; }
    [JsonPropertyAttribute("prefix")]
public string Prefix { get; internal set; }
    [JsonPropertyAttribute("attribute")]
public bool Attribute { get; internal set; }
    [CompilerGeneratedAttribute]
public JsonSchema get_ParentSchema();
    [CompilerGeneratedAttribute]
internal void set_ParentSchema(JsonSchema value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Wrapped();
    [CompilerGeneratedAttribute]
internal void set_Wrapped(bool value);
    [CompilerGeneratedAttribute]
public string get_Namespace();
    [CompilerGeneratedAttribute]
internal void set_Namespace(string value);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
internal void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public bool get_Attribute();
    [CompilerGeneratedAttribute]
internal void set_Attribute(bool value);
}
[ExtensionAttribute]
internal static class NJsonSchema.ObservableCollectionExtensions : object {
    [ExtensionAttribute]
public static int Count(ObservableCollection`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T ElementAt(ObservableCollection`1<T> collection, int index);
    [ExtensionAttribute]
public static T First(ObservableCollection`1<T> collection);
    [ExtensionAttribute]
public static T First(ObservableCollection`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FirstOrDefault(ObservableCollection`1<T> collection, Func`2<T, bool> predicate);
    [ExtensionAttribute]
public static T FirstOrDefault(ObservableCollection`1<T> collection);
    [ExtensionAttribute]
public static bool Any(ObservableCollection`1<T> collection);
    [ExtensionAttribute]
public static bool Any(ObservableCollection`1<T> collection, Func`2<T, bool> predicate);
    private static void ThrowNoMatchingElement();
}
public class NJsonSchema.OpenApiDiscriminator : object {
    [CompilerGeneratedAttribute]
private string <PropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonSchema> <Mapping>k__BackingField;
    [CompilerGeneratedAttribute]
private object <JsonInheritanceConverter>k__BackingField;
    [JsonPropertyAttribute("propertyName")]
public string PropertyName { get; public set; }
    [JsonPropertyAttribute("mapping")]
[JsonConverterAttribute("NJsonSchema.OpenApiDiscriminator/DiscriminatorMappingConverter")]
public IDictionary`2<string, JsonSchema> Mapping { get; }
    [JsonIgnoreAttribute]
public object JsonInheritanceConverter { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PropertyName();
    [CompilerGeneratedAttribute]
public void set_PropertyName(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonSchema> get_Mapping();
    [CompilerGeneratedAttribute]
public object get_JsonInheritanceConverter();
    [CompilerGeneratedAttribute]
public void set_JsonInheritanceConverter(object value);
    public void AddMapping(Type type, JsonSchema schema);
}
public interface NJsonSchema.References.IJsonReference {
    [JsonIgnoreAttribute]
public IJsonReference ActualObject { get; }
    [JsonIgnoreAttribute]
public object PossibleRoot { get; }
    public abstract virtual IJsonReference get_ActualObject();
    public abstract virtual object get_PossibleRoot();
}
public interface NJsonSchema.References.IJsonReferenceBase {
    [JsonPropertyAttribute("$ref")]
public string ReferencePath { get; public set; }
    [JsonIgnoreAttribute]
public IJsonReference Reference { get; public set; }
    public abstract virtual string get_ReferencePath();
    public abstract virtual void set_ReferencePath(string value);
    public abstract virtual IJsonReference get_Reference();
    public abstract virtual void set_Reference(IJsonReference value);
}
public abstract class NJsonSchema.References.JsonReferenceBase`1 : object {
    private T _reference;
    [CompilerGeneratedAttribute]
private string <DocumentPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <NJsonSchema.References.IJsonReferenceBase.ReferencePath>k__BackingField;
    [JsonIgnoreAttribute]
public string DocumentPath { get; public set; }
    [JsonPropertyAttribute("$ref")]
private string NJsonSchema.References.IJsonReferenceBase.ReferencePath { get; private set; }
    [JsonIgnoreAttribute]
public T Reference { get; public set; }
    [JsonIgnoreAttribute]
private IJsonReference NJsonSchema.References.IJsonReferenceBase.Reference { get; private set; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_DocumentPath();
    [CompilerGeneratedAttribute]
public sealed virtual void set_DocumentPath(string value);
    [CompilerGeneratedAttribute]
private sealed virtual override string NJsonSchema.References.IJsonReferenceBase.get_ReferencePath();
    [CompilerGeneratedAttribute]
private sealed virtual override void NJsonSchema.References.IJsonReferenceBase.set_ReferencePath(string value);
    public virtual T get_Reference();
    public virtual void set_Reference(T value);
    private sealed virtual override IJsonReference NJsonSchema.References.IJsonReferenceBase.get_Reference();
    private sealed virtual override void NJsonSchema.References.IJsonReferenceBase.set_Reference(IJsonReference value);
}
[ExtensionAttribute]
public static class NJsonSchema.References.JsonReferenceExtensions : object {
    [ExtensionAttribute]
public static object FindParentDocument(IJsonReference obj);
}
public enum NJsonSchema.SchemaType : Enum {
    public int value__;
    public static SchemaType JsonSchema;
    public static SchemaType Swagger2;
    public static SchemaType OpenApi3;
}
public class NJsonSchema.Validation.ChildSchemaValidationError : ValidationError {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<JsonSchema, ICollection`1<ValidationError>> <Errors>k__BackingField;
    public IReadOnlyDictionary`2<JsonSchema, ICollection`1<ValidationError>> Errors { get; private set; }
    public ChildSchemaValidationError(ValidationErrorKind kind, string property, string path, IReadOnlyDictionary`2<JsonSchema, ICollection`1<ValidationError>> errors, JToken token, JsonSchema schema);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<JsonSchema, ICollection`1<ValidationError>> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IReadOnlyDictionary`2<JsonSchema, ICollection`1<ValidationError>> value);
    public virtual string ToString();
}
public class NJsonSchema.Validation.FormatValidators.Base64FormatValidator : object {
    private ByteFormatValidator _byteFormatValidator;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.ByteFormatValidator : object {
    private static string Base64Expression;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.DateFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
}
public class NJsonSchema.Validation.FormatValidators.DateTimeFormatValidator : object {
    private String[] _acceptableFormats;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.EmailFormatValidator : object {
    private static string EmailRegexExpression;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.GuidFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.HostnameFormatValidator : object {
    private static string HostnameExpression;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public interface NJsonSchema.Validation.FormatValidators.IFormatValidator {
    public ValidationErrorKind ValidationErrorKind { get; }
    public string Format { get; }
    public abstract virtual bool IsValid(string value, JTokenType tokenType);
    public abstract virtual ValidationErrorKind get_ValidationErrorKind();
    public abstract virtual string get_Format();
}
public class NJsonSchema.Validation.FormatValidators.IpV4FormatValidator : object {
    private static string IpV4RegexExpression;
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.IpV6FormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.TimeFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.TimeSpanFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.UriFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.FormatValidators.UuidFormatValidator : object {
    [CompilerGeneratedAttribute]
private string <Format>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationErrorKind <ValidationErrorKind>k__BackingField;
    public string Format { get; }
    public ValidationErrorKind ValidationErrorKind { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_Format();
    [CompilerGeneratedAttribute]
public sealed virtual ValidationErrorKind get_ValidationErrorKind();
    public sealed virtual bool IsValid(string value, JTokenType tokenType);
}
public class NJsonSchema.Validation.JsonSchemaValidator : object {
    private IDictionary`2<string, IFormatValidator[]> _formatValidatorsMap;
    private JsonSchemaValidatorSettings _settings;
    private static IEnumerable`1<JsonObjectType> JsonObjectTypes;
    public JsonSchemaValidator(IFormatValidator[] customValidators);
    public JsonSchemaValidator(JsonSchemaValidatorSettings settings);
    private static JsonSchemaValidator();
    public ICollection`1<ValidationError> Validate(string jsonData, JsonSchema schema, SchemaType schemaType);
    public ICollection`1<ValidationError> Validate(JToken token, JsonSchema schema, SchemaType schemaType);
    protected virtual ICollection`1<ValidationError> Validate(JToken token, JsonSchema schema, SchemaType schemaType, string propertyName, string propertyPath);
    private void ValidateType(JToken token, JsonSchema schema, SchemaType schemaType, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private IEnumerable`1<JsonObjectType> GetTypes(JsonSchema schema);
    private void ValidateAnyOf(JToken token, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateAllOf(JToken token, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateOneOf(JToken token, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateNot(JToken token, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateNull(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateEnum(JToken token, JsonSchema schema, SchemaType schemaType, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateString(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateNumber(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateInteger(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateBoolean(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateObject(JToken token, JsonSchema schema, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateProperties(JToken token, JsonSchema schema, SchemaType schemaType, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private string GetPropertyPath(string propertyPath, string propertyName);
    private void ValidateMaxProperties(JToken token, IList`1<JProperty> properties, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateMinProperties(JToken token, IList`1<JProperty> properties, JsonSchema schema, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidatePatternProperties(List`1<JProperty> additionalProperties, JsonSchema schema, SchemaType schemaType, List`1<ValidationError> errors);
    private void ValidateAdditionalProperties(JToken token, List`1<JProperty> additionalProperties, JsonSchema schema, SchemaType schemaType, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateArray(JToken token, JsonSchema schema, SchemaType schemaType, JsonObjectType type, string propertyName, string propertyPath, List`1<ValidationError> errors);
    private void ValidateAdditionalItems(JToken item, JsonSchema schema, SchemaType schemaType, int index, string propertyPath, List`1<ValidationError> errors);
    private ChildSchemaValidationError TryCreateChildSchemaError(JToken token, JsonSchema schema, SchemaType schemaType, ValidationErrorKind errorKind, string property, string path);
    private bool TryGetPropertyWithStringComparer(JObject obj, string propertyName, StringComparer comparer, JToken& value);
}
public class NJsonSchema.Validation.JsonSchemaValidatorSettings : object {
    private StringComparer _propertyStringComparer;
    [CompilerGeneratedAttribute]
private IEnumerable`1<IFormatValidator> <FormatValidators>k__BackingField;
    public StringComparer PropertyStringComparer { get; public set; }
    public IEnumerable`1<IFormatValidator> FormatValidators { get; public set; }
    public StringComparer get_PropertyStringComparer();
    public void set_PropertyStringComparer(StringComparer value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<IFormatValidator> get_FormatValidators();
    [CompilerGeneratedAttribute]
public void set_FormatValidators(IEnumerable`1<IFormatValidator> value);
    public void AddCustomFormatValidator(IFormatValidator formatValidator);
}
public class NJsonSchema.Validation.MultiTypeValidationError : ValidationError {
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<JsonObjectType, ICollection`1<ValidationError>> <Errors>k__BackingField;
    public IReadOnlyDictionary`2<JsonObjectType, ICollection`1<ValidationError>> Errors { get; private set; }
    public MultiTypeValidationError(ValidationErrorKind kind, string property, string path, IReadOnlyDictionary`2<JsonObjectType, ICollection`1<ValidationError>> errors, JToken token, JsonSchema schema);
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<JsonObjectType, ICollection`1<ValidationError>> get_Errors();
    [CompilerGeneratedAttribute]
private void set_Errors(IReadOnlyDictionary`2<JsonObjectType, ICollection`1<ValidationError>> value);
    public virtual string ToString();
}
public class NJsonSchema.Validation.ValidationError : object {
    [CompilerGeneratedAttribute]
private ValidationErrorKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLineInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private JsonSchema <Schema>k__BackingField;
    public ValidationErrorKind Kind { get; private set; }
    public string Property { get; private set; }
    public string Path { get; private set; }
    public bool HasLineInfo { get; private set; }
    public int LineNumber { get; private set; }
    public int LinePosition { get; private set; }
    public JsonSchema Schema { get; private set; }
    public ValidationError(ValidationErrorKind errorKind, string propertyName, string propertyPath, JToken token, JsonSchema schema);
    [CompilerGeneratedAttribute]
public ValidationErrorKind get_Kind();
    [CompilerGeneratedAttribute]
private void set_Kind(ValidationErrorKind value);
    [CompilerGeneratedAttribute]
public string get_Property();
    [CompilerGeneratedAttribute]
private void set_Property(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public bool get_HasLineInfo();
    [CompilerGeneratedAttribute]
private void set_HasLineInfo(bool value);
    [CompilerGeneratedAttribute]
public int get_LineNumber();
    [CompilerGeneratedAttribute]
private void set_LineNumber(int value);
    [CompilerGeneratedAttribute]
public int get_LinePosition();
    [CompilerGeneratedAttribute]
private void set_LinePosition(int value);
    [CompilerGeneratedAttribute]
public JsonSchema get_Schema();
    [CompilerGeneratedAttribute]
private void set_Schema(JsonSchema value);
    public virtual string ToString();
}
public enum NJsonSchema.Validation.ValidationErrorKind : Enum {
    public int value__;
    public static ValidationErrorKind Unknown;
    public static ValidationErrorKind StringExpected;
    public static ValidationErrorKind NumberExpected;
    public static ValidationErrorKind IntegerExpected;
    public static ValidationErrorKind BooleanExpected;
    public static ValidationErrorKind ObjectExpected;
    public static ValidationErrorKind PropertyRequired;
    public static ValidationErrorKind ArrayExpected;
    public static ValidationErrorKind NullExpected;
    public static ValidationErrorKind PatternMismatch;
    public static ValidationErrorKind StringTooShort;
    public static ValidationErrorKind StringTooLong;
    public static ValidationErrorKind NumberTooSmall;
    public static ValidationErrorKind NumberTooBig;
    public static ValidationErrorKind IntegerTooBig;
    public static ValidationErrorKind TooManyItems;
    public static ValidationErrorKind TooFewItems;
    public static ValidationErrorKind ItemsNotUnique;
    public static ValidationErrorKind DateTimeExpected;
    public static ValidationErrorKind DateExpected;
    public static ValidationErrorKind TimeExpected;
    public static ValidationErrorKind TimeSpanExpected;
    public static ValidationErrorKind UriExpected;
    public static ValidationErrorKind IpV4Expected;
    public static ValidationErrorKind IpV6Expected;
    public static ValidationErrorKind GuidExpected;
    public static ValidationErrorKind NotAnyOf;
    public static ValidationErrorKind NotAllOf;
    public static ValidationErrorKind NotOneOf;
    public static ValidationErrorKind ExcludedSchemaValidates;
    public static ValidationErrorKind NumberNotMultipleOf;
    public static ValidationErrorKind IntegerNotMultipleOf;
    public static ValidationErrorKind NotInEnumeration;
    public static ValidationErrorKind EmailExpected;
    public static ValidationErrorKind HostnameExpected;
    public static ValidationErrorKind TooManyItemsInTuple;
    public static ValidationErrorKind ArrayItemNotValid;
    public static ValidationErrorKind AdditionalItemNotValid;
    public static ValidationErrorKind AdditionalPropertiesNotValid;
    public static ValidationErrorKind NoAdditionalPropertiesAllowed;
    public static ValidationErrorKind TooManyProperties;
    public static ValidationErrorKind TooFewProperties;
    public static ValidationErrorKind Base64Expected;
    public static ValidationErrorKind NoTypeValidates;
    public static ValidationErrorKind UuidExpected;
}
public abstract class NJsonSchema.Visitors.AsyncJsonReferenceVisitorBase : object {
    private IContractResolver _contractResolver;
    protected AsyncJsonReferenceVisitorBase(IContractResolver contractResolver);
    [AsyncStateMachineAttribute("NJsonSchema.Visitors.AsyncJsonReferenceVisitorBase/<VisitAsync>d__3")]
[ObsoleteAttribute("VisitAsync is deprecated, please use VisitAsync with cancellation token insteaed.")]
public virtual Task VisitAsync(object obj);
    [AsyncStateMachineAttribute("NJsonSchema.Visitors.AsyncJsonReferenceVisitorBase/<VisitAsync>d__4")]
public virtual Task VisitAsync(object obj, CancellationToken cancellationToken);
    protected abstract virtual Task`1<IJsonReference> VisitJsonReferenceAsync(IJsonReference reference, string path, string typeNameHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.Visitors.AsyncJsonReferenceVisitorBase/<VisitAsync>d__6")]
protected virtual Task VisitAsync(object obj, string path, string typeNameHint, ISet`1<object> checkedObjects, Action`1<object> replacer, CancellationToken cancellationToken);
    private static void ReplaceOrDelete(ObservableCollection`1<T> collection, int index, T obj);
    private static void ReplaceOrDelete(IList collection, int index, object obj);
}
public abstract class NJsonSchema.Visitors.AsyncJsonSchemaVisitorBase : AsyncJsonReferenceVisitorBase {
    protected abstract virtual Task`1<JsonSchema> VisitSchemaAsync(JsonSchema schema, string path, string typeNameHint, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NJsonSchema.Visitors.AsyncJsonSchemaVisitorBase/<VisitJsonReferenceAsync>d__1")]
protected virtual Task`1<IJsonReference> VisitJsonReferenceAsync(IJsonReference reference, string path, string typeNameHint, CancellationToken cancellationToken);
}
public abstract class NJsonSchema.Visitors.JsonReferenceVisitorBase : object {
    private IContractResolver _contractResolver;
    protected JsonReferenceVisitorBase(IContractResolver contractResolver);
    public virtual void Visit(object obj);
    protected abstract virtual IJsonReference VisitJsonReference(IJsonReference reference, string path, string typeNameHint);
    protected virtual void Visit(object obj, string path, string typeNameHint, ISet`1<object> checkedObjects, Action`1<object> replacer);
    private static void ReplaceOrDelete(ObservableCollection`1<T> collection, int index, T obj);
    private static void ReplaceOrDelete(IList collection, int index, object obj);
}
public abstract class NJsonSchema.Visitors.JsonSchemaVisitorBase : JsonReferenceVisitorBase {
    protected abstract virtual JsonSchema VisitSchema(JsonSchema schema, string path, string typeNameHint);
    protected virtual IJsonReference VisitJsonReference(IJsonReference reference, string path, string typeNameHint);
}
