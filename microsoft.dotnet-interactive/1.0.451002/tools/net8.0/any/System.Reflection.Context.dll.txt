internal static class FxResources.System.Reflection.Context.SR : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal static class System.Reflection.Context.CollectionServices : object {
    public static T[] Empty();
    public static bool CompareArrays(T[] left, T[] right);
    public static int GetArrayHashCode(T[] array);
    public static Object[] ConvertListToArray(List`1<object> list, Type arrayType);
    public static Object[] IEnumerableToArray(IEnumerable`1<object> enumerable, Type arrayType);
}
internal static class System.Reflection.Context.Custom.AttributeUtils : object {
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomType type, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomMethodInfo method, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomConstructorInfo constructor, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomPropertyInfo property, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomEventInfo evnt, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomFieldInfo field, Type attributeFilterType, bool inherit);
    public static Object[] GetCustomAttributes(CustomReflectionContext context, CustomParameterInfo parameter, Type attributeFilterType, bool inherit);
    public static bool IsDefined(ICustomAttributeProvider provider, Type attributeType, bool inherit);
    private static IEnumerable`1<object> GetFilteredAttributes(CustomReflectionContext context, MemberInfo member, Type attributeFilterType);
    private static IEnumerable`1<object> GetFilteredAttributes(CustomReflectionContext context, ParameterInfo parameter, Type attributeFilterType);
    private static void CombineCustomAttributes(List`1<object> declaredAttributes, IEnumerable`1<object> inheritedAttributes, Type attributeFilterType, bool inherited, bool allowMultiple);
    private static void GetAttributeUsage(Type attributeFilterType, Boolean& inherited, Boolean& allowMultiple);
    [IteratorStateMachineAttribute("System.Reflection.Context.Custom.AttributeUtils/<FilterCustomAttributes>d__12")]
internal static IEnumerable`1<object> FilterCustomAttributes(IEnumerable`1<object> attributes, Type attributeFilterType);
}
internal class System.Reflection.Context.Custom.CustomAssembly : ProjectingAssembly {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomAssembly(Assembly template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
}
internal class System.Reflection.Context.Custom.CustomConstructorInfo : ProjectingConstructorInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomConstructorInfo(ConstructorInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomEventInfo : ProjectingEventInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomEventInfo(EventInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomFieldInfo : ProjectingFieldInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomFieldInfo(FieldInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomMethodInfo : ProjectingMethodInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomMethodInfo(MethodInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomModule : ProjectingModule {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomModule(Module template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
}
internal class System.Reflection.Context.Custom.CustomParameterInfo : ProjectingParameterInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomParameterInfo(ParameterInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomPropertyInfo : ProjectingPropertyInfo {
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public CustomPropertyInfo(PropertyInfo template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.Context.Custom.CustomType : ProjectingType {
    private IEnumerable`1<PropertyInfo> _newProperties;
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    private IEnumerable`1<PropertyInfo> NewProperties { get; }
    public CustomType(Type template, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsInstanceOfType(object o);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    private IEnumerable`1<PropertyInfo> get_NewProperties();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Context.CustomReflectionContext : ReflectionContext {
    private ReflectionContextProjector _projector;
    [CompilerGeneratedAttribute]
private ReflectionContext <SourceContext>k__BackingField;
    internal Projector Projector { get; }
    internal ReflectionContext SourceContext { get; }
    protected CustomReflectionContext(ReflectionContext source);
    public virtual Assembly MapAssembly(Assembly assembly);
    public virtual TypeInfo MapType(TypeInfo type);
    protected virtual IEnumerable`1<object> GetCustomAttributes(MemberInfo member, IEnumerable`1<object> declaredAttributes);
    protected virtual IEnumerable`1<object> GetCustomAttributes(ParameterInfo parameter, IEnumerable`1<object> declaredAttributes);
    [IteratorStateMachineAttribute("System.Reflection.Context.CustomReflectionContext/<AddProperties>d__7")]
protected virtual IEnumerable`1<PropertyInfo> AddProperties(Type type);
    protected PropertyInfo CreateProperty(Type propertyType, string name, Func`2<object, object> getter, Action`2<object, object> setter);
    protected PropertyInfo CreateProperty(Type propertyType, string name, Func`2<object, object> getter, Action`2<object, object> setter, IEnumerable`1<Attribute> propertyCustomAttributes, IEnumerable`1<Attribute> getterCustomAttributes, IEnumerable`1<Attribute> setterCustomAttributes);
    [IteratorStateMachineAttribute("System.Reflection.Context.CustomReflectionContext/<GetNewPropertiesForType>d__10")]
internal IEnumerable`1<PropertyInfo> GetNewPropertiesForType(CustomType type);
    internal IEnumerable`1<object> GetCustomAttributesOnMember(MemberInfo member, IEnumerable`1<object> declaredAttributes, Type attributeFilterType);
    internal IEnumerable`1<object> GetCustomAttributesOnParameter(ParameterInfo parameter, IEnumerable`1<object> declaredAttributes, Type attributeFilterType);
    internal Projector get_Projector();
    [CompilerGeneratedAttribute]
internal ReflectionContext get_SourceContext();
}
internal class System.Reflection.Context.Delegation.DelegatingAssembly : Assembly {
    [CompilerGeneratedAttribute]
private Assembly <UnderlyingAssembly>k__BackingField;
    [RequiresAssemblyFilesAttribute("Calling 'System.Reflection.Assembly.Location' always returns an empty string for assemblies embedded in a single-file app. If the path to the app directory is needed, consider calling 'System.AppContext.BaseDirectory'")]
public string Location { get; }
    public Module ManifestModule { get; }
    public bool ReflectionOnly { get; }
    public Assembly UnderlyingAssembly { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    [ObsoleteAttribute]
[RequiresAssemblyFilesAttribute]
public string CodeBase { get; }
    public MethodInfo EntryPoint { get; }
    [ObsoleteAttribute]
[RequiresAssemblyFilesAttribute]
public string EscapedCodeBase { get; }
    public string FullName { get; }
    [ObsoleteAttribute]
public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public DelegatingAssembly(Assembly assembly);
    public virtual string get_Location();
    public virtual Module get_ManifestModule();
    public virtual bool get_ReflectionOnly();
    [CompilerGeneratedAttribute]
public Assembly get_UnderlyingAssembly();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    public virtual string get_CodeBase();
    public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    public virtual MethodInfo get_EntryPoint();
    public virtual string get_EscapedCodeBase();
    public virtual string get_FullName();
    public virtual Type[] GetExportedTypes();
    [RequiresAssemblyFilesAttribute("Calling 'System.Reflection.Assembly.GetFile(string)' will throw for assemblies embedded in a single-file app")]
public virtual FileStream GetFile(string name);
    [RequiresAssemblyFilesAttribute("Calling 'System.Reflection.Assembly.GetFiles()' will throw for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles();
    [RequiresAssemblyFilesAttribute("Calling 'System.Reflection.Assembly.GetFiles(bool)' will throw for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles(bool getResourceModules);
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsDynamic();
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
}
internal class System.Reflection.Context.Delegation.DelegatingConstructorInfo : ConstructorInfo {
    [CompilerGeneratedAttribute]
private ConstructorInfo <UnderlyingConstructor>k__BackingField;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type DeclaringType { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ConstructorInfo UnderlyingConstructor { get; }
    public DelegatingConstructorInfo(ConstructorInfo constructor);
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_DeclaringType();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    [CompilerGeneratedAttribute]
public ConstructorInfo get_UnderlyingConstructor();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetGenericArguments();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingCustomAttributeData : CustomAttributeData {
    [CompilerGeneratedAttribute]
private CustomAttributeData <UnderlyingAttribute>k__BackingField;
    public CustomAttributeData UnderlyingAttribute { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public DelegatingCustomAttributeData(CustomAttributeData attribute);
    [CompilerGeneratedAttribute]
public CustomAttributeData get_UnderlyingAttribute();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingEventInfo : EventInfo {
    [CompilerGeneratedAttribute]
private EventInfo <UnderlyingEvent>k__BackingField;
    public EventAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public EventInfo UnderlyingEvent { get; }
    public DelegatingEventInfo(EventInfo event);
    public virtual EventAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual Type get_EventHandlerType();
    public virtual bool get_IsMulticast();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    [CompilerGeneratedAttribute]
public EventInfo get_UnderlyingEvent();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual void RemoveEventHandler(object target, Delegate handler);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingExceptionHandlingClause : ExceptionHandlingClause {
    private ExceptionHandlingClause _clause;
    public Type CatchType { get; }
    public int FilterOffset { get; }
    public ExceptionHandlingClauseOptions Flags { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public DelegatingExceptionHandlingClause(ExceptionHandlingClause clause);
    public virtual Type get_CatchType();
    public virtual int get_FilterOffset();
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_HandlerLength();
    public virtual int get_HandlerOffset();
    public virtual int get_TryLength();
    public virtual int get_TryOffset();
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingFieldInfo : FieldInfo {
    [CompilerGeneratedAttribute]
private FieldInfo <UnderlyingField>k__BackingField;
    public FieldAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    public Type FieldType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public FieldInfo UnderlyingField { get; }
    public DelegatingFieldInfo(FieldInfo field);
    public virtual FieldAttributes get_Attributes();
    public virtual Type get_DeclaringType();
    public virtual RuntimeFieldHandle get_FieldHandle();
    public virtual Type get_FieldType();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    [CompilerGeneratedAttribute]
public FieldInfo get_UnderlyingField();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual object GetValue(object obj);
    public virtual object GetValueDirect(TypedReference obj);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public virtual void SetValueDirect(TypedReference obj, object value);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingLocalVariableInfo : LocalVariableInfo {
    [CompilerGeneratedAttribute]
private LocalVariableInfo <UnderlyingVariable>k__BackingField;
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public LocalVariableInfo UnderlyingVariable { get; }
    public DelegatingLocalVariableInfo(LocalVariableInfo variable);
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
    [CompilerGeneratedAttribute]
public LocalVariableInfo get_UnderlyingVariable();
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingManifestResourceInfo : ManifestResourceInfo {
    [CompilerGeneratedAttribute]
private ManifestResourceInfo <UnderlyingResource>k__BackingField;
    public ManifestResourceInfo UnderlyingResource { get; }
    public DelegatingManifestResourceInfo(ManifestResourceInfo resource);
    [CompilerGeneratedAttribute]
public ManifestResourceInfo get_UnderlyingResource();
}
internal class System.Reflection.Context.Delegation.DelegatingMethodBody : MethodBody {
    private MethodBody _body;
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public DelegatingMethodBody(MethodBody body);
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    public virtual Byte[] GetILAsByteArray();
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingMethodInfo : MethodInfo {
    [CompilerGeneratedAttribute]
private MethodInfo <UnderlyingMethod>k__BackingField;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public Type DeclaringType { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public int MetadataToken { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReturnType { get; }
    public MethodInfo UnderlyingMethod { get; }
    public DelegatingMethodInfo(MethodInfo method);
    public virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public virtual Type get_DeclaringType();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual int get_MetadataToken();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Type get_ReturnType();
    [CompilerGeneratedAttribute]
public MethodInfo get_UnderlyingMethod();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodBody GetMethodBody();
    public virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    public virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingModule : Module {
    [CompilerGeneratedAttribute]
private Module <UnderlyingModule>k__BackingField;
    internal static string UnknownStringMessageInRAF;
    public Module UnderlyingModule { get; }
    public Assembly Assembly { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string Name { get; }
    public string ScopeName { get; }
    public DelegatingModule(Module module);
    [CompilerGeneratedAttribute]
public Module get_UnderlyingModule();
    public virtual Assembly get_Assembly();
    public virtual string get_FullyQualifiedName();
    public virtual int get_MDStreamVersion();
    public virtual int get_MetadataToken();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsResource();
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Byte[] ResolveSignature(int metadataToken);
    public virtual string ResolveString(int metadataToken);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingParameterInfo : ParameterInfo {
    [CompilerGeneratedAttribute]
private ParameterInfo <UnderlyingParameter>k__BackingField;
    public ParameterAttributes Attributes { get; }
    public object DefaultValue { get; }
    public MemberInfo Member { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    public object RawDefaultValue { get; }
    public ParameterInfo UnderlyingParameter { get; }
    public DelegatingParameterInfo(ParameterInfo parameter);
    public virtual ParameterAttributes get_Attributes();
    public virtual object get_DefaultValue();
    public virtual MemberInfo get_Member();
    public virtual int get_MetadataToken();
    public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    public virtual object get_RawDefaultValue();
    [CompilerGeneratedAttribute]
public ParameterInfo get_UnderlyingParameter();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal class System.Reflection.Context.Delegation.DelegatingPropertyInfo : PropertyInfo {
    [CompilerGeneratedAttribute]
private PropertyInfo <UnderlyingProperty>k__BackingField;
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public Type DeclaringType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public PropertyInfo UnderlyingProperty { get; }
    public DelegatingPropertyInfo(PropertyInfo property);
    public virtual PropertyAttributes get_Attributes();
    public virtual bool get_CanRead();
    public virtual bool get_CanWrite();
    public virtual Type get_DeclaringType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    [CompilerGeneratedAttribute]
public PropertyInfo get_UnderlyingProperty();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual object GetValue(object obj, Object[] index);
    public virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual void SetValue(object obj, object value, Object[] index);
    public virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual object GetConstantValue();
    public virtual object GetRawConstantValue();
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal abstract class System.Reflection.Context.Delegation.DelegatingType : TypeInfo {
    private TypeInfo _typeInfo;
    public Assembly Assembly { get; }
    public string AssemblyQualifiedName { get; }
    public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public Guid GUID { get; }
    public bool IsEnum { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    public string Namespace { get; }
    public Type ReflectedType { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public Type UnderlyingType { get; }
    internal object Delegate { get; }
    public DelegatingType(Type type);
    public virtual Assembly get_Assembly();
    public virtual string get_AssemblyQualifiedName();
    public virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    public virtual int get_GenericParameterPosition();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual Guid get_GUID();
    public virtual bool get_IsEnum();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSerializable();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    public virtual string get_Namespace();
    public virtual Type get_ReflectedType();
    public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    public Type get_UnderlyingType();
    internal object get_Delegate();
    public virtual int GetArrayRank();
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    public virtual Array GetEnumValues();
    public virtual Type GetEnumUnderlyingType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual EventInfo[] GetEvents();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    protected virtual TypeCode GetTypeCodeImpl();
    public virtual bool IsAssignableFrom(Type c);
    protected virtual bool IsContextfulImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsEnumDefined(object value);
    public virtual bool IsEquivalentTo(Type other);
    public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsMarshalByRefImpl();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsValueTypeImpl();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakePointerType();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakeByRefType();
    public virtual string ToString();
}
internal class System.Reflection.Context.IdentityReflectionContext : ReflectionContext {
    public virtual Assembly MapAssembly(Assembly assembly);
    public virtual TypeInfo MapType(TypeInfo type);
}
internal interface System.Reflection.Context.Projection.IProjectable {
    public Projector Projector { get; }
    public abstract virtual Projector get_Projector();
}
internal class System.Reflection.Context.Projection.ProjectingAssembly : DelegatingAssembly {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Module ManifestModule { get; }
    public MethodInfo EntryPoint { get; }
    public ProjectingAssembly(Assembly assembly, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Module get_ManifestModule();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual MethodInfo get_EntryPoint();
    public virtual Type[] GetExportedTypes();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual Module GetModule(string name);
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingConstructorInfo : DelegatingConstructorInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ProjectingConstructorInfo(ConstructorInfo constructor, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type[] GetGenericArguments();
    public virtual MethodBody GetMethodBody();
    public virtual ParameterInfo[] GetParameters();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingCustomAttributeData : DelegatingCustomAttributeData {
    private Projector _projector;
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public ProjectingCustomAttributeData(CustomAttributeData attribute, Projector projector);
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
internal class System.Reflection.Context.Projection.ProjectingEventInfo : DelegatingEventInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Type DeclaringType { get; }
    public Type EventHandlerType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ProjectingEventInfo(EventInfo event, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Type get_DeclaringType();
    public virtual Type get_EventHandlerType();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingExceptionHandlingClause : DelegatingExceptionHandlingClause {
    private Projector _projector;
    public Type CatchType { get; }
    public ProjectingExceptionHandlingClause(ExceptionHandlingClause clause, Projector projector);
    public virtual Type get_CatchType();
}
internal class System.Reflection.Context.Projection.ProjectingFieldInfo : DelegatingFieldInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Type DeclaringType { get; }
    public Type FieldType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ProjectingFieldInfo(FieldInfo field, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Type get_DeclaringType();
    public virtual Type get_FieldType();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingLocalVariableInfo : DelegatingLocalVariableInfo {
    private Projector _projector;
    public Type LocalType { get; }
    public ProjectingLocalVariableInfo(LocalVariableInfo variable, Projector projector);
    public virtual Type get_LocalType();
}
internal class System.Reflection.Context.Projection.ProjectingManifestResourceInfo : DelegatingManifestResourceInfo {
    private Projector _projector;
    public Assembly ReferencedAssembly { get; }
    public ProjectingManifestResourceInfo(ManifestResourceInfo resource, Projector projector);
    public virtual Assembly get_ReferencedAssembly();
}
internal class System.Reflection.Context.Projection.ProjectingMethodBody : DelegatingMethodBody {
    private Projector _projector;
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public ProjectingMethodBody(MethodBody body, Projector projector);
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
}
internal class System.Reflection.Context.Projection.ProjectingMethodInfo : DelegatingMethodInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReturnType { get; }
    public ProjectingMethodInfo(MethodInfo method, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Type get_ReturnType();
    public virtual MethodInfo GetBaseDefinition();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual MethodBody GetMethodBody();
    public virtual ParameterInfo[] GetParameters();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingModule : DelegatingModule {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Assembly Assembly { get; }
    public ProjectingModule(Module module, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Assembly get_Assembly();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    public virtual Type[] GetTypes();
    public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingParameterInfo : DelegatingParameterInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public MemberInfo Member { get; }
    public Type ParameterType { get; }
    public ProjectingParameterInfo(ParameterInfo parameter, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual MemberInfo get_Member();
    public virtual Type get_ParameterType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingPropertyInfo : DelegatingPropertyInfo {
    [CompilerGeneratedAttribute]
private Projector <Projector>k__BackingField;
    public Projector Projector { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public Type PropertyType { get; }
    public Type ReflectedType { get; }
    public ProjectingPropertyInfo(PropertyInfo property, Projector projector);
    [CompilerGeneratedAttribute]
public sealed virtual Projector get_Projector();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual Type get_PropertyType();
    public virtual Type get_ReflectedType();
    public virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual ParameterInfo[] GetIndexParameters();
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual Type[] GetOptionalCustomModifiers();
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Projection.ProjectingType : DelegatingType {
    private Projector _projector;
    public Projector Projector { get; }
    public Assembly Assembly { get; }
    public Type BaseType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type DeclaringType { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ProjectingType(Type type, Projector projector);
    public sealed virtual Projector get_Projector();
    public virtual Assembly get_Assembly();
    public virtual Type get_BaseType();
    public virtual MethodBase get_DeclaringMethod();
    public virtual Type get_DeclaringType();
    public virtual Module get_Module();
    public virtual Type get_ReflectedType();
    public virtual MemberInfo[] GetDefaultMembers();
    public virtual Type GetEnumUnderlyingType();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual EventInfo[] GetEvents();
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    public virtual bool IsAssignableFrom(Type c);
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsEquivalentTo(Type other);
    public virtual bool IsInstanceOfType(object o);
    public virtual bool IsSubclassOf(Type c);
    protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Type GetElementType();
    public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual Type[] GetInterfaces();
    public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public virtual Type MakeArrayType();
    public virtual Type MakeArrayType(int rank);
    public virtual Type MakePointerType();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakeByRefType();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal abstract class System.Reflection.Context.Projection.Projector : object {
    public IList`1<T> Project(IList`1<T> values, Func`2<T, T> project);
    public T[] Project(T[] values, Func`2<T, T> project);
    public T Project(T value, Func`2<T, T> project);
    public abstract virtual TypeInfo ProjectType(Type value);
    public abstract virtual Assembly ProjectAssembly(Assembly value);
    public abstract virtual Module ProjectModule(Module value);
    public abstract virtual FieldInfo ProjectField(FieldInfo value);
    public abstract virtual EventInfo ProjectEvent(EventInfo value);
    public abstract virtual ConstructorInfo ProjectConstructor(ConstructorInfo value);
    public abstract virtual MethodInfo ProjectMethod(MethodInfo value);
    public abstract virtual MethodBase ProjectMethodBase(MethodBase value);
    public abstract virtual PropertyInfo ProjectProperty(PropertyInfo value);
    public abstract virtual ParameterInfo ProjectParameter(ParameterInfo value);
    public abstract virtual MethodBody ProjectMethodBody(MethodBody value);
    public abstract virtual LocalVariableInfo ProjectLocalVariable(LocalVariableInfo value);
    public abstract virtual ExceptionHandlingClause ProjectExceptionHandlingClause(ExceptionHandlingClause value);
    public abstract virtual CustomAttributeData ProjectCustomAttributeData(CustomAttributeData value);
    public abstract virtual ManifestResourceInfo ProjectManifestResource(ManifestResourceInfo value);
    public abstract virtual CustomAttributeTypedArgument ProjectTypedArgument(CustomAttributeTypedArgument value);
    public abstract virtual CustomAttributeNamedArgument ProjectNamedArgument(CustomAttributeNamedArgument value);
    public abstract virtual InterfaceMapping ProjectInterfaceMapping(InterfaceMapping value);
    public abstract virtual MemberInfo ProjectMember(MemberInfo value);
    public static Type[] Unproject(Type[] values);
    public static Type Unproject(Type value);
    public bool NeedsProjection(object value);
    private T[] ProjectAll(IList`1<T> values, Func`2<T, T> project);
}
internal class System.Reflection.Context.Virtual.InheritedMethodInfo : DelegatingMethodInfo {
    private Type _reflectedType;
    public Type ReflectedType { get; }
    public InheritedMethodInfo(MethodInfo baseMethod, Type reflectedType);
    public virtual Type get_ReflectedType();
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal class System.Reflection.Context.Virtual.InheritedPropertyInfo : DelegatingPropertyInfo {
    private Type _reflectedType;
    public Type ReflectedType { get; }
    public InheritedPropertyInfo(PropertyInfo baseProperty, Type reflectedType);
    public virtual Type get_ReflectedType();
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual bool Equals(object o);
    public virtual int GetHashCode();
}
internal abstract class System.Reflection.Context.Virtual.VirtualMethodBase : MethodInfo {
    private ParameterInfo _returnParameter;
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    public ParameterInfo ReturnParameter { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    protected abstract virtual Type[] GetParameterTypes();
    public virtual MethodAttributes get_Attributes();
    public sealed virtual CallingConventions get_CallingConvention();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public virtual RuntimeMethodHandle get_MethodHandle();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual ParameterInfo get_ReturnParameter();
    public sealed virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public sealed virtual MethodInfo GetBaseDefinition();
    public sealed virtual Type[] GetGenericArguments();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual MethodImplAttributes GetMethodImplementationFlags();
    public virtual ParameterInfo[] GetParameters();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.Reflection.Context.Virtual.VirtualParameter : ParameterInfo {
    public VirtualParameter(MemberInfo member, Type parameterType, string name, int position);
    internal static ParameterInfo[] CloneParameters(MemberInfo member, ParameterInfo[] parameters, bool skipLastParameter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal abstract class System.Reflection.Context.Virtual.VirtualPropertyBase : PropertyInfo {
    private string _name;
    private Type _propertyType;
    private Type _declaringType;
    private ParameterInfo[] _indexedParameters;
    [CompilerGeneratedAttribute]
private CustomReflectionContext <ReflectionContext>k__BackingField;
    public CustomReflectionContext ReflectionContext { get; }
    public PropertyAttributes Attributes { get; }
    public Type DeclaringType { get; }
    public string Name { get; }
    public Type PropertyType { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public Type ReflectedType { get; }
    protected VirtualPropertyBase(Type propertyType, string name, CustomReflectionContext context);
    [CompilerGeneratedAttribute]
public CustomReflectionContext get_ReflectionContext();
    public sealed virtual PropertyAttributes get_Attributes();
    public sealed virtual Type get_DeclaringType();
    public sealed virtual string get_Name();
    public sealed virtual Type get_PropertyType();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Module get_Module();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual MethodInfo[] GetAccessors(bool nonPublic);
    public sealed virtual ParameterInfo[] GetIndexParameters();
    public sealed virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public sealed virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public sealed virtual object GetConstantValue();
    public sealed virtual object GetRawConstantValue();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    internal void SetDeclaringType(Type declaringType);
    private ParameterInfo[] GetIndexParametersNoCopy();
}
internal class System.Reflection.Context.Virtual.VirtualPropertyInfo : VirtualPropertyBase {
    private PropertyGetter _getter;
    private PropertySetter _setter;
    private IEnumerable`1<Attribute> _attributes;
    public VirtualPropertyInfo(string name, Type propertyType, Func`2<object, object> getter, Action`2<object, object> setter, IEnumerable`1<Attribute> propertyAttributes, IEnumerable`1<Attribute> getterAttributes, IEnumerable`1<Attribute> setterAttributes, CustomReflectionContext context);
    public virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual MethodInfo GetSetMethod(bool nonPublic);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
internal class System.Reflection.Context.Virtual.VirtualReturnParameter : VirtualParameter {
    public VirtualReturnParameter(MethodInfo method);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentNull_GetterOrSetterMustBeSpecified { get; }
    internal static string Argument_GetMethNotFnd { get; }
    internal static string Argument_PropertyTypeFromDifferentContext { get; }
    internal static string Format_AttributeUsage { get; }
    internal static string InvalidOperation_AddNullProperty { get; }
    internal static string InvalidOperation_AddPropertyDifferentContext { get; }
    internal static string InvalidOperation_AddPropertyDifferentType { get; }
    internal static string InvalidOperation_EnumLitValueNotFound { get; }
    internal static string InvalidOperation_InvalidMemberType { get; }
    internal static string InvalidOperation_InvalidMethodType { get; }
    internal static string InvalidOperation_NotGenericMethodDefinition { get; }
    internal static string InvalidOperation_NoTypeInfoForThisType { get; }
    internal static string InvalidOperation_NullAttribute { get; }
    internal static string PlatformNotSupported_ReflectionContext { get; }
    internal static string Target_InstanceMethodRequiresTarget { get; }
    internal static string Target_ObjectTargetMismatch { get; }
    internal static string Argument_ObjectArgumentMismatch { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentNull_GetterOrSetterMustBeSpecified();
    internal static string get_Argument_GetMethNotFnd();
    internal static string get_Argument_PropertyTypeFromDifferentContext();
    internal static string get_Format_AttributeUsage();
    internal static string get_InvalidOperation_AddNullProperty();
    internal static string get_InvalidOperation_AddPropertyDifferentContext();
    internal static string get_InvalidOperation_AddPropertyDifferentType();
    internal static string get_InvalidOperation_EnumLitValueNotFound();
    internal static string get_InvalidOperation_InvalidMemberType();
    internal static string get_InvalidOperation_InvalidMethodType();
    internal static string get_InvalidOperation_NotGenericMethodDefinition();
    internal static string get_InvalidOperation_NoTypeInfoForThisType();
    internal static string get_InvalidOperation_NullAttribute();
    internal static string get_PlatformNotSupported_ReflectionContext();
    internal static string get_Target_InstanceMethodRequiresTarget();
    internal static string get_Target_ObjectTargetMismatch();
    internal static string get_Argument_ObjectArgumentMismatch();
}
