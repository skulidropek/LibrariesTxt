[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class System.Buffers.ArrayBufferWriter`1 : object {
    public int Capacity { get; }
    public int FreeCapacity { get; }
    public int WrittenCount { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> WrittenMemory { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> WrittenSpan { get; }
    public ArrayBufferWriter`1(int initialCapacity);
    public int get_Capacity();
    public int get_FreeCapacity();
    public int get_WrittenCount();
    public ReadOnlyMemory`1<T> get_WrittenMemory();
    public ReadOnlySpan`1<T> get_WrittenSpan();
    public sealed virtual void Advance(int count);
    public void Clear();
    public sealed virtual Memory`1<T> GetMemory(int sizeHint);
    public sealed virtual Span`1<T> GetSpan(int sizeHint);
}
public static class System.Buffers.Binary.BinaryPrimitives : object {
    public static double ReadDoubleBigEndian(ReadOnlySpan`1<byte> source);
    public static double ReadDoubleLittleEndian(ReadOnlySpan`1<byte> source);
    public static Half ReadHalfBigEndian(ReadOnlySpan`1<byte> source);
    public static Half ReadHalfLittleEndian(ReadOnlySpan`1<byte> source);
    public static short ReadInt16BigEndian(ReadOnlySpan`1<byte> source);
    public static short ReadInt16LittleEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32BigEndian(ReadOnlySpan`1<byte> source);
    public static int ReadInt32LittleEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64BigEndian(ReadOnlySpan`1<byte> source);
    public static long ReadInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static float ReadSingleBigEndian(ReadOnlySpan`1<byte> source);
    public static float ReadSingleLittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ushort ReadUInt16LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static UInt32 ReadUInt32LittleEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64BigEndian(ReadOnlySpan`1<byte> source);
    [CLSCompliantAttribute("False")]
public static ulong ReadUInt64LittleEndian(ReadOnlySpan`1<byte> source);
    public static byte ReverseEndianness(byte value);
    public static short ReverseEndianness(short value);
    public static int ReverseEndianness(int value);
    public static long ReverseEndianness(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ReverseEndianness(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ReverseEndianness(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ReverseEndianness(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ReverseEndianness(ulong value);
    public static bool TryReadDoubleBigEndian(ReadOnlySpan`1<byte> source, Double& value);
    public static bool TryReadDoubleLittleEndian(ReadOnlySpan`1<byte> source, Double& value);
    public static bool TryReadHalfBigEndian(ReadOnlySpan`1<byte> source, Half& value);
    public static bool TryReadHalfLittleEndian(ReadOnlySpan`1<byte> source, Half& value);
    public static bool TryReadInt16BigEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt16LittleEndian(ReadOnlySpan`1<byte> source, Int16& value);
    public static bool TryReadInt32BigEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt32LittleEndian(ReadOnlySpan`1<byte> source, Int32& value);
    public static bool TryReadInt64BigEndian(ReadOnlySpan`1<byte> source, Int64& value);
    public static bool TryReadInt64LittleEndian(ReadOnlySpan`1<byte> source, Int64& value);
    public static bool TryReadSingleBigEndian(ReadOnlySpan`1<byte> source, Single& value);
    public static bool TryReadSingleLittleEndian(ReadOnlySpan`1<byte> source, Single& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16BigEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt16LittleEndian(ReadOnlySpan`1<byte> source, UInt16& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32BigEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt32LittleEndian(ReadOnlySpan`1<byte> source, UInt32& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64BigEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    [CLSCompliantAttribute("False")]
public static bool TryReadUInt64LittleEndian(ReadOnlySpan`1<byte> source, UInt64& value);
    public static bool TryWriteDoubleBigEndian(Span`1<byte> destination, double value);
    public static bool TryWriteDoubleLittleEndian(Span`1<byte> destination, double value);
    public static bool TryWriteHalfBigEndian(Span`1<byte> destination, Half value);
    public static bool TryWriteHalfLittleEndian(Span`1<byte> destination, Half value);
    public static bool TryWriteInt16BigEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static bool TryWriteInt32BigEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static bool TryWriteInt64BigEndian(Span`1<byte> destination, long value);
    public static bool TryWriteInt64LittleEndian(Span`1<byte> destination, long value);
    public static bool TryWriteSingleBigEndian(Span`1<byte> destination, float value);
    public static bool TryWriteSingleLittleEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static bool TryWriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
    public static void WriteDoubleBigEndian(Span`1<byte> destination, double value);
    public static void WriteDoubleLittleEndian(Span`1<byte> destination, double value);
    public static void WriteHalfBigEndian(Span`1<byte> destination, Half value);
    public static void WriteHalfLittleEndian(Span`1<byte> destination, Half value);
    public static void WriteInt16BigEndian(Span`1<byte> destination, short value);
    public static void WriteInt16LittleEndian(Span`1<byte> destination, short value);
    public static void WriteInt32BigEndian(Span`1<byte> destination, int value);
    public static void WriteInt32LittleEndian(Span`1<byte> destination, int value);
    public static void WriteInt64BigEndian(Span`1<byte> destination, long value);
    public static void WriteInt64LittleEndian(Span`1<byte> destination, long value);
    public static void WriteSingleBigEndian(Span`1<byte> destination, float value);
    public static void WriteSingleLittleEndian(Span`1<byte> destination, float value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16BigEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt16LittleEndian(Span`1<byte> destination, ushort value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32BigEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt32LittleEndian(Span`1<byte> destination, UInt32 value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64BigEndian(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static void WriteUInt64LittleEndian(Span`1<byte> destination, ulong value);
}
[ExtensionAttribute]
public static class System.Buffers.BuffersExtensions : object {
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(ReadOnlySequence`1& source, Span`1<T> destination);
    [ExtensionAttribute]
public static Nullable`1<SequencePosition> PositionOf(ReadOnlySequence`1& source, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static T[] ToArray(ReadOnlySequence`1& sequence);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Write(IBufferWriter`1<T> writer, ReadOnlySpan`1<T> value);
}
[NullableContextAttribute("2")]
public interface System.Buffers.IBufferWriter`1 {
    public abstract virtual void Advance(int count);
    public abstract virtual Memory`1<T> GetMemory(int sizeHint);
    public abstract virtual Span`1<T> GetSpan(int sizeHint);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Buffers.MemoryPool`1 : object {
    public int MaxBufferSize { get; }
    public static MemoryPool`1<T> Shared { get; }
    public abstract virtual int get_MaxBufferSize();
    public static MemoryPool`1<T> get_Shared();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual IMemoryOwner`1<T> Rent(int minBufferSize);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Buffers.ReadOnlySequence`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlySequence`1<T> Empty;
    public SequencePosition End { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> First { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> FirstSpan { get; }
    public bool IsEmpty { get; }
    public bool IsSingleSegment { get; }
    public long Length { get; }
    public SequencePosition Start { get; }
    public ReadOnlySequence`1(ReadOnlySequenceSegment`1<T> startSegment, int startIndex, ReadOnlySequenceSegment`1<T> endSegment, int endIndex);
    public ReadOnlySequence`1(ReadOnlyMemory`1<T> memory);
    public ReadOnlySequence`1(T[] array);
    public ReadOnlySequence`1(T[] array, int start, int length);
    public SequencePosition get_End();
    public ReadOnlyMemory`1<T> get_First();
    public ReadOnlySpan`1<T> get_FirstSpan();
    public bool get_IsEmpty();
    public bool get_IsSingleSegment();
    public long get_Length();
    public SequencePosition get_Start();
    public Enumerator<T> GetEnumerator();
    public long GetOffset(SequencePosition position);
    public SequencePosition GetPosition(long offset);
    public SequencePosition GetPosition(long offset, SequencePosition origin);
    public ReadOnlySequence`1<T> Slice(int start, int length);
    public ReadOnlySequence`1<T> Slice(int start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(long start);
    public ReadOnlySequence`1<T> Slice(long start, long length);
    public ReadOnlySequence`1<T> Slice(long start, SequencePosition end);
    public ReadOnlySequence`1<T> Slice(SequencePosition start);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, int length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, long length);
    public ReadOnlySequence`1<T> Slice(SequencePosition start, SequencePosition end);
    public virtual string ToString();
    public bool TryGet(SequencePosition& position, ReadOnlyMemory`1& memory, bool advance);
}
public abstract class System.Buffers.ReadOnlySequenceSegment`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlyMemory`1<T> Memory { get; protected set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySequenceSegment`1<T> Next { get; protected set; }
    public long RunningIndex { get; protected set; }
    public ReadOnlyMemory`1<T> get_Memory();
    protected void set_Memory(ReadOnlyMemory`1<T> value);
    public ReadOnlySequenceSegment`1<T> get_Next();
    protected void set_Next(ReadOnlySequenceSegment`1<T> value);
    public long get_RunningIndex();
    protected void set_RunningIndex(long value);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Buffers.SequenceReader`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public long Consumed { get; }
    public ReadOnlySpan`1<T> CurrentSpan { get; }
    public int CurrentSpanIndex { get; }
    public bool End { get; }
    public long Length { get; }
    public SequencePosition Position { get; }
    public long Remaining { get; }
    public ReadOnlySequence`1<T> Sequence { get; }
    public ReadOnlySequence`1<T> UnreadSequence { get; }
    public ReadOnlySpan`1<T> UnreadSpan { get; }
    public SequenceReader`1(ReadOnlySequence`1<T> sequence);
    [IsReadOnlyAttribute]
public long get_Consumed();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_CurrentSpan();
    [IsReadOnlyAttribute]
public int get_CurrentSpanIndex();
    [IsReadOnlyAttribute]
public bool get_End();
    [IsReadOnlyAttribute]
public long get_Length();
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [IsReadOnlyAttribute]
public long get_Remaining();
    [IsReadOnlyAttribute]
public ReadOnlySequence`1<T> get_Sequence();
    [IsReadOnlyAttribute]
public ReadOnlySequence`1<T> get_UnreadSequence();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<T> get_UnreadSpan();
    public void Advance(long count);
    public long AdvancePast(T value);
    public long AdvancePastAny(ReadOnlySpan`1<T> values);
    public long AdvancePastAny(T value0, T value1);
    public long AdvancePastAny(T value0, T value1, T value2);
    public long AdvancePastAny(T value0, T value1, T value2, T value3);
    public void AdvanceToEnd();
    public bool IsNext(ReadOnlySpan`1<T> next, bool advancePast);
    public bool IsNext(T next, bool advancePast);
    public void Rewind(long count);
    public bool TryAdvanceTo(T delimiter, bool advancePastDelimiter);
    public bool TryAdvanceToAny(ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    [IsReadOnlyAttribute]
public bool TryCopyTo(Span`1<T> destination);
    [IsReadOnlyAttribute]
public bool TryPeek(T& value);
    [IsReadOnlyAttribute]
public bool TryPeek(long offset, T& value);
    public bool TryRead(T& value);
    public bool TryReadTo(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySequence`1& sequence, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, bool advancePastDelimiter);
    public bool TryReadTo(ReadOnlySpan`1& span, T delimiter, T delimiterEscape, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySequence`1& sequence, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public bool TryReadToAny(ReadOnlySpan`1& span, ReadOnlySpan`1<T> delimiters, bool advancePastDelimiter);
    public bool TryReadExact(int count, ReadOnlySequence`1& sequence);
}
[ExtensionAttribute]
public static class System.Buffers.SequenceReaderExtensions : object {
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadBigEndian(SequenceReader`1& reader, Int64& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int16& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int32& value);
    [ExtensionAttribute]
public static bool TryReadLittleEndian(SequenceReader`1& reader, Int64& value);
}
[IsReadOnlyAttribute]
public class System.Buffers.StandardFormat : ValueType {
    private int _dummyPrimitive;
    public static byte MaxPrecision;
    public static byte NoPrecision;
    public bool HasPrecision { get; }
    public bool IsDefault { get; }
    public byte Precision { get; }
    public char Symbol { get; }
    public StandardFormat(char symbol, byte precision);
    public bool get_HasPrecision();
    public bool get_IsDefault();
    public byte get_Precision();
    public char get_Symbol();
    public sealed virtual bool Equals(StandardFormat other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(StandardFormat left, StandardFormat right);
    public static StandardFormat op_Implicit(char symbol);
    public static bool op_Inequality(StandardFormat left, StandardFormat right);
    public static StandardFormat Parse(ReadOnlySpan`1<char> format);
    [NullableContextAttribute("2")]
public static StandardFormat Parse(string format);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public static bool TryParse(ReadOnlySpan`1<char> format, StandardFormat& result);
}
public static class System.Buffers.Text.Utf8Formatter : object {
    public static bool TryFormat(bool value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(byte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTime value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(DateTimeOffset value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(decimal value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(double value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(Guid value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(short value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(int value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(long value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(sbyte value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(float value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    public static bool TryFormat(TimeSpan value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ushort value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(UInt32 value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
    [CLSCompliantAttribute("False")]
public static bool TryFormat(ulong value, Span`1<byte> destination, Int32& bytesWritten, StandardFormat format);
}
public static class System.Buffers.Text.Utf8Parser : object {
    public static bool TryParse(ReadOnlySpan`1<byte> source, Boolean& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Byte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTime& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, DateTimeOffset& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Decimal& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Double& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Guid& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int16& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int32& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Int64& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, SByte& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, Single& value, Int32& bytesConsumed, char standardFormat);
    public static bool TryParse(ReadOnlySpan`1<byte> source, TimeSpan& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt16& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt32& value, Int32& bytesConsumed, char standardFormat);
    [CLSCompliantAttribute("False")]
public static bool TryParse(ReadOnlySpan`1<byte> source, UInt64& value, Int32& bytesConsumed, char standardFormat);
}
[ExtensionAttribute]
public static class System.MemoryExtensions : object {
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Index startIndex);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, int start, int length);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> AsMemory(string text, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Memory`1<T> AsMemory(T[] array, Range range);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> AsSpan(string text, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(ArraySegment`1<T> segment, Range range);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Index startIndex);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, int start, int length);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static Span`1<T> AsSpan(T[] array, Range range);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, IComparable`1<T> comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(ReadOnlySpan`1<T> span, TComparable comparable);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, T value, TComparer comparer);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int BinarySearch(Span`1<T> span, TComparable comparable);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(Span`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static int CommonPrefixLength(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [ExtensionAttribute]
public static int CompareTo(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool Contains(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static bool Contains(Span`1<T> span, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Memory`1<T> destination);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void CopyTo(T[] source, Span`1<T> destination);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool EndsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool EndsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static SpanLineEnumerator EnumerateLines(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static SpanLineEnumerator EnumerateLines(Span`1<char> span);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static SpanRuneEnumerator EnumerateRunes(Span`1<char> span);
    [ExtensionAttribute]
public static bool Equals(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> other, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int IndexOfAnyExcept(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int IndexOf(Span`1<T> span, T value);
    [ExtensionAttribute]
public static bool IsWhiteSpace(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, ReadOnlySpan`1<T> values);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAny(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(Span`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, T value0, T value1, T value2);
    [ExtensionAttribute]
public static int LastIndexOfAnyExcept(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> values);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(ReadOnlySpan`1<T> span, T value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int LastIndexOf(Span`1<T> span, T value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool Overlaps(Span`1<T> span, ReadOnlySpan`1<T> other, Int32& elementOffset);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Reverse(Span`1<T> span);
    [ExtensionAttribute]
public static int SequenceCompareTo(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static int SequenceCompareTo(Span`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other);
    [ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool SequenceEqual(Span`1<T> span, ReadOnlySpan`1<T> other, IEqualityComparer`1<T> comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<T> span);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static void Sort(Span`1<T> span, Comparison`1<T> comparison);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items, Comparison`1<TKey> comparison);
    [ExtensionAttribute]
public static void Sort(Span`1<T> span, TComparer comparer);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static void Sort(Span`1<TKey> keys, Span`1<TValue> items, TComparer comparer);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> value, StringComparison comparisonType);
    [ExtensionAttribute]
public static bool StartsWith(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static bool StartsWith(Span`1<T> span, ReadOnlySpan`1<T> value);
    [ExtensionAttribute]
public static int ToLower(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToLowerInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static int ToUpper(ReadOnlySpan`1<char> source, Span`1<char> destination, CultureInfo culture);
    [ExtensionAttribute]
public static int ToUpperInvariant(ReadOnlySpan`1<char> source, Span`1<char> destination);
    [ExtensionAttribute]
public static Memory`1<char> Trim(Memory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> Trim(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> Trim(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static Span`1<char> Trim(Span`1<char> span);
    [ExtensionAttribute]
public static Memory`1<char> TrimEnd(Memory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimEnd(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimEnd(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static Span`1<char> TrimEnd(Span`1<char> span);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimEnd(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimEnd(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimEnd(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimEnd(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Memory`1<char> TrimStart(Memory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<char> TrimStart(ReadOnlyMemory`1<char> memory);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, char trimChar);
    [ExtensionAttribute]
public static ReadOnlySpan`1<char> TrimStart(ReadOnlySpan`1<char> span, ReadOnlySpan`1<char> trimChars);
    [ExtensionAttribute]
public static Span`1<char> TrimStart(Span`1<char> span);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> TrimStart(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> TrimStart(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> TrimStart(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> TrimStart(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Memory`1<T> Trim(Memory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlyMemory`1<T> Trim(ReadOnlyMemory`1<T> memory, T trimElement);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static ReadOnlySpan`1<T> Trim(ReadOnlySpan`1<T> span, T trimElement);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, ReadOnlySpan`1<T> trimElements);
    [ExtensionAttribute]
public static Span`1<T> Trim(Span`1<T> span, T trimElement);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, TryWriteInterpolatedStringHandler& handler, Int32& charsWritten);
    [ExtensionAttribute]
public static bool TryWrite(Span`1<char> destination, IFormatProvider provider, TryWriteInterpolatedStringHandler& handler, Int32& charsWritten);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
public static class System.Runtime.InteropServices.MemoryMarshal : object {
    public static ReadOnlySpan`1<byte> AsBytes(ReadOnlySpan`1<T> span);
    public static Span`1<byte> AsBytes(Span`1<T> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> AsMemory(ReadOnlyMemory`1<T> memory);
    public static T& modreq(System.Runtime.InteropServices.InAttribute) AsRef(ReadOnlySpan`1<byte> span);
    public static T& AsRef(Span`1<byte> span);
    public static ReadOnlySpan`1<TTo> Cast(ReadOnlySpan`1<TFrom> span);
    public static Span`1<TTo> Cast(Span`1<TFrom> span);
    [NullableContextAttribute("2")]
public static Memory`1<T> CreateFromPinnedArray(T[] array, int start, int length);
    [NullableContextAttribute("1")]
public static ReadOnlySpan`1<T> CreateReadOnlySpan(T& reference, int length);
    [CLSCompliantAttribute("False")]
public static ReadOnlySpan`1<byte> CreateReadOnlySpanFromNullTerminated(Byte* value);
    [CLSCompliantAttribute("False")]
public static ReadOnlySpan`1<char> CreateReadOnlySpanFromNullTerminated(Char* value);
    [NullableContextAttribute("1")]
public static Span`1<T> CreateSpan(T& reference, int length);
    [NullableContextAttribute("1")]
public static T& GetArrayDataReference(T[] array);
    [NullableContextAttribute("1")]
public static Byte& GetArrayDataReference(Array array);
    [NullableContextAttribute("1")]
public static T& GetReference(ReadOnlySpan`1<T> span);
    [NullableContextAttribute("1")]
public static T& GetReference(Span`1<T> span);
    public static T Read(ReadOnlySpan`1<byte> source);
    [NullableContextAttribute("1")]
public static IEnumerable`1<T> ToEnumerable(ReadOnlyMemory`1<T> memory);
    [NullableContextAttribute("2")]
public static bool TryGetArray(ReadOnlyMemory`1<T> memory, ArraySegment`1& segment);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager);
    [NullableContextAttribute("2")]
public static bool TryGetMemoryManager(ReadOnlyMemory`1<T> memory, TManager& manager, Int32& start, Int32& length);
    public static bool TryGetString(ReadOnlyMemory`1<char> memory, String& text, Int32& start, Int32& length);
    public static bool TryRead(ReadOnlySpan`1<byte> source, T& value);
    public static bool TryWrite(Span`1<byte> destination, T& value);
    public static void Write(Span`1<byte> destination, T& value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.SequenceMarshal : object {
    public static bool TryGetArray(ReadOnlySequence`1<T> sequence, ArraySegment`1& segment);
    public static bool TryGetReadOnlyMemory(ReadOnlySequence`1<T> sequence, ReadOnlyMemory`1& memory);
    public static bool TryGetReadOnlySequenceSegment(ReadOnlySequence`1<T> sequence, ReadOnlySequenceSegment`1& startSegment, Int32& startIndex, ReadOnlySequenceSegment`1& endSegment, Int32& endIndex);
    [NullableContextAttribute("0")]
public static bool TryRead(SequenceReader`1& reader, T& value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.SequencePosition : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public SequencePosition(object object, int integer);
    [EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SequencePosition other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public int GetInteger();
    [EditorBrowsableAttribute("1")]
public object GetObject();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Text.EncodingExtensions : object {
    [ExtensionAttribute]
public static void Convert(Decoder decoder, ReadOnlySequence`1& bytes, IBufferWriter`1<char> writer, bool flush, Int64& charsUsed, Boolean& completed);
    [ExtensionAttribute]
public static void Convert(Decoder decoder, ReadOnlySpan`1<byte> bytes, IBufferWriter`1<char> writer, bool flush, Int64& charsUsed, Boolean& completed);
    [ExtensionAttribute]
public static void Convert(Encoder encoder, ReadOnlySequence`1& chars, IBufferWriter`1<byte> writer, bool flush, Int64& bytesUsed, Boolean& completed);
    [ExtensionAttribute]
public static void Convert(Encoder encoder, ReadOnlySpan`1<char> chars, IBufferWriter`1<byte> writer, bool flush, Int64& bytesUsed, Boolean& completed);
    [ExtensionAttribute]
public static Byte[] GetBytes(Encoding encoding, ReadOnlySequence`1& chars);
    [ExtensionAttribute]
public static long GetBytes(Encoding encoding, ReadOnlySequence`1& chars, IBufferWriter`1<byte> writer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int GetBytes(Encoding encoding, ReadOnlySequence`1& chars, Span`1<byte> bytes);
    [ExtensionAttribute]
public static long GetBytes(Encoding encoding, ReadOnlySpan`1<char> chars, IBufferWriter`1<byte> writer);
    [ExtensionAttribute]
public static long GetChars(Encoding encoding, ReadOnlySequence`1& bytes, IBufferWriter`1<char> writer);
    [NullableContextAttribute("0")]
[ExtensionAttribute]
public static int GetChars(Encoding encoding, ReadOnlySequence`1& bytes, Span`1<char> chars);
    [ExtensionAttribute]
public static long GetChars(Encoding encoding, ReadOnlySpan`1<byte> bytes, IBufferWriter`1<char> writer);
    [ExtensionAttribute]
public static string GetString(Encoding encoding, ReadOnlySequence`1& bytes);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Text.SpanLineEnumerator : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ReadOnlySpan`1<char> Current { get; }
    public ReadOnlySpan`1<char> get_Current();
    public SpanLineEnumerator GetEnumerator();
    public bool MoveNext();
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Text.SpanRuneEnumerator : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Rune Current { get; }
    public Rune get_Current();
    public SpanRuneEnumerator GetEnumerator();
    public bool MoveNext();
}
