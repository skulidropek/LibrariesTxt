[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.DataContractResolver : object {
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual Type ResolveName(string typeName, string typeNamespace, Type declaredType, DataContractResolver knownTypeResolver);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual bool TryResolveType(Type type, Type declaredType, DataContractResolver knownTypeResolver, XmlDictionaryString& typeName, XmlDictionaryString& typeNamespace);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.DataContracts.DataContract : object {
    internal static DynamicallyAccessedMemberTypes DataContractPreserveMemberTypes;
    [NullableAttribute("2")]
public DataContract BaseContract { get; }
    [NullableAttribute("2")]
public string ContractType { get; }
    public bool IsBuiltInDataContract { get; }
    public bool IsISerializable { get; }
    public bool IsReference { get; }
    public bool IsValueType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<XmlQualifiedName, DataContract> KnownDataContracts { get; }
    public ReadOnlyCollection`1<DataMember> DataMembers { get; }
    public Type OriginalUnderlyingType { get; }
    public XmlQualifiedName XmlName { get; }
    [DynamicallyAccessedMembersAttribute("575")]
public Type UnderlyingType { get; }
    [NullableAttribute("2")]
public XmlDictionaryString TopLevelElementName { get; }
    [NullableAttribute("2")]
public XmlDictionaryString TopLevelElementNamespace { get; }
    internal DataContract(DataContractCriticalHelper helper);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual DataContract get_BaseContract();
    [NullableContextAttribute("2")]
public virtual string get_ContractType();
    public virtual bool get_IsBuiltInDataContract();
    public virtual bool get_IsISerializable();
    public virtual bool get_IsReference();
    public virtual bool get_IsValueType();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual Dictionary`2<XmlQualifiedName, DataContract> get_KnownDataContracts();
    public virtual ReadOnlyCollection`1<DataMember> get_DataMembers();
    public virtual Type get_OriginalUnderlyingType();
    public virtual XmlQualifiedName get_XmlName();
    public virtual Type get_UnderlyingType();
    [NullableContextAttribute("2")]
public virtual XmlDictionaryString get_TopLevelElementName();
    [NullableContextAttribute("2")]
public virtual XmlDictionaryString get_TopLevelElementNamespace();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static DataContract GetBuiltInDataContract(string name, string ns);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static XmlQualifiedName GetXmlName(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual XmlQualifiedName GetArrayTypeName(bool isNullable);
    [NullableContextAttribute("2")]
public virtual bool IsDictionaryLike(String& keyName, String& valueName, String& itemName);
}
internal abstract class System.Runtime.Serialization.DataContracts.DataContractCriticalHelper : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.DataContractSet : object {
    public Dictionary`2<XmlQualifiedName, DataContract> Contracts { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<XmlQualifiedName, DataContract> KnownTypesForObject { get; }
    public Dictionary`2<DataContract, object> ProcessedContracts { get; }
    public Hashtable SurrogateData { get; }
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContractSet(DataContractSet dataContractSet);
    [NullableContextAttribute("2")]
public DataContractSet(ISerializationSurrogateProvider dataContractSurrogate, IEnumerable`1<Type> referencedTypes, IEnumerable`1<Type> referencedCollectionTypes);
    public Dictionary`2<XmlQualifiedName, DataContract> get_Contracts();
    public Dictionary`2<XmlQualifiedName, DataContract> get_KnownTypesForObject();
    public Dictionary`2<DataContract, object> get_ProcessedContracts();
    public Hashtable get_SurrogateData();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract GetDataContract(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract GetDataContract(XmlQualifiedName key);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public Type GetReferencedType(XmlQualifiedName xmlName, DataContract dataContract, DataContract& referencedContract, Object[]& genericParameters, Nullable`1<bool> supportGenericTypes);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable`1<XmlQualifiedName> typeNames, bool importXmlDataType);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public List`1<XmlQualifiedName> ImportSchemaSet(XmlSchemaSet schemaSet, IEnumerable`1<XmlSchemaElement> elements, bool importXmlDataType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.DataMember : object {
    public bool EmitDefaultValue { get; }
    public bool IsNullable { get; }
    public bool IsRequired { get; }
    public DataContract MemberTypeContract { get; }
    public string Name { get; }
    public long Order { get; }
    public bool get_EmitDefaultValue();
    public bool get_IsNullable();
    public bool get_IsRequired();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public DataContract get_MemberTypeContract();
    public string get_Name();
    public long get_Order();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContracts.XmlDataContract : DataContract {
    public bool HasRoot { get; }
    public bool IsAnonymous { get; }
    public bool IsTopLevelElementNullable { get; }
    public bool IsTypeDefinedOnImport { get; public set; }
    public bool IsValueType { get; public set; }
    public XmlSchemaType XsdType { get; }
    internal XmlDataContract(Type type);
    public bool get_HasRoot();
    public bool get_IsAnonymous();
    public bool get_IsTopLevelElementNullable();
    public bool get_IsTypeDefinedOnImport();
    public void set_IsTypeDefinedOnImport(bool value);
    public bool get_IsValueType();
    public void set_IsValueType(bool value);
    public XmlSchemaType get_XsdType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContractSerializer : XmlObjectSerializer {
    [NullableAttribute("2")]
public DataContractResolver DataContractResolver { get; }
    public bool IgnoreExtensionDataObject { get; }
    public ReadOnlyCollection`1<Type> KnownTypes { get; }
    public int MaxItemsInObjectGraph { get; }
    public bool PreserveObjectReferences { get; }
    public bool SerializeReadOnlyTypes { get; }
    public DataContractSerializer(Type type);
    public DataContractSerializer(Type type, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, DataContractSerializerSettings settings);
    public DataContractSerializer(Type type, string rootName, string rootNamespace);
    public DataContractSerializer(Type type, string rootName, string rootNamespace, IEnumerable`1<Type> knownTypes);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace);
    public DataContractSerializer(Type type, XmlDictionaryString rootName, XmlDictionaryString rootNamespace, IEnumerable`1<Type> knownTypes);
    [NullableContextAttribute("2")]
public DataContractResolver get_DataContractResolver();
    public bool get_IgnoreExtensionDataObject();
    public ReadOnlyCollection`1<Type> get_KnownTypes();
    public int get_MaxItemsInObjectGraph();
    public bool get_PreserveObjectReferences();
    public bool get_SerializeReadOnlyTypes();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlDictionaryReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public object ReadObject(XmlDictionaryReader reader, bool verifyObjectName, DataContractResolver dataContractResolver);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlDictionaryWriter writer);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlWriter writer);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void WriteObject(XmlDictionaryWriter writer, object graph, DataContractResolver dataContractResolver);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlWriter writer, object graph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Runtime.Serialization.DataContractSerializerExtensions : object {
    [ExtensionAttribute]
public static ISerializationSurrogateProvider GetSerializationSurrogateProvider(DataContractSerializer serializer);
    [ExtensionAttribute]
public static void SetSerializationSurrogateProvider(DataContractSerializer serializer, ISerializationSurrogateProvider provider);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.DataContractSerializerSettings : object {
    public DataContractResolver DataContractResolver { get; public set; }
    public bool IgnoreExtensionDataObject { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IEnumerable`1<Type> KnownTypes { get; public set; }
    public int MaxItemsInObjectGraph { get; public set; }
    public bool PreserveObjectReferences { get; public set; }
    public XmlDictionaryString RootName { get; public set; }
    public XmlDictionaryString RootNamespace { get; public set; }
    public bool SerializeReadOnlyTypes { get; public set; }
    public DataContractResolver get_DataContractResolver();
    public void set_DataContractResolver(DataContractResolver value);
    public bool get_IgnoreExtensionDataObject();
    public void set_IgnoreExtensionDataObject(bool value);
    public IEnumerable`1<Type> get_KnownTypes();
    public void set_KnownTypes(IEnumerable`1<Type> value);
    public int get_MaxItemsInObjectGraph();
    public void set_MaxItemsInObjectGraph(int value);
    public bool get_PreserveObjectReferences();
    public void set_PreserveObjectReferences(bool value);
    public XmlDictionaryString get_RootName();
    public void set_RootName(XmlDictionaryString value);
    public XmlDictionaryString get_RootNamespace();
    public void set_RootNamespace(XmlDictionaryString value);
    public bool get_SerializeReadOnlyTypes();
    public void set_SerializeReadOnlyTypes(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.ExportOptions : object {
    [NullableAttribute("1")]
public Collection`1<Type> KnownTypes { get; }
    public ISerializationSurrogateProvider DataContractSurrogate { get; public set; }
    [NullableContextAttribute("1")]
public Collection`1<Type> get_KnownTypes();
    public ISerializationSurrogateProvider get_DataContractSurrogate();
    public void set_DataContractSurrogate(ISerializationSurrogateProvider value);
}
public class System.Runtime.Serialization.ExtensionDataObject : object {
}
[NullableContextAttribute("2")]
public interface System.Runtime.Serialization.IExtensibleDataObject {
    public ExtensionDataObject ExtensionData { get; public set; }
    public abstract virtual ExtensionDataObject get_ExtensionData();
    public abstract virtual void set_ExtensionData(ExtensionDataObject value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Serialization.XmlObjectSerializer : object {
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual bool IsStartObject(XmlDictionaryReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual bool IsStartObject(XmlReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(Stream stream);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlDictionaryReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual object ReadObject(XmlDictionaryReader reader, bool verifyObjectName);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual object ReadObject(XmlReader reader, bool verifyObjectName);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteEndObject(XmlDictionaryWriter writer);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteEndObject(XmlWriter writer);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(Stream stream, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlDictionaryWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObject(XmlWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteObjectContent(XmlDictionaryWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteObjectContent(XmlWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public abstract virtual void WriteStartObject(XmlDictionaryWriter writer, object graph);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public virtual void WriteStartObject(XmlWriter writer, object graph);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.XmlSerializableServices : object {
    public static void AddDefaultSchema(XmlSchemaSet schemas, XmlQualifiedName typeQName);
    public static XmlNode[] ReadNodes(XmlReader xmlReader);
    public static void WriteNodes(XmlWriter xmlWriter, XmlNode[] nodes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.Serialization.XPathQueryGenerator : object {
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, StringBuilder rootElementXpath, XmlNamespaceManager& namespaces);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public static string CreateFromDataContractSerializer(Type type, MemberInfo[] pathToMember, XmlNamespaceManager& namespaces);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.XsdDataContractExporter : object {
    [NullableAttribute("2")]
public ExportOptions Options { get; public set; }
    public XmlSchemaSet Schemas { get; }
    [NullableContextAttribute("2")]
public XsdDataContractExporter(XmlSchemaSet schemas);
    [NullableContextAttribute("2")]
public ExportOptions get_Options();
    [NullableContextAttribute("2")]
public void set_Options(ExportOptions value);
    public XmlSchemaSet get_Schemas();
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(ICollection`1<Assembly> assemblies);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(ICollection`1<Type> types);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public bool CanExport(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(ICollection`1<Assembly> assemblies);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(ICollection`1<Type> types);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public void Export(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlQualifiedName GetRootElementName(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlSchemaType GetSchemaType(Type type);
    [RequiresUnreferencedCodeAttribute("Data Contract Serialization and Deserialization might require types that cannot be statically analyzed. Make sure all of the required types are preserved.")]
public XmlQualifiedName GetSchemaTypeName(Type type);
}
[NullableContextAttribute("1")]
public interface System.Xml.IFragmentCapableXmlDictionaryWriter {
    public bool CanFragment { get; }
    public abstract virtual bool get_CanFragment();
    public abstract virtual void EndFragment();
    public abstract virtual void StartFragment(Stream stream, bool generateSelfContainedTextFragment);
    public abstract virtual void WriteFragment(Byte[] buffer, int offset, int count);
}
[NullableContextAttribute("1")]
public interface System.Xml.IStreamProvider {
    public abstract virtual Stream GetStream();
    public abstract virtual void ReleaseStream(Stream stream);
}
[NullableContextAttribute("2")]
public interface System.Xml.IXmlBinaryReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
}
[NullableContextAttribute("2")]
public interface System.Xml.IXmlBinaryWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlDictionary {
    [NullableContextAttribute("2")]
public abstract virtual bool TryLookup(int key, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(string value, XmlDictionaryString& result);
    public abstract virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlTextReaderInitializer {
    public abstract virtual void SetInput(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public abstract virtual void SetInput(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
}
[NullableContextAttribute("1")]
public interface System.Xml.IXmlTextWriterInitializer {
    public abstract virtual void SetOutput(Stream stream, Encoding encoding, bool ownsStream);
}
public class System.Xml.OnXmlDictionaryReaderClose : MulticastDelegate {
    public OnXmlDictionaryReaderClose(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(XmlDictionaryReader reader);
    public virtual IAsyncResult BeginInvoke(XmlDictionaryReader reader, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.UniqueId : object {
    public int CharArrayLength { get; }
    public bool IsGuid { get; }
    public UniqueId(Byte[] guid);
    public UniqueId(Byte[] guid, int offset);
    public UniqueId(Char[] chars, int offset, int count);
    public UniqueId(Guid guid);
    public UniqueId(string value);
    public int get_CharArrayLength();
    public bool get_IsGuid();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(UniqueId id1, UniqueId id2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(UniqueId id1, UniqueId id2);
    public int ToCharArray(Char[] chars, int offset);
    public virtual string ToString();
    public bool TryGetGuid(Byte[] buffer, int offset);
    public bool TryGetGuid(Guid& guid);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlBinaryReaderSession : object {
    public XmlDictionaryString Add(int id, string value);
    public void Clear();
    [NullableContextAttribute("2")]
public sealed virtual bool TryLookup(int key, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(string value, XmlDictionaryString& result);
    public sealed virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
public class System.Xml.XmlBinaryWriterSession : object {
    public void Reset();
    [NullableContextAttribute("1")]
public virtual bool TryAdd(XmlDictionaryString value, Int32& key);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionary : object {
    public static IXmlDictionary Empty { get; }
    public XmlDictionary(int capacity);
    public static IXmlDictionary get_Empty();
    public virtual XmlDictionaryString Add(string value);
    [NullableContextAttribute("2")]
public virtual bool TryLookup(int key, XmlDictionaryString& result);
    public virtual bool TryLookup(string value, XmlDictionaryString& result);
    public virtual bool TryLookup(XmlDictionaryString value, XmlDictionaryString& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Xml.XmlDictionaryReader : XmlReader {
    public bool CanCanonicalize { get; }
    public XmlDictionaryReaderQuotas Quotas { get; }
    public virtual bool get_CanCanonicalize();
    public virtual XmlDictionaryReaderQuotas get_Quotas();
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, IXmlDictionary dictionary, XmlDictionaryReaderQuotas quotas, XmlBinaryReaderSession session, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateBinaryReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateDictionaryReader(XmlReader reader);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Byte[] buffer, int offset, int count, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, string contentType, XmlDictionaryReaderQuotas quotas, int maxBufferSize, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateMtomReader(Stream stream, Encoding[] encodings, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, int offset, int count, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Byte[] buffer, XmlDictionaryReaderQuotas quotas);
    public static XmlDictionaryReader CreateTextReader(Stream stream, Encoding encoding, XmlDictionaryReaderQuotas quotas, OnXmlDictionaryReaderClose onClose);
    public static XmlDictionaryReader CreateTextReader(Stream stream, XmlDictionaryReaderQuotas quotas);
    public virtual void EndCanonicalization();
    public virtual string GetAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void GetNonAtomizedNames(String& localName, String& namespaceUri);
    public virtual int IndexOfLocalName(String[] localNames, string namespaceUri);
    public virtual int IndexOfLocalName(XmlDictionaryString[] localNames, XmlDictionaryString namespaceUri);
    public virtual bool IsLocalName(string localName);
    public virtual bool IsLocalName(XmlDictionaryString localName);
    public virtual bool IsNamespaceUri(string namespaceUri);
    public virtual bool IsNamespaceUri(XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual bool IsStartArray(Type& type);
    public virtual bool IsStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    protected bool IsTextNode(XmlNodeType nodeType);
    public virtual void MoveToStartElement();
    public virtual void MoveToStartElement(string name);
    public virtual void MoveToStartElement(string localName, string namespaceUri);
    public virtual void MoveToStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadArray(string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual int ReadArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual Boolean[] ReadBooleanArray(string localName, string namespaceUri);
    public virtual Boolean[] ReadBooleanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual object ReadContentAs(Type type, IXmlNamespaceResolver namespaceResolver);
    public virtual Byte[] ReadContentAsBase64();
    public virtual Byte[] ReadContentAsBinHex();
    protected Byte[] ReadContentAsBinHex(int maxByteArrayContentLength);
    public virtual int ReadContentAsChars(Char[] chars, int offset, int count);
    public virtual decimal ReadContentAsDecimal();
    public virtual float ReadContentAsFloat();
    public virtual Guid ReadContentAsGuid();
    public virtual void ReadContentAsQualifiedName(String& localName, String& namespaceUri);
    public virtual string ReadContentAsString();
    protected string ReadContentAsString(int maxStringContentLength);
    public virtual string ReadContentAsString(String[] strings, Int32& index);
    public virtual string ReadContentAsString(XmlDictionaryString[] strings, Int32& index);
    public virtual TimeSpan ReadContentAsTimeSpan();
    public virtual UniqueId ReadContentAsUniqueId();
    public virtual DateTime[] ReadDateTimeArray(string localName, string namespaceUri);
    public virtual DateTime[] ReadDateTimeArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Decimal[] ReadDecimalArray(string localName, string namespaceUri);
    public virtual Decimal[] ReadDecimalArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Double[] ReadDoubleArray(string localName, string namespaceUri);
    public virtual Double[] ReadDoubleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Byte[] ReadElementContentAsBase64();
    public virtual Byte[] ReadElementContentAsBinHex();
    public virtual bool ReadElementContentAsBoolean();
    public virtual DateTime ReadElementContentAsDateTime();
    public virtual decimal ReadElementContentAsDecimal();
    public virtual double ReadElementContentAsDouble();
    public virtual float ReadElementContentAsFloat();
    public virtual Guid ReadElementContentAsGuid();
    public virtual int ReadElementContentAsInt();
    public virtual long ReadElementContentAsLong();
    public virtual string ReadElementContentAsString();
    public virtual TimeSpan ReadElementContentAsTimeSpan();
    public virtual UniqueId ReadElementContentAsUniqueId();
    public virtual void ReadFullStartElement();
    public virtual void ReadFullStartElement(string name);
    public virtual void ReadFullStartElement(string localName, string namespaceUri);
    public virtual void ReadFullStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Guid[] ReadGuidArray(string localName, string namespaceUri);
    public virtual Guid[] ReadGuidArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int16[] ReadInt16Array(string localName, string namespaceUri);
    public virtual Int16[] ReadInt16Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int32[] ReadInt32Array(string localName, string namespaceUri);
    public virtual Int32[] ReadInt32Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Int64[] ReadInt64Array(string localName, string namespaceUri);
    public virtual Int64[] ReadInt64Array(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual Single[] ReadSingleArray(string localName, string namespaceUri);
    public virtual Single[] ReadSingleArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual void ReadStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual string ReadString();
    protected string ReadString(int maxStringContentLength);
    public virtual TimeSpan[] ReadTimeSpanArray(string localName, string namespaceUri);
    public virtual TimeSpan[] ReadTimeSpanArray(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public virtual int ReadValueAsBase64(Byte[] buffer, int offset, int count);
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual bool TryGetArrayLength(Int32& count);
    public virtual bool TryGetBase64ContentLength(Int32& length);
    [NullableContextAttribute("2")]
public virtual bool TryGetLocalNameAsDictionaryString(XmlDictionaryString& localName);
    [NullableContextAttribute("2")]
public virtual bool TryGetNamespaceUriAsDictionaryString(XmlDictionaryString& namespaceUri);
    [NullableContextAttribute("2")]
public virtual bool TryGetValueAsDictionaryString(XmlDictionaryString& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionaryReaderQuotas : object {
    public static XmlDictionaryReaderQuotas Max { get; }
    [DefaultValueAttribute("16384")]
public int MaxArrayLength { get; public set; }
    [DefaultValueAttribute("4096")]
public int MaxBytesPerRead { get; public set; }
    [DefaultValueAttribute("32")]
public int MaxDepth { get; public set; }
    [DefaultValueAttribute("16384")]
public int MaxNameTableCharCount { get; public set; }
    [DefaultValueAttribute("8192")]
public int MaxStringContentLength { get; public set; }
    public XmlDictionaryReaderQuotaTypes ModifiedQuotas { get; }
    public static XmlDictionaryReaderQuotas get_Max();
    public int get_MaxArrayLength();
    public void set_MaxArrayLength(int value);
    public int get_MaxBytesPerRead();
    public void set_MaxBytesPerRead(int value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public int get_MaxNameTableCharCount();
    public void set_MaxNameTableCharCount(int value);
    public int get_MaxStringContentLength();
    public void set_MaxStringContentLength(int value);
    public XmlDictionaryReaderQuotaTypes get_ModifiedQuotas();
    public void CopyTo(XmlDictionaryReaderQuotas quotas);
}
[FlagsAttribute]
public enum System.Xml.XmlDictionaryReaderQuotaTypes : Enum {
    public int value__;
    public static XmlDictionaryReaderQuotaTypes MaxDepth;
    public static XmlDictionaryReaderQuotaTypes MaxStringContentLength;
    public static XmlDictionaryReaderQuotaTypes MaxArrayLength;
    public static XmlDictionaryReaderQuotaTypes MaxBytesPerRead;
    public static XmlDictionaryReaderQuotaTypes MaxNameTableCharCount;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Xml.XmlDictionaryString : object {
    public IXmlDictionary Dictionary { get; }
    public static XmlDictionaryString Empty { get; }
    public int Key { get; }
    public string Value { get; }
    public XmlDictionaryString(IXmlDictionary dictionary, string value, int key);
    public IXmlDictionary get_Dictionary();
    public static XmlDictionaryString get_Empty();
    public int get_Key();
    public string get_Value();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Xml.XmlDictionaryWriter : XmlWriter {
    public bool CanCanonicalize { get; }
    public virtual bool get_CanCanonicalize();
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session);
    public static XmlDictionaryWriter CreateBinaryWriter(Stream stream, IXmlDictionary dictionary, XmlBinaryWriterSession session, bool ownsStream);
    public static XmlDictionaryWriter CreateDictionaryWriter(XmlWriter writer);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo);
    public static XmlDictionaryWriter CreateMtomWriter(Stream stream, Encoding encoding, int maxSizeInBytes, string startInfo, string boundary, string startUri, bool writeMessageHeaders, bool ownsStream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding);
    public static XmlDictionaryWriter CreateTextWriter(Stream stream, Encoding encoding, bool ownsStream);
    public virtual void EndCanonicalization();
    public virtual void StartCanonicalization(Stream stream, bool includeComments, String[] inclusivePrefixes);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, string localName, string namespaceUri, TimeSpan[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Boolean[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, DateTime[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Decimal[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Double[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Guid[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int16[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int32[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Int64[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, Single[] array, int offset, int count);
    public virtual void WriteArray(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, TimeSpan[] array, int offset, int count);
    [NullableContextAttribute("2")]
public void WriteAttributeString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    [NullableContextAttribute("2")]
public void WriteAttributeString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual Task WriteBase64Async(Byte[] buffer, int index, int count);
    [NullableContextAttribute("2")]
public void WriteElementString(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    [NullableContextAttribute("2")]
public void WriteElementString(XmlDictionaryString localName, XmlDictionaryString namespaceUri, string value);
    public virtual void WriteNode(XmlDictionaryReader reader, bool defattr);
    public virtual void WriteNode(XmlReader reader, bool defattr);
    public virtual void WriteQualifiedName(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteStartAttribute(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartAttribute(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteStartElement(string prefix, XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    public void WriteStartElement(XmlDictionaryString localName, XmlDictionaryString namespaceUri);
    [NullableContextAttribute("2")]
public virtual void WriteString(XmlDictionaryString value);
    protected virtual void WriteTextNode(XmlDictionaryReader reader, bool isAttribute);
    public virtual void WriteValue(Guid value);
    public virtual void WriteValue(TimeSpan value);
    public virtual void WriteValue(IStreamProvider value);
    public virtual void WriteValue(UniqueId value);
    [NullableContextAttribute("2")]
public virtual void WriteValue(XmlDictionaryString value);
    public virtual Task WriteValueAsync(IStreamProvider value);
    public virtual void WriteXmlAttribute(string localName, string value);
    public virtual void WriteXmlAttribute(XmlDictionaryString localName, XmlDictionaryString value);
    public virtual void WriteXmlnsAttribute(string prefix, string namespaceUri);
    public virtual void WriteXmlnsAttribute(string prefix, XmlDictionaryString namespaceUri);
}
