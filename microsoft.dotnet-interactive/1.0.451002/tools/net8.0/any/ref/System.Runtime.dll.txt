[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.CriticalHandleZeroOrMinusOneIsInvalid : CriticalHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeFileHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public bool IsInvalid { get; }
    public bool IsAsync { get; }
    public SafeFileHandle(IntPtr preexistingHandle, bool ownsHandle);
    public virtual bool get_IsInvalid();
    public bool get_IsAsync();
    protected virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public abstract class Microsoft.Win32.SafeHandles.SafeHandleZeroOrMinusOneIsInvalid : SafeHandle {
    public bool IsInvalid { get; }
    protected SafeHandleZeroOrMinusOneIsInvalid(bool ownsHandle);
    public virtual bool get_IsInvalid();
}
public class Microsoft.Win32.SafeHandles.SafeWaitHandle : SafeHandleZeroOrMinusOneIsInvalid {
    public SafeWaitHandle(IntPtr existingHandle, bool ownsHandle);
    protected virtual bool ReleaseHandle();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AccessViolationException : SystemException {
    [NullableContextAttribute("1")]
protected AccessViolationException(SerializationInfo info, StreamingContext context);
    public AccessViolationException(string message);
    public AccessViolationException(string message, Exception innerException);
}
public class System.Action : MulticastDelegate {
    public Action(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`1 : MulticastDelegate {
    public Action`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`10 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`10(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`11 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`11(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`12 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`12(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`13 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`13(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`14 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`14(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`15 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`15(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`16 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`16(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`2 : MulticastDelegate {
    public Action`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Action`3 : MulticastDelegate {
    public Action`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`4 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Action`9 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Action`9(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Activator : object {
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    public static object CreateInstance(Type type);
    public static object CreateInstance(Type type, bool nonPublic);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, Object[] args);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, Object[] args, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture);
    [NullableContextAttribute("2")]
public static object CreateInstance(Type type, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public static ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    public static T CreateInstance();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AggregateException : Exception {
    public ReadOnlyCollection`1<Exception> InnerExceptions { get; }
    public string Message { get; }
    public AggregateException(IEnumerable`1<Exception> innerExceptions);
    public AggregateException(Exception[] innerExceptions);
    protected AggregateException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public AggregateException(string message);
    public AggregateException(string message, IEnumerable`1<Exception> innerExceptions);
    public AggregateException(string message, Exception innerException);
    public AggregateException(string message, Exception[] innerExceptions);
    public ReadOnlyCollection`1<Exception> get_InnerExceptions();
    public virtual string get_Message();
    public AggregateException Flatten();
    public virtual Exception GetBaseException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void Handle(Func`2<Exception, bool> predicate);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.AppContext : object {
    public static string BaseDirectory { get; }
    [NullableAttribute("2")]
public static string TargetFrameworkName { get; }
    public static string get_BaseDirectory();
    [NullableContextAttribute("2")]
public static string get_TargetFrameworkName();
    public static object GetData(string name);
    public static void SetData(string name, object data);
    public static void SetSwitch(string switchName, bool isEnabled);
    public static bool TryGetSwitch(string switchName, Boolean& isEnabled);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AppDomain : MarshalByRefObject {
    public string BaseDirectory { get; }
    public static AppDomain CurrentDomain { get; }
    [NullableAttribute("2")]
public string DynamicDirectory { get; }
    public string FriendlyName { get; }
    public int Id { get; }
    public bool IsFullyTrusted { get; }
    public bool IsHomogenous { get; }
    public static bool MonitoringIsEnabled { get; public set; }
    public long MonitoringSurvivedMemorySize { get; }
    public static long MonitoringSurvivedProcessMemorySize { get; }
    public long MonitoringTotalAllocatedMemorySize { get; }
    public TimeSpan MonitoringTotalProcessorTime { get; }
    [ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public PermissionSet PermissionSet { get; }
    [NullableAttribute("2")]
public string RelativeSearchPath { get; }
    public AppDomainSetup SetupInformation { get; }
    public bool ShadowCopyFiles { get; }
    public string get_BaseDirectory();
    public static AppDomain get_CurrentDomain();
    [NullableContextAttribute("2")]
public string get_DynamicDirectory();
    public string get_FriendlyName();
    public int get_Id();
    public bool get_IsFullyTrusted();
    public bool get_IsHomogenous();
    public static bool get_MonitoringIsEnabled();
    public static void set_MonitoringIsEnabled(bool value);
    public long get_MonitoringSurvivedMemorySize();
    public static long get_MonitoringSurvivedProcessMemorySize();
    public long get_MonitoringTotalAllocatedMemorySize();
    public TimeSpan get_MonitoringTotalProcessorTime();
    public PermissionSet get_PermissionSet();
    [NullableContextAttribute("2")]
public string get_RelativeSearchPath();
    public AppDomainSetup get_SetupInformation();
    public bool get_ShadowCopyFiles();
    [NullableContextAttribute("2")]
public void add_AssemblyLoad(AssemblyLoadEventHandler value);
    [NullableContextAttribute("2")]
public void remove_AssemblyLoad(AssemblyLoadEventHandler value);
    [NullableContextAttribute("2")]
public void add_AssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_AssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_DomainUnload(EventHandler value);
    [NullableContextAttribute("2")]
public void remove_DomainUnload(EventHandler value);
    public void add_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    public void remove_FirstChanceException(EventHandler`1<FirstChanceExceptionEventArgs> value);
    [NullableContextAttribute("2")]
public void add_ProcessExit(EventHandler value);
    [NullableContextAttribute("2")]
public void remove_ProcessExit(EventHandler value);
    [NullableContextAttribute("2")]
public void add_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_ReflectionOnlyAssemblyResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_ResourceResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_ResourceResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_TypeResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void remove_TypeResolve(ResolveEventHandler value);
    [NullableContextAttribute("2")]
public void add_UnhandledException(UnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
public void remove_UnhandledException(UnhandledExceptionEventHandler value);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.AppendPrivatePath has been deprecated and is not supported.")]
public void AppendPrivatePath(string path);
    public string ApplyPolicy(string assemblyName);
    [ObsoleteAttribute("AppDomain.ClearPrivatePath has been deprecated and is not supported.")]
public void ClearPrivatePath();
    [ObsoleteAttribute("AppDomain.ClearShadowCopyPath has been deprecated and is not supported.")]
public void ClearShadowCopyPath();
    [ObsoleteAttribute("Creating and unloading AppDomains is not supported and throws an exception.")]
public static AppDomain CreateDomain(string friendlyName);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstance(string assemblyName, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceAndUnwrap(string assemblyName, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public ObjectHandle CreateInstanceFrom(string assemblyFile, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Type and its constructor could be removed")]
public object CreateInstanceFromAndUnwrap(string assemblyFile, string typeName, Object[] activationAttributes);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public int ExecuteAssembly(string assemblyFile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public int ExecuteAssembly(string assemblyFile, String[] args);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public int ExecuteAssembly(string assemblyFile, String[] args, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    public int ExecuteAssemblyByName(AssemblyName assemblyName, String[] args);
    public int ExecuteAssemblyByName(string assemblyName);
    public int ExecuteAssemblyByName(string assemblyName, String[] args);
    public Assembly[] GetAssemblies();
    [ObsoleteAttribute("AppDomain.GetCurrentThreadId has been deprecated because it does not provide a stable Id when managed threads are running on fibers (aka lightweight threads). To get a stable identifier for a managed thread, use the ManagedThreadId property on Thread instead.")]
public static int GetCurrentThreadId();
    public object GetData(string name);
    public Nullable`1<bool> IsCompatibilitySwitchSet(string value);
    public bool IsDefaultAppDomain();
    public bool IsFinalizingForUnload();
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly Load(Byte[] rawAssembly);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public Assembly Load(AssemblyName assemblyRef);
    public Assembly Load(string assemblyString);
    public Assembly[] ReflectionOnlyGetAssemblies();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetCachePath has been deprecated and is not supported.")]
public void SetCachePath(string path);
    public void SetData(string name, object data);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetDynamicBase has been deprecated and is not supported.")]
public void SetDynamicBase(string path);
    public void SetPrincipalPolicy(PrincipalPolicy policy);
    [ObsoleteAttribute("AppDomain.SetShadowCopyFiles has been deprecated and is not supported.")]
public void SetShadowCopyFiles();
    [NullableContextAttribute("2")]
[ObsoleteAttribute("AppDomain.SetShadowCopyPath has been deprecated and is not supported.")]
public void SetShadowCopyPath(string path);
    public void SetThreadPrincipal(IPrincipal principal);
    public virtual string ToString();
    [ObsoleteAttribute("Creating and unloading AppDomains is not supported and throws an exception.")]
public static void Unload(AppDomain domain);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AppDomainSetup : object {
    public string ApplicationBase { get; }
    public string TargetFrameworkName { get; }
    public string get_ApplicationBase();
    public string get_TargetFrameworkName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.AppDomainUnloadedException : SystemException {
    [NullableContextAttribute("1")]
protected AppDomainUnloadedException(SerializationInfo info, StreamingContext context);
    public AppDomainUnloadedException(string message);
    public AppDomainUnloadedException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ApplicationException : Exception {
    [NullableContextAttribute("1")]
protected ApplicationException(SerializationInfo info, StreamingContext context);
    public ApplicationException(string message);
    public ApplicationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ApplicationId : object {
    [NullableAttribute("2")]
public string Culture { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string ProcessorArchitecture { get; }
    public Byte[] PublicKeyToken { get; }
    public Version Version { get; }
    public ApplicationId(Byte[] publicKeyToken, string name, Version version, string processorArchitecture, string culture);
    [NullableContextAttribute("2")]
public string get_Culture();
    public string get_Name();
    [NullableContextAttribute("2")]
public string get_ProcessorArchitecture();
    public Byte[] get_PublicKeyToken();
    public Version get_Version();
    public ApplicationId Copy();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[IsByRefLikeAttribute]
public class System.ArgIterator : ValueType {
    private int _dummyPrimitive;
    public ArgIterator(RuntimeArgumentHandle arglist);
    [CLSCompliantAttribute("False")]
public ArgIterator(RuntimeArgumentHandle arglist, Void* ptr);
    public void End();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg();
    [CLSCompliantAttribute("False")]
public TypedReference GetNextArg(RuntimeTypeHandle rth);
    public RuntimeTypeHandle GetNextArgType();
    public int GetRemainingCount();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArgumentException : SystemException {
    [NullableAttribute("1")]
public string Message { get; }
    public string ParamName { get; }
    [NullableContextAttribute("1")]
protected ArgumentException(SerializationInfo info, StreamingContext context);
    public ArgumentException(string message);
    public ArgumentException(string message, Exception innerException);
    public ArgumentException(string message, string paramName);
    public ArgumentException(string message, string paramName, Exception innerException);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    public virtual string get_ParamName();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static void ThrowIfNullOrEmpty(string argument, string paramName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArgumentNullException : ArgumentException {
    [NullableContextAttribute("1")]
protected ArgumentNullException(SerializationInfo info, StreamingContext context);
    public ArgumentNullException(string paramName);
    public ArgumentNullException(string message, Exception innerException);
    public ArgumentNullException(string paramName, string message);
    public static void ThrowIfNull(object argument, string paramName);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void ThrowIfNull(Void* argument, string paramName);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArgumentOutOfRangeException : ArgumentException {
    public object ActualValue { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected ArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public ArgumentOutOfRangeException(string paramName);
    public ArgumentOutOfRangeException(string message, Exception innerException);
    public ArgumentOutOfRangeException(string paramName, object actualValue, string message);
    public ArgumentOutOfRangeException(string paramName, string message);
    public virtual object get_ActualValue();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArithmeticException : SystemException {
    [NullableContextAttribute("1")]
protected ArithmeticException(SerializationInfo info, StreamingContext context);
    public ArithmeticException(string message);
    public ArithmeticException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Array : object {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public int Length { get; }
    public long LongLength { get; }
    public static int MaxLength { get; }
    public int Rank { get; }
    public object SyncRoot { get; }
    private int System.Collections.ICollection.Count { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public sealed virtual bool get_IsFixedSize();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool get_IsSynchronized();
    public int get_Length();
    public long get_LongLength();
    public static int get_MaxLength();
    public int get_Rank();
    public sealed virtual object get_SyncRoot();
    private sealed virtual override int System.Collections.ICollection.get_Count();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public static ReadOnlyCollection`1<T> AsReadOnly(T[] array);
    public static int BinarySearch(Array array, int index, int length, object value);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, int index, int length, object value, IComparer comparer);
    public static int BinarySearch(Array array, object value);
    [NullableContextAttribute("2")]
public static int BinarySearch(Array array, object value, IComparer comparer);
    public static int BinarySearch(T[] array, int index, int length, T value);
    public static int BinarySearch(T[] array, int index, int length, T value, IComparer`1<T> comparer);
    public static int BinarySearch(T[] array, T value);
    public static int BinarySearch(T[] array, T value, IComparer`1<T> comparer);
    public static void Clear(Array array);
    public static void Clear(Array array, int index, int length);
    public sealed virtual object Clone();
    public static void ConstrainedCopy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static TOutput[] ConvertAll(TInput[] array, Converter`2<TInput, TOutput> converter);
    public static void Copy(Array sourceArray, Array destinationArray, int length);
    public static void Copy(Array sourceArray, Array destinationArray, long length);
    public static void Copy(Array sourceArray, int sourceIndex, Array destinationArray, int destinationIndex, int length);
    public static void Copy(Array sourceArray, long sourceIndex, Array destinationArray, long destinationIndex, long length);
    public sealed virtual void CopyTo(Array array, int index);
    public void CopyTo(Array array, long index);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, int length);
    public static Array CreateInstance(Type elementType, int length1, int length2);
    public static Array CreateInstance(Type elementType, int length1, int length2, int length3);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int32[] lengths);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int32[] lengths, Int32[] lowerBounds);
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public static Array CreateInstance(Type elementType, Int64[] lengths);
    public static T[] Empty();
    public static bool Exists(T[] array, Predicate`1<T> match);
    public static void Fill(T[] array, T value);
    public static void Fill(T[] array, T value, int startIndex, int count);
    public static T[] FindAll(T[] array, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindIndex(T[] array, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, int count, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, int startIndex, Predicate`1<T> match);
    public static int FindLastIndex(T[] array, Predicate`1<T> match);
    public static T FindLast(T[] array, Predicate`1<T> match);
    public static T Find(T[] array, Predicate`1<T> match);
    public static void ForEach(T[] array, Action`1<T> action);
    public sealed virtual IEnumerator GetEnumerator();
    public int GetLength(int dimension);
    public long GetLongLength(int dimension);
    public int GetLowerBound(int dimension);
    public int GetUpperBound(int dimension);
    [NullableContextAttribute("2")]
public object GetValue(int index);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2);
    [NullableContextAttribute("2")]
public object GetValue(int index1, int index2, int index3);
    public object GetValue(Int32[] indices);
    [NullableContextAttribute("2")]
public object GetValue(long index);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2);
    [NullableContextAttribute("2")]
public object GetValue(long index1, long index2, long index3);
    public object GetValue(Int64[] indices);
    public static int IndexOf(Array array, object value);
    public static int IndexOf(Array array, object value, int startIndex);
    public static int IndexOf(Array array, object value, int startIndex, int count);
    public static int IndexOf(T[] array, T value);
    public static int IndexOf(T[] array, T value, int startIndex);
    public static int IndexOf(T[] array, T value, int startIndex, int count);
    public void Initialize();
    public static int LastIndexOf(Array array, object value);
    public static int LastIndexOf(Array array, object value, int startIndex);
    public static int LastIndexOf(Array array, object value, int startIndex, int count);
    public static int LastIndexOf(T[] array, T value);
    public static int LastIndexOf(T[] array, T value, int startIndex);
    public static int LastIndexOf(T[] array, T value, int startIndex, int count);
    [NullableContextAttribute("2")]
public static void Resize(T[]& array, int newSize);
    public static void Reverse(Array array);
    public static void Reverse(Array array, int index, int length);
    public static void Reverse(T[] array);
    public static void Reverse(T[] array, int index, int length);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, int index1, int index2, int index3);
    public void SetValue(object value, Int32[] indices);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2);
    [NullableContextAttribute("2")]
public void SetValue(object value, long index1, long index2, long index3);
    public void SetValue(object value, Int64[] indices);
    public static void Sort(Array array);
    public static void Sort(Array keys, Array items);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, IComparer comparer);
    public static void Sort(Array keys, Array items, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(Array keys, Array items, int index, int length, IComparer comparer);
    public static void Sort(Array array, IComparer comparer);
    public static void Sort(Array array, int index, int length);
    public static void Sort(Array array, int index, int length, IComparer comparer);
    public static void Sort(T[] array);
    public static void Sort(T[] array, IComparer`1<T> comparer);
    public static void Sort(T[] array, Comparison`1<T> comparison);
    public static void Sort(T[] array, int index, int length);
    public static void Sort(T[] array, int index, int length, IComparer`1<T> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, IComparer`1<TKey> comparer);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length);
    [NullableContextAttribute("2")]
public static void Sort(TKey[] keys, TValue[] items, int index, int length, IComparer`1<TKey> comparer);
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    public static bool TrueForAll(T[] array, Predicate`1<T> match);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.ArraySegment`1 : ValueType {
    private T[] _array;
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public T[] Array { get; }
    public int Count { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ArraySegment`1<T> Empty { get; }
    public T Item { get; public set; }
    public int Offset { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private T System.Collections.Generic.IReadOnlyList<T>.Item { get; }
    public ArraySegment`1(T[] array);
    public ArraySegment`1(T[] array, int offset, int count);
    public T[] get_Array();
    public sealed virtual int get_Count();
    public static ArraySegment`1<T> get_Empty();
    public T get_Item(int index);
    public void set_Item(int index, T value);
    public int get_Offset();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override T System.Collections.Generic.IReadOnlyList<T>.get_Item(int index);
    public void CopyTo(ArraySegment`1<T> destination);
    public void CopyTo(T[] destination);
    public sealed virtual void CopyTo(T[] destination, int destinationIndex);
    public bool Equals(ArraySegment`1<T> obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    public virtual int GetHashCode();
    public static bool op_Equality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public static ArraySegment`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(ArraySegment`1<T> a, ArraySegment`1<T> b);
    public ArraySegment`1<T> Slice(int index);
    public ArraySegment`1<T> Slice(int index, int count);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Contains(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override int System.Collections.Generic.IList<T>.IndexOf(T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T item);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public T[] ToArray();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ArrayTypeMismatchException : SystemException {
    [NullableContextAttribute("1")]
protected ArrayTypeMismatchException(SerializationInfo info, StreamingContext context);
    public ArrayTypeMismatchException(string message);
    public ArrayTypeMismatchException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.AssemblyLoadEventArgs : EventArgs {
    public Assembly LoadedAssembly { get; }
    public AssemblyLoadEventArgs(Assembly loadedAssembly);
    public Assembly get_LoadedAssembly();
}
public class System.AssemblyLoadEventHandler : MulticastDelegate {
    public AssemblyLoadEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, AssemblyLoadEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, AssemblyLoadEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.AsyncCallback : MulticastDelegate {
    public AsyncCallback(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(IAsyncResult ar);
    public virtual IAsyncResult BeginInvoke(IAsyncResult ar, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public abstract class System.Attribute : object {
    public object TypeId { get; }
    public virtual object get_TypeId();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    public static Attribute GetCustomAttribute(Assembly element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(Module element, Type attributeType);
    public static Attribute GetCustomAttribute(Module element, Type attributeType, bool inherit);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element);
    public static Attribute[] GetCustomAttributes(Assembly element, bool inherit);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Assembly element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element);
    public static Attribute[] GetCustomAttributes(MemberInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element);
    public static Attribute[] GetCustomAttributes(Module element, bool inherit);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType);
    public static Attribute[] GetCustomAttributes(Module element, Type attributeType, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, bool inherit);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType);
    public static Attribute[] GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    public virtual int GetHashCode();
    public virtual bool IsDefaultAttribute();
    public static bool IsDefined(Assembly element, Type attributeType);
    public static bool IsDefined(Assembly element, Type attributeType, bool inherit);
    public static bool IsDefined(MemberInfo element, Type attributeType);
    public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    public static bool IsDefined(Module element, Type attributeType);
    public static bool IsDefined(Module element, Type attributeType, bool inherit);
    public static bool IsDefined(ParameterInfo element, Type attributeType);
    public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
    [NullableContextAttribute("2")]
public virtual bool Match(object obj);
}
[FlagsAttribute]
public enum System.AttributeTargets : Enum {
    public int value__;
    public static AttributeTargets Assembly;
    public static AttributeTargets Module;
    public static AttributeTargets Class;
    public static AttributeTargets Struct;
    public static AttributeTargets Enum;
    public static AttributeTargets Constructor;
    public static AttributeTargets Method;
    public static AttributeTargets Property;
    public static AttributeTargets Field;
    public static AttributeTargets Event;
    public static AttributeTargets Interface;
    public static AttributeTargets Parameter;
    public static AttributeTargets Delegate;
    public static AttributeTargets ReturnValue;
    public static AttributeTargets GenericParameter;
    public static AttributeTargets All;
}
[AttributeUsageAttribute("4")]
public class System.AttributeUsageAttribute : Attribute {
    public bool AllowMultiple { get; public set; }
    public bool Inherited { get; public set; }
    public AttributeTargets ValidOn { get; }
    public AttributeUsageAttribute(AttributeTargets validOn);
    public bool get_AllowMultiple();
    public void set_AllowMultiple(bool value);
    public bool get_Inherited();
    public void set_Inherited(bool value);
    public AttributeTargets get_ValidOn();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.BadImageFormatException : SystemException {
    public string FileName { get; }
    public string FusionLog { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected BadImageFormatException(SerializationInfo info, StreamingContext context);
    public BadImageFormatException(string message);
    public BadImageFormatException(string message, Exception inner);
    public BadImageFormatException(string message, string fileName);
    public BadImageFormatException(string message, string fileName, Exception inner);
    public string get_FileName();
    public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.Base64FormattingOptions : Enum {
    public int value__;
    public static Base64FormattingOptions None;
    public static Base64FormattingOptions InsertLineBreaks;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.BitConverter : object {
    public static bool IsLittleEndian;
    public static long DoubleToInt64Bits(double value);
    [CLSCompliantAttribute("False")]
public static ulong DoubleToUInt64Bits(double value);
    public static Byte[] GetBytes(bool value);
    public static Byte[] GetBytes(char value);
    public static Byte[] GetBytes(double value);
    public static Byte[] GetBytes(Half value);
    public static Byte[] GetBytes(short value);
    public static Byte[] GetBytes(int value);
    public static Byte[] GetBytes(long value);
    public static Byte[] GetBytes(float value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ushort value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Byte[] GetBytes(ulong value);
    public static short HalfToInt16Bits(Half value);
    [CLSCompliantAttribute("False")]
public static ushort HalfToUInt16Bits(Half value);
    public static Half Int16BitsToHalf(short value);
    public static float Int32BitsToSingle(int value);
    public static double Int64BitsToDouble(long value);
    public static int SingleToInt32Bits(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 SingleToUInt32Bits(float value);
    public static bool ToBoolean(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static bool ToBoolean(ReadOnlySpan`1<byte> value);
    public static char ToChar(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static char ToChar(ReadOnlySpan`1<byte> value);
    public static double ToDouble(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static double ToDouble(ReadOnlySpan`1<byte> value);
    public static Half ToHalf(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static Half ToHalf(ReadOnlySpan`1<byte> value);
    public static short ToInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static short ToInt16(ReadOnlySpan`1<byte> value);
    public static int ToInt32(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static int ToInt32(ReadOnlySpan`1<byte> value);
    public static long ToInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static long ToInt64(ReadOnlySpan`1<byte> value);
    public static float ToSingle(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
public static float ToSingle(ReadOnlySpan`1<byte> value);
    public static string ToString(Byte[] value);
    public static string ToString(Byte[] value, int startIndex);
    public static string ToString(Byte[] value, int startIndex, int length);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ushort ToUInt16(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ReadOnlySpan`1<byte> value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(Byte[] value, int startIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static ulong ToUInt64(ReadOnlySpan`1<byte> value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, bool value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, char value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, double value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, Half value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, short value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, int value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, long value);
    [NullableContextAttribute("0")]
public static bool TryWriteBytes(Span`1<byte> destination, float value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ushort value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, UInt32 value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static bool TryWriteBytes(Span`1<byte> destination, ulong value);
    [CLSCompliantAttribute("False")]
public static Half UInt16BitsToHalf(ushort value);
    [CLSCompliantAttribute("False")]
public static float UInt32BitsToSingle(UInt32 value);
    [CLSCompliantAttribute("False")]
public static double UInt64BitsToDouble(ulong value);
}
[IsReadOnlyAttribute]
public class System.Boolean : ValueType {
    private bool _dummyPrimitive;
    [NullableAttribute("1")]
public static string FalseString;
    [NullableAttribute("1")]
public static string TrueString;
    public sealed virtual int CompareTo(bool value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual bool Equals(bool obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static bool Parse(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public static bool Parse(string value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    public static bool TryParse(ReadOnlySpan`1<char> value, Boolean& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string value, Boolean& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Buffer : object {
    public static void BlockCopy(Array src, int srcOffset, Array dst, int dstOffset, int count);
    public static int ByteLength(Array array);
    public static byte GetByte(Array array, int index);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, long destinationSizeInBytes, long sourceBytesToCopy);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void MemoryCopy(Void* source, Void* destination, ulong destinationSizeInBytes, ulong sourceBytesToCopy);
    public static void SetByte(Array array, int index, byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Buffers.ArrayPool`1 : object {
    public static ArrayPool`1<T> Shared { get; }
    public static ArrayPool`1<T> get_Shared();
    public static ArrayPool`1<T> Create();
    public static ArrayPool`1<T> Create(int maxArrayLength, int maxArraysPerBucket);
    public abstract virtual T[] Rent(int minimumLength);
    public abstract virtual void Return(T[] array, bool clearArray);
}
public interface System.Buffers.IMemoryOwner`1 {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public abstract virtual Memory`1<T> get_Memory();
}
public interface System.Buffers.IPinnable {
    public abstract virtual MemoryHandle Pin(int elementIndex);
    public abstract virtual void Unpin();
}
public class System.Buffers.MemoryHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [CLSCompliantAttribute("False")]
public Void* Pointer { get; }
    [CLSCompliantAttribute("False")]
public MemoryHandle(Void* pointer, GCHandle handle, IPinnable pinnable);
    public Void* get_Pointer();
    public sealed virtual void Dispose();
}
public abstract class System.Buffers.MemoryManager`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Memory`1<T> Memory { get; }
    public virtual Memory`1<T> get_Memory();
    protected Memory`1<T> CreateMemory(int length);
    protected Memory`1<T> CreateMemory(int start, int length);
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual Span`1<T> GetSpan();
    public abstract virtual MemoryHandle Pin(int elementIndex);
    private sealed virtual override void System.IDisposable.Dispose();
    protected internal virtual bool TryGetArray(ArraySegment`1& segment);
    public abstract virtual void Unpin();
}
public enum System.Buffers.OperationStatus : Enum {
    public int value__;
    public static OperationStatus Done;
    public static OperationStatus DestinationTooSmall;
    public static OperationStatus NeedMoreData;
    public static OperationStatus InvalidData;
}
public class System.Buffers.ReadOnlySpanAction`2 : MulticastDelegate {
    public ReadOnlySpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(ReadOnlySpan`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(ReadOnlySpan`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Buffers.SpanAction`2 : MulticastDelegate {
    public SpanAction`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(Span`1<T> span, TArg arg);
    public virtual IAsyncResult BeginInvoke(Span`1<T> span, TArg arg, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public static class System.Buffers.Text.Base64 : object {
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> utf8, Span`1<byte> bytes, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static OperationStatus DecodeFromUtf8InPlace(Span`1<byte> buffer, Int32& bytesWritten);
    public static OperationStatus EncodeToUtf8(ReadOnlySpan`1<byte> bytes, Span`1<byte> utf8, Int32& bytesConsumed, Int32& bytesWritten, bool isFinalBlock);
    public static OperationStatus EncodeToUtf8InPlace(Span`1<byte> buffer, int dataLength, Int32& bytesWritten);
    public static int GetMaxDecodedFromUtf8Length(int length);
    public static int GetMaxEncodedToUtf8Length(int length);
}
[IsReadOnlyAttribute]
public class System.Byte : ValueType {
    private byte _dummyPrimitive;
    public static byte MaxValue;
    public static byte MinValue;
    private static byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.AdditiveIdentity { get; }
    private static byte System.Numerics.IBinaryNumber<System.Byte>.AllBitsSet { get; }
    private static byte System.Numerics.IMinMaxValue<System.Byte>.MaxValue { get; }
    private static byte System.Numerics.IMinMaxValue<System.Byte>.MinValue { get; }
    private static byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.MultiplicativeIdentity { get; }
    private static byte System.Numerics.INumberBase<System.Byte>.One { get; }
    private static int System.Numerics.INumberBase<System.Byte>.Radix { get; }
    private static byte System.Numerics.INumberBase<System.Byte>.Zero { get; }
    private static override byte System.Numerics.IAdditiveIdentity<System.Byte,System.Byte>.get_AdditiveIdentity();
    private static override byte System.Numerics.IBinaryNumber<System.Byte>.get_AllBitsSet();
    private static override byte System.Numerics.IMinMaxValue<System.Byte>.get_MaxValue();
    private static override byte System.Numerics.IMinMaxValue<System.Byte>.get_MinValue();
    private static override byte System.Numerics.IMultiplicativeIdentity<System.Byte,System.Byte>.get_MultiplicativeIdentity();
    private static override byte System.Numerics.INumberBase<System.Byte>.get_One();
    private static override int System.Numerics.INumberBase<System.Byte>.get_Radix();
    private static override byte System.Numerics.INumberBase<System.Byte>.get_Zero();
    public static override byte Clamp(byte value, byte min, byte max);
    public sealed virtual int CompareTo(byte value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    [NullableContextAttribute("1")]
public static override byte CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override byte CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override byte CreateTruncating(TOther value);
    public static override ValueTuple`2<byte, byte> DivRem(byte left, byte right);
    public sealed virtual bool Equals(byte obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(byte value);
    public static override bool IsOddInteger(byte value);
    public static override bool IsPow2(byte value);
    public static override byte LeadingZeroCount(byte value);
    public static override byte Log2(byte value);
    public static override byte Max(byte x, byte y);
    public static override byte Min(byte x, byte y);
    public static override byte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override byte Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static byte Parse(string s);
    [NullableContextAttribute("1")]
public static byte Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override byte Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override byte Parse(string s, IFormatProvider provider);
    public static override byte PopCount(byte value);
    public static override byte RotateLeft(byte value, int rotateAmount);
    public static override byte RotateRight(byte value, int rotateAmount);
    public static override int Sign(byte value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override byte System.Numerics.IAdditionOperators<System.Byte,System.Byte,System.Byte>.op_Addition(byte left, byte right);
    private static override byte System.Numerics.IAdditionOperators<System.Byte,System.Byte,System.Byte>.op_CheckedAddition(byte left, byte right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Byte>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Byte>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.Byte>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Byte& value);
    private static override bool System.Numerics.IBinaryInteger<System.Byte>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Byte& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Byte>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_BitwiseAnd(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_BitwiseOr(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_ExclusiveOr(byte left, byte right);
    private static override byte System.Numerics.IBitwiseOperators<System.Byte,System.Byte,System.Byte>.op_OnesComplement(byte value);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_GreaterThan(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_GreaterThanOrEqual(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_LessThan(byte left, byte right);
    private static override bool System.Numerics.IComparisonOperators<System.Byte,System.Byte,System.Boolean>.op_LessThanOrEqual(byte left, byte right);
    private static override byte System.Numerics.IDecrementOperators<System.Byte>.op_CheckedDecrement(byte value);
    private static override byte System.Numerics.IDecrementOperators<System.Byte>.op_Decrement(byte value);
    private static override byte System.Numerics.IDivisionOperators<System.Byte,System.Byte,System.Byte>.op_Division(byte left, byte right);
    private static override bool System.Numerics.IEqualityOperators<System.Byte,System.Byte,System.Boolean>.op_Equality(byte left, byte right);
    private static override bool System.Numerics.IEqualityOperators<System.Byte,System.Byte,System.Boolean>.op_Inequality(byte left, byte right);
    private static override byte System.Numerics.IIncrementOperators<System.Byte>.op_CheckedIncrement(byte value);
    private static override byte System.Numerics.IIncrementOperators<System.Byte>.op_Increment(byte value);
    private static override byte System.Numerics.IModulusOperators<System.Byte,System.Byte,System.Byte>.op_Modulus(byte left, byte right);
    private static override byte System.Numerics.IMultiplyOperators<System.Byte,System.Byte,System.Byte>.op_CheckedMultiply(byte left, byte right);
    private static override byte System.Numerics.IMultiplyOperators<System.Byte,System.Byte,System.Byte>.op_Multiply(byte left, byte right);
    private static override byte System.Numerics.INumberBase<System.Byte>.Abs(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsCanonical(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsComplexNumber(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsFinite(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsImaginaryNumber(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsInteger(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNaN(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNegative(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNegativeInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsNormal(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsPositive(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsPositiveInfinity(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsRealNumber(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsSubnormal(byte value);
    private static override bool System.Numerics.INumberBase<System.Byte>.IsZero(byte value);
    private static override byte System.Numerics.INumberBase<System.Byte>.MaxMagnitude(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MaxMagnitudeNumber(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MinMagnitude(byte x, byte y);
    private static override byte System.Numerics.INumberBase<System.Byte>.MinMagnitudeNumber(byte x, byte y);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromChecked(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromSaturating(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertFromTruncating(TOther value, Byte& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToChecked(byte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToSaturating(byte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Byte>.TryConvertToTruncating(byte value, TOther& result);
    private static override byte System.Numerics.INumber<System.Byte>.CopySign(byte value, byte sign);
    private static override byte System.Numerics.INumber<System.Byte>.MaxNumber(byte x, byte y);
    private static override byte System.Numerics.INumber<System.Byte>.MinNumber(byte x, byte y);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_LeftShift(byte value, int shiftAmount);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_RightShift(byte value, int shiftAmount);
    private static override byte System.Numerics.IShiftOperators<System.Byte,System.Int32,System.Byte>.op_UnsignedRightShift(byte value, int shiftAmount);
    private static override byte System.Numerics.ISubtractionOperators<System.Byte,System.Byte,System.Byte>.op_CheckedSubtraction(byte left, byte right);
    private static override byte System.Numerics.ISubtractionOperators<System.Byte,System.Byte,System.Byte>.op_Subtraction(byte left, byte right);
    private static override byte System.Numerics.IUnaryNegationOperators<System.Byte,System.Byte>.op_CheckedUnaryNegation(byte value);
    private static override byte System.Numerics.IUnaryNegationOperators<System.Byte,System.Byte>.op_UnaryNegation(byte value);
    private static override byte System.Numerics.IUnaryPlusOperators<System.Byte,System.Byte>.op_UnaryPlus(byte value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override byte TrailingZeroCount(byte value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, Byte& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Byte& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Byte& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Byte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Byte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Byte& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.CannotUnloadAppDomainException : SystemException {
    [NullableContextAttribute("1")]
protected CannotUnloadAppDomainException(SerializationInfo info, StreamingContext context);
    public CannotUnloadAppDomainException(string message);
    public CannotUnloadAppDomainException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Char : ValueType {
    private char _dummyPrimitive;
    public static char MaxValue;
    public static char MinValue;
    private static char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.AdditiveIdentity { get; }
    private static char System.Numerics.IBinaryNumber<System.Char>.AllBitsSet { get; }
    private static char System.Numerics.IMinMaxValue<System.Char>.MaxValue { get; }
    private static char System.Numerics.IMinMaxValue<System.Char>.MinValue { get; }
    private static char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.MultiplicativeIdentity { get; }
    private static char System.Numerics.INumberBase<System.Char>.One { get; }
    private static int System.Numerics.INumberBase<System.Char>.Radix { get; }
    private static char System.Numerics.INumberBase<System.Char>.Zero { get; }
    private static override char System.Numerics.IAdditiveIdentity<System.Char,System.Char>.get_AdditiveIdentity();
    private static override char System.Numerics.IBinaryNumber<System.Char>.get_AllBitsSet();
    private static override char System.Numerics.IMinMaxValue<System.Char>.get_MaxValue();
    private static override char System.Numerics.IMinMaxValue<System.Char>.get_MinValue();
    private static override char System.Numerics.IMultiplicativeIdentity<System.Char,System.Char>.get_MultiplicativeIdentity();
    private static override char System.Numerics.INumberBase<System.Char>.get_One();
    private static override int System.Numerics.INumberBase<System.Char>.get_Radix();
    private static override char System.Numerics.INumberBase<System.Char>.get_Zero();
    public sealed virtual int CompareTo(char value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    [NullableContextAttribute("1")]
public static string ConvertFromUtf32(int utf32);
    public static int ConvertToUtf32(char highSurrogate, char lowSurrogate);
    [NullableContextAttribute("1")]
public static int ConvertToUtf32(string s, int index);
    public sealed virtual bool Equals(char obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static double GetNumericValue(char c);
    [NullableContextAttribute("1")]
public static double GetNumericValue(string s, int index);
    public sealed virtual TypeCode GetTypeCode();
    public static UnicodeCategory GetUnicodeCategory(char c);
    [NullableContextAttribute("1")]
public static UnicodeCategory GetUnicodeCategory(string s, int index);
    public static bool IsAscii(char c);
    public static bool IsAsciiDigit(char c);
    public static bool IsAsciiHexDigit(char c);
    public static bool IsAsciiHexDigitLower(char c);
    public static bool IsAsciiHexDigitUpper(char c);
    public static bool IsAsciiLetter(char c);
    public static bool IsAsciiLetterLower(char c);
    public static bool IsAsciiLetterOrDigit(char c);
    public static bool IsAsciiLetterUpper(char c);
    public static bool IsBetween(char c, char minInclusive, char maxInclusive);
    public static bool IsControl(char c);
    [NullableContextAttribute("1")]
public static bool IsControl(string s, int index);
    public static bool IsDigit(char c);
    [NullableContextAttribute("1")]
public static bool IsDigit(string s, int index);
    public static bool IsHighSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsHighSurrogate(string s, int index);
    public static bool IsLetter(char c);
    [NullableContextAttribute("1")]
public static bool IsLetter(string s, int index);
    public static bool IsLetterOrDigit(char c);
    [NullableContextAttribute("1")]
public static bool IsLetterOrDigit(string s, int index);
    public static bool IsLower(char c);
    [NullableContextAttribute("1")]
public static bool IsLower(string s, int index);
    public static bool IsLowSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsLowSurrogate(string s, int index);
    public static bool IsNumber(char c);
    [NullableContextAttribute("1")]
public static bool IsNumber(string s, int index);
    public static bool IsPunctuation(char c);
    [NullableContextAttribute("1")]
public static bool IsPunctuation(string s, int index);
    public static bool IsSeparator(char c);
    [NullableContextAttribute("1")]
public static bool IsSeparator(string s, int index);
    public static bool IsSurrogate(char c);
    [NullableContextAttribute("1")]
public static bool IsSurrogate(string s, int index);
    public static bool IsSurrogatePair(char highSurrogate, char lowSurrogate);
    [NullableContextAttribute("1")]
public static bool IsSurrogatePair(string s, int index);
    public static bool IsSymbol(char c);
    [NullableContextAttribute("1")]
public static bool IsSymbol(string s, int index);
    public static bool IsUpper(char c);
    [NullableContextAttribute("1")]
public static bool IsUpper(string s, int index);
    public static bool IsWhiteSpace(char c);
    [NullableContextAttribute("1")]
public static bool IsWhiteSpace(string s, int index);
    [NullableContextAttribute("1")]
public static char Parse(string s);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    private static override char System.IParsable<System.Char>.Parse(string s, IFormatProvider provider);
    private static override bool System.IParsable<System.Char>.TryParse(string s, IFormatProvider provider, Char& result);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    private static override char System.ISpanParsable<System.Char>.Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    private static override bool System.ISpanParsable<System.Char>.TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Char& result);
    private static override char System.Numerics.IAdditionOperators<System.Char,System.Char,System.Char>.op_Addition(char left, char right);
    private static override char System.Numerics.IAdditionOperators<System.Char,System.Char,System.Char>.op_CheckedAddition(char left, char right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Char>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Char>.GetShortestBitLength();
    private static override char System.Numerics.IBinaryInteger<System.Char>.LeadingZeroCount(char value);
    private static override char System.Numerics.IBinaryInteger<System.Char>.PopCount(char value);
    private static override char System.Numerics.IBinaryInteger<System.Char>.RotateLeft(char value, int rotateAmount);
    private static override char System.Numerics.IBinaryInteger<System.Char>.RotateRight(char value, int rotateAmount);
    private static override char System.Numerics.IBinaryInteger<System.Char>.TrailingZeroCount(char value);
    private static override bool System.Numerics.IBinaryInteger<System.Char>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Char& value);
    private static override bool System.Numerics.IBinaryInteger<System.Char>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Char& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Char>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Char>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override bool System.Numerics.IBinaryNumber<System.Char>.IsPow2(char value);
    private static override char System.Numerics.IBinaryNumber<System.Char>.Log2(char value);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_BitwiseAnd(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_BitwiseOr(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_ExclusiveOr(char left, char right);
    private static override char System.Numerics.IBitwiseOperators<System.Char,System.Char,System.Char>.op_OnesComplement(char value);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_GreaterThan(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_GreaterThanOrEqual(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_LessThan(char left, char right);
    private static override bool System.Numerics.IComparisonOperators<System.Char,System.Char,System.Boolean>.op_LessThanOrEqual(char left, char right);
    private static override char System.Numerics.IDecrementOperators<System.Char>.op_CheckedDecrement(char value);
    private static override char System.Numerics.IDecrementOperators<System.Char>.op_Decrement(char value);
    private static override char System.Numerics.IDivisionOperators<System.Char,System.Char,System.Char>.op_Division(char left, char right);
    private static override bool System.Numerics.IEqualityOperators<System.Char,System.Char,System.Boolean>.op_Equality(char left, char right);
    private static override bool System.Numerics.IEqualityOperators<System.Char,System.Char,System.Boolean>.op_Inequality(char left, char right);
    private static override char System.Numerics.IIncrementOperators<System.Char>.op_CheckedIncrement(char value);
    private static override char System.Numerics.IIncrementOperators<System.Char>.op_Increment(char value);
    private static override char System.Numerics.IModulusOperators<System.Char,System.Char,System.Char>.op_Modulus(char left, char right);
    private static override char System.Numerics.IMultiplyOperators<System.Char,System.Char,System.Char>.op_CheckedMultiply(char left, char right);
    private static override char System.Numerics.IMultiplyOperators<System.Char,System.Char,System.Char>.op_Multiply(char left, char right);
    private static override char System.Numerics.INumberBase<System.Char>.Abs(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsCanonical(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsComplexNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsEvenInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsFinite(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsImaginaryNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNaN(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNegative(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNegativeInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsNormal(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsOddInteger(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsPositive(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsPositiveInfinity(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsRealNumber(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsSubnormal(char value);
    private static override bool System.Numerics.INumberBase<System.Char>.IsZero(char value);
    private static override char System.Numerics.INumberBase<System.Char>.MaxMagnitude(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MaxMagnitudeNumber(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MinMagnitude(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.MinMagnitudeNumber(char x, char y);
    private static override char System.Numerics.INumberBase<System.Char>.Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    private static override char System.Numerics.INumberBase<System.Char>.Parse(string s, NumberStyles style, IFormatProvider provider);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromChecked(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromSaturating(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertFromTruncating(TOther value, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToChecked(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToSaturating(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryConvertToTruncating(char value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Char& result);
    private static override bool System.Numerics.INumberBase<System.Char>.TryParse(string s, NumberStyles style, IFormatProvider provider, Char& result);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_LeftShift(char value, int shiftAmount);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_RightShift(char value, int shiftAmount);
    private static override char System.Numerics.IShiftOperators<System.Char,System.Int32,System.Char>.op_UnsignedRightShift(char value, int shiftAmount);
    private static override char System.Numerics.ISubtractionOperators<System.Char,System.Char,System.Char>.op_CheckedSubtraction(char left, char right);
    private static override char System.Numerics.ISubtractionOperators<System.Char,System.Char,System.Char>.op_Subtraction(char left, char right);
    private static override char System.Numerics.IUnaryNegationOperators<System.Char,System.Char>.op_CheckedUnaryNegation(char value);
    private static override char System.Numerics.IUnaryNegationOperators<System.Char,System.Char>.op_UnaryNegation(char value);
    private static override char System.Numerics.IUnaryPlusOperators<System.Char,System.Char>.op_UnaryPlus(char value);
    public static char ToLower(char c);
    [NullableContextAttribute("1")]
public static char ToLower(char c, CultureInfo culture);
    public static char ToLowerInvariant(char c);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static string ToString(char c);
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    public static char ToUpper(char c);
    [NullableContextAttribute("1")]
public static char ToUpper(char c, CultureInfo culture);
    public static char ToUpperInvariant(char c);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Char& result);
}
public class System.CharEnumerator : object {
    public char Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual char get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public sealed virtual void Dispose();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[AttributeUsageAttribute("32767")]
public class System.CLSCompliantAttribute : Attribute {
    public bool IsCompliant { get; }
    public CLSCompliantAttribute(bool isCompliant);
    public bool get_IsCompliant();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.CodeDom.Compiler.GeneratedCodeAttribute : Attribute {
    public string Tool { get; }
    public string Version { get; }
    public GeneratedCodeAttribute(string tool, string version);
    public string get_Tool();
    public string get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.CodeDom.Compiler.IndentedTextWriter : TextWriter {
    public static string DefaultTabString;
    public Encoding Encoding { get; }
    public int Indent { get; public set; }
    public TextWriter InnerWriter { get; }
    public string NewLine { get; public set; }
    public IndentedTextWriter(TextWriter writer);
    public IndentedTextWriter(TextWriter writer, string tabString);
    public virtual Encoding get_Encoding();
    public int get_Indent();
    public void set_Indent(int value);
    public TextWriter get_InnerWriter();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    protected virtual void OutputTabs();
    protected virtual Task OutputTabsAsync();
    public virtual void Write(bool value);
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    [NullableContextAttribute("2")]
public virtual void Write(object value);
    public virtual void Write(float value);
    [NullableContextAttribute("2")]
public virtual void Write(string s);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(object value);
    public virtual void WriteLine(float value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string s);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, Object[] arg);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public void WriteLineNoTabs(string s);
    public Task WriteLineNoTabsAsync(string s);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ArrayList : object {
    public int Capacity { get; public set; }
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public object SyncRoot { get; }
    public ArrayList(ICollection c);
    public ArrayList(int capacity);
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    [NullableContextAttribute("2")]
public virtual object get_Item(int index);
    [NullableContextAttribute("2")]
public virtual void set_Item(int index, object value);
    public virtual object get_SyncRoot();
    public static ArrayList Adapter(IList list);
    [NullableContextAttribute("2")]
public virtual int Add(object value);
    public virtual void AddRange(ICollection c);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(int index, int count, object value, IComparer comparer);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value);
    [NullableContextAttribute("2")]
public virtual int BinarySearch(object value, IComparer comparer);
    public virtual void Clear();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public virtual bool Contains(object item);
    public virtual void CopyTo(Array array);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual void CopyTo(int index, Array array, int arrayIndex, int count);
    public static ArrayList FixedSize(ArrayList list);
    public static IList FixedSize(IList list);
    public virtual IEnumerator GetEnumerator();
    public virtual IEnumerator GetEnumerator(int index, int count);
    public virtual ArrayList GetRange(int index, int count);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int IndexOf(object value, int startIndex, int count);
    [NullableContextAttribute("2")]
public virtual void Insert(int index, object value);
    public virtual void InsertRange(int index, ICollection c);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex);
    [NullableContextAttribute("2")]
public virtual int LastIndexOf(object value, int startIndex, int count);
    public static ArrayList ReadOnly(ArrayList list);
    public static IList ReadOnly(IList list);
    [NullableContextAttribute("2")]
public virtual void Remove(object obj);
    public virtual void RemoveAt(int index);
    public virtual void RemoveRange(int index, int count);
    public static ArrayList Repeat(object value, int count);
    public virtual void Reverse();
    public virtual void Reverse(int index, int count);
    public virtual void SetRange(int index, ICollection c);
    public virtual void Sort();
    [NullableContextAttribute("2")]
public virtual void Sort(IComparer comparer);
    [NullableContextAttribute("2")]
public virtual void Sort(int index, int count, IComparer comparer);
    public static ArrayList Synchronized(ArrayList list);
    public static IList Synchronized(IList list);
    public virtual Object[] ToArray();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Array ToArray(Type type);
    public virtual void TrimToSize();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Collections.Comparer : object {
    public static Comparer Default;
    public static Comparer DefaultInvariant;
    public Comparer(CultureInfo culture);
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object a, object b);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Collections.DictionaryEntry : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public object Key { get; public set; }
    [NullableAttribute("2")]
public object Value { get; public set; }
    public DictionaryEntry(object key, object value);
    public object get_Key();
    public void set_Key(object value);
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public void set_Value(object value);
    [EditorBrowsableAttribute("1")]
public void Deconstruct(Object& key, Object& value);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IAsyncEnumerable`1 {
    public abstract virtual IAsyncEnumerator`1<T> GetAsyncEnumerator(CancellationToken cancellationToken);
}
public interface System.Collections.Generic.IAsyncEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
    public abstract virtual ValueTask`1<bool> MoveNextAsync();
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.ICollection`1 {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual void Add(T item);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(T item);
    public abstract virtual void CopyTo(T[] array, int arrayIndex);
    public abstract virtual bool Remove(T item);
}
[NullableContextAttribute("2")]
public interface System.Collections.Generic.IComparer`1 {
    public abstract virtual int Compare(T x, T y);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IDictionary`2 {
    public TValue Item { get; public set; }
    public ICollection`1<TKey> Keys { get; }
    public ICollection`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual void set_Item(TKey key, TValue value);
    public abstract virtual ICollection`1<TKey> get_Keys();
    public abstract virtual ICollection`1<TValue> get_Values();
    public abstract virtual void Add(TKey key, TValue value);
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool Remove(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
public interface System.Collections.Generic.IEnumerable`1 {
    [NullableContextAttribute("1")]
public abstract virtual IEnumerator`1<T> GetEnumerator();
}
public interface System.Collections.Generic.IEnumerator`1 {
    [NullableAttribute("1")]
public T Current { get; }
    [NullableContextAttribute("1")]
public abstract virtual T get_Current();
}
[NullableContextAttribute("2")]
public interface System.Collections.Generic.IEqualityComparer`1 {
    public abstract virtual bool Equals(T x, T y);
    [NullableContextAttribute("1")]
public abstract virtual int GetHashCode(T obj);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IList`1 {
    public T Item { get; public set; }
    public abstract virtual T get_Item(int index);
    public abstract virtual void set_Item(int index, T value);
    public abstract virtual int IndexOf(T item);
    public abstract virtual void Insert(int index, T item);
    public abstract virtual void RemoveAt(int index);
}
public interface System.Collections.Generic.IReadOnlyCollection`1 {
    public int Count { get; }
    public abstract virtual int get_Count();
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyDictionary`2 {
    public TValue Item { get; }
    public IEnumerable`1<TKey> Keys { get; }
    public IEnumerable`1<TValue> Values { get; }
    public abstract virtual TValue get_Item(TKey key);
    public abstract virtual IEnumerable`1<TKey> get_Keys();
    public abstract virtual IEnumerable`1<TValue> get_Values();
    public abstract virtual bool ContainsKey(TKey key);
    public abstract virtual bool TryGetValue(TKey key, TValue& value);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.Generic.IReadOnlyList`1 {
    public T Item { get; }
    public abstract virtual T get_Item(int index);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.IReadOnlySet`1 {
    public abstract virtual bool Contains(T item);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
}
[NullableContextAttribute("1")]
public interface System.Collections.Generic.ISet`1 {
    public abstract virtual bool Add(T item);
    public abstract virtual void ExceptWith(IEnumerable`1<T> other);
    public abstract virtual void IntersectWith(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsProperSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSubsetOf(IEnumerable`1<T> other);
    public abstract virtual bool IsSupersetOf(IEnumerable`1<T> other);
    public abstract virtual bool Overlaps(IEnumerable`1<T> other);
    public abstract virtual bool SetEquals(IEnumerable`1<T> other);
    public abstract virtual void SymmetricExceptWith(IEnumerable`1<T> other);
    public abstract virtual void UnionWith(IEnumerable`1<T> other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Collections.Generic.KeyNotFoundException : SystemException {
    [NullableContextAttribute("1")]
protected KeyNotFoundException(SerializationInfo info, StreamingContext context);
    public KeyNotFoundException(string message);
    public KeyNotFoundException(string message, Exception innerException);
}
public static class System.Collections.Generic.KeyValuePair : object {
    [NullableContextAttribute("1")]
public static KeyValuePair`2<TKey, TValue> Create(TKey key, TValue value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Collections.Generic.KeyValuePair`2 : ValueType {
    private TKey key;
    private TValue value;
    private int _dummyPrimitive;
    public TKey Key { get; }
    public TValue Value { get; }
    public KeyValuePair`2(TKey key, TValue value);
    public TKey get_Key();
    public TValue get_Value();
    [EditorBrowsableAttribute("1")]
public void Deconstruct(TKey& key, TValue& value);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.Hashtable : object {
    [NullableAttribute("2")]
[ObsoleteAttribute("Hashtable.comparer has been deprecated. Use the KeyComparer properties instead.")]
protected IComparer comparer { get; protected set; }
    public int Count { get; }
    [NullableAttribute("2")]
protected IEqualityComparer EqualityComparer { get; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Hashtable.hcp has been deprecated. Use the EqualityComparer property instead.")]
protected IHashCodeProvider hcp { get; protected set; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection Keys { get; }
    public object SyncRoot { get; }
    public ICollection Values { get; }
    public Hashtable(IDictionary d);
    public Hashtable(IDictionary d, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IDictionary, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(IDictionary d, float loadFactor);
    public Hashtable(IDictionary d, float loadFactor, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IDictionary, float, IEqualityComparer) instead.")]
public Hashtable(IDictionary d, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    [NullableContextAttribute("2")]
public Hashtable(IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(IEqualityComparer) instead.")]
public Hashtable(IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(int, IEqualityComparer) instead.")]
public Hashtable(int capacity, IHashCodeProvider hcp, IComparer comparer);
    public Hashtable(int capacity, float loadFactor);
    [NullableContextAttribute("2")]
public Hashtable(int capacity, float loadFactor, IEqualityComparer equalityComparer);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("This constructor has been deprecated. Use Hashtable(int, float, IEqualityComparer) instead.")]
public Hashtable(int capacity, float loadFactor, IHashCodeProvider hcp, IComparer comparer);
    protected Hashtable(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
protected IComparer get_comparer();
    [NullableContextAttribute("2")]
protected void set_comparer(IComparer value);
    public virtual int get_Count();
    [NullableContextAttribute("2")]
protected IEqualityComparer get_EqualityComparer();
    [NullableContextAttribute("2")]
protected IHashCodeProvider get_hcp();
    [NullableContextAttribute("2")]
protected void set_hcp(IHashCodeProvider value);
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual ICollection get_Keys();
    public virtual object get_SyncRoot();
    public virtual ICollection get_Values();
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    [NullableContextAttribute("2")]
public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual IDictionaryEnumerator GetEnumerator();
    protected virtual int GetHash(object key);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    protected virtual bool KeyEquals(object item, object key);
    [NullableContextAttribute("2")]
public virtual void OnDeserialization(object sender);
    public virtual void Remove(object key);
    public static Hashtable Synchronized(Hashtable table);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
public interface System.Collections.ICollection {
    public int Count { get; }
    public bool IsSynchronized { get; }
    public object SyncRoot { get; }
    public abstract virtual int get_Count();
    public abstract virtual bool get_IsSynchronized();
    public abstract virtual object get_SyncRoot();
    public abstract virtual void CopyTo(Array array, int index);
}
[NullableContextAttribute("2")]
public interface System.Collections.IComparer {
    public abstract virtual int Compare(object x, object y);
}
[NullableContextAttribute("1")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IDictionary {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(object key);
    public abstract virtual void set_Item(object key, object value);
    public abstract virtual ICollection get_Keys();
    public abstract virtual ICollection get_Values();
    public abstract virtual void Add(object key, object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object key);
    public abstract virtual IDictionaryEnumerator GetEnumerator();
    public abstract virtual void Remove(object key);
}
[NullableContextAttribute("1")]
public interface System.Collections.IDictionaryEnumerator {
    public DictionaryEntry Entry { get; }
    public object Key { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public abstract virtual DictionaryEntry get_Entry();
    public abstract virtual object get_Key();
    [NullableContextAttribute("2")]
public abstract virtual object get_Value();
}
[NullableContextAttribute("1")]
public interface System.Collections.IEnumerable {
    public abstract virtual IEnumerator GetEnumerator();
}
public interface System.Collections.IEnumerator {
    public object Current { get; }
    public abstract virtual object get_Current();
    public abstract virtual bool MoveNext();
    public abstract virtual void Reset();
}
[NullableContextAttribute("1")]
public interface System.Collections.IEqualityComparer {
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(object x, object y);
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("IHashCodeProvider has been deprecated. Use IEqualityComparer instead.")]
public interface System.Collections.IHashCodeProvider {
    public abstract virtual int GetHashCode(object obj);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Collections.IList {
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public object Item { get; public set; }
    public abstract virtual bool get_IsFixedSize();
    public abstract virtual bool get_IsReadOnly();
    public abstract virtual object get_Item(int index);
    public abstract virtual void set_Item(int index, object value);
    public abstract virtual int Add(object value);
    public abstract virtual void Clear();
    public abstract virtual bool Contains(object value);
    public abstract virtual int IndexOf(object value);
    public abstract virtual void Insert(int index, object value);
    public abstract virtual void Remove(object value);
    public abstract virtual void RemoveAt(int index);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralComparable {
    public abstract virtual int CompareTo(object other, IComparer comparer);
}
[NullableContextAttribute("1")]
public interface System.Collections.IStructuralEquatable {
    public abstract virtual bool Equals(object other, IEqualityComparer comparer);
    public abstract virtual int GetHashCode(IEqualityComparer comparer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.Collection`1 : object {
    public int Count { get; }
    public T Item { get; public set; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public Collection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    protected virtual void ClearItems();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    protected virtual void InsertItem(int index, T item);
    public sealed virtual bool Remove(T item);
    public sealed virtual void RemoveAt(int index);
    protected virtual void RemoveItem(int index);
    protected virtual void SetItem(int index, T item);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyCollection`1 : object {
    public int Count { get; }
    public T Item { get; }
    protected IList`1<T> Items { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    private T System.Collections.Generic.IList<T>.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IList.Item { get; private set; }
    public ReadOnlyCollection`1(IList`1<T> list);
    public sealed virtual int get_Count();
    public sealed virtual T get_Item(int index);
    protected IList`1<T> get_Items();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override T System.Collections.Generic.IList<T>.get_Item(int index);
    private sealed virtual override void System.Collections.Generic.IList<T>.set_Item(int index, T value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    public sealed virtual bool Contains(T value);
    public sealed virtual void CopyTo(T[] array, int index);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    public sealed virtual int IndexOf(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T value);
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.Insert(int index, T value);
    private sealed virtual override void System.Collections.Generic.IList<T>.RemoveAt(int index);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override void System.Collections.IList.Clear();
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override void System.Collections.IList.RemoveAt(int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Collections.ObjectModel.ReadOnlyDictionary`2 : object {
    public int Count { get; }
    protected IDictionary`2<TKey, TValue> Dictionary { get; }
    public TValue Item { get; }
    public KeyCollection<TKey, TValue> Keys { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.IsReadOnly { get; }
    private TValue System.Collections.Generic.IDictionary<TKey,TValue>.Item { get; private set; }
    private ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.Keys { get; }
    private ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.Values { get; }
    private IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Keys { get; }
    private IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.Values { get; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    private bool System.Collections.IDictionary.IsFixedSize { get; }
    private bool System.Collections.IDictionary.IsReadOnly { get; }
    [NullableAttribute("2")]
private object System.Collections.IDictionary.Item { get; private set; }
    private ICollection System.Collections.IDictionary.Keys { get; }
    private ICollection System.Collections.IDictionary.Values { get; }
    public ValueCollection<TKey, TValue> Values { get; }
    public ReadOnlyDictionary`2(IDictionary`2<TKey, TValue> dictionary);
    public sealed virtual int get_Count();
    protected IDictionary`2<TKey, TValue> get_Dictionary();
    public sealed virtual TValue get_Item(TKey key);
    public KeyCollection<TKey, TValue> get_Keys();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.get_IsReadOnly();
    private sealed virtual override TValue System.Collections.Generic.IDictionary<TKey,TValue>.get_Item(TKey key);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.set_Item(TKey key, TValue value);
    private sealed virtual override ICollection`1<TKey> System.Collections.Generic.IDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override ICollection`1<TValue> System.Collections.Generic.IDictionary<TKey,TValue>.get_Values();
    private sealed virtual override IEnumerable`1<TKey> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Keys();
    private sealed virtual override IEnumerable`1<TValue> System.Collections.Generic.IReadOnlyDictionary<TKey,TValue>.get_Values();
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override bool System.Collections.IDictionary.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IDictionary.get_IsReadOnly();
    private sealed virtual override object System.Collections.IDictionary.get_Item(object key);
    private sealed virtual override void System.Collections.IDictionary.set_Item(object key, object value);
    private sealed virtual override ICollection System.Collections.IDictionary.get_Keys();
    private sealed virtual override ICollection System.Collections.IDictionary.get_Values();
    public ValueCollection<TKey, TValue> get_Values();
    public sealed virtual bool ContainsKey(TKey key);
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Add(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Clear();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Contains(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.CopyTo(KeyValuePair`2[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<TKey,TValue>>.Remove(KeyValuePair`2<TKey, TValue> item);
    private sealed virtual override void System.Collections.Generic.IDictionary<TKey,TValue>.Add(TKey key, TValue value);
    private sealed virtual override bool System.Collections.Generic.IDictionary<TKey,TValue>.Remove(TKey key);
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override void System.Collections.IDictionary.Add(object key, object value);
    private sealed virtual override void System.Collections.IDictionary.Clear();
    private sealed virtual override bool System.Collections.IDictionary.Contains(object key);
    private sealed virtual override IDictionaryEnumerator System.Collections.IDictionary.GetEnumerator();
    private sealed virtual override void System.Collections.IDictionary.Remove(object key);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool TryGetValue(TKey key, TValue& value);
}
public class System.Comparison`1 : MulticastDelegate {
    public Comparison`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual int Invoke(T x, T y);
    public virtual IAsyncResult BeginInvoke(T x, T y, AsyncCallback callback, object object);
    public virtual int EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.ComponentModel.DefaultValueAttribute : Attribute {
    public object Value { get; }
    public DefaultValueAttribute(bool value);
    public DefaultValueAttribute(byte value);
    public DefaultValueAttribute(char value);
    public DefaultValueAttribute(double value);
    public DefaultValueAttribute(short value);
    public DefaultValueAttribute(int value);
    public DefaultValueAttribute(long value);
    public DefaultValueAttribute(object value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(sbyte value);
    public DefaultValueAttribute(float value);
    public DefaultValueAttribute(string value);
    [NullableContextAttribute("1")]
[RequiresUnreferencedCodeAttribute("Generic TypeConverters may require the generic types to be annotated. For example, NullableConverter requires the underlying type to be DynamicallyAccessedMembers All.")]
public DefaultValueAttribute(Type type, string value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ushort value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(UInt32 value);
    [CLSCompliantAttribute("False")]
public DefaultValueAttribute(ulong value);
    public virtual object get_Value();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    protected void SetValue(object value);
}
[AttributeUsageAttribute("6140")]
public class System.ComponentModel.EditorBrowsableAttribute : Attribute {
    public EditorBrowsableState State { get; }
    public EditorBrowsableAttribute(EditorBrowsableState state);
    public EditorBrowsableState get_State();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public enum System.ComponentModel.EditorBrowsableState : Enum {
    public int value__;
    public static EditorBrowsableState Always;
    public static EditorBrowsableState Never;
    public static EditorBrowsableState Advanced;
}
public enum System.Configuration.Assemblies.AssemblyHashAlgorithm : Enum {
    public int value__;
    public static AssemblyHashAlgorithm None;
    public static AssemblyHashAlgorithm MD5;
    public static AssemblyHashAlgorithm SHA1;
    public static AssemblyHashAlgorithm SHA256;
    public static AssemblyHashAlgorithm SHA384;
    public static AssemblyHashAlgorithm SHA512;
}
public enum System.Configuration.Assemblies.AssemblyVersionCompatibility : Enum {
    public int value__;
    public static AssemblyVersionCompatibility SameMachine;
    public static AssemblyVersionCompatibility SameProcess;
    public static AssemblyVersionCompatibility SameDomain;
}
public abstract class System.ContextBoundObject : MarshalByRefObject {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ContextMarshalException : SystemException {
    [NullableContextAttribute("1")]
protected ContextMarshalException(SerializationInfo info, StreamingContext context);
    public ContextMarshalException(string message);
    public ContextMarshalException(string message, Exception inner);
}
[AttributeUsageAttribute("256")]
public class System.ContextStaticAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Convert : object {
    [NullableAttribute("1")]
public static object DBNull;
    public static object ChangeType(object value, Type conversionType);
    public static object ChangeType(object value, Type conversionType, IFormatProvider provider);
    public static object ChangeType(object value, TypeCode typeCode);
    public static object ChangeType(object value, TypeCode typeCode, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64CharArray(Char[] inArray, int offset, int length);
    [NullableContextAttribute("1")]
public static Byte[] FromBase64String(string s);
    [NullableContextAttribute("0")]
public static Byte[] FromHexString(ReadOnlySpan`1<char> chars);
    [NullableContextAttribute("1")]
public static Byte[] FromHexString(string s);
    public static TypeCode GetTypeCode(object value);
    public static bool IsDBNull(object value);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut);
    [NullableContextAttribute("1")]
public static int ToBase64CharArray(Byte[] inArray, int offsetIn, int length, Char[] outArray, int offsetOut, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, Base64FormattingOptions options);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length);
    [NullableContextAttribute("1")]
public static string ToBase64String(Byte[] inArray, int offset, int length, Base64FormattingOptions options);
    [NullableContextAttribute("0")]
public static string ToBase64String(ReadOnlySpan`1<byte> bytes, Base64FormattingOptions options);
    public static bool ToBoolean(bool value);
    public static bool ToBoolean(byte value);
    public static bool ToBoolean(char value);
    public static bool ToBoolean(DateTime value);
    public static bool ToBoolean(decimal value);
    public static bool ToBoolean(double value);
    public static bool ToBoolean(short value);
    public static bool ToBoolean(int value);
    public static bool ToBoolean(long value);
    public static bool ToBoolean(object value);
    public static bool ToBoolean(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(sbyte value);
    public static bool ToBoolean(float value);
    public static bool ToBoolean(string value);
    public static bool ToBoolean(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ushort value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool ToBoolean(ulong value);
    public static byte ToByte(bool value);
    public static byte ToByte(byte value);
    public static byte ToByte(char value);
    public static byte ToByte(DateTime value);
    public static byte ToByte(decimal value);
    public static byte ToByte(double value);
    public static byte ToByte(short value);
    public static byte ToByte(int value);
    public static byte ToByte(long value);
    public static byte ToByte(object value);
    public static byte ToByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static byte ToByte(sbyte value);
    public static byte ToByte(float value);
    public static byte ToByte(string value);
    public static byte ToByte(string value, IFormatProvider provider);
    public static byte ToByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ushort value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static byte ToByte(ulong value);
    public static char ToChar(bool value);
    public static char ToChar(byte value);
    public static char ToChar(char value);
    public static char ToChar(DateTime value);
    public static char ToChar(decimal value);
    public static char ToChar(double value);
    public static char ToChar(short value);
    public static char ToChar(int value);
    public static char ToChar(long value);
    public static char ToChar(object value);
    public static char ToChar(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(sbyte value);
    public static char ToChar(float value);
    [NullableContextAttribute("1")]
public static char ToChar(string value);
    [NullableContextAttribute("1")]
public static char ToChar(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static char ToChar(ushort value);
    [CLSCompliantAttribute("False")]
public static char ToChar(UInt32 value);
    [CLSCompliantAttribute("False")]
public static char ToChar(ulong value);
    public static DateTime ToDateTime(bool value);
    public static DateTime ToDateTime(byte value);
    public static DateTime ToDateTime(char value);
    public static DateTime ToDateTime(DateTime value);
    public static DateTime ToDateTime(decimal value);
    public static DateTime ToDateTime(double value);
    public static DateTime ToDateTime(short value);
    public static DateTime ToDateTime(int value);
    public static DateTime ToDateTime(long value);
    public static DateTime ToDateTime(object value);
    public static DateTime ToDateTime(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(sbyte value);
    public static DateTime ToDateTime(float value);
    public static DateTime ToDateTime(string value);
    public static DateTime ToDateTime(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ushort value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(UInt32 value);
    [CLSCompliantAttribute("False")]
public static DateTime ToDateTime(ulong value);
    public static decimal ToDecimal(bool value);
    public static decimal ToDecimal(byte value);
    public static decimal ToDecimal(char value);
    public static decimal ToDecimal(DateTime value);
    public static decimal ToDecimal(decimal value);
    public static decimal ToDecimal(double value);
    public static decimal ToDecimal(short value);
    public static decimal ToDecimal(int value);
    public static decimal ToDecimal(long value);
    public static decimal ToDecimal(object value);
    public static decimal ToDecimal(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(sbyte value);
    public static decimal ToDecimal(float value);
    public static decimal ToDecimal(string value);
    public static decimal ToDecimal(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal ToDecimal(ulong value);
    public static double ToDouble(bool value);
    public static double ToDouble(byte value);
    public static double ToDouble(char value);
    public static double ToDouble(DateTime value);
    public static double ToDouble(decimal value);
    public static double ToDouble(double value);
    public static double ToDouble(short value);
    public static double ToDouble(int value);
    public static double ToDouble(long value);
    public static double ToDouble(object value);
    public static double ToDouble(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(sbyte value);
    public static double ToDouble(float value);
    public static double ToDouble(string value);
    public static double ToDouble(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ushort value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(UInt32 value);
    [CLSCompliantAttribute("False")]
public static double ToDouble(ulong value);
    [NullableContextAttribute("1")]
public static string ToHexString(Byte[] inArray);
    [NullableContextAttribute("1")]
public static string ToHexString(Byte[] inArray, int offset, int length);
    [NullableContextAttribute("0")]
public static string ToHexString(ReadOnlySpan`1<byte> bytes);
    public static short ToInt16(bool value);
    public static short ToInt16(byte value);
    public static short ToInt16(char value);
    public static short ToInt16(DateTime value);
    public static short ToInt16(decimal value);
    public static short ToInt16(double value);
    public static short ToInt16(short value);
    public static short ToInt16(int value);
    public static short ToInt16(long value);
    public static short ToInt16(object value);
    public static short ToInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static short ToInt16(sbyte value);
    public static short ToInt16(float value);
    public static short ToInt16(string value);
    public static short ToInt16(string value, IFormatProvider provider);
    public static short ToInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static short ToInt16(ulong value);
    public static int ToInt32(bool value);
    public static int ToInt32(byte value);
    public static int ToInt32(char value);
    public static int ToInt32(DateTime value);
    public static int ToInt32(decimal value);
    public static int ToInt32(double value);
    public static int ToInt32(short value);
    public static int ToInt32(int value);
    public static int ToInt32(long value);
    public static int ToInt32(object value);
    public static int ToInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static int ToInt32(sbyte value);
    public static int ToInt32(float value);
    public static int ToInt32(string value);
    public static int ToInt32(string value, IFormatProvider provider);
    public static int ToInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int ToInt32(ulong value);
    public static long ToInt64(bool value);
    public static long ToInt64(byte value);
    public static long ToInt64(char value);
    public static long ToInt64(DateTime value);
    public static long ToInt64(decimal value);
    public static long ToInt64(double value);
    public static long ToInt64(short value);
    public static long ToInt64(int value);
    public static long ToInt64(long value);
    public static long ToInt64(object value);
    public static long ToInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static long ToInt64(sbyte value);
    public static long ToInt64(float value);
    public static long ToInt64(string value);
    public static long ToInt64(string value, IFormatProvider provider);
    public static long ToInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static long ToInt64(ulong value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(bool value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(byte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(char value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(DateTime value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(double value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(short value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(int value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(long value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(sbyte value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(float value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ushort value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(UInt32 value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(ulong value);
    public static float ToSingle(bool value);
    public static float ToSingle(byte value);
    public static float ToSingle(char value);
    public static float ToSingle(DateTime value);
    public static float ToSingle(decimal value);
    public static float ToSingle(double value);
    public static float ToSingle(short value);
    public static float ToSingle(int value);
    public static float ToSingle(long value);
    public static float ToSingle(object value);
    public static float ToSingle(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(sbyte value);
    public static float ToSingle(float value);
    public static float ToSingle(string value);
    public static float ToSingle(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ushort value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(UInt32 value);
    [CLSCompliantAttribute("False")]
public static float ToSingle(ulong value);
    [NullableContextAttribute("1")]
public static string ToString(bool value);
    [NullableContextAttribute("1")]
public static string ToString(bool value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(byte value);
    [NullableContextAttribute("1")]
public static string ToString(byte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(byte value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(char value);
    [NullableContextAttribute("1")]
public static string ToString(char value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value);
    [NullableContextAttribute("1")]
public static string ToString(DateTime value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(decimal value);
    [NullableContextAttribute("1")]
public static string ToString(decimal value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(double value);
    [NullableContextAttribute("1")]
public static string ToString(double value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(short value);
    [NullableContextAttribute("1")]
public static string ToString(short value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(short value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(int value);
    [NullableContextAttribute("1")]
public static string ToString(int value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(int value, int toBase);
    [NullableContextAttribute("1")]
public static string ToString(long value);
    [NullableContextAttribute("1")]
public static string ToString(long value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(long value, int toBase);
    public static string ToString(object value);
    public static string ToString(object value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(sbyte value, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static string ToString(float value);
    [NullableContextAttribute("1")]
public static string ToString(float value, IFormatProvider provider);
    public static string ToString(string value);
    public static string ToString(string value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ushort value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(UInt32 value, IFormatProvider provider);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ulong value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static string ToString(ulong value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(bool value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(byte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(char value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(DateTime value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(double value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(short value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(int value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(long value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(sbyte value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(float value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ushort value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(bool value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(byte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(char value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(DateTime value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(double value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(short value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(int value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(long value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(sbyte value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(float value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(ulong value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(bool value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(byte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(char value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(DateTime value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(double value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(short value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(int value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(long value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(object value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(sbyte value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(float value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(string value, int fromBase);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ushort value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(ulong value);
    [NullableContextAttribute("0")]
public static bool TryFromBase64Chars(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static bool TryFromBase64String(string s, Span`1<byte> bytes, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public static bool TryToBase64Chars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, Int32& charsWritten, Base64FormattingOptions options);
}
public class System.Converter`2 : MulticastDelegate {
    public Converter`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TOutput Invoke(TInput input);
    public virtual IAsyncResult BeginInvoke(TInput input, AsyncCallback callback, object object);
    public virtual TOutput EndInvoke(IAsyncResult result);
}
[IsReadOnlyAttribute]
public class System.DateOnly : ValueType {
    private int _dummyPrimitive;
    public int Day { get; }
    public int DayNumber { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public static DateOnly MaxValue { get; }
    public static DateOnly MinValue { get; }
    public int Month { get; }
    public int Year { get; }
    public DateOnly(int year, int month, int day);
    [NullableContextAttribute("1")]
public DateOnly(int year, int month, int day, Calendar calendar);
    public int get_Day();
    public int get_DayNumber();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public static DateOnly get_MaxValue();
    public static DateOnly get_MinValue();
    public int get_Month();
    public int get_Year();
    public DateOnly AddDays(int value);
    public DateOnly AddMonths(int value);
    public DateOnly AddYears(int value);
    public sealed virtual int CompareTo(DateOnly value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(DateOnly value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public static DateOnly FromDateTime(DateTime dateTime);
    public static DateOnly FromDayNumber(int dayNumber);
    public virtual int GetHashCode();
    public static bool op_Equality(DateOnly left, DateOnly right);
    public static bool op_GreaterThan(DateOnly left, DateOnly right);
    public static bool op_GreaterThanOrEqual(DateOnly left, DateOnly right);
    public static bool op_Inequality(DateOnly left, DateOnly right);
    public static bool op_LessThan(DateOnly left, DateOnly right);
    public static bool op_LessThanOrEqual(DateOnly left, DateOnly right);
    public static override DateOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static DateOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly Parse(string s);
    [NullableContextAttribute("1")]
public static override DateOnly Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static DateOnly Parse(string s, IFormatProvider provider, DateTimeStyles style);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats);
    public static DateOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, string format);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, String[] formats);
    [NullableContextAttribute("1")]
public static DateOnly ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public DateTime ToDateTime(TimeOnly time);
    public DateTime ToDateTime(TimeOnly time, DateTimeKind kind);
    [NullableContextAttribute("1")]
public string ToLongDateString();
    [NullableContextAttribute("1")]
public string ToShortDateString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, DateOnly& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateOnly& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, DateOnly& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, DateOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateOnly& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.DateTime : ValueType {
    private int _dummyPrimitive;
    public static DateTime MaxValue;
    public static DateTime MinValue;
    public static DateTime UnixEpoch;
    public DateTime Date { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTimeKind Kind { get; }
    public int Microsecond { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public int Nanosecond { get; }
    public static DateTime Now { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public static DateTime Today { get; }
    public static DateTime UtcNow { get; }
    public int Year { get; }
    public DateTime(int year, int month, int day);
    public DateTime(int year, int month, int day, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second);
    public DateTime(int year, int month, int day, int hour, int minute, int second, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, DateTimeKind kind);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar);
    public DateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, DateTimeKind kind);
    public DateTime(long ticks);
    public DateTime(long ticks, DateTimeKind kind);
    public DateTime get_Date();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTimeKind get_Kind();
    public int get_Microsecond();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public int get_Nanosecond();
    public static DateTime get_Now();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public static DateTime get_Today();
    public static DateTime get_UtcNow();
    public int get_Year();
    public DateTime Add(TimeSpan value);
    public DateTime AddDays(double value);
    public DateTime AddHours(double value);
    public DateTime AddMicroseconds(double value);
    public DateTime AddMilliseconds(double value);
    public DateTime AddMinutes(double value);
    public DateTime AddMonths(int months);
    public DateTime AddSeconds(double value);
    public DateTime AddTicks(long value);
    public DateTime AddYears(int value);
    public static int Compare(DateTime t1, DateTime t2);
    public sealed virtual int CompareTo(DateTime value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static int DaysInMonth(int year, int month);
    public sealed virtual bool Equals(DateTime value);
    public static bool Equals(DateTime t1, DateTime t2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public static DateTime FromBinary(long dateData);
    public static DateTime FromFileTime(long fileTime);
    public static DateTime FromFileTimeUtc(long fileTime);
    public static DateTime FromOADate(double d);
    public String[] GetDateTimeFormats();
    public String[] GetDateTimeFormats(char format);
    public String[] GetDateTimeFormats(char format, IFormatProvider provider);
    public String[] GetDateTimeFormats(IFormatProvider provider);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public bool IsDaylightSavingTime();
    public static bool IsLeapYear(int year);
    public static DateTime op_Addition(DateTime d, TimeSpan t);
    public static bool op_Equality(DateTime d1, DateTime d2);
    public static bool op_GreaterThan(DateTime t1, DateTime t2);
    public static bool op_GreaterThanOrEqual(DateTime t1, DateTime t2);
    public static bool op_Inequality(DateTime d1, DateTime d2);
    public static bool op_LessThan(DateTime t1, DateTime t2);
    public static bool op_LessThanOrEqual(DateTime t1, DateTime t2);
    public static TimeSpan op_Subtraction(DateTime d1, DateTime d2);
    public static DateTime op_Subtraction(DateTime d, TimeSpan t);
    [NullableContextAttribute("0")]
public static override DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static DateTime Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles);
    public static DateTime Parse(string s);
    public static override DateTime Parse(string s, IFormatProvider provider);
    public static DateTime Parse(string s, IFormatProvider provider, DateTimeStyles styles);
    [NullableContextAttribute("0")]
public static DateTime ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("0")]
public static DateTime ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider);
    public static DateTime ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    public static DateTime ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    public static DateTime SpecifyKind(DateTime value, DateTimeKind kind);
    public TimeSpan Subtract(DateTime value);
    public DateTime Subtract(TimeSpan value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToBinary();
    public long ToFileTime();
    public long ToFileTimeUtc();
    public DateTime ToLocalTime();
    public string ToLongDateString();
    public string ToLongTimeString();
    public double ToOADate();
    public string ToShortDateString();
    public string ToShortTimeString();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public DateTime ToUniversalTime();
    [NullableContextAttribute("0")]
public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, DateTime& result);
    [NullableContextAttribute("0")]
public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTime& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, DateTime& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles styles, DateTime& result);
    [NullableContextAttribute("0")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, DateTime& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, DateTime& result);
}
public enum System.DateTimeKind : Enum {
    public int value__;
    public static DateTimeKind Unspecified;
    public static DateTimeKind Utc;
    public static DateTimeKind Local;
}
[IsReadOnlyAttribute]
public class System.DateTimeOffset : ValueType {
    private int _dummyPrimitive;
    public static DateTimeOffset MaxValue;
    public static DateTimeOffset MinValue;
    public static DateTimeOffset UnixEpoch;
    public DateTime Date { get; }
    public DateTime DateTime { get; }
    public int Day { get; }
    public DayOfWeek DayOfWeek { get; }
    public int DayOfYear { get; }
    public int Hour { get; }
    public DateTime LocalDateTime { get; }
    public int Microsecond { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public int Month { get; }
    public int Nanosecond { get; }
    public static DateTimeOffset Now { get; }
    public TimeSpan Offset { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeSpan TimeOfDay { get; }
    public DateTime UtcDateTime { get; }
    public static DateTimeOffset UtcNow { get; }
    public long UtcTicks { get; }
    public int Year { get; }
    public DateTimeOffset(DateTime dateTime);
    public DateTimeOffset(DateTime dateTime, TimeSpan offset);
    [NullableContextAttribute("1")]
public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, Calendar calendar, TimeSpan offset);
    [NullableContextAttribute("1")]
public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, Calendar calendar, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, int microsecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, int millisecond, TimeSpan offset);
    public DateTimeOffset(int year, int month, int day, int hour, int minute, int second, TimeSpan offset);
    public DateTimeOffset(long ticks, TimeSpan offset);
    public DateTime get_Date();
    public DateTime get_DateTime();
    public int get_Day();
    public DayOfWeek get_DayOfWeek();
    public int get_DayOfYear();
    public int get_Hour();
    public DateTime get_LocalDateTime();
    public int get_Microsecond();
    public int get_Millisecond();
    public int get_Minute();
    public int get_Month();
    public int get_Nanosecond();
    public static DateTimeOffset get_Now();
    public TimeSpan get_Offset();
    public int get_Second();
    public long get_Ticks();
    public TimeSpan get_TimeOfDay();
    public DateTime get_UtcDateTime();
    public static DateTimeOffset get_UtcNow();
    public long get_UtcTicks();
    public int get_Year();
    public DateTimeOffset Add(TimeSpan timeSpan);
    public DateTimeOffset AddDays(double days);
    public DateTimeOffset AddHours(double hours);
    public DateTimeOffset AddMicroseconds(double microseconds);
    public DateTimeOffset AddMilliseconds(double milliseconds);
    public DateTimeOffset AddMinutes(double minutes);
    public DateTimeOffset AddMonths(int months);
    public DateTimeOffset AddSeconds(double seconds);
    public DateTimeOffset AddTicks(long ticks);
    public DateTimeOffset AddYears(int years);
    public static int Compare(DateTimeOffset first, DateTimeOffset second);
    public sealed virtual int CompareTo(DateTimeOffset other);
    public sealed virtual bool Equals(DateTimeOffset other);
    public static bool Equals(DateTimeOffset first, DateTimeOffset second);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public bool EqualsExact(DateTimeOffset other);
    public static DateTimeOffset FromFileTime(long fileTime);
    public static DateTimeOffset FromUnixTimeMilliseconds(long milliseconds);
    public static DateTimeOffset FromUnixTimeSeconds(long seconds);
    public virtual int GetHashCode();
    public static DateTimeOffset op_Addition(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static bool op_Equality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_GreaterThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Implicit(DateTime dateTime);
    public static bool op_Inequality(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThan(DateTimeOffset left, DateTimeOffset right);
    public static bool op_LessThanOrEqual(DateTimeOffset left, DateTimeOffset right);
    public static TimeSpan op_Subtraction(DateTimeOffset left, DateTimeOffset right);
    public static DateTimeOffset op_Subtraction(DateTimeOffset dateTimeOffset, TimeSpan timeSpan);
    public static override DateTimeOffset Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static DateTimeOffset Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input);
    [NullableContextAttribute("1")]
public static override DateTimeOffset Parse(string input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset Parse(string input, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles);
    public static DateTimeOffset ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles);
    [NullableContextAttribute("1")]
public static DateTimeOffset ParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles);
    public TimeSpan Subtract(DateTimeOffset value);
    public DateTimeOffset Subtract(TimeSpan value);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public long ToFileTime();
    public DateTimeOffset ToLocalTime();
    public DateTimeOffset ToOffset(TimeSpan offset);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public DateTimeOffset ToUniversalTime();
    public long ToUnixTimeMilliseconds();
    public long ToUnixTimeSeconds();
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static bool TryParse(ReadOnlySpan`1<char> input, DateTimeOffset& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeOffset& result);
    public static bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, DateTimeStyles styles, DateTimeOffset& result);
}
public enum System.DayOfWeek : Enum {
    public int value__;
    public static DayOfWeek Sunday;
    public static DayOfWeek Monday;
    public static DayOfWeek Tuesday;
    public static DayOfWeek Wednesday;
    public static DayOfWeek Thursday;
    public static DayOfWeek Friday;
    public static DayOfWeek Saturday;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.DBNull : object {
    public static DBNull Value;
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual TypeCode GetTypeCode();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
}
[IsReadOnlyAttribute]
public class System.Decimal : ValueType {
    private int _dummyPrimitive;
    [DecimalConstantAttribute("0", "0", "4294967295", "4294967295", "4294967295")]
public static decimal MaxValue;
    [DecimalConstantAttribute("0", "128", "0", "0", "1")]
public static decimal MinusOne;
    [DecimalConstantAttribute("0", "128", "4294967295", "4294967295", "4294967295")]
public static decimal MinValue;
    [DecimalConstantAttribute("0", "0", "0", "0", "1")]
public static decimal One;
    [DecimalConstantAttribute("0", "0", "0", "0", "0")]
public static decimal Zero;
    public byte Scale { get; }
    private static decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.AdditiveIdentity { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.E { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Pi { get; }
    private static decimal System.Numerics.IFloatingPointConstants<System.Decimal>.Tau { get; }
    private static decimal System.Numerics.IMinMaxValue<System.Decimal>.MaxValue { get; }
    private static decimal System.Numerics.IMinMaxValue<System.Decimal>.MinValue { get; }
    private static decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.MultiplicativeIdentity { get; }
    private static decimal System.Numerics.INumberBase<System.Decimal>.One { get; }
    private static int System.Numerics.INumberBase<System.Decimal>.Radix { get; }
    private static decimal System.Numerics.INumberBase<System.Decimal>.Zero { get; }
    private static decimal System.Numerics.ISignedNumber<System.Decimal>.NegativeOne { get; }
    public Decimal(double value);
    public Decimal(int value);
    public Decimal(int lo, int mid, int hi, bool isNegative, byte scale);
    [NullableContextAttribute("1")]
public Decimal(Int32[] bits);
    public Decimal(long value);
    public Decimal(ReadOnlySpan`1<int> bits);
    public Decimal(float value);
    [CLSCompliantAttribute("False")]
public Decimal(UInt32 value);
    [CLSCompliantAttribute("False")]
public Decimal(ulong value);
    public byte get_Scale();
    private static override decimal System.Numerics.IAdditiveIdentity<System.Decimal,System.Decimal>.get_AdditiveIdentity();
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_E();
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_Pi();
    private static override decimal System.Numerics.IFloatingPointConstants<System.Decimal>.get_Tau();
    private static override decimal System.Numerics.IMinMaxValue<System.Decimal>.get_MaxValue();
    private static override decimal System.Numerics.IMinMaxValue<System.Decimal>.get_MinValue();
    private static override decimal System.Numerics.IMultiplicativeIdentity<System.Decimal,System.Decimal>.get_MultiplicativeIdentity();
    private static override decimal System.Numerics.INumberBase<System.Decimal>.get_One();
    private static override int System.Numerics.INumberBase<System.Decimal>.get_Radix();
    private static override decimal System.Numerics.INumberBase<System.Decimal>.get_Zero();
    private static override decimal System.Numerics.ISignedNumber<System.Decimal>.get_NegativeOne();
    public static override decimal Abs(decimal value);
    public static decimal Add(decimal d1, decimal d2);
    public static override decimal Ceiling(decimal d);
    public static override decimal Clamp(decimal value, decimal min, decimal max);
    public static int Compare(decimal d1, decimal d2);
    public sealed virtual int CompareTo(decimal value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override decimal CopySign(decimal value, decimal sign);
    [NullableContextAttribute("1")]
public static override decimal CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override decimal CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override decimal CreateTruncating(TOther value);
    public static decimal Divide(decimal d1, decimal d2);
    public sealed virtual bool Equals(decimal value);
    public static bool Equals(decimal d1, decimal d2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public static override decimal Floor(decimal d);
    public static decimal FromOACurrency(long cy);
    [NullableContextAttribute("1")]
public static Int32[] GetBits(decimal d);
    public static int GetBits(decimal d, Span`1<int> destination);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsCanonical(decimal value);
    public static override bool IsEvenInteger(decimal value);
    public static override bool IsInteger(decimal value);
    public static override bool IsNegative(decimal value);
    public static override bool IsOddInteger(decimal value);
    public static override bool IsPositive(decimal value);
    public static override decimal Max(decimal x, decimal y);
    public static override decimal MaxMagnitude(decimal x, decimal y);
    public static override decimal Min(decimal x, decimal y);
    public static override decimal MinMagnitude(decimal x, decimal y);
    public static decimal Multiply(decimal d1, decimal d2);
    public static decimal Negate(decimal d);
    public static override decimal op_Addition(decimal d1, decimal d2);
    public static override decimal op_Decrement(decimal d);
    public static override decimal op_Division(decimal d1, decimal d2);
    public static override bool op_Equality(decimal d1, decimal d2);
    public static byte op_Explicit(decimal value);
    public static char op_Explicit(decimal value);
    public static double op_Explicit(decimal value);
    public static short op_Explicit(decimal value);
    public static int op_Explicit(decimal value);
    public static long op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(decimal value);
    public static float op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(decimal value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(decimal value);
    public static decimal op_Explicit(double value);
    public static decimal op_Explicit(float value);
    public static override bool op_GreaterThan(decimal d1, decimal d2);
    public static override bool op_GreaterThanOrEqual(decimal d1, decimal d2);
    public static decimal op_Implicit(byte value);
    public static decimal op_Implicit(char value);
    public static decimal op_Implicit(short value);
    public static decimal op_Implicit(int value);
    public static decimal op_Implicit(long value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static decimal op_Implicit(ulong value);
    public static override decimal op_Increment(decimal d);
    public static override bool op_Inequality(decimal d1, decimal d2);
    public static override bool op_LessThan(decimal d1, decimal d2);
    public static override bool op_LessThanOrEqual(decimal d1, decimal d2);
    public static override decimal op_Modulus(decimal d1, decimal d2);
    public static override decimal op_Multiply(decimal d1, decimal d2);
    public static override decimal op_Subtraction(decimal d1, decimal d2);
    public static override decimal op_UnaryNegation(decimal d);
    public static override decimal op_UnaryPlus(decimal d);
    public static override decimal Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override decimal Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static decimal Parse(string s);
    [NullableContextAttribute("1")]
public static decimal Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override decimal Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override decimal Parse(string s, IFormatProvider provider);
    public static decimal Remainder(decimal d1, decimal d2);
    public static override decimal Round(decimal d);
    public static override decimal Round(decimal d, int decimals);
    public static override decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static override decimal Round(decimal d, MidpointRounding mode);
    public static override int Sign(decimal d);
    public static decimal Subtract(decimal d1, decimal d2);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Decimal>.GetSignificandByteCount();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Decimal>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsComplexNumber(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsFinite(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsImaginaryNumber(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsInfinity(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNaN(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNegativeInfinity(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsNormal(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsPositiveInfinity(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsRealNumber(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsSubnormal(decimal value);
    private static override bool System.Numerics.INumberBase<System.Decimal>.IsZero(decimal value);
    private static override decimal System.Numerics.INumberBase<System.Decimal>.MaxMagnitudeNumber(decimal x, decimal y);
    private static override decimal System.Numerics.INumberBase<System.Decimal>.MinMagnitudeNumber(decimal x, decimal y);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromChecked(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromSaturating(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertFromTruncating(TOther value, Decimal& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToChecked(decimal value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToSaturating(decimal value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Decimal>.TryConvertToTruncating(decimal value, TOther& result);
    private static override decimal System.Numerics.INumber<System.Decimal>.MaxNumber(decimal x, decimal y);
    private static override decimal System.Numerics.INumber<System.Decimal>.MinNumber(decimal x, decimal y);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static byte ToByte(decimal value);
    public static double ToDouble(decimal d);
    public static short ToInt16(decimal value);
    public static int ToInt32(decimal d);
    public static long ToInt64(decimal d);
    public static long ToOACurrency(decimal value);
    [CLSCompliantAttribute("False")]
public static sbyte ToSByte(decimal value);
    public static float ToSingle(decimal d);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [CLSCompliantAttribute("False")]
public static ushort ToUInt16(decimal value);
    [CLSCompliantAttribute("False")]
public static UInt32 ToUInt32(decimal d);
    [CLSCompliantAttribute("False")]
public static ulong ToUInt64(decimal d);
    public static override decimal Truncate(decimal d);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryGetBits(decimal d, Span`1<int> destination, Int32& valuesWritten);
    public static bool TryParse(ReadOnlySpan`1<char> s, Decimal& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Decimal& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Decimal& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Decimal& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Decimal& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Decimal& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Delegate : object {
    public MethodInfo Method { get; }
    [NullableAttribute("2")]
public object Target { get; }
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
protected Delegate(object target, string method);
    protected Delegate(Type target, string method);
    public MethodInfo get_Method();
    [NullableContextAttribute("2")]
public object get_Target();
    public virtual object Clone();
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate a, Delegate b);
    [NullableContextAttribute("2")]
public static Delegate Combine(Delegate[] delegates);
    protected virtual Delegate CombineImpl(Delegate d);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method);
    public static Delegate CreateDelegate(Type type, object firstArgument, MethodInfo method, bool throwOnBindFailure);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
public static Delegate CreateDelegate(Type type, object target, string method, bool ignoreCase, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, MethodInfo method);
    public static Delegate CreateDelegate(Type type, MethodInfo method, bool throwOnBindFailure);
    public static Delegate CreateDelegate(Type type, Type target, string method);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase);
    public static Delegate CreateDelegate(Type type, Type target, string method, bool ignoreCase, bool throwOnBindFailure);
    [NullableContextAttribute("2")]
public object DynamicInvoke(Object[] args);
    [NullableContextAttribute("2")]
protected virtual object DynamicInvokeImpl(Object[] args);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public static bool op_Equality(Delegate d1, Delegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Delegate d1, Delegate d2);
    [NullableContextAttribute("2")]
public static Delegate Remove(Delegate source, Delegate value);
    [NullableContextAttribute("2")]
public static Delegate RemoveAll(Delegate source, Delegate value);
    protected virtual Delegate RemoveImpl(Delegate d);
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.ConstantExpectedAttribute : Attribute {
    public object Max { get; public set; }
    public object Min { get; public set; }
    public object get_Max();
    public void set_Max(object value);
    public object get_Min();
    public void set_Min(object value);
}
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    public bool get_ParameterValue();
}
[AttributeUsageAttribute("28108")]
public class System.Diagnostics.CodeAnalysis.DynamicallyAccessedMembersAttribute : Attribute {
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public DynamicallyAccessedMembersAttribute(DynamicallyAccessedMemberTypes memberTypes);
    public DynamicallyAccessedMemberTypes get_MemberTypes();
}
[FlagsAttribute]
public enum System.Diagnostics.CodeAnalysis.DynamicallyAccessedMemberTypes : Enum {
    public int value__;
    public static DynamicallyAccessedMemberTypes All;
    public static DynamicallyAccessedMemberTypes None;
    public static DynamicallyAccessedMemberTypes PublicParameterlessConstructor;
    public static DynamicallyAccessedMemberTypes PublicConstructors;
    public static DynamicallyAccessedMemberTypes NonPublicConstructors;
    public static DynamicallyAccessedMemberTypes PublicMethods;
    public static DynamicallyAccessedMemberTypes NonPublicMethods;
    public static DynamicallyAccessedMemberTypes PublicFields;
    public static DynamicallyAccessedMemberTypes NonPublicFields;
    public static DynamicallyAccessedMemberTypes PublicNestedTypes;
    public static DynamicallyAccessedMemberTypes NonPublicNestedTypes;
    public static DynamicallyAccessedMemberTypes PublicProperties;
    public static DynamicallyAccessedMemberTypes NonPublicProperties;
    public static DynamicallyAccessedMemberTypes PublicEvents;
    public static DynamicallyAccessedMemberTypes NonPublicEvents;
    public static DynamicallyAccessedMemberTypes Interfaces;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
public class System.Diagnostics.CodeAnalysis.DynamicDependencyAttribute : Attribute {
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public Type Type { get; }
    public string TypeName { get; }
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(DynamicallyAccessedMemberTypes memberTypes, Type type);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependencyAttribute(string memberSignature, Type type);
    public string get_AssemblyName();
    public string get_Condition();
    public void set_Condition(string value);
    public string get_MemberSignature();
    public DynamicallyAccessedMemberTypes get_MemberTypes();
    public Type get_Type();
    public string get_TypeName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("749")]
public class System.Diagnostics.CodeAnalysis.ExcludeFromCodeCoverageAttribute : Attribute {
    public string Justification { get; public set; }
    public string get_Justification();
    public void set_Justification(string value);
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    public String[] get_Members();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("192")]
public class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    public String[] Members { get; }
    public bool ReturnValue { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    public String[] get_Members();
    public bool get_ReturnValue();
}
[AttributeUsageAttribute("10624")]
public class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("10368")]
public class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    public bool get_ReturnValue();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("736")]
public class System.Diagnostics.CodeAnalysis.RequiresAssemblyFilesAttribute : Attribute {
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public RequiresAssemblyFilesAttribute(string message);
    public string get_Message();
    public string get_Url();
    public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
public class System.Diagnostics.CodeAnalysis.RequiresDynamicCodeAttribute : Attribute {
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresDynamicCodeAttribute(string message);
    public string get_Message();
    [NullableContextAttribute("2")]
public string get_Url();
    [NullableContextAttribute("2")]
public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("100")]
public class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    public string Message { get; }
    [NullableAttribute("2")]
public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    public string get_Message();
    [NullableContextAttribute("2")]
public string get_Url();
    [NullableContextAttribute("2")]
public void set_Url(string value);
}
[AttributeUsageAttribute("32")]
public class System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2432")]
public class System.Diagnostics.CodeAnalysis.StringSyntaxAttribute : Attribute {
    public static string CompositeFormat;
    public static string DateOnlyFormat;
    public static string DateTimeFormat;
    public static string EnumFormat;
    public static string GuidFormat;
    public static string Json;
    public static string NumericFormat;
    public static string Regex;
    public static string TimeOnlyFormat;
    public static string TimeSpanFormat;
    public static string Uri;
    public static string Xml;
    public string Syntax { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] Arguments { get; }
    public StringSyntaxAttribute(string syntax);
    public StringSyntaxAttribute(string syntax, Object[] arguments);
    public string get_Syntax();
    public Object[] get_Arguments();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
[ConditionalAttribute("CODE_ANALYSIS")]
public class System.Diagnostics.CodeAnalysis.SuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Justification { get; public set; }
    public string MessageId { get; public set; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    [NullableContextAttribute("1")]
public SuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
public string get_Category();
    [NullableContextAttribute("1")]
public string get_CheckId();
    public string get_Justification();
    public void set_Justification(string value);
    public string get_MessageId();
    public void set_MessageId(string value);
    public string get_Scope();
    public void set_Scope(string value);
    public string get_Target();
    public void set_Target(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [NullableAttribute("1")]
public string Category { get; }
    [NullableAttribute("1")]
public string CheckId { get; }
    public string Justification { get; public set; }
    public string MessageId { get; public set; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    [NullableContextAttribute("1")]
public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [NullableContextAttribute("1")]
public string get_Category();
    [NullableContextAttribute("1")]
public string get_CheckId();
    public string get_Justification();
    public void set_Justification(string value);
    public string get_MessageId();
    public void set_MessageId(string value);
    public string get_Scope();
    public void set_Scope(string value);
    public string get_Target();
    public void set_Target(string value);
}
[AttributeUsageAttribute("2240")]
public class System.Diagnostics.CodeAnalysis.UnscopedRefAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("68")]
public class System.Diagnostics.ConditionalAttribute : Attribute {
    public string ConditionString { get; }
    public ConditionalAttribute(string conditionString);
    public string get_ConditionString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debug : object {
    public static bool AutoFlush { get; public set; }
    public static int IndentLevel { get; public set; }
    public static int IndentSize { get; public set; }
    public static bool get_AutoFlush();
    public static void set_AutoFlush(bool value);
    public static int get_IndentLevel();
    public static void set_IndentLevel(int value);
    public static int get_IndentSize();
    public static void set_IndentSize(int value);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, AssertInterpolatedStringHandler& message, AssertInterpolatedStringHandler& detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessage);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Assert(bool condition, string message, string detailMessageFormat, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Close();
    [DoesNotReturnAttribute]
[ConditionalAttribute("DEBUG")]
public static void Fail(string message);
    [DoesNotReturnAttribute]
[ConditionalAttribute("DEBUG")]
public static void Fail(string message, string detailMessage);
    [ConditionalAttribute("DEBUG")]
public static void Flush();
    [ConditionalAttribute("DEBUG")]
public static void Indent();
    [ConditionalAttribute("DEBUG")]
public static void Print(string message);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void Print(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void Unindent();
    [ConditionalAttribute("DEBUG")]
public static void Write(object value);
    [ConditionalAttribute("DEBUG")]
public static void Write(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message);
    [ConditionalAttribute("DEBUG")]
public static void Write(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, WriteIfInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, WriteIfInterpolatedStringHandler& message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteIf(bool condition, string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void WriteLine(string format, Object[] args);
    [ConditionalAttribute("DEBUG")]
public static void WriteLine(string message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, WriteIfInterpolatedStringHandler& message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, WriteIfInterpolatedStringHandler& message, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, object value, string category);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message);
    [ConditionalAttribute("DEBUG")]
public static void WriteLineIf(bool condition, string message, string category);
}
[AttributeUsageAttribute("3")]
public class System.Diagnostics.DebuggableAttribute : Attribute {
    public DebuggingModes DebuggingFlags { get; }
    public bool IsJITOptimizerDisabled { get; }
    public bool IsJITTrackingEnabled { get; }
    public DebuggableAttribute(bool isJITTrackingEnabled, bool isJITOptimizerDisabled);
    public DebuggableAttribute(DebuggingModes modes);
    public DebuggingModes get_DebuggingFlags();
    public bool get_IsJITOptimizerDisabled();
    public bool get_IsJITTrackingEnabled();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Diagnostics.Debugger : object {
    public static string DefaultCategory;
    public static bool IsAttached { get; }
    public static bool get_IsAttached();
    public static void Break();
    public static bool IsLogging();
    public static bool Launch();
    public static void Log(int level, string category, string message);
    public static void NotifyOfCrossThreadDependency();
}
[AttributeUsageAttribute("384")]
public class System.Diagnostics.DebuggerBrowsableAttribute : Attribute {
    public DebuggerBrowsableState State { get; }
    public DebuggerBrowsableAttribute(DebuggerBrowsableState state);
    public DebuggerBrowsableState get_State();
}
public enum System.Diagnostics.DebuggerBrowsableState : Enum {
    public int value__;
    public static DebuggerBrowsableState Never;
    public static DebuggerBrowsableState Collapsed;
    public static DebuggerBrowsableState RootHidden;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4509")]
public class System.Diagnostics.DebuggerDisplayAttribute : Attribute {
    public string Name { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    public string Type { get; public set; }
    [NullableAttribute("1")]
public string Value { get; }
    public DebuggerDisplayAttribute(string value);
    public string get_Name();
    public void set_Name(string value);
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
    public string get_Type();
    public void set_Type(string value);
    [NullableContextAttribute("1")]
public string get_Value();
}
[AttributeUsageAttribute("224")]
public class System.Diagnostics.DebuggerHiddenAttribute : Attribute {
}
[AttributeUsageAttribute("236")]
public class System.Diagnostics.DebuggerNonUserCodeAttribute : Attribute {
}
[AttributeUsageAttribute("96")]
public class System.Diagnostics.DebuggerStepperBoundaryAttribute : Attribute {
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.DebuggerStepThroughAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerTypeProxyAttribute : Attribute {
    [NullableAttribute("1")]
[DynamicallyAccessedMembersAttribute("-1")]
public string ProxyTypeName { get; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(string typeName);
    [NullableContextAttribute("1")]
public DebuggerTypeProxyAttribute(Type type);
    [NullableContextAttribute("1")]
public string get_ProxyTypeName();
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("13")]
public class System.Diagnostics.DebuggerVisualizerAttribute : Attribute {
    public string Description { get; public set; }
    public Type Target { get; public set; }
    public string TargetTypeName { get; public set; }
    [DynamicallyAccessedMembersAttribute("-1")]
public string VisualizerObjectSourceTypeName { get; }
    [NullableAttribute("1")]
[DynamicallyAccessedMembersAttribute("-1")]
public string VisualizerTypeName { get; }
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, string visualizerObjectSourceTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(string visualizerTypeName, Type visualizerObjectSource);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, string visualizerObjectSourceTypeName);
    [NullableContextAttribute("1")]
public DebuggerVisualizerAttribute(Type visualizer, Type visualizerObjectSource);
    public string get_Description();
    public void set_Description(string value);
    public Type get_Target();
    public void set_Target(Type value);
    public string get_TargetTypeName();
    public void set_TargetTypeName(string value);
    public string get_VisualizerObjectSourceTypeName();
    [NullableContextAttribute("1")]
public string get_VisualizerTypeName();
}
[AttributeUsageAttribute("108")]
public class System.Diagnostics.StackTraceHiddenAttribute : Attribute {
}
public class System.Diagnostics.Stopwatch : object {
    public static long Frequency;
    public static bool IsHighResolution;
    public TimeSpan Elapsed { get; }
    public long ElapsedMilliseconds { get; }
    public long ElapsedTicks { get; }
    public bool IsRunning { get; }
    public TimeSpan get_Elapsed();
    public long get_ElapsedMilliseconds();
    public long get_ElapsedTicks();
    public bool get_IsRunning();
    public static long GetTimestamp();
    public static TimeSpan GetElapsedTime(long startingTimestamp);
    public static TimeSpan GetElapsedTime(long startingTimestamp, long endingTimestamp);
    public void Reset();
    public void Restart();
    public void Start();
    [NullableContextAttribute("1")]
public static Stopwatch StartNew();
    public void Stop();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Diagnostics.UnreachableException : Exception {
    public UnreachableException(string message);
    public UnreachableException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.DivideByZeroException : ArithmeticException {
    [NullableContextAttribute("1")]
protected DivideByZeroException(SerializationInfo info, StreamingContext context);
    public DivideByZeroException(string message);
    public DivideByZeroException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Double : ValueType {
    private double _dummyPrimitive;
    public static double E;
    public static double Epsilon;
    public static double MaxValue;
    public static double MinValue;
    public static double NaN;
    public static double NegativeInfinity;
    public static double NegativeZero;
    public static double Pi;
    public static double PositiveInfinity;
    public static double Tau;
    private static double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.AdditiveIdentity { get; }
    private static double System.Numerics.IBinaryNumber<System.Double>.AllBitsSet { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.E { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.Pi { get; }
    private static double System.Numerics.IFloatingPointConstants<System.Double>.Tau { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.Epsilon { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NaN { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeInfinity { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.NegativeZero { get; }
    private static double System.Numerics.IFloatingPointIeee754<System.Double>.PositiveInfinity { get; }
    private static double System.Numerics.IMinMaxValue<System.Double>.MaxValue { get; }
    private static double System.Numerics.IMinMaxValue<System.Double>.MinValue { get; }
    private static double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.MultiplicativeIdentity { get; }
    private static double System.Numerics.INumberBase<System.Double>.One { get; }
    private static int System.Numerics.INumberBase<System.Double>.Radix { get; }
    private static double System.Numerics.INumberBase<System.Double>.Zero { get; }
    private static double System.Numerics.ISignedNumber<System.Double>.NegativeOne { get; }
    private static override double System.Numerics.IAdditiveIdentity<System.Double,System.Double>.get_AdditiveIdentity();
    private static override double System.Numerics.IBinaryNumber<System.Double>.get_AllBitsSet();
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_E();
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_Pi();
    private static override double System.Numerics.IFloatingPointConstants<System.Double>.get_Tau();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_Epsilon();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NaN();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NegativeInfinity();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_NegativeZero();
    private static override double System.Numerics.IFloatingPointIeee754<System.Double>.get_PositiveInfinity();
    private static override double System.Numerics.IMinMaxValue<System.Double>.get_MaxValue();
    private static override double System.Numerics.IMinMaxValue<System.Double>.get_MinValue();
    private static override double System.Numerics.IMultiplicativeIdentity<System.Double,System.Double>.get_MultiplicativeIdentity();
    private static override double System.Numerics.INumberBase<System.Double>.get_One();
    private static override int System.Numerics.INumberBase<System.Double>.get_Radix();
    private static override double System.Numerics.INumberBase<System.Double>.get_Zero();
    private static override double System.Numerics.ISignedNumber<System.Double>.get_NegativeOne();
    public static override double Abs(double value);
    public static override double Acos(double x);
    public static override double Acosh(double x);
    public static override double AcosPi(double x);
    public static override double Asin(double x);
    public static override double Asinh(double x);
    public static override double AsinPi(double x);
    public static override double Atan(double x);
    public static override double Atan2(double y, double x);
    public static override double Atan2Pi(double y, double x);
    public static override double Atanh(double x);
    public static override double AtanPi(double x);
    public static override double BitDecrement(double x);
    public static override double BitIncrement(double x);
    public static override double Cbrt(double x);
    public static override double Ceiling(double x);
    public static override double Clamp(double value, double min, double max);
    public sealed virtual int CompareTo(double value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override double CopySign(double value, double sign);
    public static override double Cos(double x);
    public static override double Cosh(double x);
    public static override double CosPi(double x);
    [NullableContextAttribute("1")]
public static override double CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override double CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override double CreateTruncating(TOther value);
    public sealed virtual bool Equals(double obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static override double Exp(double x);
    public static override double Exp10(double x);
    public static override double Exp10M1(double x);
    public static override double Exp2(double x);
    public static override double Exp2M1(double x);
    public static override double ExpM1(double x);
    public static override double Floor(double x);
    public static override double FusedMultiplyAdd(double left, double right, double addend);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override double Hypot(double x, double y);
    public static override double Ieee754Remainder(double left, double right);
    public static override int ILogB(double x);
    public static override bool IsEvenInteger(double value);
    public static override bool IsFinite(double d);
    public static override bool IsInfinity(double d);
    public static override bool IsInteger(double value);
    public static override bool IsNaN(double d);
    public static override bool IsNegative(double d);
    public static override bool IsNegativeInfinity(double d);
    public static override bool IsNormal(double d);
    public static override bool IsOddInteger(double value);
    public static override bool IsPositive(double value);
    public static override bool IsPositiveInfinity(double d);
    public static override bool IsPow2(double value);
    public static override bool IsRealNumber(double value);
    public static override bool IsSubnormal(double d);
    public static override double Log(double x);
    public static override double Log(double x, double newBase);
    public static override double Log10(double x);
    public static override double Log10P1(double x);
    public static override double Log2(double value);
    public static override double Log2P1(double x);
    public static override double LogP1(double x);
    public static override double Max(double x, double y);
    public static override double MaxMagnitude(double x, double y);
    public static override double MaxMagnitudeNumber(double x, double y);
    public static override double MaxNumber(double x, double y);
    public static override double Min(double x, double y);
    public static override double MinMagnitude(double x, double y);
    public static override double MinMagnitudeNumber(double x, double y);
    public static override double MinNumber(double x, double y);
    public static override bool op_Equality(double left, double right);
    public static override bool op_GreaterThan(double left, double right);
    public static override bool op_GreaterThanOrEqual(double left, double right);
    public static override bool op_Inequality(double left, double right);
    public static override bool op_LessThan(double left, double right);
    public static override bool op_LessThanOrEqual(double left, double right);
    public static override double Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override double Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static double Parse(string s);
    [NullableContextAttribute("1")]
public static double Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override double Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override double Parse(string s, IFormatProvider provider);
    public static override double Pow(double x, double y);
    public static override double ReciprocalEstimate(double x);
    public static override double ReciprocalSqrtEstimate(double x);
    public static override double RootN(double x, int n);
    public static override double Round(double x);
    public static override double Round(double x, int digits);
    public static override double Round(double x, int digits, MidpointRounding mode);
    public static override double Round(double x, MidpointRounding mode);
    public static override double ScaleB(double x, int n);
    public static override int Sign(double value);
    public static override double Sin(double x);
    public static override ValueTuple`2<double, double> SinCos(double x);
    public static override ValueTuple`2<double, double> SinCosPi(double x);
    public static override double Sinh(double x);
    public static override double SinPi(double x);
    public static override double Sqrt(double x);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override double System.Numerics.IAdditionOperators<System.Double,System.Double,System.Double>.op_Addition(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_BitwiseAnd(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_BitwiseOr(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_ExclusiveOr(double left, double right);
    private static override double System.Numerics.IBitwiseOperators<System.Double,System.Double,System.Double>.op_OnesComplement(double value);
    private static override double System.Numerics.IDecrementOperators<System.Double>.op_Decrement(double value);
    private static override double System.Numerics.IDivisionOperators<System.Double,System.Double,System.Double>.op_Division(double left, double right);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetSignificandBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Double>.GetSignificandByteCount();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Double>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override double System.Numerics.IIncrementOperators<System.Double>.op_Increment(double value);
    private static override double System.Numerics.IModulusOperators<System.Double,System.Double,System.Double>.op_Modulus(double left, double right);
    private static override double System.Numerics.IMultiplyOperators<System.Double,System.Double,System.Double>.op_Multiply(double left, double right);
    private static override bool System.Numerics.INumberBase<System.Double>.IsCanonical(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsComplexNumber(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsImaginaryNumber(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.IsZero(double value);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromChecked(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromSaturating(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertFromTruncating(TOther value, Double& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToChecked(double value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToSaturating(double value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Double>.TryConvertToTruncating(double value, TOther& result);
    private static override double System.Numerics.ISubtractionOperators<System.Double,System.Double,System.Double>.op_Subtraction(double left, double right);
    private static override double System.Numerics.IUnaryNegationOperators<System.Double,System.Double>.op_UnaryNegation(double value);
    private static override double System.Numerics.IUnaryPlusOperators<System.Double,System.Double>.op_UnaryPlus(double value);
    public static override double Tan(double x);
    public static override double Tanh(double x);
    public static override double TanPi(double x);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override double Truncate(double x);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, Double& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Double& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Double& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Double& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Double& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Double& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.DuplicateWaitObjectException : ArgumentException {
    [NullableContextAttribute("1")]
protected DuplicateWaitObjectException(SerializationInfo info, StreamingContext context);
    public DuplicateWaitObjectException(string parameterName);
    public DuplicateWaitObjectException(string message, Exception innerException);
    public DuplicateWaitObjectException(string parameterName, string message);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.EntryPointNotFoundException : TypeLoadException {
    [NullableContextAttribute("1")]
protected EntryPointNotFoundException(SerializationInfo info, StreamingContext context);
    public EntryPointNotFoundException(string message);
    public EntryPointNotFoundException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Enum : ValueType {
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object target);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static string Format(Type enumType, object value, string format);
    public virtual int GetHashCode();
    public static string GetName(Type enumType, object value);
    [NullableContextAttribute("0")]
public static string GetName(TEnum value);
    public static String[] GetNames(Type enumType);
    public static String[] GetNames();
    public sealed virtual TypeCode GetTypeCode();
    public static Type GetUnderlyingType(Type enumType);
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use the GetValues<TEnum> overload or the GetValuesAsUnderlyingType method instead.")]
public static Array GetValues(Type enumType);
    [NullableContextAttribute("0")]
public static TEnum[] GetValues();
    public static Array GetValuesAsUnderlyingType(Type enumType);
    public static Array GetValuesAsUnderlyingType();
    public bool HasFlag(Enum flag);
    public static bool IsDefined(Type enumType, object value);
    [NullableContextAttribute("0")]
public static bool IsDefined(TEnum value);
    public static object Parse(Type enumType, ReadOnlySpan`1<char> value);
    public static object Parse(Type enumType, ReadOnlySpan`1<char> value, bool ignoreCase);
    public static object Parse(Type enumType, string value);
    public static object Parse(Type enumType, string value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public static TEnum Parse(ReadOnlySpan`1<char> value, bool ignoreCase);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value);
    [NullableContextAttribute("0")]
public static TEnum Parse(string value, bool ignoreCase);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public static object ToObject(Type enumType, byte value);
    public static object ToObject(Type enumType, short value);
    public static object ToObject(Type enumType, int value);
    public static object ToObject(Type enumType, long value);
    public static object ToObject(Type enumType, object value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, sbyte value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ushort value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, UInt32 value);
    [CLSCompliantAttribute("False")]
public static object ToObject(Type enumType, ulong value);
    public virtual string ToString();
    [ObsoleteAttribute("The provider argument is not used. Use ToString() instead.")]
public sealed virtual string ToString(IFormatProvider provider);
    public string ToString(string format);
    [NullableContextAttribute("2")]
[ObsoleteAttribute("The provider argument is not used. Use ToString(String) instead.")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    [NullableContextAttribute("0")]
public static bool TryParse(Type enumType, ReadOnlySpan`1<char> value, bool ignoreCase, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(Type enumType, ReadOnlySpan`1<char> value, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, bool ignoreCase, Object& result);
    [NullableContextAttribute("2")]
public static bool TryParse(Type enumType, string value, Object& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> value, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, bool ignoreCase, TEnum& result);
    [NullableContextAttribute("0")]
public static bool TryParse(string value, TEnum& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Environment : object {
    public static string CommandLine { get; }
    public static string CurrentDirectory { get; public set; }
    public static int CurrentManagedThreadId { get; }
    public static int ExitCode { get; public set; }
    public static bool HasShutdownStarted { get; }
    public static bool Is64BitOperatingSystem { get; }
    public static bool Is64BitProcess { get; }
    public static string MachineName { get; }
    public static string NewLine { get; }
    public static OperatingSystem OSVersion { get; }
    public static int ProcessId { get; }
    public static int ProcessorCount { get; }
    [NullableAttribute("2")]
public static string ProcessPath { get; }
    public static string StackTrace { get; }
    public static string SystemDirectory { get; }
    public static int SystemPageSize { get; }
    public static int TickCount { get; }
    public static long TickCount64 { get; }
    public static string UserDomainName { get; }
    public static bool UserInteractive { get; }
    public static string UserName { get; }
    public static Version Version { get; }
    public static long WorkingSet { get; }
    public static string get_CommandLine();
    public static string get_CurrentDirectory();
    public static void set_CurrentDirectory(string value);
    public static int get_CurrentManagedThreadId();
    public static int get_ExitCode();
    public static void set_ExitCode(int value);
    public static bool get_HasShutdownStarted();
    public static bool get_Is64BitOperatingSystem();
    public static bool get_Is64BitProcess();
    public static string get_MachineName();
    public static string get_NewLine();
    public static OperatingSystem get_OSVersion();
    public static int get_ProcessId();
    public static int get_ProcessorCount();
    [NullableContextAttribute("2")]
public static string get_ProcessPath();
    public static string get_StackTrace();
    public static string get_SystemDirectory();
    public static int get_SystemPageSize();
    public static int get_TickCount();
    public static long get_TickCount64();
    public static string get_UserDomainName();
    public static bool get_UserInteractive();
    public static string get_UserName();
    public static Version get_Version();
    public static long get_WorkingSet();
    [DoesNotReturnAttribute]
public static void Exit(int exitCode);
    public static string ExpandEnvironmentVariables(string name);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void FailFast(string message);
    [NullableContextAttribute("2")]
[DoesNotReturnAttribute]
public static void FailFast(string message, Exception exception);
    public static String[] GetCommandLineArgs();
    public static string GetEnvironmentVariable(string variable);
    public static string GetEnvironmentVariable(string variable, EnvironmentVariableTarget target);
    public static IDictionary GetEnvironmentVariables();
    public static IDictionary GetEnvironmentVariables(EnvironmentVariableTarget target);
    public static string GetFolderPath(SpecialFolder folder);
    public static string GetFolderPath(SpecialFolder folder, SpecialFolderOption option);
    public static String[] GetLogicalDrives();
    public static void SetEnvironmentVariable(string variable, string value);
    public static void SetEnvironmentVariable(string variable, string value, EnvironmentVariableTarget target);
}
public enum System.EnvironmentVariableTarget : Enum {
    public int value__;
    public static EnvironmentVariableTarget Process;
    public static EnvironmentVariableTarget User;
    public static EnvironmentVariableTarget Machine;
}
public class System.EventArgs : object {
    [NullableAttribute("1")]
public static EventArgs Empty;
}
public class System.EventHandler : MulticastDelegate {
    public EventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, EventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, EventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.EventHandler`1 : MulticastDelegate {
    public EventHandler`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, TEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, TEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Exception : object {
    [NullableAttribute("1")]
public IDictionary Data { get; }
    public string HelpLink { get; public set; }
    public int HResult { get; public set; }
    public Exception InnerException { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public string Source { get; public set; }
    public string StackTrace { get; }
    public MethodBase TargetSite { get; }
    [NullableContextAttribute("1")]
protected Exception(SerializationInfo info, StreamingContext context);
    public Exception(string message);
    public Exception(string message, Exception innerException);
    [NullableContextAttribute("1")]
public virtual IDictionary get_Data();
    public virtual string get_HelpLink();
    public virtual void set_HelpLink(string value);
    public int get_HResult();
    public void set_HResult(int value);
    public Exception get_InnerException();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    public virtual string get_Source();
    public virtual void set_Source(string value);
    public virtual string get_StackTrace();
    [RequiresUnreferencedCodeAttribute("Metadata for the method might be incomplete or removed")]
public MethodBase get_TargetSite();
    protected void add_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    protected void remove_SerializeObjectState(EventHandler`1<SafeSerializationEventArgs> value);
    [NullableContextAttribute("1")]
public virtual Exception GetBaseException();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public Type GetType();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ObsoleteAttribute("ExecutionEngineException previously indicated an unspecified fatal error in the runtime. The runtime no longer raises this exception so this type is obsolete.")]
public class System.ExecutionEngineException : SystemException {
    public ExecutionEngineException(string message);
    public ExecutionEngineException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.FieldAccessException : MemberAccessException {
    [NullableContextAttribute("1")]
protected FieldAccessException(SerializationInfo info, StreamingContext context);
    public FieldAccessException(string message);
    public FieldAccessException(string message, Exception inner);
}
public class System.FileStyleUriParser : UriParser {
}
[AttributeUsageAttribute("16")]
public class System.FlagsAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.FormatException : SystemException {
    [NullableContextAttribute("1")]
protected FormatException(SerializationInfo info, StreamingContext context);
    public FormatException(string message);
    public FormatException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.FormattableString : object {
    public int ArgumentCount { get; }
    [StringSyntaxAttribute("CompositeFormat")]
public string Format { get; }
    public abstract virtual int get_ArgumentCount();
    public abstract virtual string get_Format();
    public static string CurrentCulture(FormattableString formattable);
    [NullableContextAttribute("2")]
public abstract virtual object GetArgument(int index);
    public abstract virtual Object[] GetArguments();
    public static string Invariant(FormattableString formattable);
    private sealed virtual override string System.IFormattable.ToString(string ignored, IFormatProvider formatProvider);
    public virtual string ToString();
    public abstract virtual string ToString(IFormatProvider formatProvider);
}
public class System.FtpStyleUriParser : UriParser {
}
public class System.Func`1 : MulticastDelegate {
    public Func`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`10 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`10(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`11 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`11(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`12 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`12(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`13 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`13(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`14 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`14(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`15 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`15(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`16 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`16(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`17 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`17(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14, T15 arg15, T16 arg16, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`2 : MulticastDelegate {
    public Func`2(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T arg);
    public virtual IAsyncResult BeginInvoke(T arg, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`3 : MulticastDelegate {
    public Func`3(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
public class System.Func`4 : MulticastDelegate {
    public Func`4(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3);
    public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, AsyncCallback callback, object object);
    public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`5 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`5(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`6 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`6(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`7 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`7(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`8 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`8(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Func`9 : MulticastDelegate {
    [NullableContextAttribute("0")]
public Func`9(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TResult Invoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, AsyncCallback callback, object object);
    [NullableContextAttribute("0")]
public virtual TResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.GC : object {
    public static int MaxGeneration { get; }
    public static int get_MaxGeneration();
    public static void AddMemoryPressure(long bytesAllocated);
    public static T[] AllocateArray(int length, bool pinned);
    public static T[] AllocateUninitializedArray(int length, bool pinned);
    public static void CancelFullGCNotification();
    public static void Collect();
    public static void Collect(int generation);
    public static void Collect(int generation, GCCollectionMode mode);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking);
    public static void Collect(int generation, GCCollectionMode mode, bool blocking, bool compacting);
    public static int CollectionCount(int generation);
    public static void EndNoGCRegion();
    public static long GetAllocatedBytesForCurrentThread();
    public static GCMemoryInfo GetGCMemoryInfo();
    public static GCMemoryInfo GetGCMemoryInfo(GCKind kind);
    public static int GetGeneration(object obj);
    public static int GetGeneration(WeakReference wo);
    public static long GetTotalAllocatedBytes(bool precise);
    public static long GetTotalMemory(bool forceFullCollection);
    [NullableContextAttribute("2")]
public static void KeepAlive(object obj);
    public static void RegisterForFullGCNotification(int maxGenerationThreshold, int largeObjectHeapThreshold);
    public static void RemoveMemoryPressure(long bytesAllocated);
    public static void ReRegisterForFinalize(object obj);
    public static void SuppressFinalize(object obj);
    public static bool TryStartNoGCRegion(long totalSize);
    public static bool TryStartNoGCRegion(long totalSize, bool disallowFullBlockingGC);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize);
    public static bool TryStartNoGCRegion(long totalSize, long lohSize, bool disallowFullBlockingGC);
    public static GCNotificationStatus WaitForFullGCApproach();
    public static GCNotificationStatus WaitForFullGCApproach(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCApproach(TimeSpan timeout);
    public static GCNotificationStatus WaitForFullGCComplete();
    public static GCNotificationStatus WaitForFullGCComplete(int millisecondsTimeout);
    public static GCNotificationStatus WaitForFullGCComplete(TimeSpan timeout);
    public static void WaitForPendingFinalizers();
    public static TimeSpan GetTotalPauseDuration();
    public static IReadOnlyDictionary`2<string, object> GetConfigurationVariables();
}
public enum System.GCCollectionMode : Enum {
    public int value__;
    public static GCCollectionMode Default;
    public static GCCollectionMode Forced;
    public static GCCollectionMode Optimized;
    public static GCCollectionMode Aggressive;
}
[IsReadOnlyAttribute]
public class System.GCGenerationInfo : ValueType {
    private int _dummyPrimitive;
    public long FragmentationAfterBytes { get; }
    public long FragmentationBeforeBytes { get; }
    public long SizeAfterBytes { get; }
    public long SizeBeforeBytes { get; }
    public long get_FragmentationAfterBytes();
    public long get_FragmentationBeforeBytes();
    public long get_SizeAfterBytes();
    public long get_SizeBeforeBytes();
}
public enum System.GCKind : Enum {
    public int value__;
    public static GCKind Any;
    public static GCKind Ephemeral;
    public static GCKind FullBlocking;
    public static GCKind Background;
}
[IsReadOnlyAttribute]
public class System.GCMemoryInfo : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool Compacted { get; }
    public bool Concurrent { get; }
    public long FinalizationPendingCount { get; }
    public long FragmentedBytes { get; }
    public int Generation { get; }
    public ReadOnlySpan`1<GCGenerationInfo> GenerationInfo { get; }
    public long HeapSizeBytes { get; }
    public long HighMemoryLoadThresholdBytes { get; }
    public long Index { get; }
    public long MemoryLoadBytes { get; }
    public ReadOnlySpan`1<TimeSpan> PauseDurations { get; }
    public double PauseTimePercentage { get; }
    public long PinnedObjectsCount { get; }
    public long PromotedBytes { get; }
    public long TotalAvailableMemoryBytes { get; }
    public long TotalCommittedBytes { get; }
    public bool get_Compacted();
    public bool get_Concurrent();
    public long get_FinalizationPendingCount();
    public long get_FragmentedBytes();
    public int get_Generation();
    public ReadOnlySpan`1<GCGenerationInfo> get_GenerationInfo();
    public long get_HeapSizeBytes();
    public long get_HighMemoryLoadThresholdBytes();
    public long get_Index();
    public long get_MemoryLoadBytes();
    public ReadOnlySpan`1<TimeSpan> get_PauseDurations();
    public double get_PauseTimePercentage();
    public long get_PinnedObjectsCount();
    public long get_PromotedBytes();
    public long get_TotalAvailableMemoryBytes();
    public long get_TotalCommittedBytes();
}
public enum System.GCNotificationStatus : Enum {
    public int value__;
    public static GCNotificationStatus Succeeded;
    public static GCNotificationStatus Failed;
    public static GCNotificationStatus Canceled;
    public static GCNotificationStatus Timeout;
    public static GCNotificationStatus NotApplicable;
}
public class System.GenericUriParser : UriParser {
    public GenericUriParser(GenericUriParserOptions options);
}
[FlagsAttribute]
public enum System.GenericUriParserOptions : Enum {
    public int value__;
    public static GenericUriParserOptions Default;
    public static GenericUriParserOptions GenericAuthority;
    public static GenericUriParserOptions AllowEmptyAuthority;
    public static GenericUriParserOptions NoUserInfo;
    public static GenericUriParserOptions NoPort;
    public static GenericUriParserOptions NoQuery;
    public static GenericUriParserOptions NoFragment;
    public static GenericUriParserOptions DontConvertPathBackslashes;
    public static GenericUriParserOptions DontCompressPath;
    public static GenericUriParserOptions DontUnescapePathDotsAndSlashes;
    public static GenericUriParserOptions Idn;
    public static GenericUriParserOptions IriParsing;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Globalization.Calendar : object {
    public static int CurrentEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public bool IsReadOnly { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public abstract virtual Int32[] get_Eras();
    public bool get_IsReadOnly();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddDays(DateTime time, int days);
    public virtual DateTime AddHours(DateTime time, int hours);
    public virtual DateTime AddMilliseconds(DateTime time, double milliseconds);
    public virtual DateTime AddMinutes(DateTime time, int minutes);
    public abstract virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddSeconds(DateTime time, int seconds);
    public virtual DateTime AddWeeks(DateTime time, int weeks);
    public abstract virtual DateTime AddYears(DateTime time, int years);
    public virtual object Clone();
    public abstract virtual int GetDayOfMonth(DateTime time);
    public abstract virtual DayOfWeek GetDayOfWeek(DateTime time);
    public abstract virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month);
    public abstract virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year);
    public abstract virtual int GetDaysInYear(int year, int era);
    public abstract virtual int GetEra(DateTime time);
    public virtual int GetHour(DateTime time);
    public virtual int GetLeapMonth(int year);
    public virtual int GetLeapMonth(int year, int era);
    public virtual double GetMilliseconds(DateTime time);
    public virtual int GetMinute(DateTime time);
    public abstract virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year);
    public abstract virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSecond(DateTime time);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public abstract virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day);
    public abstract virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month);
    public abstract virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year);
    public abstract virtual bool IsLeapYear(int year, int era);
    public static Calendar ReadOnly(Calendar calendar);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond);
    public abstract virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.CalendarAlgorithmType : Enum {
    public int value__;
    public static CalendarAlgorithmType Unknown;
    public static CalendarAlgorithmType SolarCalendar;
    public static CalendarAlgorithmType LunarCalendar;
    public static CalendarAlgorithmType LunisolarCalendar;
}
public enum System.Globalization.CalendarWeekRule : Enum {
    public int value__;
    public static CalendarWeekRule FirstDay;
    public static CalendarWeekRule FirstFullWeek;
    public static CalendarWeekRule FirstFourDayWeek;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Globalization.CharUnicodeInfo : object {
    public static int GetDecimalDigitValue(char ch);
    public static int GetDecimalDigitValue(string s, int index);
    public static int GetDigitValue(char ch);
    public static int GetDigitValue(string s, int index);
    public static double GetNumericValue(char ch);
    public static double GetNumericValue(string s, int index);
    public static UnicodeCategory GetUnicodeCategory(char ch);
    public static UnicodeCategory GetUnicodeCategory(int codePoint);
    public static UnicodeCategory GetUnicodeCategory(string s, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.ChineseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int ChineseEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.CompareInfo : object {
    public int LCID { get; }
    public string Name { get; }
    public SortVersion Version { get; }
    public int get_LCID();
    public string get_Name();
    public SortVersion get_Version();
    [NullableContextAttribute("0")]
public int Compare(ReadOnlySpan`1<char> string1, ReadOnlySpan`1<char> string2, CompareOptions options);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, int length1, string string2, int offset2, int length2, CompareOptions options);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, string string2, int offset2);
    [NullableContextAttribute("2")]
public int Compare(string string1, int offset1, string string2, int offset2, CompareOptions options);
    [NullableContextAttribute("2")]
public int Compare(string string1, string string2);
    [NullableContextAttribute("2")]
public int Compare(string string1, string string2, CompareOptions options);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public static CompareInfo GetCompareInfo(int culture);
    public static CompareInfo GetCompareInfo(int culture, Assembly assembly);
    public static CompareInfo GetCompareInfo(string name);
    public static CompareInfo GetCompareInfo(string name, Assembly assembly);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public int GetHashCode(ReadOnlySpan`1<char> source, CompareOptions options);
    public int GetHashCode(string source, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetSortKey(ReadOnlySpan`1<char> source, Span`1<byte> destination, CompareOptions options);
    public SortKey GetSortKey(string source);
    public SortKey GetSortKey(string source, CompareOptions options);
    [NullableContextAttribute("0")]
public int GetSortKeyLength(ReadOnlySpan`1<char> source, CompareOptions options);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options, Int32& matchLength);
    [NullableContextAttribute("0")]
public int IndexOf(ReadOnlySpan`1<char> source, Rune value, CompareOptions options);
    public int IndexOf(string source, char value);
    public int IndexOf(string source, char value, CompareOptions options);
    public int IndexOf(string source, char value, int startIndex);
    public int IndexOf(string source, char value, int startIndex, CompareOptions options);
    public int IndexOf(string source, char value, int startIndex, int count);
    public int IndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public int IndexOf(string source, string value);
    public int IndexOf(string source, string value, CompareOptions options);
    public int IndexOf(string source, string value, int startIndex);
    public int IndexOf(string source, string value, int startIndex, CompareOptions options);
    public int IndexOf(string source, string value, int startIndex, int count);
    public int IndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsPrefix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> prefix, CompareOptions options, Int32& matchLength);
    public bool IsPrefix(string source, string prefix);
    public bool IsPrefix(string source, string prefix, CompareOptions options);
    public static bool IsSortable(char ch);
    [NullableContextAttribute("0")]
public static bool IsSortable(ReadOnlySpan`1<char> text);
    public static bool IsSortable(string text);
    public static bool IsSortable(Rune value);
    [NullableContextAttribute("0")]
public bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options);
    [NullableContextAttribute("0")]
public bool IsSuffix(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> suffix, CompareOptions options, Int32& matchLength);
    public bool IsSuffix(string source, string suffix);
    public bool IsSuffix(string source, string suffix, CompareOptions options);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, ReadOnlySpan`1<char> value, CompareOptions options, Int32& matchLength);
    [NullableContextAttribute("0")]
public int LastIndexOf(ReadOnlySpan`1<char> source, Rune value, CompareOptions options);
    public int LastIndexOf(string source, char value);
    public int LastIndexOf(string source, char value, CompareOptions options);
    public int LastIndexOf(string source, char value, int startIndex);
    public int LastIndexOf(string source, char value, int startIndex, CompareOptions options);
    public int LastIndexOf(string source, char value, int startIndex, int count);
    public int LastIndexOf(string source, char value, int startIndex, int count, CompareOptions options);
    public int LastIndexOf(string source, string value);
    public int LastIndexOf(string source, string value, CompareOptions options);
    public int LastIndexOf(string source, string value, int startIndex);
    public int LastIndexOf(string source, string value, int startIndex, CompareOptions options);
    public int LastIndexOf(string source, string value, int startIndex, int count);
    public int LastIndexOf(string source, string value, int startIndex, int count, CompareOptions options);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Globalization.CompareOptions : Enum {
    public int value__;
    public static CompareOptions None;
    public static CompareOptions IgnoreCase;
    public static CompareOptions IgnoreNonSpace;
    public static CompareOptions IgnoreSymbols;
    public static CompareOptions IgnoreKanaType;
    public static CompareOptions IgnoreWidth;
    public static CompareOptions OrdinalIgnoreCase;
    public static CompareOptions StringSort;
    public static CompareOptions Ordinal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.CultureInfo : object {
    public Calendar Calendar { get; }
    public CompareInfo CompareInfo { get; }
    public CultureTypes CultureTypes { get; }
    public static CultureInfo CurrentCulture { get; public set; }
    public static CultureInfo CurrentUICulture { get; public set; }
    public DateTimeFormatInfo DateTimeFormat { get; public set; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentCulture { get; public set; }
    [NullableAttribute("2")]
public static CultureInfo DefaultThreadCurrentUICulture { get; public set; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public string IetfLanguageTag { get; }
    public static CultureInfo InstalledUICulture { get; }
    public static CultureInfo InvariantCulture { get; }
    public bool IsNeutralCulture { get; }
    public bool IsReadOnly { get; }
    public int KeyboardLayoutId { get; }
    public int LCID { get; }
    public string Name { get; }
    public string NativeName { get; }
    public NumberFormatInfo NumberFormat { get; public set; }
    public Calendar[] OptionalCalendars { get; }
    public CultureInfo Parent { get; }
    public TextInfo TextInfo { get; }
    public string ThreeLetterISOLanguageName { get; }
    public string ThreeLetterWindowsLanguageName { get; }
    public string TwoLetterISOLanguageName { get; }
    public bool UseUserOverride { get; }
    public CultureInfo(int culture);
    public CultureInfo(int culture, bool useUserOverride);
    public CultureInfo(string name);
    public CultureInfo(string name, bool useUserOverride);
    public virtual Calendar get_Calendar();
    public virtual CompareInfo get_CompareInfo();
    public CultureTypes get_CultureTypes();
    public static CultureInfo get_CurrentCulture();
    public static void set_CurrentCulture(CultureInfo value);
    public static CultureInfo get_CurrentUICulture();
    public static void set_CurrentUICulture(CultureInfo value);
    public virtual DateTimeFormatInfo get_DateTimeFormat();
    public virtual void set_DateTimeFormat(DateTimeFormatInfo value);
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentCulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentCulture(CultureInfo value);
    [NullableContextAttribute("2")]
public static CultureInfo get_DefaultThreadCurrentUICulture();
    [NullableContextAttribute("2")]
public static void set_DefaultThreadCurrentUICulture(CultureInfo value);
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public string get_IetfLanguageTag();
    public static CultureInfo get_InstalledUICulture();
    public static CultureInfo get_InvariantCulture();
    public virtual bool get_IsNeutralCulture();
    public bool get_IsReadOnly();
    public virtual int get_KeyboardLayoutId();
    public virtual int get_LCID();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual NumberFormatInfo get_NumberFormat();
    public virtual void set_NumberFormat(NumberFormatInfo value);
    public virtual Calendar[] get_OptionalCalendars();
    public virtual CultureInfo get_Parent();
    public virtual TextInfo get_TextInfo();
    public virtual string get_ThreeLetterISOLanguageName();
    public virtual string get_ThreeLetterWindowsLanguageName();
    public virtual string get_TwoLetterISOLanguageName();
    public bool get_UseUserOverride();
    public void ClearCachedData();
    public virtual object Clone();
    public static CultureInfo CreateSpecificCulture(string name);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public CultureInfo GetConsoleFallbackUICulture();
    public static CultureInfo GetCultureInfo(int culture);
    public static CultureInfo GetCultureInfo(string name);
    public static CultureInfo GetCultureInfo(string name, bool predefinedOnly);
    public static CultureInfo GetCultureInfo(string name, string altName);
    public static CultureInfo GetCultureInfoByIetfLanguageTag(string name);
    public static CultureInfo[] GetCultures(CultureTypes types);
    [NullableContextAttribute("2")]
public virtual object GetFormat(Type formatType);
    public virtual int GetHashCode();
    public static CultureInfo ReadOnly(CultureInfo ci);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Globalization.CultureNotFoundException : ArgumentException {
    public Nullable`1<int> InvalidCultureId { get; }
    public string InvalidCultureName { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected CultureNotFoundException(SerializationInfo info, StreamingContext context);
    public CultureNotFoundException(string message);
    public CultureNotFoundException(string message, Exception innerException);
    public CultureNotFoundException(string message, int invalidCultureId, Exception innerException);
    public CultureNotFoundException(string paramName, int invalidCultureId, string message);
    public CultureNotFoundException(string paramName, string message);
    public CultureNotFoundException(string message, string invalidCultureName, Exception innerException);
    public CultureNotFoundException(string paramName, string invalidCultureName, string message);
    public virtual Nullable`1<int> get_InvalidCultureId();
    public virtual string get_InvalidCultureName();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[FlagsAttribute]
public enum System.Globalization.CultureTypes : Enum {
    public int value__;
    public static CultureTypes NeutralCultures;
    public static CultureTypes SpecificCultures;
    public static CultureTypes InstalledWin32Cultures;
    public static CultureTypes AllCultures;
    public static CultureTypes UserCustomCulture;
    public static CultureTypes ReplacementCultures;
    [ObsoleteAttribute("CultureTypes.WindowsOnlyCultures has been deprecated. Use other values in CultureTypes instead.")]
public static CultureTypes WindowsOnlyCultures;
    [ObsoleteAttribute("CultureTypes.FrameworkCultures has been deprecated. Use other values in CultureTypes instead.")]
public static CultureTypes FrameworkCultures;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.DateTimeFormatInfo : object {
    public String[] AbbreviatedDayNames { get; public set; }
    public String[] AbbreviatedMonthGenitiveNames { get; public set; }
    public String[] AbbreviatedMonthNames { get; public set; }
    public string AMDesignator { get; public set; }
    public Calendar Calendar { get; public set; }
    public CalendarWeekRule CalendarWeekRule { get; public set; }
    public static DateTimeFormatInfo CurrentInfo { get; }
    public string DateSeparator { get; public set; }
    public String[] DayNames { get; public set; }
    public DayOfWeek FirstDayOfWeek { get; public set; }
    public string FullDateTimePattern { get; public set; }
    public static DateTimeFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string LongDatePattern { get; public set; }
    public string LongTimePattern { get; public set; }
    public string MonthDayPattern { get; public set; }
    public String[] MonthGenitiveNames { get; public set; }
    public String[] MonthNames { get; public set; }
    public string NativeCalendarName { get; }
    public string PMDesignator { get; public set; }
    public string RFC1123Pattern { get; }
    public string ShortDatePattern { get; public set; }
    public String[] ShortestDayNames { get; public set; }
    public string ShortTimePattern { get; public set; }
    public string SortableDateTimePattern { get; }
    public string TimeSeparator { get; public set; }
    public string UniversalSortableDateTimePattern { get; }
    public string YearMonthPattern { get; public set; }
    public String[] get_AbbreviatedDayNames();
    public void set_AbbreviatedDayNames(String[] value);
    public String[] get_AbbreviatedMonthGenitiveNames();
    public void set_AbbreviatedMonthGenitiveNames(String[] value);
    public String[] get_AbbreviatedMonthNames();
    public void set_AbbreviatedMonthNames(String[] value);
    public string get_AMDesignator();
    public void set_AMDesignator(string value);
    public Calendar get_Calendar();
    public void set_Calendar(Calendar value);
    public CalendarWeekRule get_CalendarWeekRule();
    public void set_CalendarWeekRule(CalendarWeekRule value);
    public static DateTimeFormatInfo get_CurrentInfo();
    public string get_DateSeparator();
    public void set_DateSeparator(string value);
    public String[] get_DayNames();
    public void set_DayNames(String[] value);
    public DayOfWeek get_FirstDayOfWeek();
    public void set_FirstDayOfWeek(DayOfWeek value);
    public string get_FullDateTimePattern();
    public void set_FullDateTimePattern(string value);
    public static DateTimeFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_LongDatePattern();
    public void set_LongDatePattern(string value);
    public string get_LongTimePattern();
    public void set_LongTimePattern(string value);
    public string get_MonthDayPattern();
    public void set_MonthDayPattern(string value);
    public String[] get_MonthGenitiveNames();
    public void set_MonthGenitiveNames(String[] value);
    public String[] get_MonthNames();
    public void set_MonthNames(String[] value);
    public string get_NativeCalendarName();
    public string get_PMDesignator();
    public void set_PMDesignator(string value);
    public string get_RFC1123Pattern();
    public string get_ShortDatePattern();
    public void set_ShortDatePattern(string value);
    public String[] get_ShortestDayNames();
    public void set_ShortestDayNames(String[] value);
    public string get_ShortTimePattern();
    public void set_ShortTimePattern(string value);
    public string get_SortableDateTimePattern();
    public string get_TimeSeparator();
    public void set_TimeSeparator(string value);
    public string get_UniversalSortableDateTimePattern();
    public string get_YearMonthPattern();
    public void set_YearMonthPattern(string value);
    public sealed virtual object Clone();
    public string GetAbbreviatedDayName(DayOfWeek dayofweek);
    public string GetAbbreviatedEraName(int era);
    public string GetAbbreviatedMonthName(int month);
    public String[] GetAllDateTimePatterns();
    public String[] GetAllDateTimePatterns(char format);
    public string GetDayName(DayOfWeek dayofweek);
    public int GetEra(string eraName);
    public string GetEraName(int era);
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public static DateTimeFormatInfo GetInstance(IFormatProvider provider);
    public string GetMonthName(int month);
    public string GetShortestDayName(DayOfWeek dayOfWeek);
    public static DateTimeFormatInfo ReadOnly(DateTimeFormatInfo dtfi);
    public void SetAllDateTimePatterns(String[] patterns, char format);
}
[FlagsAttribute]
public enum System.Globalization.DateTimeStyles : Enum {
    public int value__;
    public static DateTimeStyles None;
    public static DateTimeStyles AllowLeadingWhite;
    public static DateTimeStyles AllowTrailingWhite;
    public static DateTimeStyles AllowInnerWhite;
    public static DateTimeStyles AllowWhiteSpaces;
    public static DateTimeStyles NoCurrentDateDefault;
    public static DateTimeStyles AdjustToUniversal;
    public static DateTimeStyles AssumeLocal;
    public static DateTimeStyles AssumeUniversal;
    public static DateTimeStyles RoundtripKind;
}
public class System.Globalization.DaylightTime : object {
    public TimeSpan Delta { get; }
    public DateTime End { get; }
    public DateTime Start { get; }
    public DaylightTime(DateTime start, DateTime end, TimeSpan delta);
    public TimeSpan get_Delta();
    public DateTime get_End();
    public DateTime get_Start();
}
public enum System.Globalization.DigitShapes : Enum {
    public int value__;
    public static DigitShapes Context;
    public static DigitShapes None;
    public static DigitShapes NativeNational;
}
public abstract class System.Globalization.EastAsianLunisolarCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public int GetCelestialStem(int sexagenaryYear);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetSexagenaryYear(DateTime time);
    public int GetTerrestrialBranch(int sexagenaryYear);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[ExtensionAttribute]
public static class System.Globalization.GlobalizationExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static StringComparer GetStringComparer(CompareInfo compareInfo, CompareOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.GregorianCalendar : Calendar {
    public static int ADEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public GregorianCalendarTypes CalendarType { get; public set; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public GregorianCalendar(GregorianCalendarTypes type);
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual GregorianCalendarTypes get_CalendarType();
    public virtual void set_CalendarType(GregorianCalendarTypes value);
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.GregorianCalendarTypes : Enum {
    public int value__;
    public static GregorianCalendarTypes Localized;
    public static GregorianCalendarTypes USEnglish;
    public static GregorianCalendarTypes MiddleEastFrench;
    public static GregorianCalendarTypes Arabic;
    public static GregorianCalendarTypes TransliteratedEnglish;
    public static GregorianCalendarTypes TransliteratedFrench;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.HebrewCalendar : Calendar {
    public static int HebrewEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.HijriCalendar : Calendar {
    public static int HijriEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public int HijriAdjustment { get; public set; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public int get_HijriAdjustment();
    public void set_HijriAdjustment(int value);
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.IdnMapping : object {
    public bool AllowUnassigned { get; public set; }
    public bool UseStd3AsciiRules { get; public set; }
    public bool get_AllowUnassigned();
    public void set_AllowUnassigned(bool value);
    public bool get_UseStd3AsciiRules();
    public void set_UseStd3AsciiRules(bool value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public string GetAscii(string unicode);
    public string GetAscii(string unicode, int index);
    public string GetAscii(string unicode, int index, int count);
    public virtual int GetHashCode();
    public string GetUnicode(string ascii);
    public string GetUnicode(string ascii, int index);
    public string GetUnicode(string ascii, int index, int count);
}
public static class System.Globalization.ISOWeek : object {
    public static int GetWeekOfYear(DateTime date);
    public static int GetWeeksInYear(int year);
    public static int GetYear(DateTime date);
    public static DateTime GetYearEnd(int year);
    public static DateTime GetYearStart(int year);
    public static DateTime ToDateTime(int year, int week, DayOfWeek dayOfWeek);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JapaneseCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JapaneseLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int JapaneseEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.JulianCalendar : Calendar {
    public static int JulianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.KoreanCalendar : Calendar {
    public static int KoreanEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.KoreanLunisolarCalendar : EastAsianLunisolarCalendar {
    public static int GregorianEra;
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.NumberFormatInfo : object {
    public int CurrencyDecimalDigits { get; public set; }
    public string CurrencyDecimalSeparator { get; public set; }
    public string CurrencyGroupSeparator { get; public set; }
    public Int32[] CurrencyGroupSizes { get; public set; }
    public int CurrencyNegativePattern { get; public set; }
    public int CurrencyPositivePattern { get; public set; }
    public string CurrencySymbol { get; public set; }
    public static NumberFormatInfo CurrentInfo { get; }
    public DigitShapes DigitSubstitution { get; public set; }
    public static NumberFormatInfo InvariantInfo { get; }
    public bool IsReadOnly { get; }
    public string NaNSymbol { get; public set; }
    public String[] NativeDigits { get; public set; }
    public string NegativeInfinitySymbol { get; public set; }
    public string NegativeSign { get; public set; }
    public int NumberDecimalDigits { get; public set; }
    public string NumberDecimalSeparator { get; public set; }
    public string NumberGroupSeparator { get; public set; }
    public Int32[] NumberGroupSizes { get; public set; }
    public int NumberNegativePattern { get; public set; }
    public int PercentDecimalDigits { get; public set; }
    public string PercentDecimalSeparator { get; public set; }
    public string PercentGroupSeparator { get; public set; }
    public Int32[] PercentGroupSizes { get; public set; }
    public int PercentNegativePattern { get; public set; }
    public int PercentPositivePattern { get; public set; }
    public string PercentSymbol { get; public set; }
    public string PerMilleSymbol { get; public set; }
    public string PositiveInfinitySymbol { get; public set; }
    public string PositiveSign { get; public set; }
    public int get_CurrencyDecimalDigits();
    public void set_CurrencyDecimalDigits(int value);
    public string get_CurrencyDecimalSeparator();
    public void set_CurrencyDecimalSeparator(string value);
    public string get_CurrencyGroupSeparator();
    public void set_CurrencyGroupSeparator(string value);
    public Int32[] get_CurrencyGroupSizes();
    public void set_CurrencyGroupSizes(Int32[] value);
    public int get_CurrencyNegativePattern();
    public void set_CurrencyNegativePattern(int value);
    public int get_CurrencyPositivePattern();
    public void set_CurrencyPositivePattern(int value);
    public string get_CurrencySymbol();
    public void set_CurrencySymbol(string value);
    public static NumberFormatInfo get_CurrentInfo();
    public DigitShapes get_DigitSubstitution();
    public void set_DigitSubstitution(DigitShapes value);
    public static NumberFormatInfo get_InvariantInfo();
    public bool get_IsReadOnly();
    public string get_NaNSymbol();
    public void set_NaNSymbol(string value);
    public String[] get_NativeDigits();
    public void set_NativeDigits(String[] value);
    public string get_NegativeInfinitySymbol();
    public void set_NegativeInfinitySymbol(string value);
    public string get_NegativeSign();
    public void set_NegativeSign(string value);
    public int get_NumberDecimalDigits();
    public void set_NumberDecimalDigits(int value);
    public string get_NumberDecimalSeparator();
    public void set_NumberDecimalSeparator(string value);
    public string get_NumberGroupSeparator();
    public void set_NumberGroupSeparator(string value);
    public Int32[] get_NumberGroupSizes();
    public void set_NumberGroupSizes(Int32[] value);
    public int get_NumberNegativePattern();
    public void set_NumberNegativePattern(int value);
    public int get_PercentDecimalDigits();
    public void set_PercentDecimalDigits(int value);
    public string get_PercentDecimalSeparator();
    public void set_PercentDecimalSeparator(string value);
    public string get_PercentGroupSeparator();
    public void set_PercentGroupSeparator(string value);
    public Int32[] get_PercentGroupSizes();
    public void set_PercentGroupSizes(Int32[] value);
    public int get_PercentNegativePattern();
    public void set_PercentNegativePattern(int value);
    public int get_PercentPositivePattern();
    public void set_PercentPositivePattern(int value);
    public string get_PercentSymbol();
    public void set_PercentSymbol(string value);
    public string get_PerMilleSymbol();
    public void set_PerMilleSymbol(string value);
    public string get_PositiveInfinitySymbol();
    public void set_PositiveInfinitySymbol(string value);
    public string get_PositiveSign();
    public void set_PositiveSign(string value);
    public sealed virtual object Clone();
    [NullableContextAttribute("2")]
public sealed virtual object GetFormat(Type formatType);
    public static NumberFormatInfo GetInstance(IFormatProvider formatProvider);
    public static NumberFormatInfo ReadOnly(NumberFormatInfo nfi);
}
[FlagsAttribute]
public enum System.Globalization.NumberStyles : Enum {
    public int value__;
    public static NumberStyles None;
    public static NumberStyles AllowLeadingWhite;
    public static NumberStyles AllowTrailingWhite;
    public static NumberStyles AllowLeadingSign;
    public static NumberStyles Integer;
    public static NumberStyles AllowTrailingSign;
    public static NumberStyles AllowParentheses;
    public static NumberStyles AllowDecimalPoint;
    public static NumberStyles AllowThousands;
    public static NumberStyles Number;
    public static NumberStyles AllowExponent;
    public static NumberStyles Float;
    public static NumberStyles AllowCurrencySymbol;
    public static NumberStyles Currency;
    public static NumberStyles Any;
    public static NumberStyles AllowHexSpecifier;
    public static NumberStyles HexNumber;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.PersianCalendar : Calendar {
    public static int PersianEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.RegionInfo : object {
    public string CurrencyEnglishName { get; }
    public string CurrencyNativeName { get; }
    public string CurrencySymbol { get; }
    public static RegionInfo CurrentRegion { get; }
    public string DisplayName { get; }
    public string EnglishName { get; }
    public int GeoId { get; }
    public bool IsMetric { get; }
    public string ISOCurrencySymbol { get; }
    public string Name { get; }
    public string NativeName { get; }
    public string ThreeLetterISORegionName { get; }
    public string ThreeLetterWindowsRegionName { get; }
    public string TwoLetterISORegionName { get; }
    public RegionInfo(int culture);
    public RegionInfo(string name);
    public virtual string get_CurrencyEnglishName();
    public virtual string get_CurrencyNativeName();
    public virtual string get_CurrencySymbol();
    public static RegionInfo get_CurrentRegion();
    public virtual string get_DisplayName();
    public virtual string get_EnglishName();
    public virtual int get_GeoId();
    public virtual bool get_IsMetric();
    public virtual string get_ISOCurrencySymbol();
    public virtual string get_Name();
    public virtual string get_NativeName();
    public virtual string get_ThreeLetterISORegionName();
    public virtual string get_ThreeLetterWindowsRegionName();
    public virtual string get_TwoLetterISORegionName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.SortKey : object {
    public Byte[] KeyData { get; }
    public string OriginalString { get; }
    public Byte[] get_KeyData();
    public string get_OriginalString();
    public static int Compare(SortKey sortkey1, SortKey sortkey2);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Globalization.SortVersion : object {
    public int FullVersion { get; }
    public Guid SortId { get; }
    public SortVersion(int fullVersion, Guid sortId);
    public int get_FullVersion();
    public Guid get_SortId();
    public sealed virtual bool Equals(SortVersion other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SortVersion left, SortVersion right);
    public static bool op_Inequality(SortVersion left, SortVersion right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.StringInfo : object {
    public int LengthInTextElements { get; }
    public string String { get; public set; }
    public StringInfo(string value);
    public int get_LengthInTextElements();
    public string get_String();
    public void set_String(string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
    public static string GetNextTextElement(string str);
    public static string GetNextTextElement(string str, int index);
    [NullableContextAttribute("0")]
public static int GetNextTextElementLength(ReadOnlySpan`1<char> str);
    public static int GetNextTextElementLength(string str);
    public static int GetNextTextElementLength(string str, int index);
    public static TextElementEnumerator GetTextElementEnumerator(string str);
    public static TextElementEnumerator GetTextElementEnumerator(string str, int index);
    public static Int32[] ParseCombiningCharacters(string str);
    public string SubstringByTextElements(int startingTextElement);
    public string SubstringByTextElements(int startingTextElement, int lengthInTextElements);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TaiwanCalendar : Calendar {
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TaiwanLunisolarCalendar : EastAsianLunisolarCalendar {
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int GetEra(DateTime time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TextElementEnumerator : object {
    public object Current { get; }
    public int ElementIndex { get; }
    public sealed virtual object get_Current();
    public int get_ElementIndex();
    public string GetTextElement();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.TextInfo : object {
    public int ANSICodePage { get; }
    public string CultureName { get; }
    public int EBCDICCodePage { get; }
    public bool IsReadOnly { get; }
    public bool IsRightToLeft { get; }
    public int LCID { get; }
    public string ListSeparator { get; public set; }
    public int MacCodePage { get; }
    public int OEMCodePage { get; }
    public int get_ANSICodePage();
    public string get_CultureName();
    public int get_EBCDICCodePage();
    public bool get_IsReadOnly();
    public bool get_IsRightToLeft();
    public int get_LCID();
    public string get_ListSeparator();
    public void set_ListSeparator(string value);
    public int get_MacCodePage();
    public int get_OEMCodePage();
    public sealed virtual object Clone();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static TextInfo ReadOnly(TextInfo textInfo);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    public char ToLower(char c);
    public string ToLower(string str);
    public virtual string ToString();
    public string ToTitleCase(string str);
    public char ToUpper(char c);
    public string ToUpper(string str);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.ThaiBuddhistCalendar : Calendar {
    public static int ThaiBuddhistEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetWeekOfYear(DateTime time, CalendarWeekRule rule, DayOfWeek firstDayOfWeek);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
[FlagsAttribute]
public enum System.Globalization.TimeSpanStyles : Enum {
    public int value__;
    public static TimeSpanStyles None;
    public static TimeSpanStyles AssumeNegative;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Globalization.UmAlQuraCalendar : Calendar {
    public static int UmAlQuraEra;
    public CalendarAlgorithmType AlgorithmType { get; }
    protected int DaysInYearBeforeMinSupportedYear { get; }
    public Int32[] Eras { get; }
    public DateTime MaxSupportedDateTime { get; }
    public DateTime MinSupportedDateTime { get; }
    public int TwoDigitYearMax { get; public set; }
    public virtual CalendarAlgorithmType get_AlgorithmType();
    protected virtual int get_DaysInYearBeforeMinSupportedYear();
    public virtual Int32[] get_Eras();
    public virtual DateTime get_MaxSupportedDateTime();
    public virtual DateTime get_MinSupportedDateTime();
    public virtual int get_TwoDigitYearMax();
    public virtual void set_TwoDigitYearMax(int value);
    public virtual DateTime AddMonths(DateTime time, int months);
    public virtual DateTime AddYears(DateTime time, int years);
    public virtual int GetDayOfMonth(DateTime time);
    public virtual DayOfWeek GetDayOfWeek(DateTime time);
    public virtual int GetDayOfYear(DateTime time);
    public virtual int GetDaysInMonth(int year, int month, int era);
    public virtual int GetDaysInYear(int year, int era);
    public virtual int GetEra(DateTime time);
    public virtual int GetLeapMonth(int year, int era);
    public virtual int GetMonth(DateTime time);
    public virtual int GetMonthsInYear(int year, int era);
    public virtual int GetYear(DateTime time);
    public virtual bool IsLeapDay(int year, int month, int day, int era);
    public virtual bool IsLeapMonth(int year, int month, int era);
    public virtual bool IsLeapYear(int year, int era);
    public virtual DateTime ToDateTime(int year, int month, int day, int hour, int minute, int second, int millisecond, int era);
    public virtual int ToFourDigitYear(int year);
}
public enum System.Globalization.UnicodeCategory : Enum {
    public int value__;
    public static UnicodeCategory UppercaseLetter;
    public static UnicodeCategory LowercaseLetter;
    public static UnicodeCategory TitlecaseLetter;
    public static UnicodeCategory ModifierLetter;
    public static UnicodeCategory OtherLetter;
    public static UnicodeCategory NonSpacingMark;
    public static UnicodeCategory SpacingCombiningMark;
    public static UnicodeCategory EnclosingMark;
    public static UnicodeCategory DecimalDigitNumber;
    public static UnicodeCategory LetterNumber;
    public static UnicodeCategory OtherNumber;
    public static UnicodeCategory SpaceSeparator;
    public static UnicodeCategory LineSeparator;
    public static UnicodeCategory ParagraphSeparator;
    public static UnicodeCategory Control;
    public static UnicodeCategory Format;
    public static UnicodeCategory Surrogate;
    public static UnicodeCategory PrivateUse;
    public static UnicodeCategory ConnectorPunctuation;
    public static UnicodeCategory DashPunctuation;
    public static UnicodeCategory OpenPunctuation;
    public static UnicodeCategory ClosePunctuation;
    public static UnicodeCategory InitialQuotePunctuation;
    public static UnicodeCategory FinalQuotePunctuation;
    public static UnicodeCategory OtherPunctuation;
    public static UnicodeCategory MathSymbol;
    public static UnicodeCategory CurrencySymbol;
    public static UnicodeCategory ModifierSymbol;
    public static UnicodeCategory OtherSymbol;
    public static UnicodeCategory OtherNotAssigned;
}
public class System.GopherStyleUriParser : UriParser {
}
[IsReadOnlyAttribute]
public class System.Guid : ValueType {
    private int _dummyPrimitive;
    public static Guid Empty;
    [NullableContextAttribute("1")]
public Guid(Byte[] b);
    public Guid(int a, short b, short c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    [NullableContextAttribute("1")]
public Guid(int a, short b, short c, Byte[] d);
    public Guid(ReadOnlySpan`1<byte> b);
    [NullableContextAttribute("1")]
public Guid(string g);
    [CLSCompliantAttribute("False")]
public Guid(UInt32 a, ushort b, ushort c, byte d, byte e, byte f, byte g, byte h, byte i, byte j, byte k);
    public sealed virtual int CompareTo(Guid value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual bool Equals(Guid g);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Guid NewGuid();
    public static bool op_Equality(Guid a, Guid b);
    public static bool op_GreaterThan(Guid left, Guid right);
    public static bool op_GreaterThanOrEqual(Guid left, Guid right);
    public static bool op_Inequality(Guid a, Guid b);
    public static bool op_LessThan(Guid left, Guid right);
    public static bool op_LessThanOrEqual(Guid left, Guid right);
    public static Guid Parse(ReadOnlySpan`1<char> input);
    public static override Guid Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Guid Parse(string input);
    [NullableContextAttribute("1")]
public static override Guid Parse(string s, IFormatProvider provider);
    public static Guid ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format);
    [NullableContextAttribute("1")]
public static Guid ParseExact(string input, string format);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public Byte[] ToByteArray();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format);
    public static bool TryParse(ReadOnlySpan`1<char> input, Guid& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Guid& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string input, Guid& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Guid& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, Guid& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, Guid& result);
    public bool TryWriteBytes(Span`1<byte> destination);
}
[IsReadOnlyAttribute]
public class System.Half : ValueType {
    private int _dummyPrimitive;
    public static Half E { get; }
    public static Half Epsilon { get; }
    public static Half MaxValue { get; }
    public static Half MinValue { get; }
    public static Half MultiplicativeIdentity { get; }
    public static Half NaN { get; }
    public static Half NegativeInfinity { get; }
    public static Half NegativeOne { get; }
    public static Half NegativeZero { get; }
    public static Half One { get; }
    public static Half Pi { get; }
    public static Half PositiveInfinity { get; }
    private static Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.AdditiveIdentity { get; }
    private static Half System.Numerics.IBinaryNumber<System.Half>.AllBitsSet { get; }
    private static int System.Numerics.INumberBase<System.Half>.Radix { get; }
    public static Half Tau { get; }
    public static Half Zero { get; }
    public static override Half get_E();
    public static override Half get_Epsilon();
    public static override Half get_MaxValue();
    public static override Half get_MinValue();
    public static override Half get_MultiplicativeIdentity();
    public static override Half get_NaN();
    public static override Half get_NegativeInfinity();
    public static override Half get_NegativeOne();
    public static override Half get_NegativeZero();
    public static override Half get_One();
    public static override Half get_Pi();
    public static override Half get_PositiveInfinity();
    private static override Half System.Numerics.IAdditiveIdentity<System.Half,System.Half>.get_AdditiveIdentity();
    private static override Half System.Numerics.IBinaryNumber<System.Half>.get_AllBitsSet();
    private static override int System.Numerics.INumberBase<System.Half>.get_Radix();
    public static override Half get_Tau();
    public static override Half get_Zero();
    public static override Half Abs(Half value);
    public static override Half Acos(Half x);
    public static override Half Acosh(Half x);
    public static override Half AcosPi(Half x);
    public static override Half Asin(Half x);
    public static override Half Asinh(Half x);
    public static override Half AsinPi(Half x);
    public static override Half Atan(Half x);
    public static override Half Atan2(Half y, Half x);
    public static override Half Atan2Pi(Half y, Half x);
    public static override Half Atanh(Half x);
    public static override Half AtanPi(Half x);
    public static override Half BitDecrement(Half x);
    public static override Half BitIncrement(Half x);
    public static override Half Cbrt(Half x);
    public static override Half Ceiling(Half x);
    public static override Half Clamp(Half value, Half min, Half max);
    public sealed virtual int CompareTo(Half other);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public static override Half CopySign(Half value, Half sign);
    public static override Half Cos(Half x);
    public static override Half Cosh(Half x);
    public static override Half CosPi(Half x);
    [NullableContextAttribute("1")]
public static override Half CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override Half CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override Half CreateTruncating(TOther value);
    public sealed virtual bool Equals(Half other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static override Half Exp(Half x);
    public static override Half Exp10(Half x);
    public static override Half Exp10M1(Half x);
    public static override Half Exp2(Half x);
    public static override Half Exp2M1(Half x);
    public static override Half ExpM1(Half x);
    public static override Half Floor(Half x);
    public static override Half FusedMultiplyAdd(Half left, Half right, Half addend);
    public virtual int GetHashCode();
    public static override Half Hypot(Half x, Half y);
    public static override Half Ieee754Remainder(Half left, Half right);
    public static override int ILogB(Half x);
    public static override bool IsEvenInteger(Half value);
    public static override bool IsFinite(Half value);
    public static override bool IsInfinity(Half value);
    public static override bool IsInteger(Half value);
    public static override bool IsNaN(Half value);
    public static override bool IsNegative(Half value);
    public static override bool IsNegativeInfinity(Half value);
    public static override bool IsNormal(Half value);
    public static override bool IsOddInteger(Half value);
    public static override bool IsPositive(Half value);
    public static override bool IsPositiveInfinity(Half value);
    public static override bool IsPow2(Half value);
    public static override bool IsRealNumber(Half value);
    public static override bool IsSubnormal(Half value);
    public static override Half Log(Half x);
    public static override Half Log(Half x, Half newBase);
    public static override Half Log10(Half x);
    public static override Half Log10P1(Half x);
    public static override Half Log2(Half value);
    public static override Half Log2P1(Half x);
    public static override Half LogP1(Half x);
    public static override Half Max(Half x, Half y);
    public static override Half MaxMagnitude(Half x, Half y);
    public static override Half MaxMagnitudeNumber(Half x, Half y);
    public static override Half MaxNumber(Half x, Half y);
    public static override Half Min(Half x, Half y);
    public static override Half MinMagnitude(Half x, Half y);
    public static override Half MinMagnitudeNumber(Half x, Half y);
    public static override Half MinNumber(Half x, Half y);
    public static override Half op_Addition(Half left, Half right);
    public static byte op_CheckedExplicit(Half value);
    public static char op_CheckedExplicit(Half value);
    public static short op_CheckedExplicit(Half value);
    public static int op_CheckedExplicit(Half value);
    public static long op_CheckedExplicit(Half value);
    public static Int128 op_CheckedExplicit(Half value);
    public static IntPtr op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(Half value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(Half value);
    public static override Half op_Decrement(Half value);
    public static override Half op_Division(Half left, Half right);
    public static override bool op_Equality(Half left, Half right);
    public static Half op_Explicit(char value);
    public static Half op_Explicit(decimal value);
    public static Half op_Explicit(double value);
    public static byte op_Explicit(Half value);
    public static char op_Explicit(Half value);
    public static decimal op_Explicit(Half value);
    public static double op_Explicit(Half value);
    public static Int128 op_Explicit(Half value);
    public static short op_Explicit(Half value);
    public static int op_Explicit(Half value);
    public static long op_Explicit(Half value);
    public static IntPtr op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(Half value);
    public static float op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(Half value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Half value);
    public static Half op_Explicit(short value);
    public static Half op_Explicit(int value);
    public static Half op_Explicit(long value);
    public static Half op_Explicit(IntPtr value);
    public static Half op_Explicit(float value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(ulong value);
    [CLSCompliantAttribute("False")]
public static Half op_Explicit(UIntPtr value);
    public static override bool op_GreaterThan(Half left, Half right);
    public static override bool op_GreaterThanOrEqual(Half left, Half right);
    public static Half op_Implicit(byte value);
    [CLSCompliantAttribute("False")]
public static Half op_Implicit(sbyte value);
    public static override Half op_Increment(Half value);
    public static override bool op_Inequality(Half left, Half right);
    public static override bool op_LessThan(Half left, Half right);
    public static override bool op_LessThanOrEqual(Half left, Half right);
    public static override Half op_Modulus(Half left, Half right);
    public static override Half op_Multiply(Half left, Half right);
    public static override Half op_Subtraction(Half left, Half right);
    public static override Half op_UnaryNegation(Half value);
    public static override Half op_UnaryPlus(Half value);
    public static override Half Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override Half Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Half Parse(string s);
    [NullableContextAttribute("1")]
public static Half Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override Half Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override Half Parse(string s, IFormatProvider provider);
    public static override Half Pow(Half x, Half y);
    public static override Half ReciprocalEstimate(Half x);
    public static override Half ReciprocalSqrtEstimate(Half x);
    public static override Half RootN(Half x, int n);
    public static override Half Round(Half x);
    public static override Half Round(Half x, int digits);
    public static override Half Round(Half x, int digits, MidpointRounding mode);
    public static override Half Round(Half x, MidpointRounding mode);
    public static override Half ScaleB(Half x, int n);
    public static override int Sign(Half value);
    public static override Half Sin(Half x);
    public static override ValueTuple`2<Half, Half> SinCos(Half x);
    public static override ValueTuple`2<Half, Half> SinCosPi(Half x);
    public static override Half Sinh(Half x);
    public static override Half SinPi(Half x);
    public static override Half Sqrt(Half x);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_BitwiseAnd(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_BitwiseOr(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_ExclusiveOr(Half left, Half right);
    private static override Half System.Numerics.IBitwiseOperators<System.Half,System.Half,System.Half>.op_OnesComplement(Half value);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetSignificandBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Half>.GetSignificandByteCount();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Half>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override bool System.Numerics.INumberBase<System.Half>.IsCanonical(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsComplexNumber(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsImaginaryNumber(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.IsZero(Half value);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromChecked(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromSaturating(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertFromTruncating(TOther value, Half& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToChecked(Half value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToSaturating(Half value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Half>.TryConvertToTruncating(Half value, TOther& result);
    public static override Half Tan(Half x);
    public static override Half Tanh(Half x);
    public static override Half TanPi(Half x);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override Half Truncate(Half x);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Half& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Half& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Half& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Half& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Half& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Half& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.HashCode : ValueType {
    private int _dummyPrimitive;
    [NullableContextAttribute("0")]
public void AddBytes(ReadOnlySpan`1<byte> value);
    public void Add(T value);
    public void Add(T value, IEqualityComparer`1<T> comparer);
    public static int Combine(T1 value1);
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7);
    public static int Combine(T1 value1, T2 value2, T3 value3, T4 value4, T5 value5, T6 value6, T7 value7, T8 value8);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes.", "True")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("HashCode is a mutable struct and should not be compared with other HashCodes. Use ToHashCode to retrieve the computed hash code.", "True")]
public virtual int GetHashCode();
    public int ToHashCode();
}
public class System.HttpStyleUriParser : UriParser {
}
public interface System.IAsyncDisposable {
    public abstract virtual ValueTask DisposeAsync();
}
[NullableContextAttribute("1")]
public interface System.IAsyncResult {
    [NullableAttribute("2")]
public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    [NullableContextAttribute("2")]
public abstract virtual object get_AsyncState();
    public abstract virtual WaitHandle get_AsyncWaitHandle();
    public abstract virtual bool get_CompletedSynchronously();
    public abstract virtual bool get_IsCompleted();
}
[NullableContextAttribute("1")]
public interface System.ICloneable {
    public abstract virtual object Clone();
}
[NullableContextAttribute("2")]
public interface System.IComparable {
    public abstract virtual int CompareTo(object obj);
}
[NullableContextAttribute("2")]
public interface System.IComparable`1 {
    public abstract virtual int CompareTo(T other);
}
[NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public interface System.IConvertible {
    public abstract virtual TypeCode GetTypeCode();
    public abstract virtual bool ToBoolean(IFormatProvider provider);
    public abstract virtual byte ToByte(IFormatProvider provider);
    public abstract virtual char ToChar(IFormatProvider provider);
    public abstract virtual DateTime ToDateTime(IFormatProvider provider);
    public abstract virtual decimal ToDecimal(IFormatProvider provider);
    public abstract virtual double ToDouble(IFormatProvider provider);
    public abstract virtual short ToInt16(IFormatProvider provider);
    public abstract virtual int ToInt32(IFormatProvider provider);
    public abstract virtual long ToInt64(IFormatProvider provider);
    public abstract virtual sbyte ToSByte(IFormatProvider provider);
    public abstract virtual float ToSingle(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public abstract virtual object ToType(Type conversionType, IFormatProvider provider);
    public abstract virtual ushort ToUInt16(IFormatProvider provider);
    public abstract virtual UInt32 ToUInt32(IFormatProvider provider);
    public abstract virtual ulong ToUInt64(IFormatProvider provider);
}
[NullableContextAttribute("2")]
public interface System.ICustomFormatter {
    public abstract virtual string Format(string format, object arg, IFormatProvider formatProvider);
}
public interface System.IDisposable {
    public abstract virtual void Dispose();
}
[NullableContextAttribute("2")]
public interface System.IEquatable`1 {
    public abstract virtual bool Equals(T other);
}
[NullableContextAttribute("2")]
public interface System.IFormatProvider {
    public abstract virtual object GetFormat(Type formatType);
}
[NullableContextAttribute("2")]
public interface System.IFormattable {
    public abstract virtual string ToString(string format, IFormatProvider formatProvider);
}
[IsReadOnlyAttribute]
public class System.Index : ValueType {
    private int _dummyPrimitive;
    public static Index End { get; }
    public bool IsFromEnd { get; }
    public static Index Start { get; }
    public int Value { get; }
    public Index(int value, bool fromEnd);
    public static Index get_End();
    public bool get_IsFromEnd();
    public static Index get_Start();
    public int get_Value();
    public sealed virtual bool Equals(Index other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public static Index FromEnd(int value);
    public static Index FromStart(int value);
    public virtual int GetHashCode();
    public int GetOffset(int length);
    public static Index op_Implicit(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IndexOutOfRangeException : SystemException {
    public IndexOutOfRangeException(string message);
    public IndexOutOfRangeException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InsufficientExecutionStackException : SystemException {
    public InsufficientExecutionStackException(string message);
    public InsufficientExecutionStackException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InsufficientMemoryException : OutOfMemoryException {
    public InsufficientMemoryException(string message);
    public InsufficientMemoryException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.Int128 : ValueType {
    private int _dummyPrimitive;
    public static Int128 MaxValue { get; }
    public static Int128 MinValue { get; }
    public static Int128 NegativeOne { get; }
    public static Int128 One { get; }
    private static Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.AdditiveIdentity { get; }
    private static Int128 System.Numerics.IBinaryNumber<System.Int128>.AllBitsSet { get; }
    private static Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.MultiplicativeIdentity { get; }
    private static int System.Numerics.INumberBase<System.Int128>.Radix { get; }
    public static Int128 Zero { get; }
    [CLSCompliantAttribute("False")]
public Int128(ulong upper, ulong lower);
    public static override Int128 get_MaxValue();
    public static override Int128 get_MinValue();
    public static override Int128 get_NegativeOne();
    public static override Int128 get_One();
    private static override Int128 System.Numerics.IAdditiveIdentity<System.Int128,System.Int128>.get_AdditiveIdentity();
    private static override Int128 System.Numerics.IBinaryNumber<System.Int128>.get_AllBitsSet();
    private static override Int128 System.Numerics.IMultiplicativeIdentity<System.Int128,System.Int128>.get_MultiplicativeIdentity();
    private static override int System.Numerics.INumberBase<System.Int128>.get_Radix();
    public static override Int128 get_Zero();
    public static override Int128 Abs(Int128 value);
    public static override Int128 Clamp(Int128 value, Int128 min, Int128 max);
    public sealed virtual int CompareTo(Int128 value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override Int128 CopySign(Int128 value, Int128 sign);
    [NullableContextAttribute("1")]
public static override Int128 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override Int128 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override Int128 CreateTruncating(TOther value);
    public static override ValueTuple`2<Int128, Int128> DivRem(Int128 left, Int128 right);
    public sealed virtual bool Equals(Int128 other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static override bool IsEvenInteger(Int128 value);
    public static override bool IsNegative(Int128 value);
    public static override bool IsOddInteger(Int128 value);
    public static override bool IsPositive(Int128 value);
    public static override bool IsPow2(Int128 value);
    public static override Int128 LeadingZeroCount(Int128 value);
    public static override Int128 Log2(Int128 value);
    public static override Int128 Max(Int128 x, Int128 y);
    public static override Int128 MaxMagnitude(Int128 x, Int128 y);
    public static override Int128 Min(Int128 x, Int128 y);
    public static override Int128 MinMagnitude(Int128 x, Int128 y);
    public static override Int128 op_Addition(Int128 left, Int128 right);
    public static override Int128 op_BitwiseAnd(Int128 left, Int128 right);
    public static override Int128 op_BitwiseOr(Int128 left, Int128 right);
    public static override Int128 op_CheckedAddition(Int128 left, Int128 right);
    public static override Int128 op_CheckedDecrement(Int128 value);
    public static override Int128 op_CheckedDivision(Int128 left, Int128 right);
    public static Int128 op_CheckedExplicit(double value);
    public static byte op_CheckedExplicit(Int128 value);
    public static char op_CheckedExplicit(Int128 value);
    public static short op_CheckedExplicit(Int128 value);
    public static int op_CheckedExplicit(Int128 value);
    public static long op_CheckedExplicit(Int128 value);
    public static IntPtr op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(Int128 value);
    public static Int128 op_CheckedExplicit(float value);
    public static override Int128 op_CheckedIncrement(Int128 value);
    public static override Int128 op_CheckedMultiply(Int128 left, Int128 right);
    public static override Int128 op_CheckedSubtraction(Int128 left, Int128 right);
    public static override Int128 op_CheckedUnaryNegation(Int128 value);
    public static override Int128 op_Decrement(Int128 value);
    public static override Int128 op_Division(Int128 left, Int128 right);
    public static override bool op_Equality(Int128 left, Int128 right);
    public static override Int128 op_ExclusiveOr(Int128 left, Int128 right);
    public static Int128 op_Explicit(decimal value);
    public static Int128 op_Explicit(double value);
    public static byte op_Explicit(Int128 value);
    public static char op_Explicit(Int128 value);
    public static decimal op_Explicit(Int128 value);
    public static double op_Explicit(Int128 value);
    public static Half op_Explicit(Int128 value);
    public static short op_Explicit(Int128 value);
    public static int op_Explicit(Int128 value);
    public static long op_Explicit(Int128 value);
    public static IntPtr op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(Int128 value);
    public static float op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(Int128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(Int128 value);
    public static Int128 op_Explicit(float value);
    public static override bool op_GreaterThan(Int128 left, Int128 right);
    public static override bool op_GreaterThanOrEqual(Int128 left, Int128 right);
    public static Int128 op_Implicit(byte value);
    public static Int128 op_Implicit(char value);
    public static Int128 op_Implicit(short value);
    public static Int128 op_Implicit(int value);
    public static Int128 op_Implicit(long value);
    public static Int128 op_Implicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(sbyte value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Implicit(UIntPtr value);
    public static override Int128 op_Increment(Int128 value);
    public static override bool op_Inequality(Int128 left, Int128 right);
    public static override Int128 op_LeftShift(Int128 value, int shiftAmount);
    public static override bool op_LessThan(Int128 left, Int128 right);
    public static override bool op_LessThanOrEqual(Int128 left, Int128 right);
    public static override Int128 op_Modulus(Int128 left, Int128 right);
    public static override Int128 op_Multiply(Int128 left, Int128 right);
    public static override Int128 op_OnesComplement(Int128 value);
    public static override Int128 op_RightShift(Int128 value, int shiftAmount);
    public static override Int128 op_Subtraction(Int128 left, Int128 right);
    public static override Int128 op_UnaryNegation(Int128 value);
    public static override Int128 op_UnaryPlus(Int128 value);
    public static override Int128 op_UnsignedRightShift(Int128 value, int shiftAmount);
    public static override Int128 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override Int128 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Int128 Parse(string s);
    [NullableContextAttribute("1")]
public static Int128 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override Int128 Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override Int128 Parse(string s, IFormatProvider provider);
    public static override Int128 PopCount(Int128 value);
    public static override Int128 RotateLeft(Int128 value, int rotateAmount);
    public static override Int128 RotateRight(Int128 value, int rotateAmount);
    public static override int Sign(Int128 value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int128>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int128>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.Int128>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int128& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int128>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int128& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int128>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsCanonical(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsComplexNumber(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsFinite(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsImaginaryNumber(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsInteger(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNaN(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNegativeInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsNormal(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsPositiveInfinity(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsRealNumber(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsSubnormal(Int128 value);
    private static override bool System.Numerics.INumberBase<System.Int128>.IsZero(Int128 value);
    private static override Int128 System.Numerics.INumberBase<System.Int128>.MaxMagnitudeNumber(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumberBase<System.Int128>.MinMagnitudeNumber(Int128 x, Int128 y);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromChecked(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromSaturating(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertFromTruncating(TOther value, Int128& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToChecked(Int128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToSaturating(Int128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int128>.TryConvertToTruncating(Int128 value, TOther& result);
    private static override Int128 System.Numerics.INumber<System.Int128>.MaxNumber(Int128 x, Int128 y);
    private static override Int128 System.Numerics.INumber<System.Int128>.MinNumber(Int128 x, Int128 y);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override Int128 TrailingZeroCount(Int128 value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int128& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int128& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int128& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int128& result);
}
[IsReadOnlyAttribute]
public class System.Int16 : ValueType {
    private short _dummyPrimitive;
    public static short MaxValue;
    public static short MinValue;
    private static short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.AdditiveIdentity { get; }
    private static short System.Numerics.IBinaryNumber<System.Int16>.AllBitsSet { get; }
    private static short System.Numerics.IMinMaxValue<System.Int16>.MaxValue { get; }
    private static short System.Numerics.IMinMaxValue<System.Int16>.MinValue { get; }
    private static short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.MultiplicativeIdentity { get; }
    private static short System.Numerics.INumberBase<System.Int16>.One { get; }
    private static int System.Numerics.INumberBase<System.Int16>.Radix { get; }
    private static short System.Numerics.INumberBase<System.Int16>.Zero { get; }
    private static short System.Numerics.ISignedNumber<System.Int16>.NegativeOne { get; }
    private static override short System.Numerics.IAdditiveIdentity<System.Int16,System.Int16>.get_AdditiveIdentity();
    private static override short System.Numerics.IBinaryNumber<System.Int16>.get_AllBitsSet();
    private static override short System.Numerics.IMinMaxValue<System.Int16>.get_MaxValue();
    private static override short System.Numerics.IMinMaxValue<System.Int16>.get_MinValue();
    private static override short System.Numerics.IMultiplicativeIdentity<System.Int16,System.Int16>.get_MultiplicativeIdentity();
    private static override short System.Numerics.INumberBase<System.Int16>.get_One();
    private static override int System.Numerics.INumberBase<System.Int16>.get_Radix();
    private static override short System.Numerics.INumberBase<System.Int16>.get_Zero();
    private static override short System.Numerics.ISignedNumber<System.Int16>.get_NegativeOne();
    public static override short Abs(short value);
    public static override short Clamp(short value, short min, short max);
    public sealed virtual int CompareTo(short value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override short CopySign(short value, short sign);
    [NullableContextAttribute("1")]
public static override short CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override short CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override short CreateTruncating(TOther value);
    public static override ValueTuple`2<short, short> DivRem(short left, short right);
    public sealed virtual bool Equals(short obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(short value);
    public static override bool IsNegative(short value);
    public static override bool IsOddInteger(short value);
    public static override bool IsPositive(short value);
    public static override bool IsPow2(short value);
    public static override short LeadingZeroCount(short value);
    public static override short Log2(short value);
    public static override short Max(short x, short y);
    public static override short MaxMagnitude(short x, short y);
    public static override short Min(short x, short y);
    public static override short MinMagnitude(short x, short y);
    public static override short Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override short Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static short Parse(string s);
    [NullableContextAttribute("1")]
public static short Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override short Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override short Parse(string s, IFormatProvider provider);
    public static override short PopCount(short value);
    public static override short RotateLeft(short value, int rotateAmount);
    public static override short RotateRight(short value, int rotateAmount);
    public static override int Sign(short value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override short System.Numerics.IAdditionOperators<System.Int16,System.Int16,System.Int16>.op_Addition(short left, short right);
    private static override short System.Numerics.IAdditionOperators<System.Int16,System.Int16,System.Int16>.op_CheckedAddition(short left, short right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int16>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int16>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.Int16>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int16& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int16>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int16& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int16>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_BitwiseAnd(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_BitwiseOr(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_ExclusiveOr(short left, short right);
    private static override short System.Numerics.IBitwiseOperators<System.Int16,System.Int16,System.Int16>.op_OnesComplement(short value);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_GreaterThan(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_GreaterThanOrEqual(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_LessThan(short left, short right);
    private static override bool System.Numerics.IComparisonOperators<System.Int16,System.Int16,System.Boolean>.op_LessThanOrEqual(short left, short right);
    private static override short System.Numerics.IDecrementOperators<System.Int16>.op_CheckedDecrement(short value);
    private static override short System.Numerics.IDecrementOperators<System.Int16>.op_Decrement(short value);
    private static override short System.Numerics.IDivisionOperators<System.Int16,System.Int16,System.Int16>.op_Division(short left, short right);
    private static override bool System.Numerics.IEqualityOperators<System.Int16,System.Int16,System.Boolean>.op_Equality(short left, short right);
    private static override bool System.Numerics.IEqualityOperators<System.Int16,System.Int16,System.Boolean>.op_Inequality(short left, short right);
    private static override short System.Numerics.IIncrementOperators<System.Int16>.op_CheckedIncrement(short value);
    private static override short System.Numerics.IIncrementOperators<System.Int16>.op_Increment(short value);
    private static override short System.Numerics.IModulusOperators<System.Int16,System.Int16,System.Int16>.op_Modulus(short left, short right);
    private static override short System.Numerics.IMultiplyOperators<System.Int16,System.Int16,System.Int16>.op_CheckedMultiply(short left, short right);
    private static override short System.Numerics.IMultiplyOperators<System.Int16,System.Int16,System.Int16>.op_Multiply(short left, short right);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsCanonical(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsComplexNumber(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsFinite(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsImaginaryNumber(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsInteger(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNaN(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNegativeInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsNormal(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsPositiveInfinity(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsRealNumber(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsSubnormal(short value);
    private static override bool System.Numerics.INumberBase<System.Int16>.IsZero(short value);
    private static override short System.Numerics.INumberBase<System.Int16>.MaxMagnitudeNumber(short x, short y);
    private static override short System.Numerics.INumberBase<System.Int16>.MinMagnitudeNumber(short x, short y);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromChecked(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromSaturating(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertFromTruncating(TOther value, Int16& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToChecked(short value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToSaturating(short value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int16>.TryConvertToTruncating(short value, TOther& result);
    private static override short System.Numerics.INumber<System.Int16>.MaxNumber(short x, short y);
    private static override short System.Numerics.INumber<System.Int16>.MinNumber(short x, short y);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_LeftShift(short value, int shiftAmount);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_RightShift(short value, int shiftAmount);
    private static override short System.Numerics.IShiftOperators<System.Int16,System.Int32,System.Int16>.op_UnsignedRightShift(short value, int shiftAmount);
    private static override short System.Numerics.ISubtractionOperators<System.Int16,System.Int16,System.Int16>.op_CheckedSubtraction(short left, short right);
    private static override short System.Numerics.ISubtractionOperators<System.Int16,System.Int16,System.Int16>.op_Subtraction(short left, short right);
    private static override short System.Numerics.IUnaryNegationOperators<System.Int16,System.Int16>.op_CheckedUnaryNegation(short value);
    private static override short System.Numerics.IUnaryNegationOperators<System.Int16,System.Int16>.op_UnaryNegation(short value);
    private static override short System.Numerics.IUnaryPlusOperators<System.Int16,System.Int16>.op_UnaryPlus(short value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override short TrailingZeroCount(short value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int16& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int16& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int16& result);
}
[IsReadOnlyAttribute]
public class System.Int32 : ValueType {
    private int _dummyPrimitive;
    public static int MaxValue;
    public static int MinValue;
    private static int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.AdditiveIdentity { get; }
    private static int System.Numerics.IBinaryNumber<System.Int32>.AllBitsSet { get; }
    private static int System.Numerics.IMinMaxValue<System.Int32>.MaxValue { get; }
    private static int System.Numerics.IMinMaxValue<System.Int32>.MinValue { get; }
    private static int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.MultiplicativeIdentity { get; }
    private static int System.Numerics.INumberBase<System.Int32>.One { get; }
    private static int System.Numerics.INumberBase<System.Int32>.Radix { get; }
    private static int System.Numerics.INumberBase<System.Int32>.Zero { get; }
    private static int System.Numerics.ISignedNumber<System.Int32>.NegativeOne { get; }
    private static override int System.Numerics.IAdditiveIdentity<System.Int32,System.Int32>.get_AdditiveIdentity();
    private static override int System.Numerics.IBinaryNumber<System.Int32>.get_AllBitsSet();
    private static override int System.Numerics.IMinMaxValue<System.Int32>.get_MaxValue();
    private static override int System.Numerics.IMinMaxValue<System.Int32>.get_MinValue();
    private static override int System.Numerics.IMultiplicativeIdentity<System.Int32,System.Int32>.get_MultiplicativeIdentity();
    private static override int System.Numerics.INumberBase<System.Int32>.get_One();
    private static override int System.Numerics.INumberBase<System.Int32>.get_Radix();
    private static override int System.Numerics.INumberBase<System.Int32>.get_Zero();
    private static override int System.Numerics.ISignedNumber<System.Int32>.get_NegativeOne();
    public static override int Abs(int value);
    public static override int Clamp(int value, int min, int max);
    public sealed virtual int CompareTo(int value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override int CopySign(int value, int sign);
    [NullableContextAttribute("1")]
public static override int CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override int CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override int CreateTruncating(TOther value);
    public static override ValueTuple`2<int, int> DivRem(int left, int right);
    public sealed virtual bool Equals(int obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(int value);
    public static override bool IsNegative(int value);
    public static override bool IsOddInteger(int value);
    public static override bool IsPositive(int value);
    public static override bool IsPow2(int value);
    public static override int LeadingZeroCount(int value);
    public static override int Log2(int value);
    public static override int Max(int x, int y);
    public static override int MaxMagnitude(int x, int y);
    public static override int Min(int x, int y);
    public static override int MinMagnitude(int x, int y);
    public static override int Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override int Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static int Parse(string s);
    [NullableContextAttribute("1")]
public static int Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override int Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override int Parse(string s, IFormatProvider provider);
    public static override int PopCount(int value);
    public static override int RotateLeft(int value, int rotateAmount);
    public static override int RotateRight(int value, int rotateAmount);
    public static override int Sign(int value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override int System.Numerics.IAdditionOperators<System.Int32,System.Int32,System.Int32>.op_Addition(int left, int right);
    private static override int System.Numerics.IAdditionOperators<System.Int32,System.Int32,System.Int32>.op_CheckedAddition(int left, int right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int32>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int32>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.Int32>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int32& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int32>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int32& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int32>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int32>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_BitwiseAnd(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_BitwiseOr(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_ExclusiveOr(int left, int right);
    private static override int System.Numerics.IBitwiseOperators<System.Int32,System.Int32,System.Int32>.op_OnesComplement(int value);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_GreaterThan(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_GreaterThanOrEqual(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_LessThan(int left, int right);
    private static override bool System.Numerics.IComparisonOperators<System.Int32,System.Int32,System.Boolean>.op_LessThanOrEqual(int left, int right);
    private static override int System.Numerics.IDecrementOperators<System.Int32>.op_CheckedDecrement(int value);
    private static override int System.Numerics.IDecrementOperators<System.Int32>.op_Decrement(int value);
    private static override int System.Numerics.IDivisionOperators<System.Int32,System.Int32,System.Int32>.op_Division(int left, int right);
    private static override bool System.Numerics.IEqualityOperators<System.Int32,System.Int32,System.Boolean>.op_Equality(int left, int right);
    private static override bool System.Numerics.IEqualityOperators<System.Int32,System.Int32,System.Boolean>.op_Inequality(int left, int right);
    private static override int System.Numerics.IIncrementOperators<System.Int32>.op_CheckedIncrement(int value);
    private static override int System.Numerics.IIncrementOperators<System.Int32>.op_Increment(int value);
    private static override int System.Numerics.IModulusOperators<System.Int32,System.Int32,System.Int32>.op_Modulus(int left, int right);
    private static override int System.Numerics.IMultiplyOperators<System.Int32,System.Int32,System.Int32>.op_CheckedMultiply(int left, int right);
    private static override int System.Numerics.IMultiplyOperators<System.Int32,System.Int32,System.Int32>.op_Multiply(int left, int right);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsCanonical(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsComplexNumber(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsFinite(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsImaginaryNumber(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsInteger(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNaN(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNegativeInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsNormal(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsPositiveInfinity(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsRealNumber(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsSubnormal(int value);
    private static override bool System.Numerics.INumberBase<System.Int32>.IsZero(int value);
    private static override int System.Numerics.INumberBase<System.Int32>.MaxMagnitudeNumber(int x, int y);
    private static override int System.Numerics.INumberBase<System.Int32>.MinMagnitudeNumber(int x, int y);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromChecked(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromSaturating(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertFromTruncating(TOther value, Int32& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToChecked(int value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToSaturating(int value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int32>.TryConvertToTruncating(int value, TOther& result);
    private static override int System.Numerics.INumber<System.Int32>.MaxNumber(int x, int y);
    private static override int System.Numerics.INumber<System.Int32>.MinNumber(int x, int y);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_LeftShift(int value, int shiftAmount);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_RightShift(int value, int shiftAmount);
    private static override int System.Numerics.IShiftOperators<System.Int32,System.Int32,System.Int32>.op_UnsignedRightShift(int value, int shiftAmount);
    private static override int System.Numerics.ISubtractionOperators<System.Int32,System.Int32,System.Int32>.op_CheckedSubtraction(int left, int right);
    private static override int System.Numerics.ISubtractionOperators<System.Int32,System.Int32,System.Int32>.op_Subtraction(int left, int right);
    private static override int System.Numerics.IUnaryNegationOperators<System.Int32,System.Int32>.op_CheckedUnaryNegation(int value);
    private static override int System.Numerics.IUnaryNegationOperators<System.Int32,System.Int32>.op_UnaryNegation(int value);
    private static override int System.Numerics.IUnaryPlusOperators<System.Int32,System.Int32>.op_UnaryPlus(int value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override int TrailingZeroCount(int value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int32& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int32& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int32& result);
}
[IsReadOnlyAttribute]
public class System.Int64 : ValueType {
    private long _dummyPrimitive;
    public static long MaxValue;
    public static long MinValue;
    private static long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.AdditiveIdentity { get; }
    private static long System.Numerics.IBinaryNumber<System.Int64>.AllBitsSet { get; }
    private static long System.Numerics.IMinMaxValue<System.Int64>.MaxValue { get; }
    private static long System.Numerics.IMinMaxValue<System.Int64>.MinValue { get; }
    private static long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.MultiplicativeIdentity { get; }
    private static long System.Numerics.INumberBase<System.Int64>.One { get; }
    private static int System.Numerics.INumberBase<System.Int64>.Radix { get; }
    private static long System.Numerics.INumberBase<System.Int64>.Zero { get; }
    private static long System.Numerics.ISignedNumber<System.Int64>.NegativeOne { get; }
    private static override long System.Numerics.IAdditiveIdentity<System.Int64,System.Int64>.get_AdditiveIdentity();
    private static override long System.Numerics.IBinaryNumber<System.Int64>.get_AllBitsSet();
    private static override long System.Numerics.IMinMaxValue<System.Int64>.get_MaxValue();
    private static override long System.Numerics.IMinMaxValue<System.Int64>.get_MinValue();
    private static override long System.Numerics.IMultiplicativeIdentity<System.Int64,System.Int64>.get_MultiplicativeIdentity();
    private static override long System.Numerics.INumberBase<System.Int64>.get_One();
    private static override int System.Numerics.INumberBase<System.Int64>.get_Radix();
    private static override long System.Numerics.INumberBase<System.Int64>.get_Zero();
    private static override long System.Numerics.ISignedNumber<System.Int64>.get_NegativeOne();
    public static override long Abs(long value);
    public static override long Clamp(long value, long min, long max);
    public sealed virtual int CompareTo(long value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override long CopySign(long value, long sign);
    [NullableContextAttribute("1")]
public static override long CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override long CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override long CreateTruncating(TOther value);
    public static override ValueTuple`2<long, long> DivRem(long left, long right);
    public sealed virtual bool Equals(long obj);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(long value);
    public static override bool IsNegative(long value);
    public static override bool IsOddInteger(long value);
    public static override bool IsPositive(long value);
    public static override bool IsPow2(long value);
    public static override long LeadingZeroCount(long value);
    public static override long Log2(long value);
    public static override long Max(long x, long y);
    public static override long MaxMagnitude(long x, long y);
    public static override long Min(long x, long y);
    public static override long MinMagnitude(long x, long y);
    public static override long Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override long Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static long Parse(string s);
    [NullableContextAttribute("1")]
public static long Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override long Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override long Parse(string s, IFormatProvider provider);
    public static override long PopCount(long value);
    public static override long RotateLeft(long value, int rotateAmount);
    public static override long RotateRight(long value, int rotateAmount);
    public static override int Sign(long value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override long System.Numerics.IAdditionOperators<System.Int64,System.Int64,System.Int64>.op_Addition(long left, long right);
    private static override long System.Numerics.IAdditionOperators<System.Int64,System.Int64,System.Int64>.op_CheckedAddition(long left, long right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int64>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.Int64>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.Int64>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int64& value);
    private static override bool System.Numerics.IBinaryInteger<System.Int64>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, Int64& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.Int64>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_BitwiseAnd(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_BitwiseOr(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_ExclusiveOr(long left, long right);
    private static override long System.Numerics.IBitwiseOperators<System.Int64,System.Int64,System.Int64>.op_OnesComplement(long value);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_GreaterThan(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_GreaterThanOrEqual(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_LessThan(long left, long right);
    private static override bool System.Numerics.IComparisonOperators<System.Int64,System.Int64,System.Boolean>.op_LessThanOrEqual(long left, long right);
    private static override long System.Numerics.IDecrementOperators<System.Int64>.op_CheckedDecrement(long value);
    private static override long System.Numerics.IDecrementOperators<System.Int64>.op_Decrement(long value);
    private static override long System.Numerics.IDivisionOperators<System.Int64,System.Int64,System.Int64>.op_Division(long left, long right);
    private static override bool System.Numerics.IEqualityOperators<System.Int64,System.Int64,System.Boolean>.op_Equality(long left, long right);
    private static override bool System.Numerics.IEqualityOperators<System.Int64,System.Int64,System.Boolean>.op_Inequality(long left, long right);
    private static override long System.Numerics.IIncrementOperators<System.Int64>.op_CheckedIncrement(long value);
    private static override long System.Numerics.IIncrementOperators<System.Int64>.op_Increment(long value);
    private static override long System.Numerics.IModulusOperators<System.Int64,System.Int64,System.Int64>.op_Modulus(long left, long right);
    private static override long System.Numerics.IMultiplyOperators<System.Int64,System.Int64,System.Int64>.op_CheckedMultiply(long left, long right);
    private static override long System.Numerics.IMultiplyOperators<System.Int64,System.Int64,System.Int64>.op_Multiply(long left, long right);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsCanonical(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsComplexNumber(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsFinite(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsImaginaryNumber(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsInteger(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNaN(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNegativeInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsNormal(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsPositiveInfinity(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsRealNumber(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsSubnormal(long value);
    private static override bool System.Numerics.INumberBase<System.Int64>.IsZero(long value);
    private static override long System.Numerics.INumberBase<System.Int64>.MaxMagnitudeNumber(long x, long y);
    private static override long System.Numerics.INumberBase<System.Int64>.MinMagnitudeNumber(long x, long y);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromChecked(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromSaturating(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertFromTruncating(TOther value, Int64& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToChecked(long value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToSaturating(long value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Int64>.TryConvertToTruncating(long value, TOther& result);
    private static override long System.Numerics.INumber<System.Int64>.MaxNumber(long x, long y);
    private static override long System.Numerics.INumber<System.Int64>.MinNumber(long x, long y);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_LeftShift(long value, int shiftAmount);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_RightShift(long value, int shiftAmount);
    private static override long System.Numerics.IShiftOperators<System.Int64,System.Int32,System.Int64>.op_UnsignedRightShift(long value, int shiftAmount);
    private static override long System.Numerics.ISubtractionOperators<System.Int64,System.Int64,System.Int64>.op_CheckedSubtraction(long left, long right);
    private static override long System.Numerics.ISubtractionOperators<System.Int64,System.Int64,System.Int64>.op_Subtraction(long left, long right);
    private static override long System.Numerics.IUnaryNegationOperators<System.Int64,System.Int64>.op_CheckedUnaryNegation(long value);
    private static override long System.Numerics.IUnaryNegationOperators<System.Int64,System.Int64>.op_UnaryNegation(long value);
    private static override long System.Numerics.IUnaryPlusOperators<System.Int64,System.Int64>.op_UnaryPlus(long value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override long TrailingZeroCount(long value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Int64& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Int64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Int64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Int64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Int64& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Int64& result);
}
[IsReadOnlyAttribute]
public class System.IntPtr : ValueType {
    private Void* _dummyPrimitive;
    public static IntPtr Zero;
    public static IntPtr MaxValue { get; }
    public static IntPtr MinValue { get; }
    public static int Size { get; }
    private static IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.AdditiveIdentity { get; }
    private static IntPtr System.Numerics.IBinaryNumber<nint>.AllBitsSet { get; }
    private static IntPtr System.Numerics.IMinMaxValue<nint>.MaxValue { get; }
    private static IntPtr System.Numerics.IMinMaxValue<nint>.MinValue { get; }
    private static IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.MultiplicativeIdentity { get; }
    private static IntPtr System.Numerics.INumberBase<nint>.One { get; }
    private static int System.Numerics.INumberBase<nint>.Radix { get; }
    private static IntPtr System.Numerics.INumberBase<nint>.Zero { get; }
    private static IntPtr System.Numerics.ISignedNumber<nint>.NegativeOne { get; }
    public IntPtr(int value);
    public IntPtr(long value);
    [CLSCompliantAttribute("False")]
public IntPtr(Void* value);
    public static IntPtr get_MaxValue();
    public static IntPtr get_MinValue();
    public static int get_Size();
    private static override IntPtr System.Numerics.IAdditiveIdentity<nint,nint>.get_AdditiveIdentity();
    private static override IntPtr System.Numerics.IBinaryNumber<nint>.get_AllBitsSet();
    private static override IntPtr System.Numerics.IMinMaxValue<nint>.get_MaxValue();
    private static override IntPtr System.Numerics.IMinMaxValue<nint>.get_MinValue();
    private static override IntPtr System.Numerics.IMultiplicativeIdentity<nint,nint>.get_MultiplicativeIdentity();
    private static override IntPtr System.Numerics.INumberBase<nint>.get_One();
    private static override int System.Numerics.INumberBase<nint>.get_Radix();
    private static override IntPtr System.Numerics.INumberBase<nint>.get_Zero();
    private static override IntPtr System.Numerics.ISignedNumber<nint>.get_NegativeOne();
    public static override IntPtr Abs(IntPtr value);
    public static IntPtr Add(IntPtr pointer, int offset);
    public static override IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
    public sealed virtual int CompareTo(IntPtr value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public static override IntPtr CopySign(IntPtr value, IntPtr sign);
    [NullableContextAttribute("1")]
public static override IntPtr CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override IntPtr CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override IntPtr CreateTruncating(TOther value);
    public static override ValueTuple`2<IntPtr, IntPtr> DivRem(IntPtr left, IntPtr right);
    public sealed virtual bool Equals(IntPtr other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static override bool IsEvenInteger(IntPtr value);
    public static override bool IsNegative(IntPtr value);
    public static override bool IsOddInteger(IntPtr value);
    public static override bool IsPositive(IntPtr value);
    public static override bool IsPow2(IntPtr value);
    public static override IntPtr LeadingZeroCount(IntPtr value);
    public static override IntPtr Log2(IntPtr value);
    public static override IntPtr Max(IntPtr x, IntPtr y);
    public static override IntPtr MaxMagnitude(IntPtr x, IntPtr y);
    public static override IntPtr Min(IntPtr x, IntPtr y);
    public static override IntPtr MinMagnitude(IntPtr x, IntPtr y);
    public static IntPtr op_Addition(IntPtr pointer, int offset);
    public static override bool op_Equality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Explicit(int value);
    public static IntPtr op_Explicit(long value);
    public static int op_Explicit(IntPtr value);
    public static long op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static Void* op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static IntPtr op_Explicit(Void* value);
    public static override bool op_Inequality(IntPtr value1, IntPtr value2);
    public static IntPtr op_Subtraction(IntPtr pointer, int offset);
    public static override IntPtr Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override IntPtr Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static IntPtr Parse(string s);
    [NullableContextAttribute("1")]
public static IntPtr Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override IntPtr Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override IntPtr Parse(string s, IFormatProvider provider);
    public static override IntPtr PopCount(IntPtr value);
    public static override IntPtr RotateLeft(IntPtr value, int rotateAmount);
    public static override IntPtr RotateRight(IntPtr value, int rotateAmount);
    public static override int Sign(IntPtr value);
    public static IntPtr Subtract(IntPtr pointer, int offset);
    private static override IntPtr System.Numerics.IAdditionOperators<nint,nint,nint>.op_Addition(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IAdditionOperators<nint,nint,nint>.op_CheckedAddition(IntPtr left, IntPtr right);
    private sealed virtual override int System.Numerics.IBinaryInteger<nint>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<nint>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<nint>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, IntPtr& value);
    private static override bool System.Numerics.IBinaryInteger<nint>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, IntPtr& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nint>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nint>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_BitwiseAnd(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_BitwiseOr(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_ExclusiveOr(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IBitwiseOperators<nint,nint,nint>.op_OnesComplement(IntPtr value);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_GreaterThan(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_GreaterThanOrEqual(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_LessThan(IntPtr left, IntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nint,nint,System.Boolean>.op_LessThanOrEqual(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IDecrementOperators<nint>.op_CheckedDecrement(IntPtr value);
    private static override IntPtr System.Numerics.IDecrementOperators<nint>.op_Decrement(IntPtr value);
    private static override IntPtr System.Numerics.IDivisionOperators<nint,nint,nint>.op_Division(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IIncrementOperators<nint>.op_CheckedIncrement(IntPtr value);
    private static override IntPtr System.Numerics.IIncrementOperators<nint>.op_Increment(IntPtr value);
    private static override IntPtr System.Numerics.IModulusOperators<nint,nint,nint>.op_Modulus(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IMultiplyOperators<nint,nint,nint>.op_CheckedMultiply(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IMultiplyOperators<nint,nint,nint>.op_Multiply(IntPtr left, IntPtr right);
    private static override bool System.Numerics.INumberBase<nint>.IsCanonical(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsComplexNumber(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsFinite(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsImaginaryNumber(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsInteger(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNaN(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNegativeInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsNormal(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsPositiveInfinity(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsRealNumber(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsSubnormal(IntPtr value);
    private static override bool System.Numerics.INumberBase<nint>.IsZero(IntPtr value);
    private static override IntPtr System.Numerics.INumberBase<nint>.MaxMagnitudeNumber(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumberBase<nint>.MinMagnitudeNumber(IntPtr x, IntPtr y);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromChecked(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromSaturating(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertFromTruncating(TOther value, IntPtr& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToChecked(IntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToSaturating(IntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nint>.TryConvertToTruncating(IntPtr value, TOther& result);
    private static override IntPtr System.Numerics.INumber<nint>.MaxNumber(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.INumber<nint>.MinNumber(IntPtr x, IntPtr y);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_LeftShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_RightShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.IShiftOperators<nint,System.Int32,nint>.op_UnsignedRightShift(IntPtr value, int shiftAmount);
    private static override IntPtr System.Numerics.ISubtractionOperators<nint,nint,nint>.op_CheckedSubtraction(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.ISubtractionOperators<nint,nint,nint>.op_Subtraction(IntPtr left, IntPtr right);
    private static override IntPtr System.Numerics.IUnaryNegationOperators<nint,nint>.op_CheckedUnaryNegation(IntPtr value);
    private static override IntPtr System.Numerics.IUnaryNegationOperators<nint,nint>.op_UnaryNegation(IntPtr value);
    private static override IntPtr System.Numerics.IUnaryPlusOperators<nint,nint>.op_UnaryPlus(IntPtr value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public int ToInt32();
    public long ToInt64();
    [CLSCompliantAttribute("False")]
public Void* ToPointer();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override IntPtr TrailingZeroCount(IntPtr value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, IntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, IntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, IntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, IntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, IntPtr& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IntPtr& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InvalidCastException : SystemException {
    [NullableContextAttribute("1")]
protected InvalidCastException(SerializationInfo info, StreamingContext context);
    public InvalidCastException(string message);
    public InvalidCastException(string message, Exception innerException);
    public InvalidCastException(string message, int errorCode);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InvalidOperationException : SystemException {
    [NullableContextAttribute("1")]
protected InvalidOperationException(SerializationInfo info, StreamingContext context);
    public InvalidOperationException(string message);
    public InvalidOperationException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InvalidProgramException : SystemException {
    public InvalidProgramException(string message);
    public InvalidProgramException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.InvalidTimeZoneException : Exception {
    [NullableContextAttribute("1")]
protected InvalidTimeZoneException(SerializationInfo info, StreamingContext context);
    public InvalidTimeZoneException(string message);
    public InvalidTimeZoneException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BinaryReader : object {
    public Stream BaseStream { get; }
    public BinaryReader(Stream input);
    public BinaryReader(Stream input, Encoding encoding);
    public BinaryReader(Stream input, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void FillBuffer(int numBytes);
    public virtual int PeekChar();
    public virtual int Read();
    public virtual int Read(Byte[] buffer, int index, int count);
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public int Read7BitEncodedInt();
    public long Read7BitEncodedInt64();
    public virtual bool ReadBoolean();
    public virtual byte ReadByte();
    public virtual Byte[] ReadBytes(int count);
    public virtual char ReadChar();
    public virtual Char[] ReadChars(int count);
    public virtual decimal ReadDecimal();
    public virtual double ReadDouble();
    public virtual Half ReadHalf();
    public virtual short ReadInt16();
    public virtual int ReadInt32();
    public virtual long ReadInt64();
    [CLSCompliantAttribute("False")]
public virtual sbyte ReadSByte();
    public virtual float ReadSingle();
    public virtual string ReadString();
    [CLSCompliantAttribute("False")]
public virtual ushort ReadUInt16();
    [CLSCompliantAttribute("False")]
public virtual UInt32 ReadUInt32();
    [CLSCompliantAttribute("False")]
public virtual ulong ReadUInt64();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BinaryWriter : object {
    public static BinaryWriter Null;
    protected Stream OutStream;
    public Stream BaseStream { get; }
    public BinaryWriter(Stream output);
    public BinaryWriter(Stream output, Encoding encoding);
    public BinaryWriter(Stream output, Encoding encoding, bool leaveOpen);
    public virtual Stream get_BaseStream();
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual long Seek(int offset, SeekOrigin origin);
    public virtual void Write(bool value);
    public virtual void Write(byte value);
    public virtual void Write(Byte[] buffer);
    public virtual void Write(Byte[] buffer, int index, int count);
    public virtual void Write(char ch);
    public virtual void Write(Char[] chars);
    public virtual void Write(Char[] chars, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(Half value);
    public virtual void Write(short value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> chars);
    [CLSCompliantAttribute("False")]
public virtual void Write(sbyte value);
    public virtual void Write(float value);
    public virtual void Write(string value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ushort value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public void Write7BitEncodedInt(int value);
    public void Write7BitEncodedInt64(long value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.BufferedStream : Stream {
    public int BufferSize { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public Stream UnderlyingStream { get; }
    public BufferedStream(Stream stream);
    public BufferedStream(Stream stream, int bufferSize);
    public int get_BufferSize();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Stream get_UnderlyingStream();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> destination);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.IO.Directory : object {
    public static DirectoryInfo CreateDirectory(string path);
    [UnsupportedOSPlatformAttribute("windows")]
public static DirectoryInfo CreateDirectory(string path, UnixFileMode unixCreateMode);
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static DirectoryInfo CreateTempSubdirectory(string prefix);
    public static void Delete(string path);
    public static void Delete(string path, bool recursive);
    public static IEnumerable`1<string> EnumerateDirectories(string path);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateDirectories(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFiles(string path);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFiles(string path, string searchPattern, SearchOption searchOption);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static IEnumerable`1<string> EnumerateFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(string path);
    public static string GetCurrentDirectory();
    public static String[] GetDirectories(string path);
    public static String[] GetDirectories(string path, string searchPattern);
    public static String[] GetDirectories(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetDirectories(string path, string searchPattern, SearchOption searchOption);
    public static string GetDirectoryRoot(string path);
    public static String[] GetFiles(string path);
    public static String[] GetFiles(string path, string searchPattern);
    public static String[] GetFiles(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFiles(string path, string searchPattern, SearchOption searchOption);
    public static String[] GetFileSystemEntries(string path);
    public static String[] GetFileSystemEntries(string path, string searchPattern);
    public static String[] GetFileSystemEntries(string path, string searchPattern, EnumerationOptions enumerationOptions);
    public static String[] GetFileSystemEntries(string path, string searchPattern, SearchOption searchOption);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(string path);
    public static String[] GetLogicalDrives();
    public static DirectoryInfo GetParent(string path);
    public static void Move(string sourceDirName, string destDirName);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static void SetCurrentDirectory(string path);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.DirectoryInfo : FileSystemInfo {
    public bool Exists { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public DirectoryInfo Parent { get; }
    public DirectoryInfo Root { get; }
    public DirectoryInfo(string path);
    public virtual bool get_Exists();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public DirectoryInfo get_Parent();
    public DirectoryInfo get_Root();
    public void Create();
    public DirectoryInfo CreateSubdirectory(string path);
    public virtual void Delete();
    public void Delete(bool recursive);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories();
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<DirectoryInfo> EnumerateDirectories(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileInfo> EnumerateFiles();
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileInfo> EnumerateFiles(string searchPattern, SearchOption searchOption);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos();
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public IEnumerable`1<FileSystemInfo> EnumerateFileSystemInfos(string searchPattern, SearchOption searchOption);
    public DirectoryInfo[] GetDirectories();
    public DirectoryInfo[] GetDirectories(string searchPattern);
    public DirectoryInfo[] GetDirectories(string searchPattern, EnumerationOptions enumerationOptions);
    public DirectoryInfo[] GetDirectories(string searchPattern, SearchOption searchOption);
    public FileInfo[] GetFiles();
    public FileInfo[] GetFiles(string searchPattern);
    public FileInfo[] GetFiles(string searchPattern, EnumerationOptions enumerationOptions);
    public FileInfo[] GetFiles(string searchPattern, SearchOption searchOption);
    public FileSystemInfo[] GetFileSystemInfos();
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, EnumerationOptions enumerationOptions);
    public FileSystemInfo[] GetFileSystemInfos(string searchPattern, SearchOption searchOption);
    public void MoveTo(string destDirName);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.DirectoryNotFoundException : IOException {
    [NullableContextAttribute("1")]
protected DirectoryNotFoundException(SerializationInfo info, StreamingContext context);
    public DirectoryNotFoundException(string message);
    public DirectoryNotFoundException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.EndOfStreamException : IOException {
    [NullableContextAttribute("1")]
protected EndOfStreamException(SerializationInfo info, StreamingContext context);
    public EndOfStreamException(string message);
    public EndOfStreamException(string message, Exception innerException);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.IO.Enumeration.FileSystemEntry : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public FileAttributes Attributes { get; }
    public DateTimeOffset CreationTimeUtc { get; }
    public ReadOnlySpan`1<char> Directory { get; }
    public ReadOnlySpan`1<char> FileName { get; }
    public bool IsDirectory { get; }
    public bool IsHidden { get; }
    public DateTimeOffset LastAccessTimeUtc { get; }
    public DateTimeOffset LastWriteTimeUtc { get; }
    public long Length { get; }
    public ReadOnlySpan`1<char> OriginalRootDirectory { get; }
    public ReadOnlySpan`1<char> RootDirectory { get; }
    public FileAttributes get_Attributes();
    public DateTimeOffset get_CreationTimeUtc();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<char> get_Directory();
    public ReadOnlySpan`1<char> get_FileName();
    public bool get_IsDirectory();
    public bool get_IsHidden();
    public DateTimeOffset get_LastAccessTimeUtc();
    public DateTimeOffset get_LastWriteTimeUtc();
    public long get_Length();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<char> get_OriginalRootDirectory();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<char> get_RootDirectory();
    [NullableContextAttribute("1")]
public FileSystemInfo ToFileSystemInfo();
    [NullableContextAttribute("1")]
public string ToFullPath();
    [NullableContextAttribute("1")]
public string ToSpecifiedFullPath();
}
public class System.IO.Enumeration.FileSystemEnumerable`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldIncludePredicate { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public FindPredicate<TResult> ShouldRecursePredicate { get; public set; }
    [NullableContextAttribute("1")]
public FileSystemEnumerable`1(string directory, FindTransform<TResult> transform, EnumerationOptions options);
    public FindPredicate<TResult> get_ShouldIncludePredicate();
    public void set_ShouldIncludePredicate(FindPredicate<TResult> value);
    public FindPredicate<TResult> get_ShouldRecursePredicate();
    public void set_ShouldRecursePredicate(FindPredicate<TResult> value);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator`1<TResult> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public abstract class System.IO.Enumeration.FileSystemEnumerator`1 : CriticalFinalizerObject {
    [NullableAttribute("1")]
public TResult Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableContextAttribute("1")]
public FileSystemEnumerator`1(string directory, EnumerationOptions options);
    [NullableContextAttribute("1")]
public sealed virtual TResult get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    protected virtual bool ContinueOnError(int error);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool MoveNext();
    protected virtual void OnDirectoryFinished(ReadOnlySpan`1<char> directory);
    public sealed virtual void Reset();
    protected virtual bool ShouldIncludeEntry(FileSystemEntry& entry);
    protected virtual bool ShouldRecurseIntoEntry(FileSystemEntry& entry);
    [NullableContextAttribute("1")]
protected abstract virtual TResult TransformEntry(FileSystemEntry& entry);
}
public static class System.IO.Enumeration.FileSystemName : object {
    public static bool MatchesSimpleExpression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    public static bool MatchesWin32Expression(ReadOnlySpan`1<char> expression, ReadOnlySpan`1<char> name, bool ignoreCase);
    [NullableContextAttribute("1")]
public static string TranslateWin32Expression(string expression);
}
public class System.IO.EnumerationOptions : object {
    public FileAttributes AttributesToSkip { get; public set; }
    public int BufferSize { get; public set; }
    public bool IgnoreInaccessible { get; public set; }
    public MatchCasing MatchCasing { get; public set; }
    public MatchType MatchType { get; public set; }
    public int MaxRecursionDepth { get; public set; }
    public bool RecurseSubdirectories { get; public set; }
    public bool ReturnSpecialDirectories { get; public set; }
    public FileAttributes get_AttributesToSkip();
    public void set_AttributesToSkip(FileAttributes value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public bool get_IgnoreInaccessible();
    public void set_IgnoreInaccessible(bool value);
    public MatchCasing get_MatchCasing();
    public void set_MatchCasing(MatchCasing value);
    public MatchType get_MatchType();
    public void set_MatchType(MatchType value);
    public int get_MaxRecursionDepth();
    public void set_MaxRecursionDepth(int value);
    public bool get_RecurseSubdirectories();
    public void set_RecurseSubdirectories(bool value);
    public bool get_ReturnSpecialDirectories();
    public void set_ReturnSpecialDirectories(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.IO.File : object {
    public static void AppendAllLines(string path, IEnumerable`1<string> contents);
    public static void AppendAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static void AppendAllText(string path, string contents);
    public static void AppendAllText(string path, string contents, Encoding encoding);
    public static Task AppendAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task AppendAllTextAsync(string path, string contents, CancellationToken cancellationToken);
    public static StreamWriter AppendText(string path);
    public static void Copy(string sourceFileName, string destFileName);
    public static void Copy(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Create(string path);
    public static FileStream Create(string path, int bufferSize);
    public static FileStream Create(string path, int bufferSize, FileOptions options);
    public static FileSystemInfo CreateSymbolicLink(string path, string pathToTarget);
    public static StreamWriter CreateText(string path);
    [SupportedOSPlatformAttribute("windows")]
public static void Decrypt(string path);
    public static void Delete(string path);
    [SupportedOSPlatformAttribute("windows")]
public static void Encrypt(string path);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    public static FileAttributes GetAttributes(SafeFileHandle fileHandle);
    public static FileAttributes GetAttributes(string path);
    public static DateTime GetCreationTime(SafeFileHandle fileHandle);
    public static DateTime GetCreationTime(string path);
    public static DateTime GetCreationTimeUtc(SafeFileHandle fileHandle);
    public static DateTime GetCreationTimeUtc(string path);
    public static DateTime GetLastAccessTime(SafeFileHandle fileHandle);
    public static DateTime GetLastAccessTime(string path);
    public static DateTime GetLastAccessTimeUtc(SafeFileHandle fileHandle);
    public static DateTime GetLastAccessTimeUtc(string path);
    public static DateTime GetLastWriteTime(SafeFileHandle fileHandle);
    public static DateTime GetLastWriteTime(string path);
    public static DateTime GetLastWriteTimeUtc(SafeFileHandle fileHandle);
    public static DateTime GetLastWriteTimeUtc(string path);
    [UnsupportedOSPlatformAttribute("windows")]
public static UnixFileMode GetUnixFileMode(SafeFileHandle fileHandle);
    [UnsupportedOSPlatformAttribute("windows")]
public static UnixFileMode GetUnixFileMode(string path);
    public static void Move(string sourceFileName, string destFileName);
    public static void Move(string sourceFileName, string destFileName, bool overwrite);
    public static FileStream Open(string path, FileMode mode);
    public static FileStream Open(string path, FileMode mode, FileAccess access);
    public static FileStream Open(string path, FileMode mode, FileAccess access, FileShare share);
    public static FileStream Open(string path, FileStreamOptions options);
    public static SafeFileHandle OpenHandle(string path, FileMode mode, FileAccess access, FileShare share, FileOptions options, long preallocationSize);
    public static FileStream OpenRead(string path);
    public static StreamReader OpenText(string path);
    public static FileStream OpenWrite(string path);
    public static Byte[] ReadAllBytes(string path);
    public static Task`1<Byte[]> ReadAllBytesAsync(string path, CancellationToken cancellationToken);
    public static String[] ReadAllLines(string path);
    public static String[] ReadAllLines(string path, Encoding encoding);
    public static Task`1<String[]> ReadAllLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<String[]> ReadAllLinesAsync(string path, CancellationToken cancellationToken);
    public static string ReadAllText(string path);
    public static string ReadAllText(string path, Encoding encoding);
    public static Task`1<string> ReadAllTextAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static Task`1<string> ReadAllTextAsync(string path, CancellationToken cancellationToken);
    public static IEnumerable`1<string> ReadLines(string path);
    public static IEnumerable`1<string> ReadLines(string path, Encoding encoding);
    public static IAsyncEnumerable`1<string> ReadLinesAsync(string path, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<string> ReadLinesAsync(string path, Encoding encoding, CancellationToken cancellationToken);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName);
    public static void Replace(string sourceFileName, string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
    public static FileSystemInfo ResolveLinkTarget(string linkPath, bool returnFinalTarget);
    public static void SetAttributes(SafeFileHandle fileHandle, FileAttributes fileAttributes);
    public static void SetAttributes(string path, FileAttributes fileAttributes);
    public static void SetCreationTime(SafeFileHandle fileHandle, DateTime creationTime);
    public static void SetCreationTime(string path, DateTime creationTime);
    public static void SetCreationTimeUtc(SafeFileHandle fileHandle, DateTime creationTimeUtc);
    public static void SetCreationTimeUtc(string path, DateTime creationTimeUtc);
    public static void SetLastAccessTime(SafeFileHandle fileHandle, DateTime lastAccessTime);
    public static void SetLastAccessTime(string path, DateTime lastAccessTime);
    public static void SetLastAccessTimeUtc(SafeFileHandle fileHandle, DateTime lastAccessTimeUtc);
    public static void SetLastAccessTimeUtc(string path, DateTime lastAccessTimeUtc);
    public static void SetLastWriteTime(SafeFileHandle fileHandle, DateTime lastWriteTime);
    public static void SetLastWriteTime(string path, DateTime lastWriteTime);
    public static void SetLastWriteTimeUtc(SafeFileHandle fileHandle, DateTime lastWriteTimeUtc);
    public static void SetLastWriteTimeUtc(string path, DateTime lastWriteTimeUtc);
    [UnsupportedOSPlatformAttribute("windows")]
public static void SetUnixFileMode(SafeFileHandle fileHandle, UnixFileMode mode);
    [UnsupportedOSPlatformAttribute("windows")]
public static void SetUnixFileMode(string path, UnixFileMode mode);
    public static void WriteAllBytes(string path, Byte[] bytes);
    public static Task WriteAllBytesAsync(string path, Byte[] bytes, CancellationToken cancellationToken);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents);
    public static void WriteAllLines(string path, IEnumerable`1<string> contents, Encoding encoding);
    public static void WriteAllLines(string path, String[] contents);
    public static void WriteAllLines(string path, String[] contents, Encoding encoding);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllLinesAsync(string path, IEnumerable`1<string> contents, CancellationToken cancellationToken);
    public static void WriteAllText(string path, string contents);
    public static void WriteAllText(string path, string contents, Encoding encoding);
    public static Task WriteAllTextAsync(string path, string contents, Encoding encoding, CancellationToken cancellationToken);
    public static Task WriteAllTextAsync(string path, string contents, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.IO.FileAccess : Enum {
    public int value__;
    public static FileAccess Read;
    public static FileAccess Write;
    public static FileAccess ReadWrite;
}
[FlagsAttribute]
public enum System.IO.FileAttributes : Enum {
    public int value__;
    public static FileAttributes ReadOnly;
    public static FileAttributes Hidden;
    public static FileAttributes System;
    public static FileAttributes Directory;
    public static FileAttributes Archive;
    public static FileAttributes Device;
    public static FileAttributes Normal;
    public static FileAttributes Temporary;
    public static FileAttributes SparseFile;
    public static FileAttributes ReparsePoint;
    public static FileAttributes Compressed;
    public static FileAttributes Offline;
    public static FileAttributes NotContentIndexed;
    public static FileAttributes Encrypted;
    public static FileAttributes IntegrityStream;
    public static FileAttributes NoScrubData;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.FileInfo : FileSystemInfo {
    [NullableAttribute("2")]
public DirectoryInfo Directory { get; }
    [NullableAttribute("2")]
public string DirectoryName { get; }
    public bool Exists { get; }
    public bool IsReadOnly { get; public set; }
    public long Length { get; }
    public string Name { get; }
    public FileInfo(string fileName);
    [NullableContextAttribute("2")]
public DirectoryInfo get_Directory();
    [NullableContextAttribute("2")]
public string get_DirectoryName();
    public virtual bool get_Exists();
    public bool get_IsReadOnly();
    public void set_IsReadOnly(bool value);
    public long get_Length();
    public virtual string get_Name();
    public StreamWriter AppendText();
    public FileInfo CopyTo(string destFileName);
    public FileInfo CopyTo(string destFileName, bool overwrite);
    public FileStream Create();
    public StreamWriter CreateText();
    [SupportedOSPlatformAttribute("windows")]
public void Decrypt();
    public virtual void Delete();
    [SupportedOSPlatformAttribute("windows")]
public void Encrypt();
    public void MoveTo(string destFileName);
    public void MoveTo(string destFileName, bool overwrite);
    public FileStream Open(FileMode mode);
    public FileStream Open(FileMode mode, FileAccess access);
    public FileStream Open(FileMode mode, FileAccess access, FileShare share);
    public FileStream Open(FileStreamOptions options);
    public FileStream OpenRead();
    public StreamReader OpenText();
    public FileStream OpenWrite();
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName);
    public FileInfo Replace(string destinationFileName, string destinationBackupFileName, bool ignoreMetadataErrors);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.FileLoadException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected FileLoadException(SerializationInfo info, StreamingContext context);
    public FileLoadException(string message);
    public FileLoadException(string message, Exception inner);
    public FileLoadException(string message, string fileName);
    public FileLoadException(string message, string fileName, Exception inner);
    public string get_FileName();
    public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public enum System.IO.FileMode : Enum {
    public int value__;
    public static FileMode CreateNew;
    public static FileMode Create;
    public static FileMode Open;
    public static FileMode OpenOrCreate;
    public static FileMode Truncate;
    public static FileMode Append;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.FileNotFoundException : IOException {
    public string FileName { get; }
    public string FusionLog { get; }
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected FileNotFoundException(SerializationInfo info, StreamingContext context);
    public FileNotFoundException(string message);
    public FileNotFoundException(string message, Exception innerException);
    public FileNotFoundException(string message, string fileName);
    public FileNotFoundException(string message, string fileName, Exception innerException);
    public string get_FileName();
    public string get_FusionLog();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.IO.FileOptions : Enum {
    public int value__;
    public static FileOptions WriteThrough;
    public static FileOptions None;
    public static FileOptions Encrypted;
    public static FileOptions DeleteOnClose;
    public static FileOptions SequentialScan;
    public static FileOptions RandomAccess;
    public static FileOptions Asynchronous;
}
[FlagsAttribute]
public enum System.IO.FileShare : Enum {
    public int value__;
    public static FileShare None;
    public static FileShare Read;
    public static FileShare Write;
    public static FileShare ReadWrite;
    public static FileShare Delete;
    public static FileShare Inheritable;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.FileStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    [ObsoleteAttribute("FileStream.Handle has been deprecated. Use FileStream's SafeFileHandle property instead.")]
public IntPtr Handle { get; }
    public bool IsAsync { get; }
    public long Length { get; }
    public string Name { get; }
    public long Position { get; public set; }
    public SafeFileHandle SafeFileHandle { get; }
    public FileStream(SafeFileHandle handle, FileAccess access);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize);
    public FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access) instead.")]
public FileStream(IntPtr handle, FileAccess access);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This constructor has been deprecated. Use FileStream(SafeFileHandle handle, FileAccess access, int bufferSize, bool isAsync) and optionally make a new SafeFileHandle with ownsHandle=false if needed instead.")]
public FileStream(IntPtr handle, FileAccess access, bool ownsHandle, int bufferSize, bool isAsync);
    public FileStream(string path, FileMode mode);
    public FileStream(string path, FileMode mode, FileAccess access);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, bool useAsync);
    public FileStream(string path, FileMode mode, FileAccess access, FileShare share, int bufferSize, FileOptions options);
    public FileStream(string path, FileStreamOptions options);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual IntPtr get_Handle();
    public virtual bool get_IsAsync();
    public virtual long get_Length();
    public virtual string get_Name();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual SafeFileHandle get_SafeFileHandle();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual override void Finalize();
    public virtual void Flush();
    public virtual void Flush(bool flushToDisk);
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("macos")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("freebsd")]
public virtual void Lock(long position, long length);
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [UnsupportedOSPlatformAttribute("ios")]
[UnsupportedOSPlatformAttribute("macos")]
[UnsupportedOSPlatformAttribute("tvos")]
[UnsupportedOSPlatformAttribute("freebsd")]
public virtual void Unlock(long position, long length);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
public class System.IO.FileStreamOptions : object {
    public FileAccess Access { get; public set; }
    public int BufferSize { get; public set; }
    public FileMode Mode { get; public set; }
    public FileOptions Options { get; public set; }
    public long PreallocationSize { get; public set; }
    public FileShare Share { get; public set; }
    public Nullable`1<UnixFileMode> UnixCreateMode { get; public set; }
    public FileAccess get_Access();
    public void set_Access(FileAccess value);
    public int get_BufferSize();
    public void set_BufferSize(int value);
    public FileMode get_Mode();
    public void set_Mode(FileMode value);
    public FileOptions get_Options();
    public void set_Options(FileOptions value);
    public long get_PreallocationSize();
    public void set_PreallocationSize(long value);
    public FileShare get_Share();
    public void set_Share(FileShare value);
    public Nullable`1<UnixFileMode> get_UnixCreateMode();
    [UnsupportedOSPlatformAttribute("windows")]
public void set_UnixCreateMode(Nullable`1<UnixFileMode> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.FileSystemInfo : MarshalByRefObject {
    protected string FullPath;
    protected string OriginalPath;
    public FileAttributes Attributes { get; public set; }
    public DateTime CreationTime { get; public set; }
    public DateTime CreationTimeUtc { get; public set; }
    public bool Exists { get; }
    public string Extension { get; }
    public string FullName { get; }
    public DateTime LastAccessTime { get; public set; }
    public DateTime LastAccessTimeUtc { get; public set; }
    public DateTime LastWriteTime { get; public set; }
    public DateTime LastWriteTimeUtc { get; public set; }
    [NullableAttribute("2")]
public string LinkTarget { get; }
    public string Name { get; }
    public UnixFileMode UnixFileMode { get; public set; }
    protected FileSystemInfo(SerializationInfo info, StreamingContext context);
    public FileAttributes get_Attributes();
    public void set_Attributes(FileAttributes value);
    public DateTime get_CreationTime();
    public void set_CreationTime(DateTime value);
    public DateTime get_CreationTimeUtc();
    public void set_CreationTimeUtc(DateTime value);
    public abstract virtual bool get_Exists();
    public string get_Extension();
    public virtual string get_FullName();
    public DateTime get_LastAccessTime();
    public void set_LastAccessTime(DateTime value);
    public DateTime get_LastAccessTimeUtc();
    public void set_LastAccessTimeUtc(DateTime value);
    public DateTime get_LastWriteTime();
    public void set_LastWriteTime(DateTime value);
    public DateTime get_LastWriteTimeUtc();
    public void set_LastWriteTimeUtc(DateTime value);
    [NullableContextAttribute("2")]
public string get_LinkTarget();
    public abstract virtual string get_Name();
    public UnixFileMode get_UnixFileMode();
    [UnsupportedOSPlatformAttribute("windows")]
public void set_UnixFileMode(UnixFileMode value);
    public void CreateAsSymbolicLink(string pathToTarget);
    public abstract virtual void Delete();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void Refresh();
    [NullableContextAttribute("2")]
public FileSystemInfo ResolveLinkTarget(bool returnFinalTarget);
    public virtual string ToString();
}
public enum System.IO.HandleInheritability : Enum {
    public int value__;
    public static HandleInheritability None;
    public static HandleInheritability Inheritable;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.InvalidDataException : SystemException {
    public InvalidDataException(string message);
    public InvalidDataException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.IOException : SystemException {
    [NullableContextAttribute("1")]
protected IOException(SerializationInfo info, StreamingContext context);
    public IOException(string message);
    public IOException(string message, Exception innerException);
    public IOException(string message, int hresult);
}
public enum System.IO.MatchCasing : Enum {
    public int value__;
    public static MatchCasing PlatformDefault;
    public static MatchCasing CaseSensitive;
    public static MatchCasing CaseInsensitive;
}
public enum System.IO.MatchType : Enum {
    public int value__;
    public static MatchType Simple;
    public static MatchType Win32;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.MemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public int Capacity { get; public set; }
    public long Length { get; }
    public long Position { get; public set; }
    public MemoryStream(Byte[] buffer);
    public MemoryStream(Byte[] buffer, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable);
    public MemoryStream(Byte[] buffer, int index, int count, bool writable, bool publiclyVisible);
    public MemoryStream(int capacity);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual int get_Capacity();
    public virtual void set_Capacity(int value);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual Byte[] GetBuffer();
    public virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    public virtual Byte[] ToArray();
    [NullableContextAttribute("0")]
public virtual bool TryGetBuffer(ArraySegment`1& buffer);
    public virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
    public virtual void WriteTo(Stream stream);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.IO.Path : object {
    public static char AltDirectorySeparatorChar;
    public static char DirectorySeparatorChar;
    [ObsoleteAttribute("Path.InvalidPathChars has been deprecated. Use GetInvalidPathChars or GetInvalidFileNameChars instead.")]
public static Char[] InvalidPathChars;
    public static char PathSeparator;
    public static char VolumeSeparatorChar;
    [NullableContextAttribute("2")]
public static string ChangeExtension(string path, string extension);
    public static string Combine(string path1, string path2);
    public static string Combine(string path1, string path2, string path3);
    public static string Combine(string path1, string path2, string path3, string path4);
    public static string Combine(String[] paths);
    [NullableContextAttribute("0")]
public static bool EndsInDirectorySeparator(ReadOnlySpan`1<char> path);
    public static bool EndsInDirectorySeparator(string path);
    [NullableContextAttribute("2")]
public static bool Exists(string path);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> GetDirectoryName(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetDirectoryName(string path);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> GetExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetExtension(string path);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> GetFileName(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileName(string path);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> GetFileNameWithoutExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetFileNameWithoutExtension(string path);
    public static string GetFullPath(string path);
    public static string GetFullPath(string path, string basePath);
    public static Char[] GetInvalidFileNameChars();
    public static Char[] GetInvalidPathChars();
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> GetPathRoot(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static string GetPathRoot(string path);
    public static string GetRandomFileName();
    public static string GetRelativePath(string relativeTo, string path);
    public static string GetTempFileName();
    public static string GetTempPath();
    [NullableContextAttribute("0")]
public static bool HasExtension(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool HasExtension(string path);
    [NullableContextAttribute("0")]
public static bool IsPathFullyQualified(ReadOnlySpan`1<char> path);
    public static bool IsPathFullyQualified(string path);
    [NullableContextAttribute("0")]
public static bool IsPathRooted(ReadOnlySpan`1<char> path);
    [NullableContextAttribute("2")]
public static bool IsPathRooted(string path);
    [NullableContextAttribute("0")]
public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2);
    [NullableContextAttribute("0")]
public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3);
    [NullableContextAttribute("0")]
public static string Join(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, ReadOnlySpan`1<char> path4);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3);
    [NullableContextAttribute("2")]
public static string Join(string path1, string path2, string path3, string path4);
    public static string Join(String[] paths);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> TrimEndingDirectorySeparator(ReadOnlySpan`1<char> path);
    public static string TrimEndingDirectorySeparator(string path);
    [NullableContextAttribute("0")]
public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, ReadOnlySpan`1<char> path3, Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public static bool TryJoin(ReadOnlySpan`1<char> path1, ReadOnlySpan`1<char> path2, Span`1<char> destination, Int32& charsWritten);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.IO.PathTooLongException : IOException {
    [NullableContextAttribute("1")]
protected PathTooLongException(SerializationInfo info, StreamingContext context);
    public PathTooLongException(string message);
    public PathTooLongException(string message, Exception innerException);
}
public static class System.IO.RandomAccess : object {
    [NullableContextAttribute("1")]
public static long GetLength(SafeFileHandle handle);
    [NullableContextAttribute("1")]
public static void SetLength(SafeFileHandle handle, long length);
    [NullableContextAttribute("1")]
public static long Read(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset);
    public static int Read(SafeFileHandle handle, Span`1<byte> buffer, long fileOffset);
    public static ValueTask`1<long> ReadAsync(SafeFileHandle handle, IReadOnlyList`1<Memory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
    public static ValueTask`1<int> ReadAsync(SafeFileHandle handle, Memory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static void Write(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset);
    public static void Write(SafeFileHandle handle, ReadOnlySpan`1<byte> buffer, long fileOffset);
    [NullableContextAttribute("1")]
public static ValueTask WriteAsync(SafeFileHandle handle, IReadOnlyList`1<ReadOnlyMemory`1<byte>> buffers, long fileOffset, CancellationToken cancellationToken);
    public static ValueTask WriteAsync(SafeFileHandle handle, ReadOnlyMemory`1<byte> buffer, long fileOffset, CancellationToken cancellationToken);
}
public enum System.IO.SearchOption : Enum {
    public int value__;
    public static SearchOption TopDirectoryOnly;
    public static SearchOption AllDirectories;
}
public enum System.IO.SeekOrigin : Enum {
    public int value__;
    public static SeekOrigin Begin;
    public static SeekOrigin Current;
    public static SeekOrigin End;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.Stream : MarshalByRefObject {
    public static Stream Null;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public int ReadTimeout { get; public set; }
    public int WriteTimeout { get; public set; }
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public abstract virtual bool get_CanWrite();
    public abstract virtual long get_Length();
    public abstract virtual long get_Position();
    public abstract virtual void set_Position(long value);
    public virtual int get_ReadTimeout();
    public virtual void set_ReadTimeout(int value);
    public virtual int get_WriteTimeout();
    public virtual void set_WriteTimeout(int value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public void CopyTo(Stream destination);
    public virtual void CopyTo(Stream destination, int bufferSize);
    public Task CopyToAsync(Stream destination);
    public Task CopyToAsync(Stream destination, int bufferSize);
    public virtual Task CopyToAsync(Stream destination, int bufferSize, CancellationToken cancellationToken);
    public Task CopyToAsync(Stream destination, CancellationToken cancellationToken);
    [ObsoleteAttribute("CreateWaitHandle has been deprecated. Use the ManualResetEvent(false) constructor instead.")]
protected virtual WaitHandle CreateWaitHandle();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public abstract virtual void Flush();
    public Task FlushAsync();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    [ObsoleteAttribute("Do not call or override this method.")]
protected virtual void ObjectInvariant();
    public abstract virtual int Read(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<byte> buffer);
    public Task`1<int> ReadAsync(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public int ReadAtLeast(Span`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream);
    [NullableContextAttribute("0")]
public ValueTask`1<int> ReadAtLeastAsync(Memory`1<byte> buffer, int minimumBytes, bool throwOnEndOfStream, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public void ReadExactly(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public void ReadExactly(Span`1<byte> buffer);
    public ValueTask ReadExactlyAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public ValueTask ReadExactlyAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public abstract virtual long Seek(long offset, SeekOrigin origin);
    public abstract virtual void SetLength(long value);
    public static Stream Synchronized(Stream stream);
    protected static void ValidateBufferArguments(Byte[] buffer, int offset, int count);
    protected static void ValidateCopyToArguments(Stream destination, int bufferSize);
    public abstract virtual void Write(Byte[] buffer, int offset, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<byte> buffer);
    public Task WriteAsync(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StreamReader : TextReader {
    public static StreamReader Null;
    public Stream BaseStream { get; }
    public Encoding CurrentEncoding { get; }
    public bool EndOfStream { get; }
    public StreamReader(Stream stream);
    public StreamReader(Stream stream, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(Stream stream, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize, bool leaveOpen);
    public StreamReader(string path);
    public StreamReader(string path, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, FileStreamOptions options);
    public StreamReader(string path, Encoding encoding);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, int bufferSize);
    public StreamReader(string path, Encoding encoding, bool detectEncodingFromByteOrderMarks, FileStreamOptions options);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_CurrentEncoding();
    public bool get_EndOfStream();
    public virtual void Close();
    public void DiscardBufferedData();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StreamWriter : TextWriter {
    public static StreamWriter Null;
    public bool AutoFlush { get; public set; }
    public Stream BaseStream { get; }
    public Encoding Encoding { get; }
    public StreamWriter(Stream stream);
    public StreamWriter(Stream stream, Encoding encoding);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize);
    public StreamWriter(Stream stream, Encoding encoding, int bufferSize, bool leaveOpen);
    public StreamWriter(string path);
    public StreamWriter(string path, bool append);
    public StreamWriter(string path, bool append, Encoding encoding);
    public StreamWriter(string path, bool append, Encoding encoding, int bufferSize);
    public StreamWriter(string path, FileStreamOptions options);
    public StreamWriter(string path, Encoding encoding, FileStreamOptions options);
    public virtual bool get_AutoFlush();
    public virtual void set_AutoFlush(bool value);
    public virtual Stream get_BaseStream();
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StringReader : TextReader {
    public StringReader(string s);
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.IO.StringWriter : TextWriter {
    public Encoding Encoding { get; }
    [NullableContextAttribute("2")]
public StringWriter(IFormatProvider formatProvider);
    public StringWriter(StringBuilder sb);
    public StringWriter(StringBuilder sb, IFormatProvider formatProvider);
    public virtual Encoding get_Encoding();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual Task FlushAsync();
    public virtual StringBuilder GetStringBuilder();
    public virtual string ToString();
    public virtual void Write(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    [NullableContextAttribute("2")]
public virtual void Write(StringBuilder value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    [NullableContextAttribute("2")]
public virtual void WriteLine(StringBuilder value);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextReader : MarshalByRefObject {
    public static TextReader Null;
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int Read(Span`1<char> buffer);
    public virtual Task`1<int> ReadAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual int ReadBlock(Span`1<char> buffer);
    public virtual Task`1<int> ReadBlockAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual ValueTask`1<int> ReadBlockAsync(Memory`1<char> buffer, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public virtual string ReadLine();
    public virtual Task`1<string> ReadLineAsync();
    public virtual ValueTask`1<string> ReadLineAsync(CancellationToken cancellationToken);
    public virtual string ReadToEnd();
    public virtual Task`1<string> ReadToEndAsync();
    public virtual Task`1<string> ReadToEndAsync(CancellationToken cancellationToken);
    public static TextReader Synchronized(TextReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.IO.TextWriter : MarshalByRefObject {
    protected Char[] CoreNewLine;
    public static TextWriter Null;
    public Encoding Encoding { get; }
    public IFormatProvider FormatProvider { get; }
    public string NewLine { get; public set; }
    [NullableContextAttribute("2")]
protected TextWriter(IFormatProvider formatProvider);
    public abstract virtual Encoding get_Encoding();
    public virtual IFormatProvider get_FormatProvider();
    public virtual string get_NewLine();
    public virtual void set_NewLine(string value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual ValueTask DisposeAsync();
    public virtual void Flush();
    public virtual Task FlushAsync();
    public static TextWriter Synchronized(TextWriter writer);
    public virtual void Write(bool value);
    public virtual void Write(char value);
    [NullableContextAttribute("2")]
public virtual void Write(Char[] buffer);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    [NullableContextAttribute("2")]
public virtual void Write(object value);
    [NullableContextAttribute("0")]
public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(float value);
    [NullableContextAttribute("2")]
public virtual void Write(string value);
    public virtual void Write(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    [NullableContextAttribute("2")]
public virtual void Write(StringBuilder value);
    [CLSCompliantAttribute("False")]
public virtual void Write(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void Write(ulong value);
    public virtual Task WriteAsync(char value);
    public Task WriteAsync(Char[] buffer);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteAsync(StringBuilder value, CancellationToken cancellationToken);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(object value);
    [NullableContextAttribute("0")]
public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(float value);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    [NullableContextAttribute("2")]
public virtual void WriteLine(StringBuilder value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(UInt32 value);
    [CLSCompliantAttribute("False")]
public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public Task WriteLineAsync(Char[] buffer);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    [NullableContextAttribute("0")]
public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
    public virtual Task WriteLineAsync(StringBuilder value, CancellationToken cancellationToken);
}
[FlagsAttribute]
public enum System.IO.UnixFileMode : Enum {
    public int value__;
    public static UnixFileMode None;
    public static UnixFileMode OtherExecute;
    public static UnixFileMode OtherWrite;
    public static UnixFileMode OtherRead;
    public static UnixFileMode GroupExecute;
    public static UnixFileMode GroupWrite;
    public static UnixFileMode GroupRead;
    public static UnixFileMode UserExecute;
    public static UnixFileMode UserWrite;
    public static UnixFileMode UserRead;
    public static UnixFileMode StickyBit;
    public static UnixFileMode SetGroup;
    public static UnixFileMode SetUser;
}
public class System.IO.UnmanagedMemoryStream : Stream {
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Capacity { get; }
    public long Length { get; }
    public long Position { get; public set; }
    [CLSCompliantAttribute("False")]
public Byte* PositionPointer { get; public set; }
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length);
    [CLSCompliantAttribute("False")]
public UnmanagedMemoryStream(Byte* pointer, long length, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length);
    [NullableContextAttribute("1")]
public UnmanagedMemoryStream(SafeBuffer buffer, long offset, long length, FileAccess access);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public long get_Capacity();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public Byte* get_PositionPointer();
    public void set_PositionPointer(Byte* value);
    protected virtual void Dispose(bool disposing);
    public virtual void Flush();
    [NullableContextAttribute("1")]
public virtual Task FlushAsync(CancellationToken cancellationToken);
    [CLSCompliantAttribute("False")]
protected void Initialize(Byte* pointer, long length, long capacity, FileAccess access);
    [NullableContextAttribute("1")]
protected void Initialize(SafeBuffer buffer, long offset, long length, FileAccess access);
    [NullableContextAttribute("1")]
public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual int Read(Span`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask`1<int> ReadAsync(Memory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual int ReadByte();
    public virtual long Seek(long offset, SeekOrigin loc);
    public virtual void SetLength(long value);
    [NullableContextAttribute("1")]
public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void Write(ReadOnlySpan`1<byte> buffer);
    [NullableContextAttribute("1")]
public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual ValueTask WriteAsync(ReadOnlyMemory`1<byte> buffer, CancellationToken cancellationToken);
    public virtual void WriteByte(byte value);
}
[NullableContextAttribute("1")]
public interface System.IObservable`1 {
    public abstract virtual IDisposable Subscribe(IObserver`1<T> observer);
}
[NullableContextAttribute("1")]
public interface System.IObserver`1 {
    public abstract virtual void OnCompleted();
    public abstract virtual void OnError(Exception error);
    public abstract virtual void OnNext(T value);
}
public interface System.IParsable`1 {
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("2")]
public static abstract virtual bool TryParse(string s, IFormatProvider provider, TSelf& result);
}
[NullableContextAttribute("1")]
public interface System.IProgress`1 {
    public abstract virtual void Report(T value);
}
public interface System.ISpanFormattable {
    public abstract virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
}
public interface System.ISpanParsable`1 {
    public static abstract virtual TSelf Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static abstract virtual bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, TSelf& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Lazy`1 : object {
    public bool IsValueCreated { get; }
    public T Value { get; }
    public Lazy`1(bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory);
    public Lazy`1(Func`1<T> valueFactory, bool isThreadSafe);
    public Lazy`1(Func`1<T> valueFactory, LazyThreadSafetyMode mode);
    public Lazy`1(LazyThreadSafetyMode mode);
    public Lazy`1(T value);
    public bool get_IsValueCreated();
    public T get_Value();
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class System.Lazy`2 : Lazy`1<T> {
    public TMetadata Metadata { get; }
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, bool isThreadSafe);
    public Lazy`2(Func`1<T> valueFactory, TMetadata metadata, LazyThreadSafetyMode mode);
    public Lazy`2(TMetadata metadata);
    public Lazy`2(TMetadata metadata, bool isThreadSafe);
    public Lazy`2(TMetadata metadata, LazyThreadSafetyMode mode);
    public TMetadata get_Metadata();
}
public class System.LdapStyleUriParser : UriParser {
}
public enum System.LoaderOptimization : Enum {
    public int value__;
    public static LoaderOptimization NotSpecified;
    public static LoaderOptimization SingleDomain;
    public static LoaderOptimization MultiDomain;
    [ObsoleteAttribute("LoaderOptimization.DomainMask has been deprecated and is not supported.")]
public static LoaderOptimization DomainMask;
    public static LoaderOptimization MultiDomainHost;
    [ObsoleteAttribute("LoaderOptimization.DisallowBindings has been deprecated and is not supported.")]
public static LoaderOptimization DisallowBindings;
}
[AttributeUsageAttribute("64")]
public class System.LoaderOptimizationAttribute : Attribute {
    public LoaderOptimization Value { get; }
    public LoaderOptimizationAttribute(byte value);
    public LoaderOptimizationAttribute(LoaderOptimization value);
    public LoaderOptimization get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.MarshalByRefObject : object {
    [ObsoleteAttribute("This Remoting API is not supported and throws PlatformNotSupportedException.")]
public object GetLifetimeService();
    [ObsoleteAttribute("This Remoting API is not supported and throws PlatformNotSupportedException.")]
public virtual object InitializeLifetimeService();
    protected MarshalByRefObject MemberwiseClone(bool cloneIdentity);
}
public static class System.Math : object {
    public static double E;
    public static double PI;
    public static double Tau;
    public static decimal Abs(decimal value);
    public static double Abs(double value);
    public static short Abs(short value);
    public static int Abs(int value);
    public static long Abs(long value);
    public static IntPtr Abs(IntPtr value);
    [CLSCompliantAttribute("False")]
public static sbyte Abs(sbyte value);
    public static float Abs(float value);
    public static double Acos(double d);
    public static double Acosh(double d);
    public static double Asin(double d);
    public static double Asinh(double d);
    public static double Atan(double d);
    public static double Atan2(double y, double x);
    public static double Atanh(double d);
    public static long BigMul(int a, int b);
    public static long BigMul(long a, long b, Int64& low);
    [CLSCompliantAttribute("False")]
public static ulong BigMul(ulong a, ulong b, UInt64& low);
    public static double BitDecrement(double x);
    public static double BitIncrement(double x);
    public static double Cbrt(double d);
    public static decimal Ceiling(decimal d);
    public static double Ceiling(double a);
    public static byte Clamp(byte value, byte min, byte max);
    public static decimal Clamp(decimal value, decimal min, decimal max);
    public static double Clamp(double value, double min, double max);
    public static short Clamp(short value, short min, short max);
    public static int Clamp(int value, int min, int max);
    public static long Clamp(long value, long min, long max);
    public static IntPtr Clamp(IntPtr value, IntPtr min, IntPtr max);
    [CLSCompliantAttribute("False")]
public static sbyte Clamp(sbyte value, sbyte min, sbyte max);
    public static float Clamp(float value, float min, float max);
    [CLSCompliantAttribute("False")]
public static ushort Clamp(ushort value, ushort min, ushort max);
    [CLSCompliantAttribute("False")]
public static UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [CLSCompliantAttribute("False")]
public static ulong Clamp(ulong value, ulong min, ulong max);
    [CLSCompliantAttribute("False")]
public static UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
    public static double CopySign(double x, double y);
    public static double Cos(double d);
    public static double Cosh(double value);
    public static int DivRem(int a, int b, Int32& result);
    public static long DivRem(long a, long b, Int64& result);
    public static ValueTuple`2<byte, byte> DivRem(byte left, byte right);
    public static ValueTuple`2<short, short> DivRem(short left, short right);
    public static ValueTuple`2<int, int> DivRem(int left, int right);
    public static ValueTuple`2<long, long> DivRem(long left, long right);
    public static ValueTuple`2<IntPtr, IntPtr> DivRem(IntPtr left, IntPtr right);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<sbyte, sbyte> DivRem(sbyte left, sbyte right);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<ushort, ushort> DivRem(ushort left, ushort right);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<UInt32, UInt32> DivRem(UInt32 left, UInt32 right);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<ulong, ulong> DivRem(ulong left, ulong right);
    [CLSCompliantAttribute("False")]
public static ValueTuple`2<UIntPtr, UIntPtr> DivRem(UIntPtr left, UIntPtr right);
    public static double Exp(double d);
    public static decimal Floor(decimal d);
    public static double Floor(double d);
    public static double FusedMultiplyAdd(double x, double y, double z);
    public static double IEEERemainder(double x, double y);
    public static int ILogB(double x);
    public static double Log(double d);
    public static double Log(double a, double newBase);
    public static double Log10(double d);
    public static double Log2(double x);
    public static byte Max(byte val1, byte val2);
    public static decimal Max(decimal val1, decimal val2);
    public static double Max(double val1, double val2);
    public static short Max(short val1, short val2);
    public static int Max(int val1, int val2);
    public static long Max(long val1, long val2);
    public static IntPtr Max(IntPtr val1, IntPtr val2);
    [CLSCompliantAttribute("False")]
public static sbyte Max(sbyte val1, sbyte val2);
    public static float Max(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Max(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Max(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Max(ulong val1, ulong val2);
    [CLSCompliantAttribute("False")]
public static UIntPtr Max(UIntPtr val1, UIntPtr val2);
    public static double MaxMagnitude(double x, double y);
    public static byte Min(byte val1, byte val2);
    public static decimal Min(decimal val1, decimal val2);
    public static double Min(double val1, double val2);
    public static short Min(short val1, short val2);
    public static int Min(int val1, int val2);
    public static long Min(long val1, long val2);
    public static IntPtr Min(IntPtr val1, IntPtr val2);
    [CLSCompliantAttribute("False")]
public static sbyte Min(sbyte val1, sbyte val2);
    public static float Min(float val1, float val2);
    [CLSCompliantAttribute("False")]
public static ushort Min(ushort val1, ushort val2);
    [CLSCompliantAttribute("False")]
public static UInt32 Min(UInt32 val1, UInt32 val2);
    [CLSCompliantAttribute("False")]
public static ulong Min(ulong val1, ulong val2);
    [CLSCompliantAttribute("False")]
public static UIntPtr Min(UIntPtr val1, UIntPtr val2);
    public static double MinMagnitude(double x, double y);
    public static double Pow(double x, double y);
    public static double ReciprocalEstimate(double d);
    public static double ReciprocalSqrtEstimate(double d);
    public static decimal Round(decimal d);
    public static decimal Round(decimal d, int decimals);
    public static decimal Round(decimal d, int decimals, MidpointRounding mode);
    public static decimal Round(decimal d, MidpointRounding mode);
    public static double Round(double a);
    public static double Round(double value, int digits);
    public static double Round(double value, int digits, MidpointRounding mode);
    public static double Round(double value, MidpointRounding mode);
    public static double ScaleB(double x, int n);
    public static int Sign(decimal value);
    public static int Sign(double value);
    public static int Sign(short value);
    public static int Sign(int value);
    public static int Sign(long value);
    public static int Sign(IntPtr value);
    [CLSCompliantAttribute("False")]
public static int Sign(sbyte value);
    public static int Sign(float value);
    public static double Sin(double a);
    public static ValueTuple`2<double, double> SinCos(double x);
    public static double Sinh(double value);
    public static double Sqrt(double d);
    public static double Tan(double a);
    public static double Tanh(double value);
    public static decimal Truncate(decimal d);
    public static double Truncate(double d);
}
public static class System.MathF : object {
    public static float E;
    public static float PI;
    public static float Tau;
    public static float Abs(float x);
    public static float Acos(float x);
    public static float Acosh(float x);
    public static float Asin(float x);
    public static float Asinh(float x);
    public static float Atan(float x);
    public static float Atan2(float y, float x);
    public static float Atanh(float x);
    public static float BitDecrement(float x);
    public static float BitIncrement(float x);
    public static float Cbrt(float x);
    public static float Ceiling(float x);
    public static float CopySign(float x, float y);
    public static float Cos(float x);
    public static float Cosh(float x);
    public static float Exp(float x);
    public static float Floor(float x);
    public static float FusedMultiplyAdd(float x, float y, float z);
    public static float IEEERemainder(float x, float y);
    public static int ILogB(float x);
    public static float Log(float x);
    public static float Log(float x, float y);
    public static float Log10(float x);
    public static float Log2(float x);
    public static float Max(float x, float y);
    public static float MaxMagnitude(float x, float y);
    public static float Min(float x, float y);
    public static float MinMagnitude(float x, float y);
    public static float Pow(float x, float y);
    public static float ReciprocalEstimate(float x);
    public static float ReciprocalSqrtEstimate(float x);
    public static float Round(float x);
    public static float Round(float x, int digits);
    public static float Round(float x, int digits, MidpointRounding mode);
    public static float Round(float x, MidpointRounding mode);
    public static float ScaleB(float x, int n);
    public static int Sign(float x);
    public static float Sin(float x);
    public static ValueTuple`2<float, float> SinCos(float x);
    public static float Sinh(float x);
    public static float Sqrt(float x);
    public static float Tan(float x);
    public static float Tanh(float x);
    public static float Truncate(float x);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.MemberAccessException : SystemException {
    [NullableContextAttribute("1")]
protected MemberAccessException(SerializationInfo info, StreamingContext context);
    public MemberAccessException(string message);
    public MemberAccessException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Memory`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Memory`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Span`1<T> Span { get; }
    public Memory`1(T[] array);
    public Memory`1(T[] array, int start, int length);
    public static Memory`1<T> get_Empty();
    public bool get_IsEmpty();
    public int get_Length();
    public Span`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    public sealed virtual bool Equals(Memory`1<T> other);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static Memory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(Memory`1<T> memory);
    public static Memory`1<T> op_Implicit(T[] array);
    public MemoryHandle Pin();
    public Memory`1<T> Slice(int start);
    public Memory`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Memory`1<T> destination);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.MethodAccessException : MemberAccessException {
    [NullableContextAttribute("1")]
protected MethodAccessException(SerializationInfo info, StreamingContext context);
    public MethodAccessException(string message);
    public MethodAccessException(string message, Exception inner);
}
public enum System.MidpointRounding : Enum {
    public int value__;
    public static MidpointRounding ToEven;
    public static MidpointRounding AwayFromZero;
    public static MidpointRounding ToZero;
    public static MidpointRounding ToNegativeInfinity;
    public static MidpointRounding ToPositiveInfinity;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.MissingFieldException : MissingMemberException {
    public string Message { get; }
    protected MissingFieldException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public MissingFieldException(string message);
    [NullableContextAttribute("2")]
public MissingFieldException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingFieldException(string className, string fieldName);
    public virtual string get_Message();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.MissingMemberException : MemberAccessException {
    protected string ClassName;
    protected string MemberName;
    protected Byte[] Signature;
    [NullableAttribute("1")]
public string Message { get; }
    [NullableContextAttribute("1")]
protected MissingMemberException(SerializationInfo info, StreamingContext context);
    public MissingMemberException(string message);
    public MissingMemberException(string message, Exception inner);
    public MissingMemberException(string className, string memberName);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.MissingMethodException : MissingMemberException {
    public string Message { get; }
    protected MissingMethodException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public MissingMethodException(string message);
    [NullableContextAttribute("2")]
public MissingMethodException(string message, Exception inner);
    [NullableContextAttribute("2")]
public MissingMethodException(string className, string methodName);
    public virtual string get_Message();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.ModuleHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static ModuleHandle EmptyHandle;
    public int MDStreamVersion { get; }
    public int get_MDStreamVersion();
    public sealed virtual bool Equals(ModuleHandle handle);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle GetRuntimeFieldHandleFromMetadataToken(int fieldToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle GetRuntimeMethodHandleFromMetadataToken(int methodToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle GetRuntimeTypeHandleFromMetadataToken(int typeToken);
    public static bool op_Equality(ModuleHandle left, ModuleHandle right);
    public static bool op_Inequality(ModuleHandle left, ModuleHandle right);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeFieldHandle ResolveFieldHandle(int fieldToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle ResolveMethodHandle(int methodToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeMethodHandle ResolveMethodHandle(int methodToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle ResolveTypeHandle(int typeToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public RuntimeTypeHandle ResolveTypeHandle(int typeToken, RuntimeTypeHandle[] typeInstantiationContext, RuntimeTypeHandle[] methodInstantiationContext);
}
[AttributeUsageAttribute("64")]
public class System.MTAThreadAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.MulticastDelegate : Delegate {
    [RequiresUnreferencedCodeAttribute("The target method might be removed")]
protected MulticastDelegate(object target, string method);
    protected MulticastDelegate(Type target, string method);
    protected sealed virtual Delegate CombineImpl(Delegate follow);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Delegate[] GetInvocationList();
    protected virtual MethodInfo GetMethodImpl();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public static bool op_Equality(MulticastDelegate d1, MulticastDelegate d2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MulticastDelegate d1, MulticastDelegate d2);
    protected sealed virtual Delegate RemoveImpl(Delegate value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.MulticastNotSupportedException : SystemException {
    public MulticastNotSupportedException(string message);
    public MulticastNotSupportedException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public static class System.Net.WebUtility : object {
    public static string HtmlDecode(string value);
    [NullableContextAttribute("1")]
public static void HtmlDecode(string value, TextWriter output);
    public static string HtmlEncode(string value);
    [NullableContextAttribute("1")]
public static void HtmlEncode(string value, TextWriter output);
    public static string UrlDecode(string encodedValue);
    public static Byte[] UrlDecodeToBytes(Byte[] encodedValue, int offset, int count);
    public static string UrlEncode(string value);
    public static Byte[] UrlEncodeToBytes(Byte[] value, int offset, int count);
}
public class System.NetPipeStyleUriParser : UriParser {
}
public class System.NetTcpStyleUriParser : UriParser {
}
public class System.NewsStyleUriParser : UriParser {
}
[AttributeUsageAttribute("256")]
public class System.NonSerializedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.NotFiniteNumberException : ArithmeticException {
    public double OffendingNumber { get; }
    public NotFiniteNumberException(double offendingNumber);
    [NullableContextAttribute("1")]
protected NotFiniteNumberException(SerializationInfo info, StreamingContext context);
    public NotFiniteNumberException(string message);
    public NotFiniteNumberException(string message, double offendingNumber);
    public NotFiniteNumberException(string message, double offendingNumber, Exception innerException);
    public NotFiniteNumberException(string message, Exception innerException);
    public double get_OffendingNumber();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.NotImplementedException : SystemException {
    [NullableContextAttribute("1")]
protected NotImplementedException(SerializationInfo info, StreamingContext context);
    public NotImplementedException(string message);
    public NotImplementedException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.NotSupportedException : SystemException {
    [NullableContextAttribute("1")]
protected NotSupportedException(SerializationInfo info, StreamingContext context);
    public NotSupportedException(string message);
    public NotSupportedException(string message, Exception innerException);
}
public static class System.Nullable : object {
    public static int Compare(Nullable`1<T> n1, Nullable`1<T> n2);
    public static bool Equals(Nullable`1<T> n1, Nullable`1<T> n2);
    [NullableContextAttribute("1")]
public static Type GetUnderlyingType(Type nullableType);
    public static T& modreq(System.Runtime.InteropServices.InAttribute) GetValueRefOrDefaultRef(Nullable`1& nullable);
}
public class System.Nullable`1 : ValueType {
    private T value;
    private int _dummyPrimitive;
    public bool HasValue { get; }
    public T Value { get; }
    public Nullable`1(T value);
    [IsReadOnlyAttribute]
public bool get_HasValue();
    [IsReadOnlyAttribute]
public T get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object other);
    public virtual int GetHashCode();
    [IsReadOnlyAttribute]
public T GetValueOrDefault();
    [IsReadOnlyAttribute]
public T GetValueOrDefault(T defaultValue);
    public static T op_Explicit(Nullable`1<T> value);
    public static Nullable`1<T> op_Implicit(T value);
    [NullableContextAttribute("2")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.NullReferenceException : SystemException {
    [NullableContextAttribute("1")]
protected NullReferenceException(SerializationInfo info, StreamingContext context);
    public NullReferenceException(string message);
    public NullReferenceException(string message, Exception innerException);
}
public static class System.Numerics.BitOperations : object {
    public static bool IsPow2(int value);
    public static bool IsPow2(long value);
    public static bool IsPow2(IntPtr value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(ulong value);
    [CLSCompliantAttribute("False")]
public static bool IsPow2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int LeadingZeroCount(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int Log2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int Log2(ulong value);
    [CLSCompliantAttribute("False")]
public static int Log2(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int PopCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int PopCount(UIntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateLeft(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateLeft(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UIntPtr RotateLeft(UIntPtr value, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 RotateRight(UInt32 value, int offset);
    [CLSCompliantAttribute("False")]
public static ulong RotateRight(ulong value, int offset);
    [CLSCompliantAttribute("False")]
public static UIntPtr RotateRight(UIntPtr value, int offset);
    [CLSCompliantAttribute("False")]
public static UInt32 RoundUpToPowerOf2(UInt32 value);
    [CLSCompliantAttribute("False")]
public static ulong RoundUpToPowerOf2(ulong value);
    [CLSCompliantAttribute("False")]
public static UIntPtr RoundUpToPowerOf2(UIntPtr value);
    public static int TrailingZeroCount(int value);
    public static int TrailingZeroCount(long value);
    public static int TrailingZeroCount(IntPtr value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UInt32 value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(ulong value);
    [CLSCompliantAttribute("False")]
public static int TrailingZeroCount(UIntPtr value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IAdditionOperators`3 {
    public static abstract virtual TResult op_Addition(TSelf left, TOther right);
    public static virtual TResult op_CheckedAddition(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IAdditiveIdentity`2 {
    public static TResult AdditiveIdentity { get; }
    public static abstract virtual TResult get_AdditiveIdentity();
}
public interface System.Numerics.IBinaryFloatingPointIeee754`1 {
}
[NullableContextAttribute("1")]
public interface System.Numerics.IBinaryInteger`1 {
    public static virtual ValueTuple`2<TSelf, TSelf> DivRem(TSelf left, TSelf right);
    public abstract virtual int GetByteCount();
    public abstract virtual int GetShortestBitLength();
    public static virtual TSelf LeadingZeroCount(TSelf value);
    public static abstract virtual TSelf PopCount(TSelf value);
    public static virtual TSelf ReadBigEndian(Byte[] source, bool isUnsigned);
    public static virtual TSelf ReadBigEndian(Byte[] source, int startIndex, bool isUnsigned);
    [NullableContextAttribute("0")]
public static virtual TSelf ReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned);
    public static virtual TSelf ReadLittleEndian(Byte[] source, bool isUnsigned);
    public static virtual TSelf ReadLittleEndian(Byte[] source, int startIndex, bool isUnsigned);
    [NullableContextAttribute("0")]
public static virtual TSelf ReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned);
    public static virtual TSelf RotateLeft(TSelf value, int rotateAmount);
    public static virtual TSelf RotateRight(TSelf value, int rotateAmount);
    public static abstract virtual TSelf TrailingZeroCount(TSelf value);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, TSelf& value);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, TSelf& value);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public virtual int WriteBigEndian(Byte[] destination);
    public virtual int WriteBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteBigEndian(Span`1<byte> destination);
    public virtual int WriteLittleEndian(Byte[] destination);
    public virtual int WriteLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteLittleEndian(Span`1<byte> destination);
}
public interface System.Numerics.IBinaryNumber`1 {
    [NullableAttribute("1")]
public static TSelf AllBitsSet { get; }
    [NullableContextAttribute("1")]
public static virtual TSelf get_AllBitsSet();
    [NullableContextAttribute("1")]
public static abstract virtual bool IsPow2(TSelf value);
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Log2(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IBitwiseOperators`3 {
    public static abstract virtual TResult op_BitwiseAnd(TSelf left, TOther right);
    public static abstract virtual TResult op_BitwiseOr(TSelf left, TOther right);
    public static abstract virtual TResult op_ExclusiveOr(TSelf left, TOther right);
    public static abstract virtual TResult op_OnesComplement(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IComparisonOperators`3 {
    public static abstract virtual TResult op_GreaterThan(TSelf left, TOther right);
    public static abstract virtual TResult op_GreaterThanOrEqual(TSelf left, TOther right);
    public static abstract virtual TResult op_LessThan(TSelf left, TOther right);
    public static abstract virtual TResult op_LessThanOrEqual(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IDecrementOperators`1 {
    public static virtual TSelf op_CheckedDecrement(TSelf value);
    public static abstract virtual TSelf op_Decrement(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IDivisionOperators`3 {
    public static virtual TResult op_CheckedDivision(TSelf left, TOther right);
    public static abstract virtual TResult op_Division(TSelf left, TOther right);
}
[NullableContextAttribute("2")]
public interface System.Numerics.IEqualityOperators`3 {
    public static abstract virtual TResult op_Equality(TSelf left, TOther right);
    public static abstract virtual TResult op_Inequality(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IExponentialFunctions`1 {
    public static abstract virtual TSelf Exp(TSelf x);
    public static abstract virtual TSelf Exp10(TSelf x);
    public static virtual TSelf Exp10M1(TSelf x);
    public static abstract virtual TSelf Exp2(TSelf x);
    public static virtual TSelf Exp2M1(TSelf x);
    public static virtual TSelf ExpM1(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPoint`1 {
    public static virtual TSelf Ceiling(TSelf x);
    public static virtual TSelf Floor(TSelf x);
    public abstract virtual int GetExponentByteCount();
    public abstract virtual int GetExponentShortestBitLength();
    public abstract virtual int GetSignificandBitLength();
    public abstract virtual int GetSignificandByteCount();
    public static virtual TSelf Round(TSelf x);
    public static virtual TSelf Round(TSelf x, int digits);
    public static abstract virtual TSelf Round(TSelf x, int digits, MidpointRounding mode);
    public static virtual TSelf Round(TSelf x, MidpointRounding mode);
    public static virtual TSelf Truncate(TSelf x);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("0")]
public abstract virtual bool TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    public virtual int WriteExponentBigEndian(Byte[] destination);
    public virtual int WriteExponentBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteExponentBigEndian(Span`1<byte> destination);
    public virtual int WriteExponentLittleEndian(Byte[] destination);
    public virtual int WriteExponentLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteExponentLittleEndian(Span`1<byte> destination);
    public virtual int WriteSignificandBigEndian(Byte[] destination);
    public virtual int WriteSignificandBigEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteSignificandBigEndian(Span`1<byte> destination);
    public virtual int WriteSignificandLittleEndian(Byte[] destination);
    public virtual int WriteSignificandLittleEndian(Byte[] destination, int startIndex);
    [NullableContextAttribute("0")]
public virtual int WriteSignificandLittleEndian(Span`1<byte> destination);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPointConstants`1 {
    public static TSelf E { get; }
    public static TSelf Pi { get; }
    public static TSelf Tau { get; }
    public static abstract virtual TSelf get_E();
    public static abstract virtual TSelf get_Pi();
    public static abstract virtual TSelf get_Tau();
}
[NullableContextAttribute("1")]
public interface System.Numerics.IFloatingPointIeee754`1 {
    public static TSelf Epsilon { get; }
    public static TSelf NaN { get; }
    public static TSelf NegativeInfinity { get; }
    public static TSelf NegativeZero { get; }
    public static TSelf PositiveInfinity { get; }
    public static abstract virtual TSelf get_Epsilon();
    public static abstract virtual TSelf get_NaN();
    public static abstract virtual TSelf get_NegativeInfinity();
    public static abstract virtual TSelf get_NegativeZero();
    public static abstract virtual TSelf get_PositiveInfinity();
    public static abstract virtual TSelf Atan2(TSelf y, TSelf x);
    public static abstract virtual TSelf Atan2Pi(TSelf y, TSelf x);
    public static abstract virtual TSelf BitDecrement(TSelf x);
    public static abstract virtual TSelf BitIncrement(TSelf x);
    public static abstract virtual TSelf FusedMultiplyAdd(TSelf left, TSelf right, TSelf addend);
    public static abstract virtual TSelf Ieee754Remainder(TSelf left, TSelf right);
    public static abstract virtual int ILogB(TSelf x);
    public static virtual TSelf ReciprocalEstimate(TSelf x);
    public static virtual TSelf ReciprocalSqrtEstimate(TSelf x);
    public static abstract virtual TSelf ScaleB(TSelf x, int n);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IHyperbolicFunctions`1 {
    public static abstract virtual TSelf Acosh(TSelf x);
    public static abstract virtual TSelf Asinh(TSelf x);
    public static abstract virtual TSelf Atanh(TSelf x);
    public static abstract virtual TSelf Cosh(TSelf x);
    public static abstract virtual TSelf Sinh(TSelf x);
    public static abstract virtual TSelf Tanh(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IIncrementOperators`1 {
    public static virtual TSelf op_CheckedIncrement(TSelf value);
    public static abstract virtual TSelf op_Increment(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.ILogarithmicFunctions`1 {
    public static abstract virtual TSelf Log(TSelf x);
    public static abstract virtual TSelf Log(TSelf x, TSelf newBase);
    public static abstract virtual TSelf Log10(TSelf x);
    public static virtual TSelf Log10P1(TSelf x);
    public static abstract virtual TSelf Log2(TSelf x);
    public static virtual TSelf Log2P1(TSelf x);
    public static virtual TSelf LogP1(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMinMaxValue`1 {
    public static TSelf MaxValue { get; }
    public static TSelf MinValue { get; }
    public static abstract virtual TSelf get_MaxValue();
    public static abstract virtual TSelf get_MinValue();
}
[NullableContextAttribute("2")]
public interface System.Numerics.IModulusOperators`3 {
    [NullableContextAttribute("1")]
public static abstract virtual TResult op_Modulus(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMultiplicativeIdentity`2 {
    public static TResult MultiplicativeIdentity { get; }
    public static abstract virtual TResult get_MultiplicativeIdentity();
}
[NullableContextAttribute("1")]
public interface System.Numerics.IMultiplyOperators`3 {
    public static virtual TResult op_CheckedMultiply(TSelf left, TOther right);
    public static abstract virtual TResult op_Multiply(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.INumber`1 {
    public static virtual TSelf Clamp(TSelf value, TSelf min, TSelf max);
    public static virtual TSelf CopySign(TSelf value, TSelf sign);
    public static virtual TSelf Max(TSelf x, TSelf y);
    public static virtual TSelf MaxNumber(TSelf x, TSelf y);
    public static virtual TSelf Min(TSelf x, TSelf y);
    public static virtual TSelf MinNumber(TSelf x, TSelf y);
    public static virtual int Sign(TSelf value);
}
[NullableContextAttribute("1")]
public interface System.Numerics.INumberBase`1 {
    public static TSelf One { get; }
    public static int Radix { get; }
    public static TSelf Zero { get; }
    public static abstract virtual TSelf get_One();
    public static abstract virtual int get_Radix();
    public static abstract virtual TSelf get_Zero();
    public static abstract virtual TSelf Abs(TSelf value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateChecked(TOther value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateSaturating(TOther value);
    [NullableContextAttribute("0")]
public static virtual TSelf CreateTruncating(TOther value);
    public static abstract virtual bool IsCanonical(TSelf value);
    public static abstract virtual bool IsComplexNumber(TSelf value);
    public static abstract virtual bool IsEvenInteger(TSelf value);
    public static abstract virtual bool IsFinite(TSelf value);
    public static abstract virtual bool IsImaginaryNumber(TSelf value);
    public static abstract virtual bool IsInfinity(TSelf value);
    public static abstract virtual bool IsInteger(TSelf value);
    public static abstract virtual bool IsNaN(TSelf value);
    public static abstract virtual bool IsNegative(TSelf value);
    public static abstract virtual bool IsNegativeInfinity(TSelf value);
    public static abstract virtual bool IsNormal(TSelf value);
    public static abstract virtual bool IsOddInteger(TSelf value);
    public static abstract virtual bool IsPositive(TSelf value);
    public static abstract virtual bool IsPositiveInfinity(TSelf value);
    public static abstract virtual bool IsRealNumber(TSelf value);
    public static abstract virtual bool IsSubnormal(TSelf value);
    public static abstract virtual bool IsZero(TSelf value);
    public static abstract virtual TSelf MaxMagnitude(TSelf x, TSelf y);
    public static abstract virtual TSelf MaxMagnitudeNumber(TSelf x, TSelf y);
    public static abstract virtual TSelf MinMagnitude(TSelf x, TSelf y);
    public static abstract virtual TSelf MinMagnitudeNumber(TSelf x, TSelf y);
    [NullableContextAttribute("0")]
public static abstract virtual TSelf Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static abstract virtual TSelf Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromChecked(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromSaturating(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertFromTruncating(TOther value, TSelf& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToChecked(TSelf value, TOther& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToSaturating(TSelf value, TOther& result);
    [NullableContextAttribute("0")]
protected static abstract virtual bool TryConvertToTruncating(TSelf value, TOther& result);
    [NullableContextAttribute("0")]
public static abstract virtual bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, TSelf& result);
    [NullableContextAttribute("2")]
public static abstract virtual bool TryParse(string s, NumberStyles style, IFormatProvider provider, TSelf& result);
}
public interface System.Numerics.IPowerFunctions`1 {
    [NullableContextAttribute("1")]
public static abstract virtual TSelf Pow(TSelf x, TSelf y);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IRootFunctions`1 {
    public static abstract virtual TSelf Cbrt(TSelf x);
    public static abstract virtual TSelf Hypot(TSelf x, TSelf y);
    public static abstract virtual TSelf RootN(TSelf x, int n);
    public static abstract virtual TSelf Sqrt(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IShiftOperators`3 {
    public static abstract virtual TResult op_LeftShift(TSelf value, TOther shiftAmount);
    public static abstract virtual TResult op_RightShift(TSelf value, TOther shiftAmount);
    public static abstract virtual TResult op_UnsignedRightShift(TSelf value, TOther shiftAmount);
}
public interface System.Numerics.ISignedNumber`1 {
    [NullableAttribute("1")]
public static TSelf NegativeOne { get; }
    [NullableContextAttribute("1")]
public static abstract virtual TSelf get_NegativeOne();
}
[NullableContextAttribute("1")]
public interface System.Numerics.ISubtractionOperators`3 {
    public static virtual TResult op_CheckedSubtraction(TSelf left, TOther right);
    public static abstract virtual TResult op_Subtraction(TSelf left, TOther right);
}
[NullableContextAttribute("1")]
public interface System.Numerics.ITrigonometricFunctions`1 {
    public static abstract virtual TSelf Acos(TSelf x);
    public static abstract virtual TSelf AcosPi(TSelf x);
    public static abstract virtual TSelf Asin(TSelf x);
    public static abstract virtual TSelf AsinPi(TSelf x);
    public static abstract virtual TSelf Atan(TSelf x);
    public static abstract virtual TSelf AtanPi(TSelf x);
    public static abstract virtual TSelf Cos(TSelf x);
    public static abstract virtual TSelf CosPi(TSelf x);
    public static abstract virtual TSelf Sin(TSelf x);
    public static abstract virtual ValueTuple`2<TSelf, TSelf> SinCos(TSelf x);
    public static abstract virtual ValueTuple`2<TSelf, TSelf> SinCosPi(TSelf x);
    public static abstract virtual TSelf SinPi(TSelf x);
    public static abstract virtual TSelf Tan(TSelf x);
    public static abstract virtual TSelf TanPi(TSelf x);
}
[NullableContextAttribute("1")]
public interface System.Numerics.IUnaryNegationOperators`2 {
    public static virtual TResult op_CheckedUnaryNegation(TSelf value);
    public static abstract virtual TResult op_UnaryNegation(TSelf value);
}
public interface System.Numerics.IUnaryPlusOperators`2 {
    [NullableContextAttribute("1")]
public static abstract virtual TResult op_UnaryPlus(TSelf value);
}
public interface System.Numerics.IUnsignedNumber`1 {
}
[NullableContextAttribute("2")]
public class System.Object {
    public virtual bool Equals(object obj);
    public static bool Equals(object objA, object objB);
    protected virtual void Finalize();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public Type GetType();
    [NullableContextAttribute("1")]
protected object MemberwiseClone();
    public static bool ReferenceEquals(object objA, object objB);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ObjectDisposedException : InvalidOperationException {
    public string Message { get; }
    public string ObjectName { get; }
    protected ObjectDisposedException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string message, Exception innerException);
    [NullableContextAttribute("2")]
public ObjectDisposedException(string objectName, string message);
    public virtual string get_Message();
    public string get_ObjectName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static void ThrowIf(bool condition, object instance);
    public static void ThrowIf(bool condition, Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6140")]
public class System.ObsoleteAttribute : Attribute {
    public string DiagnosticId { get; public set; }
    public bool IsError { get; }
    public string Message { get; }
    public string UrlFormat { get; public set; }
    public ObsoleteAttribute(string message);
    public ObsoleteAttribute(string message, bool error);
    public string get_DiagnosticId();
    public void set_DiagnosticId(string value);
    public bool get_IsError();
    public string get_Message();
    public string get_UrlFormat();
    public void set_UrlFormat(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.OperatingSystem : object {
    public PlatformID Platform { get; }
    public string ServicePack { get; }
    public Version Version { get; }
    public string VersionString { get; }
    public OperatingSystem(PlatformID platform, Version version);
    public PlatformID get_Platform();
    public string get_ServicePack();
    public Version get_Version();
    public string get_VersionString();
    public sealed virtual object Clone();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static bool IsAndroid();
    public static bool IsAndroidVersionAtLeast(int major, int minor, int build, int revision);
    public static bool IsBrowser();
    public static bool IsFreeBSD();
    public static bool IsFreeBSDVersionAtLeast(int major, int minor, int build, int revision);
    [SupportedOSPlatformGuardAttribute("maccatalyst")]
public static bool IsIOS();
    [SupportedOSPlatformGuardAttribute("maccatalyst")]
public static bool IsIOSVersionAtLeast(int major, int minor, int build);
    public static bool IsLinux();
    public static bool IsMacCatalyst();
    public static bool IsMacCatalystVersionAtLeast(int major, int minor, int build);
    public static bool IsMacOS();
    public static bool IsMacOSVersionAtLeast(int major, int minor, int build);
    public static bool IsOSPlatform(string platform);
    public static bool IsOSPlatformVersionAtLeast(string platform, int major, int minor, int build, int revision);
    public static bool IsTvOS();
    public static bool IsTvOSVersionAtLeast(int major, int minor, int build);
    public static bool IsWatchOS();
    public static bool IsWatchOSVersionAtLeast(int major, int minor, int build);
    public static bool IsWindows();
    public static bool IsWindowsVersionAtLeast(int major, int minor, int build, int revision);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.OperationCanceledException : SystemException {
    public CancellationToken CancellationToken { get; }
    [NullableContextAttribute("1")]
protected OperationCanceledException(SerializationInfo info, StreamingContext context);
    public OperationCanceledException(string message);
    public OperationCanceledException(string message, Exception innerException);
    public OperationCanceledException(string message, Exception innerException, CancellationToken token);
    public OperationCanceledException(string message, CancellationToken token);
    public OperationCanceledException(CancellationToken token);
    public CancellationToken get_CancellationToken();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.OutOfMemoryException : SystemException {
    [NullableContextAttribute("1")]
protected OutOfMemoryException(SerializationInfo info, StreamingContext context);
    public OutOfMemoryException(string message);
    public OutOfMemoryException(string message, Exception innerException);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.OverflowException : ArithmeticException {
    [NullableContextAttribute("1")]
protected OverflowException(SerializationInfo info, StreamingContext context);
    public OverflowException(string message);
    public OverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("2048")]
public class System.ParamArrayAttribute : Attribute {
}
public enum System.PlatformID : Enum {
    public int value__;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32S;
    [EditorBrowsableAttribute("1")]
public static PlatformID Win32Windows;
    public static PlatformID Win32NT;
    [EditorBrowsableAttribute("1")]
public static PlatformID WinCE;
    public static PlatformID Unix;
    [EditorBrowsableAttribute("1")]
public static PlatformID Xbox;
    [EditorBrowsableAttribute("1")]
public static PlatformID MacOSX;
    public static PlatformID Other;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.PlatformNotSupportedException : NotSupportedException {
    [NullableContextAttribute("1")]
protected PlatformNotSupportedException(SerializationInfo info, StreamingContext context);
    public PlatformNotSupportedException(string message);
    public PlatformNotSupportedException(string message, Exception inner);
}
public class System.Predicate`1 : MulticastDelegate {
    public Predicate`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(T obj);
    public virtual IAsyncResult BeginInvoke(T obj, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Progress`1 : object {
    public Progress`1(Action`1<T> handler);
    public void add_ProgressChanged(EventHandler`1<T> value);
    public void remove_ProgressChanged(EventHandler`1<T> value);
    protected virtual void OnReport(T value);
    private sealed virtual override void System.IProgress<T>.Report(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Random : object {
    public static Random Shared { get; }
    public Random(int Seed);
    public static Random get_Shared();
    public virtual int Next();
    public virtual int Next(int maxValue);
    public virtual int Next(int minValue, int maxValue);
    public virtual void NextBytes(Byte[] buffer);
    [NullableContextAttribute("0")]
public virtual void NextBytes(Span`1<byte> buffer);
    public virtual double NextDouble();
    public virtual long NextInt64();
    public virtual long NextInt64(long maxValue);
    public virtual long NextInt64(long minValue, long maxValue);
    public virtual float NextSingle();
    protected virtual double Sample();
}
[IsReadOnlyAttribute]
public class System.Range : ValueType {
    private int _dummyPrimitive;
    public static Range All { get; }
    public Index End { get; }
    public Index Start { get; }
    public Range(Index start, Index end);
    public static Range get_All();
    public Index get_End();
    public Index get_Start();
    public static Range EndAt(Index end);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(Range other);
    public virtual int GetHashCode();
    public ValueTuple`2<int, int> GetOffsetAndLength(int length);
    public static Range StartAt(Index start);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.RankException : SystemException {
    [NullableContextAttribute("1")]
protected RankException(SerializationInfo info, StreamingContext context);
    public RankException(string message);
    public RankException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.ReadOnlyMemory`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlyMemory`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public int Length { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ReadOnlySpan`1<T> Span { get; }
    public ReadOnlyMemory`1(T[] array);
    public ReadOnlyMemory`1(T[] array, int start, int length);
    public static ReadOnlyMemory`1<T> get_Empty();
    public bool get_IsEmpty();
    public int get_Length();
    public ReadOnlySpan`1<T> get_Span();
    public void CopyTo(Memory`1<T> destination);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ReadOnlyMemory`1<T> other);
    [EditorBrowsableAttribute("1")]
public virtual int GetHashCode();
    public static ReadOnlyMemory`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlyMemory`1<T> op_Implicit(T[] array);
    public MemoryHandle Pin();
    public ReadOnlyMemory`1<T> Slice(int start);
    public ReadOnlyMemory`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Memory`1<T> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[NativeMarshallingAttribute("System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2")]
public class System.ReadOnlySpan`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static ReadOnlySpan`1<T> Empty { get; }
    public bool IsEmpty { get; }
    [IsReadOnlyAttribute]
public T& modreq(System.Runtime.InteropServices.InAttribute) Item { get; }
    public int Length { get; }
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public ReadOnlySpan`1(Void* pointer, int length);
    public ReadOnlySpan`1(T[] array);
    public ReadOnlySpan`1(T[] array, int start, int length);
    public ReadOnlySpan`1(T& reference);
    public static ReadOnlySpan`1<T> get_Empty();
    public bool get_IsEmpty();
    public T& modreq(System.Runtime.InteropServices.InAttribute) get_Item(int index);
    public int get_Length();
    public void CopyTo(Span`1<T> destination);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on ReadOnlySpan will always throw an exception. Use the equality operator instead.")]
public virtual bool Equals(object obj);
    public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on ReadOnlySpan will always throw an exception.")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public T& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public static bool op_Equality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public static ReadOnlySpan`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(ReadOnlySpan`1<T> left, ReadOnlySpan`1<T> right);
    public ReadOnlySpan`1<T> Slice(int start);
    public ReadOnlySpan`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Span`1<T> destination);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.AmbiguousMatchException : SystemException {
    public AmbiguousMatchException(string message);
    public AmbiguousMatchException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Assembly : object {
    [NullableAttribute("2")]
[ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string CodeBase { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    [NullableAttribute("2")]
public MethodInfo EntryPoint { get; }
    [ObsoleteAttribute("Assembly.CodeBase and Assembly.EscapedCodeBase are only included for .NET Framework compatibility. Use Assembly.Location.")]
[RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public string EscapedCodeBase { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    [ObsoleteAttribute("The Global Assembly Cache is not supported.")]
public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsCollectible { get; }
    public bool IsDynamic { get; }
    public bool IsFullyTrusted { get; }
    public string Location { get; }
    public Module ManifestModule { get; }
    public IEnumerable`1<Module> Modules { get; }
    public bool ReflectionOnly { get; }
    public SecurityRuleSet SecurityRuleSet { get; }
    [NullableContextAttribute("2")]
public virtual string get_CodeBase();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    [NullableContextAttribute("2")]
public virtual MethodInfo get_EntryPoint();
    public virtual string get_EscapedCodeBase();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual IEnumerable`1<Type> get_ExportedTypes();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    public virtual bool get_GlobalAssemblyCache();
    public virtual long get_HostContext();
    public virtual string get_ImageRuntimeVersion();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsDynamic();
    public bool get_IsFullyTrusted();
    public virtual string get_Location();
    public virtual Module get_ManifestModule();
    public virtual IEnumerable`1<Module> get_Modules();
    public virtual bool get_ReflectionOnly();
    public virtual SecurityRuleSet get_SecurityRuleSet();
    [NullableContextAttribute("2")]
public virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [NullableContextAttribute("2")]
public virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    [RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public object CreateInstance(string typeName);
    [RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public object CreateInstance(string typeName, bool ignoreCase);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Assembly.CreateInstance is not supported with trimming. Use Type.GetType instead.")]
public virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [NullableContextAttribute("2")]
public static string CreateQualifiedName(string assemblyName, string typeName);
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public static Assembly GetAssembly(Type type);
    public static Assembly GetCallingAssembly();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [NullableContextAttribute("2")]
public static Assembly GetEntryAssembly();
    public static Assembly GetExecutingAssembly();
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetExportedTypes();
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream GetFile(string name);
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles();
    [RequiresAssemblyFilesAttribute("This member throws an exception for assemblies embedded in a single-file app")]
public virtual FileStream[] GetFiles(bool getResourceModules);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetForwardedTypes();
    public virtual int GetHashCode();
    public Module[] GetLoadedModules();
    public virtual Module[] GetLoadedModules(bool getResourceModules);
    public virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public virtual String[] GetManifestResourceNames();
    public virtual Stream GetManifestResourceStream(string name);
    public virtual Stream GetManifestResourceStream(Type type, string name);
    public virtual Module GetModule(string name);
    public Module[] GetModules();
    public virtual Module[] GetModules(bool getResourceModules);
    public virtual AssemblyName GetName();
    public virtual AssemblyName GetName(bool copiedName);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [RequiresUnreferencedCodeAttribute("Assembly references might be removed")]
public virtual AssemblyName[] GetReferencedAssemblies();
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly Load(Byte[] rawAssembly);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly Load(Byte[] rawAssembly, Byte[] rawSymbolStore);
    public static Assembly Load(AssemblyName assemblyRef);
    public static Assembly Load(string assemblyString);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFile(string path);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFrom(string assemblyFile);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly LoadFrom(string assemblyFile, Byte[] hashValue, AssemblyHashAlgorithm hashAlgorithm);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded module depends on might be removed")]
public Module LoadModule(string moduleName, Byte[] rawModule);
    [RequiresUnreferencedCodeAttribute("Types and members the loaded module depends on might be removed")]
public virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    [ObsoleteAttribute("Assembly.LoadWithPartialName has been deprecated. Use Assembly.Load() instead.")]
public static Assembly LoadWithPartialName(string partialName);
    [NullableContextAttribute("2")]
public static bool op_Equality(Assembly left, Assembly right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Assembly left, Assembly right);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoad(Byte[] rawAssembly);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoad(string assemblyString);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
[RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly ReflectionOnlyLoadFrom(string assemblyFile);
    public virtual string ToString();
    [RequiresUnreferencedCodeAttribute("Types and members the loaded assembly depends on might be removed")]
public static Assembly UnsafeLoadFrom(string assemblyFile);
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyAlgorithmIdAttribute : Attribute {
    [CLSCompliantAttribute("False")]
public UInt32 AlgorithmId { get; }
    public AssemblyAlgorithmIdAttribute(AssemblyHashAlgorithm algorithmId);
    [CLSCompliantAttribute("False")]
public AssemblyAlgorithmIdAttribute(UInt32 algorithmId);
    public UInt32 get_AlgorithmId();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCompanyAttribute : Attribute {
    public string Company { get; }
    public AssemblyCompanyAttribute(string company);
    public string get_Company();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyConfigurationAttribute : Attribute {
    public string Configuration { get; }
    public AssemblyConfigurationAttribute(string configuration);
    public string get_Configuration();
}
public enum System.Reflection.AssemblyContentType : Enum {
    public int value__;
    public static AssemblyContentType Default;
    public static AssemblyContentType WindowsRuntime;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCopyrightAttribute : Attribute {
    public string Copyright { get; }
    public AssemblyCopyrightAttribute(string copyright);
    public string get_Copyright();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyCultureAttribute : Attribute {
    public string Culture { get; }
    public AssemblyCultureAttribute(string culture);
    public string get_Culture();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDefaultAliasAttribute : Attribute {
    public string DefaultAlias { get; }
    public AssemblyDefaultAliasAttribute(string defaultAlias);
    public string get_DefaultAlias();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDelaySignAttribute : Attribute {
    public bool DelaySign { get; }
    public AssemblyDelaySignAttribute(bool delaySign);
    public bool get_DelaySign();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyDescriptionAttribute : Attribute {
    public string Description { get; }
    public AssemblyDescriptionAttribute(string description);
    public string get_Description();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFileVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyFileVersionAttribute(string version);
    public string get_Version();
}
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyFlagsAttribute : Attribute {
    public int AssemblyFlags { get; }
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("AssemblyFlagsAttribute.Flags has been deprecated. Use AssemblyFlags instead.")]
public UInt32 Flags { get; }
    [ObsoleteAttribute("This constructor has been deprecated. Use AssemblyFlagsAttribute(AssemblyNameFlags) instead.")]
public AssemblyFlagsAttribute(int assemblyFlags);
    public AssemblyFlagsAttribute(AssemblyNameFlags assemblyFlags);
    [CLSCompliantAttribute("False")]
[ObsoleteAttribute("This constructor has been deprecated. Use AssemblyFlagsAttribute(AssemblyNameFlags) instead.")]
public AssemblyFlagsAttribute(UInt32 flags);
    public int get_AssemblyFlags();
    public UInt32 get_Flags();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyInformationalVersionAttribute : Attribute {
    public string InformationalVersion { get; }
    public AssemblyInformationalVersionAttribute(string informationalVersion);
    public string get_InformationalVersion();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyFileAttribute : Attribute {
    public string KeyFile { get; }
    public AssemblyKeyFileAttribute(string keyFile);
    public string get_KeyFile();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyKeyNameAttribute : Attribute {
    public string KeyName { get; }
    public AssemblyKeyNameAttribute(string keyName);
    public string get_KeyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyMetadataAttribute : Attribute {
    public string Key { get; }
    [NullableAttribute("2")]
public string Value { get; }
    public AssemblyMetadataAttribute(string key, string value);
    public string get_Key();
    [NullableContextAttribute("2")]
public string get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.AssemblyName : object {
    [ObsoleteAttribute("AssemblyName.CodeBase and AssemblyName.EscapedCodeBase are obsolete. Using them for loading an assembly is not supported.")]
public string CodeBase { get; public set; }
    public AssemblyContentType ContentType { get; public set; }
    public CultureInfo CultureInfo { get; public set; }
    public string CultureName { get; public set; }
    [RequiresAssemblyFilesAttribute("The code will return an empty string for assemblies embedded in a single-file app")]
[ObsoleteAttribute("AssemblyName.CodeBase and AssemblyName.EscapedCodeBase are obsolete. Using them for loading an assembly is not supported.")]
public string EscapedCodeBase { get; }
    public AssemblyNameFlags Flags { get; public set; }
    [NullableAttribute("1")]
public string FullName { get; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public AssemblyHashAlgorithm HashAlgorithm { get; public set; }
    [ObsoleteAttribute("Strong name signing is not supported and throws PlatformNotSupportedException.")]
public StrongNameKeyPair KeyPair { get; public set; }
    public string Name { get; public set; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    public Version Version { get; public set; }
    [ObsoleteAttribute("AssemblyName members HashAlgorithm, ProcessorArchitecture, and VersionCompatibility are obsolete and not supported.")]
public AssemblyVersionCompatibility VersionCompatibility { get; public set; }
    [NullableContextAttribute("1")]
public AssemblyName(string assemblyName);
    [RequiresAssemblyFilesAttribute("The code will return an empty string for assemblies embedded in a single-file app")]
public string get_CodeBase();
    public void set_CodeBase(string value);
    public AssemblyContentType get_ContentType();
    public void set_ContentType(AssemblyContentType value);
    public CultureInfo get_CultureInfo();
    public void set_CultureInfo(CultureInfo value);
    public string get_CultureName();
    public void set_CultureName(string value);
    public string get_EscapedCodeBase();
    public AssemblyNameFlags get_Flags();
    public void set_Flags(AssemblyNameFlags value);
    [NullableContextAttribute("1")]
public string get_FullName();
    public AssemblyHashAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(AssemblyHashAlgorithm value);
    public StrongNameKeyPair get_KeyPair();
    public void set_KeyPair(StrongNameKeyPair value);
    public string get_Name();
    public void set_Name(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public Version get_Version();
    public void set_Version(Version value);
    public AssemblyVersionCompatibility get_VersionCompatibility();
    public void set_VersionCompatibility(AssemblyVersionCompatibility value);
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    [NullableContextAttribute("1")]
public static AssemblyName GetAssemblyName(string assemblyFile);
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public Byte[] GetPublicKey();
    public Byte[] GetPublicKeyToken();
    public sealed virtual void OnDeserialization(object sender);
    public static bool ReferenceMatchesDefinition(AssemblyName reference, AssemblyName definition);
    public void SetPublicKey(Byte[] publicKey);
    public void SetPublicKeyToken(Byte[] publicKeyToken);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.AssemblyNameFlags : Enum {
    public int value__;
    public static AssemblyNameFlags None;
    public static AssemblyNameFlags PublicKey;
    public static AssemblyNameFlags Retargetable;
    public static AssemblyNameFlags EnableJITcompileOptimizer;
    public static AssemblyNameFlags EnableJITcompileTracking;
}
public class System.Reflection.AssemblyNameProxy : MarshalByRefObject {
    [NullableContextAttribute("1")]
public AssemblyName GetAssemblyName(string assemblyFile);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyProductAttribute : Attribute {
    public string Product { get; }
    public AssemblyProductAttribute(string product);
    public string get_Product();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblySignatureKeyAttribute : Attribute {
    public string Countersignature { get; }
    public string PublicKey { get; }
    public AssemblySignatureKeyAttribute(string publicKey, string countersignature);
    public string get_Countersignature();
    public string get_PublicKey();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTitleAttribute : Attribute {
    public string Title { get; }
    public AssemblyTitleAttribute(string title);
    public string get_Title();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyTrademarkAttribute : Attribute {
    public string Trademark { get; }
    public AssemblyTrademarkAttribute(string trademark);
    public string get_Trademark();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Reflection.AssemblyVersionAttribute : Attribute {
    public string Version { get; }
    public AssemblyVersionAttribute(string version);
    public string get_Version();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Binder : object {
    public abstract virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo culture);
    [NullableContextAttribute("2")]
public abstract virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo culture, String[] names, Object& state);
    public abstract virtual object ChangeType(object value, Type type, CultureInfo culture);
    public abstract virtual void ReorderArgumentArray(Object[]& args, object state);
    public abstract virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
public abstract virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
}
[FlagsAttribute]
public enum System.Reflection.BindingFlags : Enum {
    public int value__;
    public static BindingFlags Default;
    public static BindingFlags IgnoreCase;
    public static BindingFlags DeclaredOnly;
    public static BindingFlags Instance;
    public static BindingFlags Static;
    public static BindingFlags Public;
    public static BindingFlags NonPublic;
    public static BindingFlags FlattenHierarchy;
    public static BindingFlags InvokeMethod;
    public static BindingFlags CreateInstance;
    public static BindingFlags GetField;
    public static BindingFlags SetField;
    public static BindingFlags GetProperty;
    public static BindingFlags SetProperty;
    public static BindingFlags PutDispProperty;
    public static BindingFlags PutRefDispProperty;
    public static BindingFlags ExactBinding;
    public static BindingFlags SuppressChangeType;
    public static BindingFlags OptionalParamBinding;
    public static BindingFlags IgnoreReturn;
    public static BindingFlags DoNotWrapExceptions;
}
[FlagsAttribute]
public enum System.Reflection.CallingConventions : Enum {
    public int value__;
    public static CallingConventions Standard;
    public static CallingConventions VarArgs;
    public static CallingConventions Any;
    public static CallingConventions HasThis;
    public static CallingConventions ExplicitThis;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.ConstructorInfo : MethodBase {
    [NullableAttribute("1")]
public static string ConstructorName;
    [NullableAttribute("1")]
public static string TypeConstructorName;
    public MemberTypes MemberType { get; }
    public virtual MemberTypes get_MemberType();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public object Invoke(Object[] parameters);
    public abstract virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public static bool op_Equality(ConstructorInfo left, ConstructorInfo right);
    public static bool op_Inequality(ConstructorInfo left, ConstructorInfo right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.CustomAttributeData : object {
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public virtual Type get_AttributeType();
    public virtual ConstructorInfo get_Constructor();
    public virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Assembly target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(MemberInfo target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(Module target);
    public static IList`1<CustomAttributeData> GetCustomAttributes(ParameterInfo target);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.CustomAttributeExtensions : object {
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(Module element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static Attribute GetCustomAttribute(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(Module element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static IEnumerable`1<Attribute> GetCustomAttributes(ParameterInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Assembly element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(Module element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetCustomAttributes(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Assembly element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(MemberInfo element, bool inherit);
    [ExtensionAttribute]
public static T GetCustomAttribute(Module element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element);
    [ExtensionAttribute]
public static T GetCustomAttribute(ParameterInfo element, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Assembly element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(MemberInfo element, Type attributeType, bool inherit);
    [ExtensionAttribute]
public static bool IsDefined(Module element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType);
    [ExtensionAttribute]
public static bool IsDefined(ParameterInfo element, Type attributeType, bool inherit);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.CustomAttributeFormatException : FormatException {
    [NullableContextAttribute("1")]
protected CustomAttributeFormatException(SerializationInfo info, StreamingContext context);
    public CustomAttributeFormatException(string message);
    public CustomAttributeFormatException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.CustomAttributeNamedArgument : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsField { get; }
    public MemberInfo MemberInfo { get; }
    public string MemberName { get; }
    public CustomAttributeTypedArgument TypedValue { get; }
    public CustomAttributeNamedArgument(MemberInfo memberInfo, object value);
    public CustomAttributeNamedArgument(MemberInfo memberInfo, CustomAttributeTypedArgument typedArgument);
    public bool get_IsField();
    public MemberInfo get_MemberInfo();
    public string get_MemberName();
    public CustomAttributeTypedArgument get_TypedValue();
    public sealed virtual bool Equals(CustomAttributeNamedArgument other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public static bool op_Inequality(CustomAttributeNamedArgument left, CustomAttributeNamedArgument right);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Reflection.CustomAttributeTypedArgument : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Type ArgumentType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public CustomAttributeTypedArgument(object value);
    public CustomAttributeTypedArgument(Type argumentType, object value);
    public Type get_ArgumentType();
    [NullableContextAttribute("2")]
public object get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CustomAttributeTypedArgument other);
    public virtual int GetHashCode();
    public static bool op_Equality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public static bool op_Inequality(CustomAttributeTypedArgument left, CustomAttributeTypedArgument right);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1036")]
public class System.Reflection.DefaultMemberAttribute : Attribute {
    public string MemberName { get; }
    public DefaultMemberAttribute(string memberName);
    public string get_MemberName();
}
[FlagsAttribute]
public enum System.Reflection.EventAttributes : Enum {
    public int value__;
    public static EventAttributes None;
    public static EventAttributes SpecialName;
    public static EventAttributes ReservedMask;
    public static EventAttributes RTSpecialName;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.EventInfo : MemberInfo {
    public MethodInfo AddMethod { get; }
    public EventAttributes Attributes { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    public MethodInfo RaiseMethod { get; }
    public MethodInfo RemoveMethod { get; }
    public virtual MethodInfo get_AddMethod();
    public abstract virtual EventAttributes get_Attributes();
    public virtual Type get_EventHandlerType();
    public virtual bool get_IsMulticast();
    public bool get_IsSpecialName();
    public virtual MemberTypes get_MemberType();
    public virtual MethodInfo get_RaiseMethod();
    public virtual MethodInfo get_RemoveMethod();
    public virtual void AddEventHandler(object target, Delegate handler);
    public virtual bool Equals(object obj);
    public MethodInfo GetAddMethod();
    public abstract virtual MethodInfo GetAddMethod(bool nonPublic);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public MethodInfo[] GetOtherMethods();
    [NullableContextAttribute("1")]
public virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public MethodInfo GetRaiseMethod();
    public abstract virtual MethodInfo GetRaiseMethod(bool nonPublic);
    public MethodInfo GetRemoveMethod();
    public abstract virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public static bool op_Equality(EventInfo left, EventInfo right);
    public static bool op_Inequality(EventInfo left, EventInfo right);
    public virtual void RemoveEventHandler(object target, Delegate handler);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.ExceptionHandlingClause : object {
    public Type CatchType { get; }
    public int FilterOffset { get; }
    public ExceptionHandlingClauseOptions Flags { get; }
    public int HandlerLength { get; }
    public int HandlerOffset { get; }
    public int TryLength { get; }
    public int TryOffset { get; }
    public virtual Type get_CatchType();
    public virtual int get_FilterOffset();
    public virtual ExceptionHandlingClauseOptions get_Flags();
    public virtual int get_HandlerLength();
    public virtual int get_HandlerOffset();
    public virtual int get_TryLength();
    public virtual int get_TryOffset();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ExceptionHandlingClauseOptions : Enum {
    public int value__;
    public static ExceptionHandlingClauseOptions Clause;
    public static ExceptionHandlingClauseOptions Filter;
    public static ExceptionHandlingClauseOptions Finally;
    public static ExceptionHandlingClauseOptions Fault;
}
[FlagsAttribute]
public enum System.Reflection.FieldAttributes : Enum {
    public int value__;
    public static FieldAttributes PrivateScope;
    public static FieldAttributes Private;
    public static FieldAttributes FamANDAssem;
    public static FieldAttributes Assembly;
    public static FieldAttributes Family;
    public static FieldAttributes FamORAssem;
    public static FieldAttributes Public;
    public static FieldAttributes FieldAccessMask;
    public static FieldAttributes Static;
    public static FieldAttributes InitOnly;
    public static FieldAttributes Literal;
    public static FieldAttributes NotSerialized;
    public static FieldAttributes HasFieldRVA;
    public static FieldAttributes SpecialName;
    public static FieldAttributes RTSpecialName;
    public static FieldAttributes HasFieldMarshal;
    public static FieldAttributes PinvokeImpl;
    public static FieldAttributes HasDefault;
    public static FieldAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.FieldInfo : MemberInfo {
    public FieldAttributes Attributes { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    [NullableAttribute("1")]
public Type FieldType { get; }
    public bool IsAssembly { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsInitOnly { get; }
    public bool IsLiteral { get; }
    public bool IsNotSerialized { get; }
    public bool IsPinvokeImpl { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public MemberTypes MemberType { get; }
    public abstract virtual FieldAttributes get_Attributes();
    public abstract virtual RuntimeFieldHandle get_FieldHandle();
    [NullableContextAttribute("1")]
public abstract virtual Type get_FieldType();
    public bool get_IsAssembly();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsInitOnly();
    public bool get_IsLiteral();
    public bool get_IsNotSerialized();
    public bool get_IsPinvokeImpl();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public virtual MemberTypes get_MemberType();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle);
    [NullableContextAttribute("1")]
public static FieldInfo GetFieldFromHandle(RuntimeFieldHandle handle, RuntimeTypeHandle declaringType);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    [NullableContextAttribute("1")]
public virtual Type[] GetRequiredCustomModifiers();
    public abstract virtual object GetValue(object obj);
    [CLSCompliantAttribute("False")]
public virtual object GetValueDirect(TypedReference obj);
    public static bool op_Equality(FieldInfo left, FieldInfo right);
    public static bool op_Inequality(FieldInfo left, FieldInfo right);
    public void SetValue(object obj, object value);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public virtual void SetValueDirect(TypedReference obj, object value);
}
[FlagsAttribute]
public enum System.Reflection.GenericParameterAttributes : Enum {
    public int value__;
    public static GenericParameterAttributes None;
    public static GenericParameterAttributes Covariant;
    public static GenericParameterAttributes Contravariant;
    public static GenericParameterAttributes VarianceMask;
    public static GenericParameterAttributes ReferenceTypeConstraint;
    public static GenericParameterAttributes NotNullableValueTypeConstraint;
    public static GenericParameterAttributes DefaultConstructorConstraint;
    public static GenericParameterAttributes SpecialConstraintMask;
}
[NullableContextAttribute("1")]
public interface System.Reflection.ICustomAttributeProvider {
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
}
public enum System.Reflection.ImageFileMachine : Enum {
    public int value__;
    public static ImageFileMachine I386;
    public static ImageFileMachine ARM;
    public static ImageFileMachine IA64;
    public static ImageFileMachine AMD64;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.InterfaceMapping : ValueType {
    public MethodInfo[] InterfaceMethods;
    public Type InterfaceType;
    public MethodInfo[] TargetMethods;
    public Type TargetType;
}
[ExtensionAttribute]
public static class System.Reflection.IntrospectionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static TypeInfo GetTypeInfo(Type type);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.InvalidFilterCriteriaException : ApplicationException {
    [NullableContextAttribute("1")]
protected InvalidFilterCriteriaException(SerializationInfo info, StreamingContext context);
    public InvalidFilterCriteriaException(string message);
    public InvalidFilterCriteriaException(string message, Exception inner);
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflect {
    public Type UnderlyingSystemType { get; }
    public abstract virtual Type get_UnderlyingSystemType();
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
}
[NullableContextAttribute("1")]
public interface System.Reflection.IReflectableType {
    public abstract virtual TypeInfo GetTypeInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.LocalVariableInfo : object {
    public bool IsPinned { get; }
    public int LocalIndex { get; }
    public Type LocalType { get; }
    public virtual bool get_IsPinned();
    public virtual int get_LocalIndex();
    public virtual Type get_LocalType();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.ManifestResourceInfo : object {
    public string FileName { get; }
    public Assembly ReferencedAssembly { get; }
    public ResourceLocation ResourceLocation { get; }
    public ManifestResourceInfo(Assembly containingAssembly, string containingFileName, ResourceLocation resourceLocation);
    public virtual string get_FileName();
    public virtual Assembly get_ReferencedAssembly();
    public virtual ResourceLocation get_ResourceLocation();
}
public class System.Reflection.MemberFilter : MulticastDelegate {
    public MemberFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(MemberInfo m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(MemberInfo m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.MemberInfo : object {
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    public bool IsCollectible { get; }
    public MemberTypes MemberType { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [NullableContextAttribute("2")]
public abstract virtual Type get_DeclaringType();
    public virtual bool get_IsCollectible();
    public abstract virtual MemberTypes get_MemberType();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual Type get_ReflectedType();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public abstract virtual Object[] GetCustomAttributes(bool inherit);
    public abstract virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual int GetHashCode();
    public virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual bool IsDefined(Type attributeType, bool inherit);
    [NullableContextAttribute("2")]
public static bool op_Equality(MemberInfo left, MemberInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MemberInfo left, MemberInfo right);
}
[FlagsAttribute]
public enum System.Reflection.MemberTypes : Enum {
    public int value__;
    public static MemberTypes Constructor;
    public static MemberTypes Event;
    public static MemberTypes Field;
    public static MemberTypes Method;
    public static MemberTypes Property;
    public static MemberTypes TypeInfo;
    public static MemberTypes Custom;
    public static MemberTypes NestedType;
    public static MemberTypes All;
}
[FlagsAttribute]
public enum System.Reflection.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes PrivateScope;
    public static MethodAttributes ReuseSlot;
    public static MethodAttributes Private;
    public static MethodAttributes FamANDAssem;
    public static MethodAttributes Assembly;
    public static MethodAttributes Family;
    public static MethodAttributes FamORAssem;
    public static MethodAttributes Public;
    public static MethodAttributes MemberAccessMask;
    public static MethodAttributes UnmanagedExport;
    public static MethodAttributes Static;
    public static MethodAttributes Final;
    public static MethodAttributes Virtual;
    public static MethodAttributes HideBySig;
    public static MethodAttributes NewSlot;
    public static MethodAttributes VtableLayoutMask;
    public static MethodAttributes CheckAccessOnOverride;
    public static MethodAttributes Abstract;
    public static MethodAttributes SpecialName;
    public static MethodAttributes RTSpecialName;
    public static MethodAttributes PinvokeImpl;
    public static MethodAttributes HasSecurity;
    public static MethodAttributes RequireSecObject;
    public static MethodAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.MethodBase : MemberInfo {
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public bool ContainsGenericParameters { get; }
    public bool IsAbstract { get; }
    public bool IsAssembly { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsConstructor { get; }
    public bool IsFamily { get; }
    public bool IsFamilyAndAssembly { get; }
    public bool IsFamilyOrAssembly { get; }
    public bool IsFinal { get; }
    public bool IsGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsHideBySig { get; }
    public bool IsPrivate { get; }
    public bool IsPublic { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSpecialName { get; }
    public bool IsStatic { get; }
    public bool IsVirtual { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public abstract virtual MethodAttributes get_Attributes();
    public virtual CallingConventions get_CallingConvention();
    public virtual bool get_ContainsGenericParameters();
    public bool get_IsAbstract();
    public bool get_IsAssembly();
    public virtual bool get_IsConstructedGenericMethod();
    public bool get_IsConstructor();
    public bool get_IsFamily();
    public bool get_IsFamilyAndAssembly();
    public bool get_IsFamilyOrAssembly();
    public bool get_IsFinal();
    public virtual bool get_IsGenericMethod();
    public virtual bool get_IsGenericMethodDefinition();
    public bool get_IsHideBySig();
    public bool get_IsPrivate();
    public bool get_IsPublic();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public bool get_IsSpecialName();
    public bool get_IsStatic();
    public bool get_IsVirtual();
    public abstract virtual RuntimeMethodHandle get_MethodHandle();
    public virtual MethodImplAttributes get_MethodImplementationFlags();
    public virtual bool Equals(object obj);
    [RequiresUnreferencedCodeAttribute("Metadata for the method might be incomplete or removed")]
public static MethodBase GetCurrentMethod();
    [NullableContextAttribute("1")]
public virtual Type[] GetGenericArguments();
    public virtual int GetHashCode();
    [RequiresUnreferencedCodeAttribute("Trimming may change method bodies. For example it can change some instructions, remove branches or local variables.")]
public virtual MethodBody GetMethodBody();
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle);
    public static MethodBase GetMethodFromHandle(RuntimeMethodHandle handle, RuntimeTypeHandle declaringType);
    public abstract virtual MethodImplAttributes GetMethodImplementationFlags();
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetParameters();
    public object Invoke(object obj, Object[] parameters);
    public abstract virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public static bool op_Equality(MethodBase left, MethodBase right);
    public static bool op_Inequality(MethodBase left, MethodBase right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.MethodBody : object {
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public bool InitLocals { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public int MaxStackSize { get; }
    public virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    public virtual bool get_InitLocals();
    public virtual int get_LocalSignatureMetadataToken();
    public virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public virtual int get_MaxStackSize();
    [NullableContextAttribute("2")]
public virtual Byte[] GetILAsByteArray();
}
public enum System.Reflection.MethodImplAttributes : Enum {
    public int value__;
    public static MethodImplAttributes IL;
    public static MethodImplAttributes Managed;
    public static MethodImplAttributes Native;
    public static MethodImplAttributes OPTIL;
    public static MethodImplAttributes CodeTypeMask;
    public static MethodImplAttributes Runtime;
    public static MethodImplAttributes ManagedMask;
    public static MethodImplAttributes Unmanaged;
    public static MethodImplAttributes NoInlining;
    public static MethodImplAttributes ForwardRef;
    public static MethodImplAttributes Synchronized;
    public static MethodImplAttributes NoOptimization;
    public static MethodImplAttributes PreserveSig;
    public static MethodImplAttributes AggressiveInlining;
    public static MethodImplAttributes AggressiveOptimization;
    public static MethodImplAttributes InternalCall;
    public static MethodImplAttributes MaxMethodImplVal;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.MethodInfo : MethodBase {
    public MemberTypes MemberType { get; }
    public ParameterInfo ReturnParameter { get; }
    public Type ReturnType { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public virtual MemberTypes get_MemberType();
    public virtual ParameterInfo get_ReturnParameter();
    public virtual Type get_ReturnType();
    public abstract virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public virtual Delegate CreateDelegate(Type delegateType);
    public virtual Delegate CreateDelegate(Type delegateType, object target);
    public T CreateDelegate();
    public T CreateDelegate(object target);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public abstract virtual MethodInfo GetBaseDefinition();
    public virtual Type[] GetGenericArguments();
    public virtual MethodInfo GetGenericMethodDefinition();
    public virtual int GetHashCode();
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    [NullableContextAttribute("2")]
public static bool op_Equality(MethodInfo left, MethodInfo right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(MethodInfo left, MethodInfo right);
}
public class System.Reflection.Missing : object {
    [NullableAttribute("1")]
public static Missing Value;
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.Module : object {
    public static TypeFilter FilterTypeName;
    public static TypeFilter FilterTypeNameIgnoreCase;
    public Assembly Assembly { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public ModuleHandle ModuleHandle { get; }
    public Guid ModuleVersionId { get; }
    [RequiresAssemblyFilesAttribute("Returns <Unknown> for modules with no file path")]
public string Name { get; }
    public string ScopeName { get; }
    public virtual Assembly get_Assembly();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public virtual string get_FullyQualifiedName();
    public virtual int get_MDStreamVersion();
    public virtual int get_MetadataToken();
    public ModuleHandle get_ModuleHandle();
    public virtual Guid get_ModuleVersionId();
    public virtual string get_Name();
    public virtual string get_ScopeName();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] FindTypes(TypeFilter filter, object filterCriteria);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public FieldInfo GetField(string name);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public FieldInfo[] GetFields();
    [RequiresUnreferencedCodeAttribute("Fields might be removed")]
public virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public virtual int GetHashCode();
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo GetMethod(string name, Type[] types);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Methods might be removed")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public MethodInfo[] GetMethods();
    [RequiresUnreferencedCodeAttribute("Methods might be removed")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("Types might be removed")]
public virtual Type[] GetTypes();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual bool IsResource();
    [NullableContextAttribute("2")]
public static bool op_Equality(Module left, Module right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Module left, Module right);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public FieldInfo ResolveField(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public MemberInfo ResolveMember(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public MethodBase ResolveMethod(int metadataToken);
    [NullableContextAttribute("2")]
[RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Byte[] ResolveSignature(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual string ResolveString(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public Type ResolveType(int metadataToken);
    [RequiresUnreferencedCodeAttribute("Trimming changes metadata tokens")]
public virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public virtual string ToString();
}
public class System.Reflection.ModuleResolveEventHandler : MulticastDelegate {
    public ModuleResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual Module Invoke(object sender, ResolveEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs e, AsyncCallback callback, object object);
    public virtual Module EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.NullabilityInfo : object {
    [NullableAttribute("2")]
public NullabilityInfo ElementType { get; }
    public NullabilityInfo[] GenericTypeArguments { get; }
    public NullabilityState ReadState { get; }
    public Type Type { get; }
    public NullabilityState WriteState { get; }
    [NullableContextAttribute("2")]
public NullabilityInfo get_ElementType();
    public NullabilityInfo[] get_GenericTypeArguments();
    public NullabilityState get_ReadState();
    public Type get_Type();
    public NullabilityState get_WriteState();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.NullabilityInfoContext : object {
    public NullabilityInfo Create(EventInfo eventInfo);
    public NullabilityInfo Create(FieldInfo fieldInfo);
    public NullabilityInfo Create(ParameterInfo parameterInfo);
    public NullabilityInfo Create(PropertyInfo propertyInfo);
}
public enum System.Reflection.NullabilityState : Enum {
    public int value__;
    public static NullabilityState Unknown;
    public static NullabilityState NotNull;
    public static NullabilityState Nullable;
}
[AttributeUsageAttribute("1")]
public class System.Reflection.ObfuscateAssemblyAttribute : Attribute {
    public bool AssemblyIsPrivate { get; }
    public bool StripAfterObfuscation { get; public set; }
    public ObfuscateAssemblyAttribute(bool assemblyIsPrivate);
    public bool get_AssemblyIsPrivate();
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("8157")]
public class System.Reflection.ObfuscationAttribute : Attribute {
    public bool ApplyToMembers { get; public set; }
    public bool Exclude { get; public set; }
    public string Feature { get; public set; }
    public bool StripAfterObfuscation { get; public set; }
    public bool get_ApplyToMembers();
    public void set_ApplyToMembers(bool value);
    public bool get_Exclude();
    public void set_Exclude(bool value);
    public string get_Feature();
    public void set_Feature(string value);
    public bool get_StripAfterObfuscation();
    public void set_StripAfterObfuscation(bool value);
}
[FlagsAttribute]
public enum System.Reflection.ParameterAttributes : Enum {
    public int value__;
    public static ParameterAttributes None;
    public static ParameterAttributes In;
    public static ParameterAttributes Out;
    public static ParameterAttributes Lcid;
    public static ParameterAttributes Retval;
    public static ParameterAttributes Optional;
    public static ParameterAttributes HasDefault;
    public static ParameterAttributes HasFieldMarshal;
    public static ParameterAttributes Reserved3;
    public static ParameterAttributes Reserved4;
    public static ParameterAttributes ReservedMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.ParameterInfo : object {
    protected ParameterAttributes AttrsImpl;
    [NullableAttribute("2")]
protected Type ClassImpl;
    [NullableAttribute("2")]
protected object DefaultValueImpl;
    protected MemberInfo MemberImpl;
    [NullableAttribute("2")]
protected string NameImpl;
    protected int PositionImpl;
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    [NullableAttribute("2")]
public object DefaultValue { get; }
    public bool HasDefaultValue { get; }
    public bool IsIn { get; }
    public bool IsLcid { get; }
    public bool IsOptional { get; }
    public bool IsOut { get; }
    public bool IsRetval { get; }
    public MemberInfo Member { get; }
    public int MetadataToken { get; }
    [NullableAttribute("2")]
public string Name { get; }
    public Type ParameterType { get; }
    public int Position { get; }
    [NullableAttribute("2")]
public object RawDefaultValue { get; }
    public virtual ParameterAttributes get_Attributes();
    public virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    [NullableContextAttribute("2")]
public virtual object get_DefaultValue();
    public virtual bool get_HasDefaultValue();
    public bool get_IsIn();
    public bool get_IsLcid();
    public bool get_IsOptional();
    public bool get_IsOut();
    public bool get_IsRetval();
    public virtual MemberInfo get_Member();
    public virtual int get_MetadataToken();
    [NullableContextAttribute("2")]
public virtual string get_Name();
    public virtual Type get_ParameterType();
    public virtual int get_Position();
    [NullableContextAttribute("2")]
public virtual object get_RawDefaultValue();
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual object GetRealObject(StreamingContext context);
    public virtual Type[] GetRequiredCustomModifiers();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    public virtual string ToString();
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Reflection.ParameterModifier : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool Item { get; public set; }
    public ParameterModifier(int parameterCount);
    public bool get_Item(int index);
    public void set_Item(int index, bool value);
}
[CLSCompliantAttribute("False")]
public class System.Reflection.Pointer : object {
    [NullableContextAttribute("1")]
public static object Box(Void* ptr, Type type);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public static Void* Unbox(object ptr);
}
[FlagsAttribute]
public enum System.Reflection.PortableExecutableKinds : Enum {
    public int value__;
    public static PortableExecutableKinds NotAPortableExecutableImage;
    public static PortableExecutableKinds ILOnly;
    public static PortableExecutableKinds Required32Bit;
    public static PortableExecutableKinds PE32Plus;
    public static PortableExecutableKinds Unmanaged32Bit;
    public static PortableExecutableKinds Preferred32Bit;
}
public enum System.Reflection.ProcessorArchitecture : Enum {
    public int value__;
    public static ProcessorArchitecture None;
    public static ProcessorArchitecture MSIL;
    public static ProcessorArchitecture X86;
    public static ProcessorArchitecture IA64;
    public static ProcessorArchitecture Amd64;
    public static ProcessorArchitecture Arm;
}
[FlagsAttribute]
public enum System.Reflection.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes SpecialName;
    public static PropertyAttributes RTSpecialName;
    public static PropertyAttributes HasDefault;
    public static PropertyAttributes Reserved2;
    public static PropertyAttributes Reserved3;
    public static PropertyAttributes Reserved4;
    public static PropertyAttributes ReservedMask;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Reflection.PropertyInfo : MemberInfo {
    public PropertyAttributes Attributes { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    public MethodInfo GetMethod { get; }
    public bool IsSpecialName { get; }
    public MemberTypes MemberType { get; }
    [NullableAttribute("1")]
public Type PropertyType { get; }
    public MethodInfo SetMethod { get; }
    public abstract virtual PropertyAttributes get_Attributes();
    public abstract virtual bool get_CanRead();
    public abstract virtual bool get_CanWrite();
    public virtual MethodInfo get_GetMethod();
    public bool get_IsSpecialName();
    public virtual MemberTypes get_MemberType();
    [NullableContextAttribute("1")]
public abstract virtual Type get_PropertyType();
    public virtual MethodInfo get_SetMethod();
    public virtual bool Equals(object obj);
    [NullableContextAttribute("1")]
public MethodInfo[] GetAccessors();
    [NullableContextAttribute("1")]
public abstract virtual MethodInfo[] GetAccessors(bool nonPublic);
    public virtual object GetConstantValue();
    public MethodInfo GetGetMethod();
    public abstract virtual MethodInfo GetGetMethod(bool nonPublic);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public abstract virtual ParameterInfo[] GetIndexParameters();
    [NullableContextAttribute("1")]
public virtual Type[] GetOptionalCustomModifiers();
    public virtual object GetRawConstantValue();
    [NullableContextAttribute("1")]
public virtual Type[] GetRequiredCustomModifiers();
    public MethodInfo GetSetMethod();
    public abstract virtual MethodInfo GetSetMethod(bool nonPublic);
    public object GetValue(object obj);
    public virtual object GetValue(object obj, Object[] index);
    public abstract virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public static bool op_Equality(PropertyInfo left, PropertyInfo right);
    public static bool op_Inequality(PropertyInfo left, PropertyInfo right);
    public void SetValue(object obj, object value);
    public virtual void SetValue(object obj, object value, Object[] index);
    public abstract virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.ReflectionContext : object {
    public virtual TypeInfo GetTypeForObject(object value);
    public abstract virtual Assembly MapAssembly(Assembly assembly);
    public abstract virtual TypeInfo MapType(TypeInfo type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.ReflectionTypeLoadException : SystemException {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Exception[] LoaderExceptions { get; }
    public string Message { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Type[] Types { get; }
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions);
    [NullableContextAttribute("2")]
public ReflectionTypeLoadException(Type[] classes, Exception[] exceptions, string message);
    public Exception[] get_LoaderExceptions();
    public virtual string get_Message();
    public Type[] get_Types();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.Reflection.ResourceAttributes : Enum {
    public int value__;
    public static ResourceAttributes Public;
    public static ResourceAttributes Private;
}
[FlagsAttribute]
public enum System.Reflection.ResourceLocation : Enum {
    public int value__;
    public static ResourceLocation Embedded;
    public static ResourceLocation ContainedInAnotherAssembly;
    public static ResourceLocation ContainedInManifestFile;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Reflection.RuntimeReflectionExtensions : object {
    [ExtensionAttribute]
public static MethodInfo GetMethodInfo(Delegate del);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeBaseDefinition(MethodInfo method);
    [ExtensionAttribute]
public static EventInfo GetRuntimeEvent(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<EventInfo> GetRuntimeEvents(Type type);
    [ExtensionAttribute]
public static FieldInfo GetRuntimeField(Type type, string name);
    [ExtensionAttribute]
public static IEnumerable`1<FieldInfo> GetRuntimeFields(Type type);
    [ExtensionAttribute]
public static InterfaceMapping GetRuntimeInterfaceMap(TypeInfo typeInfo, Type interfaceType);
    [ExtensionAttribute]
public static MethodInfo GetRuntimeMethod(Type type, string name, Type[] parameters);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetRuntimeMethods(Type type);
    [ExtensionAttribute]
public static IEnumerable`1<PropertyInfo> GetRuntimeProperties(Type type);
    [ExtensionAttribute]
public static PropertyInfo GetRuntimeProperty(Type type, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("Strong name signing is not supported and throws PlatformNotSupportedException.")]
public class System.Reflection.StrongNameKeyPair : object {
    public Byte[] PublicKey { get; }
    public StrongNameKeyPair(Byte[] keyPairArray);
    public StrongNameKeyPair(FileStream keyPairFile);
    protected StrongNameKeyPair(SerializationInfo info, StreamingContext context);
    public StrongNameKeyPair(string keyPairContainer);
    public Byte[] get_PublicKey();
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.TargetException : ApplicationException {
    [NullableContextAttribute("1")]
protected TargetException(SerializationInfo info, StreamingContext context);
    public TargetException(string message);
    public TargetException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.TargetInvocationException : ApplicationException {
    public TargetInvocationException(Exception inner);
    public TargetInvocationException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Reflection.TargetParameterCountException : ApplicationException {
    public TargetParameterCountException(string message);
    public TargetParameterCountException(string message, Exception inner);
}
[FlagsAttribute]
public enum System.Reflection.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes AnsiClass;
    public static TypeAttributes AutoLayout;
    public static TypeAttributes Class;
    public static TypeAttributes NotPublic;
    public static TypeAttributes Public;
    public static TypeAttributes NestedPublic;
    public static TypeAttributes NestedPrivate;
    public static TypeAttributes NestedFamily;
    public static TypeAttributes NestedAssembly;
    public static TypeAttributes NestedFamANDAssem;
    public static TypeAttributes NestedFamORAssem;
    public static TypeAttributes VisibilityMask;
    public static TypeAttributes SequentialLayout;
    public static TypeAttributes ExplicitLayout;
    public static TypeAttributes LayoutMask;
    public static TypeAttributes ClassSemanticsMask;
    public static TypeAttributes Interface;
    public static TypeAttributes Abstract;
    public static TypeAttributes Sealed;
    public static TypeAttributes SpecialName;
    public static TypeAttributes RTSpecialName;
    public static TypeAttributes Import;
    public static TypeAttributes Serializable;
    public static TypeAttributes WindowsRuntime;
    public static TypeAttributes UnicodeClass;
    public static TypeAttributes AutoClass;
    public static TypeAttributes CustomFormatClass;
    public static TypeAttributes StringFormatMask;
    public static TypeAttributes HasSecurity;
    public static TypeAttributes ReservedMask;
    public static TypeAttributes BeforeFieldInit;
    public static TypeAttributes CustomFormatMask;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.TypeDelegator : TypeInfo {
    [DynamicallyAccessedMembersAttribute("-1")]
protected Type typeImpl;
    public Assembly Assembly { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public Guid GUID { get; }
    public bool IsByRefLike { get; }
    public bool IsCollectible { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsVariableBoundArray { get; }
    public int MetadataToken { get; }
    public Module Module { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    public Type UnderlyingSystemType { get; }
    public TypeDelegator(Type delegatingType);
    public virtual Assembly get_Assembly();
    [NullableContextAttribute("2")]
public virtual string get_AssemblyQualifiedName();
    [NullableContextAttribute("2")]
public virtual Type get_BaseType();
    [NullableContextAttribute("2")]
public virtual string get_FullName();
    public virtual Guid get_GUID();
    public virtual bool get_IsByRefLike();
    public virtual bool get_IsCollectible();
    public virtual bool get_IsConstructedGenericType();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericTypeParameter();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public virtual bool get_IsVariableBoundArray();
    public virtual int get_MetadataToken();
    public virtual Module get_Module();
    public virtual string get_Name();
    [NullableContextAttribute("2")]
public virtual string get_Namespace();
    public virtual RuntimeTypeHandle get_TypeHandle();
    public virtual Type get_UnderlyingSystemType();
    protected virtual TypeAttributes GetAttributeFlagsImpl();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
protected virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    public virtual Object[] GetCustomAttributes(bool inherit);
    public virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    [NullableContextAttribute("2")]
public virtual Type GetElementType();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
protected virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    protected virtual bool HasElementTypeImpl();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected virtual bool IsArrayImpl();
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    protected virtual bool IsByRefImpl();
    protected virtual bool IsCOMObjectImpl();
    public virtual bool IsDefined(Type attributeType, bool inherit);
    protected virtual bool IsPointerImpl();
    protected virtual bool IsPrimitiveImpl();
    protected virtual bool IsValueTypeImpl();
}
public class System.Reflection.TypeFilter : MulticastDelegate {
    public TypeFilter(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual bool Invoke(Type m, object filterCriteria);
    public virtual IAsyncResult BeginInvoke(Type m, object filterCriteria, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Reflection.TypeInfo : Type {
    public IEnumerable`1<ConstructorInfo> DeclaredConstructors { get; }
    public IEnumerable`1<EventInfo> DeclaredEvents { get; }
    public IEnumerable`1<FieldInfo> DeclaredFields { get; }
    public IEnumerable`1<MemberInfo> DeclaredMembers { get; }
    public IEnumerable`1<MethodInfo> DeclaredMethods { get; }
    public IEnumerable`1<TypeInfo> DeclaredNestedTypes { get; }
    public IEnumerable`1<PropertyInfo> DeclaredProperties { get; }
    public Type[] GenericTypeParameters { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    [DynamicallyAccessedMembersAttribute("7")]
public virtual IEnumerable`1<ConstructorInfo> get_DeclaredConstructors();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual IEnumerable`1<EventInfo> get_DeclaredEvents();
    [DynamicallyAccessedMembersAttribute("96")]
public virtual IEnumerable`1<FieldInfo> get_DeclaredFields();
    [DynamicallyAccessedMembersAttribute("-1")]
public virtual IEnumerable`1<MemberInfo> get_DeclaredMembers();
    [DynamicallyAccessedMembersAttribute("24")]
public virtual IEnumerable`1<MethodInfo> get_DeclaredMethods();
    [DynamicallyAccessedMembersAttribute("384")]
public virtual IEnumerable`1<TypeInfo> get_DeclaredNestedTypes();
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual IEnumerable`1<PropertyInfo> get_DeclaredProperties();
    public virtual Type[] get_GenericTypeParameters();
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    public virtual Type AsType();
    [DynamicallyAccessedMembersAttribute("6144")]
public virtual EventInfo GetDeclaredEvent(string name);
    [DynamicallyAccessedMembersAttribute("96")]
public virtual FieldInfo GetDeclaredField(string name);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual MethodInfo GetDeclaredMethod(string name);
    [DynamicallyAccessedMembersAttribute("24")]
public virtual IEnumerable`1<MethodInfo> GetDeclaredMethods(string name);
    [DynamicallyAccessedMembersAttribute("384")]
public virtual TypeInfo GetDeclaredNestedType(string name);
    [DynamicallyAccessedMembersAttribute("1536")]
public virtual PropertyInfo GetDeclaredProperty(string name);
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(TypeInfo typeInfo);
    private sealed virtual override TypeInfo System.Reflection.IReflectableType.GetTypeInfo();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ResolveEventArgs : EventArgs {
    public string Name { get; }
    [NullableAttribute("2")]
public Assembly RequestingAssembly { get; }
    public ResolveEventArgs(string name);
    public ResolveEventArgs(string name, Assembly requestingAssembly);
    public string get_Name();
    [NullableContextAttribute("2")]
public Assembly get_RequestingAssembly();
}
public class System.ResolveEventHandler : MulticastDelegate {
    public ResolveEventHandler(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual Assembly Invoke(object sender, ResolveEventArgs args);
    public virtual IAsyncResult BeginInvoke(object sender, ResolveEventArgs args, AsyncCallback callback, object object);
    public virtual Assembly EndInvoke(IAsyncResult result);
}
public interface System.Resources.IResourceReader {
    public abstract virtual void Close();
    [NullableContextAttribute("1")]
public abstract virtual IDictionaryEnumerator GetEnumerator();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Resources.MissingManifestResourceException : SystemException {
    [NullableContextAttribute("1")]
protected MissingManifestResourceException(SerializationInfo info, StreamingContext context);
    public MissingManifestResourceException(string message);
    public MissingManifestResourceException(string message, Exception inner);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Resources.MissingSatelliteAssemblyException : SystemException {
    public string CultureName { get; }
    [NullableContextAttribute("1")]
protected MissingSatelliteAssemblyException(SerializationInfo info, StreamingContext context);
    public MissingSatelliteAssemblyException(string message);
    public MissingSatelliteAssemblyException(string message, Exception inner);
    public MissingSatelliteAssemblyException(string message, string cultureName);
    public string get_CultureName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
[EditorBrowsableAttribute("1")]
public class System.Resources.NeutralResourcesLanguageAttribute : Attribute {
    public string CultureName { get; }
    public UltimateResourceFallbackLocation Location { get; }
    public NeutralResourcesLanguageAttribute(string cultureName);
    public NeutralResourcesLanguageAttribute(string cultureName, UltimateResourceFallbackLocation location);
    public string get_CultureName();
    public UltimateResourceFallbackLocation get_Location();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Resources.ResourceManager : object {
    public static int HeaderVersionNumber;
    public static int MagicNumber;
    [NullableAttribute("2")]
protected Assembly MainAssembly;
    public string BaseName { get; }
    protected UltimateResourceFallbackLocation FallbackLocation { get; protected set; }
    public bool IgnoreCase { get; public set; }
    [DynamicallyAccessedMembersAttribute("7")]
public Type ResourceSetType { get; }
    public ResourceManager(string baseName, Assembly assembly);
    public ResourceManager(string baseName, Assembly assembly, Type usingResourceSet);
    public ResourceManager(Type resourceSource);
    public virtual string get_BaseName();
    protected UltimateResourceFallbackLocation get_FallbackLocation();
    protected void set_FallbackLocation(UltimateResourceFallbackLocation value);
    public virtual bool get_IgnoreCase();
    public virtual void set_IgnoreCase(bool value);
    public virtual Type get_ResourceSetType();
    public static ResourceManager CreateFileBasedResourceManager(string baseName, string resourceDir, Type usingResourceSet);
    protected static CultureInfo GetNeutralResourcesLanguage(Assembly a);
    public virtual object GetObject(string name);
    [NullableContextAttribute("2")]
public virtual object GetObject(string name, CultureInfo culture);
    protected virtual string GetResourceFileName(CultureInfo culture);
    public virtual ResourceSet GetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    protected static Version GetSatelliteContractVersion(Assembly a);
    public UnmanagedMemoryStream GetStream(string name);
    [NullableContextAttribute("2")]
public UnmanagedMemoryStream GetStream(string name, CultureInfo culture);
    public virtual string GetString(string name);
    [NullableContextAttribute("2")]
public virtual string GetString(string name, CultureInfo culture);
    protected virtual ResourceSet InternalGetResourceSet(CultureInfo culture, bool createIfNotExists, bool tryParents);
    public virtual void ReleaseAllResources();
}
public class System.Resources.ResourceReader : object {
    [NullableContextAttribute("1")]
public ResourceReader(Stream stream);
    [NullableContextAttribute("1")]
public ResourceReader(string fileName);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
    [NullableContextAttribute("1")]
public sealed virtual IDictionaryEnumerator GetEnumerator();
    [NullableContextAttribute("1")]
public void GetResourceData(string resourceName, String& resourceType, Byte[]& resourceData);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Resources.ResourceSet : object {
    public ResourceSet(Stream stream);
    public ResourceSet(IResourceReader reader);
    public ResourceSet(string fileName);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public virtual Type GetDefaultReader();
    public virtual Type GetDefaultWriter();
    public virtual IDictionaryEnumerator GetEnumerator();
    public virtual object GetObject(string name);
    public virtual object GetObject(string name, bool ignoreCase);
    public virtual string GetString(string name);
    public virtual string GetString(string name, bool ignoreCase);
    protected virtual void ReadResources();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
[EditorBrowsableAttribute("1")]
public class System.Resources.SatelliteContractVersionAttribute : Attribute {
    public string Version { get; }
    public SatelliteContractVersionAttribute(string version);
    public string get_Version();
}
public enum System.Resources.UltimateResourceFallbackLocation : Enum {
    public int value__;
    public static UltimateResourceFallbackLocation MainAssembly;
    public static UltimateResourceFallbackLocation Satellite;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.AmbiguousImplementationException : Exception {
    public AmbiguousImplementationException(string message);
    public AmbiguousImplementationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.AssemblyTargetedPatchBandAttribute : Attribute {
    public string TargetedPatchBand { get; }
    public AssemblyTargetedPatchBandAttribute(string targetedPatchBand);
    public string get_TargetedPatchBand();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.AccessedThroughPropertyAttribute : Attribute {
    public string PropertyName { get; }
    public AccessedThroughPropertyAttribute(string propertyName);
    public string get_PropertyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncIteratorMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void Complete();
    public static AsyncIteratorMethodBuilder Create();
    public void MoveNext(TStateMachine& stateMachine);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncIteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncIteratorStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5212")]
public class System.Runtime.CompilerServices.AsyncMethodBuilderAttribute : Attribute {
    public Type BuilderType { get; }
    public AsyncMethodBuilderAttribute(Type builderType);
    public Type get_BuilderType();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.AsyncStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public AsyncStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Task Task { get; }
    public Task get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncTaskMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Task`1<TResult> Task { get; }
    public Task`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncTaskMethodBuilder`1<TResult> Create();
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ValueTask Task { get; }
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncValueTaskMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTask`1<TResult> Task { get; }
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncValueTaskMethodBuilder`1<TResult> Create();
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.AsyncVoidMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static AsyncVoidMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
public class System.Runtime.CompilerServices.CallConvCdecl : object {
}
public class System.Runtime.CompilerServices.CallConvFastcall : object {
}
public class System.Runtime.CompilerServices.CallConvMemberFunction : object {
}
public class System.Runtime.CompilerServices.CallConvStdcall : object {
}
public class System.Runtime.CompilerServices.CallConvSuppressGCTransition : object {
}
public class System.Runtime.CompilerServices.CallConvThiscall : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerArgumentExpressionAttribute : Attribute {
    public string ParameterName { get; }
    public CallerArgumentExpressionAttribute(string parameterName);
    public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerFilePathAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerLineNumberAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.CallerMemberNameAttribute : Attribute {
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.CompilationRelaxations : Enum {
    public int value__;
    public static CompilationRelaxations NoStringInterning;
}
[AttributeUsageAttribute("71")]
public class System.Runtime.CompilerServices.CompilationRelaxationsAttribute : Attribute {
    public int CompilationRelaxations { get; }
    public CompilationRelaxationsAttribute(int relaxations);
    public CompilationRelaxationsAttribute(CompilationRelaxations relaxations);
    public int get_CompilationRelaxations();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute : Attribute {
    public static string RefStructs;
    public static string RequiredMembers;
    public string FeatureName { get; }
    public bool IsOptional { get; public set; }
    public CompilerFeatureRequiredAttribute(string featureName);
    public string get_FeatureName();
    public bool get_IsOptional();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsOptional(bool value);
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.CompilerGeneratedAttribute : Attribute {
}
[AttributeUsageAttribute("4")]
public class System.Runtime.CompilerServices.CompilerGlobalScopeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.ConditionalWeakTable`2 : object {
    public void Add(TKey key, TValue value);
    public void AddOrUpdate(TKey key, TValue value);
    public void Clear();
    public TValue GetOrCreateValue(TKey key);
    public TValue GetValue(TKey key, CreateValueCallback<TKey, TValue> createValueCallback);
    public bool Remove(TKey key);
    private sealed virtual override IEnumerator`1<KeyValuePair`2<TKey, TValue>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<TKey,TValue>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryAdd(TKey key, TValue value);
    public bool TryGetValue(TKey key, TValue& value);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredAsyncDisposable : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredValueTaskAwaitable DisposeAsync();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredCancelableAsyncEnumerable`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(bool continueOnCapturedContext);
    public Enumerator<T> GetAsyncEnumerator();
    public ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(CancellationToken cancellationToken);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredTaskAwaitable`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredTaskAwaiter<TResult> GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredValueTaskAwaiter GetAwaiter();
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ConfiguredValueTaskAwaitable`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ConfiguredValueTaskAwaiter<TResult> GetAwaiter();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2304")]
public abstract class System.Runtime.CompilerServices.CustomConstantAttribute : Attribute {
    public object Value { get; }
    public abstract virtual object get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DateTimeConstantAttribute : CustomConstantAttribute {
    public object Value { get; }
    public DateTimeConstantAttribute(long ticks);
    public virtual object get_Value();
}
[AttributeUsageAttribute("2304")]
public class System.Runtime.CompilerServices.DecimalConstantAttribute : Attribute {
    public decimal Value { get; }
    public DecimalConstantAttribute(byte scale, byte sign, int hi, int mid, int low);
    [CLSCompliantAttribute("False")]
public DecimalConstantAttribute(byte scale, byte sign, UInt32 hi, UInt32 mid, UInt32 low);
    public decimal get_Value();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DefaultDependencyAttribute : Attribute {
    public LoadHint LoadHint { get; }
    public DefaultDependencyAttribute(LoadHint loadHintArgument);
    public LoadHint get_LoadHint();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[InterpolatedStringHandlerAttribute]
public class System.Runtime.CompilerServices.DefaultInterpolatedStringHandler : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount);
    public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider);
    [NullableContextAttribute("0")]
public DefaultInterpolatedStringHandler(int literalLength, int formattedCount, IFormatProvider provider, Span`1<char> initialBuffer);
    public void AppendFormatted(object value, int alignment, string format);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public void AppendFormatted(ReadOnlySpan`1<char> value, int alignment, string format);
    public void AppendFormatted(string value);
    public void AppendFormatted(string value, int alignment, string format);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value);
    [NullableContextAttribute("1")]
public void AppendFormatted(T value, int alignment);
    public void AppendFormatted(T value, int alignment, string format);
    public void AppendFormatted(T value, string format);
    [NullableContextAttribute("1")]
public void AppendLiteral(string value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToStringAndClear();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DependencyAttribute : Attribute {
    public string DependentAssembly { get; }
    public LoadHint LoadHint { get; }
    public DependencyAttribute(string dependentAssemblyArgument, LoadHint loadHintArgument);
    public string get_DependentAssembly();
    public LoadHint get_LoadHint();
}
[ObsoleteAttribute("DisablePrivateReflectionAttribute has no effect in .NET 6.0+.")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisablePrivateReflectionAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.DisableRuntimeMarshallingAttribute : Attribute {
}
[AttributeUsageAttribute("32767")]
public class System.Runtime.CompilerServices.DiscardableAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.EnumeratorCancellationAttribute : Attribute {
}
[AttributeUsageAttribute("69")]
public class System.Runtime.CompilerServices.ExtensionAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedAddressValueTypeAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("256")]
public class System.Runtime.CompilerServices.FixedBufferAttribute : Attribute {
    public Type ElementType { get; }
    public int Length { get; }
    public FixedBufferAttribute(Type elementType, int length);
    public Type get_ElementType();
    public int get_Length();
}
public static class System.Runtime.CompilerServices.FormattableStringFactory : object {
    [NullableContextAttribute("1")]
public static FormattableString Create(string format, Object[] arguments);
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.IAsyncStateMachine {
    public abstract virtual void MoveNext();
    public abstract virtual void SetStateMachine(IAsyncStateMachine stateMachine);
}
public interface System.Runtime.CompilerServices.ICriticalNotifyCompletion {
    [NullableContextAttribute("1")]
public abstract virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("128")]
public class System.Runtime.CompilerServices.IndexerNameAttribute : Attribute {
    [NullableContextAttribute("1")]
public IndexerNameAttribute(string indexerName);
}
[NullableContextAttribute("1")]
public interface System.Runtime.CompilerServices.INotifyCompletion {
    public abstract virtual void OnCompleted(Action continuation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.InternalsVisibleToAttribute : Attribute {
    public bool AllInternalsVisible { get; public set; }
    public string AssemblyName { get; }
    public InternalsVisibleToAttribute(string assemblyName);
    public bool get_AllInternalsVisible();
    public void set_AllInternalsVisible(bool value);
    public string get_AssemblyName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2048")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute : Attribute {
    public String[] Arguments { get; }
    public InterpolatedStringHandlerArgumentAttribute(string argument);
    public InterpolatedStringHandlerArgumentAttribute(String[] arguments);
    public String[] get_Arguments();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute : Attribute {
}
[AttributeUsageAttribute("8")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsByRefLikeAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsConst : object {
}
[EditorBrowsableAttribute("1")]
public static class System.Runtime.CompilerServices.IsExternalInit : object {
}
[AttributeUsageAttribute("32767")]
[EditorBrowsableAttribute("1")]
public class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[NullableContextAttribute("2")]
public interface System.Runtime.CompilerServices.IStrongBox {
    public object Value { get; public set; }
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
public static class System.Runtime.CompilerServices.IsVolatile : object {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.IteratorStateMachineAttribute : StateMachineAttribute {
    [NullableContextAttribute("1")]
public IteratorStateMachineAttribute(Type stateMachineType);
}
[NullableContextAttribute("2")]
[DefaultMemberAttribute("Item")]
public interface System.Runtime.CompilerServices.ITuple {
    public object Item { get; }
    public int Length { get; }
    public abstract virtual object get_Item(int index);
    public abstract virtual int get_Length();
}
public enum System.Runtime.CompilerServices.LoadHint : Enum {
    public int value__;
    public static LoadHint Default;
    public static LoadHint Always;
    public static LoadHint Sometimes;
}
public enum System.Runtime.CompilerServices.MethodCodeType : Enum {
    public int value__;
    public static MethodCodeType IL;
    public static MethodCodeType Native;
    public static MethodCodeType OPTIL;
    public static MethodCodeType Runtime;
}
[AttributeUsageAttribute("96")]
public class System.Runtime.CompilerServices.MethodImplAttribute : Attribute {
    public MethodCodeType MethodCodeType;
    public MethodImplOptions Value { get; }
    public MethodImplAttribute(short value);
    public MethodImplAttribute(MethodImplOptions methodImplOptions);
    public MethodImplOptions get_Value();
}
[FlagsAttribute]
public enum System.Runtime.CompilerServices.MethodImplOptions : Enum {
    public int value__;
    public static MethodImplOptions Unmanaged;
    public static MethodImplOptions NoInlining;
    public static MethodImplOptions ForwardRef;
    public static MethodImplOptions Synchronized;
    public static MethodImplOptions NoOptimization;
    public static MethodImplOptions PreserveSig;
    public static MethodImplOptions AggressiveInlining;
    public static MethodImplOptions AggressiveOptimization;
    public static MethodImplOptions InternalCall;
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.ModuleInitializerAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ValueTask Task { get; }
    public ValueTask get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static PoolingAsyncValueTaskMethodBuilder Create();
    public void SetException(Exception exception);
    public void SetResult();
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.PoolingAsyncValueTaskMethodBuilder`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTask`1<TResult> Task { get; }
    public ValueTask`1<TResult> get_Task();
    public void AwaitOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public void AwaitUnsafeOnCompleted(TAwaiter& awaiter, TStateMachine& stateMachine);
    public static PoolingAsyncValueTaskMethodBuilder`1<TResult> Create();
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public void SetStateMachine(IAsyncStateMachine stateMachine);
    public void Start(TStateMachine& stateMachine);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.PreserveBaseOverridesAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.ReferenceAssemblyAttribute : Attribute {
    public string Description { get; }
    public ReferenceAssemblyAttribute(string description);
    public string get_Description();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
[AttributeUsageAttribute("396")]
public class System.Runtime.CompilerServices.RequiredMemberAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.RuntimeCompatibilityAttribute : Attribute {
    public bool WrapNonExceptionThrows { get; public set; }
    public bool get_WrapNonExceptionThrows();
    public void set_WrapNonExceptionThrows(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.RuntimeFeature : object {
    public static string ByRefFields;
    public static string CovariantReturnsOfClasses;
    public static string DefaultImplementationsOfInterfaces;
    public static string NumericIntPtr;
    public static string PortablePdb;
    public static string UnmanagedSignatureCallingConvention;
    public static string VirtualStaticsInInterfaces;
    public static bool IsDynamicCodeCompiled { get; }
    public static bool IsDynamicCodeSupported { get; }
    public static bool get_IsDynamicCodeCompiled();
    public static bool get_IsDynamicCodeSupported();
    public static bool IsSupported(string feature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.RuntimeHelpers : object {
    [ObsoleteAttribute("OffsetToStringData has been deprecated. Use string.GetPinnableReference() instead.")]
public static int OffsetToStringData { get; }
    public static int get_OffsetToStringData();
    public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);
    [NullableContextAttribute("2")]
public static ReadOnlySpan`1<T> CreateSpan(RuntimeFieldHandle fldHandle);
    public static void EnsureSufficientExecutionStack();
    [NullableContextAttribute("2")]
public static bool Equals(object o1, object o2);
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void ExecuteCodeWithGuaranteedCleanup(TryCode code, CleanupCode backoutCode, object userData);
    [NullableContextAttribute("2")]
public static int GetHashCode(object o);
    [NullableContextAttribute("2")]
public static object GetObjectValue(object obj);
    public static T[] GetSubArray(T[] array, Range range);
    public static object GetUninitializedObject(Type type);
    public static void InitializeArray(Array array, RuntimeFieldHandle fldHandle);
    [NullableContextAttribute("2")]
public static bool IsReferenceOrContainsReferences();
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareConstrainedRegions();
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareConstrainedRegionsNoOP();
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void PrepareContractedDelegate(Delegate d);
    public static void PrepareDelegate(Delegate d);
    public static void PrepareMethod(RuntimeMethodHandle method);
    [NullableContextAttribute("2")]
public static void PrepareMethod(RuntimeMethodHandle method, RuntimeTypeHandle[] instantiation);
    [ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public static void ProbeForSufficientStack();
    [RequiresUnreferencedCodeAttribute("Trimmer can't guarantee existence of class constructor")]
public static void RunClassConstructor(RuntimeTypeHandle type);
    public static void RunModuleConstructor(ModuleHandle module);
    public static bool TryEnsureSufficientExecutionStack();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.RuntimeWrappedException : Exception {
    public object WrappedException { get; }
    public RuntimeWrappedException(object thrownObject);
    public object get_WrappedException();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2048")]
internal class System.Runtime.CompilerServices.ScopedRefAttribute : Attribute {
}
[AttributeUsageAttribute("1774")]
public class System.Runtime.CompilerServices.SkipLocalsInitAttribute : Attribute {
}
[AttributeUsageAttribute("972")]
public class System.Runtime.CompilerServices.SpecialNameAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("64")]
public class System.Runtime.CompilerServices.StateMachineAttribute : Attribute {
    public Type StateMachineType { get; }
    public StateMachineAttribute(Type stateMachineType);
    public Type get_StateMachineType();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.StringFreezingAttribute : Attribute {
}
public class System.Runtime.CompilerServices.StrongBox`1 : object {
    [NullableAttribute("1")]
[MaybeNullAttribute]
public T Value;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.IStrongBox.Value { get; private set; }
    [NullableContextAttribute("1")]
public StrongBox`1(T value);
    private sealed virtual override object System.Runtime.CompilerServices.IStrongBox.get_Value();
    private sealed virtual override void System.Runtime.CompilerServices.IStrongBox.set_Value(object value);
}
[ObsoleteAttribute("SuppressIldasmAttribute has no effect in .NET 6.0+.")]
[AttributeUsageAttribute("3")]
public class System.Runtime.CompilerServices.SuppressIldasmAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.CompilerServices.SwitchExpressionException : InvalidOperationException {
    [NullableAttribute("1")]
public string Message { get; }
    public object UnmatchedValue { get; }
    public SwitchExpressionException(Exception innerException);
    public SwitchExpressionException(object unmatchedValue);
    public SwitchExpressionException(string message);
    public SwitchExpressionException(string message, Exception innerException);
    [NullableContextAttribute("1")]
public virtual string get_Message();
    public object get_UnmatchedValue();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.TaskAwaiter`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public TResult GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[AttributeUsageAttribute("11148")]
[CLSCompliantAttribute("False")]
public class System.Runtime.CompilerServices.TupleElementNamesAttribute : Attribute {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public IList`1<string> TransformNames { get; }
    public TupleElementNamesAttribute(String[] transformNames);
    public IList`1<string> get_TransformNames();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("5148")]
public class System.Runtime.CompilerServices.TypeForwardedFromAttribute : Attribute {
    public string AssemblyFullName { get; }
    public TypeForwardedFromAttribute(string assemblyFullName);
    public string get_AssemblyFullName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.CompilerServices.TypeForwardedToAttribute : Attribute {
    public Type Destination { get; }
    public TypeForwardedToAttribute(Type destination);
    public Type get_Destination();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.CompilerServices.Unsafe : object {
    public static T& AddByteOffset(T& source, IntPtr byteOffset);
    [CLSCompliantAttribute("False")]
public static T& AddByteOffset(T& source, UIntPtr byteOffset);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static Void* Add(Void* source, int elementOffset);
    public static T& Add(T& source, int elementOffset);
    public static T& Add(T& source, IntPtr elementOffset);
    [CLSCompliantAttribute("False")]
public static T& Add(T& source, UIntPtr elementOffset);
    public static bool AreSame(T& left, T& right);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static Void* AsPointer(T& value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static T& AsRef(Void* source);
    public static T& AsRef(T& source);
    [NullableContextAttribute("2")]
public static T As(object o);
    public static TTo& As(TFrom& source);
    public static IntPtr ByteOffset(T& origin, T& target);
    [CLSCompliantAttribute("False")]
public static void CopyBlock(Byte& destination, Byte& source, UInt32 byteCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void CopyBlock(Void* destination, Void* source, UInt32 byteCount);
    [CLSCompliantAttribute("False")]
public static void CopyBlockUnaligned(Byte& destination, Byte& source, UInt32 byteCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void CopyBlockUnaligned(Void* destination, Void* source, UInt32 byteCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void Copy(Void* destination, T& source);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void Copy(T& destination, Void* source);
    [CLSCompliantAttribute("False")]
public static void InitBlock(Byte& startAddress, byte value, UInt32 byteCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void InitBlock(Void* startAddress, byte value, UInt32 byteCount);
    [CLSCompliantAttribute("False")]
public static void InitBlockUnaligned(Byte& startAddress, byte value, UInt32 byteCount);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void InitBlockUnaligned(Void* startAddress, byte value, UInt32 byteCount);
    public static bool IsAddressGreaterThan(T& left, T& right);
    public static bool IsAddressLessThan(T& left, T& right);
    public static bool IsNullRef(T& source);
    public static T& NullRef();
    public static T ReadUnaligned(Byte& source);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static T ReadUnaligned(Void* source);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static T Read(Void* source);
    public static void SkipInit(T& value);
    [NullableContextAttribute("2")]
public static int SizeOf();
    public static T& SubtractByteOffset(T& source, IntPtr byteOffset);
    [CLSCompliantAttribute("False")]
public static T& SubtractByteOffset(T& source, UIntPtr byteOffset);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static Void* Subtract(Void* source, int elementOffset);
    public static T& Subtract(T& source, int elementOffset);
    public static T& Subtract(T& source, IntPtr elementOffset);
    [CLSCompliantAttribute("False")]
public static T& Subtract(T& source, UIntPtr elementOffset);
    [NullableContextAttribute("0")]
public static T& Unbox(object box);
    public static void WriteUnaligned(Byte& destination, T value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void WriteUnaligned(Void* destination, T value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public static void Write(Void* destination, T value);
}
[AttributeUsageAttribute("8")]
public class System.Runtime.CompilerServices.UnsafeValueTypeAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    public void GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.ValueTaskAwaiter`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCompleted { get; }
    public bool get_IsCompleted();
    [NullableContextAttribute("1")]
public TResult GetResult();
    [NullableContextAttribute("1")]
public sealed virtual void OnCompleted(Action continuation);
    [NullableContextAttribute("1")]
public sealed virtual void UnsafeOnCompleted(Action continuation);
}
[IsReadOnlyAttribute]
public class System.Runtime.CompilerServices.YieldAwaitable : ValueType {
    public YieldAwaiter GetAwaiter();
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public enum System.Runtime.ConstrainedExecution.Cer : Enum {
    public int value__;
    public static Cer None;
    public static Cer MayFail;
    public static Cer Success;
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
public enum System.Runtime.ConstrainedExecution.Consistency : Enum {
    public int value__;
    public static Consistency MayCorruptProcess;
    public static Consistency MayCorruptAppDomain;
    public static Consistency MayCorruptInstance;
    public static Consistency WillNotCorruptState;
}
public abstract class System.Runtime.ConstrainedExecution.CriticalFinalizerObject : object {
    protected virtual override void Finalize();
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
[AttributeUsageAttribute("96")]
public class System.Runtime.ConstrainedExecution.PrePrepareMethodAttribute : Attribute {
}
[ObsoleteAttribute("The Constrained Execution Region (CER) feature is not supported.")]
[AttributeUsageAttribute("1133")]
public class System.Runtime.ConstrainedExecution.ReliabilityContractAttribute : Attribute {
    public Cer Cer { get; }
    public Consistency ConsistencyGuarantee { get; }
    public ReliabilityContractAttribute(Consistency consistencyGuarantee, Cer cer);
    public Cer get_Cer();
    public Consistency get_ConsistencyGuarantee();
}
public static class System.Runtime.ControlledExecution : object {
    [NullableContextAttribute("1")]
[ObsoleteAttribute("ControlledExecution.Run method may corrupt the process and should not be used in production code.")]
public static void Run(Action action, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.DependentHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public object Dependent { get; public set; }
    public bool IsAllocated { get; }
    public object Target { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueTuple`2<object, object> TargetAndDependent { get; }
    public DependentHandle(object target, object dependent);
    public object get_Dependent();
    public void set_Dependent(object value);
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public ValueTuple`2<object, object> get_TargetAndDependent();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.ExceptionDispatchInfo : object {
    public Exception SourceException { get; }
    public Exception get_SourceException();
    public static ExceptionDispatchInfo Capture(Exception source);
    public static Exception SetCurrentStackTrace(Exception source);
    public static Exception SetRemoteStackTrace(Exception source, string stackTrace);
    [DoesNotReturnAttribute]
public void Throw();
    [DoesNotReturnAttribute]
public static void Throw(Exception source);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.ExceptionServices.FirstChanceExceptionEventArgs : EventArgs {
    public Exception Exception { get; }
    public FirstChanceExceptionEventArgs(Exception exception);
    public Exception get_Exception();
}
[AttributeUsageAttribute("64")]
[ObsoleteAttribute("Recovery from corrupted process state exceptions is not supported; HandleProcessCorruptedStateExceptionsAttribute is ignored.")]
public class System.Runtime.ExceptionServices.HandleProcessCorruptedStateExceptionsAttribute : Attribute {
}
public enum System.Runtime.GCLargeObjectHeapCompactionMode : Enum {
    public int value__;
    public static GCLargeObjectHeapCompactionMode Default;
    public static GCLargeObjectHeapCompactionMode CompactOnce;
}
public enum System.Runtime.GCLatencyMode : Enum {
    public int value__;
    public static GCLatencyMode Batch;
    public static GCLatencyMode Interactive;
    public static GCLatencyMode LowLatency;
    public static GCLatencyMode SustainedLowLatency;
    public static GCLatencyMode NoGCRegion;
}
public static class System.Runtime.GCSettings : object {
    public static bool IsServerGC { get; }
    public static GCLargeObjectHeapCompactionMode LargeObjectHeapCompactionMode { get; public set; }
    public static GCLatencyMode LatencyMode { get; public set; }
    public static bool get_IsServerGC();
    public static GCLargeObjectHeapCompactionMode get_LargeObjectHeapCompactionMode();
    public static void set_LargeObjectHeapCompactionMode(GCLargeObjectHeapCompactionMode value);
    public static GCLatencyMode get_LatencyMode();
    public static void set_LatencyMode(GCLatencyMode value);
}
public enum System.Runtime.InteropServices.Architecture : Enum {
    public int value__;
    public static Architecture X86;
    public static Architecture X64;
    public static Architecture Arm;
    public static Architecture Arm64;
    public static Architecture Wasm;
    public static Architecture S390x;
    public static Architecture LoongArch64;
    public static Architecture Armv6;
    public static Architecture Ppc64le;
}
public enum System.Runtime.InteropServices.CharSet : Enum {
    public int value__;
    public static CharSet None;
    public static CharSet Ansi;
    public static CharSet Unicode;
    public static CharSet Auto;
}
[AttributeUsageAttribute("5597")]
public class System.Runtime.InteropServices.ComVisibleAttribute : Attribute {
    public bool Value { get; }
    public ComVisibleAttribute(bool visibility);
    public bool get_Value();
}
public abstract class System.Runtime.InteropServices.CriticalHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected CriticalHandle(IntPtr invalidHandleValue);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    public void SetHandleAsInvalid();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.ExternalException : SystemException {
    public int ErrorCode { get; }
    [NullableContextAttribute("1")]
protected ExternalException(SerializationInfo info, StreamingContext context);
    public ExternalException(string message);
    public ExternalException(string message, Exception inner);
    public ExternalException(string message, int errorCode);
    public virtual int get_ErrorCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("256")]
public class System.Runtime.InteropServices.FieldOffsetAttribute : Attribute {
    public int Value { get; }
    public FieldOffsetAttribute(int offset);
    public int get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.InteropServices.GCHandle : ValueType {
    private int _dummyPrimitive;
    public bool IsAllocated { get; }
    public object Target { get; public set; }
    public bool get_IsAllocated();
    public object get_Target();
    public void set_Target(object value);
    public IntPtr AddrOfPinnedObject();
    public static GCHandle Alloc(object value);
    public static GCHandle Alloc(object value, GCHandleType type);
    public virtual bool Equals(object o);
    public sealed virtual bool Equals(GCHandle other);
    public void Free();
    public static GCHandle FromIntPtr(IntPtr value);
    public virtual int GetHashCode();
    public static bool op_Equality(GCHandle a, GCHandle b);
    public static GCHandle op_Explicit(IntPtr value);
    public static IntPtr op_Explicit(GCHandle value);
    public static bool op_Inequality(GCHandle a, GCHandle b);
    public static IntPtr ToIntPtr(GCHandle value);
}
public enum System.Runtime.InteropServices.GCHandleType : Enum {
    public int value__;
    public static GCHandleType Weak;
    public static GCHandleType WeakTrackResurrection;
    public static GCHandleType Normal;
    public static GCHandleType Pinned;
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.InAttribute : Attribute {
}
public enum System.Runtime.InteropServices.LayoutKind : Enum {
    public int value__;
    public static LayoutKind Sequential;
    public static LayoutKind Explicit;
    public static LayoutKind Auto;
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.Marshalling.ContiguousCollectionMarshallerAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.Marshalling.CustomMarshallerAttribute : Attribute {
    public Type ManagedType { get; }
    public MarshalMode MarshalMode { get; }
    public Type MarshallerType { get; }
    public CustomMarshallerAttribute(Type managedType, MarshalMode marshalMode, Type marshallerType);
    public Type get_ManagedType();
    public MarshalMode get_MarshalMode();
    public Type get_MarshallerType();
}
public enum System.Runtime.InteropServices.Marshalling.MarshalMode : Enum {
    public int value__;
    public static MarshalMode Default;
    public static MarshalMode ManagedToUnmanagedIn;
    public static MarshalMode ManagedToUnmanagedRef;
    public static MarshalMode ManagedToUnmanagedOut;
    public static MarshalMode UnmanagedToManagedIn;
    public static MarshalMode UnmanagedToManagedRef;
    public static MarshalMode UnmanagedToManagedOut;
    public static MarshalMode ElementIn;
    public static MarshalMode ElementRef;
    public static MarshalMode ElementOut;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4124")]
public class System.Runtime.InteropServices.Marshalling.NativeMarshallingAttribute : Attribute {
    public Type NativeType { get; }
    public NativeMarshallingAttribute(Type nativeType);
    public Type get_NativeType();
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.ReadOnlySpan`1", "1", "System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2/ManagedToUnmanagedIn")]
[CustomMarshallerAttribute("System.ReadOnlySpan`1", "6", "System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2/UnmanagedToManagedOut")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.ReadOnlySpanMarshaller`2 : object {
}
[CLSCompliantAttribute("False")]
[CustomMarshallerAttribute("System.Span`1", "0", "System.Runtime.InteropServices.Marshalling.SpanMarshaller`2")]
[CustomMarshallerAttribute("System.Span`1", "1", "System.Runtime.InteropServices.Marshalling.SpanMarshaller`2/ManagedToUnmanagedIn")]
[ContiguousCollectionMarshallerAttribute]
public static class System.Runtime.InteropServices.Marshalling.SpanMarshaller`2 : object {
    public static TUnmanagedElement* AllocateContainerForUnmanagedElements(Span`1<T> managed, Int32& numElements);
    public static ReadOnlySpan`1<T> GetManagedValuesSource(Span`1<T> managed);
    public static Span`1<TUnmanagedElement> GetUnmanagedValuesDestination(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<T> AllocateContainerForManagedElements(TUnmanagedElement* unmanaged, int numElements);
    public static Span`1<T> GetManagedValuesDestination(Span`1<T> managed);
    public static ReadOnlySpan`1<TUnmanagedElement> GetUnmanagedValuesSource(TUnmanagedElement* unmanaged, int numElements);
    public static void Free(TUnmanagedElement* unmanaged);
}
[IsReadOnlyAttribute]
public class System.Runtime.InteropServices.OSPlatform : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static OSPlatform FreeBSD { get; }
    public static OSPlatform Linux { get; }
    public static OSPlatform OSX { get; }
    public static OSPlatform Windows { get; }
    public static OSPlatform get_FreeBSD();
    public static OSPlatform get_Linux();
    public static OSPlatform get_OSX();
    public static OSPlatform get_Windows();
    [NullableContextAttribute("1")]
public static OSPlatform Create(string osPlatform);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(OSPlatform other);
    public virtual int GetHashCode();
    public static bool op_Equality(OSPlatform left, OSPlatform right);
    public static bool op_Inequality(OSPlatform left, OSPlatform right);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("2048")]
public class System.Runtime.InteropServices.OutAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Runtime.InteropServices.RuntimeInformation : object {
    public static string FrameworkDescription { get; }
    public static Architecture OSArchitecture { get; }
    public static string OSDescription { get; }
    public static Architecture ProcessArchitecture { get; }
    public static string RuntimeIdentifier { get; }
    public static string get_FrameworkDescription();
    public static Architecture get_OSArchitecture();
    public static string get_OSDescription();
    public static Architecture get_ProcessArchitecture();
    public static string get_RuntimeIdentifier();
    public static bool IsOSPlatform(OSPlatform osPlatform);
}
public abstract class System.Runtime.InteropServices.SafeBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    [CLSCompliantAttribute("False")]
public ulong ByteLength { get; }
    protected SafeBuffer(bool ownsHandle);
    public ulong get_ByteLength();
    [CLSCompliantAttribute("False")]
public void AcquirePointer(Byte*& pointer);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements, UInt32 sizeOfEachElement);
    [CLSCompliantAttribute("False")]
public void Initialize(ulong numBytes);
    [CLSCompliantAttribute("False")]
public void Initialize(UInt32 numElements);
    [CLSCompliantAttribute("False")]
public void ReadArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void ReadSpan(ulong byteOffset, Span`1<T> buffer);
    [CLSCompliantAttribute("False")]
public T Read(ulong byteOffset);
    public void ReleasePointer();
    [CLSCompliantAttribute("False")]
public void WriteArray(ulong byteOffset, T[] array, int index, int count);
    [CLSCompliantAttribute("False")]
public void WriteSpan(ulong byteOffset, ReadOnlySpan`1<T> data);
    [CLSCompliantAttribute("False")]
public void Write(ulong byteOffset, T value);
}
public abstract class System.Runtime.InteropServices.SafeHandle : CriticalFinalizerObject {
    protected IntPtr handle;
    public bool IsClosed { get; }
    public bool IsInvalid { get; }
    protected SafeHandle(IntPtr invalidHandleValue, bool ownsHandle);
    public bool get_IsClosed();
    public abstract virtual bool get_IsInvalid();
    public void Close();
    public void DangerousAddRef(Boolean& success);
    public IntPtr DangerousGetHandle();
    public void DangerousRelease();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    protected abstract virtual bool ReleaseHandle();
    protected void SetHandle(IntPtr handle);
    public void SetHandleAsInvalid();
}
[AttributeUsageAttribute("12")]
public class System.Runtime.InteropServices.StructLayoutAttribute : Attribute {
    public CharSet CharSet;
    public int Pack;
    public int Size;
    public LayoutKind Value { get; }
    public StructLayoutAttribute(short layoutKind);
    public StructLayoutAttribute(LayoutKind layoutKind);
    public LayoutKind get_Value();
}
[AttributeUsageAttribute("64")]
public class System.Runtime.InteropServices.SuppressGCTransitionAttribute : Attribute {
}
public enum System.Runtime.InteropServices.UnmanagedType : Enum {
    public int value__;
    public static UnmanagedType Bool;
    public static UnmanagedType I1;
    public static UnmanagedType U1;
    public static UnmanagedType I2;
    public static UnmanagedType U2;
    public static UnmanagedType I4;
    public static UnmanagedType U4;
    public static UnmanagedType I8;
    public static UnmanagedType U8;
    public static UnmanagedType R4;
    public static UnmanagedType R8;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as Currency may be unavailable in future releases.")]
public static UnmanagedType Currency;
    public static UnmanagedType BStr;
    public static UnmanagedType LPStr;
    public static UnmanagedType LPWStr;
    public static UnmanagedType LPTStr;
    public static UnmanagedType ByValTStr;
    public static UnmanagedType IUnknown;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType IDispatch;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType Struct;
    public static UnmanagedType Interface;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType SafeArray;
    public static UnmanagedType ByValArray;
    public static UnmanagedType SysInt;
    public static UnmanagedType SysUInt;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as VBByRefString may be unavailable in future releases.")]
public static UnmanagedType VBByRefStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as AnsiBStr may be unavailable in future releases.")]
public static UnmanagedType AnsiBStr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling as TBstr may be unavailable in future releases.")]
public static UnmanagedType TBStr;
    [EditorBrowsableAttribute("1")]
public static UnmanagedType VariantBool;
    public static UnmanagedType FunctionPtr;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Marshalling arbitrary types may be unavailable in future releases. Specify the type you wish to marshal as.")]
public static UnmanagedType AsAny;
    public static UnmanagedType LPArray;
    public static UnmanagedType LPStruct;
    public static UnmanagedType CustomMarshaler;
    public static UnmanagedType Error;
    public static UnmanagedType IInspectable;
    public static UnmanagedType HString;
    public static UnmanagedType LPUTF8Str;
}
public static class System.Runtime.JitInfo : object {
    public static TimeSpan GetCompilationTime(bool currentThread);
    public static long GetCompiledILBytes(bool currentThread);
    public static long GetCompiledMethodCount(bool currentThread);
}
public class System.Runtime.MemoryFailPoint : CriticalFinalizerObject {
    public MemoryFailPoint(int sizeInMegabytes);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
public static class System.Runtime.ProfileOptimization : object {
    [NullableContextAttribute("1")]
public static void SetProfileRoot(string directoryPath);
    [NullableContextAttribute("2")]
public static void StartProfile(string profile);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Remoting.ObjectHandle : MarshalByRefObject {
    public ObjectHandle(object o);
    public object Unwrap();
}
[NullableContextAttribute("2")]
public interface System.Runtime.Serialization.IDeserializationCallback {
    public abstract virtual void OnDeserialization(object sender);
}
[NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public interface System.Runtime.Serialization.IFormatterConverter {
    public abstract virtual object Convert(object value, Type type);
    public abstract virtual object Convert(object value, TypeCode typeCode);
    public abstract virtual bool ToBoolean(object value);
    public abstract virtual byte ToByte(object value);
    public abstract virtual char ToChar(object value);
    public abstract virtual DateTime ToDateTime(object value);
    public abstract virtual decimal ToDecimal(object value);
    public abstract virtual double ToDouble(object value);
    public abstract virtual short ToInt16(object value);
    public abstract virtual int ToInt32(object value);
    public abstract virtual long ToInt64(object value);
    public abstract virtual sbyte ToSByte(object value);
    public abstract virtual float ToSingle(object value);
    public abstract virtual string ToString(object value);
    public abstract virtual ushort ToUInt16(object value);
    public abstract virtual UInt32 ToUInt32(object value);
    public abstract virtual ulong ToUInt64(object value);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.IObjectReference {
    public abstract virtual object GetRealObject(StreamingContext context);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.ISafeSerializationData {
    public abstract virtual void CompleteDeserialization(object deserialized);
}
[NullableContextAttribute("1")]
public interface System.Runtime.Serialization.ISerializable {
    public abstract virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnDeserializingAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializedAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
public class System.Runtime.Serialization.OnSerializingAttribute : Attribute {
}
[AttributeUsageAttribute("256")]
public class System.Runtime.Serialization.OptionalFieldAttribute : Attribute {
    public int VersionAdded { get; public set; }
    public int get_VersionAdded();
    public void set_VersionAdded(int value);
}
public class System.Runtime.Serialization.SafeSerializationEventArgs : EventArgs {
    public StreamingContext StreamingContext { get; }
    public StreamingContext get_StreamingContext();
    [NullableContextAttribute("1")]
public void AddSerializedState(ISafeSerializationData serializedState);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.SerializationEntry : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public string Name { get; }
    public Type ObjectType { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public string get_Name();
    public Type get_ObjectType();
    [NullableContextAttribute("2")]
public object get_Value();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.SerializationException : SystemException {
    [NullableContextAttribute("1")]
protected SerializationException(SerializationInfo info, StreamingContext context);
    public SerializationException(string message);
    public SerializationException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.SerializationInfo : object {
    public string AssemblyName { get; public set; }
    public string FullTypeName { get; public set; }
    public bool IsAssemblyNameSetExplicit { get; }
    public bool IsFullTypeNameSetExplicit { get; }
    public int MemberCount { get; }
    public Type ObjectType { get; }
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter);
    [CLSCompliantAttribute("False")]
public SerializationInfo(Type type, IFormatterConverter converter, bool requireSameTokenInPartialTrust);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_FullTypeName();
    public void set_FullTypeName(string value);
    public bool get_IsAssemblyNameSetExplicit();
    public bool get_IsFullTypeNameSetExplicit();
    public int get_MemberCount();
    public Type get_ObjectType();
    public void AddValue(string name, bool value);
    public void AddValue(string name, byte value);
    public void AddValue(string name, char value);
    public void AddValue(string name, DateTime value);
    public void AddValue(string name, decimal value);
    public void AddValue(string name, double value);
    public void AddValue(string name, short value);
    public void AddValue(string name, int value);
    public void AddValue(string name, long value);
    public void AddValue(string name, object value);
    public void AddValue(string name, object value, Type type);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, sbyte value);
    public void AddValue(string name, float value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ushort value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, UInt32 value);
    [CLSCompliantAttribute("False")]
public void AddValue(string name, ulong value);
    public bool GetBoolean(string name);
    public byte GetByte(string name);
    public char GetChar(string name);
    public DateTime GetDateTime(string name);
    public decimal GetDecimal(string name);
    public double GetDouble(string name);
    public SerializationInfoEnumerator GetEnumerator();
    public short GetInt16(string name);
    public int GetInt32(string name);
    public long GetInt64(string name);
    [CLSCompliantAttribute("False")]
public sbyte GetSByte(string name);
    public float GetSingle(string name);
    public string GetString(string name);
    [CLSCompliantAttribute("False")]
public ushort GetUInt16(string name);
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32(string name);
    [CLSCompliantAttribute("False")]
public ulong GetUInt64(string name);
    public object GetValue(string name, Type type);
    public void SetType(Type type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Serialization.SerializationInfoEnumerator : object {
    public SerializationEntry Current { get; }
    public string Name { get; }
    public Type ObjectType { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    [NullableAttribute("2")]
public object Value { get; }
    public SerializationEntry get_Current();
    public string get_Name();
    public Type get_ObjectType();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [NullableContextAttribute("2")]
public object get_Value();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Runtime.Serialization.StreamingContext : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public object Context { get; }
    public StreamingContextStates State { get; }
    public StreamingContext(StreamingContextStates state);
    public StreamingContext(StreamingContextStates state, object additional);
    public object get_Context();
    public StreamingContextStates get_State();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[FlagsAttribute]
public enum System.Runtime.Serialization.StreamingContextStates : Enum {
    public int value__;
    public static StreamingContextStates CrossProcess;
    public static StreamingContextStates CrossMachine;
    public static StreamingContextStates File;
    public static StreamingContextStates Persistence;
    public static StreamingContextStates Remoting;
    public static StreamingContextStates Other;
    public static StreamingContextStates Clone;
    public static StreamingContextStates CrossAppDomain;
    public static StreamingContextStates All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("96")]
public class System.Runtime.TargetedPatchingOptOutAttribute : Attribute {
    public string Reason { get; }
    public TargetedPatchingOptOutAttribute(string reason);
    public string get_Reason();
}
[AttributeUsageAttribute("5887")]
public class System.Runtime.Versioning.ComponentGuaranteesAttribute : Attribute {
    public ComponentGuaranteesOptions Guarantees { get; }
    public ComponentGuaranteesAttribute(ComponentGuaranteesOptions guarantees);
    public ComponentGuaranteesOptions get_Guarantees();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ComponentGuaranteesOptions : Enum {
    public int value__;
    public static ComponentGuaranteesOptions None;
    public static ComponentGuaranteesOptions Exchange;
    public static ComponentGuaranteesOptions Stable;
    public static ComponentGuaranteesOptions SideBySide;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Runtime.Versioning.FrameworkName : object {
    public string FullName { get; }
    public string Identifier { get; }
    public string Profile { get; }
    public Version Version { get; }
    public FrameworkName(string frameworkName);
    public FrameworkName(string identifier, Version version);
    public FrameworkName(string identifier, Version version, string profile);
    public string get_FullName();
    public string get_Identifier();
    public string get_Profile();
    public Version get_Version();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(FrameworkName other);
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public static bool op_Equality(FrameworkName left, FrameworkName right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(FrameworkName left, FrameworkName right);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.ObsoletedOSPlatformAttribute : OSPlatformAttribute {
    public string Message { get; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName);
    [NullableContextAttribute("1")]
public ObsoletedOSPlatformAttribute(string platformName, string message);
    public string get_Message();
    public string get_Url();
    public void set_Url(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Runtime.Versioning.OSPlatformAttribute : Attribute {
    public string PlatformName { get; }
    private protected OSPlatformAttribute(string platformName);
    public string get_PlatformName();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("6143")]
public class System.Runtime.Versioning.RequiresPreviewFeaturesAttribute : Attribute {
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresPreviewFeaturesAttribute(string message);
    public string get_Message();
    public string get_Url();
    public void set_Url(string value);
}
[AttributeUsageAttribute("224")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceConsumptionAttribute : Attribute {
    public ResourceScope ConsumptionScope { get; }
    public ResourceScope ResourceScope { get; }
    public ResourceConsumptionAttribute(ResourceScope resourceScope);
    public ResourceConsumptionAttribute(ResourceScope resourceScope, ResourceScope consumptionScope);
    public ResourceScope get_ConsumptionScope();
    public ResourceScope get_ResourceScope();
}
[AttributeUsageAttribute("480")]
[ConditionalAttribute("RESOURCE_ANNOTATION_WORK")]
public class System.Runtime.Versioning.ResourceExposureAttribute : Attribute {
    public ResourceScope ResourceExposureLevel { get; }
    public ResourceExposureAttribute(ResourceScope exposureLevel);
    public ResourceScope get_ResourceExposureLevel();
}
[FlagsAttribute]
public enum System.Runtime.Versioning.ResourceScope : Enum {
    public int value__;
    public static ResourceScope None;
    public static ResourceScope Machine;
    public static ResourceScope Process;
    public static ResourceScope AppDomain;
    public static ResourceScope Library;
    public static ResourceScope Private;
    public static ResourceScope Assembly;
}
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.SupportedOSPlatformAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public SupportedOSPlatformAttribute(string platformName);
}
[AttributeUsageAttribute("448")]
public class System.Runtime.Versioning.SupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public SupportedOSPlatformGuardAttribute(string platformName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetFrameworkAttribute : Attribute {
    [NullableAttribute("2")]
public string FrameworkDisplayName { get; public set; }
    public string FrameworkName { get; }
    public TargetFrameworkAttribute(string frameworkName);
    [NullableContextAttribute("2")]
public string get_FrameworkDisplayName();
    [NullableContextAttribute("2")]
public void set_FrameworkDisplayName(string value);
    public string get_FrameworkName();
}
[AttributeUsageAttribute("1")]
public class System.Runtime.Versioning.TargetPlatformAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public TargetPlatformAttribute(string platformName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("2047")]
public class System.Runtime.Versioning.UnsupportedOSPlatformAttribute : OSPlatformAttribute {
    [NullableAttribute("2")]
public string Message { get; }
    public UnsupportedOSPlatformAttribute(string platformName);
    public UnsupportedOSPlatformAttribute(string platformName, string message);
    [NullableContextAttribute("2")]
public string get_Message();
}
[AttributeUsageAttribute("448")]
public class System.Runtime.Versioning.UnsupportedOSPlatformGuardAttribute : OSPlatformAttribute {
    [NullableContextAttribute("1")]
public UnsupportedOSPlatformGuardAttribute(string platformName);
}
public static class System.Runtime.Versioning.VersioningHelper : object {
    [NullableContextAttribute("1")]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to);
    [NullableContextAttribute("2")]
public static string MakeVersionSafeName(string name, ResourceScope from, ResourceScope to, Type type);
}
[IsByRefLikeAttribute]
public class System.RuntimeArgumentHandle : ValueType {
    private int _dummyPrimitive;
}
public class System.RuntimeFieldHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeFieldHandle handle);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static RuntimeFieldHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeFieldHandle value);
    public static bool op_Equality(RuntimeFieldHandle left, RuntimeFieldHandle right);
    public static bool op_Inequality(RuntimeFieldHandle left, RuntimeFieldHandle right);
}
public class System.RuntimeMethodHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeMethodHandle handle);
    public IntPtr GetFunctionPointer();
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static RuntimeMethodHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeMethodHandle value);
    public static bool op_Equality(RuntimeMethodHandle left, RuntimeMethodHandle right);
    public static bool op_Inequality(RuntimeMethodHandle left, RuntimeMethodHandle right);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.RuntimeTypeHandle : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public IntPtr Value { get; }
    public IntPtr get_Value();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(RuntimeTypeHandle handle);
    public virtual int GetHashCode();
    public ModuleHandle GetModuleHandle();
    [NullableContextAttribute("1")]
public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static RuntimeTypeHandle FromIntPtr(IntPtr value);
    public static IntPtr ToIntPtr(RuntimeTypeHandle value);
    public static bool op_Equality(object left, RuntimeTypeHandle right);
    public static bool op_Equality(RuntimeTypeHandle left, object right);
    public static bool op_Inequality(object left, RuntimeTypeHandle right);
    public static bool op_Inequality(RuntimeTypeHandle left, object right);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.SByte : ValueType {
    private sbyte _dummyPrimitive;
    public static sbyte MaxValue;
    public static sbyte MinValue;
    private static sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.AdditiveIdentity { get; }
    private static sbyte System.Numerics.IBinaryNumber<System.SByte>.AllBitsSet { get; }
    private static sbyte System.Numerics.IMinMaxValue<System.SByte>.MaxValue { get; }
    private static sbyte System.Numerics.IMinMaxValue<System.SByte>.MinValue { get; }
    private static sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.MultiplicativeIdentity { get; }
    private static sbyte System.Numerics.INumberBase<System.SByte>.One { get; }
    private static int System.Numerics.INumberBase<System.SByte>.Radix { get; }
    private static sbyte System.Numerics.INumberBase<System.SByte>.Zero { get; }
    private static sbyte System.Numerics.ISignedNumber<System.SByte>.NegativeOne { get; }
    private static override sbyte System.Numerics.IAdditiveIdentity<System.SByte,System.SByte>.get_AdditiveIdentity();
    private static override sbyte System.Numerics.IBinaryNumber<System.SByte>.get_AllBitsSet();
    private static override sbyte System.Numerics.IMinMaxValue<System.SByte>.get_MaxValue();
    private static override sbyte System.Numerics.IMinMaxValue<System.SByte>.get_MinValue();
    private static override sbyte System.Numerics.IMultiplicativeIdentity<System.SByte,System.SByte>.get_MultiplicativeIdentity();
    private static override sbyte System.Numerics.INumberBase<System.SByte>.get_One();
    private static override int System.Numerics.INumberBase<System.SByte>.get_Radix();
    private static override sbyte System.Numerics.INumberBase<System.SByte>.get_Zero();
    private static override sbyte System.Numerics.ISignedNumber<System.SByte>.get_NegativeOne();
    public static override sbyte Abs(sbyte value);
    public static override sbyte Clamp(sbyte value, sbyte min, sbyte max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object obj);
    public sealed virtual int CompareTo(sbyte value);
    public static override sbyte CopySign(sbyte value, sbyte sign);
    [NullableContextAttribute("1")]
public static override sbyte CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override sbyte CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override sbyte CreateTruncating(TOther value);
    public static override ValueTuple`2<sbyte, sbyte> DivRem(sbyte left, sbyte right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(sbyte obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(sbyte value);
    public static override bool IsNegative(sbyte value);
    public static override bool IsOddInteger(sbyte value);
    public static override bool IsPositive(sbyte value);
    public static override bool IsPow2(sbyte value);
    public static override sbyte LeadingZeroCount(sbyte value);
    public static override sbyte Log2(sbyte value);
    public static override sbyte Max(sbyte x, sbyte y);
    public static override sbyte MaxMagnitude(sbyte x, sbyte y);
    public static override sbyte Min(sbyte x, sbyte y);
    public static override sbyte MinMagnitude(sbyte x, sbyte y);
    public static override sbyte Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override sbyte Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static sbyte Parse(string s);
    [NullableContextAttribute("1")]
public static sbyte Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override sbyte Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override sbyte Parse(string s, IFormatProvider provider);
    public static override sbyte PopCount(sbyte value);
    public static override sbyte RotateLeft(sbyte value, int rotateAmount);
    public static override sbyte RotateRight(sbyte value, int rotateAmount);
    public static override int Sign(sbyte value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override sbyte System.Numerics.IAdditionOperators<System.SByte,System.SByte,System.SByte>.op_Addition(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IAdditionOperators<System.SByte,System.SByte,System.SByte>.op_CheckedAddition(sbyte left, sbyte right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.SByte>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.SByte>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.SByte>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, SByte& value);
    private static override bool System.Numerics.IBinaryInteger<System.SByte>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, SByte& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.SByte>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_BitwiseAnd(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_BitwiseOr(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_ExclusiveOr(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IBitwiseOperators<System.SByte,System.SByte,System.SByte>.op_OnesComplement(sbyte value);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_GreaterThan(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_GreaterThanOrEqual(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_LessThan(sbyte left, sbyte right);
    private static override bool System.Numerics.IComparisonOperators<System.SByte,System.SByte,System.Boolean>.op_LessThanOrEqual(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IDecrementOperators<System.SByte>.op_CheckedDecrement(sbyte value);
    private static override sbyte System.Numerics.IDecrementOperators<System.SByte>.op_Decrement(sbyte value);
    private static override sbyte System.Numerics.IDivisionOperators<System.SByte,System.SByte,System.SByte>.op_Division(sbyte left, sbyte right);
    private static override bool System.Numerics.IEqualityOperators<System.SByte,System.SByte,System.Boolean>.op_Equality(sbyte left, sbyte right);
    private static override bool System.Numerics.IEqualityOperators<System.SByte,System.SByte,System.Boolean>.op_Inequality(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IIncrementOperators<System.SByte>.op_CheckedIncrement(sbyte value);
    private static override sbyte System.Numerics.IIncrementOperators<System.SByte>.op_Increment(sbyte value);
    private static override sbyte System.Numerics.IModulusOperators<System.SByte,System.SByte,System.SByte>.op_Modulus(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IMultiplyOperators<System.SByte,System.SByte,System.SByte>.op_CheckedMultiply(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IMultiplyOperators<System.SByte,System.SByte,System.SByte>.op_Multiply(sbyte left, sbyte right);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsCanonical(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsComplexNumber(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsFinite(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsImaginaryNumber(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsInteger(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNaN(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNegativeInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsNormal(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsPositiveInfinity(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsRealNumber(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsSubnormal(sbyte value);
    private static override bool System.Numerics.INumberBase<System.SByte>.IsZero(sbyte value);
    private static override sbyte System.Numerics.INumberBase<System.SByte>.MaxMagnitudeNumber(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumberBase<System.SByte>.MinMagnitudeNumber(sbyte x, sbyte y);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromChecked(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromSaturating(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertFromTruncating(TOther value, SByte& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToChecked(sbyte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToSaturating(sbyte value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.SByte>.TryConvertToTruncating(sbyte value, TOther& result);
    private static override sbyte System.Numerics.INumber<System.SByte>.MaxNumber(sbyte x, sbyte y);
    private static override sbyte System.Numerics.INumber<System.SByte>.MinNumber(sbyte x, sbyte y);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_LeftShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_RightShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.IShiftOperators<System.SByte,System.Int32,System.SByte>.op_UnsignedRightShift(sbyte value, int shiftAmount);
    private static override sbyte System.Numerics.ISubtractionOperators<System.SByte,System.SByte,System.SByte>.op_CheckedSubtraction(sbyte left, sbyte right);
    private static override sbyte System.Numerics.ISubtractionOperators<System.SByte,System.SByte,System.SByte>.op_Subtraction(sbyte left, sbyte right);
    private static override sbyte System.Numerics.IUnaryNegationOperators<System.SByte,System.SByte>.op_CheckedUnaryNegation(sbyte value);
    private static override sbyte System.Numerics.IUnaryNegationOperators<System.SByte,System.SByte>.op_UnaryNegation(sbyte value);
    private static override sbyte System.Numerics.IUnaryPlusOperators<System.SByte,System.SByte>.op_UnaryPlus(sbyte value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override sbyte TrailingZeroCount(sbyte value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, SByte& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, SByte& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, SByte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, SByte& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, SByte& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, SByte& result);
}
[AttributeUsageAttribute("1")]
public class System.Security.AllowPartiallyTrustedCallersAttribute : Attribute {
    public PartialTrustVisibilityLevel PartialTrustVisibilityLevel { get; public set; }
    public PartialTrustVisibilityLevel get_PartialTrustVisibilityLevel();
    public void set_PartialTrustVisibilityLevel(PartialTrustVisibilityLevel value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Security.Cryptography.CryptographicException : SystemException {
    public CryptographicException(int hr);
    protected CryptographicException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public CryptographicException(string message);
    [NullableContextAttribute("2")]
public CryptographicException(string message, Exception inner);
    public CryptographicException(string format, string insert);
}
[NullableContextAttribute("2")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public interface System.Security.IPermission {
    [NullableContextAttribute("1")]
public abstract virtual IPermission Copy();
    public abstract virtual void Demand();
    public abstract virtual IPermission Intersect(IPermission target);
    public abstract virtual bool IsSubsetOf(IPermission target);
    public abstract virtual IPermission Union(IPermission target);
}
[NullableContextAttribute("1")]
public interface System.Security.ISecurityEncodable {
    public abstract virtual void FromXml(SecurityElement e);
    [NullableContextAttribute("2")]
public abstract virtual SecurityElement ToXml();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public interface System.Security.IStackWalk {
    public abstract virtual void Assert();
    public abstract virtual void Demand();
    public abstract virtual void Deny();
    public abstract virtual void PermitOnly();
}
public enum System.Security.PartialTrustVisibilityLevel : Enum {
    public int value__;
    public static PartialTrustVisibilityLevel VisibleToAllHosts;
    public static PartialTrustVisibilityLevel NotVisibleByDefault;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.CodeAccessSecurityAttribute : SecurityAttribute {
    protected CodeAccessSecurityAttribute(SecurityAction action);
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public enum System.Security.Permissions.PermissionState : Enum {
    public int value__;
    public static PermissionState None;
    public static PermissionState Unrestricted;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public enum System.Security.Permissions.SecurityAction : Enum {
    public int value__;
    public static SecurityAction Demand;
    public static SecurityAction Assert;
    public static SecurityAction Deny;
    public static SecurityAction PermitOnly;
    public static SecurityAction LinkDemand;
    public static SecurityAction InheritanceDemand;
    public static SecurityAction RequestMinimum;
    public static SecurityAction RequestOptional;
    public static SecurityAction RequestRefuse;
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public abstract class System.Security.Permissions.SecurityAttribute : Attribute {
    public SecurityAction Action { get; public set; }
    public bool Unrestricted { get; public set; }
    protected SecurityAttribute(SecurityAction action);
    public SecurityAction get_Action();
    public void set_Action(SecurityAction value);
    public bool get_Unrestricted();
    public void set_Unrestricted(bool value);
    [NullableContextAttribute("2")]
public abstract virtual IPermission CreatePermission();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[AttributeUsageAttribute("109")]
public class System.Security.Permissions.SecurityPermissionAttribute : CodeAccessSecurityAttribute {
    public bool Assertion { get; public set; }
    public bool BindingRedirects { get; public set; }
    public bool ControlAppDomain { get; public set; }
    public bool ControlDomainPolicy { get; public set; }
    public bool ControlEvidence { get; public set; }
    public bool ControlPolicy { get; public set; }
    public bool ControlPrincipal { get; public set; }
    public bool ControlThread { get; public set; }
    public bool Execution { get; public set; }
    public SecurityPermissionFlag Flags { get; public set; }
    public bool Infrastructure { get; public set; }
    public bool RemotingConfiguration { get; public set; }
    public bool SerializationFormatter { get; public set; }
    public bool SkipVerification { get; public set; }
    public bool UnmanagedCode { get; public set; }
    public SecurityPermissionAttribute(SecurityAction action);
    public bool get_Assertion();
    public void set_Assertion(bool value);
    public bool get_BindingRedirects();
    public void set_BindingRedirects(bool value);
    public bool get_ControlAppDomain();
    public void set_ControlAppDomain(bool value);
    public bool get_ControlDomainPolicy();
    public void set_ControlDomainPolicy(bool value);
    public bool get_ControlEvidence();
    public void set_ControlEvidence(bool value);
    public bool get_ControlPolicy();
    public void set_ControlPolicy(bool value);
    public bool get_ControlPrincipal();
    public void set_ControlPrincipal(bool value);
    public bool get_ControlThread();
    public void set_ControlThread(bool value);
    public bool get_Execution();
    public void set_Execution(bool value);
    public SecurityPermissionFlag get_Flags();
    public void set_Flags(SecurityPermissionFlag value);
    public bool get_Infrastructure();
    public void set_Infrastructure(bool value);
    public bool get_RemotingConfiguration();
    public void set_RemotingConfiguration(bool value);
    public bool get_SerializationFormatter();
    public void set_SerializationFormatter(bool value);
    public bool get_SkipVerification();
    public void set_SkipVerification(bool value);
    public bool get_UnmanagedCode();
    public void set_UnmanagedCode(bool value);
    [NullableContextAttribute("2")]
public virtual IPermission CreatePermission();
}
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
[FlagsAttribute]
public enum System.Security.Permissions.SecurityPermissionFlag : Enum {
    public int value__;
    public static SecurityPermissionFlag NoFlags;
    public static SecurityPermissionFlag Assertion;
    public static SecurityPermissionFlag UnmanagedCode;
    public static SecurityPermissionFlag SkipVerification;
    public static SecurityPermissionFlag Execution;
    public static SecurityPermissionFlag ControlThread;
    public static SecurityPermissionFlag ControlEvidence;
    public static SecurityPermissionFlag ControlPolicy;
    public static SecurityPermissionFlag SerializationFormatter;
    public static SecurityPermissionFlag ControlDomainPolicy;
    public static SecurityPermissionFlag ControlPrincipal;
    public static SecurityPermissionFlag ControlAppDomain;
    public static SecurityPermissionFlag RemotingConfiguration;
    public static SecurityPermissionFlag Infrastructure;
    public static SecurityPermissionFlag BindingRedirects;
    public static SecurityPermissionFlag AllFlags;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ObsoleteAttribute("Code Access Security is not supported or honored by the runtime.")]
public class System.Security.PermissionSet : object {
    public int Count { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    [NullableAttribute("1")]
public object SyncRoot { get; }
    public PermissionSet(PermissionState state);
    public PermissionSet(PermissionSet permSet);
    public virtual int get_Count();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    [NullableContextAttribute("1")]
public virtual object get_SyncRoot();
    public IPermission AddPermission(IPermission perm);
    protected virtual IPermission AddPermissionImpl(IPermission perm);
    public sealed virtual void Assert();
    public bool ContainsNonCodeAccessPermissions();
    [NullableContextAttribute("1")]
[ObsoleteAttribute]
public static Byte[] ConvertPermissionSet(string inFormat, Byte[] inData, string outFormat);
    [NullableContextAttribute("1")]
public virtual PermissionSet Copy();
    [NullableContextAttribute("1")]
public virtual void CopyTo(Array array, int index);
    public sealed virtual void Demand();
    [ObsoleteAttribute]
public sealed virtual void Deny();
    public virtual bool Equals(object o);
    [NullableContextAttribute("1")]
public virtual void FromXml(SecurityElement et);
    [NullableContextAttribute("1")]
public sealed virtual IEnumerator GetEnumerator();
    [NullableContextAttribute("1")]
protected virtual IEnumerator GetEnumeratorImpl();
    public virtual int GetHashCode();
    public IPermission GetPermission(Type permClass);
    protected virtual IPermission GetPermissionImpl(Type permClass);
    public PermissionSet Intersect(PermissionSet other);
    public bool IsEmpty();
    public bool IsSubsetOf(PermissionSet target);
    public bool IsUnrestricted();
    public sealed virtual void PermitOnly();
    public IPermission RemovePermission(Type permClass);
    protected virtual IPermission RemovePermissionImpl(Type permClass);
    public static void RevertAssert();
    public IPermission SetPermission(IPermission perm);
    protected virtual IPermission SetPermissionImpl(IPermission perm);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public virtual SecurityElement ToXml();
    public PermissionSet Union(PermissionSet other);
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IIdentity {
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public abstract virtual string get_AuthenticationType();
    public abstract virtual bool get_IsAuthenticated();
    public abstract virtual string get_Name();
}
[NullableContextAttribute("2")]
public interface System.Security.Principal.IPrincipal {
    public IIdentity Identity { get; }
    public abstract virtual IIdentity get_Identity();
    [NullableContextAttribute("1")]
public abstract virtual bool IsInRole(string role);
}
public enum System.Security.Principal.PrincipalPolicy : Enum {
    public int value__;
    public static PrincipalPolicy UnauthenticatedPrincipal;
    public static PrincipalPolicy NoPrincipal;
    public static PrincipalPolicy WindowsPrincipal;
}
public enum System.Security.Principal.TokenImpersonationLevel : Enum {
    public int value__;
    public static TokenImpersonationLevel None;
    public static TokenImpersonationLevel Anonymous;
    public static TokenImpersonationLevel Identification;
    public static TokenImpersonationLevel Impersonation;
    public static TokenImpersonationLevel Delegation;
}
[AttributeUsageAttribute("5501")]
public class System.Security.SecurityCriticalAttribute : Attribute {
    [ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public SecurityCriticalScope Scope { get; }
    public SecurityCriticalAttribute(SecurityCriticalScope scope);
    public SecurityCriticalScope get_Scope();
}
[ObsoleteAttribute("SecurityCriticalScope is only used for .NET 2.0 transparency compatibility.")]
public enum System.Security.SecurityCriticalScope : Enum {
    public int value__;
    public static SecurityCriticalScope Explicit;
    public static SecurityCriticalScope Everything;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.SecurityElement : object {
    public Hashtable Attributes { get; public set; }
    public ArrayList Children { get; public set; }
    [NullableAttribute("1")]
public string Tag { get; public set; }
    public string Text { get; public set; }
    [NullableContextAttribute("1")]
public SecurityElement(string tag);
    [NullableContextAttribute("1")]
public SecurityElement(string tag, string text);
    public Hashtable get_Attributes();
    public void set_Attributes(Hashtable value);
    public ArrayList get_Children();
    public void set_Children(ArrayList value);
    [NullableContextAttribute("1")]
public string get_Tag();
    [NullableContextAttribute("1")]
public void set_Tag(string value);
    public string get_Text();
    public void set_Text(string value);
    [NullableContextAttribute("1")]
public void AddAttribute(string name, string value);
    [NullableContextAttribute("1")]
public void AddChild(SecurityElement child);
    [NullableContextAttribute("1")]
public string Attribute(string name);
    [NullableContextAttribute("1")]
public SecurityElement Copy();
    public bool Equal(SecurityElement other);
    public static string Escape(string str);
    [NullableContextAttribute("1")]
public static SecurityElement FromString(string xml);
    public static bool IsValidAttributeName(string name);
    public static bool IsValidAttributeValue(string value);
    public static bool IsValidTag(string tag);
    public static bool IsValidText(string text);
    [NullableContextAttribute("1")]
public SecurityElement SearchForChildByTag(string tag);
    [NullableContextAttribute("1")]
public string SearchForTextOfTag(string tag);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.SecurityException : SystemException {
    public object Demanded { get; public set; }
    public object DenySetInstance { get; public set; }
    public AssemblyName FailedAssemblyInfo { get; public set; }
    public string GrantedSet { get; public set; }
    public MethodInfo Method { get; public set; }
    public string PermissionState { get; public set; }
    public Type PermissionType { get; public set; }
    public object PermitOnlySetInstance { get; public set; }
    public string RefusedSet { get; public set; }
    public string Url { get; public set; }
    [NullableContextAttribute("1")]
protected SecurityException(SerializationInfo info, StreamingContext context);
    public SecurityException(string message);
    public SecurityException(string message, Exception inner);
    public SecurityException(string message, Type type);
    public SecurityException(string message, Type type, string state);
    public object get_Demanded();
    public void set_Demanded(object value);
    public object get_DenySetInstance();
    public void set_DenySetInstance(object value);
    public AssemblyName get_FailedAssemblyInfo();
    public void set_FailedAssemblyInfo(AssemblyName value);
    public string get_GrantedSet();
    public void set_GrantedSet(string value);
    public MethodInfo get_Method();
    public void set_Method(MethodInfo value);
    public string get_PermissionState();
    public void set_PermissionState(string value);
    public Type get_PermissionType();
    public void set_PermissionType(Type value);
    public object get_PermitOnlySetInstance();
    public void set_PermitOnlySetInstance(object value);
    public string get_RefusedSet();
    public void set_RefusedSet(string value);
    public string get_Url();
    public void set_Url(string value);
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityRulesAttribute : Attribute {
    public SecurityRuleSet RuleSet { get; }
    public bool SkipVerificationInFullTrust { get; public set; }
    public SecurityRulesAttribute(SecurityRuleSet ruleSet);
    public SecurityRuleSet get_RuleSet();
    public bool get_SkipVerificationInFullTrust();
    public void set_SkipVerificationInFullTrust(bool value);
}
public enum System.Security.SecurityRuleSet : Enum {
    public byte value__;
    public static SecurityRuleSet None;
    public static SecurityRuleSet Level1;
    public static SecurityRuleSet Level2;
}
[AttributeUsageAttribute("5500")]
public class System.Security.SecuritySafeCriticalAttribute : Attribute {
}
[AttributeUsageAttribute("1")]
public class System.Security.SecurityTransparentAttribute : Attribute {
}
[AttributeUsageAttribute("5501")]
[ObsoleteAttribute("SecurityTreatAsSafe is only used for .NET 2.0 transparency compatibility. Use the SecuritySafeCriticalAttribute instead.")]
public class System.Security.SecurityTreatAsSafeAttribute : Attribute {
}
[AttributeUsageAttribute("5188")]
public class System.Security.SuppressUnmanagedCodeSecurityAttribute : Attribute {
}
[AttributeUsageAttribute("2")]
public class System.Security.UnverifiableCodeAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Security.VerificationException : SystemException {
    [NullableContextAttribute("1")]
protected VerificationException(SerializationInfo info, StreamingContext context);
    public VerificationException(string message);
    public VerificationException(string message, Exception innerException);
}
[AttributeUsageAttribute("4124")]
public class System.SerializableAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.Single : ValueType {
    private float _dummyPrimitive;
    public static float E;
    public static float Epsilon;
    public static float MaxValue;
    public static float MinValue;
    public static float NaN;
    public static float NegativeInfinity;
    public static float NegativeZero;
    public static float Pi;
    public static float PositiveInfinity;
    public static float Tau;
    private static float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.AdditiveIdentity { get; }
    private static float System.Numerics.IBinaryNumber<System.Single>.AllBitsSet { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.E { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.Pi { get; }
    private static float System.Numerics.IFloatingPointConstants<System.Single>.Tau { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.Epsilon { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NaN { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeInfinity { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.NegativeZero { get; }
    private static float System.Numerics.IFloatingPointIeee754<System.Single>.PositiveInfinity { get; }
    private static float System.Numerics.IMinMaxValue<System.Single>.MaxValue { get; }
    private static float System.Numerics.IMinMaxValue<System.Single>.MinValue { get; }
    private static float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.MultiplicativeIdentity { get; }
    private static float System.Numerics.INumberBase<System.Single>.One { get; }
    private static int System.Numerics.INumberBase<System.Single>.Radix { get; }
    private static float System.Numerics.INumberBase<System.Single>.Zero { get; }
    private static float System.Numerics.ISignedNumber<System.Single>.NegativeOne { get; }
    private static override float System.Numerics.IAdditiveIdentity<System.Single,System.Single>.get_AdditiveIdentity();
    private static override float System.Numerics.IBinaryNumber<System.Single>.get_AllBitsSet();
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_E();
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_Pi();
    private static override float System.Numerics.IFloatingPointConstants<System.Single>.get_Tau();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_Epsilon();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NaN();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NegativeInfinity();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_NegativeZero();
    private static override float System.Numerics.IFloatingPointIeee754<System.Single>.get_PositiveInfinity();
    private static override float System.Numerics.IMinMaxValue<System.Single>.get_MaxValue();
    private static override float System.Numerics.IMinMaxValue<System.Single>.get_MinValue();
    private static override float System.Numerics.IMultiplicativeIdentity<System.Single,System.Single>.get_MultiplicativeIdentity();
    private static override float System.Numerics.INumberBase<System.Single>.get_One();
    private static override int System.Numerics.INumberBase<System.Single>.get_Radix();
    private static override float System.Numerics.INumberBase<System.Single>.get_Zero();
    private static override float System.Numerics.ISignedNumber<System.Single>.get_NegativeOne();
    public static override float Abs(float value);
    public static override float Acos(float x);
    public static override float Acosh(float x);
    public static override float AcosPi(float x);
    public static override float Asin(float x);
    public static override float Asinh(float x);
    public static override float AsinPi(float x);
    public static override float Atan(float x);
    public static override float Atan2(float y, float x);
    public static override float Atan2Pi(float y, float x);
    public static override float Atanh(float x);
    public static override float AtanPi(float x);
    public static override float BitDecrement(float x);
    public static override float BitIncrement(float x);
    public static override float Cbrt(float x);
    public static override float Ceiling(float x);
    public static override float Clamp(float value, float min, float max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(float value);
    public static override float CopySign(float value, float sign);
    public static override float Cos(float x);
    public static override float Cosh(float x);
    public static override float CosPi(float x);
    [NullableContextAttribute("1")]
public static override float CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override float CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override float CreateTruncating(TOther value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(float obj);
    public static override float Exp(float x);
    public static override float Exp10(float x);
    public static override float Exp10M1(float x);
    public static override float Exp2(float x);
    public static override float Exp2M1(float x);
    public static override float ExpM1(float x);
    public static override float Floor(float x);
    public static override float FusedMultiplyAdd(float left, float right, float addend);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override float Hypot(float x, float y);
    public static override float Ieee754Remainder(float left, float right);
    public static override int ILogB(float x);
    public static override bool IsEvenInteger(float value);
    public static override bool IsFinite(float f);
    public static override bool IsInfinity(float f);
    public static override bool IsInteger(float value);
    public static override bool IsNaN(float f);
    public static override bool IsNegative(float f);
    public static override bool IsNegativeInfinity(float f);
    public static override bool IsNormal(float f);
    public static override bool IsOddInteger(float value);
    public static override bool IsPositive(float value);
    public static override bool IsPositiveInfinity(float f);
    public static override bool IsPow2(float value);
    public static override bool IsRealNumber(float value);
    public static override bool IsSubnormal(float f);
    public static override float Log(float x);
    public static override float Log(float x, float newBase);
    public static override float Log10(float x);
    public static override float Log10P1(float x);
    public static override float Log2(float value);
    public static override float Log2P1(float x);
    public static override float LogP1(float x);
    public static override float Max(float x, float y);
    public static override float MaxMagnitude(float x, float y);
    public static override float MaxMagnitudeNumber(float x, float y);
    public static override float MaxNumber(float x, float y);
    public static override float Min(float x, float y);
    public static override float MinMagnitude(float x, float y);
    public static override float MinMagnitudeNumber(float x, float y);
    public static override float MinNumber(float x, float y);
    public static override bool op_Equality(float left, float right);
    public static override bool op_GreaterThan(float left, float right);
    public static override bool op_GreaterThanOrEqual(float left, float right);
    public static override bool op_Inequality(float left, float right);
    public static override bool op_LessThan(float left, float right);
    public static override bool op_LessThanOrEqual(float left, float right);
    public static override float Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override float Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static float Parse(string s);
    [NullableContextAttribute("1")]
public static float Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override float Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override float Parse(string s, IFormatProvider provider);
    public static override float Pow(float x, float y);
    public static override float ReciprocalEstimate(float x);
    public static override float ReciprocalSqrtEstimate(float x);
    public static override float RootN(float x, int n);
    public static override float Round(float x);
    public static override float Round(float x, int digits);
    public static override float Round(float x, int digits, MidpointRounding mode);
    public static override float Round(float x, MidpointRounding mode);
    public static override float ScaleB(float x, int n);
    public static override int Sign(float value);
    public static override float Sin(float x);
    public static override ValueTuple`2<float, float> SinCos(float x);
    public static override ValueTuple`2<float, float> SinCosPi(float x);
    public static override float Sinh(float x);
    public static override float SinPi(float x);
    public static override float Sqrt(float x);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override float System.Numerics.IAdditionOperators<System.Single,System.Single,System.Single>.op_Addition(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_BitwiseAnd(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_BitwiseOr(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_ExclusiveOr(float left, float right);
    private static override float System.Numerics.IBitwiseOperators<System.Single,System.Single,System.Single>.op_OnesComplement(float value);
    private static override float System.Numerics.IDecrementOperators<System.Single>.op_Decrement(float value);
    private static override float System.Numerics.IDivisionOperators<System.Single,System.Single,System.Single>.op_Division(float left, float right);
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetExponentByteCount();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetExponentShortestBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetSignificandBitLength();
    private sealed virtual override int System.Numerics.IFloatingPoint<System.Single>.GetSignificandByteCount();
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteExponentBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteExponentLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteSignificandBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IFloatingPoint<System.Single>.TryWriteSignificandLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override float System.Numerics.IIncrementOperators<System.Single>.op_Increment(float value);
    private static override float System.Numerics.IModulusOperators<System.Single,System.Single,System.Single>.op_Modulus(float left, float right);
    private static override float System.Numerics.IMultiplyOperators<System.Single,System.Single,System.Single>.op_Multiply(float left, float right);
    private static override bool System.Numerics.INumberBase<System.Single>.IsCanonical(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsComplexNumber(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsImaginaryNumber(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.IsZero(float value);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromChecked(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromSaturating(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertFromTruncating(TOther value, Single& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToChecked(float value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToSaturating(float value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.Single>.TryConvertToTruncating(float value, TOther& result);
    private static override float System.Numerics.ISubtractionOperators<System.Single,System.Single,System.Single>.op_Subtraction(float left, float right);
    private static override float System.Numerics.IUnaryNegationOperators<System.Single,System.Single>.op_UnaryNegation(float value);
    private static override float System.Numerics.IUnaryPlusOperators<System.Single,System.Single>.op_UnaryPlus(float value);
    public static override float Tan(float x);
    public static override float Tanh(float x);
    public static override float TanPi(float x);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override float Truncate(float x);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, Single& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, Single& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, Single& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, Single& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, Single& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, Single& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
[NativeMarshallingAttribute("System.Runtime.InteropServices.Marshalling.SpanMarshaller`2")]
public class System.Span`1 : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static Span`1<T> Empty { get; }
    public bool IsEmpty { get; }
    public T& Item { get; }
    public int Length { get; }
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public Span`1(Void* pointer, int length);
    public Span`1(T[] array);
    public Span`1(T[] array, int start, int length);
    public Span`1(T& reference);
    public static Span`1<T> get_Empty();
    public bool get_IsEmpty();
    public T& get_Item(int index);
    public int get_Length();
    public void Clear();
    public void CopyTo(Span`1<T> destination);
    [NullableContextAttribute("2")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Equals() on Span will always throw an exception. Use the equality operator instead.")]
public virtual bool Equals(object obj);
    public void Fill(T value);
    public Enumerator<T> GetEnumerator();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("GetHashCode() on Span will always throw an exception.")]
public virtual int GetHashCode();
    [EditorBrowsableAttribute("1")]
public T& GetPinnableReference();
    public static bool op_Equality(Span`1<T> left, Span`1<T> right);
    public static Span`1<T> op_Implicit(ArraySegment`1<T> segment);
    public static ReadOnlySpan`1<T> op_Implicit(Span`1<T> span);
    public static Span`1<T> op_Implicit(T[] array);
    public static bool op_Inequality(Span`1<T> left, Span`1<T> right);
    public Span`1<T> Slice(int start);
    public Span`1<T> Slice(int start, int length);
    public T[] ToArray();
    public virtual string ToString();
    public bool TryCopyTo(Span`1<T> destination);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.StackOverflowException : SystemException {
    public StackOverflowException(string message);
    public StackOverflowException(string message, Exception innerException);
}
[AttributeUsageAttribute("64")]
public class System.STAThreadAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Chars")]
public class System.String : object {
    public static string Empty;
    public char Chars { get; }
    public int Length { get; }
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(Char* value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(Char* value, int startIndex, int length);
    public String(char c, int count);
    [NullableContextAttribute("2")]
public String(Char[] value);
    public String(Char[] value, int startIndex, int length);
    [NullableContextAttribute("0")]
public String(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(SByte* value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public String(SByte* value, int startIndex, int length, Encoding enc);
    public char get_Chars(int index);
    public int get_Length();
    public sealed virtual object Clone();
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, int indexA, string strB, int indexB, int length, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, bool ignoreCase, CultureInfo culture);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public static int Compare(string strA, string strB, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, int indexA, string strB, int indexB, int length);
    [NullableContextAttribute("2")]
public static int CompareOrdinal(string strA, string strB);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(string strB);
    public static string Concat(IEnumerable`1<string> values);
    public static string Concat(object arg0);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Concat(object arg0, object arg1, object arg2);
    public static string Concat(Object[] args);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2);
    [NullableContextAttribute("0")]
public static string Concat(ReadOnlySpan`1<char> str0, ReadOnlySpan`1<char> str1, ReadOnlySpan`1<char> str2, ReadOnlySpan`1<char> str3);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2);
    [NullableContextAttribute("2")]
public static string Concat(string str0, string str1, string str2, string str3);
    public static string Concat(String[] values);
    public static string Concat(IEnumerable`1<T> values);
    public bool Contains(char value);
    public bool Contains(char value, StringComparison comparisonType);
    public bool Contains(string value);
    public bool Contains(string value, StringComparison comparisonType);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This API should not be used to create mutable strings. See https://go.microsoft.com/fwlink/?linkid=2084035 for alternatives.")]
public static string Copy(string str);
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<char> destination);
    public static string Create(IFormatProvider provider, DefaultInterpolatedStringHandler& handler);
    [NullableContextAttribute("0")]
public static string Create(IFormatProvider provider, Span`1<char> initialBuffer, DefaultInterpolatedStringHandler& handler);
    public static string Create(int length, TState state, SpanAction`2<char, TState> action);
    public bool EndsWith(char value);
    public bool EndsWith(string value);
    public bool EndsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool EndsWith(string value, StringComparison comparisonType);
    public StringRuneEnumerator EnumerateRunes();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(string value);
    [NullableContextAttribute("2")]
public static bool Equals(string a, string b);
    [NullableContextAttribute("2")]
public static bool Equals(string a, string b, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public bool Equals(string value, StringComparison comparisonType);
    public static string Format(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public static string Format(IFormatProvider provider, string format, Object[] args);
    public static string Format(string format, object arg0);
    public static string Format(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public static string Format(string format, object arg0, object arg1, object arg2);
    public static string Format(string format, Object[] args);
    public CharEnumerator GetEnumerator();
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("0")]
public static int GetHashCode(ReadOnlySpan`1<char> value, StringComparison comparisonType);
    public int GetHashCode(StringComparison comparisonType);
    [EditorBrowsableAttribute("1")]
public Char& modreq(System.Runtime.InteropServices.InAttribute) GetPinnableReference();
    public sealed virtual TypeCode GetTypeCode();
    public int IndexOf(char value);
    public int IndexOf(char value, int startIndex);
    public int IndexOf(char value, int startIndex, int count);
    public int IndexOf(char value, StringComparison comparisonType);
    public int IndexOf(string value);
    public int IndexOf(string value, int startIndex);
    public int IndexOf(string value, int startIndex, int count);
    public int IndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int IndexOf(string value, int startIndex, StringComparison comparisonType);
    public int IndexOf(string value, StringComparison comparisonType);
    public int IndexOfAny(Char[] anyOf);
    public int IndexOfAny(Char[] anyOf, int startIndex);
    public int IndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Insert(int startIndex, string value);
    public static string Intern(string str);
    public static string IsInterned(string str);
    public bool IsNormalized();
    public bool IsNormalized(NormalizationForm normalizationForm);
    [NullableContextAttribute("2")]
public static bool IsNullOrEmpty(string value);
    [NullableContextAttribute("2")]
public static bool IsNullOrWhiteSpace(string value);
    public static string Join(char separator, Object[] values);
    public static string Join(char separator, String[] value);
    public static string Join(char separator, String[] value, int startIndex, int count);
    public static string Join(string separator, IEnumerable`1<string> values);
    public static string Join(string separator, Object[] values);
    public static string Join(string separator, String[] value);
    public static string Join(string separator, String[] value, int startIndex, int count);
    public static string Join(char separator, IEnumerable`1<T> values);
    public static string Join(string separator, IEnumerable`1<T> values);
    public int LastIndexOf(char value);
    public int LastIndexOf(char value, int startIndex);
    public int LastIndexOf(char value, int startIndex, int count);
    public int LastIndexOf(string value);
    public int LastIndexOf(string value, int startIndex);
    public int LastIndexOf(string value, int startIndex, int count);
    public int LastIndexOf(string value, int startIndex, int count, StringComparison comparisonType);
    public int LastIndexOf(string value, int startIndex, StringComparison comparisonType);
    public int LastIndexOf(string value, StringComparison comparisonType);
    public int LastIndexOfAny(Char[] anyOf);
    public int LastIndexOfAny(Char[] anyOf, int startIndex);
    public int LastIndexOfAny(Char[] anyOf, int startIndex, int count);
    public string Normalize();
    public string Normalize(NormalizationForm normalizationForm);
    [NullableContextAttribute("2")]
public static bool op_Equality(string a, string b);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<char> op_Implicit(string value);
    [NullableContextAttribute("2")]
public static bool op_Inequality(string a, string b);
    public string PadLeft(int totalWidth);
    public string PadLeft(int totalWidth, char paddingChar);
    public string PadRight(int totalWidth);
    public string PadRight(int totalWidth, char paddingChar);
    public string Remove(int startIndex);
    public string Remove(int startIndex, int count);
    public string Replace(char oldChar, char newChar);
    public string Replace(string oldValue, string newValue);
    public string Replace(string oldValue, string newValue, bool ignoreCase, CultureInfo culture);
    public string Replace(string oldValue, string newValue, StringComparison comparisonType);
    public string ReplaceLineEndings();
    public string ReplaceLineEndings(string replacementText);
    public String[] Split(char separator, int count, StringSplitOptions options);
    public String[] Split(char separator, StringSplitOptions options);
    public String[] Split(Char[] separator);
    public String[] Split(Char[] separator, int count);
    public String[] Split(Char[] separator, int count, StringSplitOptions options);
    public String[] Split(Char[] separator, StringSplitOptions options);
    public String[] Split(string separator, int count, StringSplitOptions options);
    public String[] Split(string separator, StringSplitOptions options);
    public String[] Split(String[] separator, int count, StringSplitOptions options);
    public String[] Split(String[] separator, StringSplitOptions options);
    public bool StartsWith(char value);
    public bool StartsWith(string value);
    public bool StartsWith(string value, bool ignoreCase, CultureInfo culture);
    public bool StartsWith(string value, StringComparison comparisonType);
    public string Substring(int startIndex);
    public string Substring(int startIndex, int length);
    private sealed virtual override IEnumerator`1<char> System.Collections.Generic.IEnumerable<System.Char>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    public Char[] ToCharArray();
    public Char[] ToCharArray(int startIndex, int length);
    public string ToLower();
    public string ToLower(CultureInfo culture);
    public string ToLowerInvariant();
    public virtual string ToString();
    public sealed virtual string ToString(IFormatProvider provider);
    public string ToUpper();
    public string ToUpper(CultureInfo culture);
    public string ToUpperInvariant();
    public string Trim();
    public string Trim(char trimChar);
    public string Trim(Char[] trimChars);
    public string TrimEnd();
    public string TrimEnd(char trimChar);
    public string TrimEnd(Char[] trimChars);
    public string TrimStart();
    public string TrimStart(char trimChar);
    public string TrimStart(Char[] trimChars);
    [NullableContextAttribute("0")]
public bool TryCopyTo(Span`1<char> destination);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.StringComparer : object {
    public static StringComparer CurrentCulture { get; }
    public static StringComparer CurrentCultureIgnoreCase { get; }
    public static StringComparer InvariantCulture { get; }
    public static StringComparer InvariantCultureIgnoreCase { get; }
    public static StringComparer Ordinal { get; }
    public static StringComparer OrdinalIgnoreCase { get; }
    public static StringComparer get_CurrentCulture();
    public static StringComparer get_CurrentCultureIgnoreCase();
    public static StringComparer get_InvariantCulture();
    public static StringComparer get_InvariantCultureIgnoreCase();
    public static StringComparer get_Ordinal();
    public static StringComparer get_OrdinalIgnoreCase();
    [NullableContextAttribute("2")]
public sealed virtual int Compare(object x, object y);
    [NullableContextAttribute("2")]
public abstract virtual int Compare(string x, string y);
    public static StringComparer Create(CultureInfo culture, bool ignoreCase);
    public static StringComparer Create(CultureInfo culture, CompareOptions options);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(object x, object y);
    [NullableContextAttribute("2")]
public abstract virtual bool Equals(string x, string y);
    public static StringComparer FromComparison(StringComparison comparisonType);
    public sealed virtual int GetHashCode(object obj);
    public abstract virtual int GetHashCode(string obj);
    [NullableContextAttribute("2")]
public static bool IsWellKnownCultureAwareComparer(IEqualityComparer`1<string> comparer, CompareInfo& compareInfo, CompareOptions& compareOptions);
    [NullableContextAttribute("2")]
public static bool IsWellKnownOrdinalComparer(IEqualityComparer`1<string> comparer, Boolean& ignoreCase);
}
public enum System.StringComparison : Enum {
    public int value__;
    public static StringComparison CurrentCulture;
    public static StringComparison CurrentCultureIgnoreCase;
    public static StringComparison InvariantCulture;
    public static StringComparison InvariantCultureIgnoreCase;
    public static StringComparison Ordinal;
    public static StringComparison OrdinalIgnoreCase;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.StringNormalizationExtensions : object {
    [ExtensionAttribute]
public static bool IsNormalized(string strInput);
    [ExtensionAttribute]
public static bool IsNormalized(string strInput, NormalizationForm normalizationForm);
    [ExtensionAttribute]
public static string Normalize(string strInput);
    [ExtensionAttribute]
public static string Normalize(string strInput, NormalizationForm normalizationForm);
}
[FlagsAttribute]
public enum System.StringSplitOptions : Enum {
    public int value__;
    public static StringSplitOptions None;
    public static StringSplitOptions RemoveEmptyEntries;
    public static StringSplitOptions TrimEntries;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.SystemException : Exception {
    [NullableContextAttribute("1")]
protected SystemException(SerializationInfo info, StreamingContext context);
    public SystemException(string message);
    public SystemException(string message, Exception innerException);
}
public abstract class System.Text.Decoder : object {
    [NullableAttribute("2")]
public DecoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public DecoderFallbackBuffer FallbackBuffer { get; }
    [NullableContextAttribute("2")]
public DecoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(DecoderFallback value);
    [NullableContextAttribute("1")]
public DecoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [NullableContextAttribute("1")]
public virtual void Convert(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, int charCount, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush, Int32& bytesUsed, Int32& charsUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("1")]
public virtual int GetCharCount(Byte[] bytes, int index, int count, bool flush);
    public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("1")]
public virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex, bool flush);
    public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars, bool flush);
    public virtual void Reset();
}
public class System.Text.DecoderExceptionFallback : DecoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("1")]
public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.DecoderExceptionFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    [NullableContextAttribute("1")]
public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.DecoderFallback : object {
    public static DecoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static DecoderFallback ReplacementFallback { get; }
    public static DecoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static DecoderFallback get_ReplacementFallback();
    public abstract virtual DecoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.DecoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    [NullableContextAttribute("1")]
public abstract virtual bool Fallback(Byte[] bytesUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.DecoderFallbackException : ArgumentException {
    public Byte[] BytesUnknown { get; }
    public int Index { get; }
    public DecoderFallbackException(string message);
    public DecoderFallbackException(string message, Byte[] bytesUnknown, int index);
    public DecoderFallbackException(string message, Exception innerException);
    public Byte[] get_BytesUnknown();
    public int get_Index();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.DecoderReplacementFallback : DecoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public DecoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual DecoderFallbackBuffer CreateFallbackBuffer();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.DecoderReplacementFallbackBuffer : DecoderFallbackBuffer {
    public int Remaining { get; }
    public DecoderReplacementFallbackBuffer(DecoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(Byte[] bytesUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual void Reset();
}
public abstract class System.Text.Encoder : object {
    [NullableAttribute("2")]
public EncoderFallback Fallback { get; public set; }
    [NullableAttribute("1")]
public EncoderFallbackBuffer FallbackBuffer { get; }
    [NullableContextAttribute("2")]
public EncoderFallback get_Fallback();
    [NullableContextAttribute("2")]
public void set_Fallback(EncoderFallback value);
    [NullableContextAttribute("1")]
public EncoderFallbackBuffer get_FallbackBuffer();
    [CLSCompliantAttribute("False")]
public virtual void Convert(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [NullableContextAttribute("1")]
public virtual void Convert(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, int byteCount, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    public virtual void Convert(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush, Int32& charsUsed, Int32& bytesUsed, Boolean& completed);
    [CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetByteCount(Char[] chars, int index, int count, bool flush);
    public virtual int GetByteCount(ReadOnlySpan`1<char> chars, bool flush);
    [CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount, bool flush);
    [NullableContextAttribute("1")]
public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex, bool flush);
    public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes, bool flush);
    public virtual void Reset();
}
public class System.Text.EncoderExceptionFallback : EncoderFallback {
    public int MaxCharCount { get; }
    public virtual int get_MaxCharCount();
    [NullableContextAttribute("1")]
public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderExceptionFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncoderFallback : object {
    public static EncoderFallback ExceptionFallback { get; }
    public int MaxCharCount { get; }
    public static EncoderFallback ReplacementFallback { get; }
    public static EncoderFallback get_ExceptionFallback();
    public abstract virtual int get_MaxCharCount();
    public static EncoderFallback get_ReplacementFallback();
    public abstract virtual EncoderFallbackBuffer CreateFallbackBuffer();
}
public abstract class System.Text.EncoderFallbackBuffer : object {
    public int Remaining { get; }
    public abstract virtual int get_Remaining();
    public abstract virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public abstract virtual bool Fallback(char charUnknown, int index);
    public abstract virtual char GetNextChar();
    public abstract virtual bool MovePrevious();
    public virtual void Reset();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.EncoderFallbackException : ArgumentException {
    public char CharUnknown { get; }
    public char CharUnknownHigh { get; }
    public char CharUnknownLow { get; }
    public int Index { get; }
    public EncoderFallbackException(string message);
    public EncoderFallbackException(string message, Exception innerException);
    public char get_CharUnknown();
    public char get_CharUnknownHigh();
    public char get_CharUnknownLow();
    public int get_Index();
    public bool IsUnknownSurrogate();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.EncoderReplacementFallback : EncoderFallback {
    public string DefaultString { get; }
    public int MaxCharCount { get; }
    public EncoderReplacementFallback(string replacement);
    public string get_DefaultString();
    public virtual int get_MaxCharCount();
    public virtual EncoderFallbackBuffer CreateFallbackBuffer();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public virtual int GetHashCode();
}
public class System.Text.EncoderReplacementFallbackBuffer : EncoderFallbackBuffer {
    public int Remaining { get; }
    [NullableContextAttribute("1")]
public EncoderReplacementFallbackBuffer(EncoderReplacementFallback fallback);
    public virtual int get_Remaining();
    public virtual bool Fallback(char charUnknownHigh, char charUnknownLow, int index);
    public virtual bool Fallback(char charUnknown, int index);
    public virtual char GetNextChar();
    public virtual bool MovePrevious();
    public virtual void Reset();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Encoding : object {
    public static Encoding ASCII { get; }
    public static Encoding BigEndianUnicode { get; }
    public string BodyName { get; }
    public int CodePage { get; }
    public DecoderFallback DecoderFallback { get; public set; }
    public static Encoding Default { get; }
    public EncoderFallback EncoderFallback { get; public set; }
    public string EncodingName { get; }
    public string HeaderName { get; }
    public bool IsBrowserDisplay { get; }
    public bool IsBrowserSave { get; }
    public bool IsMailNewsDisplay { get; }
    public bool IsMailNewsSave { get; }
    public bool IsReadOnly { get; }
    public bool IsSingleByte { get; }
    public static Encoding Latin1 { get; }
    [NullableAttribute("0")]
public ReadOnlySpan`1<byte> Preamble { get; }
    public static Encoding Unicode { get; }
    public static Encoding UTF32 { get; }
    [ObsoleteAttribute("The UTF-7 encoding is insecure and should not be used. Consider using UTF-8 instead.")]
public static Encoding UTF7 { get; }
    public static Encoding UTF8 { get; }
    public string WebName { get; }
    public int WindowsCodePage { get; }
    protected Encoding(int codePage);
    [NullableContextAttribute("2")]
protected Encoding(int codePage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding get_ASCII();
    public static Encoding get_BigEndianUnicode();
    public virtual string get_BodyName();
    public virtual int get_CodePage();
    public DecoderFallback get_DecoderFallback();
    public void set_DecoderFallback(DecoderFallback value);
    public static Encoding get_Default();
    public EncoderFallback get_EncoderFallback();
    public void set_EncoderFallback(EncoderFallback value);
    public virtual string get_EncodingName();
    public virtual string get_HeaderName();
    public virtual bool get_IsBrowserDisplay();
    public virtual bool get_IsBrowserSave();
    public virtual bool get_IsMailNewsDisplay();
    public virtual bool get_IsMailNewsSave();
    public bool get_IsReadOnly();
    public virtual bool get_IsSingleByte();
    public static Encoding get_Latin1();
    [NullableContextAttribute("0")]
public virtual ReadOnlySpan`1<byte> get_Preamble();
    public static Encoding get_Unicode();
    public static Encoding get_UTF32();
    public static Encoding get_UTF7();
    public static Encoding get_UTF8();
    public virtual string get_WebName();
    public virtual int get_WindowsCodePage();
    public virtual object Clone();
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes);
    public static Byte[] Convert(Encoding srcEncoding, Encoding dstEncoding, Byte[] bytes, int index, int count);
    public static Stream CreateTranscodingStream(Stream innerStream, Encoding innerStreamEncoding, Encoding outerStreamEncoding, bool leaveOpen);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetByteCount(Char* chars, int count);
    public virtual int GetByteCount(Char[] chars);
    public abstract virtual int GetByteCount(Char[] chars, int index, int count);
    [NullableContextAttribute("0")]
public virtual int GetByteCount(ReadOnlySpan`1<char> chars);
    public virtual int GetByteCount(string s);
    public int GetByteCount(string s, int index, int count);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetBytes(Char* chars, int charCount, Byte* bytes, int byteCount);
    public virtual Byte[] GetBytes(Char[] chars);
    public virtual Byte[] GetBytes(Char[] chars, int index, int count);
    public abstract virtual int GetBytes(Char[] chars, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
public virtual int GetBytes(ReadOnlySpan`1<char> chars, Span`1<byte> bytes);
    public virtual Byte[] GetBytes(string s);
    public Byte[] GetBytes(string s, int index, int count);
    public virtual int GetBytes(string s, int charIndex, int charCount, Byte[] bytes, int byteIndex);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetCharCount(Byte* bytes, int count);
    public virtual int GetCharCount(Byte[] bytes);
    public abstract virtual int GetCharCount(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
public virtual int GetCharCount(ReadOnlySpan`1<byte> bytes);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public virtual int GetChars(Byte* bytes, int byteCount, Char* chars, int charCount);
    public virtual Char[] GetChars(Byte[] bytes);
    public virtual Char[] GetChars(Byte[] bytes, int index, int count);
    public abstract virtual int GetChars(Byte[] bytes, int byteIndex, int byteCount, Char[] chars, int charIndex);
    [NullableContextAttribute("0")]
public virtual int GetChars(ReadOnlySpan`1<byte> bytes, Span`1<char> chars);
    public virtual Decoder GetDecoder();
    public virtual Encoder GetEncoder();
    public static Encoding GetEncoding(int codepage);
    public static Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static Encoding GetEncoding(string name);
    public static Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public static EncodingInfo[] GetEncodings();
    public virtual int GetHashCode();
    public abstract virtual int GetMaxByteCount(int charCount);
    public abstract virtual int GetMaxCharCount(int byteCount);
    public virtual Byte[] GetPreamble();
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public string GetString(Byte* bytes, int byteCount);
    public virtual string GetString(Byte[] bytes);
    public virtual string GetString(Byte[] bytes, int index, int count);
    [NullableContextAttribute("0")]
public string GetString(ReadOnlySpan`1<byte> bytes);
    public bool IsAlwaysNormalized();
    public virtual bool IsAlwaysNormalized(NormalizationForm form);
    public static void RegisterProvider(EncodingProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.EncodingInfo : object {
    public int CodePage { get; }
    public string DisplayName { get; }
    public string Name { get; }
    public EncodingInfo(EncodingProvider provider, int codePage, string name, string displayName);
    public int get_CodePage();
    public string get_DisplayName();
    public string get_Name();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public Encoding GetEncoding();
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.EncodingProvider : object {
    [NullableContextAttribute("2")]
public abstract virtual Encoding GetEncoding(int codepage);
    public virtual Encoding GetEncoding(int codepage, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public abstract virtual Encoding GetEncoding(string name);
    public virtual Encoding GetEncoding(string name, EncoderFallback encoderFallback, DecoderFallback decoderFallback);
    public virtual IEnumerable`1<EncodingInfo> GetEncodings();
}
public enum System.Text.NormalizationForm : Enum {
    public int value__;
    public static NormalizationForm FormC;
    public static NormalizationForm FormD;
    [UnsupportedOSPlatformAttribute("browser")]
public static NormalizationForm FormKC;
    [UnsupportedOSPlatformAttribute("browser")]
public static NormalizationForm FormKD;
}
[IsReadOnlyAttribute]
public class System.Text.Rune : ValueType {
    private int _dummyPrimitive;
    public bool IsAscii { get; }
    public bool IsBmp { get; }
    public int Plane { get; }
    public static Rune ReplacementChar { get; }
    public int Utf16SequenceLength { get; }
    public int Utf8SequenceLength { get; }
    public int Value { get; }
    public Rune(char ch);
    public Rune(char highSurrogate, char lowSurrogate);
    public Rune(int value);
    [CLSCompliantAttribute("False")]
public Rune(UInt32 value);
    public bool get_IsAscii();
    public bool get_IsBmp();
    public int get_Plane();
    public static Rune get_ReplacementChar();
    public int get_Utf16SequenceLength();
    public int get_Utf8SequenceLength();
    public int get_Value();
    public sealed virtual int CompareTo(Rune other);
    public static OperationStatus DecodeFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeFromUtf8(ReadOnlySpan`1<byte> source, Rune& result, Int32& bytesConsumed);
    public static OperationStatus DecodeLastFromUtf16(ReadOnlySpan`1<char> source, Rune& result, Int32& charsConsumed);
    public static OperationStatus DecodeLastFromUtf8(ReadOnlySpan`1<byte> source, Rune& value, Int32& bytesConsumed);
    public int EncodeToUtf16(Span`1<char> destination);
    public int EncodeToUtf8(Span`1<byte> destination);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Rune other);
    public virtual int GetHashCode();
    public static double GetNumericValue(Rune value);
    [NullableContextAttribute("1")]
public static Rune GetRuneAt(string input, int index);
    public static UnicodeCategory GetUnicodeCategory(Rune value);
    public static bool IsControl(Rune value);
    public static bool IsDigit(Rune value);
    public static bool IsLetter(Rune value);
    public static bool IsLetterOrDigit(Rune value);
    public static bool IsLower(Rune value);
    public static bool IsNumber(Rune value);
    public static bool IsPunctuation(Rune value);
    public static bool IsSeparator(Rune value);
    public static bool IsSymbol(Rune value);
    public static bool IsUpper(Rune value);
    public static bool IsValid(int value);
    [CLSCompliantAttribute("False")]
public static bool IsValid(UInt32 value);
    public static bool IsWhiteSpace(Rune value);
    public static bool op_Equality(Rune left, Rune right);
    public static Rune op_Explicit(char ch);
    public static Rune op_Explicit(int value);
    [CLSCompliantAttribute("False")]
public static Rune op_Explicit(UInt32 value);
    public static bool op_GreaterThan(Rune left, Rune right);
    public static bool op_GreaterThanOrEqual(Rune left, Rune right);
    public static bool op_Inequality(Rune left, Rune right);
    public static bool op_LessThan(Rune left, Rune right);
    public static bool op_LessThanOrEqual(Rune left, Rune right);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static Rune ToLower(Rune value, CultureInfo culture);
    public static Rune ToLowerInvariant(Rune value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public static Rune ToUpper(Rune value, CultureInfo culture);
    public static Rune ToUpperInvariant(Rune value);
    public static bool TryCreate(char highSurrogate, char lowSurrogate, Rune& result);
    public static bool TryCreate(char ch, Rune& result);
    public static bool TryCreate(int value, Rune& result);
    [CLSCompliantAttribute("False")]
public static bool TryCreate(UInt32 value, Rune& result);
    public bool TryEncodeToUtf16(Span`1<char> destination, Int32& charsWritten);
    public bool TryEncodeToUtf8(Span`1<byte> destination, Int32& bytesWritten);
    [NullableContextAttribute("1")]
public static bool TryGetRuneAt(string input, int index, Rune& value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Chars")]
public class System.Text.StringBuilder : object {
    public int Capacity { get; public set; }
    public char Chars { get; public set; }
    public int Length { get; public set; }
    public int MaxCapacity { get; }
    public StringBuilder(int capacity);
    public StringBuilder(int capacity, int maxCapacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int capacity);
    [NullableContextAttribute("2")]
public StringBuilder(string value, int startIndex, int length, int capacity);
    public int get_Capacity();
    public void set_Capacity(int value);
    public char get_Chars(int index);
    public void set_Chars(int index, char value);
    public int get_Length();
    public void set_Length(int value);
    public int get_MaxCapacity();
    public StringBuilder Append(bool value);
    public StringBuilder Append(byte value);
    public StringBuilder Append(char value);
    [NullableContextAttribute("0")]
[CLSCompliantAttribute("False")]
public StringBuilder Append(Char* value, int valueCount);
    public StringBuilder Append(char value, int repeatCount);
    public StringBuilder Append(Char[] value);
    public StringBuilder Append(Char[] value, int startIndex, int charCount);
    public StringBuilder Append(decimal value);
    public StringBuilder Append(double value);
    public StringBuilder Append(IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    public StringBuilder Append(short value);
    public StringBuilder Append(int value);
    public StringBuilder Append(long value);
    public StringBuilder Append(object value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlyMemory`1<char> value);
    [NullableContextAttribute("0")]
public StringBuilder Append(ReadOnlySpan`1<char> value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(sbyte value);
    public StringBuilder Append(float value);
    public StringBuilder Append(string value);
    public StringBuilder Append(string value, int startIndex, int count);
    public StringBuilder Append(StringBuilder value);
    public StringBuilder Append(StringBuilder value, int startIndex, int count);
    public StringBuilder Append(AppendInterpolatedStringHandler& handler);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Append(ulong value);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(IFormatProvider provider, string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(IFormatProvider provider, string format, Object[] args);
    public StringBuilder AppendFormat(string format, object arg0);
    public StringBuilder AppendFormat(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
public StringBuilder AppendFormat(string format, object arg0, object arg1, object arg2);
    public StringBuilder AppendFormat(string format, Object[] args);
    public StringBuilder AppendJoin(char separator, Object[] values);
    public StringBuilder AppendJoin(char separator, String[] values);
    public StringBuilder AppendJoin(string separator, Object[] values);
    public StringBuilder AppendJoin(string separator, String[] values);
    public StringBuilder AppendJoin(char separator, IEnumerable`1<T> values);
    public StringBuilder AppendJoin(string separator, IEnumerable`1<T> values);
    public StringBuilder AppendLine();
    public StringBuilder AppendLine(IFormatProvider provider, AppendInterpolatedStringHandler& handler);
    public StringBuilder AppendLine(string value);
    public StringBuilder AppendLine(AppendInterpolatedStringHandler& handler);
    public StringBuilder Clear();
    public void CopyTo(int sourceIndex, Char[] destination, int destinationIndex, int count);
    [NullableContextAttribute("0")]
public void CopyTo(int sourceIndex, Span`1<char> destination, int count);
    public int EnsureCapacity(int capacity);
    [NullableContextAttribute("0")]
public bool Equals(ReadOnlySpan`1<char> span);
    [NullableContextAttribute("2")]
public bool Equals(StringBuilder sb);
    public ChunkEnumerator GetChunks();
    public StringBuilder Insert(int index, bool value);
    public StringBuilder Insert(int index, byte value);
    public StringBuilder Insert(int index, char value);
    public StringBuilder Insert(int index, Char[] value);
    public StringBuilder Insert(int index, Char[] value, int startIndex, int charCount);
    public StringBuilder Insert(int index, decimal value);
    public StringBuilder Insert(int index, double value);
    public StringBuilder Insert(int index, short value);
    public StringBuilder Insert(int index, int value);
    public StringBuilder Insert(int index, long value);
    public StringBuilder Insert(int index, object value);
    [NullableContextAttribute("0")]
public StringBuilder Insert(int index, ReadOnlySpan`1<char> value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, sbyte value);
    public StringBuilder Insert(int index, float value);
    public StringBuilder Insert(int index, string value);
    public StringBuilder Insert(int index, string value, int count);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ushort value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, UInt32 value);
    [CLSCompliantAttribute("False")]
public StringBuilder Insert(int index, ulong value);
    public StringBuilder Remove(int startIndex, int length);
    public StringBuilder Replace(char oldChar, char newChar);
    public StringBuilder Replace(char oldChar, char newChar, int startIndex, int count);
    public StringBuilder Replace(string oldValue, string newValue);
    public StringBuilder Replace(string oldValue, string newValue, int startIndex, int count);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public virtual string ToString();
    public string ToString(int startIndex, int length);
}
public class System.Text.StringRuneEnumerator : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Rune Current { get; }
    [NullableAttribute("2")]
private object System.Collections.IEnumerator.Current { get; }
    public sealed virtual Rune get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public StringRuneEnumerator GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override IEnumerator`1<Rune> System.Collections.Generic.IEnumerable<System.Text.Rune>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public static class System.Text.Unicode.Utf8 : object {
    public static OperationStatus FromUtf16(ReadOnlySpan`1<char> source, Span`1<byte> destination, Int32& charsRead, Int32& bytesWritten, bool replaceInvalidSequences, bool isFinalBlock);
    public static OperationStatus ToUtf16(ReadOnlySpan`1<byte> source, Span`1<char> destination, Int32& bytesRead, Int32& charsWritten, bool replaceInvalidSequences, bool isFinalBlock);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Threading.CancellationToken : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public bool CanBeCanceled { get; }
    public bool IsCancellationRequested { get; }
    public static CancellationToken None { get; }
    [NullableAttribute("1")]
public WaitHandle WaitHandle { get; }
    public CancellationToken(bool canceled);
    public bool get_CanBeCanceled();
    public bool get_IsCancellationRequested();
    public static CancellationToken get_None();
    [NullableContextAttribute("1")]
public WaitHandle get_WaitHandle();
    public virtual bool Equals(object other);
    public sealed virtual bool Equals(CancellationToken other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationToken left, CancellationToken right);
    public static bool op_Inequality(CancellationToken left, CancellationToken right);
    [NullableContextAttribute("1")]
public CancellationTokenRegistration Register(Action callback);
    [NullableContextAttribute("1")]
public CancellationTokenRegistration Register(Action callback, bool useSynchronizationContext);
    public CancellationTokenRegistration Register(Action`2<object, CancellationToken> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state);
    public CancellationTokenRegistration Register(Action`1<object> callback, object state, bool useSynchronizationContext);
    public void ThrowIfCancellationRequested();
    public CancellationTokenRegistration UnsafeRegister(Action`2<object, CancellationToken> callback, object state);
    public CancellationTokenRegistration UnsafeRegister(Action`1<object> callback, object state);
}
[IsReadOnlyAttribute]
public class System.Threading.CancellationTokenRegistration : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public CancellationToken Token { get; }
    public CancellationToken get_Token();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CancellationTokenRegistration other);
    public virtual int GetHashCode();
    public static bool op_Equality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public static bool op_Inequality(CancellationTokenRegistration left, CancellationTokenRegistration right);
    public bool Unregister();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.CancellationTokenSource : object {
    public bool IsCancellationRequested { get; }
    public CancellationToken Token { get; }
    public CancellationTokenSource(int millisecondsDelay);
    public CancellationTokenSource(TimeSpan delay);
    public bool get_IsCancellationRequested();
    public CancellationToken get_Token();
    public void Cancel();
    public void Cancel(bool throwOnFirstException);
    public void CancelAfter(int millisecondsDelay);
    public void CancelAfter(TimeSpan delay);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken token1, CancellationToken token2);
    public static CancellationTokenSource CreateLinkedTokenSource(CancellationToken[] tokens);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool TryReset();
}
public enum System.Threading.LazyThreadSafetyMode : Enum {
    public int value__;
    public static LazyThreadSafetyMode None;
    public static LazyThreadSafetyMode PublicationOnly;
    public static LazyThreadSafetyMode ExecutionAndPublication;
}
public class System.Threading.PeriodicTimer : object {
    public PeriodicTimer(TimeSpan period);
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
    public ValueTask`1<bool> WaitForNextTickAsync(CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.ConcurrentExclusiveSchedulerPair : object {
    public Task Completion { get; }
    public TaskScheduler ConcurrentScheduler { get; }
    public TaskScheduler ExclusiveScheduler { get; }
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel);
    public ConcurrentExclusiveSchedulerPair(TaskScheduler taskScheduler, int maxConcurrencyLevel, int maxItemsPerTask);
    public Task get_Completion();
    public TaskScheduler get_ConcurrentScheduler();
    public TaskScheduler get_ExclusiveScheduler();
    public void Complete();
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource {
    public abstract virtual void GetResult(short token);
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
[NullableContextAttribute("2")]
public interface System.Threading.Tasks.Sources.IValueTaskSource`1 {
    [NullableContextAttribute("1")]
public abstract virtual TResult GetResult(short token);
    public abstract virtual ValueTaskSourceStatus GetStatus(short token);
    public abstract virtual void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.Sources.ManualResetValueTaskSourceCore`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    public bool RunContinuationsAsynchronously { get; public set; }
    public short Version { get; }
    [IsReadOnlyAttribute]
public bool get_RunContinuationsAsynchronously();
    public void set_RunContinuationsAsynchronously(bool value);
    public short get_Version();
    public TResult GetResult(short token);
    public ValueTaskSourceStatus GetStatus(short token);
    [NullableContextAttribute("2")]
public void OnCompleted(Action`1<object> continuation, object state, short token, ValueTaskSourceOnCompletedFlags flags);
    public void Reset();
    public void SetException(Exception error);
    public void SetResult(TResult result);
}
[FlagsAttribute]
public enum System.Threading.Tasks.Sources.ValueTaskSourceOnCompletedFlags : Enum {
    public int value__;
    public static ValueTaskSourceOnCompletedFlags None;
    public static ValueTaskSourceOnCompletedFlags UseSchedulingContext;
    public static ValueTaskSourceOnCompletedFlags FlowExecutionContext;
}
public enum System.Threading.Tasks.Sources.ValueTaskSourceStatus : Enum {
    public int value__;
    public static ValueTaskSourceStatus Pending;
    public static ValueTaskSourceStatus Succeeded;
    public static ValueTaskSourceStatus Faulted;
    public static ValueTaskSourceStatus Canceled;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.Task : object {
    [NullableAttribute("2")]
public object AsyncState { get; }
    public static Task CompletedTask { get; }
    public TaskCreationOptions CreationOptions { get; }
    public static Nullable`1<int> CurrentId { get; }
    [NullableAttribute("2")]
public AggregateException Exception { get; }
    public static TaskFactory Factory { get; }
    public int Id { get; }
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public TaskStatus Status { get; }
    private WaitHandle System.IAsyncResult.AsyncWaitHandle { get; }
    private bool System.IAsyncResult.CompletedSynchronously { get; }
    public Task(Action action);
    public Task(Action action, CancellationToken cancellationToken);
    public Task(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task(Action action, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public sealed virtual object get_AsyncState();
    public static Task get_CompletedTask();
    public TaskCreationOptions get_CreationOptions();
    public static Nullable`1<int> get_CurrentId();
    [NullableContextAttribute("2")]
public AggregateException get_Exception();
    public static TaskFactory get_Factory();
    public int get_Id();
    public bool get_IsCanceled();
    public sealed virtual bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public TaskStatus get_Status();
    private sealed virtual override WaitHandle System.IAsyncResult.get_AsyncWaitHandle();
    private sealed virtual override bool System.IAsyncResult.get_CompletedSynchronously();
    public ConfiguredTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task> continuationAction, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`3<Task, object, TResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWith(Func`2<Task, TResult> continuationFunction, TaskScheduler scheduler);
    public static Task Delay(int millisecondsDelay);
    public static Task Delay(int millisecondsDelay, CancellationToken cancellationToken);
    public static Task Delay(TimeSpan delay);
    public static Task Delay(TimeSpan delay, CancellationToken cancellationToken);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public static Task FromCanceled(CancellationToken cancellationToken);
    public static Task`1<TResult> FromCanceled(CancellationToken cancellationToken);
    public static Task FromException(Exception exception);
    public static Task`1<TResult> FromException(Exception exception);
    public static Task`1<TResult> FromResult(TResult result);
    public TaskAwaiter GetAwaiter();
    public static Task Run(Action action);
    public static Task Run(Action action, CancellationToken cancellationToken);
    public static Task Run(Func`1<Task> function);
    public static Task Run(Func`1<Task> function, CancellationToken cancellationToken);
    public void RunSynchronously();
    public void RunSynchronously(TaskScheduler scheduler);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function);
    public static Task`1<TResult> Run(Func`1<Task`1<TResult>> function, CancellationToken cancellationToken);
    public static Task`1<TResult> Run(Func`1<TResult> function);
    public static Task`1<TResult> Run(Func`1<TResult> function, CancellationToken cancellationToken);
    public void Start();
    public void Start(TaskScheduler scheduler);
    public void Wait();
    public bool Wait(int millisecondsTimeout);
    public bool Wait(int millisecondsTimeout, CancellationToken cancellationToken);
    public void Wait(CancellationToken cancellationToken);
    public bool Wait(TimeSpan timeout);
    public bool Wait(TimeSpan timeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static void WaitAll(Task[] tasks);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, int millisecondsTimeout);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static void WaitAll(Task[] tasks, CancellationToken cancellationToken);
    [UnsupportedOSPlatformAttribute("browser")]
public static bool WaitAll(Task[] tasks, TimeSpan timeout);
    public static int WaitAny(Task[] tasks);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout);
    public static int WaitAny(Task[] tasks, int millisecondsTimeout, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, CancellationToken cancellationToken);
    public static int WaitAny(Task[] tasks, TimeSpan timeout);
    public Task WaitAsync(CancellationToken cancellationToken);
    public Task WaitAsync(TimeSpan timeout);
    public Task WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
    public static Task WhenAll(IEnumerable`1<Task> tasks);
    public static Task WhenAll(Task[] tasks);
    public static Task`1<TResult[]> WhenAll(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<TResult[]> WhenAll(Task`1[] tasks);
    public static Task`1<Task> WhenAny(IEnumerable`1<Task> tasks);
    public static Task`1<Task> WhenAny(Task task1, Task task2);
    public static Task`1<Task> WhenAny(Task[] tasks);
    public static Task`1<Task`1<TResult>> WhenAny(IEnumerable`1<Task`1<TResult>> tasks);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1<TResult> task1, Task`1<TResult> task2);
    public static Task`1<Task`1<TResult>> WhenAny(Task`1[] tasks);
    public static YieldAwaitable Yield();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.Task`1 : Task {
    public static TaskFactory`1<TResult> Factory { get; }
    public TResult Result { get; }
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions);
    public Task`1(Func`1<TResult> function, TaskCreationOptions creationOptions);
    public static TaskFactory`1<TResult> get_Factory();
    public TResult get_Result();
    public ConfiguredTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`2<Task`1<TResult>, object> continuationAction, object state, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task ContinueWith(Action`1<Task`1<TResult>> continuationAction, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`3<Task`1<TResult>, object, TNewResult> continuationFunction, object state, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TNewResult> ContinueWith(Func`2<Task`1<TResult>, TNewResult> continuationFunction, TaskScheduler scheduler);
    public TaskAwaiter`1<TResult> GetAwaiter();
    public Task`1<TResult> WaitAsync(CancellationToken cancellationToken);
    public Task`1<TResult> WaitAsync(TimeSpan timeout);
    public Task`1<TResult> WaitAsync(TimeSpan timeout, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskAsyncEnumerableExtensions : object {
    [ExtensionAttribute]
public static ConfiguredAsyncDisposable ConfigureAwait(IAsyncDisposable source, bool continueOnCapturedContext);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> ConfigureAwait(IAsyncEnumerable`1<T> source, bool continueOnCapturedContext);
    [ExtensionAttribute]
[UnsupportedOSPlatformAttribute("browser")]
public static IEnumerable`1<T> ToBlockingEnumerable(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ConfiguredCancelableAsyncEnumerable`1<T> WithCancellation(IAsyncEnumerable`1<T> source, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskCanceledException : OperationCanceledException {
    public Task Task { get; }
    [NullableContextAttribute("1")]
protected TaskCanceledException(SerializationInfo info, StreamingContext context);
    public TaskCanceledException(string message);
    public TaskCanceledException(string message, Exception innerException);
    public TaskCanceledException(string message, Exception innerException, CancellationToken token);
    public TaskCanceledException(Task task);
    public Task get_Task();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskCompletionSource : object {
    public Task Task { get; }
    [NullableContextAttribute("2")]
public TaskCompletionSource(object state);
    [NullableContextAttribute("2")]
public TaskCompletionSource(object state, TaskCreationOptions creationOptions);
    public TaskCompletionSource(TaskCreationOptions creationOptions);
    public Task get_Task();
    public void SetCanceled();
    public void SetCanceled(CancellationToken cancellationToken);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetResult();
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetException(Exception exception);
    public bool TrySetResult();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskCompletionSource`1 : object {
    public Task`1<TResult> Task { get; }
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state);
    [NullableContextAttribute("2")]
public TaskCompletionSource`1(object state, TaskCreationOptions creationOptions);
    public TaskCompletionSource`1(TaskCreationOptions creationOptions);
    public Task`1<TResult> get_Task();
    public void SetCanceled();
    public void SetCanceled(CancellationToken cancellationToken);
    public void SetException(IEnumerable`1<Exception> exceptions);
    public void SetException(Exception exception);
    public void SetResult(TResult result);
    public bool TrySetCanceled();
    public bool TrySetCanceled(CancellationToken cancellationToken);
    public bool TrySetException(IEnumerable`1<Exception> exceptions);
    public bool TrySetException(Exception exception);
    public bool TrySetResult(TResult result);
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskContinuationOptions : Enum {
    public int value__;
    public static TaskContinuationOptions None;
    public static TaskContinuationOptions PreferFairness;
    public static TaskContinuationOptions LongRunning;
    public static TaskContinuationOptions AttachedToParent;
    public static TaskContinuationOptions DenyChildAttach;
    public static TaskContinuationOptions HideScheduler;
    public static TaskContinuationOptions LazyCancellation;
    public static TaskContinuationOptions RunContinuationsAsynchronously;
    public static TaskContinuationOptions NotOnRanToCompletion;
    public static TaskContinuationOptions NotOnFaulted;
    public static TaskContinuationOptions OnlyOnCanceled;
    public static TaskContinuationOptions NotOnCanceled;
    public static TaskContinuationOptions OnlyOnFaulted;
    public static TaskContinuationOptions OnlyOnRanToCompletion;
    public static TaskContinuationOptions ExecuteSynchronously;
}
[FlagsAttribute]
public enum System.Threading.Tasks.TaskCreationOptions : Enum {
    public int value__;
    public static TaskCreationOptions None;
    public static TaskCreationOptions PreferFairness;
    public static TaskCreationOptions LongRunning;
    public static TaskCreationOptions AttachedToParent;
    public static TaskCreationOptions DenyChildAttach;
    public static TaskCreationOptions HideScheduler;
    public static TaskCreationOptions RunContinuationsAsynchronously;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.Tasks.TaskExtensions : object {
    [ExtensionAttribute]
public static Task Unwrap(Task`1<Task> task);
    [ExtensionAttribute]
public static Task`1<TResult> Unwrap(Task`1<Task`1<TResult>> task);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskFactory : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskFactory(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task[] tasks, Action`1<Task[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAll(Task`1[] tasks, Action`1<Task`1[]> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task[] tasks, Action`1<Task> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task ContinueWhenAny(Task`1[] tasks, Action`1<Task`1<TAntecedentResult>> continuationAction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state);
    public Task FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions);
    public Task FromAsync(IAsyncResult asyncResult, Action`1<IAsyncResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state);
    public Task FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Action`1<IAsyncResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task StartNew(Action action);
    public Task StartNew(Action action, CancellationToken cancellationToken);
    public Task StartNew(Action action, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action action, TaskCreationOptions creationOptions);
    public Task StartNew(Action`1<object> action, object state);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken);
    public Task StartNew(Action`1<object> action, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task StartNew(Action`1<object> action, object state, TaskCreationOptions creationOptions);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    [NullableContextAttribute("2")]
public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskFactory`1 : object {
    public CancellationToken CancellationToken { get; }
    public TaskContinuationOptions ContinuationOptions { get; }
    public TaskCreationOptions CreationOptions { get; }
    [NullableAttribute("2")]
public TaskScheduler Scheduler { get; }
    public TaskFactory`1(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public TaskFactory`1(CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public TaskFactory`1(TaskCreationOptions creationOptions, TaskContinuationOptions continuationOptions);
    [NullableContextAttribute("2")]
public TaskFactory`1(TaskScheduler scheduler);
    public CancellationToken get_CancellationToken();
    public TaskContinuationOptions get_ContinuationOptions();
    public TaskCreationOptions get_CreationOptions();
    [NullableContextAttribute("2")]
public TaskScheduler get_Scheduler();
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task[] tasks, Func`2<Task[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAll(Task`1[] tasks, Func`2<Task`1[], TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task[] tasks, Func`2<Task, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, CancellationToken cancellationToken, TaskContinuationOptions continuationOptions, TaskScheduler scheduler);
    public Task`1<TResult> ContinueWhenAny(Task`1[] tasks, Func`2<Task`1<TAntecedentResult>, TResult> continuationFunction, TaskContinuationOptions continuationOptions);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state);
    public Task`1<TResult> FromAsync(Func`3<AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(IAsyncResult asyncResult, Func`2<IAsyncResult, TResult> endMethod, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state);
    public Task`1<TResult> FromAsync(Func`4<TArg1, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state);
    public Task`1<TResult> FromAsync(Func`5<TArg1, TArg2, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state);
    public Task`1<TResult> FromAsync(Func`6<TArg1, TArg2, TArg3, AsyncCallback, object, IAsyncResult> beginMethod, Func`2<IAsyncResult, TResult> endMethod, TArg1 arg1, TArg2 arg2, TArg3 arg3, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`2<object, TResult> function, object state, TaskCreationOptions creationOptions);
    public Task`1<TResult> StartNew(Func`1<TResult> function);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken);
    public Task`1<TResult> StartNew(Func`1<TResult> function, CancellationToken cancellationToken, TaskCreationOptions creationOptions, TaskScheduler scheduler);
    public Task`1<TResult> StartNew(Func`1<TResult> function, TaskCreationOptions creationOptions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Threading.Tasks.TaskScheduler : object {
    public static TaskScheduler Current { get; }
    public static TaskScheduler Default { get; }
    public int Id { get; }
    public int MaximumConcurrencyLevel { get; }
    public static TaskScheduler get_Current();
    public static TaskScheduler get_Default();
    public int get_Id();
    public virtual int get_MaximumConcurrencyLevel();
    public static void add_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static void remove_UnobservedTaskException(EventHandler`1<UnobservedTaskExceptionEventArgs> value);
    public static TaskScheduler FromCurrentSynchronizationContext();
    protected abstract virtual IEnumerable`1<Task> GetScheduledTasks();
    protected internal abstract virtual void QueueTask(Task task);
    protected internal virtual bool TryDequeue(Task task);
    protected bool TryExecuteTask(Task task);
    protected abstract virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Threading.Tasks.TaskSchedulerException : Exception {
    public TaskSchedulerException(Exception innerException);
    [NullableContextAttribute("1")]
protected TaskSchedulerException(SerializationInfo info, StreamingContext context);
    public TaskSchedulerException(string message);
    public TaskSchedulerException(string message, Exception innerException);
}
public enum System.Threading.Tasks.TaskStatus : Enum {
    public int value__;
    public static TaskStatus Created;
    public static TaskStatus WaitingForActivation;
    public static TaskStatus WaitingToRun;
    public static TaskStatus Running;
    public static TaskStatus WaitingForChildrenToComplete;
    public static TaskStatus RanToCompletion;
    public static TaskStatus Canceled;
    public static TaskStatus Faulted;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Tasks.UnobservedTaskExceptionEventArgs : EventArgs {
    public AggregateException Exception { get; }
    public bool Observed { get; }
    public UnobservedTaskExceptionEventArgs(AggregateException exception);
    public AggregateException get_Exception();
    public bool get_Observed();
    public void SetObserved();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder")]
public class System.Threading.Tasks.ValueTask : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public static ValueTask CompletedTask { get; }
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public ValueTask(IValueTaskSource source, short token);
    public ValueTask(Task task);
    public static ValueTask get_CompletedTask();
    public bool get_IsCanceled();
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public Task AsTask();
    public ConfiguredValueTaskAwaitable ConfigureAwait(bool continueOnCapturedContext);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask other);
    public static ValueTask FromCanceled(CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
public static ValueTask`1<TResult> FromCanceled(CancellationToken cancellationToken);
    public static ValueTask FromException(Exception exception);
    public static ValueTask`1<TResult> FromException(Exception exception);
    public static ValueTask`1<TResult> FromResult(TResult result);
    public ValueTaskAwaiter GetAwaiter();
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTask left, ValueTask right);
    public static bool op_Inequality(ValueTask left, ValueTask right);
    public ValueTask Preserve();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
[AsyncMethodBuilderAttribute("System.Runtime.CompilerServices.AsyncValueTaskMethodBuilder`1")]
public class System.Threading.Tasks.ValueTask`1 : ValueType {
    private TResult _result;
    private object _dummy;
    private int _dummyPrimitive;
    public bool IsCanceled { get; }
    public bool IsCompleted { get; }
    public bool IsCompletedSuccessfully { get; }
    public bool IsFaulted { get; }
    public TResult Result { get; }
    public ValueTask`1(IValueTaskSource`1<TResult> source, short token);
    public ValueTask`1(Task`1<TResult> task);
    public ValueTask`1(TResult result);
    public bool get_IsCanceled();
    public bool get_IsCompleted();
    public bool get_IsCompletedSuccessfully();
    public bool get_IsFaulted();
    public TResult get_Result();
    public Task`1<TResult> AsTask();
    public ConfiguredValueTaskAwaitable`1<TResult> ConfigureAwait(bool continueOnCapturedContext);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTask`1<TResult> other);
    public ValueTaskAwaiter`1<TResult> GetAwaiter();
    public virtual int GetHashCode();
    public static bool op_Equality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public static bool op_Inequality(ValueTask`1<TResult> left, ValueTask`1<TResult> right);
    public ValueTask`1<TResult> Preserve();
    [NullableContextAttribute("2")]
public virtual string ToString();
}
public static class System.Threading.Timeout : object {
    public static int Infinite;
    public static TimeSpan InfiniteTimeSpan;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Threading.Timer : MarshalByRefObject {
    public static long ActiveCount { get; }
    public Timer(TimerCallback callback);
    public Timer(TimerCallback callback, object state, int dueTime, int period);
    public Timer(TimerCallback callback, object state, long dueTime, long period);
    public Timer(TimerCallback callback, object state, TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public Timer(TimerCallback callback, object state, UInt32 dueTime, UInt32 period);
    public static long get_ActiveCount();
    public bool Change(int dueTime, int period);
    public bool Change(long dueTime, long period);
    public bool Change(TimeSpan dueTime, TimeSpan period);
    [CLSCompliantAttribute("False")]
public bool Change(UInt32 dueTime, UInt32 period);
    public sealed virtual void Dispose();
    public bool Dispose(WaitHandle notifyObject);
    public sealed virtual ValueTask DisposeAsync();
}
public class System.Threading.TimerCallback : MulticastDelegate {
    public TimerCallback(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Threading.WaitHandle : MarshalByRefObject {
    protected static IntPtr InvalidHandle;
    public static int WaitTimeout;
    [ObsoleteAttribute("WaitHandle.Handle has been deprecated. Use the SafeWaitHandle property instead.")]
public IntPtr Handle { get; public set; }
    public SafeWaitHandle SafeWaitHandle { get; public set; }
    public virtual IntPtr get_Handle();
    public virtual void set_Handle(IntPtr value);
    public SafeWaitHandle get_SafeWaitHandle();
    public void set_SafeWaitHandle(SafeWaitHandle value);
    public virtual void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool explicitDisposing);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, int millisecondsTimeout, bool exitContext);
    public static bool SignalAndWait(WaitHandle toSignal, WaitHandle toWaitOn, TimeSpan timeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static bool WaitAll(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout);
    public static bool WaitAll(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout);
    public static int WaitAny(WaitHandle[] waitHandles, int millisecondsTimeout, bool exitContext);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout);
    public static int WaitAny(WaitHandle[] waitHandles, TimeSpan timeout, bool exitContext);
    public virtual bool WaitOne();
    public virtual bool WaitOne(int millisecondsTimeout);
    public virtual bool WaitOne(int millisecondsTimeout, bool exitContext);
    public virtual bool WaitOne(TimeSpan timeout);
    public virtual bool WaitOne(TimeSpan timeout, bool exitContext);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Threading.WaitHandleExtensions : object {
    [ExtensionAttribute]
public static SafeWaitHandle GetSafeWaitHandle(WaitHandle waitHandle);
    [ExtensionAttribute]
public static void SetSafeWaitHandle(WaitHandle waitHandle, SafeWaitHandle value);
}
[AttributeUsageAttribute("256")]
public class System.ThreadStaticAttribute : Attribute {
}
[IsReadOnlyAttribute]
public class System.TimeOnly : ValueType {
    private int _dummyPrimitive;
    public int Hour { get; }
    public static TimeOnly MaxValue { get; }
    public int Microsecond { get; }
    public int Millisecond { get; }
    public int Minute { get; }
    public static TimeOnly MinValue { get; }
    public int Nanosecond { get; }
    public int Second { get; }
    public long Ticks { get; }
    public TimeOnly(int hour, int minute);
    public TimeOnly(int hour, int minute, int second);
    public TimeOnly(int hour, int minute, int second, int millisecond);
    public TimeOnly(int hour, int minute, int second, int millisecond, int microsecond);
    public TimeOnly(long ticks);
    public int get_Hour();
    public static TimeOnly get_MaxValue();
    public int get_Microsecond();
    public int get_Millisecond();
    public int get_Minute();
    public static TimeOnly get_MinValue();
    public int get_Nanosecond();
    public int get_Second();
    public long get_Ticks();
    public TimeOnly Add(TimeSpan value);
    public TimeOnly Add(TimeSpan value, Int32& wrappedDays);
    public TimeOnly AddHours(double value);
    public TimeOnly AddHours(double value, Int32& wrappedDays);
    public TimeOnly AddMinutes(double value);
    public TimeOnly AddMinutes(double value, Int32& wrappedDays);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeOnly value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeOnly value);
    public static TimeOnly FromDateTime(DateTime dateTime);
    public static TimeOnly FromTimeSpan(TimeSpan timeSpan);
    public virtual int GetHashCode();
    public bool IsBetween(TimeOnly start, TimeOnly end);
    public static bool op_Equality(TimeOnly left, TimeOnly right);
    public static bool op_GreaterThan(TimeOnly left, TimeOnly right);
    public static bool op_GreaterThanOrEqual(TimeOnly left, TimeOnly right);
    public static bool op_Inequality(TimeOnly left, TimeOnly right);
    public static bool op_LessThan(TimeOnly left, TimeOnly right);
    public static bool op_LessThanOrEqual(TimeOnly left, TimeOnly right);
    public static TimeSpan op_Subtraction(TimeOnly t1, TimeOnly t2);
    public static override TimeOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    public static TimeOnly Parse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly Parse(string s);
    [NullableContextAttribute("1")]
public static override TimeOnly Parse(string s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static TimeOnly Parse(string s, IFormatProvider provider, DateTimeStyles style);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats);
    public static TimeOnly ParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, string format);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, String[] formats);
    [NullableContextAttribute("1")]
public static TimeOnly ParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style);
    [NullableContextAttribute("1")]
public string ToLongTimeString();
    [NullableContextAttribute("1")]
public string ToShortTimeString();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public TimeSpan ToTimeSpan();
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, TimeOnly& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, ReadOnlySpan`1<char> format, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> s, String[] formats, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, string format, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, IFormatProvider provider, DateTimeStyles style, TimeOnly& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string s, String[] formats, TimeOnly& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.TimeoutException : SystemException {
    [NullableContextAttribute("1")]
protected TimeoutException(SerializationInfo info, StreamingContext context);
    public TimeoutException(string message);
    public TimeoutException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
public class System.TimeSpan : ValueType {
    private int _dummyPrimitive;
    public static TimeSpan MaxValue;
    public static TimeSpan MinValue;
    public static long NanosecondsPerTick;
    public static long TicksPerDay;
    public static long TicksPerHour;
    public static long TicksPerMicrosecond;
    public static long TicksPerMillisecond;
    public static long TicksPerMinute;
    public static long TicksPerSecond;
    public static TimeSpan Zero;
    public int Days { get; }
    public int Hours { get; }
    public int Microseconds { get; }
    public int Milliseconds { get; }
    public int Minutes { get; }
    public int Nanoseconds { get; }
    public int Seconds { get; }
    public long Ticks { get; }
    public double TotalDays { get; }
    public double TotalHours { get; }
    public double TotalMicroseconds { get; }
    public double TotalMilliseconds { get; }
    public double TotalMinutes { get; }
    public double TotalNanoseconds { get; }
    public double TotalSeconds { get; }
    public TimeSpan(int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds);
    public TimeSpan(int days, int hours, int minutes, int seconds, int milliseconds, int microseconds);
    public TimeSpan(long ticks);
    public int get_Days();
    public int get_Hours();
    public int get_Microseconds();
    public int get_Milliseconds();
    public int get_Minutes();
    public int get_Nanoseconds();
    public int get_Seconds();
    public long get_Ticks();
    public double get_TotalDays();
    public double get_TotalHours();
    public double get_TotalMicroseconds();
    public double get_TotalMilliseconds();
    public double get_TotalMinutes();
    public double get_TotalNanoseconds();
    public double get_TotalSeconds();
    public TimeSpan Add(TimeSpan ts);
    public static int Compare(TimeSpan t1, TimeSpan t2);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(TimeSpan value);
    public TimeSpan Divide(double divisor);
    public double Divide(TimeSpan ts);
    public TimeSpan Duration();
    [NullableContextAttribute("2")]
public virtual bool Equals(object value);
    public sealed virtual bool Equals(TimeSpan obj);
    public static bool Equals(TimeSpan t1, TimeSpan t2);
    public static TimeSpan FromDays(double value);
    public static TimeSpan FromHours(double value);
    public static TimeSpan FromMicroseconds(double value);
    public static TimeSpan FromMilliseconds(double value);
    public static TimeSpan FromMinutes(double value);
    public static TimeSpan FromSeconds(double value);
    public static TimeSpan FromTicks(long value);
    public virtual int GetHashCode();
    public TimeSpan Multiply(double factor);
    public TimeSpan Negate();
    public static TimeSpan op_Addition(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Division(TimeSpan timeSpan, double divisor);
    public static double op_Division(TimeSpan t1, TimeSpan t2);
    public static bool op_Equality(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThan(TimeSpan t1, TimeSpan t2);
    public static bool op_GreaterThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static bool op_Inequality(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThan(TimeSpan t1, TimeSpan t2);
    public static bool op_LessThanOrEqual(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_Multiply(double factor, TimeSpan timeSpan);
    public static TimeSpan op_Multiply(TimeSpan timeSpan, double factor);
    public static TimeSpan op_Subtraction(TimeSpan t1, TimeSpan t2);
    public static TimeSpan op_UnaryNegation(TimeSpan t);
    public static TimeSpan op_UnaryPlus(TimeSpan t);
    public static override TimeSpan Parse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan Parse(string s);
    [NullableContextAttribute("1")]
public static override TimeSpan Parse(string input, IFormatProvider formatProvider);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles);
    public static TimeSpan ParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider);
    [NullableContextAttribute("1")]
public static TimeSpan ParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles);
    public TimeSpan Subtract(TimeSpan ts);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider formatProvider);
    public static override bool TryParse(ReadOnlySpan`1<char> input, IFormatProvider formatProvider, TimeSpan& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, TimeSpan& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string input, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    public static bool TryParseExact(ReadOnlySpan`1<char> input, ReadOnlySpan`1<char> format, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(ReadOnlySpan`1<char> input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, string format, IFormatProvider formatProvider, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpanStyles styles, TimeSpan& result);
    [NullableContextAttribute("2")]
public static bool TryParseExact(string input, String[] formats, IFormatProvider formatProvider, TimeSpan& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ObsoleteAttribute("System.TimeZone has been deprecated. Investigate the use of System.TimeZoneInfo instead.")]
public abstract class System.TimeZone : object {
    public static TimeZone CurrentTimeZone { get; }
    public string DaylightName { get; }
    public string StandardName { get; }
    public static TimeZone get_CurrentTimeZone();
    public abstract virtual string get_DaylightName();
    public abstract virtual string get_StandardName();
    public abstract virtual DaylightTime GetDaylightChanges(int year);
    public abstract virtual TimeSpan GetUtcOffset(DateTime time);
    public virtual bool IsDaylightSavingTime(DateTime time);
    public static bool IsDaylightSavingTime(DateTime time, DaylightTime daylightTimes);
    public virtual DateTime ToLocalTime(DateTime time);
    public virtual DateTime ToUniversalTime(DateTime time);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.TimeZoneInfo : object {
    public TimeSpan BaseUtcOffset { get; }
    public string DaylightName { get; }
    public string DisplayName { get; }
    public bool HasIanaId { get; }
    public string Id { get; }
    public static TimeZoneInfo Local { get; }
    public string StandardName { get; }
    public bool SupportsDaylightSavingTime { get; }
    public static TimeZoneInfo Utc { get; }
    public TimeSpan get_BaseUtcOffset();
    public string get_DaylightName();
    public string get_DisplayName();
    public bool get_HasIanaId();
    public string get_Id();
    public static TimeZoneInfo get_Local();
    public string get_StandardName();
    public bool get_SupportsDaylightSavingTime();
    public static TimeZoneInfo get_Utc();
    public static void ClearCachedData();
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTime(DateTime dateTime, TimeZoneInfo sourceTimeZone, TimeZoneInfo destinationTimeZone);
    public static DateTimeOffset ConvertTime(DateTimeOffset dateTimeOffset, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string destinationTimeZoneId);
    public static DateTime ConvertTimeBySystemTimeZoneId(DateTime dateTime, string sourceTimeZoneId, string destinationTimeZoneId);
    public static DateTimeOffset ConvertTimeBySystemTimeZoneId(DateTimeOffset dateTimeOffset, string destinationTimeZoneId);
    public static DateTime ConvertTimeFromUtc(DateTime dateTime, TimeZoneInfo destinationTimeZone);
    public static DateTime ConvertTimeToUtc(DateTime dateTime);
    public static DateTime ConvertTimeToUtc(DateTime dateTime, TimeZoneInfo sourceTimeZone);
    public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules);
    [NullableContextAttribute("2")]
public static TimeZoneInfo CreateCustomTimeZone(string id, TimeSpan baseUtcOffset, string displayName, string standardDisplayName, string daylightDisplayName, AdjustmentRule[] adjustmentRules, bool disableDaylightSavingTime);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(TimeZoneInfo other);
    public static TimeZoneInfo FindSystemTimeZoneById(string id);
    public static TimeZoneInfo FromSerializedString(string source);
    public AdjustmentRule[] GetAdjustmentRules();
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTime dateTime);
    public TimeSpan[] GetAmbiguousTimeOffsets(DateTimeOffset dateTimeOffset);
    public virtual int GetHashCode();
    public static ReadOnlyCollection`1<TimeZoneInfo> GetSystemTimeZones();
    public TimeSpan GetUtcOffset(DateTime dateTime);
    public TimeSpan GetUtcOffset(DateTimeOffset dateTimeOffset);
    public bool HasSameRules(TimeZoneInfo other);
    public bool IsAmbiguousTime(DateTime dateTime);
    public bool IsAmbiguousTime(DateTimeOffset dateTimeOffset);
    public bool IsDaylightSavingTime(DateTime dateTime);
    public bool IsDaylightSavingTime(DateTimeOffset dateTimeOffset);
    public bool IsInvalidTime(DateTime dateTime);
    private sealed virtual override void System.Runtime.Serialization.IDeserializationCallback.OnDeserialization(object sender);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public string ToSerializedString();
    public virtual string ToString();
    public static bool TryConvertIanaIdToWindowsId(string ianaId, String& windowsId);
    [NullableContextAttribute("2")]
public static bool TryConvertWindowsIdToIanaId(string windowsId, string region, String& ianaId);
    public static bool TryConvertWindowsIdToIanaId(string windowsId, String& ianaId);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.TimeZoneNotFoundException : Exception {
    [NullableContextAttribute("1")]
protected TimeZoneNotFoundException(SerializationInfo info, StreamingContext context);
    public TimeZoneNotFoundException(string message);
    public TimeZoneNotFoundException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Tuple : object {
    public static Tuple`1<T1> Create(T1 item1);
    public static Tuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static Tuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static Tuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static Tuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static Tuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
}
public class System.Tuple`1 : object {
    [NullableAttribute("1")]
public T1 Item1 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableContextAttribute("1")]
public Tuple`1(T1 item1);
    [NullableContextAttribute("1")]
public T1 get_Item1();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`2 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`2(T1 item1, T2 item2);
    public T1 get_Item1();
    public T2 get_Item2();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`3 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`3(T1 item1, T2 item2, T3 item3);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`4 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`5 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`6 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`7 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Tuple`8 : object {
    public T1 Item1 { get; }
    public T2 Item2 { get; }
    public T3 Item3 { get; }
    public T4 Item4 { get; }
    public T5 Item5 { get; }
    public T6 Item6 { get; }
    public T7 Item7 { get; }
    public TRest Rest { get; }
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public Tuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    public T1 get_Item1();
    public T2 get_Item2();
    public T3 get_Item3();
    public T4 get_Item4();
    public T5 get_Item5();
    public T6 get_Item6();
    public T7 get_Item7();
    public TRest get_Rest();
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object obj);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.TupleExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`1<T1> value, T1& item1);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`2<T1, T2> value, T1& item1, T2& item2);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9, T10& item10, T11& item11, T12& item12, T13& item13, T14& item14, T15& item15, T16& item16, T17& item17, T18& item18, T19& item19, T20& item20, T21& item21);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`3<T1, T2, T3> value, T1& item1, T2& item2, T3& item3);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`4<T1, T2, T3, T4> value, T1& item1, T2& item2, T3& item3, T4& item4);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`5<T1, T2, T3, T4, T5> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`6<T1, T2, T3, T4, T5, T6> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
[EditorBrowsableAttribute("1")]
public static void Deconstruct(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value, T1& item1, T2& item2, T3& item3, T4& item4, T5& item5, T6& item6, T7& item7, T8& item8, T9& item9);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static Tuple`1<T1> ToTuple(ValueTuple`1<T1> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static Tuple`2<T1, T2> ToTuple(ValueTuple`2<T1, T2> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static Tuple`3<T1, T2, T3> ToTuple(ValueTuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static Tuple`4<T1, T2, T3, T4> ToTuple(ValueTuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static Tuple`5<T1, T2, T3, T4, T5> ToTuple(ValueTuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static Tuple`6<T1, T2, T3, T4, T5, T6> ToTuple(ValueTuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static Tuple`7<T1, T2, T3, T4, T5, T6, T7> ToTuple(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> value);
    [ExtensionAttribute]
public static Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> ToTuple(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> value);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static ValueTuple`1<T1> ToValueTuple(Tuple`1<T1> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`3<T8, T9, T10>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`3<T8, T9, T10>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`4<T8, T9, T10, T11>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`4<T8, T9, T10, T11>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`5<T8, T9, T10, T11, T12>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`5<T8, T9, T10, T11, T12>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`6<T8, T9, T10, T11, T12, T13>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`6<T8, T9, T10, T11, T12, T13>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`7<T8, T9, T10, T11, T12, T13, T14>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`7<T8, T9, T10, T11, T12, T13, T14>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`1<T15>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`1<T15>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`2<T15, T16>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`2<T15, T16>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`3<T15, T16, T17>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`3<T15, T16, T17>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`4<T15, T16, T17, T18>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`4<T15, T16, T17, T18>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`5<T15, T16, T17, T18, T19>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`5<T15, T16, T17, T18, T19>>> value);
    [ExtensionAttribute]
public static ValueTuple`2<T1, T2> ToValueTuple(Tuple`2<T1, T2> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`6<T15, T16, T17, T18, T19, T20>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`6<T15, T16, T17, T18, T19, T20>>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`8<T8, T9, T10, T11, T12, T13, T14, ValueTuple`7<T15, T16, T17, T18, T19, T20, T21>>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`8<T8, T9, T10, T11, T12, T13, T14, Tuple`7<T15, T16, T17, T18, T19, T20, T21>>> value);
    [ExtensionAttribute]
public static ValueTuple`3<T1, T2, T3> ToValueTuple(Tuple`3<T1, T2, T3> value);
    [ExtensionAttribute]
public static ValueTuple`4<T1, T2, T3, T4> ToValueTuple(Tuple`4<T1, T2, T3, T4> value);
    [ExtensionAttribute]
public static ValueTuple`5<T1, T2, T3, T4, T5> ToValueTuple(Tuple`5<T1, T2, T3, T4, T5> value);
    [ExtensionAttribute]
public static ValueTuple`6<T1, T2, T3, T4, T5, T6> ToValueTuple(Tuple`6<T1, T2, T3, T4, T5, T6> value);
    [ExtensionAttribute]
public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> ToValueTuple(Tuple`7<T1, T2, T3, T4, T5, T6, T7> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`1<T8>> value);
    [ExtensionAttribute]
public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`2<T8, T9>> ToValueTuple(Tuple`8<T1, T2, T3, T4, T5, T6, T7, Tuple`2<T8, T9>> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Type : MemberInfo {
    public static char Delimiter;
    public static Type[] EmptyTypes;
    public static MemberFilter FilterAttribute;
    public static MemberFilter FilterName;
    public static MemberFilter FilterNameIgnoreCase;
    public static object Missing;
    public Assembly Assembly { get; }
    [NullableAttribute("2")]
public string AssemblyQualifiedName { get; }
    public TypeAttributes Attributes { get; }
    [NullableAttribute("2")]
public Type BaseType { get; }
    public bool ContainsGenericParameters { get; }
    [NullableAttribute("2")]
public MethodBase DeclaringMethod { get; }
    [NullableAttribute("2")]
public Type DeclaringType { get; }
    public static Binder DefaultBinder { get; }
    [NullableAttribute("2")]
public string FullName { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Type[] GenericTypeArguments { get; }
    public Guid GUID { get; }
    public bool HasElementType { get; }
    public bool IsAbstract { get; }
    public bool IsAnsiClass { get; }
    public bool IsArray { get; }
    public bool IsAutoClass { get; }
    public bool IsAutoLayout { get; }
    public bool IsByRef { get; }
    public bool IsByRefLike { get; }
    public bool IsClass { get; }
    public bool IsCOMObject { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsContextful { get; }
    public bool IsEnum { get; }
    public bool IsExplicitLayout { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericType { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsImport { get; }
    public bool IsInterface { get; }
    public bool IsLayoutSequential { get; }
    public bool IsMarshalByRef { get; }
    public bool IsNested { get; }
    public bool IsNestedAssembly { get; }
    public bool IsNestedFamANDAssem { get; }
    public bool IsNestedFamily { get; }
    public bool IsNestedFamORAssem { get; }
    public bool IsNestedPrivate { get; }
    public bool IsNestedPublic { get; }
    public bool IsNotPublic { get; }
    public bool IsPointer { get; }
    public bool IsPrimitive { get; }
    public bool IsPublic { get; }
    public bool IsSealed { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public bool IsSerializable { get; }
    public bool IsSignatureType { get; }
    public bool IsSpecialName { get; }
    public bool IsSZArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsUnicodeClass { get; }
    public bool IsValueType { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsVisible { get; }
    public MemberTypes MemberType { get; }
    public Module Module { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    [NullableAttribute("2")]
public Type ReflectedType { get; }
    [NullableAttribute("2")]
public StructLayoutAttribute StructLayoutAttribute { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    [NullableAttribute("2")]
public ConstructorInfo TypeInitializer { get; }
    public Type UnderlyingSystemType { get; }
    public abstract virtual Assembly get_Assembly();
    [NullableContextAttribute("2")]
public abstract virtual string get_AssemblyQualifiedName();
    public TypeAttributes get_Attributes();
    [NullableContextAttribute("2")]
public abstract virtual Type get_BaseType();
    public virtual bool get_ContainsGenericParameters();
    [NullableContextAttribute("2")]
public virtual MethodBase get_DeclaringMethod();
    [NullableContextAttribute("2")]
public virtual Type get_DeclaringType();
    public static Binder get_DefaultBinder();
    [NullableContextAttribute("2")]
public abstract virtual string get_FullName();
    public virtual GenericParameterAttributes get_GenericParameterAttributes();
    public virtual int get_GenericParameterPosition();
    public virtual Type[] get_GenericTypeArguments();
    public abstract virtual Guid get_GUID();
    public bool get_HasElementType();
    public bool get_IsAbstract();
    public bool get_IsAnsiClass();
    public bool get_IsArray();
    public bool get_IsAutoClass();
    public bool get_IsAutoLayout();
    public bool get_IsByRef();
    public virtual bool get_IsByRefLike();
    public bool get_IsClass();
    public bool get_IsCOMObject();
    public virtual bool get_IsConstructedGenericType();
    public bool get_IsContextful();
    public virtual bool get_IsEnum();
    public bool get_IsExplicitLayout();
    public virtual bool get_IsGenericMethodParameter();
    public virtual bool get_IsGenericParameter();
    public virtual bool get_IsGenericType();
    public virtual bool get_IsGenericTypeDefinition();
    public virtual bool get_IsGenericTypeParameter();
    public bool get_IsImport();
    public bool get_IsInterface();
    public bool get_IsLayoutSequential();
    public bool get_IsMarshalByRef();
    public bool get_IsNested();
    public bool get_IsNestedAssembly();
    public bool get_IsNestedFamANDAssem();
    public bool get_IsNestedFamily();
    public bool get_IsNestedFamORAssem();
    public bool get_IsNestedPrivate();
    public bool get_IsNestedPublic();
    public bool get_IsNotPublic();
    public bool get_IsPointer();
    public bool get_IsPrimitive();
    public bool get_IsPublic();
    public bool get_IsSealed();
    public virtual bool get_IsSecurityCritical();
    public virtual bool get_IsSecuritySafeCritical();
    public virtual bool get_IsSecurityTransparent();
    public virtual bool get_IsSerializable();
    public virtual bool get_IsSignatureType();
    public bool get_IsSpecialName();
    public virtual bool get_IsSZArray();
    public virtual bool get_IsTypeDefinition();
    public bool get_IsUnicodeClass();
    public bool get_IsValueType();
    public virtual bool get_IsVariableBoundArray();
    public bool get_IsVisible();
    public virtual MemberTypes get_MemberType();
    public abstract virtual Module get_Module();
    [NullableContextAttribute("2")]
public abstract virtual string get_Namespace();
    [NullableContextAttribute("2")]
public virtual Type get_ReflectedType();
    [NullableContextAttribute("2")]
public virtual StructLayoutAttribute get_StructLayoutAttribute();
    public virtual RuntimeTypeHandle get_TypeHandle();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo get_TypeInitializer();
    public abstract virtual Type get_UnderlyingSystemType();
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    [NullableContextAttribute("2")]
public virtual bool Equals(Type o);
    [DynamicallyAccessedMembersAttribute("8192")]
public virtual Type[] FindInterfaces(TypeFilter filter, object filterCriteria);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public virtual MemberInfo[] FindMembers(MemberTypes memberType, BindingFlags bindingAttr, MemberFilter filter, object filterCriteria);
    public virtual int GetArrayRank();
    protected abstract virtual TypeAttributes GetAttributeFlagsImpl();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("7")]
public ConstructorInfo GetConstructor(BindingFlags bindingAttr, Type[] types);
    [DynamicallyAccessedMembersAttribute("3")]
public ConstructorInfo GetConstructor(Type[] types);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("7")]
protected abstract virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("3")]
public ConstructorInfo[] GetConstructors();
    [DynamicallyAccessedMembersAttribute("7")]
public abstract virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2731")]
public virtual MemberInfo[] GetDefaultMembers();
    [NullableContextAttribute("2")]
public abstract virtual Type GetElementType();
    public virtual string GetEnumName(object value);
    public virtual String[] GetEnumNames();
    public virtual Type GetEnumUnderlyingType();
    [RequiresDynamicCodeAttribute("It might not be possible to create an array of the enum type at runtime. Use the GetEnumValues<TEnum> overload or the GetEnumValuesAsUnderlyingType method instead.")]
public virtual Array GetEnumValues();
    public virtual Array GetEnumValuesAsUnderlyingType();
    [DynamicallyAccessedMembersAttribute("2048")]
public EventInfo GetEvent(string name);
    [DynamicallyAccessedMembersAttribute("6144")]
public abstract virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2048")]
public virtual EventInfo[] GetEvents();
    [DynamicallyAccessedMembersAttribute("6144")]
public abstract virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("32")]
public FieldInfo GetField(string name);
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("32")]
public FieldInfo[] GetFields();
    [DynamicallyAccessedMembersAttribute("96")]
public abstract virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public virtual Type[] GetGenericArguments();
    public virtual Type[] GetGenericParameterConstraints();
    public virtual Type GetGenericTypeDefinition();
    public virtual int GetHashCode();
    [DynamicallyAccessedMembersAttribute("8192")]
public Type GetInterface(string name);
    [DynamicallyAccessedMembersAttribute("8192")]
public abstract virtual Type GetInterface(string name, bool ignoreCase);
    public virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    [DynamicallyAccessedMembersAttribute("8192")]
public abstract virtual Type[] GetInterfaces();
    [DynamicallyAccessedMembersAttribute("2731")]
public MemberInfo[] GetMember(string name);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("8191")]
public virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("2731")]
public MemberInfo[] GetMembers();
    [DynamicallyAccessedMembersAttribute("8191")]
public abstract virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public virtual MemberInfo GetMemberWithSameMetadataDefinitionAs(MemberInfo member);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, int genericParameterCount, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
public sealed virtual MethodInfo GetMethod(string name, BindingFlags bindingAttr, Binder binder, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("24")]
public MethodInfo GetMethod(string name, BindingFlags bindingAttr, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, Type[] types);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo GetMethod(string name, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("24")]
protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("8")]
public MethodInfo[] GetMethods();
    [DynamicallyAccessedMembersAttribute("24")]
public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("128")]
public Type GetNestedType(string name);
    [DynamicallyAccessedMembersAttribute("384")]
public abstract virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("128")]
public Type[] GetNestedTypes();
    [DynamicallyAccessedMembersAttribute("384")]
public abstract virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo[] GetProperties();
    [DynamicallyAccessedMembersAttribute("1536")]
public abstract virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name);
    [DynamicallyAccessedMembersAttribute("1536")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
public sealed virtual PropertyInfo GetProperty(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type returnType);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type returnType, Type[] types);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type returnType, Type[] types, ParameterModifier[] modifiers);
    [DynamicallyAccessedMembersAttribute("512")]
public PropertyInfo GetProperty(string name, Type[] types);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("1536")]
protected abstract virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    public Type GetType();
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, bool throwOnError, bool ignoreCase);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError);
    [RequiresUnreferencedCodeAttribute("The type might be removed")]
public static Type GetType(string typeName, Func`2<AssemblyName, Assembly> assemblyResolver, Func`4<Assembly, string, bool, Type> typeResolver, bool throwOnError, bool ignoreCase);
    public static Type[] GetTypeArray(Object[] args);
    [NullableContextAttribute("2")]
public static TypeCode GetTypeCode(Type type);
    protected virtual TypeCode GetTypeCodeImpl();
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, bool throwOnError);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, string server);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromCLSID(Guid clsid, string server, bool throwOnError);
    [NullableContextAttribute("2")]
public static Type GetTypeFromHandle(RuntimeTypeHandle handle);
    [SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID);
    [SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, bool throwOnError);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, string server);
    [NullableContextAttribute("2")]
[SupportedOSPlatformAttribute("windows")]
public static Type GetTypeFromProgID(string progID, string server, bool throwOnError);
    public static RuntimeTypeHandle GetTypeHandle(object o);
    protected abstract virtual bool HasElementTypeImpl();
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, CultureInfo culture);
    [NullableContextAttribute("2")]
[DynamicallyAccessedMembersAttribute("-1")]
public abstract virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    protected abstract virtual bool IsArrayImpl();
    [NullableContextAttribute("2")]
public virtual bool IsAssignableFrom(Type c);
    [NullableContextAttribute("2")]
public bool IsAssignableTo(Type targetType);
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsCOMObjectImpl();
    protected virtual bool IsContextfulImpl();
    public virtual bool IsEnumDefined(object value);
    [NullableContextAttribute("2")]
public virtual bool IsEquivalentTo(Type other);
    [NullableContextAttribute("2")]
public virtual bool IsInstanceOfType(object o);
    protected virtual bool IsMarshalByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    protected abstract virtual bool IsPrimitiveImpl();
    public virtual bool IsSubclassOf(Type c);
    protected virtual bool IsValueTypeImpl();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType();
    [RequiresDynamicCodeAttribute("The code for an array of the specified type might not be available.")]
public virtual Type MakeArrayType(int rank);
    public virtual Type MakeByRefType();
    public static Type MakeGenericMethodParameter(int position);
    public static Type MakeGenericSignatureType(Type genericTypeDefinition, Type[] typeArguments);
    [RequiresDynamicCodeAttribute("The native code for this instantiation might not be available at runtime.")]
[RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public virtual Type MakeGenericType(Type[] typeArguments);
    public virtual Type MakePointerType();
    [NullableContextAttribute("2")]
public static bool op_Equality(Type left, Type right);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Type left, Type right);
    [ObsoleteAttribute("ReflectionOnly loading is not supported and throws PlatformNotSupportedException.")]
public static Type ReflectionOnlyGetType(string typeName, bool throwIfNotFound, bool ignoreCase);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.TypeAccessException : TypeLoadException {
    [NullableContextAttribute("1")]
protected TypeAccessException(SerializationInfo info, StreamingContext context);
    public TypeAccessException(string message);
    public TypeAccessException(string message, Exception inner);
}
public enum System.TypeCode : Enum {
    public int value__;
    public static TypeCode Empty;
    public static TypeCode Object;
    public static TypeCode DBNull;
    public static TypeCode Boolean;
    public static TypeCode Char;
    public static TypeCode SByte;
    public static TypeCode Byte;
    public static TypeCode Int16;
    public static TypeCode UInt16;
    public static TypeCode Int32;
    public static TypeCode UInt32;
    public static TypeCode Int64;
    public static TypeCode UInt64;
    public static TypeCode Single;
    public static TypeCode Double;
    public static TypeCode Decimal;
    public static TypeCode DateTime;
    public static TypeCode String;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsByRefLikeAttribute]
[CLSCompliantAttribute("False")]
public class System.TypedReference : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    [NullableContextAttribute("2")]
public virtual bool Equals(object o);
    public virtual int GetHashCode();
    public static Type GetTargetType(TypedReference value);
    public static TypedReference MakeTypedReference(object target, FieldInfo[] flds);
    [NullableContextAttribute("2")]
public static void SetTypedReference(TypedReference target, object value);
    public static RuntimeTypeHandle TargetTypeToken(TypedReference value);
    public static object ToObject(TypedReference value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.TypeInitializationException : SystemException {
    public string TypeName { get; }
    [NullableContextAttribute("2")]
public TypeInitializationException(string fullTypeName, Exception innerException);
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.TypeLoadException : SystemException {
    public string Message { get; }
    public string TypeName { get; }
    protected TypeLoadException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
public TypeLoadException(string message);
    [NullableContextAttribute("2")]
public TypeLoadException(string message, Exception inner);
    public virtual string get_Message();
    public string get_TypeName();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.TypeUnloadedException : SystemException {
    [NullableContextAttribute("1")]
protected TypeUnloadedException(SerializationInfo info, StreamingContext context);
    public TypeUnloadedException(string message);
    public TypeUnloadedException(string message, Exception innerException);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt128 : ValueType {
    private int _dummyPrimitive;
    public static UInt128 MaxValue { get; }
    public static UInt128 MinValue { get; }
    public static UInt128 One { get; }
    private static UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.AdditiveIdentity { get; }
    private static UInt128 System.Numerics.IBinaryNumber<System.UInt128>.AllBitsSet { get; }
    private static UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.MultiplicativeIdentity { get; }
    private static int System.Numerics.INumberBase<System.UInt128>.Radix { get; }
    public static UInt128 Zero { get; }
    [CLSCompliantAttribute("False")]
public UInt128(ulong upper, ulong lower);
    public static override UInt128 get_MaxValue();
    public static override UInt128 get_MinValue();
    public static override UInt128 get_One();
    private static override UInt128 System.Numerics.IAdditiveIdentity<System.UInt128,System.UInt128>.get_AdditiveIdentity();
    private static override UInt128 System.Numerics.IBinaryNumber<System.UInt128>.get_AllBitsSet();
    private static override UInt128 System.Numerics.IMultiplicativeIdentity<System.UInt128,System.UInt128>.get_MultiplicativeIdentity();
    private static override int System.Numerics.INumberBase<System.UInt128>.get_Radix();
    public static override UInt128 get_Zero();
    public static override UInt128 Clamp(UInt128 value, UInt128 min, UInt128 max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt128 value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UInt128 CreateTruncating(TOther value);
    public static override ValueTuple`2<UInt128, UInt128> DivRem(UInt128 left, UInt128 right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt128 other);
    public virtual int GetHashCode();
    public static override bool IsEvenInteger(UInt128 value);
    public static override bool IsOddInteger(UInt128 value);
    public static override bool IsPow2(UInt128 value);
    public static override UInt128 LeadingZeroCount(UInt128 value);
    public static override UInt128 Log2(UInt128 value);
    public static override UInt128 Max(UInt128 x, UInt128 y);
    public static override UInt128 Min(UInt128 x, UInt128 y);
    public static override UInt128 op_Addition(UInt128 left, UInt128 right);
    public static override UInt128 op_BitwiseAnd(UInt128 left, UInt128 right);
    public static override UInt128 op_BitwiseOr(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedAddition(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedDecrement(UInt128 value);
    public static override UInt128 op_CheckedDivision(UInt128 left, UInt128 right);
    public static UInt128 op_CheckedExplicit(double value);
    public static UInt128 op_CheckedExplicit(short value);
    public static UInt128 op_CheckedExplicit(int value);
    public static UInt128 op_CheckedExplicit(long value);
    public static UInt128 op_CheckedExplicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_CheckedExplicit(sbyte value);
    public static UInt128 op_CheckedExplicit(float value);
    public static byte op_CheckedExplicit(UInt128 value);
    public static char op_CheckedExplicit(UInt128 value);
    public static short op_CheckedExplicit(UInt128 value);
    public static int op_CheckedExplicit(UInt128 value);
    public static long op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_CheckedExplicit(UInt128 value);
    public static IntPtr op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_CheckedExplicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_CheckedExplicit(UInt128 value);
    public static override UInt128 op_CheckedIncrement(UInt128 value);
    public static override UInt128 op_CheckedMultiply(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedSubtraction(UInt128 left, UInt128 right);
    public static override UInt128 op_CheckedUnaryNegation(UInt128 value);
    public static override UInt128 op_Decrement(UInt128 value);
    public static override UInt128 op_Division(UInt128 left, UInt128 right);
    public static override bool op_Equality(UInt128 left, UInt128 right);
    public static override UInt128 op_ExclusiveOr(UInt128 left, UInt128 right);
    public static UInt128 op_Explicit(decimal value);
    public static UInt128 op_Explicit(double value);
    public static UInt128 op_Explicit(short value);
    public static UInt128 op_Explicit(int value);
    public static UInt128 op_Explicit(long value);
    public static UInt128 op_Explicit(IntPtr value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Explicit(sbyte value);
    public static UInt128 op_Explicit(float value);
    public static byte op_Explicit(UInt128 value);
    public static char op_Explicit(UInt128 value);
    public static decimal op_Explicit(UInt128 value);
    public static double op_Explicit(UInt128 value);
    public static Half op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static Int128 op_Explicit(UInt128 value);
    public static short op_Explicit(UInt128 value);
    public static int op_Explicit(UInt128 value);
    public static long op_Explicit(UInt128 value);
    public static IntPtr op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(UInt128 value);
    public static float op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(UInt128 value);
    [CLSCompliantAttribute("False")]
public static UIntPtr op_Explicit(UInt128 value);
    public static override bool op_GreaterThan(UInt128 left, UInt128 right);
    public static override bool op_GreaterThanOrEqual(UInt128 left, UInt128 right);
    public static UInt128 op_Implicit(byte value);
    public static UInt128 op_Implicit(char value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(ulong value);
    [CLSCompliantAttribute("False")]
public static UInt128 op_Implicit(UIntPtr value);
    public static override UInt128 op_Increment(UInt128 value);
    public static override bool op_Inequality(UInt128 left, UInt128 right);
    public static override UInt128 op_LeftShift(UInt128 value, int shiftAmount);
    public static override bool op_LessThan(UInt128 left, UInt128 right);
    public static override bool op_LessThanOrEqual(UInt128 left, UInt128 right);
    public static override UInt128 op_Modulus(UInt128 left, UInt128 right);
    public static override UInt128 op_Multiply(UInt128 left, UInt128 right);
    public static override UInt128 op_OnesComplement(UInt128 value);
    public static override UInt128 op_RightShift(UInt128 value, int shiftAmount);
    public static override UInt128 op_Subtraction(UInt128 left, UInt128 right);
    public static override UInt128 op_UnaryNegation(UInt128 value);
    public static override UInt128 op_UnaryPlus(UInt128 value);
    public static override UInt128 op_UnsignedRightShift(UInt128 value, int shiftAmount);
    public static override UInt128 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override UInt128 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UInt128 Parse(string s);
    [NullableContextAttribute("1")]
public static UInt128 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UInt128 Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UInt128 Parse(string s, IFormatProvider provider);
    public static override UInt128 PopCount(UInt128 value);
    public static override UInt128 RotateLeft(UInt128 value, int rotateAmount);
    public static override UInt128 RotateRight(UInt128 value, int rotateAmount);
    public static override int Sign(UInt128 value);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt128>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt128>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt128& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt128>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt128& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt128>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.Abs(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsCanonical(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsComplexNumber(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsFinite(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsImaginaryNumber(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsInteger(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNaN(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNegative(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNegativeInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsNormal(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsPositive(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsPositiveInfinity(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsRealNumber(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsSubnormal(UInt128 value);
    private static override bool System.Numerics.INumberBase<System.UInt128>.IsZero(UInt128 value);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitude(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MaxMagnitudeNumber(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitude(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumberBase<System.UInt128>.MinMagnitudeNumber(UInt128 x, UInt128 y);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromChecked(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromSaturating(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertFromTruncating(TOther value, UInt128& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToChecked(UInt128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToSaturating(UInt128 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt128>.TryConvertToTruncating(UInt128 value, TOther& result);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.CopySign(UInt128 value, UInt128 sign);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.MaxNumber(UInt128 x, UInt128 y);
    private static override UInt128 System.Numerics.INumber<System.UInt128>.MinNumber(UInt128 x, UInt128 y);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override UInt128 TrailingZeroCount(UInt128 value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt128& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt128& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt128& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt128& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt128& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt16 : ValueType {
    private ushort _dummyPrimitive;
    public static ushort MaxValue;
    public static ushort MinValue;
    private static ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.AdditiveIdentity { get; }
    private static ushort System.Numerics.IBinaryNumber<System.UInt16>.AllBitsSet { get; }
    private static ushort System.Numerics.IMinMaxValue<System.UInt16>.MaxValue { get; }
    private static ushort System.Numerics.IMinMaxValue<System.UInt16>.MinValue { get; }
    private static ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.MultiplicativeIdentity { get; }
    private static ushort System.Numerics.INumberBase<System.UInt16>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt16>.Radix { get; }
    private static ushort System.Numerics.INumberBase<System.UInt16>.Zero { get; }
    private static override ushort System.Numerics.IAdditiveIdentity<System.UInt16,System.UInt16>.get_AdditiveIdentity();
    private static override ushort System.Numerics.IBinaryNumber<System.UInt16>.get_AllBitsSet();
    private static override ushort System.Numerics.IMinMaxValue<System.UInt16>.get_MaxValue();
    private static override ushort System.Numerics.IMinMaxValue<System.UInt16>.get_MinValue();
    private static override ushort System.Numerics.IMultiplicativeIdentity<System.UInt16,System.UInt16>.get_MultiplicativeIdentity();
    private static override ushort System.Numerics.INumberBase<System.UInt16>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt16>.get_Radix();
    private static override ushort System.Numerics.INumberBase<System.UInt16>.get_Zero();
    public static override ushort Clamp(ushort value, ushort min, ushort max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ushort value);
    [NullableContextAttribute("1")]
public static override ushort CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override ushort CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override ushort CreateTruncating(TOther value);
    public static override ValueTuple`2<ushort, ushort> DivRem(ushort left, ushort right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ushort obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(ushort value);
    public static override bool IsOddInteger(ushort value);
    public static override bool IsPow2(ushort value);
    public static override ushort LeadingZeroCount(ushort value);
    public static override ushort Log2(ushort value);
    public static override ushort Max(ushort x, ushort y);
    public static override ushort Min(ushort x, ushort y);
    public static override ushort Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override ushort Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static ushort Parse(string s);
    [NullableContextAttribute("1")]
public static ushort Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override ushort Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override ushort Parse(string s, IFormatProvider provider);
    public static override ushort PopCount(ushort value);
    public static override ushort RotateLeft(ushort value, int rotateAmount);
    public static override ushort RotateRight(ushort value, int rotateAmount);
    public static override int Sign(ushort value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override ushort System.Numerics.IAdditionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Addition(ushort left, ushort right);
    private static override ushort System.Numerics.IAdditionOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedAddition(ushort left, ushort right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt16>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt16>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.UInt16>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt16& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt16>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt16& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt16>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_BitwiseAnd(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_BitwiseOr(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_ExclusiveOr(ushort left, ushort right);
    private static override ushort System.Numerics.IBitwiseOperators<System.UInt16,System.UInt16,System.UInt16>.op_OnesComplement(ushort value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_GreaterThan(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_GreaterThanOrEqual(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_LessThan(ushort left, ushort right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt16,System.UInt16,System.Boolean>.op_LessThanOrEqual(ushort left, ushort right);
    private static override ushort System.Numerics.IDecrementOperators<System.UInt16>.op_CheckedDecrement(ushort value);
    private static override ushort System.Numerics.IDecrementOperators<System.UInt16>.op_Decrement(ushort value);
    private static override ushort System.Numerics.IDivisionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Division(ushort left, ushort right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt16,System.UInt16,System.Boolean>.op_Equality(ushort left, ushort right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt16,System.UInt16,System.Boolean>.op_Inequality(ushort left, ushort right);
    private static override ushort System.Numerics.IIncrementOperators<System.UInt16>.op_CheckedIncrement(ushort value);
    private static override ushort System.Numerics.IIncrementOperators<System.UInt16>.op_Increment(ushort value);
    private static override ushort System.Numerics.IModulusOperators<System.UInt16,System.UInt16,System.UInt16>.op_Modulus(ushort left, ushort right);
    private static override ushort System.Numerics.IMultiplyOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedMultiply(ushort left, ushort right);
    private static override ushort System.Numerics.IMultiplyOperators<System.UInt16,System.UInt16,System.UInt16>.op_Multiply(ushort left, ushort right);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.Abs(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsCanonical(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsComplexNumber(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsFinite(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsImaginaryNumber(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsInteger(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNaN(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNegative(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNegativeInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsNormal(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsPositive(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsPositiveInfinity(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsRealNumber(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsSubnormal(ushort value);
    private static override bool System.Numerics.INumberBase<System.UInt16>.IsZero(ushort value);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MaxMagnitude(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MaxMagnitudeNumber(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MinMagnitude(ushort x, ushort y);
    private static override ushort System.Numerics.INumberBase<System.UInt16>.MinMagnitudeNumber(ushort x, ushort y);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromChecked(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromSaturating(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertFromTruncating(TOther value, UInt16& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToChecked(ushort value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToSaturating(ushort value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt16>.TryConvertToTruncating(ushort value, TOther& result);
    private static override ushort System.Numerics.INumber<System.UInt16>.CopySign(ushort value, ushort sign);
    private static override ushort System.Numerics.INumber<System.UInt16>.MaxNumber(ushort x, ushort y);
    private static override ushort System.Numerics.INumber<System.UInt16>.MinNumber(ushort x, ushort y);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_LeftShift(ushort value, int shiftAmount);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_RightShift(ushort value, int shiftAmount);
    private static override ushort System.Numerics.IShiftOperators<System.UInt16,System.Int32,System.UInt16>.op_UnsignedRightShift(ushort value, int shiftAmount);
    private static override ushort System.Numerics.ISubtractionOperators<System.UInt16,System.UInt16,System.UInt16>.op_CheckedSubtraction(ushort left, ushort right);
    private static override ushort System.Numerics.ISubtractionOperators<System.UInt16,System.UInt16,System.UInt16>.op_Subtraction(ushort left, ushort right);
    private static override ushort System.Numerics.IUnaryNegationOperators<System.UInt16,System.UInt16>.op_CheckedUnaryNegation(ushort value);
    private static override ushort System.Numerics.IUnaryNegationOperators<System.UInt16,System.UInt16>.op_UnaryNegation(ushort value);
    private static override ushort System.Numerics.IUnaryPlusOperators<System.UInt16,System.UInt16>.op_UnaryPlus(ushort value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override ushort TrailingZeroCount(ushort value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt16& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt16& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt16& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt16& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt16& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt32 : ValueType {
    private UInt32 _dummyPrimitive;
    public static UInt32 MaxValue;
    public static UInt32 MinValue;
    private static UInt32 System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.AdditiveIdentity { get; }
    private static UInt32 System.Numerics.IBinaryNumber<System.UInt32>.AllBitsSet { get; }
    private static UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MaxValue { get; }
    private static UInt32 System.Numerics.IMinMaxValue<System.UInt32>.MinValue { get; }
    private static UInt32 System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.MultiplicativeIdentity { get; }
    private static UInt32 System.Numerics.INumberBase<System.UInt32>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt32>.Radix { get; }
    private static UInt32 System.Numerics.INumberBase<System.UInt32>.Zero { get; }
    private static override UInt32 System.Numerics.IAdditiveIdentity<System.UInt32,System.UInt32>.get_AdditiveIdentity();
    private static override UInt32 System.Numerics.IBinaryNumber<System.UInt32>.get_AllBitsSet();
    private static override UInt32 System.Numerics.IMinMaxValue<System.UInt32>.get_MaxValue();
    private static override UInt32 System.Numerics.IMinMaxValue<System.UInt32>.get_MinValue();
    private static override UInt32 System.Numerics.IMultiplicativeIdentity<System.UInt32,System.UInt32>.get_MultiplicativeIdentity();
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt32>.get_Radix();
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.get_Zero();
    public static override UInt32 Clamp(UInt32 value, UInt32 min, UInt32 max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UInt32 value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UInt32 CreateTruncating(TOther value);
    public static override ValueTuple`2<UInt32, UInt32> DivRem(UInt32 left, UInt32 right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UInt32 obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(UInt32 value);
    public static override bool IsOddInteger(UInt32 value);
    public static override bool IsPow2(UInt32 value);
    public static override UInt32 LeadingZeroCount(UInt32 value);
    public static override UInt32 Log2(UInt32 value);
    public static override UInt32 Max(UInt32 x, UInt32 y);
    public static override UInt32 Min(UInt32 x, UInt32 y);
    public static override UInt32 Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override UInt32 Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UInt32 Parse(string s);
    [NullableContextAttribute("1")]
public static UInt32 Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UInt32 Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UInt32 Parse(string s, IFormatProvider provider);
    public static override UInt32 PopCount(UInt32 value);
    public static override UInt32 RotateLeft(UInt32 value, int rotateAmount);
    public static override UInt32 RotateRight(UInt32 value, int rotateAmount);
    public static override int Sign(UInt32 value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override UInt32 System.Numerics.IAdditionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Addition(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IAdditionOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedAddition(UInt32 left, UInt32 right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt32>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt32>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.UInt32>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt32& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt32>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt32& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt32>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_BitwiseAnd(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_BitwiseOr(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_ExclusiveOr(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IBitwiseOperators<System.UInt32,System.UInt32,System.UInt32>.op_OnesComplement(UInt32 value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_GreaterThan(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_GreaterThanOrEqual(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_LessThan(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt32,System.UInt32,System.Boolean>.op_LessThanOrEqual(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IDecrementOperators<System.UInt32>.op_CheckedDecrement(UInt32 value);
    private static override UInt32 System.Numerics.IDecrementOperators<System.UInt32>.op_Decrement(UInt32 value);
    private static override UInt32 System.Numerics.IDivisionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Division(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt32,System.UInt32,System.Boolean>.op_Equality(UInt32 left, UInt32 right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt32,System.UInt32,System.Boolean>.op_Inequality(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IIncrementOperators<System.UInt32>.op_CheckedIncrement(UInt32 value);
    private static override UInt32 System.Numerics.IIncrementOperators<System.UInt32>.op_Increment(UInt32 value);
    private static override UInt32 System.Numerics.IModulusOperators<System.UInt32,System.UInt32,System.UInt32>.op_Modulus(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IMultiplyOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedMultiply(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IMultiplyOperators<System.UInt32,System.UInt32,System.UInt32>.op_Multiply(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.Abs(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsCanonical(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsComplexNumber(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsFinite(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsImaginaryNumber(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsInteger(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNaN(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNegative(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNegativeInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsNormal(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsPositive(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsPositiveInfinity(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsRealNumber(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsSubnormal(UInt32 value);
    private static override bool System.Numerics.INumberBase<System.UInt32>.IsZero(UInt32 value);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MaxMagnitude(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MaxMagnitudeNumber(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MinMagnitude(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumberBase<System.UInt32>.MinMagnitudeNumber(UInt32 x, UInt32 y);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromChecked(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromSaturating(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertFromTruncating(TOther value, UInt32& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToChecked(UInt32 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToSaturating(UInt32 value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt32>.TryConvertToTruncating(UInt32 value, TOther& result);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.CopySign(UInt32 value, UInt32 sign);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.MaxNumber(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.INumber<System.UInt32>.MinNumber(UInt32 x, UInt32 y);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_LeftShift(UInt32 value, int shiftAmount);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_RightShift(UInt32 value, int shiftAmount);
    private static override UInt32 System.Numerics.IShiftOperators<System.UInt32,System.Int32,System.UInt32>.op_UnsignedRightShift(UInt32 value, int shiftAmount);
    private static override UInt32 System.Numerics.ISubtractionOperators<System.UInt32,System.UInt32,System.UInt32>.op_CheckedSubtraction(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.ISubtractionOperators<System.UInt32,System.UInt32,System.UInt32>.op_Subtraction(UInt32 left, UInt32 right);
    private static override UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32,System.UInt32>.op_CheckedUnaryNegation(UInt32 value);
    private static override UInt32 System.Numerics.IUnaryNegationOperators<System.UInt32,System.UInt32>.op_UnaryNegation(UInt32 value);
    private static override UInt32 System.Numerics.IUnaryPlusOperators<System.UInt32,System.UInt32>.op_UnaryPlus(UInt32 value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override UInt32 TrailingZeroCount(UInt32 value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt32& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt32& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt32& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt32& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt32& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UInt64 : ValueType {
    private ulong _dummyPrimitive;
    public static ulong MaxValue;
    public static ulong MinValue;
    private static ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.AdditiveIdentity { get; }
    private static ulong System.Numerics.IBinaryNumber<System.UInt64>.AllBitsSet { get; }
    private static ulong System.Numerics.IMinMaxValue<System.UInt64>.MaxValue { get; }
    private static ulong System.Numerics.IMinMaxValue<System.UInt64>.MinValue { get; }
    private static ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.MultiplicativeIdentity { get; }
    private static ulong System.Numerics.INumberBase<System.UInt64>.One { get; }
    private static int System.Numerics.INumberBase<System.UInt64>.Radix { get; }
    private static ulong System.Numerics.INumberBase<System.UInt64>.Zero { get; }
    private static override ulong System.Numerics.IAdditiveIdentity<System.UInt64,System.UInt64>.get_AdditiveIdentity();
    private static override ulong System.Numerics.IBinaryNumber<System.UInt64>.get_AllBitsSet();
    private static override ulong System.Numerics.IMinMaxValue<System.UInt64>.get_MaxValue();
    private static override ulong System.Numerics.IMinMaxValue<System.UInt64>.get_MinValue();
    private static override ulong System.Numerics.IMultiplicativeIdentity<System.UInt64,System.UInt64>.get_MultiplicativeIdentity();
    private static override ulong System.Numerics.INumberBase<System.UInt64>.get_One();
    private static override int System.Numerics.INumberBase<System.UInt64>.get_Radix();
    private static override ulong System.Numerics.INumberBase<System.UInt64>.get_Zero();
    public static override ulong Clamp(ulong value, ulong min, ulong max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(ulong value);
    [NullableContextAttribute("1")]
public static override ulong CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override ulong CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override ulong CreateTruncating(TOther value);
    public static override ValueTuple`2<ulong, ulong> DivRem(ulong left, ulong right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ulong obj);
    public virtual int GetHashCode();
    public sealed virtual TypeCode GetTypeCode();
    public static override bool IsEvenInteger(ulong value);
    public static override bool IsOddInteger(ulong value);
    public static override bool IsPow2(ulong value);
    public static override ulong LeadingZeroCount(ulong value);
    public static override ulong Log2(ulong value);
    public static override ulong Max(ulong x, ulong y);
    public static override ulong Min(ulong x, ulong y);
    public static override ulong Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override ulong Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static ulong Parse(string s);
    [NullableContextAttribute("1")]
public static ulong Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override ulong Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override ulong Parse(string s, IFormatProvider provider);
    public static override ulong PopCount(ulong value);
    public static override ulong RotateLeft(ulong value, int rotateAmount);
    public static override ulong RotateRight(ulong value, int rotateAmount);
    public static override int Sign(ulong value);
    private sealed virtual override bool System.IConvertible.ToBoolean(IFormatProvider provider);
    private sealed virtual override byte System.IConvertible.ToByte(IFormatProvider provider);
    private sealed virtual override char System.IConvertible.ToChar(IFormatProvider provider);
    private sealed virtual override DateTime System.IConvertible.ToDateTime(IFormatProvider provider);
    private sealed virtual override decimal System.IConvertible.ToDecimal(IFormatProvider provider);
    private sealed virtual override double System.IConvertible.ToDouble(IFormatProvider provider);
    private sealed virtual override short System.IConvertible.ToInt16(IFormatProvider provider);
    private sealed virtual override int System.IConvertible.ToInt32(IFormatProvider provider);
    private sealed virtual override long System.IConvertible.ToInt64(IFormatProvider provider);
    private sealed virtual override sbyte System.IConvertible.ToSByte(IFormatProvider provider);
    private sealed virtual override float System.IConvertible.ToSingle(IFormatProvider provider);
    private sealed virtual override object System.IConvertible.ToType(Type type, IFormatProvider provider);
    private sealed virtual override ushort System.IConvertible.ToUInt16(IFormatProvider provider);
    private sealed virtual override UInt32 System.IConvertible.ToUInt32(IFormatProvider provider);
    private sealed virtual override ulong System.IConvertible.ToUInt64(IFormatProvider provider);
    private static override ulong System.Numerics.IAdditionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Addition(ulong left, ulong right);
    private static override ulong System.Numerics.IAdditionOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedAddition(ulong left, ulong right);
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt64>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<System.UInt64>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<System.UInt64>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt64& value);
    private static override bool System.Numerics.IBinaryInteger<System.UInt64>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UInt64& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<System.UInt64>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_BitwiseAnd(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_BitwiseOr(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_ExclusiveOr(ulong left, ulong right);
    private static override ulong System.Numerics.IBitwiseOperators<System.UInt64,System.UInt64,System.UInt64>.op_OnesComplement(ulong value);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_GreaterThan(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_GreaterThanOrEqual(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_LessThan(ulong left, ulong right);
    private static override bool System.Numerics.IComparisonOperators<System.UInt64,System.UInt64,System.Boolean>.op_LessThanOrEqual(ulong left, ulong right);
    private static override ulong System.Numerics.IDecrementOperators<System.UInt64>.op_CheckedDecrement(ulong value);
    private static override ulong System.Numerics.IDecrementOperators<System.UInt64>.op_Decrement(ulong value);
    private static override ulong System.Numerics.IDivisionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Division(ulong left, ulong right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt64,System.UInt64,System.Boolean>.op_Equality(ulong left, ulong right);
    private static override bool System.Numerics.IEqualityOperators<System.UInt64,System.UInt64,System.Boolean>.op_Inequality(ulong left, ulong right);
    private static override ulong System.Numerics.IIncrementOperators<System.UInt64>.op_CheckedIncrement(ulong value);
    private static override ulong System.Numerics.IIncrementOperators<System.UInt64>.op_Increment(ulong value);
    private static override ulong System.Numerics.IModulusOperators<System.UInt64,System.UInt64,System.UInt64>.op_Modulus(ulong left, ulong right);
    private static override ulong System.Numerics.IMultiplyOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedMultiply(ulong left, ulong right);
    private static override ulong System.Numerics.IMultiplyOperators<System.UInt64,System.UInt64,System.UInt64>.op_Multiply(ulong left, ulong right);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.Abs(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsCanonical(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsComplexNumber(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsFinite(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsImaginaryNumber(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsInteger(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNaN(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNegative(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNegativeInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsNormal(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsPositive(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsPositiveInfinity(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsRealNumber(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsSubnormal(ulong value);
    private static override bool System.Numerics.INumberBase<System.UInt64>.IsZero(ulong value);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MaxMagnitude(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MaxMagnitudeNumber(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MinMagnitude(ulong x, ulong y);
    private static override ulong System.Numerics.INumberBase<System.UInt64>.MinMagnitudeNumber(ulong x, ulong y);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromChecked(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromSaturating(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertFromTruncating(TOther value, UInt64& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToChecked(ulong value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToSaturating(ulong value, TOther& result);
    private static override bool System.Numerics.INumberBase<System.UInt64>.TryConvertToTruncating(ulong value, TOther& result);
    private static override ulong System.Numerics.INumber<System.UInt64>.CopySign(ulong value, ulong sign);
    private static override ulong System.Numerics.INumber<System.UInt64>.MaxNumber(ulong x, ulong y);
    private static override ulong System.Numerics.INumber<System.UInt64>.MinNumber(ulong x, ulong y);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_LeftShift(ulong value, int shiftAmount);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_RightShift(ulong value, int shiftAmount);
    private static override ulong System.Numerics.IShiftOperators<System.UInt64,System.Int32,System.UInt64>.op_UnsignedRightShift(ulong value, int shiftAmount);
    private static override ulong System.Numerics.ISubtractionOperators<System.UInt64,System.UInt64,System.UInt64>.op_CheckedSubtraction(ulong left, ulong right);
    private static override ulong System.Numerics.ISubtractionOperators<System.UInt64,System.UInt64,System.UInt64>.op_Subtraction(ulong left, ulong right);
    private static override ulong System.Numerics.IUnaryNegationOperators<System.UInt64,System.UInt64>.op_CheckedUnaryNegation(ulong value);
    private static override ulong System.Numerics.IUnaryNegationOperators<System.UInt64,System.UInt64>.op_UnaryNegation(ulong value);
    private static override ulong System.Numerics.IUnaryPlusOperators<System.UInt64,System.UInt64>.op_UnaryPlus(ulong value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public static override ulong TrailingZeroCount(ulong value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UInt64& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UInt64& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UInt64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UInt64& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UInt64& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UInt64& result);
}
[IsReadOnlyAttribute]
[CLSCompliantAttribute("False")]
public class System.UIntPtr : ValueType {
    private Void* _dummyPrimitive;
    public static UIntPtr Zero;
    public static UIntPtr MaxValue { get; }
    public static UIntPtr MinValue { get; }
    public static int Size { get; }
    private static UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.AdditiveIdentity { get; }
    private static UIntPtr System.Numerics.IBinaryNumber<nuint>.AllBitsSet { get; }
    private static UIntPtr System.Numerics.IMinMaxValue<nuint>.MaxValue { get; }
    private static UIntPtr System.Numerics.IMinMaxValue<nuint>.MinValue { get; }
    private static UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.MultiplicativeIdentity { get; }
    private static UIntPtr System.Numerics.INumberBase<nuint>.One { get; }
    private static int System.Numerics.INumberBase<nuint>.Radix { get; }
    private static UIntPtr System.Numerics.INumberBase<nuint>.Zero { get; }
    public UIntPtr(UInt32 value);
    public UIntPtr(ulong value);
    public UIntPtr(Void* value);
    public static UIntPtr get_MaxValue();
    public static UIntPtr get_MinValue();
    public static int get_Size();
    private static override UIntPtr System.Numerics.IAdditiveIdentity<nuint,nuint>.get_AdditiveIdentity();
    private static override UIntPtr System.Numerics.IBinaryNumber<nuint>.get_AllBitsSet();
    private static override UIntPtr System.Numerics.IMinMaxValue<nuint>.get_MaxValue();
    private static override UIntPtr System.Numerics.IMinMaxValue<nuint>.get_MinValue();
    private static override UIntPtr System.Numerics.IMultiplicativeIdentity<nuint,nuint>.get_MultiplicativeIdentity();
    private static override UIntPtr System.Numerics.INumberBase<nuint>.get_One();
    private static override int System.Numerics.INumberBase<nuint>.get_Radix();
    private static override UIntPtr System.Numerics.INumberBase<nuint>.get_Zero();
    public static UIntPtr Add(UIntPtr pointer, int offset);
    public static override UIntPtr Clamp(UIntPtr value, UIntPtr min, UIntPtr max);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(object value);
    public sealed virtual int CompareTo(UIntPtr value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateChecked(TOther value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateSaturating(TOther value);
    [NullableContextAttribute("1")]
public static override UIntPtr CreateTruncating(TOther value);
    public static override ValueTuple`2<UIntPtr, UIntPtr> DivRem(UIntPtr left, UIntPtr right);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(UIntPtr other);
    public virtual int GetHashCode();
    public static override bool IsEvenInteger(UIntPtr value);
    public static override bool IsOddInteger(UIntPtr value);
    public static override bool IsPow2(UIntPtr value);
    public static override UIntPtr LeadingZeroCount(UIntPtr value);
    public static override UIntPtr Log2(UIntPtr value);
    public static override UIntPtr Max(UIntPtr x, UIntPtr y);
    public static override UIntPtr Min(UIntPtr x, UIntPtr y);
    public static UIntPtr op_Addition(UIntPtr pointer, int offset);
    public static override bool op_Equality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Explicit(UInt32 value);
    public static UIntPtr op_Explicit(ulong value);
    public static UInt32 op_Explicit(UIntPtr value);
    public static ulong op_Explicit(UIntPtr value);
    public static Void* op_Explicit(UIntPtr value);
    public static UIntPtr op_Explicit(Void* value);
    public static override bool op_Inequality(UIntPtr value1, UIntPtr value2);
    public static UIntPtr op_Subtraction(UIntPtr pointer, int offset);
    public static override UIntPtr Parse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider);
    public static override UIntPtr Parse(ReadOnlySpan`1<char> s, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static UIntPtr Parse(string s);
    [NullableContextAttribute("1")]
public static UIntPtr Parse(string s, NumberStyles style);
    [NullableContextAttribute("1")]
public static override UIntPtr Parse(string s, NumberStyles style, IFormatProvider provider);
    [NullableContextAttribute("1")]
public static override UIntPtr Parse(string s, IFormatProvider provider);
    public static override UIntPtr PopCount(UIntPtr value);
    public static override UIntPtr RotateLeft(UIntPtr value, int rotateAmount);
    public static override UIntPtr RotateRight(UIntPtr value, int rotateAmount);
    public static override int Sign(UIntPtr value);
    public static UIntPtr Subtract(UIntPtr pointer, int offset);
    private static override UIntPtr System.Numerics.IAdditionOperators<nuint,nuint,nuint>.op_Addition(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IAdditionOperators<nuint,nuint,nuint>.op_CheckedAddition(UIntPtr left, UIntPtr right);
    private sealed virtual override int System.Numerics.IBinaryInteger<nuint>.GetByteCount();
    private sealed virtual override int System.Numerics.IBinaryInteger<nuint>.GetShortestBitLength();
    private static override bool System.Numerics.IBinaryInteger<nuint>.TryReadBigEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UIntPtr& value);
    private static override bool System.Numerics.IBinaryInteger<nuint>.TryReadLittleEndian(ReadOnlySpan`1<byte> source, bool isUnsigned, UIntPtr& value);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nuint>.TryWriteBigEndian(Span`1<byte> destination, Int32& bytesWritten);
    private sealed virtual override bool System.Numerics.IBinaryInteger<nuint>.TryWriteLittleEndian(Span`1<byte> destination, Int32& bytesWritten);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_BitwiseAnd(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_BitwiseOr(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_ExclusiveOr(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IBitwiseOperators<nuint,nuint,nuint>.op_OnesComplement(UIntPtr value);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_GreaterThan(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_GreaterThanOrEqual(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_LessThan(UIntPtr left, UIntPtr right);
    private static override bool System.Numerics.IComparisonOperators<nuint,nuint,System.Boolean>.op_LessThanOrEqual(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IDecrementOperators<nuint>.op_CheckedDecrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IDecrementOperators<nuint>.op_Decrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IDivisionOperators<nuint,nuint,nuint>.op_Division(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IIncrementOperators<nuint>.op_CheckedIncrement(UIntPtr value);
    private static override UIntPtr System.Numerics.IIncrementOperators<nuint>.op_Increment(UIntPtr value);
    private static override UIntPtr System.Numerics.IModulusOperators<nuint,nuint,nuint>.op_Modulus(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IMultiplyOperators<nuint,nuint,nuint>.op_CheckedMultiply(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IMultiplyOperators<nuint,nuint,nuint>.op_Multiply(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.Abs(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsCanonical(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsComplexNumber(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsFinite(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsImaginaryNumber(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsInteger(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNaN(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNegative(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNegativeInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsNormal(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsPositive(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsPositiveInfinity(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsRealNumber(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsSubnormal(UIntPtr value);
    private static override bool System.Numerics.INumberBase<nuint>.IsZero(UIntPtr value);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MaxMagnitude(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MaxMagnitudeNumber(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MinMagnitude(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumberBase<nuint>.MinMagnitudeNumber(UIntPtr x, UIntPtr y);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromChecked(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromSaturating(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertFromTruncating(TOther value, UIntPtr& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToChecked(UIntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToSaturating(UIntPtr value, TOther& result);
    private static override bool System.Numerics.INumberBase<nuint>.TryConvertToTruncating(UIntPtr value, TOther& result);
    private static override UIntPtr System.Numerics.INumber<nuint>.CopySign(UIntPtr value, UIntPtr sign);
    private static override UIntPtr System.Numerics.INumber<nuint>.MaxNumber(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.INumber<nuint>.MinNumber(UIntPtr x, UIntPtr y);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_LeftShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_RightShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.IShiftOperators<nuint,System.Int32,nuint>.op_UnsignedRightShift(UIntPtr value, int shiftAmount);
    private static override UIntPtr System.Numerics.ISubtractionOperators<nuint,nuint,nuint>.op_CheckedSubtraction(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.ISubtractionOperators<nuint,nuint,nuint>.op_Subtraction(UIntPtr left, UIntPtr right);
    private static override UIntPtr System.Numerics.IUnaryNegationOperators<nuint,nuint>.op_CheckedUnaryNegation(UIntPtr value);
    private static override UIntPtr System.Numerics.IUnaryNegationOperators<nuint,nuint>.op_UnaryNegation(UIntPtr value);
    private static override UIntPtr System.Numerics.IUnaryPlusOperators<nuint,nuint>.op_UnaryPlus(UIntPtr value);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo info, StreamingContext context);
    public Void* ToPointer();
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(IFormatProvider provider);
    [NullableContextAttribute("1")]
public string ToString(string format);
    [NullableContextAttribute("2")]
public sealed virtual string ToString(string format, IFormatProvider provider);
    public UInt32 ToUInt32();
    public ulong ToUInt64();
    public static override UIntPtr TrailingZeroCount(UIntPtr value);
    public sealed virtual bool TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    public static override bool TryParse(ReadOnlySpan`1<char> s, NumberStyles style, IFormatProvider provider, UIntPtr& result);
    public static override bool TryParse(ReadOnlySpan`1<char> s, IFormatProvider provider, UIntPtr& result);
    public static bool TryParse(ReadOnlySpan`1<char> s, UIntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, NumberStyles style, IFormatProvider provider, UIntPtr& result);
    [NullableContextAttribute("2")]
public static override bool TryParse(string s, IFormatProvider provider, UIntPtr& result);
    [NullableContextAttribute("2")]
public static bool TryParse(string s, UIntPtr& result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.UnauthorizedAccessException : SystemException {
    [NullableContextAttribute("1")]
protected UnauthorizedAccessException(SerializationInfo info, StreamingContext context);
    public UnauthorizedAccessException(string message);
    public UnauthorizedAccessException(string message, Exception inner);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.UnhandledExceptionEventArgs : EventArgs {
    public object ExceptionObject { get; }
    public bool IsTerminating { get; }
    public UnhandledExceptionEventArgs(object exception, bool isTerminating);
    public object get_ExceptionObject();
    public bool get_IsTerminating();
}
public class System.UnhandledExceptionEventHandler : MulticastDelegate {
    public UnhandledExceptionEventHandler(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(object sender, UnhandledExceptionEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, UnhandledExceptionEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Uri : object {
    public static string SchemeDelimiter;
    public static string UriSchemeFile;
    public static string UriSchemeFtp;
    public static string UriSchemeFtps;
    public static string UriSchemeGopher;
    public static string UriSchemeHttp;
    public static string UriSchemeHttps;
    public static string UriSchemeMailto;
    public static string UriSchemeNetPipe;
    public static string UriSchemeNetTcp;
    public static string UriSchemeNews;
    public static string UriSchemeNntp;
    public static string UriSchemeSftp;
    public static string UriSchemeSsh;
    public static string UriSchemeTelnet;
    public static string UriSchemeWs;
    public static string UriSchemeWss;
    public string AbsolutePath { get; }
    public string AbsoluteUri { get; }
    public string Authority { get; }
    public string DnsSafeHost { get; }
    public string Fragment { get; }
    public string Host { get; }
    public UriHostNameType HostNameType { get; }
    public string IdnHost { get; }
    public bool IsAbsoluteUri { get; }
    public bool IsDefaultPort { get; }
    public bool IsFile { get; }
    public bool IsLoopback { get; }
    public bool IsUnc { get; }
    public string LocalPath { get; }
    public string OriginalString { get; }
    public string PathAndQuery { get; }
    public int Port { get; }
    public string Query { get; }
    public string Scheme { get; }
    public String[] Segments { get; }
    public bool UserEscaped { get; }
    public string UserInfo { get; }
    protected Uri(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Uri(string uriString);
    [ObsoleteAttribute("This constructor has been deprecated; the dontEscape parameter is always false. Use Uri(string) instead.")]
public Uri(string uriString, bool dontEscape);
    public Uri(string uriString, UriCreationOptions& creationOptions);
    public Uri(string uriString, UriKind uriKind);
    public Uri(Uri baseUri, string relativeUri);
    [ObsoleteAttribute("This constructor has been deprecated; the dontEscape parameter is always false. Use Uri(Uri, string) instead.")]
public Uri(Uri baseUri, string relativeUri, bool dontEscape);
    public Uri(Uri baseUri, Uri relativeUri);
    public string get_AbsolutePath();
    public string get_AbsoluteUri();
    public string get_Authority();
    public string get_DnsSafeHost();
    public string get_Fragment();
    public string get_Host();
    public UriHostNameType get_HostNameType();
    public string get_IdnHost();
    public bool get_IsAbsoluteUri();
    public bool get_IsDefaultPort();
    public bool get_IsFile();
    public bool get_IsLoopback();
    public bool get_IsUnc();
    public string get_LocalPath();
    public string get_OriginalString();
    public string get_PathAndQuery();
    public int get_Port();
    public string get_Query();
    public string get_Scheme();
    public String[] get_Segments();
    public bool get_UserEscaped();
    public string get_UserInfo();
    [ObsoleteAttribute("Uri.Canonicalize has been deprecated and is not supported.")]
protected virtual void Canonicalize();
    [NullableContextAttribute("2")]
public static UriHostNameType CheckHostName(string name);
    [NullableContextAttribute("2")]
public static bool CheckSchemeName(string schemeName);
    [ObsoleteAttribute("Uri.CheckSecurity has been deprecated and is not supported.")]
protected virtual void CheckSecurity();
    [NullableContextAttribute("2")]
public static int Compare(Uri uri1, Uri uri2, UriComponents partsToCompare, UriFormat compareFormat, StringComparison comparisonType);
    [NullableContextAttribute("2")]
public virtual bool Equals(object comparand);
    [ObsoleteAttribute("Uri.Escape has been deprecated and is not supported.")]
protected virtual void Escape();
    public static string EscapeDataString(string stringToEscape);
    [ObsoleteAttribute("Uri.EscapeString has been deprecated. Use GetComponents() or Uri.EscapeDataString to escape a Uri component or a string.")]
protected static string EscapeString(string str);
    [ObsoleteAttribute("Uri.EscapeUriString can corrupt the Uri string in some cases. Consider using Uri.EscapeDataString for query string components instead.")]
public static string EscapeUriString(string stringToEscape);
    public static int FromHex(char digit);
    public string GetComponents(UriComponents components, UriFormat format);
    public virtual int GetHashCode();
    public string GetLeftPart(UriPartial part);
    protected void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public static string HexEscape(char character);
    public static char HexUnescape(string pattern, Int32& index);
    [ObsoleteAttribute("Uri.IsBadFileSystemCharacter has been deprecated and is not supported.")]
protected virtual bool IsBadFileSystemCharacter(char character);
    public bool IsBaseOf(Uri uri);
    [ObsoleteAttribute("Uri.IsExcludedCharacter has been deprecated and is not supported.")]
protected static bool IsExcludedCharacter(char character);
    public static bool IsHexDigit(char character);
    public static bool IsHexEncoding(string pattern, int index);
    [ObsoleteAttribute("Uri.IsReservedCharacter has been deprecated and is not supported.")]
protected virtual bool IsReservedCharacter(char character);
    public bool IsWellFormedOriginalString();
    [NullableContextAttribute("2")]
public static bool IsWellFormedUriString(string uriString, UriKind uriKind);
    [ObsoleteAttribute("Uri.MakeRelative has been deprecated. Use MakeRelativeUri(Uri uri) instead.")]
public string MakeRelative(Uri toUri);
    public Uri MakeRelativeUri(Uri uri);
    [NullableContextAttribute("2")]
public static bool op_Equality(Uri uri1, Uri uri2);
    [NullableContextAttribute("2")]
public static bool op_Inequality(Uri uri1, Uri uri2);
    [ObsoleteAttribute("Uri.Parse has been deprecated and is not supported.")]
protected virtual void Parse();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual string ToString();
    [NullableContextAttribute("2")]
public static bool TryCreate(string uriString, UriCreationOptions& creationOptions, Uri& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(string uriString, UriKind uriKind, Uri& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(Uri baseUri, string relativeUri, Uri& result);
    [NullableContextAttribute("2")]
public static bool TryCreate(Uri baseUri, Uri relativeUri, Uri& result);
    [ObsoleteAttribute("Uri.Unescape has been deprecated. Use GetComponents() or Uri.UnescapeDataString() to unescape a Uri component or a string.")]
protected virtual string Unescape(string path);
    public static string UnescapeDataString(string stringToUnescape);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.UriBuilder : object {
    public string Fragment { get; public set; }
    public string Host { get; public set; }
    public string Password { get; public set; }
    public string Path { get; public set; }
    public int Port { get; public set; }
    public string Query { get; public set; }
    public string Scheme { get; public set; }
    public Uri Uri { get; }
    public string UserName { get; public set; }
    public UriBuilder(string uri);
    [NullableContextAttribute("2")]
public UriBuilder(string schemeName, string hostName);
    [NullableContextAttribute("2")]
public UriBuilder(string scheme, string host, int portNumber);
    [NullableContextAttribute("2")]
public UriBuilder(string scheme, string host, int port, string pathValue);
    [NullableContextAttribute("2")]
public UriBuilder(string scheme, string host, int port, string path, string extraValue);
    public UriBuilder(Uri uri);
    public string get_Fragment();
    public void set_Fragment(string value);
    public string get_Host();
    public void set_Host(string value);
    public string get_Password();
    public void set_Password(string value);
    public string get_Path();
    public void set_Path(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_Query();
    public void set_Query(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public Uri get_Uri();
    public string get_UserName();
    public void set_UserName(string value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[FlagsAttribute]
public enum System.UriComponents : Enum {
    public int value__;
    public static UriComponents SerializationInfoString;
    public static UriComponents Scheme;
    public static UriComponents UserInfo;
    public static UriComponents Host;
    public static UriComponents Port;
    public static UriComponents SchemeAndServer;
    public static UriComponents Path;
    public static UriComponents Query;
    public static UriComponents PathAndQuery;
    public static UriComponents HttpRequestUrl;
    public static UriComponents Fragment;
    public static UriComponents AbsoluteUri;
    public static UriComponents StrongPort;
    public static UriComponents HostAndPort;
    public static UriComponents StrongAuthority;
    public static UriComponents NormalizedHost;
    public static UriComponents KeepDelimiter;
}
public class System.UriCreationOptions : ValueType {
    private int _dummyPrimitive;
    public bool DangerousDisablePathAndQueryCanonicalization { get; public set; }
    [IsReadOnlyAttribute]
public bool get_DangerousDisablePathAndQueryCanonicalization();
    public void set_DangerousDisablePathAndQueryCanonicalization(bool value);
}
public enum System.UriFormat : Enum {
    public int value__;
    public static UriFormat UriEscaped;
    public static UriFormat Unescaped;
    public static UriFormat SafeUnescaped;
}
public class System.UriFormatException : FormatException {
    [NullableContextAttribute("1")]
protected UriFormatException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    [NullableContextAttribute("2")]
public UriFormatException(string textString);
    [NullableContextAttribute("2")]
public UriFormatException(string textString, Exception e);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
public enum System.UriHostNameType : Enum {
    public int value__;
    public static UriHostNameType Unknown;
    public static UriHostNameType Basic;
    public static UriHostNameType Dns;
    public static UriHostNameType IPv4;
    public static UriHostNameType IPv6;
}
public enum System.UriKind : Enum {
    public int value__;
    public static UriKind RelativeOrAbsolute;
    public static UriKind Absolute;
    public static UriKind Relative;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.UriParser : object {
    protected virtual string GetComponents(Uri uri, UriComponents components, UriFormat format);
    protected virtual void InitializeAndValidate(Uri uri, UriFormatException& parsingError);
    protected virtual bool IsBaseOf(Uri baseUri, Uri relativeUri);
    public static bool IsKnownScheme(string schemeName);
    protected virtual bool IsWellFormedOriginalString(Uri uri);
    protected virtual UriParser OnNewUri();
    protected virtual void OnRegister(string schemeName, int defaultPort);
    public static void Register(UriParser uriParser, string schemeName, int defaultPort);
    [NullableContextAttribute("2")]
protected virtual string Resolve(Uri baseUri, Uri relativeUri, UriFormatException& parsingError);
}
public enum System.UriPartial : Enum {
    public int value__;
    public static UriPartial Scheme;
    public static UriPartial Authority;
    public static UriPartial Path;
    public static UriPartial Query;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple : ValueType {
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple other);
    public static ValueTuple Create();
    public static ValueTuple`1<T1> Create(T1 item1);
    public static ValueTuple`2<T1, T2> Create(T1 item1, T2 item2);
    public static ValueTuple`3<T1, T2, T3> Create(T1 item1, T2 item2, T3 item3);
    public static ValueTuple`4<T1, T2, T3, T4> Create(T1 item1, T2 item2, T3 item3, T4 item4);
    public static ValueTuple`5<T1, T2, T3, T4, T5> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    public static ValueTuple`6<T1, T2, T3, T4, T5, T6> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    public static ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public static ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, ValueTuple`1<T8>> Create(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
public class System.ValueTuple`1 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableContextAttribute("1")]
public ValueTuple`1(T1 item1);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`1<T1> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`1<T1> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class System.ValueTuple`2 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableContextAttribute("1")]
public ValueTuple`2(T1 item1, T2 item2);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`2<T1, T2> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`2<T1, T2> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
public class System.ValueTuple`3 : ValueType {
    [NullableAttribute("1")]
public T1 Item1;
    [NullableAttribute("1")]
public T2 Item2;
    [NullableAttribute("1")]
public T3 Item3;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    [NullableContextAttribute("1")]
public ValueTuple`3(T1 item1, T2 item2, T3 item3);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`3<T1, T2, T3> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`3<T1, T2, T3> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple`4 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`4(T1 item1, T2 item2, T3 item3, T4 item4);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`4<T1, T2, T3, T4> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`4<T1, T2, T3, T4> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple`5 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`5(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`5<T1, T2, T3, T4, T5> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`5<T1, T2, T3, T4, T5> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple`6 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`6(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`6<T1, T2, T3, T4, T5, T6> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple`7 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`7(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`7<T1, T2, T3, T4, T5, T6, T7> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.ValueTuple`8 : ValueType {
    public T1 Item1;
    public T2 Item2;
    public T3 Item3;
    public T4 Item4;
    public T5 Item5;
    public T6 Item6;
    public T7 Item7;
    [NullableAttribute("0")]
public TRest Rest;
    [NullableAttribute("2")]
private object System.Runtime.CompilerServices.ITuple.Item { get; }
    private int System.Runtime.CompilerServices.ITuple.Length { get; }
    public ValueTuple`8(T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, TRest rest);
    private sealed virtual override object System.Runtime.CompilerServices.ITuple.get_Item(int index);
    private sealed virtual override int System.Runtime.CompilerServices.ITuple.get_Length();
    public sealed virtual int CompareTo(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueTuple`8<T1, T2, T3, T4, T5, T6, T7, TRest> other);
    public virtual int GetHashCode();
    private sealed virtual override int System.Collections.IStructuralComparable.CompareTo(object other, IComparer comparer);
    private sealed virtual override bool System.Collections.IStructuralEquatable.Equals(object other, IEqualityComparer comparer);
    private sealed virtual override int System.Collections.IStructuralEquatable.GetHashCode(IEqualityComparer comparer);
    private sealed virtual override int System.IComparable.CompareTo(object other);
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.ValueType : object {
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Version : object {
    public int Build { get; }
    public int Major { get; }
    public short MajorRevision { get; }
    public int Minor { get; }
    public short MinorRevision { get; }
    public int Revision { get; }
    public Version(int major, int minor);
    public Version(int major, int minor, int build);
    public Version(int major, int minor, int build, int revision);
    [NullableContextAttribute("1")]
public Version(string version);
    public int get_Build();
    public int get_Major();
    public short get_MajorRevision();
    public int get_Minor();
    public short get_MinorRevision();
    public int get_Revision();
    [NullableContextAttribute("1")]
public sealed virtual object Clone();
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(Version value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Version obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Version v1, Version v2);
    public static bool op_GreaterThan(Version v1, Version v2);
    public static bool op_GreaterThanOrEqual(Version v1, Version v2);
    public static bool op_Inequality(Version v1, Version v2);
    public static bool op_LessThan(Version v1, Version v2);
    public static bool op_LessThanOrEqual(Version v1, Version v2);
    [NullableContextAttribute("0")]
public static Version Parse(ReadOnlySpan`1<char> input);
    [NullableContextAttribute("1")]
public static Version Parse(string input);
    private sealed virtual override string System.IFormattable.ToString(string format, IFormatProvider formatProvider);
    private sealed virtual override bool System.ISpanFormattable.TryFormat(Span`1<char> destination, Int32& charsWritten, ReadOnlySpan`1<char> format, IFormatProvider provider);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public string ToString(int fieldCount);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, int fieldCount, Int32& charsWritten);
    [NullableContextAttribute("0")]
public bool TryFormat(Span`1<char> destination, Int32& charsWritten);
    [NullableContextAttribute("0")]
public static bool TryParse(ReadOnlySpan`1<char> input, Version& result);
    public static bool TryParse(string input, Version& result);
}
public class System.Void : ValueType {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.WeakReference : object {
    public bool IsAlive { get; }
    public object Target { get; public set; }
    public bool TrackResurrection { get; }
    public WeakReference(object target);
    public WeakReference(object target, bool trackResurrection);
    [NullableContextAttribute("1")]
protected WeakReference(SerializationInfo info, StreamingContext context);
    public virtual bool get_IsAlive();
    public virtual object get_Target();
    public virtual void set_Target(object value);
    public virtual bool get_TrackResurrection();
    protected virtual override void Finalize();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.WeakReference`1 : object {
    public WeakReference`1(T target);
    public WeakReference`1(T target, bool trackResurrection);
    protected virtual override void Finalize();
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public void SetTarget(T target);
    public bool TryGetTarget(T& target);
}
