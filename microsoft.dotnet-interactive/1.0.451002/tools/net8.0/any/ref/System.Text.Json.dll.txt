[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
public enum System.Text.Json.JsonCommentHandling : Enum {
    public byte value__;
    public static JsonCommentHandling Disallow;
    public static JsonCommentHandling Skip;
    public static JsonCommentHandling Allow;
}
public class System.Text.Json.JsonDocument : object {
    public JsonElement RootElement { get; }
    public JsonElement get_RootElement();
    public sealed virtual void Dispose();
    public static JsonDocument Parse(ReadOnlySequence`1<byte> utf8Json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(Stream utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlyMemory`1<byte> utf8Json, JsonDocumentOptions options);
    public static JsonDocument Parse(ReadOnlyMemory`1<char> json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static JsonDocument Parse(string json, JsonDocumentOptions options);
    [NullableContextAttribute("1")]
public static Task`1<JsonDocument> ParseAsync(Stream utf8Json, JsonDocumentOptions options, CancellationToken cancellationToken);
    [NullableContextAttribute("1")]
public static JsonDocument ParseValue(Utf8JsonReader& reader);
    [NullableContextAttribute("2")]
public static bool TryParseValue(Utf8JsonReader& reader, JsonDocument& document);
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
}
public class System.Text.Json.JsonDocumentOptions : ValueType {
    private int _dummyPrimitive;
    public bool AllowTrailingCommas { get; public set; }
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    [IsReadOnlyAttribute]
public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
}
[IsReadOnlyAttribute]
[DefaultMemberAttribute("Item")]
public class System.Text.Json.JsonElement : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public JsonElement Item { get; }
    public JsonValueKind ValueKind { get; }
    public JsonElement get_Item(int index);
    public JsonValueKind get_ValueKind();
    public JsonElement Clone();
    public ArrayEnumerator EnumerateArray();
    public ObjectEnumerator EnumerateObject();
    public int GetArrayLength();
    public bool GetBoolean();
    public byte GetByte();
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    public DateTime GetDateTime();
    public DateTimeOffset GetDateTimeOffset();
    public decimal GetDecimal();
    public double GetDouble();
    public Guid GetGuid();
    public short GetInt16();
    public int GetInt32();
    public long GetInt64();
    public JsonElement GetProperty(ReadOnlySpan`1<byte> utf8PropertyName);
    public JsonElement GetProperty(ReadOnlySpan`1<char> propertyName);
    [NullableContextAttribute("1")]
public JsonElement GetProperty(string propertyName);
    [NullableContextAttribute("1")]
public string GetRawText();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public float GetSingle();
    [NullableContextAttribute("2")]
public string GetString();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public static JsonElement ParseValue(Utf8JsonReader& reader);
    [NullableContextAttribute("1")]
public virtual string ToString();
    public bool TryGetByte(Byte& value);
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetDateTime(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public bool TryGetDecimal(Decimal& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetGuid(Guid& value);
    public bool TryGetInt16(Int16& value);
    public bool TryGetInt32(Int32& value);
    public bool TryGetInt64(Int64& value);
    public bool TryGetProperty(ReadOnlySpan`1<byte> utf8PropertyName, JsonElement& value);
    public bool TryGetProperty(ReadOnlySpan`1<char> propertyName, JsonElement& value);
    [NullableContextAttribute("1")]
public bool TryGetProperty(string propertyName, JsonElement& value);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    public bool TryGetSingle(Single& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    public static bool TryParseValue(Utf8JsonReader& reader, Nullable`1& element);
    public bool ValueEquals(ReadOnlySpan`1<byte> utf8Text);
    public bool ValueEquals(ReadOnlySpan`1<char> text);
    [NullableContextAttribute("2")]
public bool ValueEquals(string text);
    [NullableContextAttribute("1")]
public void WriteTo(Utf8JsonWriter writer);
}
[IsReadOnlyAttribute]
public class System.Text.Json.JsonEncodedText : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public ReadOnlySpan`1<byte> EncodedUtf8Bytes { get; }
    public ReadOnlySpan`1<byte> get_EncodedUtf8Bytes();
    public static JsonEncodedText Encode(ReadOnlySpan`1<byte> utf8Value, JavaScriptEncoder encoder);
    public static JsonEncodedText Encode(ReadOnlySpan`1<char> value, JavaScriptEncoder encoder);
    [NullableContextAttribute("1")]
public static JsonEncodedText Encode(string value, JavaScriptEncoder encoder);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(JsonEncodedText other);
    public virtual int GetHashCode();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonException : Exception {
    public Nullable`1<long> BytePositionInLine { get; }
    public Nullable`1<long> LineNumber { get; }
    [NullableAttribute("1")]
public string Message { get; }
    public string Path { get; }
    [NullableContextAttribute("1")]
protected JsonException(SerializationInfo info, StreamingContext context);
    public JsonException(string message);
    public JsonException(string message, Exception innerException);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine);
    public JsonException(string message, string path, Nullable`1<long> lineNumber, Nullable`1<long> bytePositionInLine, Exception innerException);
    public Nullable`1<long> get_BytePositionInLine();
    public Nullable`1<long> get_LineNumber();
    [NullableContextAttribute("1")]
public virtual string get_Message();
    public string get_Path();
    [NullableContextAttribute("1")]
public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.JsonNamingPolicy : object {
    public static JsonNamingPolicy CamelCase { get; }
    public static JsonNamingPolicy get_CamelCase();
    public abstract virtual string ConvertName(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Text.Json.JsonProperty : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public string Name { get; }
    public JsonElement Value { get; }
    public string get_Name();
    public JsonElement get_Value();
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<byte> utf8Text);
    [NullableContextAttribute("0")]
public bool NameEquals(ReadOnlySpan`1<char> text);
    [NullableContextAttribute("2")]
public bool NameEquals(string text);
    public virtual string ToString();
    public void WriteTo(Utf8JsonWriter writer);
}
public class System.Text.Json.JsonReaderOptions : ValueType {
    private int _dummyPrimitive;
    public bool AllowTrailingCommas { get; public set; }
    public JsonCommentHandling CommentHandling { get; public set; }
    public int MaxDepth { get; public set; }
    [IsReadOnlyAttribute]
public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    [IsReadOnlyAttribute]
public JsonCommentHandling get_CommentHandling();
    public void set_CommentHandling(JsonCommentHandling value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
}
public class System.Text.Json.JsonReaderState : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public JsonReaderOptions Options { get; }
    public JsonReaderState(JsonReaderOptions options);
    public JsonReaderOptions get_Options();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class System.Text.Json.JsonSerializer : object {
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerOptions options);
    public static object Deserialize(Stream utf8Json, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerOptions options);
    public static object Deserialize(ReadOnlySpan`1<byte> utf8Json, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerOptions options);
    public static object Deserialize(ReadOnlySpan`1<char> json, Type returnType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(string json, Type returnType, JsonSerializerOptions options);
    public static object Deserialize(string json, Type returnType, JsonSerializerContext context);
    [ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static object Deserialize(JsonDocument document, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static object Deserialize(JsonElement element, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerOptions options);
    [ExtensionAttribute]
public static object Deserialize(JsonNode node, Type returnType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerOptions options);
    public static object Deserialize(Utf8JsonReader& reader, Type returnType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<object> DeserializeAsync(Stream utf8Json, Type returnType, JsonSerializerContext context, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static IAsyncEnumerable`1<TValue> DeserializeAsyncEnumerable(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static ValueTask`1<TValue> DeserializeAsync(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(Stream utf8Json, JsonSerializerOptions options);
    public static TValue Deserialize(Stream utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<byte> utf8Json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(ReadOnlySpan`1<char> json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(string json, JsonSerializerOptions options);
    public static TValue Deserialize(string json, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonDocument document, JsonSerializerOptions options);
    [ExtensionAttribute]
public static TValue Deserialize(JsonDocument document, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonElement element, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonElement element, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(JsonNode node, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static TValue Deserialize(JsonNode node, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonSerializerOptions options);
    [NullableContextAttribute("2")]
public static TValue Deserialize(Utf8JsonReader& reader, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Stream utf8Json, object value, Type inputType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static string Serialize(object value, Type inputType, JsonSerializerOptions options);
    public static string Serialize(object value, Type inputType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, object value, Type inputType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Stream utf8Json, object value, Type inputType, JsonSerializerContext context, CancellationToken cancellationToken);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Task SerializeAsync(Stream utf8Json, TValue value, JsonSerializerOptions options, CancellationToken cancellationToken);
    public static Task SerializeAsync(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo, CancellationToken cancellationToken);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerOptions options);
    public static JsonDocument SerializeToDocument(object value, Type inputType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonDocument SerializeToDocument(TValue value, JsonSerializerOptions options);
    public static JsonDocument SerializeToDocument(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerOptions options);
    public static JsonElement SerializeToElement(object value, Type inputType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonElement SerializeToElement(TValue value, JsonSerializerOptions options);
    public static JsonElement SerializeToElement(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerOptions options);
    public static JsonNode SerializeToNode(object value, Type inputType, JsonSerializerContext context);
    [NullableContextAttribute("2")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonNode SerializeToNode(TValue value, JsonSerializerOptions options);
    public static JsonNode SerializeToNode(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(object value, Type inputType, JsonSerializerContext context);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static Byte[] SerializeToUtf8Bytes(TValue value, JsonSerializerOptions options);
    public static Byte[] SerializeToUtf8Bytes(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Stream utf8Json, TValue value, JsonSerializerOptions options);
    public static void Serialize(Stream utf8Json, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static void Serialize(Utf8JsonWriter writer, TValue value, JsonSerializerOptions options);
    public static void Serialize(Utf8JsonWriter writer, TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static string Serialize(TValue value, JsonSerializerOptions options);
    public static string Serialize(TValue value, JsonTypeInfo`1<TValue> jsonTypeInfo);
}
public enum System.Text.Json.JsonSerializerDefaults : Enum {
    public int value__;
    public static JsonSerializerDefaults General;
    public static JsonSerializerDefaults Web;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonSerializerOptions : object {
    public bool AllowTrailingCommas { get; public set; }
    [NullableAttribute("1")]
public IList`1<JsonConverter> Converters { get; }
    [NullableAttribute("1")]
public static JsonSerializerOptions Default { get; }
    public int DefaultBufferSize { get; public set; }
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonNamingPolicy DictionaryKeyPolicy { get; public set; }
    public JavaScriptEncoder Encoder { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("JsonSerializerOptions.IgnoreNullValues is obsolete. To ignore null values when serializing, set DefaultIgnoreCondition to JsonIgnoreCondition.WhenWritingNull.")]
public bool IgnoreNullValues { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IncludeFields { get; public set; }
    public int MaxDepth { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    public bool PropertyNameCaseInsensitive { get; public set; }
    public JsonNamingPolicy PropertyNamingPolicy { get; public set; }
    public JsonCommentHandling ReadCommentHandling { get; public set; }
    public ReferenceHandler ReferenceHandler { get; public set; }
    public IJsonTypeInfoResolver TypeInfoResolver { get; public set; }
    public JsonUnknownTypeHandling UnknownTypeHandling { get; public set; }
    public bool WriteIndented { get; public set; }
    public JsonSerializerOptions(JsonSerializerDefaults defaults);
    [NullableContextAttribute("1")]
public JsonSerializerOptions(JsonSerializerOptions options);
    public bool get_AllowTrailingCommas();
    public void set_AllowTrailingCommas(bool value);
    [NullableContextAttribute("1")]
public IList`1<JsonConverter> get_Converters();
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed. Use the overload that takes a JsonTypeInfo or JsonSerializerContext, or make sure all of the required types are preserved.")]
public static JsonSerializerOptions get_Default();
    public int get_DefaultBufferSize();
    public void set_DefaultBufferSize(int value);
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonNamingPolicy get_DictionaryKeyPolicy();
    public void set_DictionaryKeyPolicy(JsonNamingPolicy value);
    public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public bool get_IgnoreNullValues();
    public void set_IgnoreNullValues(bool value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public JsonNumberHandling get_NumberHandling();
    public void set_NumberHandling(JsonNumberHandling value);
    public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
    public JsonNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonNamingPolicy value);
    public JsonCommentHandling get_ReadCommentHandling();
    public void set_ReadCommentHandling(JsonCommentHandling value);
    public ReferenceHandler get_ReferenceHandler();
    public void set_ReferenceHandler(ReferenceHandler value);
    public IJsonTypeInfoResolver get_TypeInfoResolver();
    public void set_TypeInfoResolver(IJsonTypeInfoResolver value);
    public JsonUnknownTypeHandling get_UnknownTypeHandling();
    public void set_UnknownTypeHandling(JsonUnknownTypeHandling value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
    [NullableContextAttribute("0")]
public void AddContext();
    [NullableContextAttribute("1")]
[RequiresDynamicCodeAttribute("Getting a converter for a type may require reflection which depends on runtime code generation.")]
[RequiresUnreferencedCodeAttribute("Getting a converter for a type may require reflection which depends on unreferenced code.")]
public JsonConverter GetConverter(Type typeToConvert);
    [NullableContextAttribute("1")]
public JsonTypeInfo GetTypeInfo(Type type);
}
public enum System.Text.Json.JsonTokenType : Enum {
    public byte value__;
    public static JsonTokenType None;
    public static JsonTokenType StartObject;
    public static JsonTokenType EndObject;
    public static JsonTokenType StartArray;
    public static JsonTokenType EndArray;
    public static JsonTokenType PropertyName;
    public static JsonTokenType Comment;
    public static JsonTokenType String;
    public static JsonTokenType Number;
    public static JsonTokenType True;
    public static JsonTokenType False;
    public static JsonTokenType Null;
}
public enum System.Text.Json.JsonValueKind : Enum {
    public byte value__;
    public static JsonValueKind Undefined;
    public static JsonValueKind Object;
    public static JsonValueKind Array;
    public static JsonValueKind String;
    public static JsonValueKind Number;
    public static JsonValueKind True;
    public static JsonValueKind False;
    public static JsonValueKind Null;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.JsonWriterOptions : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public JavaScriptEncoder Encoder { get; public set; }
    public bool Indented { get; public set; }
    public int MaxDepth { get; public set; }
    public bool SkipValidation { get; public set; }
    [IsReadOnlyAttribute]
public JavaScriptEncoder get_Encoder();
    public void set_Encoder(JavaScriptEncoder value);
    public bool get_Indented();
    public void set_Indented(bool value);
    [IsReadOnlyAttribute]
public int get_MaxDepth();
    public void set_MaxDepth(int value);
    public bool get_SkipValidation();
    public void set_SkipValidation(bool value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Text.Json.Nodes.JsonArray : JsonNode {
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.IsReadOnly { get; }
    public JsonArray(Nullable`1<JsonNodeOptions> options);
    public JsonArray(JsonNodeOptions options, JsonNode[] items);
    public JsonArray(JsonNode[] items);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.get_IsReadOnly();
    public sealed virtual void Add(JsonNode item);
    [RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
[RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed.")]
public void Add(T value);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(JsonNode item);
    public static JsonArray Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    public sealed virtual IEnumerator`1<JsonNode> GetEnumerator();
    public sealed virtual int IndexOf(JsonNode item);
    public sealed virtual void Insert(int index, JsonNode item);
    public sealed virtual bool Remove(JsonNode item);
    public sealed virtual void RemoveAt(int index);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Text.Json.Nodes.JsonNode>.CopyTo(JsonNode[] array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [NullableContextAttribute("1")]
public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public abstract class System.Text.Json.Nodes.JsonNode : object {
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    [NullableAttribute("2")]
public JsonNode Item { get; public set; }
    public Nullable`1<JsonNodeOptions> Options { get; }
    [NullableAttribute("2")]
public JsonNode Parent { get; }
    public JsonNode Root { get; }
    [NullableContextAttribute("2")]
public sealed virtual JsonNode get_Item(int index);
    [NullableContextAttribute("2")]
public sealed virtual void set_Item(int index, JsonNode value);
    public sealed virtual JsonNode get_Item(string propertyName);
    public sealed virtual void set_Item(string propertyName, JsonNode value);
    public Nullable`1<JsonNodeOptions> get_Options();
    [NullableContextAttribute("2")]
public JsonNode get_Parent();
    public JsonNode get_Root();
    public JsonArray AsArray();
    public JsonObject AsObject();
    public JsonValue AsValue();
    public string GetPath();
    public virtual T GetValue();
    public static bool op_Explicit(JsonNode value);
    public static byte op_Explicit(JsonNode value);
    public static char op_Explicit(JsonNode value);
    public static DateTime op_Explicit(JsonNode value);
    public static DateTimeOffset op_Explicit(JsonNode value);
    public static decimal op_Explicit(JsonNode value);
    public static double op_Explicit(JsonNode value);
    public static Guid op_Explicit(JsonNode value);
    public static short op_Explicit(JsonNode value);
    public static int op_Explicit(JsonNode value);
    public static long op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<bool> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<byte> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<char> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTimeOffset> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<DateTime> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<decimal> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<double> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<Guid> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<short> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<int> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<long> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<sbyte> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static Nullable`1<float> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ushort> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<UInt32> op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static Nullable`1<ulong> op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static sbyte op_Explicit(JsonNode value);
    public static float op_Explicit(JsonNode value);
    [NullableContextAttribute("2")]
public static string op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ushort op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static UInt32 op_Explicit(JsonNode value);
    [CLSCompliantAttribute("False")]
public static ulong op_Explicit(JsonNode value);
    public static JsonNode op_Implicit(bool value);
    public static JsonNode op_Implicit(byte value);
    public static JsonNode op_Implicit(char value);
    public static JsonNode op_Implicit(DateTime value);
    public static JsonNode op_Implicit(DateTimeOffset value);
    public static JsonNode op_Implicit(decimal value);
    public static JsonNode op_Implicit(double value);
    public static JsonNode op_Implicit(Guid value);
    public static JsonNode op_Implicit(short value);
    public static JsonNode op_Implicit(int value);
    public static JsonNode op_Implicit(long value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<bool> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<byte> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<char> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTimeOffset> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<DateTime> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<decimal> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<double> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<Guid> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<short> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<int> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<long> value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<sbyte> value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(Nullable`1<float> value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ushort> value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<UInt32> value);
    [NullableContextAttribute("2")]
[CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(Nullable`1<ulong> value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(sbyte value);
    public static JsonNode op_Implicit(float value);
    [NullableContextAttribute("2")]
public static JsonNode op_Implicit(string value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ushort value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(UInt32 value);
    [CLSCompliantAttribute("False")]
public static JsonNode op_Implicit(ulong value);
    public static JsonNode Parse(Stream utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [NullableContextAttribute("0")]
public static JsonNode Parse(ReadOnlySpan`1<byte> utf8Json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    public static JsonNode Parse(string json, Nullable`1<JsonNodeOptions> nodeOptions, JsonDocumentOptions documentOptions);
    [NullableContextAttribute("2")]
public static JsonNode Parse(Utf8JsonReader& reader, Nullable`1<JsonNodeOptions> nodeOptions);
    public string ToJsonString(JsonSerializerOptions options);
    public virtual string ToString();
    public abstract virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
public class System.Text.Json.Nodes.JsonNodeOptions : ValueType {
    private int _dummyPrimitive;
    public bool PropertyNameCaseInsensitive { get; public set; }
    [IsReadOnlyAttribute]
public bool get_PropertyNameCaseInsensitive();
    public void set_PropertyNameCaseInsensitive(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Nodes.JsonObject : JsonNode {
    public int Count { get; }
    private bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.IsReadOnly { get; }
    private ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Keys { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.Values { get; }
    public JsonObject(IEnumerable`1<KeyValuePair`2<string, JsonNode>> properties, Nullable`1<JsonNodeOptions> options);
    public JsonObject(Nullable`1<JsonNodeOptions> options);
    public sealed virtual int get_Count();
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.get_IsReadOnly();
    private sealed virtual override ICollection`1<string> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Keys();
    private sealed virtual override ICollection`1<JsonNode> System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.get_Values();
    public sealed virtual void Add(KeyValuePair`2<string, JsonNode> property);
    public sealed virtual void Add(string propertyName, JsonNode value);
    public sealed virtual void Clear();
    public sealed virtual bool ContainsKey(string propertyName);
    [NullableContextAttribute("2")]
public static JsonObject Create(JsonElement element, Nullable`1<JsonNodeOptions> options);
    public sealed virtual IEnumerator`1<KeyValuePair`2<string, JsonNode>> GetEnumerator();
    public sealed virtual bool Remove(string propertyName);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Contains(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override void System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.CopyTo(KeyValuePair`2[] array, int index);
    private sealed virtual override bool System.Collections.Generic.ICollection<System.Collections.Generic.KeyValuePair<System.String,System.Text.Json.Nodes.JsonNode>>.Remove(KeyValuePair`2<string, JsonNode> item);
    private sealed virtual override bool System.Collections.Generic.IDictionary<System.String,System.Text.Json.Nodes.JsonNode>.TryGetValue(string propertyName, JsonNode& jsonNode);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool TryGetPropertyValue(string propertyName, JsonNode& jsonNode);
    public virtual void WriteTo(Utf8JsonWriter writer, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Nodes.JsonValue : JsonNode {
    [NullableContextAttribute("1")]
public static JsonValue Create(bool value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(byte value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(char value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTime value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(DateTimeOffset value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(decimal value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(double value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(Guid value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(short value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(int value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(long value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<bool> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<byte> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<char> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTimeOffset> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<DateTime> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<decimal> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<double> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<Guid> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<short> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<int> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<long> value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<sbyte> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<float> value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(Nullable`1<JsonElement> value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ushort> value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<UInt32> value, Nullable`1<JsonNodeOptions> options);
    [CLSCompliantAttribute("False")]
public static JsonValue Create(Nullable`1<ulong> value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(sbyte value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
public static JsonValue Create(float value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(string value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(JsonElement value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ushort value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(UInt32 value, Nullable`1<JsonNodeOptions> options);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public static JsonValue Create(ulong value, Nullable`1<JsonNodeOptions> options);
    [RequiresDynamicCodeAttribute("Creating JsonValue instances with non-primitive types requires generating code at runtime.")]
[RequiresUnreferencedCodeAttribute("Creating JsonValue instances with non-primitive types is not compatible with trimming. It can result in non-primitive types being serialized, which may have their members trimmed. Use the overload that takes a JsonTypeInfo, or make sure all of the required types are preserved.")]
public static JsonValue Create(T value, Nullable`1<JsonNodeOptions> options);
    public static JsonValue Create(T value, JsonTypeInfo`1<T> jsonTypeInfo, Nullable`1<JsonNodeOptions> options);
    public abstract virtual bool TryGetValue(T& value);
}
public interface System.Text.Json.Serialization.IJsonOnDeserialized {
    public abstract virtual void OnDeserialized();
}
public interface System.Text.Json.Serialization.IJsonOnDeserializing {
    public abstract virtual void OnDeserializing();
}
public interface System.Text.Json.Serialization.IJsonOnSerialized {
    public abstract virtual void OnSerialized();
}
public interface System.Text.Json.Serialization.IJsonOnSerializing {
    public abstract virtual void OnSerializing();
}
public abstract class System.Text.Json.Serialization.JsonAttribute : Attribute {
}
[AttributeUsageAttribute("32")]
public class System.Text.Json.Serialization.JsonConstructorAttribute : JsonAttribute {
}
public abstract class System.Text.Json.Serialization.JsonConverter : object {
    [NullableContextAttribute("1")]
public abstract virtual bool CanConvert(Type typeToConvert);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonConverter`1 : JsonConverter {
    public bool HandleNull { get; }
    public virtual bool get_HandleNull();
    public virtual bool CanConvert(Type typeToConvert);
    public abstract virtual T Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual T ReadAsPropertyName(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public abstract virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    public virtual void WriteAsPropertyName(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1436")]
public class System.Text.Json.Serialization.JsonConverterAttribute : JsonAttribute {
    [NullableAttribute("2")]
[DynamicallyAccessedMembersAttribute("1")]
public Type ConverterType { get; }
    public JsonConverterAttribute(Type converterType);
    [NullableContextAttribute("2")]
public Type get_ConverterType();
    public virtual JsonConverter CreateConverter(Type typeToConvert);
}
public abstract class System.Text.Json.Serialization.JsonConverterFactory : JsonConverter {
    [NullableContextAttribute("1")]
public abstract virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class System.Text.Json.Serialization.JsonDerivedTypeAttribute : JsonAttribute {
    public Type DerivedType { get; }
    [NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedTypeAttribute(Type derivedType);
    public JsonDerivedTypeAttribute(Type derivedType, int typeDiscriminator);
    public JsonDerivedTypeAttribute(Type derivedType, string typeDiscriminator);
    public Type get_DerivedType();
    [NullableContextAttribute("2")]
public object get_TypeDiscriminator();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonExtensionDataAttribute : JsonAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIgnoreAttribute : JsonAttribute {
    public JsonIgnoreCondition Condition { get; public set; }
    public JsonIgnoreCondition get_Condition();
    public void set_Condition(JsonIgnoreCondition value);
}
public enum System.Text.Json.Serialization.JsonIgnoreCondition : Enum {
    public int value__;
    public static JsonIgnoreCondition Never;
    public static JsonIgnoreCondition Always;
    public static JsonIgnoreCondition WhenWritingDefault;
    public static JsonIgnoreCondition WhenWritingNull;
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonIncludeAttribute : JsonAttribute {
}
public enum System.Text.Json.Serialization.JsonKnownNamingPolicy : Enum {
    public int value__;
    public static JsonKnownNamingPolicy Unspecified;
    public static JsonKnownNamingPolicy CamelCase;
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonNumberHandling : Enum {
    public int value__;
    public static JsonNumberHandling Strict;
    public static JsonNumberHandling AllowReadingFromString;
    public static JsonNumberHandling WriteAsString;
    public static JsonNumberHandling AllowNamedFloatingPointLiterals;
}
[AttributeUsageAttribute("396")]
public class System.Text.Json.Serialization.JsonNumberHandlingAttribute : JsonAttribute {
    public JsonNumberHandling Handling { get; }
    public JsonNumberHandlingAttribute(JsonNumberHandling handling);
    public JsonNumberHandling get_Handling();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("1028")]
public class System.Text.Json.Serialization.JsonPolymorphicAttribute : JsonAttribute {
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    public string TypeDiscriminatorPropertyName { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public bool get_IgnoreUnrecognizedTypeDiscriminators();
    public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
    public string get_TypeDiscriminatorPropertyName();
    public void set_TypeDiscriminatorPropertyName(string value);
    public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyNameAttribute : JsonAttribute {
    public string Name { get; }
    public JsonPropertyNameAttribute(string name);
    public string get_Name();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonPropertyOrderAttribute : JsonAttribute {
    public int Order { get; }
    public JsonPropertyOrderAttribute(int order);
    public int get_Order();
}
[AttributeUsageAttribute("384")]
public class System.Text.Json.Serialization.JsonRequiredAttribute : JsonAttribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSerializableAttribute : JsonAttribute {
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    public string TypeInfoPropertyName { get; public set; }
    [NullableContextAttribute("1")]
public JsonSerializableAttribute(Type type);
    public JsonSourceGenerationMode get_GenerationMode();
    public void set_GenerationMode(JsonSourceGenerationMode value);
    public string get_TypeInfoPropertyName();
    public void set_TypeInfoPropertyName(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.JsonSerializerContext : object {
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public JsonSerializerOptions Options { get; }
    [NullableContextAttribute("2")]
protected JsonSerializerContext(JsonSerializerOptions options);
    [NullableContextAttribute("2")]
protected abstract virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    public JsonSerializerOptions get_Options();
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type);
    private sealed virtual override JsonTypeInfo System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver.GetTypeInfo(Type type, JsonSerializerOptions options);
}
[FlagsAttribute]
public enum System.Text.Json.Serialization.JsonSourceGenerationMode : Enum {
    public int value__;
    public static JsonSourceGenerationMode Default;
    public static JsonSourceGenerationMode Metadata;
    public static JsonSourceGenerationMode Serialization;
}
[AttributeUsageAttribute("4")]
public class System.Text.Json.Serialization.JsonSourceGenerationOptionsAttribute : JsonAttribute {
    public JsonIgnoreCondition DefaultIgnoreCondition { get; public set; }
    public JsonSourceGenerationMode GenerationMode { get; public set; }
    public bool IgnoreReadOnlyFields { get; public set; }
    public bool IgnoreReadOnlyProperties { get; public set; }
    public bool IncludeFields { get; public set; }
    public JsonKnownNamingPolicy PropertyNamingPolicy { get; public set; }
    public bool WriteIndented { get; public set; }
    public JsonIgnoreCondition get_DefaultIgnoreCondition();
    public void set_DefaultIgnoreCondition(JsonIgnoreCondition value);
    public JsonSourceGenerationMode get_GenerationMode();
    public void set_GenerationMode(JsonSourceGenerationMode value);
    public bool get_IgnoreReadOnlyFields();
    public void set_IgnoreReadOnlyFields(bool value);
    public bool get_IgnoreReadOnlyProperties();
    public void set_IgnoreReadOnlyProperties(bool value);
    public bool get_IncludeFields();
    public void set_IncludeFields(bool value);
    public JsonKnownNamingPolicy get_PropertyNamingPolicy();
    public void set_PropertyNamingPolicy(JsonKnownNamingPolicy value);
    public bool get_WriteIndented();
    public void set_WriteIndented(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[RequiresDynamicCodeAttribute("JsonStringEnumConverter cannot be statically analyzed and requires runtime code generation. Consider authoring a custom converter that is not a factory to work around the issue. See https://github.com/dotnet/runtime/issues/73124.")]
public class System.Text.Json.Serialization.JsonStringEnumConverter : JsonConverterFactory {
    [NullableContextAttribute("2")]
public JsonStringEnumConverter(JsonNamingPolicy namingPolicy, bool allowIntegerValues);
    public sealed virtual bool CanConvert(Type typeToConvert);
    public sealed virtual JsonConverter CreateConverter(Type typeToConvert, JsonSerializerOptions options);
}
public enum System.Text.Json.Serialization.JsonUnknownDerivedTypeHandling : Enum {
    public int value__;
    public static JsonUnknownDerivedTypeHandling FailSerialization;
    public static JsonUnknownDerivedTypeHandling FallBackToBaseType;
    public static JsonUnknownDerivedTypeHandling FallBackToNearestAncestor;
}
public enum System.Text.Json.Serialization.JsonUnknownTypeHandling : Enum {
    public int value__;
    public static JsonUnknownTypeHandling JsonElement;
    public static JsonUnknownTypeHandling JsonNode;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.DefaultJsonTypeInfoResolver : object {
    public IList`1<Action`1<JsonTypeInfo>> Modifiers { get; }
    public IList`1<Action`1<JsonTypeInfo>> get_Modifiers();
    public virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
public interface System.Text.Json.Serialization.Metadata.IJsonTypeInfoResolver {
    public abstract virtual JsonTypeInfo GetTypeInfo(Type type, JsonSerializerOptions options);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonCollectionInfoValues`1 : object {
    [NullableAttribute("1")]
public JsonTypeInfo ElementInfo { get; public set; }
    public JsonTypeInfo KeyInfo { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<TCollection> ObjectCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, TCollection> SerializeHandler { get; public set; }
    [NullableContextAttribute("1")]
public JsonTypeInfo get_ElementInfo();
    [NullableContextAttribute("1")]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ElementInfo(JsonTypeInfo value);
    public JsonTypeInfo get_KeyInfo();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_KeyInfo(JsonTypeInfo value);
    public JsonNumberHandling get_NumberHandling();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    public Func`1<TCollection> get_ObjectCreator();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<TCollection> value);
    public Action`2<Utf8JsonWriter, TCollection> get_SerializeHandler();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, TCollection> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class System.Text.Json.Serialization.Metadata.JsonDerivedType : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public Type DerivedType { get; }
    [NullableAttribute("2")]
public object TypeDiscriminator { get; }
    public JsonDerivedType(Type derivedType);
    public JsonDerivedType(Type derivedType, int typeDiscriminator);
    public JsonDerivedType(Type derivedType, string typeDiscriminator);
    public Type get_DerivedType();
    [NullableContextAttribute("2")]
public object get_TypeDiscriminator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public static class System.Text.Json.Serialization.Metadata.JsonMetadataServices : object {
    public static JsonConverter`1<bool> BooleanConverter { get; }
    public static JsonConverter`1<Byte[]> ByteArrayConverter { get; }
    public static JsonConverter`1<byte> ByteConverter { get; }
    public static JsonConverter`1<char> CharConverter { get; }
    public static JsonConverter`1<DateTime> DateTimeConverter { get; }
    public static JsonConverter`1<DateTimeOffset> DateTimeOffsetConverter { get; }
    public static JsonConverter`1<decimal> DecimalConverter { get; }
    public static JsonConverter`1<double> DoubleConverter { get; }
    public static JsonConverter`1<Guid> GuidConverter { get; }
    public static JsonConverter`1<short> Int16Converter { get; }
    public static JsonConverter`1<int> Int32Converter { get; }
    public static JsonConverter`1<long> Int64Converter { get; }
    public static JsonConverter`1<JsonArray> JsonArrayConverter { get; }
    public static JsonConverter`1<JsonDocument> JsonDocumentConverter { get; }
    public static JsonConverter`1<JsonElement> JsonElementConverter { get; }
    public static JsonConverter`1<JsonNode> JsonNodeConverter { get; }
    public static JsonConverter`1<JsonObject> JsonObjectConverter { get; }
    public static JsonConverter`1<JsonValue> JsonValueConverter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public static JsonConverter`1<object> ObjectConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<sbyte> SByteConverter { get; }
    public static JsonConverter`1<float> SingleConverter { get; }
    public static JsonConverter`1<string> StringConverter { get; }
    public static JsonConverter`1<TimeSpan> TimeSpanConverter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ushort> UInt16Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<UInt32> UInt32Converter { get; }
    [CLSCompliantAttribute("False")]
public static JsonConverter`1<ulong> UInt64Converter { get; }
    public static JsonConverter`1<Uri> UriConverter { get; }
    public static JsonConverter`1<Version> VersionConverter { get; }
    public static JsonConverter`1<DateOnly> DateOnlyConverter { get; }
    public static JsonConverter`1<TimeOnly> TimeOnlyConverter { get; }
    public static JsonConverter`1<bool> get_BooleanConverter();
    public static JsonConverter`1<Byte[]> get_ByteArrayConverter();
    public static JsonConverter`1<byte> get_ByteConverter();
    public static JsonConverter`1<char> get_CharConverter();
    public static JsonConverter`1<DateTime> get_DateTimeConverter();
    public static JsonConverter`1<DateTimeOffset> get_DateTimeOffsetConverter();
    public static JsonConverter`1<decimal> get_DecimalConverter();
    public static JsonConverter`1<double> get_DoubleConverter();
    public static JsonConverter`1<Guid> get_GuidConverter();
    public static JsonConverter`1<short> get_Int16Converter();
    public static JsonConverter`1<int> get_Int32Converter();
    public static JsonConverter`1<long> get_Int64Converter();
    public static JsonConverter`1<JsonArray> get_JsonArrayConverter();
    public static JsonConverter`1<JsonDocument> get_JsonDocumentConverter();
    public static JsonConverter`1<JsonElement> get_JsonElementConverter();
    public static JsonConverter`1<JsonNode> get_JsonNodeConverter();
    public static JsonConverter`1<JsonObject> get_JsonObjectConverter();
    public static JsonConverter`1<JsonValue> get_JsonValueConverter();
    public static JsonConverter`1<object> get_ObjectConverter();
    public static JsonConverter`1<sbyte> get_SByteConverter();
    public static JsonConverter`1<float> get_SingleConverter();
    public static JsonConverter`1<string> get_StringConverter();
    public static JsonConverter`1<TimeSpan> get_TimeSpanConverter();
    public static JsonConverter`1<ushort> get_UInt16Converter();
    public static JsonConverter`1<UInt32> get_UInt32Converter();
    public static JsonConverter`1<ulong> get_UInt64Converter();
    public static JsonConverter`1<Uri> get_UriConverter();
    public static JsonConverter`1<Version> get_VersionConverter();
    public static JsonTypeInfo`1<TElement[]> CreateArrayInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TElement[]> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateConcurrentStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIAsyncEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateICollectionInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateIListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateImmutableDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<KeyValuePair`2<TKey, TValue>>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateImmutableEnumerableInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Func`2<IEnumerable`1<TElement>, TCollection> createRangeFunc);
    public static JsonTypeInfo`1<TCollection> CreateIReadOnlyDictionaryInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateISetInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateListInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<T> CreateObjectInfo(JsonSerializerOptions options, JsonObjectInfoValues`1<T> objectInfo);
    public static JsonPropertyInfo CreatePropertyInfo(JsonSerializerOptions options, JsonPropertyInfoValues`1<T> propertyInfo);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateQueueInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo, Action`2<TCollection, object> addFunc);
    public static JsonTypeInfo`1<TCollection> CreateStackInfo(JsonSerializerOptions options, JsonCollectionInfoValues`1<TCollection> collectionInfo);
    public static JsonTypeInfo`1<T> CreateValueInfo(JsonSerializerOptions options, JsonConverter converter);
    [NullableContextAttribute("0")]
public static JsonConverter`1<T> GetEnumConverter(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonSerializerOptions options);
    [NullableContextAttribute("0")]
public static JsonConverter`1<Nullable`1<T>> GetNullableConverter(JsonTypeInfo`1<T> underlyingTypeInfo);
    public static JsonConverter`1<T> GetUnsupportedTypeConverter();
    public static JsonConverter`1<DateOnly> get_DateOnlyConverter();
    public static JsonConverter`1<TimeOnly> get_TimeOnlyConverter();
}
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonObjectInfoValues`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<JsonParameterInfoValues[]> ConstructorParameterMetadataInitializer { get; public set; }
    public JsonNumberHandling NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> ObjectCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<Object[], T> ObjectWithParameterizedConstructorCreator { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<JsonSerializerContext, JsonPropertyInfo[]> PropertyMetadataInitializer { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; public set; }
    public Func`1<JsonParameterInfoValues[]> get_ConstructorParameterMetadataInitializer();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ConstructorParameterMetadataInitializer(Func`1<JsonParameterInfoValues[]> value);
    public JsonNumberHandling get_NumberHandling();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(JsonNumberHandling value);
    public Func`1<T> get_ObjectCreator();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectCreator(Func`1<T> value);
    public Func`2<Object[], T> get_ObjectWithParameterizedConstructorCreator();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ObjectWithParameterizedConstructorCreator(Func`2<Object[], T> value);
    public Func`2<JsonSerializerContext, JsonPropertyInfo[]> get_PropertyMetadataInitializer();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyMetadataInitializer(Func`2<JsonSerializerContext, JsonPropertyInfo[]> value);
    public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SerializeHandler(Action`2<Utf8JsonWriter, T> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonParameterInfoValues : object {
    [NullableAttribute("2")]
public object DefaultValue { get; public set; }
    public bool HasDefaultValue { get; public set; }
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public int Position { get; public set; }
    [NullableContextAttribute("2")]
public object get_DefaultValue();
    [NullableContextAttribute("2")]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DefaultValue(object value);
    public bool get_HasDefaultValue();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasDefaultValue(bool value);
    public string get_Name();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    public Type get_ParameterType();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParameterType(Type value);
    public int get_Position();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Position(int value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Text.Json.Serialization.Metadata.JsonPolymorphismOptions : object {
    public IList`1<JsonDerivedType> DerivedTypes { get; }
    public bool IgnoreUnrecognizedTypeDiscriminators { get; public set; }
    public string TypeDiscriminatorPropertyName { get; public set; }
    public JsonUnknownDerivedTypeHandling UnknownDerivedTypeHandling { get; public set; }
    public IList`1<JsonDerivedType> get_DerivedTypes();
    public bool get_IgnoreUnrecognizedTypeDiscriminators();
    public void set_IgnoreUnrecognizedTypeDiscriminators(bool value);
    public string get_TypeDiscriminatorPropertyName();
    public void set_TypeDiscriminatorPropertyName(string value);
    public JsonUnknownDerivedTypeHandling get_UnknownDerivedTypeHandling();
    public void set_UnknownDerivedTypeHandling(JsonUnknownDerivedTypeHandling value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.Metadata.JsonPropertyInfo : object {
    [NullableAttribute("2")]
public ICustomAttributeProvider AttributeProvider { get; public set; }
    [NullableAttribute("2")]
public JsonConverter CustomConverter { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, object> Get { get; public set; }
    public bool IsExtensionData { get; public set; }
    public bool IsRequired { get; public set; }
    public string Name { get; public set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public JsonSerializerOptions Options { get; }
    public int Order { get; public set; }
    public Type PropertyType { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, object> Set { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`3<object, object, bool> ShouldSerialize { get; public set; }
    [NullableContextAttribute("2")]
public ICustomAttributeProvider get_AttributeProvider();
    [NullableContextAttribute("2")]
public void set_AttributeProvider(ICustomAttributeProvider value);
    [NullableContextAttribute("2")]
public JsonConverter get_CustomConverter();
    [NullableContextAttribute("2")]
public void set_CustomConverter(JsonConverter value);
    public Func`2<object, object> get_Get();
    public void set_Get(Func`2<object, object> value);
    public bool get_IsExtensionData();
    public void set_IsExtensionData(bool value);
    public bool get_IsRequired();
    public void set_IsRequired(bool value);
    public string get_Name();
    public void set_Name(string value);
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public JsonSerializerOptions get_Options();
    public int get_Order();
    public void set_Order(int value);
    public Type get_PropertyType();
    public Action`2<object, object> get_Set();
    public void set_Set(Action`2<object, object> value);
    public Func`3<object, object, bool> get_ShouldSerialize();
    public void set_ShouldSerialize(Func`3<object, object, bool> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[EditorBrowsableAttribute("1")]
public class System.Text.Json.Serialization.Metadata.JsonPropertyInfoValues`1 : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonConverter`1<T> Converter { get; public set; }
    public Type DeclaringType { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`2<object, T> Getter { get; public set; }
    public bool HasJsonInclude { get; public set; }
    public Nullable`1<JsonIgnoreCondition> IgnoreCondition { get; public set; }
    public bool IsExtensionData { get; public set; }
    public bool IsProperty { get; public set; }
    public bool IsPublic { get; public set; }
    public bool IsVirtual { get; public set; }
    [NullableAttribute("2")]
public string JsonPropertyName { get; public set; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    public string PropertyName { get; public set; }
    public JsonTypeInfo PropertyTypeInfo { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`2<object, T> Setter { get; public set; }
    public JsonConverter`1<T> get_Converter();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Converter(JsonConverter`1<T> value);
    public Type get_DeclaringType();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_DeclaringType(Type value);
    public Func`2<object, T> get_Getter();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Getter(Func`2<object, T> value);
    public bool get_HasJsonInclude();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_HasJsonInclude(bool value);
    public Nullable`1<JsonIgnoreCondition> get_IgnoreCondition();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IgnoreCondition(Nullable`1<JsonIgnoreCondition> value);
    public bool get_IsExtensionData();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsExtensionData(bool value);
    public bool get_IsProperty();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsProperty(bool value);
    public bool get_IsPublic();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsPublic(bool value);
    public bool get_IsVirtual();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_IsVirtual(bool value);
    [NullableContextAttribute("2")]
public string get_JsonPropertyName();
    [NullableContextAttribute("2")]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_JsonPropertyName(string value);
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public string get_PropertyName();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyName(string value);
    public JsonTypeInfo get_PropertyTypeInfo();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PropertyTypeInfo(JsonTypeInfo value);
    public Action`2<object, T> get_Setter();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Setter(Action`2<object, T> value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo : object {
    public JsonConverter Converter { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<object> CreateObject { get; public set; }
    public bool IsReadOnly { get; }
    public JsonTypeInfoKind Kind { get; }
    public Nullable`1<JsonNumberHandling> NumberHandling { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserialized { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnDeserializing { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerialized { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Action`1<object> OnSerializing { get; public set; }
    public JsonSerializerOptions Options { get; }
    [NullableAttribute("2")]
public JsonPolymorphismOptions PolymorphismOptions { get; public set; }
    public IList`1<JsonPropertyInfo> Properties { get; }
    public Type Type { get; }
    public JsonConverter get_Converter();
    public Func`1<object> get_CreateObject();
    public void set_CreateObject(Func`1<object> value);
    public bool get_IsReadOnly();
    public JsonTypeInfoKind get_Kind();
    public void MakeReadOnly();
    public Nullable`1<JsonNumberHandling> get_NumberHandling();
    public void set_NumberHandling(Nullable`1<JsonNumberHandling> value);
    public Action`1<object> get_OnDeserialized();
    public void set_OnDeserialized(Action`1<object> value);
    public Action`1<object> get_OnDeserializing();
    public void set_OnDeserializing(Action`1<object> value);
    public Action`1<object> get_OnSerialized();
    public void set_OnSerialized(Action`1<object> value);
    public Action`1<object> get_OnSerializing();
    public void set_OnSerializing(Action`1<object> value);
    public JsonSerializerOptions get_Options();
    [NullableContextAttribute("2")]
public JsonPolymorphismOptions get_PolymorphismOptions();
    [NullableContextAttribute("2")]
public void set_PolymorphismOptions(JsonPolymorphismOptions value);
    public IList`1<JsonPropertyInfo> get_Properties();
    public Type get_Type();
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public JsonPropertyInfo CreateJsonPropertyInfo(Type propertyType, string name);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo CreateJsonTypeInfo(Type type, JsonSerializerOptions options);
    [RequiresDynamicCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
[RequiresUnreferencedCodeAttribute("JSON serialization and deserialization might require types that cannot be statically analyzed and might need runtime code generation. Use System.Text.Json source generation for native AOT applications.")]
public static JsonTypeInfo`1<T> CreateJsonTypeInfo(JsonSerializerOptions options);
}
public abstract class System.Text.Json.Serialization.Metadata.JsonTypeInfo`1 : JsonTypeInfo {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Func`1<T> CreateObject { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[EditorBrowsableAttribute("1")]
public Action`2<Utf8JsonWriter, T> SerializeHandler { get; }
    public Func`1<T> get_CreateObject();
    public void set_CreateObject(Func`1<T> value);
    public Action`2<Utf8JsonWriter, T> get_SerializeHandler();
}
public enum System.Text.Json.Serialization.Metadata.JsonTypeInfoKind : Enum {
    public int value__;
    public static JsonTypeInfoKind None;
    public static JsonTypeInfoKind Object;
    public static JsonTypeInfoKind Enumerable;
    public static JsonTypeInfoKind Dictionary;
}
public static class System.Text.Json.Serialization.Metadata.JsonTypeInfoResolver : object {
    [NullableContextAttribute("1")]
public static IJsonTypeInfoResolver Combine(IJsonTypeInfoResolver[] resolvers);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceHandler : object {
    public static ReferenceHandler IgnoreCycles { get; }
    public static ReferenceHandler Preserve { get; }
    public static ReferenceHandler get_IgnoreCycles();
    public static ReferenceHandler get_Preserve();
    public abstract virtual ReferenceResolver CreateResolver();
}
public class System.Text.Json.Serialization.ReferenceHandler`1 : ReferenceHandler {
    [NullableContextAttribute("1")]
public virtual ReferenceResolver CreateResolver();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Text.Json.Serialization.ReferenceResolver : object {
    public abstract virtual void AddReference(string referenceId, object value);
    public abstract virtual string GetReference(object value, Boolean& alreadyExists);
    public abstract virtual object ResolveReference(string referenceId);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
[CompilerFeatureRequiredAttribute("RefStructs")]
public class System.Text.Json.Utf8JsonReader : ValueType {
    private object _dummy;
    private int _dummyPrimitive;
    public long BytesConsumed { get; }
    public int CurrentDepth { get; }
    public JsonReaderState CurrentState { get; }
    public bool HasValueSequence { get; }
    public bool IsFinalBlock { get; }
    public SequencePosition Position { get; }
    public long TokenStartIndex { get; }
    public JsonTokenType TokenType { get; }
    public bool ValueIsEscaped { get; }
    public ReadOnlySequence`1<byte> ValueSequence { get; }
    public ReadOnlySpan`1<byte> ValueSpan { get; }
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySequence`1<byte> jsonData, JsonReaderOptions options);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, bool isFinalBlock, JsonReaderState state);
    public Utf8JsonReader(ReadOnlySpan`1<byte> jsonData, JsonReaderOptions options);
    [IsReadOnlyAttribute]
public long get_BytesConsumed();
    [IsReadOnlyAttribute]
public int get_CurrentDepth();
    [IsReadOnlyAttribute]
public JsonReaderState get_CurrentState();
    [IsReadOnlyAttribute]
public bool get_HasValueSequence();
    [IsReadOnlyAttribute]
public bool get_IsFinalBlock();
    [IsReadOnlyAttribute]
public SequencePosition get_Position();
    [IsReadOnlyAttribute]
public long get_TokenStartIndex();
    [IsReadOnlyAttribute]
public JsonTokenType get_TokenType();
    [IsReadOnlyAttribute]
public bool get_ValueIsEscaped();
    [IsReadOnlyAttribute]
public ReadOnlySequence`1<byte> get_ValueSequence();
    [IsReadOnlyAttribute]
public ReadOnlySpan`1<byte> get_ValueSpan();
    [IsReadOnlyAttribute]
public int CopyString(Span`1<byte> utf8Destination);
    [IsReadOnlyAttribute]
public int CopyString(Span`1<char> destination);
    public bool GetBoolean();
    public byte GetByte();
    [NullableContextAttribute("1")]
public Byte[] GetBytesFromBase64();
    [NullableContextAttribute("1")]
public string GetComment();
    public DateTime GetDateTime();
    public DateTimeOffset GetDateTimeOffset();
    public decimal GetDecimal();
    public double GetDouble();
    public Guid GetGuid();
    public short GetInt16();
    public int GetInt32();
    public long GetInt64();
    [CLSCompliantAttribute("False")]
public sbyte GetSByte();
    public float GetSingle();
    [NullableContextAttribute("2")]
public string GetString();
    [CLSCompliantAttribute("False")]
public ushort GetUInt16();
    [CLSCompliantAttribute("False")]
public UInt32 GetUInt32();
    [CLSCompliantAttribute("False")]
public ulong GetUInt64();
    public bool Read();
    public void Skip();
    public bool TryGetByte(Byte& value);
    [NullableContextAttribute("2")]
public bool TryGetBytesFromBase64(Byte[]& value);
    public bool TryGetDateTime(DateTime& value);
    public bool TryGetDateTimeOffset(DateTimeOffset& value);
    public bool TryGetDecimal(Decimal& value);
    public bool TryGetDouble(Double& value);
    public bool TryGetGuid(Guid& value);
    public bool TryGetInt16(Int16& value);
    public bool TryGetInt32(Int32& value);
    public bool TryGetInt64(Int64& value);
    [CLSCompliantAttribute("False")]
public bool TryGetSByte(SByte& value);
    public bool TryGetSingle(Single& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt16(UInt16& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt32(UInt32& value);
    [CLSCompliantAttribute("False")]
public bool TryGetUInt64(UInt64& value);
    public bool TrySkip();
    [IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<byte> utf8Text);
    [IsReadOnlyAttribute]
public bool ValueTextEquals(ReadOnlySpan`1<char> text);
    [IsReadOnlyAttribute]
[NullableContextAttribute("2")]
public bool ValueTextEquals(string text);
}
public class System.Text.Json.Utf8JsonWriter : object {
    public long BytesCommitted { get; }
    public int BytesPending { get; }
    public int CurrentDepth { get; }
    public JsonWriterOptions Options { get; }
    [NullableContextAttribute("1")]
public Utf8JsonWriter(IBufferWriter`1<byte> bufferWriter, JsonWriterOptions options);
    [NullableContextAttribute("1")]
public Utf8JsonWriter(Stream utf8Json, JsonWriterOptions options);
    public long get_BytesCommitted();
    public int get_BytesPending();
    public int get_CurrentDepth();
    public JsonWriterOptions get_Options();
    public sealed virtual void Dispose();
    public sealed virtual ValueTask DisposeAsync();
    public void Flush();
    [NullableContextAttribute("1")]
public Task FlushAsync(CancellationToken cancellationToken);
    public void Reset();
    [NullableContextAttribute("1")]
public void Reset(IBufferWriter`1<byte> bufferWriter);
    [NullableContextAttribute("1")]
public void Reset(Stream utf8Json);
    public void WriteBase64String(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(string propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64String(JsonEncodedText propertyName, ReadOnlySpan`1<byte> bytes);
    public void WriteBase64StringValue(ReadOnlySpan`1<byte> bytes);
    public void WriteBoolean(ReadOnlySpan`1<byte> utf8PropertyName, bool value);
    public void WriteBoolean(ReadOnlySpan`1<char> propertyName, bool value);
    [NullableContextAttribute("1")]
public void WriteBoolean(string propertyName, bool value);
    public void WriteBoolean(JsonEncodedText propertyName, bool value);
    public void WriteBooleanValue(bool value);
    public void WriteCommentValue(ReadOnlySpan`1<byte> utf8Value);
    public void WriteCommentValue(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public void WriteCommentValue(string value);
    public void WriteEndArray();
    public void WriteEndObject();
    public void WriteNull(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteNull(ReadOnlySpan`1<char> propertyName);
    [NullableContextAttribute("1")]
public void WriteNull(string propertyName);
    public void WriteNull(JsonEncodedText propertyName);
    public void WriteNullValue();
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, float value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<byte> utf8PropertyName, ulong value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, decimal value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, double value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, int value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, long value);
    public void WriteNumber(ReadOnlySpan`1<char> propertyName, float value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(ReadOnlySpan`1<char> propertyName, ulong value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, decimal value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, double value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, int value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, long value);
    [NullableContextAttribute("1")]
public void WriteNumber(string propertyName, float value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, UInt32 value);
    [NullableContextAttribute("1")]
[CLSCompliantAttribute("False")]
public void WriteNumber(string propertyName, ulong value);
    public void WriteNumber(JsonEncodedText propertyName, decimal value);
    public void WriteNumber(JsonEncodedText propertyName, double value);
    public void WriteNumber(JsonEncodedText propertyName, int value);
    public void WriteNumber(JsonEncodedText propertyName, long value);
    public void WriteNumber(JsonEncodedText propertyName, float value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumber(JsonEncodedText propertyName, ulong value);
    public void WriteNumberValue(decimal value);
    public void WriteNumberValue(double value);
    public void WriteNumberValue(int value);
    public void WriteNumberValue(long value);
    public void WriteNumberValue(float value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(UInt32 value);
    [CLSCompliantAttribute("False")]
public void WriteNumberValue(ulong value);
    public void WritePropertyName(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WritePropertyName(ReadOnlySpan`1<char> propertyName);
    [NullableContextAttribute("1")]
public void WritePropertyName(string propertyName);
    public void WritePropertyName(JsonEncodedText propertyName);
    public void WriteRawValue(ReadOnlySpan`1<byte> utf8Json, bool skipInputValidation);
    public void WriteRawValue(ReadOnlySpan`1<char> json, bool skipInputValidation);
    [NullableContextAttribute("1")]
public void WriteRawValue(string json, bool skipInputValidation);
    public void WriteStartArray();
    public void WriteStartArray(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartArray(ReadOnlySpan`1<char> propertyName);
    [NullableContextAttribute("1")]
public void WriteStartArray(string propertyName);
    public void WriteStartArray(JsonEncodedText propertyName);
    public void WriteStartObject();
    public void WriteStartObject(ReadOnlySpan`1<byte> utf8PropertyName);
    public void WriteStartObject(ReadOnlySpan`1<char> propertyName);
    [NullableContextAttribute("1")]
public void WriteStartObject(string propertyName);
    public void WriteStartObject(JsonEncodedText propertyName);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, string value);
    public void WriteString(ReadOnlySpan`1<byte> utf8PropertyName, JsonEncodedText value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTime value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, DateTimeOffset value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, Guid value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, ReadOnlySpan`1<char> value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, string value);
    public void WriteString(ReadOnlySpan`1<char> propertyName, JsonEncodedText value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTime value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, DateTimeOffset value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, Guid value);
    public void WriteString(string propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(string propertyName, ReadOnlySpan`1<char> value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, string value);
    [NullableContextAttribute("1")]
public void WriteString(string propertyName, JsonEncodedText value);
    public void WriteString(JsonEncodedText propertyName, DateTime value);
    public void WriteString(JsonEncodedText propertyName, DateTimeOffset value);
    public void WriteString(JsonEncodedText propertyName, Guid value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<byte> utf8Value);
    public void WriteString(JsonEncodedText propertyName, ReadOnlySpan`1<char> value);
    [NullableContextAttribute("2")]
public void WriteString(JsonEncodedText propertyName, string value);
    public void WriteString(JsonEncodedText propertyName, JsonEncodedText value);
    public void WriteStringValue(DateTime value);
    public void WriteStringValue(DateTimeOffset value);
    public void WriteStringValue(Guid value);
    public void WriteStringValue(ReadOnlySpan`1<byte> utf8Value);
    public void WriteStringValue(ReadOnlySpan`1<char> value);
    [NullableContextAttribute("2")]
public void WriteStringValue(string value);
    public void WriteStringValue(JsonEncodedText value);
}
