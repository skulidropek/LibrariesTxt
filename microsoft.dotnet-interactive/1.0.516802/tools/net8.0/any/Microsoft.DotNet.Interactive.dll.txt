public class Microsoft.DotNet.Interactive.AutomationEnvironment : FrontendEnvironment {
}
public class Microsoft.DotNet.Interactive.Base64EncodedAssembly : object {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public Base64EncodedAssembly(string value);
    [CompilerGeneratedAttribute]
public string get_Value();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.ChooseKernelDirective : Command {
    [CompilerGeneratedAttribute]
private Kernel <Kernel>k__BackingField;
    public Kernel Kernel { get; }
    public ChooseKernelDirective(Kernel kernel, string description);
    [CompilerGeneratedAttribute]
public Kernel get_Kernel();
    protected virtual Task Handle(KernelInvocationContext kernelInvocationContext, InvocationContext commandLineInvocationContext);
    [CompilerGeneratedAttribute]
private Task <.ctor>b__0_0(InvocationContext ctx);
}
public class Microsoft.DotNet.Interactive.ChooseKeyValueStoreKernelDirective : ChooseKernelDirective {
    [CompilerGeneratedAttribute]
private Option`1<string> <MimeTypeOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<Uri> <FromUrlOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<FileInfo> <FromFileOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<string> <FromValueOption>k__BackingField;
    [CompilerGeneratedAttribute]
private Option`1<string> <NameOption>k__BackingField;
    public Option`1<string> MimeTypeOption { get; }
    public Option`1<Uri> FromUrlOption { get; }
    public Option`1<FileInfo> FromFileOption { get; }
    public Option`1<string> FromValueOption { get; }
    public Option`1<string> NameOption { get; }
    public ChooseKeyValueStoreKernelDirective(Kernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.ChooseKeyValueStoreKernelDirective/<Handle>d__1")]
protected virtual Task Handle(KernelInvocationContext kernelInvocationContext, InvocationContext commandLineInvocationContext);
    [CompilerGeneratedAttribute]
public Option`1<string> get_MimeTypeOption();
    [CompilerGeneratedAttribute]
public Option`1<Uri> get_FromUrlOption();
    [CompilerGeneratedAttribute]
public Option`1<FileInfo> get_FromFileOption();
    [CompilerGeneratedAttribute]
public Option`1<string> get_FromValueOption();
    [CompilerGeneratedAttribute]
public Option`1<string> get_NameOption();
    [CompilerGeneratedAttribute]
private FileInfo <.ctor>b__0_0(ArgumentResult result);
    [CompilerGeneratedAttribute]
private string <.ctor>b__0_1(ArgumentResult result);
    [CompilerGeneratedAttribute]
internal static bool <.ctor>g__SetErrorIfAlsoUsed|0_2(Option otherOption, ArgumentResult result);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(KernelInvocationContext kernelInvocationContext, InvocationContext commandLineInvocationContext);
}
public class Microsoft.DotNet.Interactive.CodeSubmissionCompilationErrorException : Exception {
    public CodeSubmissionCompilationErrorException(Exception innerException);
}
public class Microsoft.DotNet.Interactive.CommandNotSupportedException : Exception {
    public CommandNotSupportedException(Type commandType, Kernel kernel);
}
public class Microsoft.DotNet.Interactive.CommandRoutingSlip : RoutingSlip {
    public void StampAs(Uri uri, string tag);
    public virtual void Stamp(Uri uri);
    public void StampAsArrived(Uri uri);
}
[DebuggerStepThroughAttribute]
internal class Microsoft.DotNet.Interactive.Commands.AnonymousKernelCommand : KernelCommand {
    internal bool IsHidden { get; }
    public AnonymousKernelCommand(KernelCommandInvocation handler, string targetKernelName);
    internal virtual bool get_IsHidden();
}
public class Microsoft.DotNet.Interactive.Commands.Cancel : KernelCommand {
    public Cancel(string targetKernelName);
    public virtual Task InvokeAsync(KernelInvocationContext context);
}
internal class Microsoft.DotNet.Interactive.Commands.DirectiveCommand : KernelCommand {
    [CompilerGeneratedAttribute]
private ParseResult <ParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveNode <DirectiveNode>k__BackingField;
    public ParseResult ParseResult { get; }
    public DirectiveNode DirectiveNode { get; }
    internal bool IsHidden { get; }
    internal DirectiveCommand(ParseResult parseResult, DirectiveNode directiveNode);
    [CompilerGeneratedAttribute]
public ParseResult get_ParseResult();
    [CompilerGeneratedAttribute]
public DirectiveNode get_DirectiveNode();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Commands.DirectiveCommand/<InvokeAsync>d__7")]
public virtual Task InvokeAsync(KernelInvocationContext context);
    internal virtual bool get_IsHidden();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Commands.DisplayError : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public DisplayError(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
private Task <.ctor>b__0_0(KernelCommand _, KernelInvocationContext context);
}
public class Microsoft.DotNet.Interactive.Commands.DisplayValue : KernelCommand {
    [CompilerGeneratedAttribute]
private FormattedValue <FormattedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueId>k__BackingField;
    public FormattedValue FormattedValue { get; }
    public string ValueId { get; }
    public DisplayValue(FormattedValue formattedValue, string valueId);
    [CompilerGeneratedAttribute]
public FormattedValue get_FormattedValue();
    [CompilerGeneratedAttribute]
public string get_ValueId();
    public virtual Task InvokeAsync(KernelInvocationContext context);
}
public abstract class Microsoft.DotNet.Interactive.Commands.KernelCommand : object {
    private KernelCommand _parent;
    private string _token;
    private List`1<KernelCommand> _childCommandsToBubbleEventsFrom;
    private KernelCommand _selfOrFirstUnhiddenAncestor;
    [CompilerGeneratedAttribute]
private KernelCommandInvocation <Handler>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TargetKernelName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <OriginUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <DestinationUri>k__BackingField;
    private int _childTokenCounter;
    [CompilerGeneratedAttribute]
private SchedulingScope <SchedulingScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <ShouldPublishCompletionEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ParseResult <KernelChooserParseResult>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandRoutingSlip <RoutingSlip>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasProxied>k__BackingField;
    [JsonIgnoreAttribute]
public KernelCommandInvocation Handler { get; public set; }
    [JsonIgnoreAttribute]
public KernelCommand Parent { get; }
    public string TargetKernelName { get; internal set; }
    internal static KernelCommand None { get; }
    public Uri OriginUri { get; public set; }
    public Uri DestinationUri { get; public set; }
    [JsonIgnoreAttribute]
internal SchedulingScope SchedulingScope { get; internal set; }
    [JsonIgnoreAttribute]
internal Nullable`1<bool> ShouldPublishCompletionEvent { get; internal set; }
    [JsonIgnoreAttribute]
public ParseResult KernelChooserParseResult { get; internal set; }
    [JsonIgnoreAttribute]
public CommandRoutingSlip RoutingSlip { get; }
    internal bool WasProxied { get; internal set; }
    internal bool IsHidden { get; }
    internal KernelCommand SelfOrFirstUnhiddenAncestor { get; }
    protected KernelCommand(string targetKernelName);
    [CompilerGeneratedAttribute]
public KernelCommandInvocation get_Handler();
    [CompilerGeneratedAttribute]
public void set_Handler(KernelCommandInvocation value);
    public KernelCommand get_Parent();
    public void SetParent(KernelCommand parent, bool bubbleEvents);
    [CompilerGeneratedAttribute]
public string get_TargetKernelName();
    [CompilerGeneratedAttribute]
internal void set_TargetKernelName(string value);
    internal static KernelCommand get_None();
    [CompilerGeneratedAttribute]
public Uri get_OriginUri();
    [CompilerGeneratedAttribute]
public void set_OriginUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_DestinationUri();
    [CompilerGeneratedAttribute]
public void set_DestinationUri(Uri value);
    public void SetToken(string token);
    private int GetNextChildToken();
    public string GetOrCreateToken();
    [CompilerGeneratedAttribute]
internal SchedulingScope get_SchedulingScope();
    [CompilerGeneratedAttribute]
internal void set_SchedulingScope(SchedulingScope value);
    [CompilerGeneratedAttribute]
internal Nullable`1<bool> get_ShouldPublishCompletionEvent();
    [CompilerGeneratedAttribute]
internal void set_ShouldPublishCompletionEvent(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public ParseResult get_KernelChooserParseResult();
    [CompilerGeneratedAttribute]
internal void set_KernelChooserParseResult(ParseResult value);
    [CompilerGeneratedAttribute]
public CommandRoutingSlip get_RoutingSlip();
    [CompilerGeneratedAttribute]
internal bool get_WasProxied();
    [CompilerGeneratedAttribute]
internal void set_WasProxied(bool value);
    private void ResultShouldIncludeEventsFrom(KernelCommand childCommand);
    internal bool ShouldResultIncludeEventsFrom(KernelCommand childCommand);
    public virtual Task InvokeAsync(KernelInvocationContext context);
    public sealed virtual bool Equals(KernelCommand other);
    internal bool IsSelfOrDescendantOf(KernelCommand other);
    internal bool HasSameRootCommandAs(KernelCommand other);
    internal static string GetRootToken(string token);
    internal virtual bool get_IsHidden();
    internal KernelCommand get_SelfOrFirstUnhiddenAncestor();
    [CompilerGeneratedAttribute]
internal static string <GetOrCreateToken>g__CreateRootToken|29_0();
}
public abstract class Microsoft.DotNet.Interactive.Commands.LanguageServiceCommand : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <LinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageNode <LanguageNode>k__BackingField;
    public string Code { get; protected set; }
    public LinePosition LinePosition { get; protected set; }
    internal LanguageNode LanguageNode { get; }
    protected LanguageServiceCommand(string code, LinePosition linePosition, string targetKernelName);
    protected LanguageServiceCommand(LanguageNode languageNode, LinePosition linePosition);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
protected void set_Code(string value);
    [CompilerGeneratedAttribute]
public LinePosition get_LinePosition();
    [CompilerGeneratedAttribute]
protected void set_LinePosition(LinePosition value);
    internal abstract virtual LanguageServiceCommand With(LanguageNode languageNode, LinePosition position);
    [CompilerGeneratedAttribute]
internal LanguageNode get_LanguageNode();
}
internal class Microsoft.DotNet.Interactive.Commands.NoCommand : KernelCommand {
}
public class Microsoft.DotNet.Interactive.Commands.Quit : KernelCommand {
    public virtual Task InvokeAsync(KernelInvocationContext context);
}
public class Microsoft.DotNet.Interactive.Commands.RequestCompletions : LanguageServiceCommand {
    public RequestCompletions(string code, LinePosition linePosition, string targetKernelName);
    internal RequestCompletions(LanguageNode languageNode, LinePosition linePosition);
    internal virtual LanguageServiceCommand With(LanguageNode languageNode, LinePosition position);
}
public class Microsoft.DotNet.Interactive.Commands.RequestDiagnostics : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageNode <LanguageNode>k__BackingField;
    public string Code { get; }
    internal LanguageNode LanguageNode { get; }
    public RequestDiagnostics(string code, string targetKernelName);
    internal RequestDiagnostics(LanguageNode languageNode);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
internal LanguageNode get_LanguageNode();
}
public class Microsoft.DotNet.Interactive.Commands.RequestHoverText : LanguageServiceCommand {
    public RequestHoverText(string code, LinePosition linePosition, string targetKernelName);
    internal RequestHoverText(LanguageNode languageNode, LinePosition linePosition);
    internal virtual LanguageServiceCommand With(LanguageNode languageNode, LinePosition position);
}
public class Microsoft.DotNet.Interactive.Commands.RequestInput : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Prompt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPassword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InputTypeHint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueName>k__BackingField;
    public string Prompt { get; }
    public bool IsPassword { get; }
    public string InputTypeHint { get; }
    public string ValueName { get; }
    public RequestInput(string prompt, string targetKernelName, string inputTypeHint, string valueName);
    [CompilerGeneratedAttribute]
public string get_Prompt();
    [CompilerGeneratedAttribute]
public bool get_IsPassword();
    [CompilerGeneratedAttribute]
public string get_InputTypeHint();
    [CompilerGeneratedAttribute]
public string get_ValueName();
}
public class Microsoft.DotNet.Interactive.Commands.RequestKernelInfo : KernelCommand {
    [JsonConstructorAttribute]
public RequestKernelInfo(string targetKernelName);
    public RequestKernelInfo(Uri destinationUri);
}
public class Microsoft.DotNet.Interactive.Commands.RequestSignatureHelp : LanguageServiceCommand {
    public RequestSignatureHelp(string code, LinePosition linePosition, string targetKernelName);
    internal RequestSignatureHelp(LanguageNode languageNode, LinePosition linePosition);
    internal virtual LanguageServiceCommand With(LanguageNode languageNode, LinePosition position);
}
public class Microsoft.DotNet.Interactive.Commands.RequestValue : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string Name { get; }
    public string MimeType { get; }
    public RequestValue(string name, string mimeType, string targetKernelName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_MimeType();
}
public class Microsoft.DotNet.Interactive.Commands.RequestValueInfos : KernelCommand {
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    public string MimeType { get; }
    public RequestValueInfos(string targetKernelName, string mimeType);
    [CompilerGeneratedAttribute]
public string get_MimeType();
}
public class Microsoft.DotNet.Interactive.Commands.SendEditableCode : KernelCommand {
    [CompilerGeneratedAttribute]
private string <KernelName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    public string KernelName { get; }
    public string Code { get; }
    public SendEditableCode(string kernelName, string code, string targetKernelName);
    [CompilerGeneratedAttribute]
public string get_KernelName();
    [CompilerGeneratedAttribute]
public string get_Code();
}
public class Microsoft.DotNet.Interactive.Commands.SendValue : KernelCommand {
    [CompilerGeneratedAttribute]
private FormattedValue <FormattedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public FormattedValue FormattedValue { get; }
    public string Name { get; }
    [JsonIgnoreAttribute]
public object Value { get; }
    public SendValue(string name, object value, FormattedValue formattedValue, string targetKernelName);
    [CompilerGeneratedAttribute]
public FormattedValue get_FormattedValue();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
}
public class Microsoft.DotNet.Interactive.Commands.SubmitCode : KernelCommand {
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private LanguageNode <LanguageNode>k__BackingField;
    [CompilerGeneratedAttribute]
private KernelNameDirectiveNode <KernelNameDirectiveNode>k__BackingField;
    public string Code { get; internal set; }
    internal LanguageNode LanguageNode { get; }
    internal KernelNameDirectiveNode KernelNameDirectiveNode { get; }
    public SubmitCode(string code, string targetKernelName);
    internal SubmitCode(LanguageNode languageNode, KernelNameDirectiveNode kernelNameDirectiveNode);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
internal void set_Code(string value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal LanguageNode get_LanguageNode();
    [CompilerGeneratedAttribute]
internal KernelNameDirectiveNode get_KernelNameDirectiveNode();
}
public class Microsoft.DotNet.Interactive.Commands.UpdateDisplayedValue : KernelCommand {
    [CompilerGeneratedAttribute]
private FormattedValue <FormattedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueId>k__BackingField;
    public FormattedValue FormattedValue { get; }
    public string ValueId { get; }
    public UpdateDisplayedValue(FormattedValue formattedValue, string valueId);
    [CompilerGeneratedAttribute]
public FormattedValue get_FormattedValue();
    [CompilerGeneratedAttribute]
public string get_ValueId();
    public virtual Task InvokeAsync(KernelInvocationContext context);
}
public class Microsoft.DotNet.Interactive.CompositeKernel : Kernel {
    private KernelCollection _childKernels;
    private string _defaultKernelName;
    private Command _connectDirective;
    private KernelHost _host;
    private ConcurrentDictionary`2<Type, string> _defaultKernelNamesByCommandType;
    public string DefaultKernelName { get; public set; }
    public KernelCollection ChildKernels { get; }
    public KernelHost Host { get; }
    public CompositeKernel(string name);
    public string get_DefaultKernelName();
    public void set_DefaultKernelName(string value);
    public void Add(Kernel kernel, IEnumerable`1<string> aliases);
    public void SetDefaultTargetKernelNameForCommand(Type commandType, string kernelName);
    private void AddChooseKernelDirective(Kernel kernel);
    public KernelCollection get_ChildKernels();
    protected virtual void SetHandlingKernel(KernelCommand command, KernelInvocationContext context);
    private protected virtual Kernel GetHandlingKernel(KernelCommand command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.CompositeKernel/<HandleAsync>d__16")]
internal virtual Task HandleAsync(KernelCommand command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.CompositeKernel/<HandleRequestKernelInfoAsync>d__17")]
private protected virtual Task HandleRequestKernelInfoAsync(RequestKernelInfo command, KernelInvocationContext context);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.CompositeKernel/<GetDirectiveParsersForCompletion>d__18")]
private protected virtual IEnumerable`1<Parser> GetDirectiveParsersForCompletion(DirectiveNode directiveNode, int requestPosition);
    public sealed virtual IEnumerator`1<Kernel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public void AddKernelConnector(ConnectKernelCommand connectionCommand);
    public KernelHost get_Host();
    internal void SetHost(KernelHost host);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__0(KernelCommand command, KernelInvocationContext context);
    [CompilerGeneratedAttribute]
internal static bool <GetDirectiveParsersForCompletion>g__IsDirectiveDefinedIn|18_0(Parser parser, <>c__DisplayClass18_0& );
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Connection.CommandOrEvent : object {
    [CompilerGeneratedAttribute]
private KernelCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private KernelEvent <Event>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsParseError>k__BackingField;
    public KernelCommand Command { get; }
    public KernelEvent Event { get; }
    public bool IsParseError { get; }
    public CommandOrEvent(KernelCommand kernelCommand);
    public CommandOrEvent(KernelEvent kernelEvent, bool isParseError);
    [CompilerGeneratedAttribute]
public KernelCommand get_Command();
    [CompilerGeneratedAttribute]
public KernelEvent get_Event();
    [CompilerGeneratedAttribute]
public bool get_IsParseError();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Connection.CompositeKernelExtensions : object {
    [ExtensionAttribute]
public static KernelHost UseHost(CompositeKernel kernel, IKernelCommandAndEventSender sender, IKernelCommandAndEventReceiver receiver, Uri hostUri);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.DotNet.Interactive.Connection.ConnectKernelCommand : Command {
    [NullableAttribute("1")]
public Option`1<string> KernelNameOption;
    [CompilerGeneratedAttribute]
private string <ConnectedKernelDescription>k__BackingField;
    public string ConnectedKernelDescription { get; public set; }
    [NullableContextAttribute("1")]
protected ConnectKernelCommand(string name, string description);
    [CompilerGeneratedAttribute]
public string get_ConnectedKernelDescription();
    [CompilerGeneratedAttribute]
public void set_ConnectedKernelDescription(string value);
    [NullableContextAttribute("1")]
public abstract virtual Task`1<IEnumerable`1<Kernel>> ConnectKernelsAsync(KernelInvocationContext context, InvocationContext commandLineContext);
}
public class Microsoft.DotNet.Interactive.Connection.FileSystemInfoJsonConverter : JsonConverter`1<FileSystemInfo> {
    public virtual FileSystemInfo Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, FileSystemInfo value, JsonSerializerOptions options);
}
public interface Microsoft.DotNet.Interactive.Connection.IKernelCommandAndEventReceiver {
}
public interface Microsoft.DotNet.Interactive.Connection.IKernelCommandAndEventSender {
    public Uri RemoteHostUri { get; }
    public abstract virtual Task SendAsync(KernelCommand kernelCommand, CancellationToken cancellationToken);
    public abstract virtual Task SendAsync(KernelEvent kernelEvent, CancellationToken cancellationToken);
    public abstract virtual Uri get_RemoteHostUri();
}
public interface Microsoft.DotNet.Interactive.Connection.IKernelCommandEnvelope {
    public KernelCommand Command { get; }
    public string CommandType { get; }
    public string Token { get; }
    public abstract virtual KernelCommand get_Command();
    public abstract virtual string get_CommandType();
    public abstract virtual string get_Token();
}
public interface Microsoft.DotNet.Interactive.Connection.IKernelEventEnvelope {
    public KernelEvent Event { get; }
    public string EventType { get; }
    public abstract virtual KernelEvent get_Event();
    public abstract virtual string get_EventType();
}
public abstract class Microsoft.DotNet.Interactive.Connection.KernelClientBase : object {
    public IObservable`1<KernelEvent> KernelEvents { get; }
    public abstract virtual IObservable`1<KernelEvent> get_KernelEvents();
    public abstract virtual Task SendAsync(KernelCommand command, string token);
}
public class Microsoft.DotNet.Interactive.Connection.KernelCommandAndEventReceiver : object {
    private ReadCommandOrEvent _readCommandOrEvent;
    private Subject`1<CommandOrEvent> _subject;
    private IObservable`1<CommandOrEvent> _observable;
    private CompositeDisposable _disposables;
    private CancellationTokenSource _cancellationTokenSource;
    public KernelCommandAndEventReceiver(ReadCommandOrEvent readCommandOrEvent);
    private KernelCommandAndEventReceiver(IObservable`1<string> messages);
    private void ReaderLoop();
    public sealed virtual IDisposable Subscribe(IObserver`1<CommandOrEvent> observer);
    private void TryCancelCancellationToken();
    public sealed virtual void Dispose();
    public static KernelCommandAndEventReceiver FromObservable(IObservable`1<string> messages);
    public static KernelCommandAndEventReceiver FromTextReader(TextReader reader);
    public static KernelCommandAndEventReceiver FromNamedPipe(PipeStream stream);
    [CompilerGeneratedAttribute]
private IObservable`1<CommandOrEvent> <.ctor>b__5_0();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private IDisposable <.ctor>b__5_1(IObserver`1<CommandOrEvent> observer);
}
public class Microsoft.DotNet.Interactive.Connection.KernelCommandAndEventSender : object {
    private Func`3<string, CancellationToken, Task> _sendAsync;
    [CompilerGeneratedAttribute]
private Uri <RemoteHostUri>k__BackingField;
    public Uri RemoteHostUri { get; }
    public KernelCommandAndEventSender(IObserver`1<string> observer, Uri remoteHostUri);
    public KernelCommandAndEventSender(Func`3<string, CancellationToken, Task> sendAsync, Uri remoteHostUri);
    private KernelCommandAndEventSender(Uri remoteHostUri);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.KernelCommandAndEventSender/<SendAsync>d__4")]
public sealed virtual Task SendAsync(KernelCommand kernelCommand, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.KernelCommandAndEventSender/<SendAsync>d__5")]
public sealed virtual Task SendAsync(KernelEvent kernelEvent, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public sealed virtual Uri get_RemoteHostUri();
    public static KernelCommandAndEventSender FromNamedPipe(PipeStream pipeStream, Uri remoteHostUri);
    public static KernelCommandAndEventSender FromTextWriter(TextWriter writer, Uri remoteHostUri);
    public static KernelCommandAndEventSender FromObserver(IObserver`1<string> observer, Uri remoteHostUri);
}
public abstract class Microsoft.DotNet.Interactive.Connection.KernelCommandEnvelope : object {
    private static ConcurrentDictionary`2<Type, Func`2<KernelCommand, IKernelCommandEnvelope>> _envelopeFactories;
    private static ConcurrentDictionary`2<string, Type> _envelopeTypesByCommandTypeName;
    private static ConcurrentDictionary`2<string, Type> _commandTypesByCommandTypeName;
    private KernelCommand _command;
    public string CommandType { get; }
    public string Token { get; }
    private KernelCommand Microsoft.DotNet.Interactive.Connection.IKernelCommandEnvelope.Command { get; }
    private static KernelCommandEnvelope();
    protected KernelCommandEnvelope(KernelCommand command);
    internal static Type CommandTypeByName(string name);
    public abstract virtual string get_CommandType();
    public sealed virtual string get_Token();
    private sealed virtual override KernelCommand Microsoft.DotNet.Interactive.Connection.IKernelCommandEnvelope.get_Command();
    public static void RegisterCommand();
    public static void RegisterCommand(Type commandType);
    public static void RegisterDefaults();
    public static IKernelCommandEnvelope Create(KernelCommand command);
    public static IKernelCommandEnvelope Deserialize(string json);
    public static IKernelCommandEnvelope Deserialize(JsonElement json);
    public static string Serialize(KernelCommand command);
    public static string Serialize(IKernelCommandEnvelope envelope);
    private static SerializationModel CreateSerializationModel(IKernelCommandEnvelope envelope);
}
public class Microsoft.DotNet.Interactive.Connection.KernelCommandEnvelope`1 : KernelCommandEnvelope {
    [CompilerGeneratedAttribute]
private T <Command>k__BackingField;
    public T Command { get; }
    public string CommandType { get; }
    public KernelCommandEnvelope`1(T command);
    [CompilerGeneratedAttribute]
public T get_Command();
    public virtual string get_CommandType();
}
public abstract class Microsoft.DotNet.Interactive.Connection.KernelEventEnvelope : object {
    private static ConcurrentDictionary`2<Type, Func`2<KernelEvent, IKernelEventEnvelope>> _envelopeFactories;
    private static Dictionary`2<string, Type> _envelopeTypesByEventTypeName;
    private static Dictionary`2<string, Type> _eventTypesByEventTypeName;
    private KernelEvent _event;
    [CompilerGeneratedAttribute]
private string <CommandType>k__BackingField;
    public string CommandType { get; }
    public string EventType { get; }
    private KernelEvent Microsoft.DotNet.Interactive.Connection.IKernelEventEnvelope.Event { get; }
    private static KernelEventEnvelope();
    protected KernelEventEnvelope(KernelEvent event);
    internal static Type EventTypeByName(string name);
    [CompilerGeneratedAttribute]
public string get_CommandType();
    public abstract virtual string get_EventType();
    private sealed virtual override KernelEvent Microsoft.DotNet.Interactive.Connection.IKernelEventEnvelope.get_Event();
    public static void RegisterEvent();
    public static void RegisterEvent(Type eventType);
    public static void RegisterDefaults();
    public static IKernelEventEnvelope Create(KernelEvent event);
    public static IKernelEventEnvelope Deserialize(string json);
    public static IKernelEventEnvelope Deserialize(JsonElement jsonObject);
    public static IKernelEventEnvelope DeserializeWithCommand(string json, KernelCommand command);
    public static IKernelEventEnvelope DeserializeWithCommand(JsonElement jsonObject, KernelCommand command);
    private static object GetDefaultValueForType(Type type);
    public static string Serialize(KernelEvent event);
    public static string Serialize(IKernelEventEnvelope eventEnvelope);
}
public class Microsoft.DotNet.Interactive.Connection.KernelEventEnvelope`1 : KernelEventEnvelope {
    [CompilerGeneratedAttribute]
private T <Event>k__BackingField;
    public T Event { get; }
    public string EventType { get; }
    public KernelEventEnvelope`1(T event);
    [CompilerGeneratedAttribute]
public T get_Event();
    public virtual string get_EventType();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Connection.PipeStreamExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.PipeStreamExtensions/<ReadMessageAsync>d__0")]
[ExtensionAttribute]
public static Task`1<string> ReadMessageAsync(PipeStream stream, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static void WriteMessage(PipeStream stream, string message);
}
public class Microsoft.DotNet.Interactive.Connection.ProxyKernel : Kernel {
    private IKernelCommandAndEventSender _sender;
    private IKernelCommandAndEventReceiver _receiver;
    private ExecutionContext _executionContext;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, ValueTuple`4<KernelCommand, ExecutionContext, TaskCompletionSource`1<KernelEvent>, KernelInvocationContext>> _inflight;
    internal bool AcceptsUnknownDirectives { get; }
    public ProxyKernel(string name, IKernelCommandAndEventSender sender, IKernelCommandAndEventReceiver receiver, Uri remoteUri);
    internal virtual bool get_AcceptsUnknownDirectives();
    private void UpdateKernelInfoFromEvent(KernelInfoProduced kernelInfoProduced);
    private Task HandleByForwardingToRemoteAsync(KernelCommand command, KernelInvocationContext context);
    private bool CanHandleLocally(KernelCommand command);
    protected virtual Func`3<TCommand, KernelInvocationContext, Task> CreateDefaultHandlerForCommandType();
    internal virtual Task HandleAsync(KernelCommand command, KernelInvocationContext context);
    private protected virtual Task HandleRequestKernelInfoAsync(RequestKernelInfo command, KernelInvocationContext context);
    private void DelegatePublication(KernelEvent kernelEvent);
    private bool HasSameOrigin(KernelEvent kernelEvent);
    public void UpdateKernelInfo(KernelInfo kernelInfo);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(CommandOrEvent coe);
}
public class Microsoft.DotNet.Interactive.Connection.ReadCommandOrEvent : MulticastDelegate {
    public ReadCommandOrEvent(object object, IntPtr method);
    public virtual CommandOrEvent Invoke(CancellationToken cancellationToken);
    public virtual IAsyncResult BeginInvoke(CancellationToken cancellationToken, AsyncCallback callback, object object);
    public virtual CommandOrEvent EndInvoke(IAsyncResult result);
}
public static class Microsoft.DotNet.Interactive.Connection.Serializer : object {
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <JsonSerializerOptions>k__BackingField;
    public static JsonSerializerOptions JsonSerializerOptions { get; }
    private static Serializer();
    [CompilerGeneratedAttribute]
public static JsonSerializerOptions get_JsonSerializerOptions();
    public static CommandOrEvent DeserializeCommandOrEvent(string json);
    public static CommandOrEvent DeserializeCommandOrEvent(JsonElement jsonObject);
    private static bool IsEventEnvelope(JsonElement jsonObject);
    private static bool IsCommandEnvelope(JsonElement jsonObject);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.Connection.StdIoKernelConnector : object {
    private String[] _command;
    private string _rootProxyKernelLocalName;
    private Uri _kernelHostUri;
    private DirectoryInfo _workingDirectory;
    private ConcurrentDictionary`2<string, KernelInfo> _remoteKernelInfoCache;
    [NullableAttribute("2")]
private KernelCommandAndEventReceiver _receiver;
    [NullableAttribute("2")]
private KernelCommandAndEventSender _sender;
    [NullableAttribute("2")]
private Process _process;
    [NullableAttribute("2")]
private RefCountDisposable _refCountDisposable;
    public Nullable`1<int> ProcessId { get; }
    public StdIoKernelConnector(String[] command, string rootProxyKernelLocalName, Uri kernelHostUri, DirectoryInfo workingDirectory);
    public Nullable`1<int> get_ProcessId();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.StdIoKernelConnector/<CreateRootProxyKernelAsync>d__12")]
public Task`1<ProxyKernel> CreateRootProxyKernelAsync();
    private string GetCurrentCulture();
    private string GetCurrentUICulture();
    private void UpdateRemoteKernelInfoCache(IEnumerable`1<KernelInfo> infos);
    private void UpdateRemoteKernelInfoCache(KernelInfo info);
    private KernelInfo GetCachedKernelInfoForRemoteRoot();
    private bool TryGetCachedKernelInfoByRemoteName(string remoteName, KernelInfo& remoteInfo);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.StdIoKernelConnector/<CreateProxyKernelAsync>d__19")]
public Task`1<ProxyKernel> CreateProxyKernelAsync(string remoteName, string localNameOverride);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Connection.StdIoKernelConnector/<CreateProxyKernelAsync>d__20")]
public Task`1<ProxyKernel> CreateProxyKernelAsync(KernelInfo remoteInfo, string localNameOverride);
    private void SendQuitCommand();
    private void KillRemoteKernelProcess();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <CreateRootProxyKernelAsync>b__12_5(KernelInfoProduced e);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <GetCachedKernelInfoForRemoteRoot>b__17_0(KernelInfo k);
}
public class Microsoft.DotNet.Interactive.DataDictionaryConverter : JsonConverter`1<IDictionary`2<string, object>> {
    public virtual IDictionary`2<string, object> Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    private static object GetValue(Utf8JsonReader& reader, JsonSerializerOptions options);
    private static object ParseArray(Utf8JsonReader& reader, JsonSerializerOptions options);
    [CompilerGeneratedAttribute]
internal static object <GetValue>g__GetNumber|1_0(Utf8JsonReader& reader);
}
public static class Microsoft.DotNet.Interactive.DataExplorer : object {
    private static ConcurrentDictionary`2<Type, HashSet`1<Type>> Explorers;
    private static ConcurrentDictionary`2<Type, Type> DefaultExplorer;
    private static DataExplorer();
    public static void ResetToDefault();
    public static DataExplorer`1<TData> Create(string dataExplorerTypeName, TData data);
    public static DataExplorer`1<TData> CreateDefault(TData data);
    public static void SetDefault();
    public static void Register(Type dataType, Type dataExplorerType);
    public static void Register();
}
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.DataExplorerFormatterSource")]
public abstract class Microsoft.DotNet.Interactive.DataExplorer`1 : object {
    [CompilerGeneratedAttribute]
private string <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private TData <Data>k__BackingField;
    public string Id { get; }
    public TData Data { get; }
    private static DataExplorer`1();
    protected DataExplorer`1(TData data);
    [CompilerGeneratedAttribute]
public string get_Id();
    [CompilerGeneratedAttribute]
public TData get_Data();
    public static void RegisterFormatters();
    protected abstract virtual IHtmlContent ToHtml();
    public static void Register();
}
internal class Microsoft.DotNet.Interactive.DataExplorerFormatterSource : object {
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.DataExplorerFormatterSource/<CreateTypeFormatters>d__0")]
public sealed virtual IEnumerable`1<ITypeFormatter> CreateTypeFormatters();
}
public class Microsoft.DotNet.Interactive.Diagnostic : object {
    [CompilerGeneratedAttribute]
private LinePositionSpan <LinePositionSpan>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public LinePositionSpan LinePositionSpan { get; }
    public DiagnosticSeverity Severity { get; }
    public string Code { get; }
    public string Message { get; }
    public Diagnostic(LinePositionSpan linePositionSpan, DiagnosticSeverity severity, string code, string message);
    [CompilerGeneratedAttribute]
public LinePositionSpan get_LinePositionSpan();
    [CompilerGeneratedAttribute]
public DiagnosticSeverity get_Severity();
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public string get_Message();
    public Diagnostic WithLinePositionSpan(LinePositionSpan linePositionSpan);
    public virtual string ToString();
    public static Diagnostic FromCodeAnalysisDiagnostic(Diagnostic diagnostic);
}
public class Microsoft.DotNet.Interactive.DisplayedValue : object {
    private KernelInvocationContext _context;
    [CompilerGeneratedAttribute]
private string <DisplayId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<FormattedValue> <FormattedValues>k__BackingField;
    public string DisplayId { get; }
    public IReadOnlyList`1<FormattedValue> FormattedValues { get; private set; }
    public DisplayedValue(IReadOnlyList`1<FormattedValue> formattedValues, KernelInvocationContext context);
    [CompilerGeneratedAttribute]
public string get_DisplayId();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<FormattedValue> get_FormattedValues();
    [CompilerGeneratedAttribute]
private void set_FormattedValues(IReadOnlyList`1<FormattedValue> value);
    public void Update(object updatedValue);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.DotNetStandardHelpers : object {
    [ExtensionAttribute]
internal static bool GetIsCompletedSuccessfully(Task task);
}
public class Microsoft.DotNet.Interactive.EventRoutingSlip : RoutingSlip {
    public virtual void Stamp(Uri uri);
}
public class Microsoft.DotNet.Interactive.Events.CodeSubmissionReceived : KernelEvent {
    public string Code { get; }
    public CodeSubmissionReceived(SubmitCode command);
    public string get_Code();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.CommandFailed : KernelCommandCompletionEvent {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonIgnoreAttribute]
public Exception Exception { get; }
    public string Message { get; public set; }
    public CommandFailed(Exception exception, KernelCommand command, string message, Nullable`1<int> executionOrder);
    public CommandFailed(string message, KernelCommand command, Nullable`1<int> executionOrder);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.CommandSucceeded : KernelCommandCompletionEvent {
    public CommandSucceeded(KernelCommand command, int executionOrder);
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.CompleteCodeSubmissionReceived : KernelEvent {
    public string Code { get; }
    public CompleteCodeSubmissionReceived(SubmitCode submitCode);
    public string get_Code();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.CompletionItem : object {
    [CompilerGeneratedAttribute]
private string <DisplayText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilterText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SortText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <InsertText>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<InsertTextFormat> <InsertTextFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Documentation>k__BackingField;
    public string DisplayText { get; }
    public string Kind { get; }
    public string FilterText { get; }
    public string SortText { get; }
    public string InsertText { get; }
    public Nullable`1<InsertTextFormat> InsertTextFormat { get; }
    public string Documentation { get; public set; }
    public CompletionItem(string displayText, string kind, string filterText, string sortText, string insertText, Nullable`1<InsertTextFormat> insertTextFormat, string documentation);
    [CompilerGeneratedAttribute]
public string get_DisplayText();
    [CompilerGeneratedAttribute]
public string get_Kind();
    [CompilerGeneratedAttribute]
public string get_FilterText();
    [CompilerGeneratedAttribute]
public string get_SortText();
    [CompilerGeneratedAttribute]
public string get_InsertText();
    [CompilerGeneratedAttribute]
public Nullable`1<InsertTextFormat> get_InsertTextFormat();
    [CompilerGeneratedAttribute]
public string get_Documentation();
    [CompilerGeneratedAttribute]
public void set_Documentation(string value);
    public virtual string ToString();
}
internal class Microsoft.DotNet.Interactive.Events.CompletionItemComparer : object {
    [CompilerGeneratedAttribute]
private static IEqualityComparer`1<CompletionItem> <Instance>k__BackingField;
    public static IEqualityComparer`1<CompletionItem> Instance { get; }
    private static CompletionItemComparer();
    [CompilerGeneratedAttribute]
public static IEqualityComparer`1<CompletionItem> get_Instance();
    public sealed virtual bool Equals(CompletionItem x, CompletionItem y);
    public sealed virtual int GetHashCode(CompletionItem obj);
}
public class Microsoft.DotNet.Interactive.Events.CompletionsProduced : KernelEvent {
    private LinePositionSpan _linePositionSpan;
    [CompilerGeneratedAttribute]
private IEnumerable`1<CompletionItem> <Completions>k__BackingField;
    public LinePositionSpan LinePositionSpan { get; }
    public IEnumerable`1<CompletionItem> Completions { get; }
    public CompletionsProduced(IEnumerable`1<CompletionItem> completions, RequestCompletions command, LinePositionSpan linePositionSpan);
    public LinePositionSpan get_LinePositionSpan();
    [CompilerGeneratedAttribute]
public IEnumerable`1<CompletionItem> get_Completions();
}
public class Microsoft.DotNet.Interactive.Events.DiagnosticsProduced : KernelEvent {
    private IReadOnlyCollection`1<Diagnostic> _diagnostics;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FormattedValue> <FormattedDiagnostics>k__BackingField;
    public IReadOnlyCollection`1<Diagnostic> Diagnostics { get; }
    public IReadOnlyCollection`1<FormattedValue> FormattedDiagnostics { get; }
    public DiagnosticsProduced(IEnumerable`1<Diagnostic> diagnostics, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedDiagnostics);
    public IReadOnlyCollection`1<Diagnostic> get_Diagnostics();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FormattedValue> get_FormattedDiagnostics();
    public virtual string ToString();
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Events.DisplayedValueProduced : DisplayEvent {
    public DisplayedValueProduced(object value, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues, string valueId);
}
public class Microsoft.DotNet.Interactive.Events.DisplayedValueUpdated : DisplayEvent {
    public DisplayedValueUpdated(object value, string valueId, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues);
}
[DebuggerStepThroughAttribute]
public abstract class Microsoft.DotNet.Interactive.Events.DisplayEvent : KernelEvent {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FormattedValue> <FormattedValues>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValueId>k__BackingField;
    [JsonIgnoreAttribute]
public object Value { get; }
    public IReadOnlyCollection`1<FormattedValue> FormattedValues { get; }
    public string ValueId { get; }
    protected DisplayEvent(object value, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues, string valueId);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FormattedValue> get_FormattedValues();
    [CompilerGeneratedAttribute]
public string get_ValueId();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.ErrorProduced : DisplayEvent {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public string Message { get; }
    public ErrorProduced(string message, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues);
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class Microsoft.DotNet.Interactive.Events.HoverTextProduced : KernelEvent {
    private LinePositionSpan _linePositionSpan;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<FormattedValue> <Content>k__BackingField;
    public IReadOnlyCollection`1<FormattedValue> Content { get; }
    public LinePositionSpan LinePositionSpan { get; }
    public HoverTextProduced(RequestHoverText command, IReadOnlyCollection`1<FormattedValue> content, LinePositionSpan linePositionSpan);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<FormattedValue> get_Content();
    public LinePositionSpan get_LinePositionSpan();
}
public class Microsoft.DotNet.Interactive.Events.IncompleteCodeSubmissionReceived : KernelEvent {
    public IncompleteCodeSubmissionReceived(SubmitCode submitCode);
}
public class Microsoft.DotNet.Interactive.Events.InputProduced : KernelEvent {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    public InputProduced(string value, RequestInput command);
    [CompilerGeneratedAttribute]
public string get_Value();
}
public enum Microsoft.DotNet.Interactive.Events.InsertTextFormat : Enum {
    public int value__;
    public static InsertTextFormat PlainText;
    public static InsertTextFormat Snippet;
}
public abstract class Microsoft.DotNet.Interactive.Events.KernelCommandCompletionEvent : KernelEvent {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ExecutionOrder>k__BackingField;
    public Nullable`1<int> ExecutionOrder { get; }
    private protected KernelCommandCompletionEvent(KernelCommand command, Nullable`1<int> executionOrder);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ExecutionOrder();
}
[DebuggerStepThroughAttribute]
public abstract class Microsoft.DotNet.Interactive.Events.KernelEvent : object {
    [CompilerGeneratedAttribute]
private KernelCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private EventRoutingSlip <RoutingSlip>k__BackingField;
    [JsonIgnoreAttribute]
public KernelCommand Command { get; }
    [JsonIgnoreAttribute]
public EventRoutingSlip RoutingSlip { get; }
    protected KernelEvent(KernelCommand command);
    [CompilerGeneratedAttribute]
public KernelCommand get_Command();
    [CompilerGeneratedAttribute]
public EventRoutingSlip get_RoutingSlip();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.KernelExtensionLoaded : KernelEvent {
    [CompilerGeneratedAttribute]
private IKernelExtension <KernelExtension>k__BackingField;
    [JsonIgnoreAttribute]
public IKernelExtension KernelExtension { get; }
    [JsonConstructorAttribute]
public KernelExtensionLoaded(KernelCommand command);
    public KernelExtensionLoaded(IKernelExtension kernelExtension, KernelCommand command);
    [CompilerGeneratedAttribute]
public IKernelExtension get_KernelExtension();
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Events.KernelInfoProduced : KernelEvent {
    [CompilerGeneratedAttribute]
private KernelInfo <KernelInfo>k__BackingField;
    public KernelInfo KernelInfo { get; }
    public KernelInfoProduced(KernelInfo kernelInfo, KernelCommand command);
    [CompilerGeneratedAttribute]
public KernelInfo get_KernelInfo();
}
public class Microsoft.DotNet.Interactive.Events.KernelReady : KernelEvent {
    [CompilerGeneratedAttribute]
private KernelInfo[] <KernelInfos>k__BackingField;
    public KernelInfo[] KernelInfos { get; }
    public KernelReady(KernelInfo[] kernelInfos);
    [CompilerGeneratedAttribute]
public KernelInfo[] get_KernelInfos();
}
public class Microsoft.DotNet.Interactive.Events.PackageAdded : KernelEvent {
    [CompilerGeneratedAttribute]
private ResolvedPackageReference <PackageReference>k__BackingField;
    public ResolvedPackageReference PackageReference { get; }
    public PackageAdded(ResolvedPackageReference packageReference, KernelCommand command);
    [CompilerGeneratedAttribute]
public ResolvedPackageReference get_PackageReference();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.Events.ReturnValueProduced : DisplayEvent {
    public ReturnValueProduced(object value, KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues, string valueId);
}
public class Microsoft.DotNet.Interactive.Events.SignatureHelpProduced : KernelEvent {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<SignatureInformation> <Signatures>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActiveSignatureIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ActiveParameterIndex>k__BackingField;
    public IReadOnlyList`1<SignatureInformation> Signatures { get; }
    public int ActiveSignatureIndex { get; }
    public int ActiveParameterIndex { get; }
    public SignatureHelpProduced(RequestSignatureHelp command, IReadOnlyList`1<SignatureInformation> signatures, int activeSignatureIndex, int activeParameterIndex);
    public static SignatureHelpProduced Empty(RequestSignatureHelp command);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<SignatureInformation> get_Signatures();
    [CompilerGeneratedAttribute]
public int get_ActiveSignatureIndex();
    [CompilerGeneratedAttribute]
public int get_ActiveParameterIndex();
}
public class Microsoft.DotNet.Interactive.Events.StandardErrorValueProduced : DisplayEvent {
    public StandardErrorValueProduced(KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues, string valueId);
}
public class Microsoft.DotNet.Interactive.Events.StandardOutputValueProduced : DisplayEvent {
    public StandardOutputValueProduced(KernelCommand command, IReadOnlyCollection`1<FormattedValue> formattedValues, string valueId);
}
public class Microsoft.DotNet.Interactive.Events.ValueInfosProduced : KernelEvent {
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<KernelValueInfo> <ValueInfos>k__BackingField;
    public IReadOnlyCollection`1<KernelValueInfo> ValueInfos { get; }
    public ValueInfosProduced(IReadOnlyCollection`1<KernelValueInfo> valueInfos, RequestValueInfos command);
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<KernelValueInfo> get_ValueInfos();
}
public class Microsoft.DotNet.Interactive.Events.ValueProduced : KernelEvent {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattedValue <FormattedValue>k__BackingField;
    [JsonIgnoreAttribute]
public object Value { get; }
    public string Name { get; }
    public FormattedValue FormattedValue { get; }
    public ValueProduced(object value, string name, FormattedValue formattedValue, RequestValue command);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FormattedValue get_FormattedValue();
}
public class Microsoft.DotNet.Interactive.FormattedValue : object {
    [CompilerGeneratedAttribute]
private string <MimeType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressDisplay>k__BackingField;
    public string MimeType { get; }
    public string Value { get; }
    public bool SuppressDisplay { get; public set; }
    public FormattedValue(string mimeType, string value);
    [CompilerGeneratedAttribute]
public string get_MimeType();
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public bool get_SuppressDisplay();
    [CompilerGeneratedAttribute]
public void set_SuppressDisplay(bool value);
    public static FormattedValue CreateSingleFromObject(object value, string mimeType);
    public static IReadOnlyList`1<FormattedValue> CreateManyFromObject(object value, String[] mimeTypes);
}
public abstract class Microsoft.DotNet.Interactive.FrontendEnvironment : object {
    public virtual Task ExecuteClientScript(string code, KernelInvocationContext context);
}
public class Microsoft.DotNet.Interactive.HtmlKernel : Kernel {
    public static string DefaultKernelName;
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>.HandleAsync(SubmitCode command, KernelInvocationContext context);
}
public static class Microsoft.DotNet.Interactive.Http.JavascriptUtilities : object {
    public static string GetCodeForEnsureRequireJs(Uri requireJsUri, string onRequirejsLoadedCallBackName);
    [CompilerGeneratedAttribute]
internal static string <GetCodeForEnsureRequireJs>g__GenerateOnload|0_0(<>c__DisplayClass0_0& );
    [CompilerGeneratedAttribute]
internal static string <GetCodeForEnsureRequireJs>g__GenerateElseBranch|0_1(<>c__DisplayClass0_0& );
}
public interface Microsoft.DotNet.Interactive.IKernelCommandHandler`1 {
    public abstract virtual Task HandleAsync(TCommand command, KernelInvocationContext context);
}
public interface Microsoft.DotNet.Interactive.IKernelExtension {
    public abstract virtual Task OnLoadAsync(Kernel kernel);
}
public interface Microsoft.DotNet.Interactive.IKernelScheduler`2 {
    public abstract virtual Task`1<TResult> RunAsync(T value, KernelSchedulerDelegate`2<T, TResult> onExecuteAsync, string scope, CancellationToken cancellationToken);
}
internal class Microsoft.DotNet.Interactive.ImmediateScheduler`2 : object {
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.ImmediateScheduler`2/<RunAsync>d__0")]
public sealed virtual Task`1<TResult> RunAsync(T value, KernelSchedulerDelegate`2<T, TResult> onExecuteAsync, string scope, CancellationToken cancellationToken);
}
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.InstallPackagesMessage/InstallPackagesMessageFormatterSource")]
public class Microsoft.DotNet.Interactive.InstallPackagesMessage : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <RestoreSources>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InstallingPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <InstalledPackages>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Progress>k__BackingField;
    public IReadOnlyList`1<string> RestoreSources { get; public set; }
    public IReadOnlyList`1<string> InstallingPackages { get; public set; }
    public IReadOnlyList`1<string> InstalledPackages { get; public set; }
    public int Progress { get; public set; }
    public InstallPackagesMessage(IReadOnlyList`1<string> restoreSources, IReadOnlyList`1<string> installingPackages, IReadOnlyList`1<string> installedPackages, int progress);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_RestoreSources();
    [CompilerGeneratedAttribute]
public void set_RestoreSources(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InstallingPackages();
    [CompilerGeneratedAttribute]
public void set_InstallingPackages(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_InstalledPackages();
    [CompilerGeneratedAttribute]
public void set_InstalledPackages(IReadOnlyList`1<string> value);
    [CompilerGeneratedAttribute]
public int get_Progress();
    [CompilerGeneratedAttribute]
public void set_Progress(int value);
    private IHtmlContent InstallMessage(string message, IReadOnlyList`1<string> items, string progress);
    public string FormatAsHtml();
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.InstallPackagesMessage/<FormatAsPlainTextLines>d__19")]
public IEnumerable`1<string> FormatAsPlainTextLines();
    public string FormatAsPlainText();
}
public interface Microsoft.DotNet.Interactive.IStaticContentSource {
    public string Name { get; }
    public abstract virtual string get_Name();
}
public class Microsoft.DotNet.Interactive.JavaScriptKernel : Kernel {
    private KernelClientBase _client;
    public static string DefaultKernelName;
    private static string LanguageName;
    public JavaScriptKernel(KernelClientBase client);
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>.HandleAsync(SubmitCode command, KernelInvocationContext context);
    protected virtual Func`3<TCommand, KernelInvocationContext, Task> CreateDefaultHandlerForCommandType();
    private Task ForwardCommand(KernelCommand command);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.JavaScriptKernel/<HandleAsync>d__7")]
public sealed virtual Task HandleAsync(SendValue command, KernelInvocationContext context);
    [CompilerGeneratedAttribute]
private Task <CreateDefaultHandlerForCommandType>b__5_0(TCommand kernelCommand, KernelInvocationContext _);
}
public abstract class Microsoft.DotNet.Interactive.JsonConverter`1 : JsonConverter`1<T> {
    protected void EnsureStartObject(Utf8JsonReader reader, Type typeToConvert);
    public virtual void Write(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
    protected virtual void OnWrite(Utf8JsonWriter writer, T value, JsonSerializerOptions options);
}
public abstract class Microsoft.DotNet.Interactive.Kernel : object {
    private static ConcurrentDictionary`2<Type, IReadOnlyCollection`1<Type>> _declaredHandledCommandTypesByKernelType;
    private HashSet`1<Type> _supportedCommandTypes;
    private Subject`1<KernelEvent> _kernelEvents;
    private CompositeDisposable _disposables;
    private ConcurrentDictionary`2<Type, KernelCommandInvocation> _dynamicHandlers;
    private KernelScheduler`2<KernelCommand, KernelCommandResult> _commandScheduler;
    private ImmediateScheduler`2<KernelCommand, KernelCommandResult> _fastPathScheduler;
    private FrontendEnvironment _frontendEnvironment;
    private ChooseKernelDirective _chooseKernelDirective;
    private ConcurrentQueue`1<KernelCommand> _deferredCommands;
    private KernelInvocationContext _inFlightContext;
    private int _countOfLanguageServiceCommandsInFlight;
    private KernelInfo _kernelInfo;
    [CompilerGeneratedAttribute]
private KernelCommandPipeline <Pipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private CompositeKernel <ParentKernel>k__BackingField;
    [CompilerGeneratedAttribute]
private Kernel <RootKernel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SubmissionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private SubmissionParser <SubmissionParser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private static ConcurrentDictionary`2<Type, IReadOnlyCollection`1<Type>> _implementedCommandHandlerTypes;
    internal KernelCommandPipeline Pipeline { get; }
    public CompositeKernel ParentKernel { get; internal set; }
    public Kernel RootKernel { get; internal set; }
    public int SubmissionCount { get; private set; }
    public SubmissionParser SubmissionParser { get; }
    public FrontendEnvironment FrontendEnvironment { get; public set; }
    protected bool IsDisposed { get; }
    public IObservable`1<KernelEvent> KernelEvents { get; }
    public string Name { get; }
    public KernelInfo KernelInfo { get; }
    public IReadOnlyCollection`1<Command> Directives { get; }
    internal SchedulingScope SchedulingScope { get; }
    protected internal KernelScheduler`2<KernelCommand, KernelCommandResult> Scheduler { get; }
    public ChooseKernelDirective ChooseKernelDirective { get; }
    internal bool AcceptsUnknownDirectives { get; }
    public static Kernel Current { get; }
    public static Kernel Root { get; }
    protected Kernel(string name);
    [ObsoleteAttribute("This constructor has been deprecated.  Please use the other constructor and directly set any remaining properties directly on the KernelInfo property.")]
protected Kernel(string name, string languageName, string languageVersion);
    private static Kernel();
    private KernelInfo InitializeKernelInfo(string name);
    [CompilerGeneratedAttribute]
internal KernelCommandPipeline get_Pipeline();
    [CompilerGeneratedAttribute]
public CompositeKernel get_ParentKernel();
    [CompilerGeneratedAttribute]
internal void set_ParentKernel(CompositeKernel value);
    [CompilerGeneratedAttribute]
public Kernel get_RootKernel();
    [CompilerGeneratedAttribute]
internal void set_RootKernel(Kernel value);
    [CompilerGeneratedAttribute]
public int get_SubmissionCount();
    [CompilerGeneratedAttribute]
private void set_SubmissionCount(int value);
    [CompilerGeneratedAttribute]
public SubmissionParser get_SubmissionParser();
    public void AddMiddleware(KernelCommandPipelineMiddleware middleware, string caller);
    public void DeferCommand(KernelCommand command);
    private bool TrySplitCommand(KernelCommand originalCommand, KernelInvocationContext context, IReadOnlyList`1& commands);
    private bool TryAdjustLanguageServiceCommandLinePositions(LanguageServiceCommand command, KernelInvocationContext context, LanguageServiceCommand& adjustedCommand);
    public FrontendEnvironment get_FrontendEnvironment();
    public void set_FrontendEnvironment(FrontendEnvironment value);
    protected bool get_IsDisposed();
    public IObservable`1<KernelEvent> get_KernelEvents();
    [CompilerGeneratedAttribute]
public string get_Name();
    public KernelInfo get_KernelInfo();
    public IReadOnlyCollection`1<Command> get_Directives();
    public void AddDirective(Command command);
    public void RegisterCommandHandler(Func`3<TCommand, KernelInvocationContext, Task> handler);
    public void RegisterCommandType();
    protected virtual Func`3<TCommand, KernelInvocationContext, Task> CreateDefaultHandlerForCommandType();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<HandleAsync>d__56")]
internal virtual Task HandleAsync(KernelCommand command, KernelInvocationContext context);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<SendAsync>d__57")]
public Task`1<KernelCommandResult> SendAsync(KernelCommand command, CancellationToken cancellationToken);
    internal SchedulingScope get_SchedulingScope();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<RunOnFastPath>d__60")]
private Task RunOnFastPath(KernelInvocationContext context, KernelCommand command, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<RunDeferredCommandsAsync>d__61")]
private Task RunDeferredCommandsAsync(KernelInvocationContext context);
    private KernelHost GetKernelHost();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<InvokePipelineAndCommandHandler>d__64")]
internal Task`1<KernelCommandResult> InvokePipelineAndCommandHandler(KernelCommand command);
    protected internal KernelScheduler`2<KernelCommand, KernelCommandResult> get_Scheduler();
    protected internal void SetScheduler(KernelScheduler`2<KernelCommand, KernelCommandResult> scheduler);
    private IReadOnlyList`1<KernelCommand> GetDeferredCommands(KernelCommand command, string scope);
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestKernelInfo>.HandleAsync(RequestKernelInfo command, KernelInvocationContext context);
    private protected virtual Task HandleRequestKernelInfoAsync(RequestKernelInfo command, KernelInvocationContext context);
    private protected bool CanHandle(KernelCommand command);
    private protected bool HasDynamicHandlerFor(KernelCommand command);
    private protected virtual Kernel GetHandlingKernel(KernelCommand command, KernelInvocationContext context);
    protected internal void PublishEvent(KernelEvent kernelEvent);
    public void RegisterForDisposal(Action dispose);
    public void RegisterForDisposal(IDisposable disposable);
    private Task HandleRequestCompletionsAsync(RequestCompletions command, KernelInvocationContext context);
    private IEnumerable`1<CompletionItem> GetDirectiveCompletionItems(DirectiveNode directiveNode, int requestPosition);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<GetDirectiveParsersForCompletion>d__79")]
private protected virtual IEnumerable`1<Parser> GetDirectiveParsersForCompletion(DirectiveNode directiveNode, int requestPosition);
    private void TrySetHandler(KernelCommand command, KernelInvocationContext context);
    private bool TrySetDynamicHandler(KernelCommand command);
    private static void SetHandler(T command, IKernelCommandHandler`1<T> handler);
    protected virtual void SetHandlingKernel(KernelCommand command, KernelInvocationContext context);
    public sealed virtual void Dispose();
    public virtual ChooseKernelDirective get_ChooseKernelDirective();
    internal virtual bool get_AcceptsUnknownDirectives();
    internal bool SupportsCommand(KernelCommand command);
    public bool SupportsCommandType(Type commandType);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<SetValueAsync>d__91")]
protected Task SetValueAsync(SendValue command, KernelInvocationContext context, SetValueAsyncDelegate setValueAsync);
    public virtual string ToString();
    public static Kernel get_Current();
    public static Kernel get_Root();
    public static DisplayedValue display(object value, String[] mimeTypes);
    public static IHtmlContent HTML(string content);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<GetInputAsync>d__100")]
public static Task`1<string> GetInputAsync(string prompt, string typeHint, string valueName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<GetPasswordAsync>d__101")]
public static Task`1<PasswordString> GetPasswordAsync(string prompt, string valueName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Kernel/<GetInputAsync>d__102")]
private static Task`1<string> GetInputAsync(string prompt, bool isPassword, string typeHint, string valueName);
    public static void CSS(string content);
    public static void Javascript(string scriptContent);
    private static IReadOnlyCollection`1<Type> GetImplementedCommandHandlerTypesFor(Type kernelType);
    [CompilerGeneratedAttribute]
private void <.ctor>b__13_0();
    [CompilerGeneratedAttribute]
private void <.ctor>g__IncrementSubmissionCount|13_1(KernelEvent e);
    [CompilerGeneratedAttribute]
internal static Task <CreateDefaultHandlerForCommandType>g__EmptyHandler|55_0(TCommand _, KernelInvocationContext __);
}
public class Microsoft.DotNet.Interactive.KernelCollection : object {
    private CompositeKernel _compositeKernel;
    private List`1<Kernel> _kernels;
    private Dictionary`2<Uri, Kernel> _kernelsByLocalUri;
    private Dictionary`2<Uri, Kernel> _kernelsByRemoteUri;
    private Dictionary`2<string, Kernel> _kernelsByNameOrAlias;
    public int Count { get; }
    public KernelCollection(CompositeKernel compositeKernel);
    internal void Add(Kernel kernel);
    public bool TryGetByAlias(string alias, Kernel& kernel);
    public bool TryGetByUri(Uri uri, Kernel& kernel);
    public sealed virtual IEnumerator`1<Kernel> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual int get_Count();
    internal void NotifyThatHostWasSet();
    private void UpdateKernelInfoAndIndex(Kernel kernel, IEnumerable`1<string> aliases);
    [CompilerGeneratedAttribute]
private bool <Add>b__6_0(string a);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.KernelCommandExtensions : object {
    [ExtensionAttribute]
internal static void StampRoutingSlipAndLog(KernelCommand command, Uri uri);
    [ExtensionAttribute]
internal static void StampRoutingSlipAsAndLog(KernelCommand command, Uri uri, string tag);
    [ExtensionAttribute]
internal static void StampRoutingSlipAsArrivedAndLog(KernelCommand command, Uri uri);
    [ExtensionAttribute]
private static void RoutingSlipInfo(Logger logger, KernelCommand command, Uri uri, string tag);
}
public class Microsoft.DotNet.Interactive.KernelCommandInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Name { get; public set; }
    public KernelCommandInfo(string Name);
    [CompilerGeneratedAttribute]
protected KernelCommandInfo(KernelCommandInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(KernelCommandInfo left, KernelCommandInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(KernelCommandInfo left, KernelCommandInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(KernelCommandInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual KernelCommandInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name);
}
public class Microsoft.DotNet.Interactive.KernelCommandInvocation : MulticastDelegate {
    public KernelCommandInvocation(object object, IntPtr method);
    public virtual Task Invoke(KernelCommand command, KernelInvocationContext context);
    public virtual IAsyncResult BeginInvoke(KernelCommand command, KernelInvocationContext context, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
internal class Microsoft.DotNet.Interactive.KernelCommandPipeline : object {
    private Kernel _kernel;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<KernelCommandPipelineMiddleware, string>> _middlewares;
    private KernelCommandPipelineMiddleware _pipeline;
    public KernelCommandPipeline(Kernel kernel);
    private void EnsureMiddlewarePipelineIsInitialized();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelCommandPipeline/<SendAsync>d__5")]
internal Task SendAsync(KernelCommand command, KernelInvocationContext context);
    [DebuggerHiddenAttribute]
private KernelCommandPipelineMiddleware BuildPipeline();
    public void AddMiddleware(KernelCommandPipelineMiddleware middleware, string caller);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelCommandPipeline/<<BuildPipeline>b__6_0>d")]
[CompilerGeneratedAttribute]
private Task <BuildPipeline>b__6_0(KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation _);
}
public class Microsoft.DotNet.Interactive.KernelCommandPipelineMiddleware : MulticastDelegate {
    public KernelCommandPipelineMiddleware(object object, IntPtr method);
    public virtual Task Invoke(KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next);
    public virtual IAsyncResult BeginInvoke(KernelCommand command, KernelInvocationContext context, KernelPipelineContinuation next, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.MessageDiagnosticsFormatterSource")]
public class Microsoft.DotNet.Interactive.KernelCommandResult : object {
    private List`1<KernelEvent> _events;
    [CompilerGeneratedAttribute]
private KernelCommand <Command>k__BackingField;
    public KernelCommand Command { get; }
    public IReadOnlyList`1<KernelEvent> Events { get; }
    internal KernelCommandResult(KernelCommand command);
    [CompilerGeneratedAttribute]
public KernelCommand get_Command();
    public IReadOnlyList`1<KernelEvent> get_Events();
    internal void AddEvent(KernelEvent event);
}
public class Microsoft.DotNet.Interactive.KernelCommandScheduler : KernelScheduler`2<KernelCommand, KernelCommandResult> {
    protected virtual bool IsChildOperation(KernelCommand current, KernelCommand incoming);
}
public class Microsoft.DotNet.Interactive.KernelDirectiveInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public string Name { get; public set; }
    public KernelDirectiveInfo(string Name);
    [CompilerGeneratedAttribute]
protected KernelDirectiveInfo(KernelDirectiveInfo original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Name(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(KernelDirectiveInfo left, KernelDirectiveInfo right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(KernelDirectiveInfo left, KernelDirectiveInfo right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(KernelDirectiveInfo other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual KernelDirectiveInfo <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(String& Name);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.KernelEventExtensions : object {
    [ExtensionAttribute]
public static LinePositionSpan CalculateLineOffsetFromParentCommand(KernelEvent event, LinePositionSpan initialRange);
    [ExtensionAttribute]
public static IReadOnlyCollection`1<Diagnostic> RemapDiagnosticsFromRequestingCommand(KernelEvent event, IReadOnlyCollection`1<Diagnostic> diagnostics);
    [ExtensionAttribute]
private static IReadOnlyCollection`1<Diagnostic> RemapDiagnosticsFromLanguageNode(LanguageNode languageNode, IReadOnlyCollection`1<Diagnostic> diagnostics);
    [ExtensionAttribute]
internal static void StampRoutingSlipAndLog(KernelEvent event, Uri uri);
    [ExtensionAttribute]
private static void RoutingSlipInfo(Logger logger, KernelEvent event, Uri uri, string tag);
}
public class Microsoft.DotNet.Interactive.KernelException : Exception {
    public KernelException(string message);
}
public class Microsoft.DotNet.Interactive.KernelExtensionLoadException : Exception {
    public KernelExtensionLoadException(Exception innerException);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.KernelExtensions : object {
    [ExtensionAttribute]
public static T UseQuitCommand(T kernel, Func`1<Task> onQuitAsync);
    [ExtensionAttribute]
public static Kernel FindKernelByName(Kernel kernel, string name);
    [ExtensionAttribute]
public static IEnumerable`1<Kernel> FindKernels(Kernel kernel, Func`2<Kernel, bool> predicate);
    [ExtensionAttribute]
public static Task`1<KernelCommandResult> SubmitCodeAsync(Kernel kernel, string code);
    [ExtensionAttribute]
public static TKernel UseImportMagicCommand(TKernel kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<LoadAndRunInteractiveDocument>d__5")]
[ExtensionAttribute]
public static Task LoadAndRunInteractiveDocument(Kernel kernel, FileInfo file, KernelCommand parentCommand);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<HandleSetMagicCommand>d__6`1")]
private static Task HandleSetMagicCommand(T kernel, InvocationContext cmdLineContext, Option`1<string> nameOption, Option`1<ValueOptionResult> valueOption, Option`1<bool> byrefOption);
    [ExtensionAttribute]
public static T UseValueSharing(T kernel);
    private static void ConfigureAndAddSetMagicCommand(T destinationKernel);
    private static void ConfigureAndAddShareMagicCommand(T kernel);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<GetValueAndSendTo>d__11")]
[ExtensionAttribute]
internal static Task GetValueAndSendTo(Kernel fromKernel, KernelInvocationContext context, Kernel toKernel, string fromName, string requestedMimeType, string toName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<SendValue>d__12")]
private static Task SendValue(KernelInvocationContext context, Kernel kernel, bool ignoreReferenceValue, ValueProduced valueProduced, string declarationName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<SendValue>d__13")]
private static Task SendValue(KernelInvocationContext context, Kernel kernel, object value, FormattedValue formattedValue, string declarationName);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<GetValue>d__14")]
private static Task`1<ValueProduced> GetValue(KernelInvocationContext context, Kernel kernel, string name, string requestedMimeType);
    [ExtensionAttribute]
public static TKernel UseWho(TKernel kernel);
    private static Command who();
    private static Command whos();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<DisplayValues>d__18")]
private static Task DisplayValues(KernelInvocationContext context, bool detailed);
    [ExtensionAttribute]
public static void VisitSubkernels(Kernel kernel, Action`1<Kernel> onVisit, bool recursive);
    [ExtensionAttribute]
public static void VisitSubkernelsAndSelf(Kernel kernel, Action`1<Kernel> onVisit, bool recursive);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<SubkernelsAndSelf>d__21")]
[ExtensionAttribute]
public static IEnumerable`1<Kernel> SubkernelsAndSelf(Kernel kernel, bool recursive);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.KernelExtensions/<Subkernels>d__22")]
[ExtensionAttribute]
public static IEnumerable`1<Kernel> Subkernels(Kernel kernel, bool recursive);
    [ExtensionAttribute]
internal static bool TryRegisterForDisposal(Kernel kernel, T candidateDisposable);
    [CompilerGeneratedAttribute]
internal static void <UseQuitCommand>g__ShutDown|0_1();
    [CompilerGeneratedAttribute]
internal static KernelInfoCollection <LoadAndRunInteractiveDocument>g__CreateKernelInfos|5_1(CompositeKernel kernel);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.KernelHost : object {
    private CancellationTokenSource _cancellationTokenSource;
    private TaskCompletionSource`1<Unit> _disposed;
    private CompositeKernel _kernel;
    private IKernelCommandAndEventSender _defaultSender;
    private IKernelCommandAndEventReceiver _receiver;
    [NullableAttribute("2")]
private IDisposable _kernelEventSubscription;
    private Func`2<string, Task`1<ProxyKernel>> _defaultConnector;
    [NullableAttribute("2")]
private EventLoopScheduler _eventLoop;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, KernelInvocationContext> <ContextsByRootToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    internal ConcurrentDictionary`2<string, KernelInvocationContext> ContextsByRootToken { get; }
    public Uri Uri { get; }
    internal KernelHost(CompositeKernel kernel, IKernelCommandAndEventSender sender, IKernelCommandAndEventReceiver receiver, Uri hostUri);
    [CompilerGeneratedAttribute]
internal ConcurrentDictionary`2<string, KernelInvocationContext> get_ContextsByRootToken();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelHost/<ConnectAsync>d__13")]
public Task ConnectAsync();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelHost/<ConnectAndWaitAsync>d__14")]
public Task ConnectAndWaitAsync();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelHost/<ConnectProxyKernelAsync>d__19")]
public Task`1<ProxyKernel> ConnectProxyKernelAsync(string localName, Func`2<string, Task`1<ProxyKernel>> createKernelAsync, Uri remoteKernelUri, String[] aliases);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelHost/<ConnectProxyKernelOnDefaultConnectorAsync>d__20")]
public Task`1<ProxyKernel> ConnectProxyKernelOnDefaultConnectorAsync(string localName, Uri remoteKernelUri, String[] aliases);
    public static Uri CreateHostUriForCurrentProcessId();
    public static Uri CreateHostUriForProcessId(int processId);
    public static Uri CreateHostUri(string name);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelHost/<<-ctor>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task`1<ProxyKernel> <.ctor>b__11_0(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.KernelInfo : object {
    private HashSet`1<KernelCommandInfo> _supportedKernelCommands;
    private HashSet`1<KernelDirectiveInfo> _supportedDirectives;
    [NullableAttribute("2")]
private string _displayName;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LanguageName>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComposite>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalName>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Uri <RemoteUri>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <NameAndAliases>k__BackingField;
    public String[] Aliases { get; public set; }
    [NullableAttribute("2")]
public string LanguageName { get; public set; }
    [NullableAttribute("2")]
public string LanguageVersion { get; public set; }
    public bool IsProxy { get; public set; }
    public bool IsComposite { get; public set; }
    public string DisplayName { get; public set; }
    public string LocalName { get; }
    public Uri Uri { get; public set; }
    [NullableAttribute("2")]
public Uri RemoteUri { get; public set; }
    [NullableAttribute("2")]
public string Description { get; public set; }
    public ICollection`1<KernelCommandInfo> SupportedKernelCommands { get; public set; }
    public ICollection`1<KernelDirectiveInfo> SupportedDirectives { get; public set; }
    internal HashSet`1<string> NameAndAliases { get; }
    [JsonConstructorAttribute]
public KernelInfo(string localName, String[] aliases, bool isProxy, bool isComposite, string description);
    private string CreateDisplayName();
    public String[] get_Aliases();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Aliases(String[] value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LanguageName();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_LanguageName(string value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_LanguageVersion(string value);
    [CompilerGeneratedAttribute]
public bool get_IsProxy();
    [CompilerGeneratedAttribute]
public void set_IsProxy(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsComposite();
    [CompilerGeneratedAttribute]
public void set_IsComposite(bool value);
    public string get_DisplayName();
    public void set_DisplayName(string value);
    [CompilerGeneratedAttribute]
public string get_LocalName();
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public void set_Uri(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Uri get_RemoteUri();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_RemoteUri(Uri value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_Description();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Description(string value);
    public ICollection`1<KernelCommandInfo> get_SupportedKernelCommands();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SupportedKernelCommands(ICollection`1<KernelCommandInfo> value);
    public ICollection`1<KernelDirectiveInfo> get_SupportedDirectives();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_SupportedDirectives(ICollection`1<KernelDirectiveInfo> value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_NameAndAliases();
    internal bool SupportsCommand(string commandName);
    internal void UpdateSupportedKernelCommandsFrom(KernelInfo source);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <get_Aliases>b__6_0(string n);
}
public class Microsoft.DotNet.Interactive.KernelInvocationContext : object {
    private static AsyncLocal`1<KernelInvocationContext> _current;
    private static ConcurrentDictionary`2<string, CancellationTokenSource> _cancellationTokenSources;
    private ReplaySubject`1<KernelEvent> _events;
    private ConcurrentDictionary`2<KernelCommand, ReplaySubject`1<KernelEvent>> _childCommands;
    private CompositeDisposable _disposables;
    private List`1<Action`1<KernelInvocationContext>> _onCompleteActions;
    private CancellationTokenSource _cancellationTokenSource;
    private bool _ownsCancellationTokenSource;
    private int _consoleAsyncContextId;
    [CompilerGeneratedAttribute]
private bool <IsFailed>k__BackingField;
    [CompilerGeneratedAttribute]
private KernelCommand <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    private object _lockObj;
    [CompilerGeneratedAttribute]
private KernelCommandResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private Kernel <HandlingKernel>k__BackingField;
    [CompilerGeneratedAttribute]
private DirectiveNode <CurrentlyParsingDirectiveNode>k__BackingField;
    internal bool IsFailed { get; private set; }
    public KernelCommand Command { get; }
    internal KernelCommand CurrentlyExecutingCommand { get; }
    public bool IsComplete { get; private set; }
    public CancellationToken CancellationToken { get; }
    public IObservable`1<KernelEvent> KernelEvents { get; }
    public KernelCommandResult Result { get; }
    public static KernelInvocationContext Current { get; }
    public Kernel HandlingKernel { get; internal set; }
    internal DirectiveNode CurrentlyParsingDirectiveNode { get; internal set; }
    private KernelInvocationContext(KernelCommand command);
    private static KernelInvocationContext();
    [CompilerGeneratedAttribute]
internal bool get_IsFailed();
    [CompilerGeneratedAttribute]
private void set_IsFailed(bool value);
    [CompilerGeneratedAttribute]
public KernelCommand get_Command();
    internal KernelCommand get_CurrentlyExecutingCommand();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
private void set_IsComplete(bool value);
    public CancellationToken get_CancellationToken();
    public void Complete(KernelCommand command);
    public void Fail(KernelCommand command, Exception exception, string message);
    internal void Cancel();
    private void SucceedOrFail(bool succeed, KernelCommand command, Exception exception, string message);
    private void TryCancel();
    public void OnComplete(Action`1<KernelInvocationContext> onComplete);
    public void Publish(KernelEvent event);
    public void Publish(KernelEvent event, bool publishOnAmbientContextOnly);
    public IObservable`1<KernelEvent> get_KernelEvents();
    [CompilerGeneratedAttribute]
public KernelCommandResult get_Result();
    private bool TryGetChildCommandEvents(KernelCommand command, ReplaySubject`1& events);
    internal KernelCommandResult ResultFor(KernelCommand command);
    public static KernelInvocationContext GetOrCreateAmbientContext(KernelCommand command, ConcurrentDictionary`2<string, KernelInvocationContext> contextsByRootToken);
    public static KernelInvocationContext get_Current();
    [CompilerGeneratedAttribute]
public Kernel get_HandlingKernel();
    [CompilerGeneratedAttribute]
internal void set_HandlingKernel(Kernel value);
    public sealed virtual void Dispose();
    internal void CancelWithSuccess();
    [CompilerGeneratedAttribute]
internal DirectiveNode get_CurrentlyParsingDirectiveNode();
    [CompilerGeneratedAttribute]
internal void set_CurrentlyParsingDirectiveNode(DirectiveNode value);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelInvocationContext/<ScheduleAsync>d__54")]
public Task ScheduleAsync(Func`2<KernelInvocationContext, Task> func);
    [CompilerGeneratedAttribute]
private void <SucceedOrFail>g__StopPublishingMainCommandEvents|29_0(<>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
private void <SucceedOrFail>g__StopPublishingChildCommandEvents|29_1(<>c__DisplayClass29_0& );
    [CompilerGeneratedAttribute]
internal static void <GetOrCreateAmbientContext>g__AddChildCommandToContext|41_0(KernelCommand childCommand, KernelInvocationContext currentContext);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.KernelInvocationContextExtensions : object {
    [ExtensionAttribute]
public static DisplayedValue Display(KernelInvocationContext context, object value, String[] mimeTypes);
    [ExtensionAttribute]
public static DisplayedValue DisplayAs(KernelInvocationContext context, string value, string mimeType);
    [ExtensionAttribute]
public static void DisplayStandardOut(KernelInvocationContext context, string output, KernelCommand command);
    [ExtensionAttribute]
public static void DisplayStandardError(KernelInvocationContext context, string error, KernelCommand command);
    [ExtensionAttribute]
public static void PublishValueProduced(KernelInvocationContext context, RequestValue requestValue, object value);
}
public class Microsoft.DotNet.Interactive.KernelPipelineContinuation : MulticastDelegate {
    public KernelPipelineContinuation(object object, IntPtr method);
    public virtual Task Invoke(KernelCommand command, KernelInvocationContext context);
    public virtual IAsyncResult BeginInvoke(KernelCommand command, KernelInvocationContext context, AsyncCallback callback, object object);
    public virtual Task EndInvoke(IAsyncResult result);
}
public class Microsoft.DotNet.Interactive.KernelScheduler`2 : object {
    private static Logger Log;
    private CompositeDisposable _disposables;
    private List`1<DeferredOperationSource<T, TResult>> _deferredOperationSources;
    private CancellationTokenSource _schedulerDisposalSource;
    private Task _runLoopTask;
    private BlockingCollection`1<ScheduledOperation<T, TResult>> _topLevelScheduledOperations;
    private ScheduledOperation<T, TResult> _currentlyRunningTopLevelOperation;
    private ScheduledOperation<T, TResult> _currentlyRunningOperation;
    private Barrier _childOperationsBarrier;
    public T CurrentValue { get; }
    private static KernelScheduler`2();
    public void CancelCurrentOperation();
    public T get_CurrentValue();
    public sealed virtual Task`1<TResult> RunAsync(T value, KernelSchedulerDelegate`2<T, TResult> onExecuteAsync, string scope, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KernelScheduler`2/<IdleAsync>d__14")]
internal Task IdleAsync();
    private void ScheduledOperationRunLoop(object _);
    private void Run(ScheduledOperation<T, TResult> operation);
    private void EnqueueTopLevelOperation(ScheduledOperation<T, TResult> operation);
    private void RunChildOperation(ScheduledOperation<T, TResult> operation);
    private void RunDeferredOperationsAndThen(ScheduledOperation<T, TResult> operation);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.KernelScheduler`2/<GetDeferredOperationsToRunBefore>d__20")]
private IEnumerable`1<ScheduledOperation<T, TResult>> GetDeferredOperationsToRunBefore(ScheduledOperation<T, TResult> operation);
    public void RegisterDeferredOperationSource(GetDeferredOperationsDelegate<T, TResult> getDeferredOperations, KernelSchedulerDelegate`2<T, TResult> kernelSchedulerOnExecuteAsync);
    public sealed virtual void Dispose();
    private void ThrowIfDisposed();
    protected virtual bool IsChildOperation(T current, T incoming);
}
public class Microsoft.DotNet.Interactive.KernelSchedulerDelegate`2 : MulticastDelegate {
    public KernelSchedulerDelegate`2(object object, IntPtr method);
    public virtual Task`1<TResult> Invoke(T value);
    public virtual IAsyncResult BeginInvoke(T value, AsyncCallback callback, object object);
    public virtual Task`1<TResult> EndInvoke(IAsyncResult result);
}
internal class Microsoft.DotNet.Interactive.KernelValuesFormatter : HtmlFormatter`1<KernelValues> {
    private static bool FormatKernelValues(KernelValues instance, FormatContext context);
}
public class Microsoft.DotNet.Interactive.KeyValueStoreKernel : Kernel {
    internal static string DefaultKernelName;
    private ConcurrentDictionary`2<string, FormattedValue> _values;
    private ChooseKeyValueStoreKernelDirective _chooseKernelDirective;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Nullable`1<ValueTuple`3<bool, FormattedValue, string>> _lastOperation;
    public ChooseKernelDirective ChooseKernelDirective { get; }
    public IReadOnlyDictionary`2<string, FormattedValue> Values { get; }
    internal bool AcceptsUnknownDirectives { get; }
    public KeyValueStoreKernel(string name);
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestValueInfos>.HandleAsync(RequestValueInfos command, KernelInvocationContext context);
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.RequestValue>.HandleAsync(RequestValue command, KernelInvocationContext context);
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SendValue>.HandleAsync(SendValue command, KernelInvocationContext context);
    public virtual ChooseKernelDirective get_ChooseKernelDirective();
    public IReadOnlyDictionary`2<string, FormattedValue> get_Values();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KeyValueStoreKernel/<Microsoft-DotNet-Interactive-IKernelCommandHandler<Microsoft-DotNet-Interactive-Commands-SubmitCode>-HandleAsync>d__12")]
private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>.HandleAsync(SubmitCode command, KernelInvocationContext context);
    internal virtual bool get_AcceptsUnknownDirectives();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KeyValueStoreKernel/<TryStoreValueFromOptionsAsync>d__15")]
internal Task TryStoreValueFromOptionsAsync(KernelInvocationContext context, ValueDirectiveOptions options);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KeyValueStoreKernel/<StoreValueAsync>d__16")]
private Task StoreValueAsync(KernelCommand command, KernelInvocationContext context, ValueDirectiveOptions options, string value, string mimeType);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.KeyValueStoreKernel/<StoreValueAsync>d__17")]
private Task StoreValueAsync(string value, ValueDirectiveOptions options, KernelInvocationContext context, string mimeType);
    protected virtual Task StoreValueAsync(string key, string value, string mimeType, bool shouldDisplayValue, KernelInvocationContext context);
    [CompilerGeneratedAttribute]
private void <StoreValueAsync>g__UndoSetValue|16_0(<>c__DisplayClass16_0& );
}
public class Microsoft.DotNet.Interactive.KqlDiscoverabilityKernel : Kernel {
    private HashSet`1<string> _kernelNameFilter;
    private static string DefaultKernelName;
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>.HandleAsync(SubmitCode command, KernelInvocationContext context);
}
public class Microsoft.DotNet.Interactive.LinePosition : object {
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Character>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public int Line { get; public set; }
    public int Character { get; public set; }
    public LinePosition(int Line, int Character);
    [CompilerGeneratedAttribute]
protected LinePosition(LinePosition original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Character();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Character(int value);
    public LinePosition SubtractLineOffset(LinePosition offset);
    public virtual string ToString();
    public LinePosition ToCodeAnalysisLinePosition();
    public static LinePosition FromCodeAnalysisLinePosition(LinePosition linePosition);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LinePosition left, LinePosition right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LinePosition left, LinePosition right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LinePosition other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual LinePosition <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(Int32& Line, Int32& Character);
}
public class Microsoft.DotNet.Interactive.LinePositionSpan : object {
    [CompilerGeneratedAttribute]
private LinePosition <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private LinePosition <End>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public LinePosition Start { get; public set; }
    public LinePosition End { get; public set; }
    public LinePositionSpan(LinePosition Start, LinePosition End);
    [CompilerGeneratedAttribute]
protected LinePositionSpan(LinePositionSpan original);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public LinePosition get_Start();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Start(LinePosition value);
    [CompilerGeneratedAttribute]
public LinePosition get_End();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_End(LinePosition value);
    public LinePositionSpan SubtractLineOffset(LinePosition offset);
    public virtual string ToString();
    public static LinePositionSpan FromCodeAnalysisLinePositionSpan(LinePositionSpan linePositionSpan);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LinePositionSpan left, LinePositionSpan right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LinePositionSpan left, LinePositionSpan right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LinePositionSpan other);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public virtual LinePositionSpan <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(LinePosition& Start, LinePosition& End);
}
internal static class Microsoft.DotNet.Interactive.LocalizationResources : object {
    internal static string Magics_set_name_Description();
    internal static string Magics_set_byref_Description();
    internal static string Magics_set_mime_type_Description();
    internal static string Magics_set_mime_type_ErrorMessageCannotBeUsed();
    internal static string Magics_set_ErrorMessageSharingByReference();
    internal static string Magics_set_value_Description();
    internal static string Magics_share_as_Description();
    internal static string Magics_share_from_Description();
    internal static string Magics_share_mime_type_Description();
    internal static string Magics_share_name_Description();
    internal static string Magics_ErrorMessageCannotBeUsedTogether(string option1, string option2);
    internal static string Magics_import_Description();
    internal static string Magics_value_from_file_Description();
    internal static string Magics_value_from_url_Description();
    internal static string Magics_value_from_value_Description();
    internal static string Magics_value_mime_type_Description();
    internal static string Magics_value_name_Description();
    internal static string Magics_log_Description();
    internal static string Magics_set_Description();
    internal static string Magics_share_Description();
    internal static string Magics_who_Description();
    internal static string Magics_whos_Description();
    internal static string FileDoesNotExist(string filePath);
    private static string GetResourceString(string resourceString, Object[] formatArguments);
}
internal class Microsoft.DotNet.Interactive.MessageDiagnosticsFormatterSource : object {
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.MessageDiagnosticsFormatterSource/<CreateTypeFormatters>d__0")]
public sealed virtual IEnumerable`1<ITypeFormatter> CreateTypeFormatters();
}
public class Microsoft.DotNet.Interactive.NoSuitableKernelException : Exception {
    [CompilerGeneratedAttribute]
private KernelCommand <Command>k__BackingField;
    public KernelCommand Command { get; }
    public NoSuitableKernelException(KernelCommand command);
    [CompilerGeneratedAttribute]
public KernelCommand get_Command();
}
public class Microsoft.DotNet.Interactive.PackageReference : object {
    [CompilerGeneratedAttribute]
private string <PackageName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageVersion>k__BackingField;
    public string PackageName { get; }
    public string PackageVersion { get; }
    public bool IsPackageVersionSpecified { get; }
    public PackageReference(string packageName, string packageVersion);
    [CompilerGeneratedAttribute]
public string get_PackageName();
    [CompilerGeneratedAttribute]
public string get_PackageVersion();
    public static bool TryParse(string value, PackageReference& reference);
    public bool get_IsPackageVersionSpecified();
    public virtual string ToString();
}
public class Microsoft.DotNet.Interactive.PackageReferenceOrFileInfo : object {
    private int _case;
    [CompilerGeneratedAttribute]
private FileInfo <FileInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private PackageReference <PackageReference>k__BackingField;
    public FileInfo FileInfo { get; }
    public PackageReference PackageReference { get; }
    public object Value { get; }
    public PackageReferenceOrFileInfo(FileInfo fileInfo);
    public PackageReferenceOrFileInfo(PackageReference packageReference);
    [CompilerGeneratedAttribute]
public FileInfo get_FileInfo();
    [CompilerGeneratedAttribute]
public PackageReference get_PackageReference();
    public object get_Value();
    public static PackageReferenceOrFileInfo op_Implicit(FileInfo source);
    public static PackageReferenceOrFileInfo op_Implicit(PackageReference source);
}
public class Microsoft.DotNet.Interactive.ParameterInformation : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattedValue <Documentation>k__BackingField;
    public string Label { get; }
    public FormattedValue Documentation { get; }
    public ParameterInformation(string label, FormattedValue documentation);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public FormattedValue get_Documentation();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.ActionDirectiveNode : DirectiveNode {
    [CompilerGeneratedAttribute]
private string <ParentKernelName>k__BackingField;
    public string ParentKernelName { get; }
    internal ActionDirectiveNode(DirectiveToken directiveToken, SourceText sourceText, string parentKernelName, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public string get_ParentKernelName();
}
public enum Microsoft.DotNet.Interactive.Parsing.DiagnosticSeverity : Enum {
    public int value__;
    public static DiagnosticSeverity Hidden;
    public static DiagnosticSeverity Info;
    public static DiagnosticSeverity Warning;
    public static DiagnosticSeverity Error;
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.DirectiveArgsToken : SyntaxToken {
    [NullableContextAttribute("1")]
internal DirectiveArgsToken(SourceText text, TextSpan span, PolyglotSyntaxTree syntaxTree);
}
public class Microsoft.DotNet.Interactive.Parsing.DirectiveHelpBuilder : HelpBuilder {
    private string _rootCommandName;
    private Dictionary`2<Symbol, string> _directiveHelp;
    public DirectiveHelpBuilder(string rootCommandName);
    public virtual void Write(HelpContext context);
    public string GetHelpForSymbol(Symbol symbol);
    private string CleanUp(string value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public abstract class Microsoft.DotNet.Interactive.Parsing.DirectiveNode : LanguageNode {
    private ParseResult _parseResult;
    [CompilerGeneratedAttribute]
private Parser <DirectiveParser>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowValueSharingByInterpolation>k__BackingField;
    internal Parser DirectiveParser { get; internal set; }
    internal bool AllowValueSharingByInterpolation { get; internal set; }
    internal bool IsCompilerDirective { get; }
    [NullableContextAttribute("1")]
internal DirectiveNode(DirectiveToken directiveToken, SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
internal Parser get_DirectiveParser();
    [CompilerGeneratedAttribute]
internal void set_DirectiveParser(Parser value);
    [CompilerGeneratedAttribute]
internal bool get_AllowValueSharingByInterpolation();
    [CompilerGeneratedAttribute]
internal void set_AllowValueSharingByInterpolation(bool value);
    [NullableContextAttribute("1")]
public ParseResult GetDirectiveParseResult();
    [NullableContextAttribute("1")]
[IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Parsing.DirectiveNode/<GetDiagnostics>d__11")]
public virtual IEnumerable`1<Diagnostic> GetDiagnostics();
    internal bool get_IsCompilerDirective();
    internal int GetLine();
    [NullableContextAttribute("1")]
internal LinePositionSpan GetLinePositionSpan();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.DirectiveToken : SyntaxToken {
    [CompilerGeneratedAttribute]
private string <DirectiveName>k__BackingField;
    public string DirectiveName { get; }
    internal DirectiveToken(SourceText text, TextSpan span, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public string get_DirectiveName();
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.KernelNameDirectiveNode : DirectiveNode {
    [NullableContextAttribute("1")]
internal KernelNameDirectiveNode(DirectiveToken directiveToken, SourceText sourceText, PolyglotSyntaxTree syntaxTree);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.LanguageNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SchedulingScope <CommandScope>k__BackingField;
    public string Name { get; }
    [NullableAttribute("2")]
internal SchedulingScope CommandScope { get; internal set; }
    internal LanguageNode(string name, SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public string get_Name();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal SchedulingScope get_CommandScope();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_CommandScope(SchedulingScope value);
    public virtual IEnumerable`1<Diagnostic> GetDiagnostics();
}
public class Microsoft.DotNet.Interactive.Parsing.LanguageSpecificParseResult : object {
    [CompilerGeneratedAttribute]
private static LanguageSpecificParseResult <None>k__BackingField;
    public static LanguageSpecificParseResult None { get; }
    private static LanguageSpecificParseResult();
    [CompilerGeneratedAttribute]
public static LanguageSpecificParseResult get_None();
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Parsing.LanguageSpecificParseResult/<GetDiagnostics>d__3")]
public virtual IEnumerable`1<Diagnostic> GetDiagnostics();
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.LanguageToken : SyntaxToken {
    [NullableContextAttribute("1")]
internal LanguageToken(SourceText text, TextSpan span, PolyglotSyntaxTree syntaxTree);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Parsing.ParseResultExtensions : object {
    [ExtensionAttribute]
internal static Symbol GetByAlias(IEnumerable`1<Symbol> symbols, string alias);
    [ExtensionAttribute]
internal static Argument`1<PackageReferenceOrFileInfo> FindPackageArgument(Parser parser);
}
internal class Microsoft.DotNet.Interactive.Parsing.PolyglotLexer : object {
    private TextWindow _textWindow;
    private SourceText _sourceText;
    private PolyglotSyntaxTree _syntaxTree;
    private List`1<SyntaxToken> _tokens;
    private string CurrentTextWindow { get; }
    public PolyglotLexer(SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    public IReadOnlyList`1<SyntaxToken> Lex();
    private void LexTrivia();
    private bool IsDirective();
    private void LexDirective();
    private void LexDirectiveArgs();
    private void LexSyntax();
    private void FlushToken(TokenKind kind);
    [DebuggerHiddenAttribute]
private char GetNextChar();
    [DebuggerHiddenAttribute]
private char GetPreviousChar();
    [DebuggerHiddenAttribute]
private bool More();
    private string get_CurrentTextWindow();
    [CompilerGeneratedAttribute]
private bool <IsDirective>g__IsShebangAndNoFollowingWhitespace|7_0(int position, char value);
    [CompilerGeneratedAttribute]
private bool <IsDirective>g__IsCharacterThenWhitespace|7_1(char value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.PolyglotSubmissionNode : SyntaxNode {
    [CompilerGeneratedAttribute]
private string <DefaultLanguage>k__BackingField;
    public string DefaultLanguage { get; }
    internal PolyglotSubmissionNode(string defaultLanguage, SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public string get_DefaultLanguage();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.DotNet.Interactive.Parsing.PolyglotSyntaxParser : object {
    private SourceText _sourceText;
    private Parser _rootKernelDirectiveParser;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IDictionary`2<string, ValueTuple`2<SchedulingScope, Func`1<Parser>>> _subkernelInfoByKernelName;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IReadOnlyList`1<SyntaxToken> _tokens;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _mapOfKernelNamesByAlias;
    [CompilerGeneratedAttribute]
private string <DefaultLanguage>k__BackingField;
    public string DefaultLanguage { get; }
    internal PolyglotSyntaxParser(SourceText sourceText, string defaultLanguage, Parser rootKernelDirectiveParser, IDictionary`2<string, ValueTuple`2<SchedulingScope, Func`1<Parser>>> subkernelInfoByKernelName);
    [CompilerGeneratedAttribute]
public string get_DefaultLanguage();
    public PolyglotSyntaxTree Parse();
    private void ParseSubmission(PolyglotSubmissionNode rootNode);
    private bool IsDefinedInRootKernel(string directiveName);
    private bool IsChooseKernelDirective(DirectiveToken directiveToken);
    private bool AllowsValueSharingByInterpolation(DirectiveToken directiveToken);
    [CompilerGeneratedAttribute]
private void <ParseSubmission>g__AppendAsLanguageNode|10_0(SyntaxNodeOrToken nodeOrToken, <>c__DisplayClass10_0& );
    [CompilerGeneratedAttribute]
private void <ParseSubmission>g__AssignDirectiveParser|10_1(DirectiveNode directiveNode, <>c__DisplayClass10_0& );
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Microsoft.DotNet.Interactive.Parsing.PolyglotSyntaxTree : object {
    [NullableAttribute("1")]
private SourceText _sourceText;
    private SyntaxNode _root;
    public int Length { get; }
    internal SyntaxNode RootNode { get; internal set; }
    [NullableContextAttribute("1")]
internal PolyglotSyntaxTree(SourceText sourceText);
    public int get_Length();
    internal SyntaxNode get_RootNode();
    internal void set_RootNode(SyntaxNode value);
    public SyntaxNode GetRoot();
    [NullableContextAttribute("1")]
public virtual string ToString();
    public string GetLanguageAtPosition(int position);
    [NullableContextAttribute("1")]
public int GetAbsolutePosition(LinePosition linePosition);
}
public class Microsoft.DotNet.Interactive.Parsing.SubmissionParser : object {
    private Kernel _kernel;
    private Parser _directiveParser;
    private RootCommand _rootCommand;
    private Dictionary`2<Type, string> _customInputTypeHints;
    public IReadOnlyList`1<Command> Directives { get; }
    public SubmissionParser(Kernel kernel);
    public IReadOnlyList`1<Command> get_Directives();
    public PolyglotSyntaxTree Parse(string code, string language);
    public IReadOnlyList`1<KernelCommand> SplitSubmission(SubmitCode submitCode);
    public IReadOnlyList`1<KernelCommand> SplitSubmission(RequestDiagnostics requestDiagnostics);
    private IReadOnlyList`1<KernelCommand> SplitSubmission(KernelCommand originalCommand, string code, CreateChildCommand createCommand);
    private string DefaultKernelName();
    internal IDictionary`2<string, ValueTuple`2<SchedulingScope, Func`1<Parser>>> GetSubkernelDirectiveParsers();
    internal Parser GetDirectiveParser();
    internal static ValueTuple`2<string, string> SplitKernelDesignatorToken(string tokenToReplace, string kernelNameIfNotSpecified);
    private bool InterpolateValueFromKernel(string tokenToReplace, IReadOnlyList`1& replacementTokens, String& errorMessage);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Parsing.SubmissionParser/<ParseInputProperties>d__17")]
private static IEnumerable`1<ValueTuple`2<string, string>> ParseInputProperties(string input);
    private string GetTypeHint(Symbol symbol);
    public void AddDirective(Command command);
    public void SetInputTypeHint(Type expectedType, string inputTypeHint);
    internal void ResetParser();
    public static CompletionItem CompletionItemFor(string name, ParseResult parseResult);
    private void EnsureRootCommandIsInitialized();
    [CompilerGeneratedAttribute]
internal static bool <SplitSubmission>g__IsUnknownDirective|11_2(ActionDirectiveNode adn);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private HelpBuilder <GetDirectiveParser>b__14_0(BindingContext _);
    [CompilerGeneratedAttribute]
private void <InterpolateValueFromKernel>g__ReplaceTokensWithUserInput|16_0(IReadOnlyList`1& replacementTokens, <>c__DisplayClass16_0& );
    [CompilerGeneratedAttribute]
internal static bool <InterpolateValueFromKernel>g__ContainsInvalidCharactersForValueReference|16_1(ReadOnlySpan`1<char> tokenToReplace);
    [CompilerGeneratedAttribute]
internal static ValueTuple`2<string, string> <ParseInputProperties>g__GetPromptOrFieldName|17_0(string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Microsoft.DotNet.Interactive.Parsing.SyntaxNode : SyntaxNodeOrToken {
    private List`1<SyntaxNodeOrToken> _childNodesAndTokens;
    private TextSpan _span;
    public TextSpan Span { get; }
    public IEnumerable`1<SyntaxNode> ChildNodes { get; }
    public IEnumerable`1<SyntaxNodeOrToken> ChildTokens { get; }
    public IReadOnlyList`1<SyntaxNodeOrToken> ChildNodesAndTokens { get; }
    private protected SyntaxNode(SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    public virtual TextSpan get_Span();
    public bool Contains(SyntaxNode node);
    [NullableContextAttribute("2")]
public SyntaxNode FindNode(TextSpan span);
    [NullableContextAttribute("2")]
public SyntaxNode FindNode(int position);
    [NullableContextAttribute("2")]
public SyntaxToken FindToken(int position);
    internal void GrowSpan(SyntaxNodeOrToken child);
    internal void Add(SyntaxNodeOrToken child);
    public IEnumerable`1<SyntaxNode> get_ChildNodes();
    public IEnumerable`1<SyntaxNodeOrToken> get_ChildTokens();
    public IReadOnlyList`1<SyntaxNodeOrToken> get_ChildNodesAndTokens();
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Parsing.SyntaxNode/<DescendantNodesAndTokensAndSelf>d__17")]
public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokensAndSelf();
    public IEnumerable`1<SyntaxNodeOrToken> DescendantNodesAndTokens();
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Parsing.SyntaxNode/<GetDiagnostics>d__19")]
public virtual IEnumerable`1<Diagnostic> GetDiagnostics();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
public abstract class Microsoft.DotNet.Interactive.Parsing.SyntaxNodeOrToken : object {
    [CompilerGeneratedAttribute]
private SourceText <SourceText>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private SyntaxNode <Parent>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PolyglotSyntaxTree <SyntaxTree>k__BackingField;
    protected SourceText SourceText { get; }
    [NullableAttribute("2")]
public SyntaxNode Parent { get; internal set; }
    public TextSpan Span { get; }
    [NullableAttribute("2")]
public PolyglotSyntaxTree SyntaxTree { get; }
    public string Text { get; }
    private protected SyntaxNodeOrToken(SourceText sourceText, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
protected SourceText get_SourceText();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public SyntaxNode get_Parent();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
internal void set_Parent(SyntaxNode value);
    public abstract virtual TextSpan get_Span();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PolyglotSyntaxTree get_SyntaxTree();
    public string get_Text();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerStepThroughAttribute]
[DebuggerDisplayAttribute("{GetDebuggerDisplay(), nq}")]
public abstract class Microsoft.DotNet.Interactive.Parsing.SyntaxToken : SyntaxNodeOrToken {
    [CompilerGeneratedAttribute]
private TextSpan <Span>k__BackingField;
    public TextSpan Span { get; }
    internal SyntaxToken(SourceText sourceText, TextSpan span, PolyglotSyntaxTree syntaxTree);
    [CompilerGeneratedAttribute]
public virtual TextSpan get_Span();
    private string GetDebuggerDisplay();
    public virtual string ToString();
}
[DebuggerStepThroughAttribute]
internal class Microsoft.DotNet.Interactive.Parsing.TextWindow : object {
    [CompilerGeneratedAttribute]
private int <Start>k__BackingField;
    [CompilerGeneratedAttribute]
private int <End>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Limit>k__BackingField;
    public int Start { get; }
    public int End { get; private set; }
    public int Limit { get; }
    public int Length { get; }
    public bool IsEmpty { get; }
    public TextSpan Span { get; }
    public TextWindow(int start, int limit);
    [CompilerGeneratedAttribute]
public int get_Start();
    [CompilerGeneratedAttribute]
public int get_End();
    [CompilerGeneratedAttribute]
private void set_End(int value);
    [CompilerGeneratedAttribute]
public int get_Limit();
    public int get_Length();
    public bool get_IsEmpty();
    public void Advance();
    public TextSpan get_Span();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
[DebuggerStepThroughAttribute]
public class Microsoft.DotNet.Interactive.Parsing.TriviaToken : SyntaxToken {
    [NullableContextAttribute("1")]
internal TriviaToken(SourceText text, TextSpan span, PolyglotSyntaxTree syntaxTree);
}
[JsonConverterAttribute("Microsoft.DotNet.Interactive.PasswordStringJsonConverter")]
public class Microsoft.DotNet.Interactive.PasswordString : object {
    private string _clearTextPassword;
    public PasswordString(string clearTextPassword);
    public string GetClearTextPassword();
    public virtual string ToString();
}
internal class Microsoft.DotNet.Interactive.PasswordStringJsonConverter : JsonConverter`1<PasswordString> {
    public virtual PasswordString Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, PasswordString value, JsonSerializerOptions options);
}
public class Microsoft.DotNet.Interactive.ResolvedPackageReference : PackageReference {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <AssemblyPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<string> <ProbingPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackageRoot>k__BackingField;
    public IReadOnlyList`1<string> AssemblyPaths { get; }
    public IReadOnlyList`1<string> ProbingPaths { get; }
    public string PackageRoot { get; }
    public ResolvedPackageReference(string packageName, string packageVersion, IReadOnlyList`1<string> assemblyPaths, string packageRoot, IReadOnlyList`1<string> probingPaths);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_AssemblyPaths();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<string> get_ProbingPaths();
    [CompilerGeneratedAttribute]
public string get_PackageRoot();
    public virtual string ToString();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "17.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Microsoft.DotNet.Interactive.Resources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FileDoesNotExist { get; }
    internal static string Magics_ErrorMessage_CannotBeUsedTogether { get; }
    internal static string Magics_import_Description { get; }
    internal static string Magics_log_Description { get; }
    internal static string Magics_set_byref_Description { get; }
    internal static string Magics_set_Description { get; }
    internal static string Magics_set_ErrorMessage_SharingByReference { get; }
    internal static string Magics_set_mime_type_Description { get; }
    internal static string Magics_set_mime_type_ErrorMessage_CannotBeUsed { get; }
    internal static string Magics_set_name_Description { get; }
    internal static string Magics_set_value_Description { get; }
    internal static string Magics_share_as_Description { get; }
    internal static string Magics_share_Description { get; }
    internal static string Magics_share_from_Description { get; }
    internal static string Magics_share_mime_type_Description { get; }
    internal static string Magics_share_name_Description { get; }
    internal static string Magics_value_from_file_Description { get; }
    internal static string Magics_value_from_url_Description { get; }
    internal static string Magics_value_from_value_Description { get; }
    internal static string Magics_value_mime_type_Description { get; }
    internal static string Magics_value_name_Description { get; }
    internal static string Magics_who_Description { get; }
    internal static string Magics_whos_Description { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FileDoesNotExist();
    internal static string get_Magics_ErrorMessage_CannotBeUsedTogether();
    internal static string get_Magics_import_Description();
    internal static string get_Magics_log_Description();
    internal static string get_Magics_set_byref_Description();
    internal static string get_Magics_set_Description();
    internal static string get_Magics_set_ErrorMessage_SharingByReference();
    internal static string get_Magics_set_mime_type_Description();
    internal static string get_Magics_set_mime_type_ErrorMessage_CannotBeUsed();
    internal static string get_Magics_set_name_Description();
    internal static string get_Magics_set_value_Description();
    internal static string get_Magics_share_as_Description();
    internal static string get_Magics_share_Description();
    internal static string get_Magics_share_from_Description();
    internal static string get_Magics_share_mime_type_Description();
    internal static string get_Magics_share_name_Description();
    internal static string get_Magics_value_from_file_Description();
    internal static string get_Magics_value_from_url_Description();
    internal static string get_Magics_value_from_value_Description();
    internal static string get_Magics_value_mime_type_Description();
    internal static string get_Magics_value_name_Description();
    internal static string get_Magics_who_Description();
    internal static string get_Magics_whos_Description();
}
[DebuggerStepThroughAttribute]
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.MessageDiagnosticsFormatterSource")]
public abstract class Microsoft.DotNet.Interactive.RoutingSlip : object {
    private List`1<Entry> _entries;
    internal ICollection`1<Entry> Entries { get; }
    public int Count { get; }
    internal ICollection`1<Entry> get_Entries();
    public abstract virtual void Stamp(Uri uri);
    public String[] ToUriArray();
    public int get_Count();
    public bool Contains(Uri uri, bool ignoreQuery);
    private bool Contains(string uri);
    private bool ContainsUriWithoutQuery(string uriWithoutQuery);
    public bool StartsWith(RoutingSlip other);
    public void ContinueWith(RoutingSlip other);
    public virtual string ToString();
    private bool Contains(Entry entry);
    protected static string GetAbsoluteUriWithoutQuery(Uri uri);
}
[DebuggerStepThroughAttribute]
internal class Microsoft.DotNet.Interactive.SchedulingScope : object {
    private string _stringValue;
    [CompilerGeneratedAttribute]
private String[] <Parts>k__BackingField;
    public String[] Parts { get; }
    private SchedulingScope(string scope);
    protected bool Equals(SchedulingScope other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static SchedulingScope Parse(string scope);
    [CompilerGeneratedAttribute]
public String[] get_Parts();
    public SchedulingScope Append(string part);
    public bool Contains(SchedulingScope scope);
}
public class Microsoft.DotNet.Interactive.ScriptContent : object {
    [CompilerGeneratedAttribute]
private string <ScriptValue>k__BackingField;
    public string ScriptValue { get; }
    public ScriptContent(string scriptValue);
    [CompilerGeneratedAttribute]
public string get_ScriptValue();
    public sealed virtual void WriteTo(TextWriter writer, HtmlEncoder encoder);
}
public class Microsoft.DotNet.Interactive.SignatureInformation : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattedValue <Documentation>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<ParameterInformation> <Parameters>k__BackingField;
    public string Label { get; }
    public FormattedValue Documentation { get; }
    public IReadOnlyList`1<ParameterInformation> Parameters { get; }
    public SignatureInformation(string label, FormattedValue documentation, IReadOnlyList`1<ParameterInformation> parameters);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public FormattedValue get_Documentation();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<ParameterInformation> get_Parameters();
}
public class Microsoft.DotNet.Interactive.SqlDiscoverabilityKernel : Kernel {
    private HashSet`1<string> _kernelNameFilter;
    public static string DefaultKernelName;
    private sealed virtual override Task Microsoft.DotNet.Interactive.IKernelCommandHandler<Microsoft.DotNet.Interactive.Commands.SubmitCode>.HandleAsync(SubmitCode command, KernelInvocationContext context);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Microsoft.DotNet.Interactive.StringExtensions : object {
    [ExtensionAttribute]
public static string TruncateForDisplay(string value, int maxLength);
}
public class Microsoft.DotNet.Interactive.TabularDataResourceSummaryExplorer : DataExplorer`1<TabularDataResource> {
    public TabularDataResourceSummaryExplorer(TabularDataResource data);
    protected virtual IHtmlContent ToHtml();
}
public class Microsoft.DotNet.Interactive.Utility.AddPackageResult : CommandLineResult {
    [CompilerGeneratedAttribute]
private string <InstalledVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <DetailedErrors>k__BackingField;
    public string InstalledVersion { get; }
    public IEnumerable`1<string> DetailedErrors { get; }
    public AddPackageResult(int exitCode, IReadOnlyCollection`1<string> output, IReadOnlyCollection`1<string> error);
    [CompilerGeneratedAttribute]
public string get_InstalledVersion();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_DetailedErrors();
    private IEnumerable`1<string> GetDetailedErrors(IReadOnlyCollection`1<string> output, IReadOnlyCollection`1<string> error);
    private string GetInstalledVersion(IReadOnlyCollection`1<string> output);
}
public static class Microsoft.DotNet.Interactive.Utility.AsyncContext : object {
    private static int _seed;
    private static AsyncLocal`1<Nullable`1<int>> _id;
    public static Nullable`1<int> Id { get; }
    private static AsyncContext();
    public static Nullable`1<int> get_Id();
    public static bool TryEstablish(Int32& id);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Utility.CommandLine : object {
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    private static Logger Log { get; }
    private static CommandLine();
    public static Task`1<CommandLineResult> Execute(FileInfo exePath, string args, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.CommandLine/<Execute>d__1")]
public static Task`1<CommandLineResult> Execute(string command, string args, DirectoryInfo workingDir, Nullable`1<TimeSpan> timeout);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.CommandLine/<Complete>d__2")]
[ExtensionAttribute]
public static Task`1<int> Complete(Process process);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.CommandLine/<Timeout>d__3`1")]
[ExtensionAttribute]
public static Task`1<T> Timeout(Task`1<T> source, TimeSpan timeout);
    public static Process StartProcess(string command, string args, DirectoryInfo workingDir, Action`1<string> output, Action`1<string> error, ValueTuple`2[] environmentVariables);
    [ExtensionAttribute]
public static string AppendArgs(string initial, string append);
    private static ConfirmationLogger ConfirmOnExit(object command, string args, string operationName);
    [CompilerGeneratedAttribute]
private static Logger get_Log();
}
public class Microsoft.DotNet.Interactive.Utility.CommandLineInvocationException : Exception {
    public CommandLineInvocationException(CommandLineResult result, string message);
}
public class Microsoft.DotNet.Interactive.Utility.CommandLineResult : object {
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Error>k__BackingField;
    public int ExitCode { get; }
    public IReadOnlyCollection`1<string> Output { get; }
    public IReadOnlyCollection`1<string> Error { get; }
    public CommandLineResult(int exitCode, IReadOnlyCollection`1<string> output, IReadOnlyCollection`1<string> error);
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Output();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Error();
    public void ThrowOnFailure(string message);
}
public static class Microsoft.DotNet.Interactive.Utility.ConsoleOutput : object {
    private static object _systemConsoleSwapLock;
    private static MultiplexingTextWriter _multiplexingOutputWriter;
    private static MultiplexingTextWriter _multiplexingErrorWriter;
    private static TextWriter _originalOutputWriter;
    private static TextWriter _originalErrorWriter;
    private static int _refCount;
    private static ConsoleOutput();
    public static IDisposable Subscribe(Func`2<ObservableConsole, IDisposable> subscribe);
    public static IDisposable InitializeFromAsyncContext(int asyncContextId);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.DictionaryExtensions : object {
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> getValue);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<string, object> dictionary, string key, Func`2<string, TValue> getValue);
    [ExtensionAttribute]
public static IDictionary`2<TKey, TValue> Merge(IDictionary`2<TKey, TValue> dictionary1, IDictionary`2<TKey, TValue> dictionary2, bool replace, IEqualityComparer`1<TKey> comparer);
    [ExtensionAttribute]
public static void MergeWith(IDictionary`2<TKey, TValue> target, IDictionary`2<TKey, TValue> source, bool replace);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Utility.DirectoryUtility : object {
    [ExtensionAttribute]
public static DirectoryInfo EnsureExists(DirectoryInfo directory);
}
public class Microsoft.DotNet.Interactive.Utility.DisposableDirectory : object {
    [CompilerGeneratedAttribute]
private DirectoryInfo <Directory>k__BackingField;
    public DirectoryInfo Directory { get; }
    public DisposableDirectory(DirectoryInfo directory);
    public static DisposableDirectory Create();
    [CompilerGeneratedAttribute]
public DirectoryInfo get_Directory();
    public sealed virtual void Dispose();
}
public class Microsoft.DotNet.Interactive.Utility.Dotnet : object {
    protected DirectoryInfo _workingDirectory;
    private static Lazy`1<FileInfo> _getPath;
    public static FileInfo Path { get; }
    public Dotnet(DirectoryInfo workingDirectory);
    private static Dotnet();
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.Dotnet/<New>d__2")]
public Task`1<CommandLineResult> New(string templateName, string args);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.Dotnet/<AddPackage>d__3")]
public Task`1<AddPackageResult> AddPackage(string packageId, string version);
    public Task`1<CommandLineResult> AddReference(FileInfo projectToReference, Nullable`1<TimeSpan> timeout);
    public Task`1<CommandLineResult> Build(string args, Nullable`1<TimeSpan> timeout);
    public Task`1<CommandLineResult> Clean(Nullable`1<TimeSpan> timeout);
    public Task`1<CommandLineResult> Execute(string args, Nullable`1<TimeSpan> timeout);
    public Process StartProcess(string args, Action`1<string> output, Action`1<string> error);
    public Task`1<CommandLineResult> Publish(string args, Nullable`1<TimeSpan> timeout);
    public Task`1<CommandLineResult> VSTest(string args);
    public Task`1<CommandLineResult> ToolInstall(string packageName, DirectoryInfo toolPath, string addSource, string version);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.Dotnet/<ToolList>d__12")]
public Task`1<IEnumerable`1<string>> ToolList(DirectoryInfo directory);
    public Task`1<CommandLineResult> Pack(string args, Nullable`1<TimeSpan> timeout);
    public static FileInfo get_Path();
    private static FileInfo FindDotnetFromPath();
    private static FileInfo FindDotnetFromAppContext();
    public static string GetDataFromAppDomain(string propertyName);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.EnumerableExtensions/<FlattenBreadthFirst>d__0`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> FlattenBreadthFirst(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> children);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.EnumerableExtensions/<FlattenDepthFirst>d__1`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> FlattenDepthFirst(IEnumerable`1<T> source, Func`2<T, IEnumerable`1<T>> children);
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.EnumerableExtensions/<RecurseWhileNotNull>d__2`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> RecurseWhileNotNull(T source, Func`2<T, T> next);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.Interactive.Utility.FileNameUtilities : object {
    private static string DirectorySeparatorStr;
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static char VolumeSeparatorChar;
    internal static bool IsFileName(string path);
    private static int IndexOfExtension(string path);
    public static string GetExtension(string path);
    private static string RemoveExtension(string path);
    public static string ChangeExtension(string path, string extension);
    internal static int IndexOfFileName(string path);
    public static string GetFileName(string path, bool includeExtension);
    [ExtensionAttribute]
public static string ExecutableName(string withoutExtension);
}
public class Microsoft.DotNet.Interactive.Utility.GCPressure : object {
    private long _bytesAllocated;
    public GCPressure(long bytesAllocated);
    public sealed virtual void Dispose();
}
internal static class Microsoft.DotNet.Interactive.Utility.Hash : object {
    internal static int FnvOffsetBias;
    internal static int FnvPrime;
    internal static int Combine(int newKey, int currentKey);
    internal static int Combine(UInt32 newKey, int currentKey);
    internal static int Combine(bool newKeyPart, int currentKey);
    internal static int GetFNVHashCode(Byte[] data);
    internal static int GetFNVHashCode(ImmutableArray`1<byte> data);
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.InvocationContextExtensions : object {
    [ExtensionAttribute]
public static T GetService(InvocationContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.DotNet.Interactive.Utility.IOExtensions : object {
    private static Encoding DefaultEncoding;
    private static IOExtensions();
    internal static Task`1<string> ReadAllTextAsync(string filePath, Encoding encoding, CancellationToken cancellationToken);
}
[DebuggerDisplayAttribute("MultiplexingTextWriter")]
public class Microsoft.DotNet.Interactive.Utility.MultiplexingTextWriter : TextWriter {
    private static UnicodeEncoding modreq(System.Runtime.CompilerServices.IsVolatile) _encoding;
    private Func`1<TextWriter> _createTextWriter;
    private string _name;
    private ConcurrentDictionary`2<int, TextWriter> _writers;
    private TextWriter _defaultWriter;
    public Encoding Encoding { get; }
    public IEnumerable`1<TextWriter> Writers { get; }
    public MultiplexingTextWriter(string name, Func`1<TextWriter> createTextWriter, TextWriter defaultWriter);
    private TextWriter DefaultCreateTextWriter();
    public IDisposable EnsureInitializedForCurrentAsyncContext();
    internal IDisposable InitializeCurrentAsyncContextUsingWriterFrom(int sourceAsyncContextId);
    private TextWriter GetCurrentWriter();
    public IObservable`1<string> GetObservable();
    public virtual Encoding get_Encoding();
    public IEnumerable`1<TextWriter> get_Writers();
    public virtual void Write(char value);
    public virtual void WriteLine();
    public virtual void WriteLine(char value);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual void Write(bool value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(ReadOnlySpan`1<char> buffer);
    public virtual void Write(float value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void Write(UInt32 value);
    public virtual void Write(ulong value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteAsync(string value);
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(ReadOnlySpan`1<char> buffer);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(ReadOnlyMemory`1<char> buffer, CancellationToken cancellationToken);
    public virtual Task WriteLineAsync(string value);
    protected virtual void Dispose(bool disposing);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private TextWriter <GetCurrentWriter>b__9_0(int _);
}
public class Microsoft.DotNet.Interactive.Utility.ObservableStringWriter : StringWriter {
    private Subject`1<string> _writeEvents;
    private List`1<TextSpan> _regions;
    private bool _trackingWriteOperation;
    private int _observerCount;
    private CompositeDisposable _disposable;
    protected virtual void Dispose(bool disposing);
    public virtual void Write(char value);
    private void PublishStringIfObserved(StringBuilder sb, TextSpan textSpan);
    private void TrackWriteOperation(Action action);
    [AsyncStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.ObservableStringWriter/<TrackWriteOperationAsync>d__10")]
private Task TrackWriteOperationAsync(Func`1<Task> action);
    public virtual void Write(Char[] buffer, int index, int count);
    public virtual void Write(string value);
    public virtual Task WriteAsync(char value);
    public virtual Task WriteAsync(Char[] buffer, int index, int count);
    public virtual Task WriteAsync(string value);
    public virtual Task WriteLineAsync(char value);
    public virtual Task WriteLineAsync(Char[] buffer, int index, int count);
    public virtual Task WriteLineAsync(string value);
    public virtual void Write(bool value);
    public virtual void Write(Char[] buffer);
    public virtual void Write(decimal value);
    public virtual void Write(double value);
    public virtual void Write(int value);
    public virtual void Write(long value);
    public virtual void Write(object value);
    public virtual void Write(float value);
    public virtual void Write(string format, object arg0);
    public virtual void Write(string format, object arg0, object arg1);
    public virtual void Write(string format, object arg0, object arg1, object arg2);
    public virtual void Write(string format, Object[] arg);
    public virtual void Write(UInt32 value);
    public virtual void Write(ulong value);
    public virtual void WriteLine();
    public virtual void WriteLine(bool value);
    public virtual void WriteLine(char value);
    public virtual void WriteLine(Char[] buffer);
    public virtual void WriteLine(Char[] buffer, int index, int count);
    public virtual void WriteLine(decimal value);
    public virtual void WriteLine(double value);
    public virtual void WriteLine(int value);
    public virtual void WriteLine(long value);
    public virtual void WriteLine(object value);
    public virtual void WriteLine(float value);
    public virtual void WriteLine(string value);
    public virtual void WriteLine(string format, object arg0);
    public virtual void WriteLine(string format, object arg0, object arg1);
    public virtual void WriteLine(string format, object arg0, object arg1, object arg2);
    public virtual void WriteLine(string format, Object[] arg);
    public virtual void WriteLine(UInt32 value);
    public virtual void WriteLine(ulong value);
    public virtual Task WriteLineAsync();
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.Utility.ObservableStringWriter/<Writes>d__52")]
public IEnumerable`1<string> Writes();
    public sealed virtual IDisposable Subscribe(IObserver`1<string> observer);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__0(char value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private StringBuilder <>n__1();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__2(Char[] buffer, int index, int count);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__3(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__4(char value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__5(Char[] buffer, int index, int count);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__6(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__7(char value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__8(Char[] buffer, int index, int count);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task <>n__9(string value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__10(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__11(Char[] buffer);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__12(decimal value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__13(double value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__14(int value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__15(long value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__16(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__17(float value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__18(string format, object arg0);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__19(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__20(string format, object arg0, object arg1, object arg2);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__21(string format, Object[] arg);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__22(UInt32 value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__23(ulong value);
    [CompilerGeneratedAttribute]
private void <WriteLine>b__33_0();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__24(bool value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__25(char value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__26(Char[] buffer);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__27(Char[] buffer, int index, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__28(decimal value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__29(double value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__30(int value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__31(long value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__32(object value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__33(float value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__34(string value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__35(string format, object arg0);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__36(string format, object arg0, object arg1);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__37(string format, object arg0, object arg1, object arg2);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__38(string format, Object[] arg);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__39(UInt32 value);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private void <>n__40(ulong value);
    [CompilerGeneratedAttribute]
private Task <WriteLineAsync>b__51_0();
    [CompilerGeneratedAttribute]
private void <Subscribe>b__53_0();
}
internal enum Microsoft.DotNet.Interactive.Utility.PathKind : Enum {
    public int value__;
    public static PathKind Empty;
    public static PathKind Relative;
    public static PathKind RelativeToCurrentDirectory;
    public static PathKind RelativeToCurrentParent;
    public static PathKind RelativeToCurrentRoot;
    public static PathKind RelativeToDriveDirectory;
    public static PathKind Absolute;
}
public static class Microsoft.DotNet.Interactive.Utility.Paths : object {
    private static string DotnetHomeVariableName;
    private static string DotnetProfileDirectoryName;
    private static string ToolsShimFolderName;
    [CompilerGeneratedAttribute]
private static string <DotnetToolsPath>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <UserProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <NugetCache>k__BackingField;
    public static string InstallDirectory;
    public static string DotnetUserProfileFolderPath { get; }
    public static string DotnetHomePath { get; }
    public static string DotnetToolsPath { get; }
    public static string UserProfile { get; }
    public static string NugetCache { get; }
    private static Paths();
    public static string get_DotnetUserProfileFolderPath();
    public static string get_DotnetHomePath();
    [CompilerGeneratedAttribute]
public static string get_DotnetToolsPath();
    [CompilerGeneratedAttribute]
public static string get_UserProfile();
    [CompilerGeneratedAttribute]
public static string get_NugetCache();
}
[ExtensionAttribute]
internal static class Microsoft.DotNet.Interactive.Utility.PathUtilities : object {
    internal static char DirectorySeparatorChar;
    internal static char AltDirectorySeparatorChar;
    internal static string ParentRelativeDirectory;
    internal static string ThisDirectory;
    internal static string DirectorySeparatorStr;
    internal static char VolumeSeparatorChar;
    private static Char[] s_pathChars;
    public static IEqualityComparer`1<string> Comparer;
    internal static bool IsUnixLikePlatform { get; }
    private static PathUtilities();
    internal static bool get_IsUnixLikePlatform();
    public static bool IsDirectorySeparator(char c);
    public static bool IsAnyDirectorySeparator(char c);
    [ExtensionAttribute]
public static string TrimTrailingSeparators(string s);
    [ExtensionAttribute]
public static string EnsureTrailingSeparator(string s);
    public static string GetExtension(string path);
    public static string ChangeExtension(string path, string extension);
    public static string RemoveExtension(string path);
    public static string GetFileName(string path, bool includeExtension);
    public static string GetDirectoryName(string path);
    internal static string GetDirectoryName(string path, bool isUnixLike);
    internal static bool IsSameDirectoryOrChildOf(string child, string parent);
    public static string GetPathRoot(string path);
    private static string GetPathRoot(string path, bool isUnixLike);
    private static string GetWindowsRoot(string path);
    private static int ConsumeDirectorySeparators(string path, int length, int i);
    private static string GetUnixRoot(string path);
    public static PathKind GetPathKind(string path);
    public static bool IsAbsolute(string path);
    private static bool IsDriveRootedAbsolutePath(string path);
    public static string CombineAbsoluteAndRelativePaths(string root, string relativePath);
    public static string CombinePossiblyRelativeAndRelativePaths(string rootOpt, string relativePath);
    public static string CombinePathsUnchecked(string root, string relativePath);
    private static string RemoveTrailingDirectorySeparator(string path);
    public static bool IsFilePath(string assemblyDisplayNameOrPath);
    public static bool ContainsPathComponent(string path, string component, bool ignoreCase);
    public static string GetRelativePath(string directory, string fullPath);
    private static string GetRelativeParentPath(string childPath, string parentPath);
    public static bool IsChildPath(string parentPath, string childPath);
    private static string GetRelativeChildPath(string parentPath, string childPath);
    private static String[] GetPathParts(string path);
    public static bool PathsEqual(string path1, string path2);
    private static bool PathsEqual(string path1, string path2, int length);
    private static bool PathCharEqual(char x, char y);
    private static int PathHashCode(string path);
    public static string NormalizePathPrefix(string filePath, ImmutableArray`1<KeyValuePair`2<string, string>> pathMap);
    public static bool IsValidFilePath(string fullPath);
}
public static class Microsoft.DotNet.Interactive.Utility.SourceUtilities : object {
    private static Regex _lastToken;
    private static SourceUtilities();
    public static int ComputeReplacementStartPosition(string code, int cursorPosition);
    public static int GetCursorOffsetFromPosition(string code, LinePosition position);
    public static LinePosition GetPositionFromCursorOffset(string code, int cursorOffset);
    public static LinePositionSpan GetLinePositionSpanFromStartAndEndIndices(string code, int startIndex, int endIndex);
}
internal class Microsoft.DotNet.Interactive.ValueSharing.JavaScriptValueDeclarer : object {
    private static JsonSerializerOptions _serializerOptions;
    private static JavaScriptValueDeclarer();
    public static bool TryGetValueDeclaration(object referenceValue, string declareAsName, String& code);
}
public class Microsoft.DotNet.Interactive.ValueSharing.KernelValue : object {
    private KernelValueInfo _valueInfo;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KernelName>k__BackingField;
    public object Value { get; }
    public Type Type { get; }
    public string Name { get; }
    public string KernelName { get; }
    public KernelValue(KernelValueInfo valueInfo, object value, string kernelName);
    [CompilerGeneratedAttribute]
public object get_Value();
    public Type get_Type();
    public string get_Name();
    [CompilerGeneratedAttribute]
public string get_KernelName();
}
public class Microsoft.DotNet.Interactive.ValueSharing.KernelValueInfo : object {
    private IReadOnlyCollection`1<string> _preferredMimeTypes;
    private string _typeName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattedValue <FormattedValue>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    public string TypeName { get; public set; }
    public string Name { get; }
    public FormattedValue FormattedValue { get; }
    public IReadOnlyCollection`1<string> PreferredMimeTypes { get; public set; }
    [JsonIgnoreAttribute]
public Type Type { get; }
    public KernelValueInfo(string name, FormattedValue formattedValue, Type type, string typeName);
    public string get_TypeName();
    public void set_TypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FormattedValue get_FormattedValue();
    public IReadOnlyCollection`1<string> get_PreferredMimeTypes();
    public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_PreferredMimeTypes(IReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public Type get_Type();
}
[TypeFormatterSourceAttribute("Microsoft.DotNet.Interactive.ValueSharing.KernelValuesFormatterSource")]
internal class Microsoft.DotNet.Interactive.ValueSharing.KernelValues : object {
    private Dictionary`2<string, KernelValue> _variables;
    [CompilerGeneratedAttribute]
private bool <Detailed>k__BackingField;
    public bool Detailed { get; }
    public KernelValues(IEnumerable`1<KernelValue> variables, bool detailed);
    private KernelValues(bool detailed);
    [CompilerGeneratedAttribute]
public bool get_Detailed();
    public sealed virtual IEnumerator`1<KernelValue> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class Microsoft.DotNet.Interactive.ValueSharing.KernelValuesFormatterSource : object {
    [IteratorStateMachineAttribute("Microsoft.DotNet.Interactive.ValueSharing.KernelValuesFormatterSource/<CreateTypeFormatters>d__0")]
public sealed virtual IEnumerable`1<ITypeFormatter> CreateTypeFormatters();
}
[DebuggerStepThroughAttribute]
internal class Pocket.CompositeDisposable : object {
    private bool isDisposed;
    private List`1<IDisposable> disposables;
    public void Add(IDisposable disposable);
    public void Add(Action dispose);
    public sealed virtual void Dispose();
    public sealed virtual IEnumerator`1<IDisposable> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[DebuggerStepThroughAttribute]
internal class Pocket.ConfirmationLogger : OperationLogger {
    public ConfirmationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public void Fail(Exception exception, string message, Object[] args);
    public void Succeed(string message, Object[] args);
    public virtual void Dispose();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
[ExcludeFromCodeCoverageAttribute]
internal static class Pocket.Discover : object {
    [ExtensionAttribute]
public static IEnumerable`1<Type> Concrete(IEnumerable`1<Type> types);
    public static IEnumerable`1<Type> ConcreteTypes();
    [ExtensionAttribute]
public static IEnumerable`1<Type> DerivedFrom(IEnumerable`1<Type> types, Type type);
    [ExtensionAttribute]
public static IEnumerable`1<Type> ImplementingOpenGenericInterfaces(IEnumerable`1<Type> source, Type[] interfaces);
    public static IEnumerable`1<Type> Types();
    [ExtensionAttribute]
public static IEnumerable`1<Type> Types(IEnumerable`1<Assembly> assemblies);
}
[DebuggerStepThroughAttribute]
internal static class Pocket.Disposable : object {
    private static IDisposable empty;
    [CompilerGeneratedAttribute]
private static IDisposable <Empty>k__BackingField;
    public static IDisposable Empty { get; }
    private static Disposable();
    public static IDisposable Create(Action dispose);
    [CompilerGeneratedAttribute]
public static IDisposable get_Empty();
}
[ExtensionAttribute]
internal static class Pocket.Format : object {
    [ExtensionAttribute]
public static ValueTuple`2<string, ValueTuple`2[]> Evaluate(ValueTuple`8& e);
    [ExtensionAttribute]
public static string ToLogString(ValueTuple`8& e);
    [ExtensionAttribute]
internal static string ToLogString(object value);
    [ExtensionAttribute]
private static string IfNotEmpty(string value, string prefix, string suffix);
    private static string LogLevelString(LogLevel logLevel, bool isStartOfOperation, bool isEndOfOperation, Nullable`1<bool> isOperationSuccessful, Nullable`1<TimeSpan> duration);
    [CompilerGeneratedAttribute]
internal static string <LogLevelString>g__symbol|5_0(<>c__DisplayClass5_0& );
}
[DebuggerStepThroughAttribute]
internal class Pocket.Formatter : object {
    private static ConcurrentDictionary`2<string, Formatter> cache;
    private static bool stopCaching;
    private static int cacheCount;
    private static Regex tokenRegex;
    private string template;
    private List`1<Action`2<StringBuilder, object>> argumentFormatters;
    private List`1<string> tokens;
    [CompilerGeneratedAttribute]
private static int <CacheLimit>k__BackingField;
    public IReadOnlyList`1<string> Tokens { get; }
    public static int CacheCount { get; }
    public static int CacheLimit { get; public set; }
    private static Formatter();
    public Formatter(string template);
    public IReadOnlyList`1<string> get_Tokens();
    public FormatterResult Format(IReadOnlyList`1<object> args, IList`1<ValueTuple`2<string, object>> knownProperties);
    public FormatterResult Format(Object[] args);
    public static int get_CacheCount();
    [CompilerGeneratedAttribute]
public static int get_CacheLimit();
    [CompilerGeneratedAttribute]
public static void set_CacheLimit(int value);
    public static Formatter Parse(string template);
    [CompilerGeneratedAttribute]
internal static void <Format>g__TryAppendComma|11_0(<>c__DisplayClass11_0& , <>c__DisplayClass11_1& );
    [CompilerGeneratedAttribute]
internal static Formatter <Parse>g__CreateFormatter|19_0(string t);
}
[DebuggerStepThroughAttribute]
internal class Pocket.LogEntry : object {
    [CompilerGeneratedAttribute]
private bool <IsStartOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsOperationSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndOfOperation>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TimeSpan> <OperationDuration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private OperationLogger <Operation>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimestampUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OperationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageTemplate>k__BackingField;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<ValueTuple`2<string, object>> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    public bool IsStartOfOperation { get; }
    public Nullable`1<bool> IsOperationSuccessful { get; }
    public bool IsEndOfOperation { get; }
    public Nullable`1<TimeSpan> OperationDuration { get; }
    public string OperationName { get; }
    public string Category { get; }
    public OperationLogger Operation { get; }
    public DateTime TimestampUtc { get; }
    public LogLevel LogLevel { get; }
    public Exception Exception { get; }
    public string OperationId { get; }
    public string MessageTemplate { get; public set; }
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<ValueTuple`2<string, object>> Properties { get; public set; }
    public Object[] Args { get; public set; }
    public LogEntry(LogLevel logLevel, string messageTemplate, Exception exception, string category, string operationName, OperationLogger operation, Object[] args);
    [CompilerGeneratedAttribute]
public bool get_IsStartOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsOperationSuccessful();
    [CompilerGeneratedAttribute]
public bool get_IsEndOfOperation();
    [CompilerGeneratedAttribute]
public Nullable`1<TimeSpan> get_OperationDuration();
    [CompilerGeneratedAttribute]
public string get_OperationName();
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public OperationLogger get_Operation();
    [CompilerGeneratedAttribute]
public DateTime get_TimestampUtc();
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_OperationId();
    [CompilerGeneratedAttribute]
public string get_MessageTemplate();
    [CompilerGeneratedAttribute]
public void set_MessageTemplate(string value);
    [CompilerGeneratedAttribute]
public List`1<ValueTuple`2<string, object>> get_Properties();
    [CompilerGeneratedAttribute]
public void set_Properties(List`1<ValueTuple`2<string, object>> value);
    [CompilerGeneratedAttribute]
public Object[] get_Args();
    [CompilerGeneratedAttribute]
public void set_Args(Object[] value);
    public void AddProperty(ValueTuple`2<string, object> property);
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.LogEvents : object {
    public static IDisposable Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> onEnrich, Assembly[] searchInAssemblies);
    public static LoggerSubscription Subscribe(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> onEntryPosted, Assembly[] searchInAssemblies);
    private static void SubscribeLoggers(IEnumerable`1<Type> pocketLoggerTypes, LoggerSubscription subscription, Action`1<T> onEntryPosted);
    [ExtensionAttribute]
private static Action`1<T> Catch(Action`1<T> publish);
    [ExtensionAttribute]
private static IEnumerable`1<Type> PocketLoggers(IEnumerable`1<Type> types);
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<Action`1<ValueTuple`2<string, object>>> Enrich;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private static Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> Posted;
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public string Category { get; }
    public static Logger Log { get; }
    public Logger(string category);
    private static Logger();
    [CompilerGeneratedAttribute]
public static void add_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Enrich(Action`1<Action`1<ValueTuple`2<string, object>>> value);
    [CompilerGeneratedAttribute]
public static void add_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    [CompilerGeneratedAttribute]
public static void remove_Posted(Action`1<ValueTuple`8<string, Object[], List`1<ValueTuple`2<string, object>>, byte, DateTime, Exception, string, ValueTuple`2<string, ValueTuple`5<string, bool, bool, Nullable`1<bool>, Nullable`1<TimeSpan>>>>> value);
    public virtual void Post(LogEntry entry);
    protected internal void Post(string message, LogLevel logLevel, string operationName, Exception exception, Object[] args, ValueTuple`2[]& properties);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[DebuggerStepThroughAttribute]
internal class Pocket.Logger`1 : Logger {
    [CompilerGeneratedAttribute]
private static Logger <Log>k__BackingField;
    public static Logger Log { get; }
    private static Logger`1();
    [CompilerGeneratedAttribute]
public static Logger get_Log();
}
[ExtensionAttribute]
[DebuggerStepThroughAttribute]
internal static class Pocket.LoggerExtensions : object {
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Trace(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, string message, Object[] args);
    [ExtensionAttribute]
public static TLogger Info(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Warning(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, string message, Exception exception, Object[] args);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Exception exception);
    [ExtensionAttribute]
public static TLogger Error(TLogger logger, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnEnterAndExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static OperationLogger OnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger ConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, object arg);
    [ExtensionAttribute]
public static ConfirmationLogger OnEnterAndConfirmOnExit(Logger logger, string name, Func`1<ValueTuple`2[]> exitArgs, Object[] args);
    [ExtensionAttribute]
public static void Event(Logger logger, string name);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] metrics);
    [ExtensionAttribute]
public static void Event(Logger logger, string name, ValueTuple`2[] properties);
    [ExtensionAttribute]
public static void Event(Logger logger, ValueTuple`2[]& metrics, ValueTuple`2[]& properties, string name);
}
internal class Pocket.LoggerSubscription : object {
    private CompositeDisposable disposables;
    [CompilerGeneratedAttribute]
private List`1<Type> <DiscoveredLoggerTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<string, bool> <OnFormatLogEntry>k__BackingField;
    public List`1<Type> DiscoveredLoggerTypes { get; }
    public Action`2<string, bool> OnFormatLogEntry { get; public set; }
    public void Add(Type pocketLoggerType, IDisposable unsubscribe);
    [CompilerGeneratedAttribute]
public List`1<Type> get_DiscoveredLoggerTypes();
    [CompilerGeneratedAttribute]
public Action`2<string, bool> get_OnFormatLogEntry();
    [CompilerGeneratedAttribute]
public void set_OnFormatLogEntry(Action`2<string, bool> value);
    public sealed virtual void Dispose();
}
internal enum Pocket.LogLevel : Enum {
    public byte value__;
    public static LogLevel Telemetry;
    public static LogLevel Trace;
    public static LogLevel Debug;
    public static LogLevel Information;
    public static LogLevel Warning;
    public static LogLevel Error;
    public static LogLevel Critical;
}
[DebuggerStepThroughAttribute]
internal class Pocket.OperationLogger : Logger {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`1<ValueTuple`2[]> exitArgs;
    private LogEntry initialEntry;
    private bool disposed;
    private Activity activity;
    [CompilerGeneratedAttribute]
private bool <IsComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStarting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <IsSuccessful>k__BackingField;
    public string Id { get; }
    public string Name { get; }
    public TimeSpan Duration { get; }
    public bool IsComplete { get; private set; }
    public bool IsStarting { get; }
    public Nullable`1<bool> IsSuccessful { get; protected set; }
    public OperationLogger(string operationName, string category, string message, Func`1<ValueTuple`2[]> exitArgs, bool logOnStart, Object[] args);
    public string get_Id();
    public string get_Name();
    public TimeSpan get_Duration();
    [CompilerGeneratedAttribute]
public bool get_IsComplete();
    [CompilerGeneratedAttribute]
private void set_IsComplete(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsStarting();
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_IsSuccessful();
    [CompilerGeneratedAttribute]
protected void set_IsSuccessful(Nullable`1<bool> value);
    public virtual void Post(LogEntry entry);
    protected void Complete(string message, Exception exception, Object[] args);
    public virtual void Dispose();
    protected virtual void Finalize();
}
[ExtensionAttribute]
public static class System.DisplayExtensions : object {
    [ExtensionAttribute]
public static DisplayedValue Display(object value, String[] mimeTypes);
    [ExtensionAttribute]
public static DisplayedValue DisplayAs(string value, string mimeType);
    [ExtensionAttribute]
public static DisplayedValue DisplayTable(IEnumerable`1<T> value, String[] mimeTypes);
}
internal static class System.Runtime.CompilerServices.IsExternalInit : object {
}
