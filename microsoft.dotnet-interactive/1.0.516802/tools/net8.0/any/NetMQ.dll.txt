[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.AddressAlreadyInUseException : NetMQException {
    public AddressAlreadyInUseException(Exception innerException, string message);
    public AddressAlreadyInUseException(string message);
    [NullableContextAttribute("1")]
protected AddressAlreadyInUseException(SerializationInfo info, StreamingContext context);
}
internal static class NetMQ.Assumes : object {
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public static void NotNull(T o);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.AsyncReceiveExtensions : object {
    private static Task`1<bool> s_trueTask;
    private static Task`1<bool> s_falseTask;
    private static AsyncReceiveExtensions();
    [AsyncStateMachineAttribute("NetMQ.AsyncReceiveExtensions/<ReceiveMultipartMessageAsync>d__2")]
[ExtensionAttribute]
public static Task`1<NetMQMessage> ReceiveMultipartMessageAsync(NetMQSocket socket, int expectedFrameCount, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ValueTuple`2<Byte[], bool>> ReceiveFrameBytesAsync(NetMQSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ValueTuple`2<string, bool>> ReceiveFrameStringAsync(NetMQSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<ValueTuple`2<string, bool>> ReceiveFrameStringAsync(NetMQSocket socket, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static Task`1<bool> SkipFrameAsync(NetMQSocket socket, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("NetMQ.AsyncReceiveExtensions/<SkipMultipartMessageAsync>d__7")]
[ExtensionAttribute]
public static Task SkipMultipartMessageAsync(NetMQSocket socket);
    [AsyncStateMachineAttribute("NetMQ.AsyncReceiveExtensions/<ReceiveRoutingKeyAsync>d__8")]
[ExtensionAttribute]
public static Task`1<ValueTuple`2<RoutingKey, bool>> ReceiveRoutingKeyAsync(NetMQSocket socket);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NetMQ.AtomicCounterPool : object {
    private static IAtomicCounterPool s_counterPool;
    private static AtomicCounterPool();
    public static void SetGCCounterPool();
    public static void SetCustomCounterPool(IAtomicCounterPool counterPool);
    public static AtomicCounter Take();
    public static void Return(AtomicCounter counter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.BeaconMessage : ValueType {
    [CompilerGeneratedAttribute]
private Byte[] <Bytes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PeerAddress>k__BackingField;
    public Byte[] Bytes { get; }
    public string PeerAddress { get; }
    public string String { get; }
    public string PeerHost { get; }
    internal BeaconMessage(Byte[] bytes, string peerAddress);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Byte[] get_Bytes();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public string get_PeerAddress();
    public string get_String();
    public string get_PeerHost();
}
public class NetMQ.BufferManagerBufferPool : object {
    [NullableAttribute("1")]
private BufferManager m_bufferManager;
    public BufferManagerBufferPool(long maxBufferPoolSize, int maxBufferSize);
    [NullableContextAttribute("1")]
public sealed virtual Byte[] Take(int size);
    [NullableContextAttribute("1")]
public sealed virtual void Return(Byte[] buffer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NetMQ.BufferPool : object {
    private static IBufferPool s_bufferPool;
    private static BufferPool();
    public static void SetGCBufferPool();
    public static void SetBufferManagerBufferPool(long maxBufferPoolSize, int maxBufferSize);
    public static void SetCustomBufferPool(IBufferPool bufferPool);
    public static Byte[] Take(int size);
    public static void Return(Byte[] buffer);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Address : object {
    public static string InProcProtocol;
    public static string TcpProtocol;
    public static string IpcProtocol;
    public static string PgmProtocol;
    public static string EpgmProtocol;
    [CompilerGeneratedAttribute]
private string <Protocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AddressString>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IZAddress <Resolved>k__BackingField;
    public string Protocol { get; }
    public string AddressString { get; }
    [NullableAttribute("2")]
public IZAddress Resolved { get; public set; }
    public Address(string protocol, string address);
    public Address(EndPoint endpoint);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_Protocol();
    [CompilerGeneratedAttribute]
public string get_AddressString();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public IZAddress get_Resolved();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Resolved(IZAddress value);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NetMQ.Core.Command : ValueType {
    [CompilerGeneratedAttribute]
private ZObject <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandType <CommandType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Arg>k__BackingField;
    public ZObject Destination { get; }
    public CommandType CommandType { get; }
    public object Arg { get; }
    public Command(ZObject destination, CommandType type, object arg);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ZObject get_Destination();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CommandType get_CommandType();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public object get_Arg();
    [NullableContextAttribute("1")]
public virtual string ToString();
}
internal enum NetMQ.Core.CommandType : Enum {
    public int value__;
    public static CommandType None;
    public static CommandType Stop;
    public static CommandType Plug;
    public static CommandType Own;
    public static CommandType Attach;
    public static CommandType Bind;
    public static CommandType ActivateRead;
    public static CommandType ActivateWrite;
    public static CommandType Hiccup;
    public static CommandType PipeTerm;
    public static CommandType PipeTermAck;
    public static CommandType TermReq;
    public static CommandType Term;
    public static CommandType TermAck;
    public static CommandType Reap;
    public static CommandType Reaped;
    public static CommandType Done;
    public static CommandType ForceStop;
    public static CommandType CancellationRequested;
}
internal static class NetMQ.Core.Config : object {
    public static int MessagePipeGranularity;
    public static int CommandPipeGranularity;
    public static int InboundPollRate;
    public static int InBatchSize;
    public static int OutBatchSize;
    public static int MaxWatermarkDelta;
    public static int MaxIOEvents;
    public static int MaxCommandDelay;
    public static int ClockPrecision;
    public static int PgmMaxTPDU;
    public static int SignalerPort;
}
internal class NetMQ.Core.Ctx : object {
    internal static int DefaultIOThreads;
    internal static int DefaultMaxSockets;
    private List`1<SocketBase> m_sockets;
    private Stack`1<int> m_emptySlots;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_starting;
    private bool m_terminating;
    private object m_slotSync;
    private Reaper m_reaper;
    private List`1<IOThread> m_ioThreads;
    private int m_slotCount;
    private IMailbox[] m_slots;
    private Mailbox m_termMailbox;
    private Dictionary`2<string, Endpoint> m_endpoints;
    private object m_endpointsSync;
    private static int s_maxSocketId;
    private int m_maxSockets;
    private int m_ioThreadCount;
    private object m_optSync;
    public static int TermTid;
    public static int ReaperTid;
    public int IOThreadCount { get; public set; }
    public int MaxSockets { get; public set; }
    public void Terminate(bool block);
    public int get_IOThreadCount();
    public void set_IOThreadCount(int value);
    public int get_MaxSockets();
    public void set_MaxSockets(int value);
    public SocketBase CreateSocket(ZmqSocketType type);
    public void DestroySocket(SocketBase socket);
    public ZObject GetReaper();
    public void SendCommand(int threadId, Command command);
    public IOThread ChooseIOThread(long affinity);
    public bool RegisterEndpoint(string address, Endpoint endpoint);
    public bool UnregisterEndpoint(string address, SocketBase socket);
    public void UnregisterEndpoints(SocketBase socket);
    public Endpoint FindEndpoint(string addr);
}
[ExtensionAttribute]
internal static class NetMQ.Core.ErrorHelper : object {
    [ExtensionAttribute]
public static ErrorCode ToErrorCode(SocketError error);
}
internal class NetMQ.Core.HelloMsgSession : SessionBase {
    private bool m_newPipe;
    [NullableContextAttribute("1")]
public HelloMsgSession(IOThread ioThread, bool connect, SocketBase socket, Options options, Address addr);
    public virtual PullMsgResult PullMsg(Msg& msg);
    protected virtual void Reset();
}
internal interface NetMQ.Core.IMailbox {
    public abstract virtual void Send(Command command);
    public abstract virtual bool TryRecv(int timeout, Command& command);
    public abstract virtual void Close();
}
internal interface NetMQ.Core.IMailboxEvent {
    public abstract virtual void Ready();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.IOObject : object {
    [NullableAttribute("2")]
private IOThread m_ioThread;
    [NullableAttribute("2")]
private IProactorEvents m_handler;
    [NullableContextAttribute("2")]
public IOObject(IOThread ioThread);
    public void Plug(IOThread ioThread);
    public void Unplug();
    public void AddSocket(AsyncSocket socket);
    public void RemoveSocket(AsyncSocket socket);
    public virtual void InCompleted(SocketError socketError, int bytesTransferred);
    public virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    public virtual void TimerEvent(int id);
    public void AddTimer(long timeout, int id);
    public void SetHandler(IProactorEvents handler);
    public void CancelTimer(int id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.IOThread : ZObject {
    private IOThreadMailbox m_mailbox;
    private Proactor m_proactor;
    internal Proactor Proactor { get; }
    public IMailbox Mailbox { get; }
    public int Load { get; }
    public IOThread(Ctx ctx, int threadId);
    internal Proactor get_Proactor();
    public void Start();
    public void Destroy();
    public void Stop();
    public IMailbox get_Mailbox();
    public int get_Load();
    protected virtual void ProcessStop();
    public sealed virtual void Ready();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.IOThreadMailbox : object {
    private Proactor m_proactor;
    private IMailboxEvent m_mailboxEvent;
    private YPipe`1<Command> m_commandPipe;
    private object m_sync;
    private bool m_disposed;
    public IOThreadMailbox(string name, Proactor proactor, IMailboxEvent mailboxEvent);
    public sealed virtual void Send(Command command);
    public sealed virtual bool TryRecv(int timeout, Command& command);
    public bool TryRecv(Command& command);
    public void RaiseEvent();
    public sealed virtual void Close();
}
internal interface NetMQ.Core.IPollEvents {
    public abstract virtual void InEvent();
    public abstract virtual void OutEvent();
}
internal interface NetMQ.Core.IProactorEvents {
    public abstract virtual void InCompleted(SocketError socketError, int bytesTransferred);
    public abstract virtual void OutCompleted(SocketError socketError, int bytesTransferred);
}
internal interface NetMQ.Core.ITimerEvent {
    public abstract virtual void TimerEvent(int id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Mailbox : object {
    private YPipe`1<Command> m_commandPipe;
    private Signaler m_signaler;
    private object m_sync;
    private bool m_active;
    public Socket Handle { get; }
    public Mailbox(string name);
    public Socket get_Handle();
    public sealed virtual void Send(Command cmd);
    public sealed virtual bool TryRecv(int timeout, Command& command);
    public sealed virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.MailboxSafe : object {
    private YPipe`1<Command> m_commandPipe;
    private object m_sync;
    private List`1<Signaler> m_signalers;
    public MailboxSafe(string name, object sync);
    public void AddSignaler(Signaler signaler);
    public void RemoveSignaler(Signaler signaler);
    public void ClearSignalers();
    public sealed virtual void Send(Command cmd);
    public sealed virtual bool TryRecv(int timeout, Command& command);
    public sealed virtual void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Mechanisms.CurveClientMechanism : CurveMechanismBase {
    private Byte[] m_secretKey;
    private Byte[] m_publicKey;
    private Byte[] m_serverKey;
    private Byte[] m_cnSecretKey;
    private Byte[] m_cnPublicKey;
    [NullableAttribute("2")]
private Byte[] m_cnServerKey;
    [NullableAttribute("2")]
private Byte[] m_cnCookie;
    private State m_state;
    public MechanismStatus Status { get; }
    public CurveClientMechanism(SessionBase session, Options options);
    public virtual void Dispose();
    public virtual MechanismStatus get_Status();
    public virtual PullMsgResult NextHandshakeCommand(Msg& msg);
    public virtual PushMsgResult ProcessHandshakeCommand(Msg& msg);
    private PullMsgResult ProduceHello(Msg& msg);
    private PushMsgResult ProcessWelcome(Msg& msg);
    private PullMsgResult ProduceInitiate(Msg& msg);
    private PushMsgResult ProcessReady(Msg& msg);
    private PushMsgResult ProcessError(Msg& msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.Mechanisms.CurveMechanismBase : Mechanism {
    protected static Byte[] HelloNoncePrefix;
    protected static Byte[] CookieNoncePrefix;
    protected static Byte[] WelcomeNoncePrefix;
    protected static Byte[] InitiatieNoncePrefix;
    protected static Byte[] VouchNoncePrefix;
    protected static Byte[] ReadyNoncePrefix;
    protected static Byte[] WelcomeLiteral;
    protected static Byte[] ReadyLiteral;
    protected static Byte[] HelloLiteral;
    protected static Byte[] InitiateLiteral;
    private static Byte[] MessageLiteral;
    private Byte[] m_encodeNoncePrefix;
    private Byte[] m_decodeNoncePrefix;
    protected ulong m_nonce;
    protected ulong m_peerNonce;
    [NullableAttribute("2")]
protected Curve25519XSalsa20Poly1305 m_box;
    protected CurveMechanismBase(SessionBase session, Options options, string encodeNoncePrefix, string decodeNoncePrefix);
    private static CurveMechanismBase();
    public virtual void Dispose();
    public virtual PullMsgResult Encode(Msg& msg);
    public virtual PushMsgResult Decode(Msg& msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Mechanisms.CurveServerMechanism : CurveMechanismBase {
    private Byte[] m_secretKey;
    private Byte[] m_cnSecretKey;
    private Byte[] m_cnPublicKey;
    private Byte[] m_cnClientKey;
    private Byte[] m_cookieKey;
    private State m_state;
    public MechanismStatus Status { get; }
    public CurveServerMechanism(SessionBase session, Options options);
    public virtual void Dispose();
    public virtual MechanismStatus get_Status();
    public virtual PullMsgResult NextHandshakeCommand(Msg& msg);
    public virtual PushMsgResult ProcessHandshakeCommand(Msg& msg);
    private PushMsgResult ProcessHello(Msg& msg);
    private PullMsgResult ProduceWelcome(Msg& msg);
    private PushMsgResult ProcessInitiate(Msg& msg);
    private PullMsgResult ProduceReady(Msg& msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.Mechanisms.Mechanism : object {
    private static int NameLengthSize;
    private static int ValueLengthSize;
    private static string ZmtpPropertySocketType;
    private static string ZmtpPropertyIdentity;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <PeerIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionBase <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private Options <Options>k__BackingField;
    public MechanismStatus Status { get; }
    [NullableAttribute("2")]
public Byte[] PeerIdentity { get; public set; }
    public SessionBase Session { get; }
    protected Options Options { get; }
    protected int BasicPropertiesLength { get; }
    public Mechanism(SessionBase session, Options options);
    public abstract virtual PullMsgResult NextHandshakeCommand(Msg& msg);
    public abstract virtual PushMsgResult ProcessHandshakeCommand(Msg& msg);
    public abstract virtual void Dispose();
    public virtual PullMsgResult Encode(Msg& msg);
    public virtual PushMsgResult Decode(Msg& msg);
    public abstract virtual MechanismStatus get_Status();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_PeerIdentity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_PeerIdentity(Byte[] value);
    [CompilerGeneratedAttribute]
public SessionBase get_Session();
    [CompilerGeneratedAttribute]
protected Options get_Options();
    protected string GetSocketName(ZmqSocketType socketType);
    protected int AddProperty(Span`1<byte> output, string name, Byte[] value);
    protected int AddProperty(Span`1<byte> output, string name, string value);
    protected int GetPropertyLength(string name, int valueLength);
    [NullableContextAttribute("0")]
protected void AddBasicProperties(Span`1<byte> output);
    protected int get_BasicPropertiesLength();
    protected void MakeCommandWithBasicProperties(Msg& msg, string prefix);
    [NullableContextAttribute("0")]
protected bool ParseMetadata(Span`1<byte> source);
    protected virtual bool GetProperty(string name, Byte[] output, int size);
    private bool CheckSocketType(string type);
    protected bool CheckBasicCommandStructure(Msg& msg);
    protected bool IsCommand(string command, Msg& msg);
}
internal enum NetMQ.Core.Mechanisms.MechanismStatus : Enum {
    public int value__;
    public static MechanismStatus Handshaking;
    public static MechanismStatus Ready;
    public static MechanismStatus Error;
}
internal class NetMQ.Core.Mechanisms.NullMechanism : Mechanism {
    [NullableAttribute("1")]
private static string ReadyCommandName;
    [NullableAttribute("1")]
private static string ErrorCommandName;
    private static int ErrorReasonLengthSize;
    private bool m_readyCommandSent;
    private bool m_readyCommandReceived;
    private bool m_errorCommandReceived;
    public MechanismStatus Status { get; }
    [NullableContextAttribute("1")]
public NullMechanism(SessionBase session, Options options);
    public virtual void Dispose();
    public virtual MechanismStatus get_Status();
    private PushMsgResult ProcessReadyCommand(Span`1<byte> commandData);
    private PushMsgResult ProcessErrorCommand(Span`1<byte> commandData);
    public virtual PullMsgResult NextHandshakeCommand(Msg& msg);
    public virtual PushMsgResult ProcessHandshakeCommand(Msg& msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.MonitorEvent : object {
    private static int ValueInteger;
    private static int ValueChannel;
    private SocketEvents m_monitorEvent;
    private string m_addr;
    [NullableAttribute("2")]
private object m_arg;
    private int m_flag;
    private static int s_sizeOfIntPtr;
    public string Addr { get; }
    [NullableAttribute("2")]
public object Arg { get; }
    public SocketEvents Event { get; }
    private static MonitorEvent();
    public MonitorEvent(SocketEvents monitorEvent, string addr, ErrorCode arg);
    public MonitorEvent(SocketEvents monitorEvent, string addr, int arg);
    public MonitorEvent(SocketEvents monitorEvent, string addr, AsyncSocket arg);
    private MonitorEvent(SocketEvents monitorEvent, string addr, object arg);
    public string get_Addr();
    [NullableContextAttribute("2")]
public object get_Arg();
    public SocketEvents get_Event();
    public void Write(SocketBase s);
    public static MonitorEvent Read(SocketBase s);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NetMQ.Core.Options : object {
    [CompilerGeneratedAttribute]
private long <Affinity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Backlog>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DelayAttachOnConnect>k__BackingField;
    [CompilerGeneratedAttribute]
private Endianness <Endian>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <LastPeerRoutingId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IPv4Only>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LastEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Linger>k__BackingField;
    [CompilerGeneratedAttribute]
private long <MaxMessageSize>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MulticastHops>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RawSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RecvIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReconnectIvl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReconnectIvlMax>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RecoveryIvl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendHighWatermark>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveHighWatermark>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendLowWatermark>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReceiveLowWatermark>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SendTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SocketId>k__BackingField;
    [CompilerGeneratedAttribute]
private ZmqSocketType <SocketType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpKeepalive>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpKeepaliveCnt>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpKeepaliveIdle>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TcpKeepaliveIntvl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableTimeWait>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PgmMaxTransportServiceDataUnitLength>k__BackingField;
    [CompilerGeneratedAttribute]
private MechanismType <Mechanism>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AsServer>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Byte[] <CurvePublicKey>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Byte[] <CurveSecretKey>k__BackingField;
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private Byte[] <CurveServerKey>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeartbeatTtl>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeartbeatInterval>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HeartbeatTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <HelloMsg>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CanSendHelloMsg>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Correlate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Relaxed>k__BackingField;
    public long Affinity { get; public set; }
    public int Backlog { get; public set; }
    public bool DelayAttachOnConnect { get; public set; }
    public Endianness Endian { get; public set; }
    public bool Filter { get; public set; }
    public Byte[] Identity { get; public set; }
    public byte IdentitySize { get; }
    public Byte[] LastPeerRoutingId { get; public set; }
    public bool IPv4Only { get; public set; }
    public string LastEndpoint { get; public set; }
    public int Linger { get; public set; }
    public long MaxMessageSize { get; public set; }
    public int MulticastHops { get; public set; }
    public int Rate { get; public set; }
    public bool RawSocket { get; public set; }
    public bool RecvIdentity { get; public set; }
    public int ReconnectIvl { get; public set; }
    public int ReconnectIvlMax { get; public set; }
    public int RecoveryIvl { get; public set; }
    public int SendBuffer { get; public set; }
    public int ReceiveBuffer { get; public set; }
    public int SendHighWatermark { get; public set; }
    public int ReceiveHighWatermark { get; public set; }
    public int SendLowWatermark { get; public set; }
    public int ReceiveLowWatermark { get; public set; }
    public int SendTimeout { get; public set; }
    public int SocketId { get; public set; }
    public ZmqSocketType SocketType { get; public set; }
    public int TcpKeepalive { get; public set; }
    public int TcpKeepaliveCnt { get; public set; }
    public int TcpKeepaliveIdle { get; public set; }
    public int TcpKeepaliveIntvl { get; public set; }
    public bool DisableTimeWait { get; public set; }
    public int PgmMaxTransportServiceDataUnitLength { get; public set; }
    public MechanismType Mechanism { get; public set; }
    public bool AsServer { get; public set; }
    [NullableAttribute("1")]
public Byte[] CurvePublicKey { get; public set; }
    [NullableAttribute("1")]
public Byte[] CurveSecretKey { get; public set; }
    [NullableAttribute("1")]
public Byte[] CurveServerKey { get; public set; }
    public int HeartbeatTtl { get; public set; }
    public int HeartbeatInterval { get; public set; }
    public int HeartbeatTimeout { get; public set; }
    public Byte[] HelloMsg { get; public set; }
    public bool CanSendHelloMsg { get; public set; }
    public bool Correlate { get; public set; }
    public bool Relaxed { get; public set; }
    [CompilerGeneratedAttribute]
public long get_Affinity();
    [CompilerGeneratedAttribute]
public void set_Affinity(long value);
    [CompilerGeneratedAttribute]
public int get_Backlog();
    [CompilerGeneratedAttribute]
public void set_Backlog(int value);
    [CompilerGeneratedAttribute]
public bool get_DelayAttachOnConnect();
    [CompilerGeneratedAttribute]
public void set_DelayAttachOnConnect(bool value);
    [CompilerGeneratedAttribute]
public Endianness get_Endian();
    [CompilerGeneratedAttribute]
public void set_Endian(Endianness value);
    [CompilerGeneratedAttribute]
public bool get_Filter();
    [CompilerGeneratedAttribute]
public void set_Filter(bool value);
    [CompilerGeneratedAttribute]
public Byte[] get_Identity();
    [CompilerGeneratedAttribute]
public void set_Identity(Byte[] value);
    public byte get_IdentitySize();
    [CompilerGeneratedAttribute]
public Byte[] get_LastPeerRoutingId();
    [CompilerGeneratedAttribute]
public void set_LastPeerRoutingId(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_IPv4Only();
    [CompilerGeneratedAttribute]
public void set_IPv4Only(bool value);
    [CompilerGeneratedAttribute]
public string get_LastEndpoint();
    [CompilerGeneratedAttribute]
public void set_LastEndpoint(string value);
    [CompilerGeneratedAttribute]
public int get_Linger();
    [CompilerGeneratedAttribute]
public void set_Linger(int value);
    [CompilerGeneratedAttribute]
public long get_MaxMessageSize();
    [CompilerGeneratedAttribute]
public void set_MaxMessageSize(long value);
    [CompilerGeneratedAttribute]
public int get_MulticastHops();
    [CompilerGeneratedAttribute]
public void set_MulticastHops(int value);
    [CompilerGeneratedAttribute]
public int get_Rate();
    [CompilerGeneratedAttribute]
public void set_Rate(int value);
    [CompilerGeneratedAttribute]
public bool get_RawSocket();
    [CompilerGeneratedAttribute]
public void set_RawSocket(bool value);
    [CompilerGeneratedAttribute]
public bool get_RecvIdentity();
    [CompilerGeneratedAttribute]
public void set_RecvIdentity(bool value);
    [CompilerGeneratedAttribute]
public int get_ReconnectIvl();
    [CompilerGeneratedAttribute]
public void set_ReconnectIvl(int value);
    [CompilerGeneratedAttribute]
public int get_ReconnectIvlMax();
    [CompilerGeneratedAttribute]
public void set_ReconnectIvlMax(int value);
    [CompilerGeneratedAttribute]
public int get_RecoveryIvl();
    [CompilerGeneratedAttribute]
public void set_RecoveryIvl(int value);
    [CompilerGeneratedAttribute]
public int get_SendBuffer();
    [CompilerGeneratedAttribute]
public void set_SendBuffer(int value);
    [CompilerGeneratedAttribute]
public int get_ReceiveBuffer();
    [CompilerGeneratedAttribute]
public void set_ReceiveBuffer(int value);
    [CompilerGeneratedAttribute]
public int get_SendHighWatermark();
    [CompilerGeneratedAttribute]
public void set_SendHighWatermark(int value);
    [CompilerGeneratedAttribute]
public int get_ReceiveHighWatermark();
    [CompilerGeneratedAttribute]
public void set_ReceiveHighWatermark(int value);
    [CompilerGeneratedAttribute]
public int get_SendLowWatermark();
    [CompilerGeneratedAttribute]
public void set_SendLowWatermark(int value);
    [CompilerGeneratedAttribute]
public int get_ReceiveLowWatermark();
    [CompilerGeneratedAttribute]
public void set_ReceiveLowWatermark(int value);
    [CompilerGeneratedAttribute]
public int get_SendTimeout();
    [CompilerGeneratedAttribute]
public void set_SendTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_SocketId();
    [CompilerGeneratedAttribute]
public void set_SocketId(int value);
    [CompilerGeneratedAttribute]
public ZmqSocketType get_SocketType();
    [CompilerGeneratedAttribute]
public void set_SocketType(ZmqSocketType value);
    [CompilerGeneratedAttribute]
public int get_TcpKeepalive();
    [CompilerGeneratedAttribute]
public void set_TcpKeepalive(int value);
    [CompilerGeneratedAttribute]
public int get_TcpKeepaliveCnt();
    [CompilerGeneratedAttribute]
public void set_TcpKeepaliveCnt(int value);
    [CompilerGeneratedAttribute]
public int get_TcpKeepaliveIdle();
    [CompilerGeneratedAttribute]
public void set_TcpKeepaliveIdle(int value);
    [CompilerGeneratedAttribute]
public int get_TcpKeepaliveIntvl();
    [CompilerGeneratedAttribute]
public void set_TcpKeepaliveIntvl(int value);
    [CompilerGeneratedAttribute]
public bool get_DisableTimeWait();
    [CompilerGeneratedAttribute]
public void set_DisableTimeWait(bool value);
    [CompilerGeneratedAttribute]
public int get_PgmMaxTransportServiceDataUnitLength();
    [CompilerGeneratedAttribute]
public void set_PgmMaxTransportServiceDataUnitLength(int value);
    [CompilerGeneratedAttribute]
public MechanismType get_Mechanism();
    [CompilerGeneratedAttribute]
public void set_Mechanism(MechanismType value);
    [CompilerGeneratedAttribute]
public bool get_AsServer();
    [CompilerGeneratedAttribute]
public void set_AsServer(bool value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Byte[] get_CurvePublicKey();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_CurvePublicKey(Byte[] value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Byte[] get_CurveSecretKey();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_CurveSecretKey(Byte[] value);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public Byte[] get_CurveServerKey();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public void set_CurveServerKey(Byte[] value);
    [CompilerGeneratedAttribute]
public int get_HeartbeatTtl();
    [CompilerGeneratedAttribute]
public void set_HeartbeatTtl(int value);
    [CompilerGeneratedAttribute]
public int get_HeartbeatInterval();
    [CompilerGeneratedAttribute]
public void set_HeartbeatInterval(int value);
    [CompilerGeneratedAttribute]
public int get_HeartbeatTimeout();
    [CompilerGeneratedAttribute]
public void set_HeartbeatTimeout(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_HelloMsg();
    [CompilerGeneratedAttribute]
public void set_HelloMsg(Byte[] value);
    [CompilerGeneratedAttribute]
public bool get_CanSendHelloMsg();
    [CompilerGeneratedAttribute]
public void set_CanSendHelloMsg(bool value);
    [CompilerGeneratedAttribute]
public bool get_Correlate();
    [CompilerGeneratedAttribute]
public void set_Correlate(bool value);
    [CompilerGeneratedAttribute]
public bool get_Relaxed();
    [CompilerGeneratedAttribute]
public void set_Relaxed(bool value);
    public void SetSocketOption(ZmqSocketOption option, object optionValue);
    public object GetSocketOption(ZmqSocketOption option);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <SetSocketOption>g__Get|183_0(<>c__DisplayClass183_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.Own : ZObject {
    protected Options m_options;
    private bool m_terminating;
    private long m_sentSeqnum;
    private long m_processedSeqnum;
    [NullableAttribute("2")]
private Own m_owner;
    private HashSet`1<Own> m_owned;
    private int m_termAcks;
    protected bool IsTerminating { get; }
    protected Own(Ctx parent, int threadId);
    protected Own(IOThread ioThread, Options options);
    public abstract virtual void Destroy();
    protected virtual void ProcessDestroy();
    private void SetOwner(Own owner);
    public void IncSeqnum();
    protected virtual void ProcessSeqnum();
    protected void LaunchChild(Own obj);
    protected void TermChild(Own obj);
    protected virtual void ProcessTermReq(Own obj);
    protected virtual void ProcessOwn(Own obj);
    protected void Terminate();
    protected bool get_IsTerminating();
    protected virtual void ProcessTerm(int linger);
    protected void RegisterTermAcks(int count);
    protected void UnregisterTermAck();
    protected virtual void ProcessTermAck();
    private void CheckTermAcks();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Client : SocketBase {
    private FairQueueing m_fairQueueing;
    private LoadBalancer m_loadBalancer;
    public Client(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Dealer : SocketBase {
    private FairQueueing m_fairQueueing;
    private LoadBalancer m_loadBalancer;
    public Dealer(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual bool XSend(Msg& msg);
    [NullableContextAttribute("2")]
protected bool XSendPipe(Msg& msg, Pipe& pipe);
    protected virtual bool XRecv(Msg& msg);
    [NullableContextAttribute("2")]
protected bool XRecvPipe(Msg& msg, Pipe& pipe);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Dish : SocketBase {
    private FairQueueing m_fairQueueing;
    private Distribution m_distribution;
    private HashSet`1<string> m_subscriptions;
    private bool m_hasMessage;
    private Msg m_message;
    public Dish(Ctx parent, int threadId, int socketId);
    public virtual void Destroy();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XHiccuped(Pipe pipe);
    protected virtual void XJoin(string group);
    protected virtual void XLeave(string group);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
    protected virtual bool XRecv(Msg& msg);
    private bool XXRecv(Msg& msg);
    protected virtual bool XHasIn();
    private void SendSubscriptions(Pipe pipe);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Gather : SocketBase {
    private FairQueueing m_fairQueueing;
    public Gather(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Pair : SocketBase {
    [NullableAttribute("2")]
private Pipe m_pipe;
    public Pair(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Peer : SocketBase {
    private static Random s_random;
    private FairQueueing m_fairQueueing;
    private Msg m_prefetchedMsg;
    private Dictionary`2<UInt32, Outpipe> m_outpipes;
    [NullableAttribute("2")]
private Pipe m_currentOut;
    private State m_receivingState;
    private State m_sendingState;
    private UInt32 m_nextPeerId;
    public Peer(Ctx parent, int threadId, int socketId);
    private static Peer();
    public virtual void Destroy();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Pub : XPub {
    public Pub(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Pull : SocketBase {
    private FairQueueing m_fairQueueing;
    public Pull(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Push : SocketBase {
    private LoadBalancer m_loadBalancer;
    public Push(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Radio : SocketBase {
    private Dictionary`2<string, HashSet`1<Pipe>> m_subscriptions;
    private Distribution m_distribution;
    internal Radio(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
}
internal class NetMQ.Core.Patterns.Rep : Router {
    private bool m_sendingReply;
    private bool m_requestBegins;
    [NullableContextAttribute("1")]
public Rep(Ctx parent, int threadId, int socketId);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
}
internal class NetMQ.Core.Patterns.Req : Dealer {
    private bool m_receivingReply;
    private bool m_messageBegins;
    private bool m_strict;
    private bool m_request_id_frames_enabled;
    private UInt32 m_request_id;
    [NullableAttribute("2")]
private Pipe m_replyPipe;
    [NullableContextAttribute("1")]
public Req(Ctx parent, int threadId, int socketId);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    private Msg SkipRemainingFrames(Msg msg);
    private bool RecvFromReplyPipe(Msg& msg);
    [NullableContextAttribute("1")]
protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
    [NullableContextAttribute("2")]
protected virtual bool XSetSocketOption(ZmqSocketOption option, object optionValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Router : SocketBase {
    private static Random s_random;
    private FairQueueing m_fairQueueing;
    private bool m_prefetched;
    private bool m_identitySent;
    private Msg m_prefetchedId;
    private Msg m_prefetchedMsg;
    private bool m_moreIn;
    private HashSet`1<Pipe> m_anonymousPipes;
    private Dictionary`2<Byte[], Outpipe> m_outpipes;
    [NullableAttribute("2")]
private Pipe m_currentOut;
    [NullableAttribute("2")]
private Pipe m_currentIn;
    private bool m_closingCurrentIn;
    private bool m_moreOut;
    private int m_nextPeerId;
    private bool m_mandatory;
    private bool m_rawSocket;
    private bool m_handover;
    public Router(Ctx parent, int threadId, int socketId);
    private static Router();
    public virtual void Destroy();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    [NullableContextAttribute("2")]
protected virtual bool XSetSocketOption(ZmqSocketOption option, object optval);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected void Rollback();
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
    private bool IdentifyPeer(Pipe pipe);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <XSetSocketOption>g__Get|21_0(<>c__DisplayClass21_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Scatter : SocketBase {
    private LoadBalancer m_loadBalancer;
    public Scatter(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Server : SocketBase {
    private static Random s_random;
    private FairQueueing m_fairQueueing;
    private Dictionary`2<UInt32, Outpipe> m_outpipes;
    private UInt32 m_nextRoutingId;
    public Server(Ctx parent, int threadId, int socketId);
    private static Server();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Stream : SocketBase {
    private static Random s_random;
    private FairQueueing m_fairQueueing;
    private bool m_prefetched;
    private bool m_identitySent;
    private Msg m_prefetchedId;
    private Msg m_prefetchedMsg;
    private Dictionary`2<Byte[], Outpipe> m_outpipes;
    [NullableAttribute("2")]
private Pipe m_currentOut;
    private bool m_moreOut;
    private int m_nextPeerId;
    public Stream(Ctx parent, int threadId, int socketId);
    private static Stream();
    public virtual void Destroy();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XHasOut();
    private void IdentifyPeer(Pipe pipe);
}
internal class NetMQ.Core.Patterns.Sub : XSub {
    [NullableContextAttribute("1")]
public Sub(Ctx parent, int threadId, int socketId);
    [NullableContextAttribute("2")]
protected virtual bool XSetSocketOption(ZmqSocketOption option, object optionValue);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NetMQ.Core.Patterns.Utils.ArrayExtensions : object {
    [ExtensionAttribute]
public static T[] Resize(T[] src, int size, bool ended);
    [ExtensionAttribute]
public static void Swap(List`1<T> items, int index1, int index2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Utils.Distribution : object {
    private List`1<Pipe> m_pipes;
    private int m_matching;
    private int m_active;
    private int m_eligible;
    private bool m_more;
    public void Attach(Pipe pipe);
    public void Match(Pipe pipe);
    public void Unmatch();
    public void Terminated(Pipe pipe);
    public void Activated(Pipe pipe);
    public void SendToAll(Msg& msg);
    public void SendToMatching(Msg& msg);
    private void Distribute(Msg& msg);
    public bool HasOut();
    private bool Write(Pipe pipe, Msg& msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Utils.FairQueueing : object {
    private List`1<Pipe> m_pipes;
    private int m_active;
    private int m_current;
    private bool m_more;
    public void Attach(Pipe pipe);
    public void Terminated(Pipe pipe);
    public void Activated(Pipe pipe);
    public bool Recv(Msg& msg);
    [NullableContextAttribute("2")]
public bool RecvPipe(Msg& msg, Pipe& pipe);
    public bool HasIn();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.Utils.LoadBalancer : object {
    private List`1<Pipe> m_pipes;
    private int m_active;
    private int m_current;
    private bool m_more;
    private bool m_dropping;
    public void Attach(Pipe pipe);
    public void Terminated(Pipe pipe);
    public void Activated(Pipe pipe);
    public bool Send(Msg& msg);
    [NullableContextAttribute("2")]
public bool SendPipe(Msg& msg, Pipe& pipe);
    public bool HasOut();
}
internal class NetMQ.Core.Patterns.Utils.MultiTrie : object {
    private HashSet`1<Pipe> m_pipes;
    private int m_minCharacter;
    private int m_count;
    private int m_liveNodes;
    private MultiTrie[] m_next;
    private bool IsRedundant { get; }
    public bool Add(Span`1<byte> prefix, Pipe pipe);
    private bool AddHelper(Span`1<byte> prefix, Pipe pipe);
    public bool RemoveHelper(Pipe pipe, MultiTrieDelegate func, object arg);
    private bool RemoveHelper(Pipe pipe, Byte[] buffer, int bufferSize, int maxBufferSize, MultiTrieDelegate func, object arg);
    public bool Remove(Span`1<byte> prefix, Pipe pipe);
    private bool RemoveHelper(Span`1<byte> prefix, Pipe pipe);
    public void Match(Span`1<byte> data, MultiTrieDelegate func, object arg);
    private bool get_IsRedundant();
}
internal class NetMQ.Core.Patterns.Utils.Trie : object {
    private int m_referenceCount;
    private byte m_minCharacter;
    private short m_count;
    private short m_liveNodes;
    private Trie[] m_next;
    public bool Add(Span`1<byte> prefix);
    public bool Remove(Span`1<byte> prefix);
    public bool Check(Span`1<byte> data);
    public void Apply(TrieDelegate func, object arg);
    private void ApplyHelper(Byte[] buffer, int bufferSize, int maxBufferSize, TrieDelegate func, object arg);
    private bool IsRedundant();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.XPub : SocketBase {
    private MultiTrie m_subscriptions;
    private Distribution m_distribution;
    private bool m_verbose;
    private bool m_manual;
    private bool m_broadcastEnabled;
    [NullableAttribute("2")]
private Pipe m_lastPipe;
    private bool m_lastPipeIsBroadcast;
    private Msg m_welcomeMessage;
    private bool m_moreOut;
    private bool m_moreIn;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Queue`1<KeyValuePair`2<Msg, Pipe>> m_pendingMessages;
    private static MultiTrieDelegate s_markAsMatching;
    private static MultiTrieDelegate s_sendUnsubscription;
    private static XPub();
    public XPub(Ctx parent, int threadId, int socketId);
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    [NullableContextAttribute("2")]
protected virtual bool XSetSocketOption(ZmqSocketOption option, object optionValue);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <XSetSocketOption>g__Get|18_0(<>c__DisplayClass18_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Patterns.XSub : SocketBase {
    private FairQueueing m_fairQueueing;
    private Distribution m_distribution;
    private Trie m_subscriptions;
    private bool m_hasMessage;
    private Msg m_message;
    private bool m_moreIn;
    private bool m_moreOut;
    private static TrieDelegate s_sendSubscription;
    private static XSub();
    public XSub(Ctx parent, int threadId, int socketId);
    public virtual void Destroy();
    protected virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XTerminated(Pipe pipe);
    protected virtual void XHiccuped(Pipe pipe);
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasOut();
    protected virtual bool XRecv(Msg& msg);
    protected virtual bool XHasIn();
    private bool Match(Msg msg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Pipe : ZObject {
    [NullableAttribute("2")]
private YPipe`1<Msg> m_inboundPipe;
    [NullableAttribute("2")]
private YPipe`1<Msg> m_outboundPipe;
    private bool m_inActive;
    private bool m_outActive;
    private int m_highWatermark;
    private int m_lowWatermark;
    private long m_numberOfMessagesRead;
    private long m_numberOfMessagesWritten;
    private long m_peersMsgsRead;
    [NullableAttribute("2")]
private Pipe m_peer;
    [NullableAttribute("2")]
private IPipeEvents m_sink;
    private State m_state;
    private bool m_delay;
    private ZObject m_parent;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RoutingId>k__BackingField;
    public bool Active { get; }
    [NullableAttribute("2")]
public Byte[] Identity { get; public set; }
    public UInt32 RoutingId { get; public set; }
    private Pipe(ZObject parent, YPipe`1<Msg> inboundPipe, YPipe`1<Msg> outboundPipe, int inHighWatermark, int outHighWatermark, int predefinedLowWatermark);
    public static Pipe[] PipePair(ZObject[] parents, Int32[] highWaterMarks, Int32[] lowWaterMarks);
    public bool get_Active();
    public void SetNoDelay();
    private void SetPeer(Pipe peer);
    public void SetEventSink(IPipeEvents sink);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_Identity();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_Identity(Byte[] value);
    [CompilerGeneratedAttribute]
public UInt32 get_RoutingId();
    [CompilerGeneratedAttribute]
public void set_RoutingId(UInt32 value);
    public bool CheckRead();
    public bool Read(Msg& msg);
    public bool CheckWrite();
    public bool Write(Msg& msg);
    public void Rollback();
    public void Flush();
    protected virtual void ProcessActivateRead();
    protected virtual void ProcessActivateWrite(long msgsRead);
    protected virtual void ProcessHiccup(object pipe);
    protected virtual void ProcessPipeTerm();
    protected virtual void ProcessPipeTermAck();
    public void Terminate(bool delay);
    private static int ComputeLowWatermark(int highWatermark, int predefinedLowWatermark);
    private void Delimit();
    public void Hiccup();
    public virtual string ToString();
}
internal enum NetMQ.Core.PullMsgResult : Enum {
    public int value__;
    public static PullMsgResult Ok;
    public static PullMsgResult Empty;
    public static PullMsgResult Error;
}
internal enum NetMQ.Core.PushMsgResult : Enum {
    public int value__;
    public static PushMsgResult Ok;
    public static PushMsgResult Full;
    public static PushMsgResult Error;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Reaper : ZObject {
    private Mailbox m_mailbox;
    private Socket m_mailboxHandle;
    private Poller m_poller;
    private int m_sockets;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_terminating;
    public Mailbox Mailbox { get; }
    public Reaper(Ctx ctx, int threadId);
    public void Destroy();
    public Mailbox get_Mailbox();
    public void Start();
    public void Stop();
    public void ForceStop();
    public sealed virtual void InEvent();
    public sealed virtual void OutEvent();
    public sealed virtual void TimerEvent(int id);
    protected virtual void ProcessStop();
    protected virtual void ProcessForceStop();
    protected virtual void ProcessReap(SocketBase socket);
    protected virtual void ProcessReaped();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.SessionBase : Own {
    private bool m_connect;
    [NullableAttribute("2")]
private Pipe m_pipe;
    private HashSet`1<Pipe> m_terminatingPipes;
    private bool m_incompleteIn;
    private bool m_pending;
    [NullableAttribute("2")]
private IEngine m_engine;
    private SocketBase m_socket;
    private IOThread m_ioThread;
    private static int LingerTimerId;
    private bool m_hasLingerTimer;
    private Address m_addr;
    private IOObject m_ioObject;
    public SocketBase Socket { get; }
    public SessionBase(IOThread ioThread, bool connect, SocketBase socket, Options options, Address addr);
    public static SessionBase Create(IOThread ioThread, bool connect, SocketBase socket, Options options, Address addr);
    public virtual void Destroy();
    public void AttachPipe(Pipe pipe);
    public virtual PullMsgResult PullMsg(Msg& msg);
    public virtual PushMsgResult PushMsg(Msg& msg);
    protected virtual void Reset();
    public void Flush();
    private void CleanPipes();
    public sealed virtual void Terminated(Pipe pipe);
    public sealed virtual void ReadActivated(Pipe pipe);
    public sealed virtual void WriteActivated(Pipe pipe);
    public sealed virtual void Hiccuped(Pipe pipe);
    public SocketBase get_Socket();
    protected virtual void ProcessPlug();
    protected virtual void ProcessAttach(IEngine engine);
    public void Detach();
    protected virtual void ProcessTerm(int linger);
    private void ProceedWithTerm();
    public sealed virtual void TimerEvent(int id);
    private void Detached();
    private void StartConnecting(bool wait);
    public virtual string ToString();
    public virtual void InCompleted(SocketError socketError, int bytesTransferred);
    public virtual void OutCompleted(SocketError socketError, int bytesTransferred);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.SocketBase : Own {
    private Dictionary`2<string, Endpoint> m_endpoints;
    private Dictionary`2<string, Pipe> m_inprocs;
    private bool m_disposed;
    private bool m_isStopped;
    private bool m_destroyed;
    private IMailbox m_mailbox;
    private List`1<Pipe> m_pipes;
    [NullableAttribute("2")]
private Poller m_poller;
    [NullableAttribute("2")]
private Socket m_handle;
    private long m_lastTsc;
    private int m_ticks;
    private bool m_rcvMore;
    [NullableAttribute("2")]
private SocketBase m_monitorSocket;
    private SocketEvents m_monitorEvents;
    private int m_port;
    private bool m_threadSafe;
    private object m_threadSafeSync;
    [NullableAttribute("2")]
private Signaler m_reaperSignaler;
    public IMailbox Mailbox { get; }
    public Socket Handle { get; }
    protected SocketBase(Ctx parent, int threadId, int socketId, bool threadSafe);
    protected abstract virtual void XAttachPipe(Pipe pipe, bool icanhasall);
    protected abstract virtual void XTerminated(Pipe pipe);
    public void CheckDisposed();
    private void CheckContextTerminated();
    public static SocketBase Create(ZmqSocketType type, Ctx parent, int threadId, int socketId);
    public virtual void Destroy();
    public IMailbox get_Mailbox();
    public void Stop();
    private void CheckProtocol(string protocol);
    private void AttachPipe(Pipe pipe, bool icanhasall);
    [NullableContextAttribute("2")]
public void SetSocketOption(ZmqSocketOption option, object optionValue);
    public int GetSocketOption(ZmqSocketOption option);
    [NullableContextAttribute("2")]
public object GetSocketOptionX(ZmqSocketOption option);
    public void Join(string group);
    public void Leave(string group);
    public void Bind(string addr);
    public int BindRandomPort(string addr);
    public void Connect(string addr);
    private static void DecodeAddress(string addr, String& address, String& protocol);
    private void AddEndpoint(string address, Own endpoint, Pipe pipe);
    public void TermEndpoint(string addr);
    public bool TrySend(Msg& msg, TimeSpan timeout, bool more);
    public bool TryRecv(Msg& msg, TimeSpan timeout, CancellationToken cancellationToken);
    public void Close();
    public bool HasIn();
    public bool HasOut();
    internal void StartReaping(Poller poller);
    private void ProcessCommands(int timeout, bool throttle, CancellationToken cancellationToken);
    protected virtual void ProcessStop();
    protected virtual void ProcessBind(Pipe pipe);
    protected virtual void ProcessTerm(int linger);
    protected virtual void ProcessDestroy();
    [NullableContextAttribute("2")]
protected virtual bool XSetSocketOption(ZmqSocketOption option, object optionValue);
    protected virtual bool XHasOut();
    protected virtual bool XSend(Msg& msg);
    protected virtual bool XHasIn();
    protected virtual bool XRecv(Msg& msg);
    protected virtual void XReadActivated(Pipe pipe);
    protected virtual void XWriteActivated(Pipe pipe);
    protected virtual void XHiccuped(Pipe pipe);
    protected virtual void XJoin(string group);
    protected virtual void XLeave(string group);
    public virtual void InEvent();
    public virtual void OutEvent();
    public virtual void TimerEvent(int id);
    private void CheckDestroy();
    public sealed virtual void ReadActivated(Pipe pipe);
    public sealed virtual void WriteActivated(Pipe pipe);
    public sealed virtual void Hiccuped(Pipe pipe);
    public sealed virtual void Terminated(Pipe pipe);
    private void ExtractFlags(Msg& msg);
    [NullableContextAttribute("2")]
public void Monitor(string addr, SocketEvents events);
    public void EventConnected(string addr, AsyncSocket ch);
    public void EventConnectDelayed(string addr, ErrorCode errno);
    public void EventConnectRetried(string addr, int interval);
    public void EventListening(string addr, AsyncSocket ch);
    public void EventBindFailed(string addr, ErrorCode errno);
    public void EventAccepted(string addr, AsyncSocket ch);
    public void EventAcceptFailed(string addr, ErrorCode errno);
    public void EventClosed(string addr, AsyncSocket ch);
    public void EventCloseFailed(string addr, ErrorCode errno);
    public void EventDisconnected(string addr, AsyncSocket ch);
    private void MonitorEvent(MonitorEvent monitorEvent);
    private void StopMonitor();
    internal void Lock();
    internal void Unlock();
    public virtual string ToString();
    public Socket get_Handle();
    public string GetTypeString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
internal class NetMQ.Core.Transports.ByteArraySegment : object {
    private Byte[] m_innerBuffer;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public int Size { get; }
    public int Offset { get; private set; }
    public byte Item { get; public set; }
    public ByteArraySegment(Byte[] buffer);
    public ByteArraySegment(Byte[] buffer, int offset);
    public ByteArraySegment(ByteArraySegment otherSegment);
    public ByteArraySegment(ByteArraySegment otherSegment, int offset);
    public int get_Size();
    public void AdvanceOffset(int delta);
    [CompilerGeneratedAttribute]
public int get_Offset();
    [CompilerGeneratedAttribute]
private void set_Offset(int value);
    public void PutLong(Endianness endian, long value, int i);
    public void PutUnsignedShort(Endianness endian, ushort value, int i);
    public void PutInteger(Endianness endian, int value, int i);
    public void PutString(string s, int length, int i);
    public void PutBytes(Byte[] bytes, int i);
    public void PutString(string s, int i);
    public long GetLong(Endianness endian, int i);
    public ulong GetUnsignedLong(Endianness endian, int i);
    public int GetInteger(Endianness endian, int i);
    public ushort GetUnsignedShort(Endianness endian, int i);
    public string GetString(int length, int i);
    public void CopyTo(ByteArraySegment otherSegment, int toCopy);
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<byte> span, int count);
    public void CopyTo(int fromOffset, ByteArraySegment dest, int destOffset, int toCopy);
    public ByteArraySegment Clone();
    public byte get_Item(int i);
    public void set_Item(int i, byte value);
    public void Reset();
    public static ByteArraySegment op_Addition(ByteArraySegment byteArray, int offset);
    public static ByteArraySegment op_Implicit(Byte[] buffer);
    public static Byte[] op_Explicit(ByteArraySegment buffer);
    public virtual bool Equals(object otherObject);
    public virtual int GetHashCode();
    public void Fill(byte value, int offset, int count);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.Transports.DecoderBase : object {
    [NullableAttribute("2")]
private ByteArraySegment m_readPos;
    protected int m_toRead;
    private int m_bufsize;
    private Byte[] m_buf;
    [CompilerGeneratedAttribute]
private Endianness <Endian>k__BackingField;
    [CompilerGeneratedAttribute]
private int <State>k__BackingField;
    public Endianness Endian { get; }
    protected int State { get; protected set; }
    public DecoderBase(int bufsize, Endianness endian);
    [CompilerGeneratedAttribute]
public Endianness get_Endian();
    public virtual void GetBuffer(ByteArraySegment& data, Int32& size);
    public virtual DecodeResult Decode(ByteArraySegment data, int size, Int32& bytesUsed);
    protected void NextStep(ByteArraySegment readPos, int toRead, int state);
    [CompilerGeneratedAttribute]
protected int get_State();
    [CompilerGeneratedAttribute]
protected void set_State(int value);
    public abstract virtual PushMsgResult PushMsg(ProcessMsgDelegate sink);
    protected abstract virtual DecodeResult Next();
}
internal enum NetMQ.Core.Transports.DecodeResult : Enum {
    public int value__;
    public static DecodeResult Error;
    public static DecodeResult Processing;
    public static DecodeResult MessageReady;
}
internal abstract class NetMQ.Core.Transports.EncoderBase : object {
    [NullableAttribute("2")]
private ByteArraySegment m_writePos;
    private bool m_newMsgFlag;
    private int m_toWrite;
    [NullableAttribute("1")]
private Byte[] m_buffer;
    private int m_bufferSize;
    protected Msg m_inProgress;
    private bool m_hasMessage;
    [CompilerGeneratedAttribute]
private Endianness <Endian>k__BackingField;
    [CompilerGeneratedAttribute]
private int <State>k__BackingField;
    public Endianness Endian { get; }
    protected int State { get; private set; }
    protected EncoderBase(int bufferSize, Endianness endian);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public Endianness get_Endian();
    [NullableContextAttribute("2")]
public sealed virtual int Encode(ByteArraySegment& data, int size);
    public sealed virtual void LoadMsg(Msg& msg);
    [CompilerGeneratedAttribute]
protected int get_State();
    [CompilerGeneratedAttribute]
private void set_State(int value);
    protected abstract virtual void Next();
    [NullableContextAttribute("2")]
protected void NextStep(ByteArraySegment writePos, int toWrite, int state, bool newMsgFlag);
}
[NullableContextAttribute("1")]
internal interface NetMQ.Core.Transports.IDecoder {
    public abstract virtual void GetBuffer(ByteArraySegment& data, Int32& size);
    public abstract virtual DecodeResult Decode(ByteArraySegment data, int size, Int32& processed);
    public abstract virtual PushMsgResult PushMsg(ProcessMsgDelegate sink);
}
internal interface NetMQ.Core.Transports.IEncoder {
    [NullableContextAttribute("2")]
public abstract virtual int Encode(ByteArraySegment& data, int size);
    public abstract virtual void LoadMsg(Msg& msg);
}
[NullableContextAttribute("1")]
internal interface NetMQ.Core.Transports.IEngine {
    public abstract virtual void Plug(IOThread ioThread, SessionBase session);
    public abstract virtual void Terminate();
    public abstract virtual void ActivateIn();
    public abstract virtual void ActivateOut();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Ipc.IpcAddress : object {
    private string m_name;
    [CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    public IPEndPoint Address { get; private set; }
    [NullableAttribute("1")]
public string Protocol { get; }
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual void Resolve(string name, bool ip4Only);
    [CompilerGeneratedAttribute]
public sealed virtual IPEndPoint get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(IPEndPoint value);
    [NullableContextAttribute("1")]
public sealed virtual string get_Protocol();
}
internal class NetMQ.Core.Transports.Ipc.IpcConnector : TcpConnector {
    [NullableContextAttribute("1")]
public IpcConnector(IOThread ioThread, SessionBase session, Options options, Address addr, bool wait);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Ipc.IpcListener : TcpListener {
    private IpcAddress m_address;
    public string Address { get; }
    public IpcListener(IOThread ioThread, SocketBase socket, Options options);
    public virtual string get_Address();
    public virtual void SetAddress(string addr);
}
internal class NetMQ.Core.Transports.NextMsgDelegate : MulticastDelegate {
    public NextMsgDelegate(object object, IntPtr method);
    public virtual PullMsgResult Invoke(Msg& msg);
    public virtual IAsyncResult BeginInvoke(Msg& msg, AsyncCallback callback, object object);
    public virtual PullMsgResult EndInvoke(Msg& msg, IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Pgm.PgmAddress : object {
    [CompilerGeneratedAttribute]
private IPAddress <InterfaceAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    public IPAddress InterfaceAddress { get; private set; }
    public IPEndPoint Address { get; private set; }
    [NullableAttribute("1")]
public string Protocol { get; }
    [NullableContextAttribute("1")]
public PgmAddress(string network);
    [NullableContextAttribute("1")]
public sealed virtual void Resolve(string name, bool ip4Only);
    [CompilerGeneratedAttribute]
public IPAddress get_InterfaceAddress();
    [CompilerGeneratedAttribute]
private void set_InterfaceAddress(IPAddress value);
    [CompilerGeneratedAttribute]
public sealed virtual IPEndPoint get_Address();
    [CompilerGeneratedAttribute]
private void set_Address(IPEndPoint value);
    [NullableContextAttribute("1")]
public virtual string ToString();
    [NullableContextAttribute("1")]
public sealed virtual string get_Protocol();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Pgm.PgmListener : Own {
    private SocketBase m_socket;
    private IOObject m_ioObject;
    [NullableAttribute("2")]
private AsyncSocket m_handle;
    [NullableAttribute("2")]
private PgmSocket m_pgmSocket;
    [NullableAttribute("2")]
private PgmSocket m_acceptedSocket;
    [NullableAttribute("2")]
private PgmAddress m_address;
    public PgmListener(IOThread ioThread, SocketBase socket, Options options);
    public void Init(string network);
    public virtual void Destroy();
    protected virtual void ProcessPlug();
    protected virtual void ProcessTerm(int linger);
    private void Close();
    public sealed virtual void InCompleted(SocketError socketError, int bytesTransferred);
    private void Accept();
    public sealed virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void TimerEvent(int id);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Pgm.PgmSender : IOObject {
    private static int ReconnectTimerId;
    [NullableAttribute("1")]
private Options m_options;
    [NullableAttribute("1")]
private Address m_addr;
    private bool m_delayedStart;
    private V1Encoder m_encoder;
    private AsyncSocket m_socket;
    private PgmSocket m_pgmSocket;
    private ByteArraySegment m_outBuffer;
    private int m_outBufferSize;
    private int m_writeSize;
    private State m_state;
    private PgmAddress m_pgmAddress;
    private SessionBase m_session;
    private int m_currentReconnectIvl;
    private bool m_moreFlag;
    [NullableContextAttribute("1")]
public PgmSender(IOThread ioThread, Options options, Address addr, bool delayedStart);
    [NullableContextAttribute("1")]
public void Init(PgmAddress pgmAddress);
    [NullableContextAttribute("1")]
public sealed virtual void Plug(IOThread ioThread, SessionBase session);
    private void StartConnecting();
    public sealed virtual void Terminate();
    public sealed virtual void ActivateOut();
    public sealed virtual void ActivateIn();
    public virtual void TimerEvent(int id);
    public virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    private void BeginSending();
    private void Error();
    private void Destroy();
    private int GetNewReconnectIvl();
    public virtual void InCompleted(SocketError socketError, int bytesTransferred);
}
internal class NetMQ.Core.Transports.Pgm.PgmSession : object {
    [NullableAttribute("2")]
private AsyncSocket m_handle;
    [NullableAttribute("1")]
private Options m_options;
    [NullableAttribute("2")]
private IOObject m_ioObject;
    [NullableAttribute("2")]
private SessionBase m_session;
    [NullableAttribute("2")]
private V1Decoder m_decoder;
    private bool m_joined;
    private int m_pendingBytes;
    [NullableAttribute("2")]
private ByteArraySegment m_pendingData;
    [NullableAttribute("1")]
private ByteArraySegment m_data;
    private State m_state;
    [NullableContextAttribute("1")]
public PgmSession(PgmSocket pgmSocket, Options options);
    [NullableContextAttribute("1")]
private sealed virtual override void NetMQ.Core.Transports.IEngine.Plug(IOThread ioThread, SessionBase session);
    public sealed virtual void Terminate();
    public void BeginReceive();
    public sealed virtual void ActivateIn();
    public sealed virtual void InCompleted(SocketError socketError, int bytesTransferred);
    private void ProcessInput();
    private void Error();
    public void Destroy();
    public sealed virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void TimerEvent(int id);
    private void DropSubscriptions();
    public sealed virtual void ActivateOut();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Pgm.PgmSocket : object {
    public static int ProtocolTypeNumber;
    public static ProtocolType PgmProtocolType;
    public static SocketOptionLevel PgmLevel;
    public static int RmOptionsbase;
    public static SocketOptionName RM_RATE_WINDOW_SIZE;
    public static SocketOptionName RM_SET_SEND_IF;
    public static SocketOptionName RM_ADD_RECEIVE_IF;
    public static SocketOptionName RM_SET_MCAST_TTL;
    public static SocketOptionName EnableGigabitOption;
    private Options m_options;
    private PgmSocketType m_pgmSocketType;
    private PgmAddress m_pgmAddress;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private AsyncSocket <Handle>k__BackingField;
    [NullableAttribute("2")]
public AsyncSocket Handle { get; private set; }
    public PgmSocket(Options options, PgmSocketType pgmSocketType, PgmAddress pgmAddress);
    internal void Init();
    internal void InitReceiver();
    internal void InitOptions();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public AsyncSocket get_Handle();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Handle(AsyncSocket value);
    public virtual string ToString();
    public sealed virtual void Dispose();
}
internal enum NetMQ.Core.Transports.Pgm.PgmSocketType : Enum {
    public int value__;
    public static PgmSocketType Publisher;
    public static PgmSocketType Receiver;
    public static PgmSocketType Listener;
}
internal class NetMQ.Core.Transports.ProcessMsgDelegate : MulticastDelegate {
    public ProcessMsgDelegate(object object, IntPtr method);
    public virtual PushMsgResult Invoke(Msg& msg);
    public virtual IAsyncResult BeginInvoke(Msg& msg, AsyncCallback callback, object object);
    public virtual PushMsgResult EndInvoke(Msg& msg, IAsyncResult result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.RawDecoder : DecoderBase {
    private Msg m_inProgress;
    private static int RawMessageReadyState;
    private Byte[] m_buffer;
    public RawDecoder(int bufferSize, long maxMsgSize, Endianness endianness);
    public virtual void GetBuffer(ByteArraySegment& data, Int32& size);
    public virtual DecodeResult Decode(ByteArraySegment data, int size, Int32& bytesUsed);
    protected virtual DecodeResult Next();
    public virtual PushMsgResult PushMsg(ProcessMsgDelegate sink);
}
internal class NetMQ.Core.Transports.RawEncoder : EncoderBase {
    private static int RawMessageReadyState;
    public RawEncoder(int bufferSize, Endianness endianness);
    protected virtual void Next();
}
internal class NetMQ.Core.Transports.StreamEngine : object {
    private static int HeartbeatIntervalTimerId;
    private static int HeartbeatTimeoutTimerId;
    private static int HeartbeatTtlTimerId;
    private Byte[] NullMechanismBytes;
    private Byte[] PlainMechanismBytes;
    private Byte[] CurveMechanismBytes;
    private static int GreetingSize;
    private static int PreambleSize;
    private static int GreetingSizeV3;
    private static int VersionPos;
    private AsyncSocket m_handle;
    private ByteArraySegment m_inpos;
    private int m_insize;
    private DecoderBase m_decoder;
    private bool m_subscriptionRequired;
    private ByteArraySegment m_outpos;
    private int m_outsize;
    private EncoderBase m_encoder;
    private Byte[] m_greeting;
    private int m_greetingBytesRead;
    private ByteArraySegment m_greetingOutputBuffer;
    private SessionBase m_session;
    private Options m_options;
    private string m_endpoint;
    private bool m_plugged;
    private SocketBase m_socket;
    private IOObject m_ioObject;
    private SendState m_sendingState;
    private ReceiveState m_receivingState;
    private State m_state;
    private HandshakeState m_handshakeState;
    private NextMsgDelegate m_nextMsg;
    private ProcessMsgDelegate m_processMsg;
    private Mechanism m_mechanism;
    private Msg m_pongMsg;
    private Queue`1<StateMachineAction> m_actionsQueue;
    private bool m_hasHeartbeatTimer;
    private bool m_hasTtlTimer;
    private bool m_hasTimeoutTimer;
    private int m_heartbeatTimeout;
    public StreamEngine(AsyncSocket handle, Options options, string endpoint);
    public void Destroy();
    public sealed virtual void Plug(IOThread ioThread, SessionBase session);
    public sealed virtual void Terminate();
    private void Unplug();
    private void Error();
    private void FeedAction(Action action, SocketError socketError, int bytesTransferred);
    private void EnqueueAction(Action action, SocketError socketError, int bytesTransferred);
    private void Handle(Action action, SocketError socketError, int bytesTransferred);
    private void BeginSending();
    private void HandleHandshake(Action action, SocketError socketError, int bytesTransferred);
    private void Activate();
    private void ProcessInput();
    public sealed virtual void InCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void ActivateIn();
    public sealed virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void ActivateOut();
    private static int EndWrite(SocketError socketError, int bytesTransferred);
    private void BeginWrite(ByteArraySegment data, int size);
    private static int EndRead(SocketError socketError, int bytesTransferred);
    private void BeginRead(ByteArraySegment data, int size);
    private PullMsgResult RoutingIdMsg(Msg& msg);
    private PushMsgResult ProcessRoutingIdMsg(Msg& msg);
    private PullMsgResult NextHandshakeCommand(Msg& msg);
    private PushMsgResult ProcessHandshakeCommand(Msg& msg);
    private void MechanismReady();
    private PullMsgResult PullAndEncode(Msg& msg);
    private PushMsgResult DecodeAndPush(Msg& msg);
    private PushMsgResult PushOneThenDecodeAndPush(Msg& msg);
    private PullMsgResult ProducePingMessage(Msg& msg);
    private PullMsgResult ProducePongMessage(Msg& msg);
    private void ProcessCommandMessage(Msg& msg);
    private void ProcessPingMessage(Msg& msg);
    public sealed virtual void TimerEvent(int id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Tcp.TcpAddress : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private IPEndPoint <Address>k__BackingField;
    [NullableAttribute("2")]
public IPEndPoint Address { get; private set; }
    public string Protocol { get; }
    public virtual string ToString();
    public sealed virtual void Resolve(string name, bool ip4Only);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual IPEndPoint get_Address();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_Address(IPEndPoint value);
    public sealed virtual string get_Protocol();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Tcp.TcpConnector : Own {
    private static int ReconnectTimerId;
    private IOObject m_ioObject;
    private Address m_addr;
    [NullableAttribute("2")]
private AsyncSocket m_s;
    private bool m_handleValid;
    private bool m_delayedStart;
    private bool m_timerStarted;
    private SessionBase m_session;
    private int m_currentReconnectIvl;
    private string m_endpoint;
    private SocketBase m_socket;
    public TcpConnector(IOThread ioThread, SessionBase session, Options options, Address addr, bool delayedStart);
    public virtual void Destroy();
    protected virtual void ProcessPlug();
    protected virtual void ProcessTerm(int linger);
    public sealed virtual void InCompleted(SocketError socketError, int bytesTransferred);
    private void StartConnecting();
    public sealed virtual void OutCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void TimerEvent(int id);
    private void AddReconnectTimer();
    private int GetNewReconnectIvl();
    private void Close();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.Tcp.TcpListener : Own {
    private static SocketOptionName IPv6Only;
    private IOObject m_ioObject;
    private TcpAddress m_address;
    [NullableAttribute("2")]
private AsyncSocket m_handle;
    private SocketBase m_socket;
    [NullableAttribute("2")]
private string m_endpoint;
    private int m_port;
    public string Address { get; }
    public int Port { get; }
    public TcpListener(IOThread ioThread, SocketBase socket, Options options);
    public virtual void Destroy();
    protected virtual void ProcessPlug();
    protected virtual void ProcessTerm(int linger);
    public virtual void SetAddress(string addr);
    private void Accept();
    public sealed virtual void InCompleted(SocketError socketError, int bytesTransferred);
    private void Close();
    public virtual string get_Address();
    public virtual int get_Port();
    private sealed virtual override void NetMQ.Core.IProactorEvents.OutCompleted(SocketError socketError, int bytesTransferred);
    public sealed virtual void TimerEvent(int id);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.V1Decoder : DecoderBase {
    private static int OneByteSizeReadyState;
    private static int EightByteSizeReadyState;
    private static int FlagsReadyState;
    private static int MessageReadyState;
    private ByteArraySegment m_tmpbuf;
    private Msg m_inProgress;
    private long m_maxMessageSize;
    public V1Decoder(int bufsize, long maxMessageSize, Endianness endian);
    protected virtual DecodeResult Next();
    private DecodeResult OneByteSizeReady();
    private DecodeResult EightByteSizeReady();
    private DecodeResult FlagsReady();
    private DecodeResult MessageReady();
    public virtual PushMsgResult PushMsg(ProcessMsgDelegate sink);
}
internal class NetMQ.Core.Transports.V1Encoder : EncoderBase {
    private static int SizeReadyState;
    private static int MessageReadyState;
    [NullableAttribute("1")]
private ByteArraySegment m_tmpbuf;
    public V1Encoder(int bufferSize, Endianness endian);
    protected virtual void Next();
    private void SizeReady();
    private void MessageReady();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Transports.V2Decoder : DecoderBase {
    private static int OneByteSizeReadyState;
    private static int EightByteSizeReadyState;
    private static int FlagsReadyState;
    private static int MessageReadyState;
    private ByteArraySegment m_tmpbuf;
    private Msg m_inProgress;
    private long m_maxmsgsize;
    private MsgFlags m_msgFlags;
    public V2Decoder(int bufsize, long maxmsgsize, Endianness endian);
    protected virtual DecodeResult Next();
    private DecodeResult FlagsReady();
    private DecodeResult OneByteSizeReady();
    private DecodeResult EightByteSizeReady();
    private DecodeResult MessageReady();
    public virtual PushMsgResult PushMsg(ProcessMsgDelegate sink);
}
internal class NetMQ.Core.Transports.V2Encoder : EncoderBase {
    private static int SizeReadyState;
    private static int MessageReadyState;
    [NullableAttribute("1")]
private ByteArraySegment m_tmpbuf;
    public V2Encoder(int bufferSize, Endianness endian);
    protected virtual void Next();
    private void SizeReady();
    private void MessageReady();
}
internal static class NetMQ.Core.Transports.V2Protocol : object {
    public static int MoreFlag;
    public static int LargeFlag;
    public static int CommandFlag;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class NetMQ.Core.Transports.V3Protocol : object {
    public static string PingCommand;
    public static string PongCommand;
}
public class NetMQ.Core.Utils.AtomicCounter : object {
    private int m_value;
    public void Set(int amount);
    public void Increase(int amount);
    public int Decrement(int amount);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Utils.ByteArrayEqualityComparer : object {
    private static UInt32 C1;
    private static UInt32 C2;
    public sealed virtual bool Equals(Byte[] x, Byte[] y);
    public sealed virtual int GetHashCode(Byte[] data);
}
internal static class NetMQ.Core.Utils.ByteArrayUtility : object {
    [NullableContextAttribute("1")]
public static bool AreEqual(Byte[] a, int aOffset, Byte[] b, int bOffset, int count);
}
internal static class NetMQ.Core.Utils.Clock : object {
    private static long s_lastTsc;
    private static long s_lastTime;
    private static bool s_rdtscSupported;
    private static Clock();
    public static long NowUs();
    public static long NowMs();
    public static long Rdtsc();
}
internal static class NetMQ.Core.Utils.Opcode : object {
    private static IntPtr s_codeBuffer;
    private static ulong s_size;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private static RdtscDelegate <Rdtsc>k__BackingField;
    [NullableAttribute("1")]
private static Byte[] RDTSC_32;
    [NullableAttribute("1")]
private static Byte[] RDTSC_64;
    [NullableAttribute("2")]
public static RdtscDelegate Rdtsc { get; private set; }
    private static Opcode();
    public static bool Open();
    private static bool IsARMArchitecture();
    public static void Close();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static RdtscDelegate get_Rdtsc();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private static void set_Rdtsc(RdtscDelegate value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Utils.Poller : PollerBase {
    private List`1<PollSet> m_handles;
    private List`1<PollSet> m_addList;
    private bool m_retired;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_stopping;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_stopped;
    [NullableAttribute("2")]
private Thread m_workerThread;
    private string m_name;
    private HashSet`1<Socket> m_checkRead;
    private HashSet`1<Socket> m_checkError;
    public Poller(string name);
    public void Destroy();
    public void AddHandle(Socket handle, IPollEvents events);
    public void RemoveHandle(Socket handle);
    public void SetPollIn(Socket handle);
    public void Start();
    public void Stop();
    private void Loop();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.Utils.PollerBase : object {
    private int m_load;
    private SortedList`2<long, List`1<TimerInfo>> m_timers;
    public int Load { get; }
    public int get_Load();
    protected void AdjustLoad(int amount);
    public void AddTimer(long timeout, IProactorEvents sink, int id);
    public void CancelTimer(ITimerEvent sink, int id);
    protected int ExecuteTimers();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Utils.Proactor : PollerBase {
    private static int CompletionStatusArraySize;
    private Dictionary`2<AsyncSocket, Item> m_sockets;
    private CompletionPort m_completionPort;
    private string m_name;
    [NullableAttribute("2")]
private Thread m_worker;
    private bool m_stopping;
    private bool m_stopped;
    public Proactor(string name);
    public void Start();
    public void Stop();
    public void Destroy();
    public void SignalMailbox(IOThreadMailbox mailbox);
    public void AddSocket(AsyncSocket socket, IProactorEvents proactorEvents);
    public void RemoveSocket(AsyncSocket socket);
    private void Loop();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Utils.Signaler : object {
    private Socket m_writeSocket;
    private Socket m_readSocket;
    private Byte[] m_dummy;
    private Byte[] m_receiveDummy;
    public Socket Handle { get; }
    public void Close();
    public Socket get_Handle();
    public void Send();
    public bool WaitEvent(int timeout);
    public void Recv();
}
internal static class NetMQ.Core.Utils.SocketUtility : object {
    [NullableContextAttribute("2")]
public static void Select(IList checkRead, IList checkWrite, IList checkError, int microSeconds);
}
internal static class NetMQ.Core.Utils.SpanUtility : object {
    public static string ToAscii(Span`1<byte> bytes);
    public static bool Equals(Span`1<byte> a, Span`1<byte> b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.Utils.StopSignaler : object {
    private PairSocket m_writer;
    private PairSocket m_reader;
    private int m_isDisposed;
    [CompilerGeneratedAttribute]
private bool <IsStopRequested>k__BackingField;
    public bool IsStopRequested { get; private set; }
    private NetMQSocket NetMQ.ISocketPollable.Socket { get; }
    public bool IsDisposed { get; }
    [CompilerGeneratedAttribute]
public bool get_IsStopRequested();
    [CompilerGeneratedAttribute]
private void set_IsStopRequested(bool value);
    private sealed virtual override NetMQSocket NetMQ.ISocketPollable.get_Socket();
    public sealed virtual bool get_IsDisposed();
    public sealed virtual void Dispose();
    public void Reset();
    public void RequestStop();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object <p0>, NetMQSocketEventArgs <p1>);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NetMQ.Core.Utils.StringLib : object {
    public static string AsString(List`1<Socket> list);
    [ExtensionAttribute]
public static string AsString(Socket socket);
}
internal class NetMQ.Core.Utils.Switch : object {
    [NullableAttribute("1")]
private object m_sync;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_status;
    public bool Status { get; }
    public Switch(bool status);
    public bool get_Status();
    public void WaitForOff();
    public void WaitForOn();
    public void SwitchOn();
    public void SwitchOff();
}
internal class NetMQ.Core.Utils.YQueue`1 : object {
    private int m_chunkSize;
    private Chunk modreq(System.Runtime.CompilerServices.IsVolatile) m_beginChunk;
    private int m_beginPositionInChunk;
    private Chunk<T> m_backChunk;
    private int m_backPositionInChunk;
    private Chunk<T> m_endChunk;
    private int m_endPosition;
    private Chunk<T> m_spareChunk;
    private int m_nextGlobalIndex;
    public int FrontPos { get; }
    public T Front { get; }
    public int BackPos { get; }
    public YQueue`1(int chunkSize);
    public int get_FrontPos();
    public T get_Front();
    public int get_BackPos();
    public T Pop();
    public void Push(T& val);
    public T Unpush();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.Core.YPipe`1 : object {
    private YQueue`1<T> m_queue;
    private int m_flushFromIndex;
    private int m_readToIndex;
    private int m_flushToIndex;
    private int m_lastAllowedToReadIndex;
    public YPipe`1(int qsize, string name);
    public void Write(T& value, bool incomplete);
    public bool Unwrite(T& value);
    public bool Flush();
    public bool CheckRead();
    public bool TryRead(T& value);
    public T Probe();
}
internal enum NetMQ.Core.ZmqSocketOption : Enum {
    public int value__;
    public static ZmqSocketOption Affinity;
    public static ZmqSocketOption Identity;
    public static ZmqSocketOption Subscribe;
    public static ZmqSocketOption Unsubscribe;
    public static ZmqSocketOption Rate;
    public static ZmqSocketOption RecoveryIvl;
    public static ZmqSocketOption SendBuffer;
    public static ZmqSocketOption ReceiveBuffer;
    public static ZmqSocketOption ReceiveMore;
    public static ZmqSocketOption Handle;
    public static ZmqSocketOption Events;
    public static ZmqSocketOption Type;
    public static ZmqSocketOption Linger;
    public static ZmqSocketOption ReconnectIvl;
    public static ZmqSocketOption Backlog;
    public static ZmqSocketOption ReconnectIvlMax;
    public static ZmqSocketOption MaxMessageSize;
    public static ZmqSocketOption SendHighWatermark;
    public static ZmqSocketOption ReceiveHighWatermark;
    public static ZmqSocketOption MulticastHops;
    public static ZmqSocketOption SendTimeout;
    public static ZmqSocketOption IPv4Only;
    public static ZmqSocketOption LastEndpoint;
    public static ZmqSocketOption RouterMandatory;
    public static ZmqSocketOption TcpKeepalive;
    public static ZmqSocketOption TcpKeepaliveIdle;
    public static ZmqSocketOption TcpKeepaliveIntvl;
    public static ZmqSocketOption DelayAttachOnConnect;
    public static ZmqSocketOption XpubVerbose;
    public static ZmqSocketOption RouterRawSocket;
    public static ZmqSocketOption XPublisherManual;
    public static ZmqSocketOption XPublisherWelcomeMessage;
    public static ZmqSocketOption DisableTimeWait;
    public static ZmqSocketOption XPublisherBroadcast;
    public static ZmqSocketOption SendLowWatermark;
    public static ZmqSocketOption ReceiveLowWatermark;
    public static ZmqSocketOption RouterHandover;
    public static ZmqSocketOption LastPeerRoutingId;
    public static ZmqSocketOption CurveServer;
    public static ZmqSocketOption CurvePublicKey;
    public static ZmqSocketOption CurveSecretKey;
    public static ZmqSocketOption CurveServerKey;
    public static ZmqSocketOption HeartbeatInterval;
    public static ZmqSocketOption HeartbeatTtl;
    public static ZmqSocketOption HeartbeatTimeout;
    public static ZmqSocketOption HelloMessage;
    public static ZmqSocketOption Endian;
    public static ZmqSocketOption PgmMaxTransportServiceDataUnitLength;
    public static ZmqSocketOption Correlate;
    public static ZmqSocketOption Relaxed;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class NetMQ.Core.ZObject : object {
    private Ctx m_ctx;
    private int m_threadId;
    public int ThreadId { get; }
    protected Ctx Ctx { get; }
    protected ZObject(Ctx ctx, int threadId);
    protected ZObject(ZObject parent);
    public int get_ThreadId();
    protected Ctx get_Ctx();
    protected bool RegisterEndpoint(string addr, Endpoint endpoint);
    protected bool UnregisterEndpoint(string addr, SocketBase socket);
    protected void UnregisterEndpoints(SocketBase socket);
    protected Endpoint FindEndpoint(string addr);
    protected void DestroySocket(SocketBase socket);
    [NullableContextAttribute("2")]
protected IOThread ChooseIOThread(long affinity);
    protected void SendStop();
    protected void SendForceStop();
    protected void SendPlug(Own destination, bool incSeqnum);
    protected void SendOwn(Own destination, Own obj);
    protected void SendAttach(SessionBase destination, IEngine engine, bool incSeqnum);
    protected void SendBind(Own destination, Pipe pipe, bool incSeqnum);
    protected void SendActivateRead(Pipe destination);
    protected void SendActivateWrite(Pipe destination, long msgsRead);
    protected void SendHiccup(Pipe destination, object pipe);
    protected void SendPipeTerm(Pipe destination);
    protected void SendPipeTermAck(Pipe destination);
    protected void SendTermReq(Own destination, Own obj);
    protected void SendTerm(Own destination, int linger);
    protected void SendTermAck(Own destination);
    protected void SendReap(SocketBase socket);
    protected void SendReaped();
    protected void SendDone();
    protected void SendCancellationRequested();
    private void SendCommand(Command cmd);
    public void ProcessCommand(Command cmd);
    protected virtual void ProcessStop();
    protected virtual void ProcessForceStop();
    protected virtual void ProcessPlug();
    protected virtual void ProcessOwn(Own obj);
    protected virtual void ProcessAttach(IEngine engine);
    protected virtual void ProcessBind(Pipe pipe);
    protected virtual void ProcessActivateRead();
    protected virtual void ProcessActivateWrite(long msgsRead);
    protected virtual void ProcessHiccup(object pipe);
    protected virtual void ProcessPipeTerm();
    protected virtual void ProcessPipeTermAck();
    protected virtual void ProcessTermReq(Own obj);
    protected virtual void ProcessTerm(int linger);
    protected virtual void ProcessTermAck();
    protected virtual void ProcessReap(SocketBase socket);
    protected virtual void ProcessReaped();
    protected virtual void ProcessSeqnum();
    protected virtual void ProcessCancellationRequested();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <ProcessCommand>g__GetArg|33_0(<>c__DisplayClass33_0& );
}
internal static class NetMQ.EmptyArray`1 : object {
    [NullableAttribute("1")]
public static T[] Instance;
    private static EmptyArray`1();
}
public enum NetMQ.Endianness : Enum {
    public int value__;
    public static Endianness Big;
    public static Endianness Little;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.EndpointNotFoundException : NetMQException {
    public EndpointNotFoundException(Exception innerException, string message);
    public EndpointNotFoundException(string message);
    [NullableContextAttribute("1")]
protected EndpointNotFoundException(SerializationInfo info, StreamingContext context);
}
public enum NetMQ.ErrorCode : Enum {
    public int value__;
    public static ErrorCode EndpointNotFound;
    public static ErrorCode AddressAlreadyInUse;
    public static ErrorCode TryAgain;
    public static ErrorCode AccessDenied;
    public static ErrorCode Invalid;
    public static ErrorCode InProgress;
    public static ErrorCode ProtocolNotSupported;
    public static ErrorCode Fault;
    public static ErrorCode AddressNotAvailable;
    public static ErrorCode NetworkDown;
    public static ErrorCode NoBufferSpaceAvailable;
    public static ErrorCode NotConnected;
    public static ErrorCode ConnectionRefused;
    public static ErrorCode HostUnreachable;
    public static ErrorCode BaseErrorNumber;
    public static ErrorCode MessageSize;
    public static ErrorCode AddressFamilyNotSupported;
    public static ErrorCode NetworkUnreachable;
    public static ErrorCode ConnectionAborted;
    public static ErrorCode ConnectionReset;
    public static ErrorCode TimedOut;
    public static ErrorCode NetworkReset;
    public static ErrorCode FiniteStateMachine;
    public static ErrorCode ContextTerminated;
    public static ErrorCode EmptyThread;
    public static ErrorCode TooManyOpenSockets;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.EventDelegator`1 : object {
    private Action m_registerToEvent;
    private Action m_unregisterFromEvent;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<T> m_event;
    private int m_counter;
    public EventDelegator`1(Action registerToEvent, Action unregisterFromEvent);
    public void add_Event(EventHandler`1<T> value);
    public void remove_Event(EventHandler`1<T> value);
    public void Fire(object sender, T args);
    public sealed virtual void Dispose();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.FaultException : NetMQException {
    internal FaultException(Exception innerException, string message);
    internal FaultException(string message);
    [NullableContextAttribute("1")]
protected FaultException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.FiniteStateMachineException : NetMQException {
    internal FiniteStateMachineException(Exception innerException, string message);
    internal FiniteStateMachineException(string message);
    [NullableContextAttribute("1")]
protected FiniteStateMachineException(SerializationInfo info, StreamingContext context);
}
public class NetMQ.GCAtomicCounterPool : object {
    [NullableContextAttribute("1")]
public sealed virtual AtomicCounter Take();
    [NullableContextAttribute("1")]
public sealed virtual void Return(AtomicCounter counter);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public class NetMQ.GCBufferPool : object {
    [NullableContextAttribute("1")]
public sealed virtual Byte[] Take(int size);
    [NullableContextAttribute("1")]
public sealed virtual void Return(Byte[] buffer);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.GroupSocketExtensions : object {
    [ExtensionAttribute]
public static void Send(IGroupOutSocket socket, string group, Byte[] data);
    [ExtensionAttribute]
public static void Send(IGroupOutSocket socket, string group, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, TimeSpan timeout, string group, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, TimeSpan timeout, string group, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, string group, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, string group, Byte[] data, int length);
    [ExtensionAttribute]
public static ValueTask SendAsync(IGroupOutSocket socket, string group, Byte[] data);
    [ExtensionAttribute]
public static ValueTask SendAsync(IGroupOutSocket socket, string group, Byte[] data, int length);
    [ExtensionAttribute]
public static void Send(IGroupOutSocket socket, string group, string message);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, TimeSpan timeout, string group, string message);
    [ExtensionAttribute]
public static bool TrySend(IGroupOutSocket socket, string group, string message);
    [ExtensionAttribute]
public static ValueTask SendAsync(IGroupOutSocket socket, string group, string message);
    [ExtensionAttribute]
public static ValueTuple`2<string, Byte[]> ReceiveBytes(IGroupInSocket socket, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryReceiveBytes(IGroupInSocket socket, String& group, Byte[]& bytes);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryReceiveBytes(IGroupInSocket socket, TimeSpan timeout, String& group, Byte[]& bytes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<string, Byte[]>> ReceiveBytesAsync(IGroupInSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.GroupSocketExtensions/<ReceiveBytesAsyncEnumerable>d__16")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<ValueTuple`2<string, Byte[]>> ReceiveBytesAsyncEnumerable(IGroupInSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTuple`2<string, string> ReceiveString(IGroupInSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTuple`2<string, string> ReceiveString(IGroupInSocket socket, Encoding encoding, CancellationToken cancellationToken);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryReceiveString(IGroupInSocket socket, String& group, String& str);
    [ExtensionAttribute]
public static bool TryReceiveString(IGroupInSocket socket, Encoding encoding, String& group, String& str);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
public static bool TryReceiveString(IGroupInSocket socket, TimeSpan timeout, String& group, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveString(IGroupInSocket socket, TimeSpan timeout, Encoding encoding, String& group, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<string, string>> ReceiveStringAsync(IGroupInSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.GroupSocketExtensions/<ReceiveStringAsyncEnumerable>d__24")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<ValueTuple`2<string, string>> ReceiveStringAsyncEnumerable(IGroupInSocket socket, CancellationToken cancellationToken);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.HostUnreachableException : NetMQException {
    internal HostUnreachableException(Exception innerException, string message);
    internal HostUnreachableException(string message);
    [NullableContextAttribute("1")]
protected HostUnreachableException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
public interface NetMQ.IAtomicCounterPool {
    public abstract virtual AtomicCounter Take();
    public abstract virtual void Return(AtomicCounter counter);
}
[NullableContextAttribute("1")]
public interface NetMQ.IBufferPool {
    public abstract virtual Byte[] Take(int size);
    public abstract virtual void Return(Byte[] buffer);
}
public interface NetMQ.IGroupInSocket {
}
public interface NetMQ.IGroupOutSocket {
}
[NullableContextAttribute("1")]
public interface NetMQ.INetMQPoller {
    public bool IsRunning { get; }
    public abstract virtual void Run();
    public abstract virtual void RunAsync();
    public abstract virtual void Stop();
    public abstract virtual void StopAsync();
    public abstract virtual bool get_IsRunning();
    public abstract virtual void Add(ISocketPollable socket);
    public abstract virtual void Remove(ISocketPollable socket);
    public abstract virtual void RemoveAndDispose(T socket);
}
[NullableContextAttribute("1")]
public interface NetMQ.INetMQSocket {
    public SocketOptions Options { get; }
    public bool HasIn { get; }
    public bool HasOut { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_ReceiveReady(EventHandler`1<NetMQSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ReceiveReady(EventHandler`1<NetMQSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_SendReady(EventHandler`1<NetMQSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_SendReady(EventHandler`1<NetMQSocketEventArgs> value);
    public abstract virtual SocketOptions get_Options();
    public abstract virtual bool get_HasIn();
    public abstract virtual bool get_HasOut();
    public abstract virtual void Bind(string address);
    public abstract virtual int BindRandomPort(string address);
    public abstract virtual void Connect(string address);
    public abstract virtual void Disconnect(string address);
    public abstract virtual void Unbind(string address);
    public abstract virtual void Close();
    public abstract virtual void Poll();
    public abstract virtual bool Poll(TimeSpan timeout);
    public abstract virtual PollEvents Poll(PollEvents pollEvents, TimeSpan timeout);
    public abstract virtual void Monitor(string endpoint, SocketEvents events);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.InterfaceCollection : object {
    private List`1<InterfaceItem> m_interfaceItems;
    public sealed virtual IEnumerator`1<InterfaceItem> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.InterfaceItem : object {
    [CompilerGeneratedAttribute]
private IPAddress <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private IPAddress <BroadcastAddress>k__BackingField;
    public IPAddress Address { get; }
    public IPAddress BroadcastAddress { get; }
    public InterfaceItem(IPAddress address, IPAddress broadcastAddress);
    [CompilerGeneratedAttribute]
public IPAddress get_Address();
    [CompilerGeneratedAttribute]
public IPAddress get_BroadcastAddress();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.InvalidException : NetMQException {
    public InvalidException(Exception innerException, string message);
    public InvalidException(string message);
    [NullableContextAttribute("1")]
protected InvalidException(SerializationInfo info, StreamingContext context);
}
public interface NetMQ.IOutgoingSocket {
    public abstract virtual bool TrySend(Msg& msg, TimeSpan timeout, bool more);
}
public interface NetMQ.IReceivingSocket {
    public abstract virtual bool TryReceive(Msg& msg, TimeSpan timeout);
}
public interface NetMQ.IRoutingIdSocket {
}
[NullableContextAttribute("1")]
public interface NetMQ.IShimHandler {
    public abstract virtual void Run(PairSocket shim);
}
[NullableContextAttribute("1")]
public interface NetMQ.ISocketPollable {
    public NetMQSocket Socket { get; }
    public bool IsDisposed { get; }
    public abstract virtual NetMQSocket get_Socket();
    public abstract virtual bool get_IsDisposed();
}
[NullableContextAttribute("1")]
[ObsoleteAttribute("Use INetMQPoller instead")]
public interface NetMQ.ISocketPollableCollection {
    public abstract virtual void Add(ISocketPollable socket);
    public abstract virtual void Remove(ISocketPollable socket);
    public abstract virtual void RemoveAndDispose(T socket);
}
public interface NetMQ.IThreadSafeInSocket {
}
public interface NetMQ.IThreadSafeOutSocket {
}
public interface NetMQ.IThreadSafeSocket {
    public abstract virtual bool TrySend(Msg& msg, TimeSpan timeout);
    public abstract virtual bool TryReceive(Msg& msg, TimeSpan timeout, CancellationToken cancellationToken);
}
public enum NetMQ.MechanismType : Enum {
    public int value__;
    public static MechanismType Null;
    public static MechanismType Plain;
    public static MechanismType Curve;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Monitoring.NetMQMonitor : object {
    private NetMQSocket m_monitoringSocket;
    private bool m_ownsMonitoringSocket;
    [NullableAttribute("2")]
private INetMQPoller m_attachedPoller;
    private int m_cancel;
    private ManualResetEvent m_isStoppedEvent;
    [CompilerGeneratedAttribute]
private string <Endpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <Timeout>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorEventArgs> EventReceived;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorSocketEventArgs> Connected;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorErrorEventArgs> ConnectDelayed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorIntervalEventArgs> ConnectRetried;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorSocketEventArgs> Listening;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorErrorEventArgs> BindFailed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorSocketEventArgs> Accepted;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorErrorEventArgs> AcceptFailed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorSocketEventArgs> Closed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorErrorEventArgs> CloseFailed;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQMonitorSocketEventArgs> Disconnected;
    public string Endpoint { get; }
    public bool IsRunning { get; private set; }
    public TimeSpan Timeout { get; public set; }
    public NetMQMonitor(NetMQSocket monitoredSocket, string endpoint, SocketEvents eventsToMonitor);
    public NetMQMonitor(NetMQSocket socket, string endpoint, bool ownsSocket);
    [CompilerGeneratedAttribute]
public string get_Endpoint();
    [CompilerGeneratedAttribute]
public bool get_IsRunning();
    [CompilerGeneratedAttribute]
private void set_IsRunning(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_Timeout();
    [CompilerGeneratedAttribute]
public void set_Timeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public void add_EventReceived(EventHandler`1<NetMQMonitorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_EventReceived(EventHandler`1<NetMQMonitorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Connected(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Connected(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ConnectDelayed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConnectDelayed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ConnectRetried(EventHandler`1<NetMQMonitorIntervalEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ConnectRetried(EventHandler`1<NetMQMonitorIntervalEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Listening(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Listening(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BindFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BindFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Accepted(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Accepted(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_AcceptFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_AcceptFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Closed(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Closed(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CloseFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CloseFailed(EventHandler`1<NetMQMonitorErrorEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Disconnected(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Disconnected(EventHandler`1<NetMQMonitorSocketEventArgs> value);
    private void Handle(object sender, NetMQSocketEventArgs socketEventArgs);
    private void InvokeEvent(EventHandler`1<T> handler, T args);
    private void InternalStart();
    private void InternalClose();
    public void AttachToPoller(T poller);
    public void DetachFromPoller();
    private void DetachFromPoller(bool dispose);
    public void Start();
    public Task StartAsync();
    public void Stop();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
internal static T <Handle>g__GetArg|51_0(<>c__DisplayClass51_0& );
}
public class NetMQ.Monitoring.NetMQMonitorErrorEventArgs : NetMQMonitorEventArgs {
    [CompilerGeneratedAttribute]
private ErrorCode <ErrorCode>k__BackingField;
    public ErrorCode ErrorCode { get; }
    [NullableContextAttribute("1")]
public NetMQMonitorErrorEventArgs(NetMQMonitor monitor, string address, ErrorCode errorCode, SocketEvents socketEvent);
    [CompilerGeneratedAttribute]
public ErrorCode get_ErrorCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NetMQ.Monitoring.NetMQMonitorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQMonitor <Monitor>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Address>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketEvents <SocketEvent>k__BackingField;
    public NetMQMonitor Monitor { get; }
    public string Address { get; }
    public SocketEvents SocketEvent { get; }
    protected NetMQMonitorEventArgs(NetMQMonitor monitor, string address, SocketEvents socketEvent);
    [CompilerGeneratedAttribute]
public NetMQMonitor get_Monitor();
    [CompilerGeneratedAttribute]
public string get_Address();
    [CompilerGeneratedAttribute]
public SocketEvents get_SocketEvent();
}
public class NetMQ.Monitoring.NetMQMonitorIntervalEventArgs : NetMQMonitorEventArgs {
    [CompilerGeneratedAttribute]
private int <Interval>k__BackingField;
    public int Interval { get; }
    [NullableContextAttribute("1")]
public NetMQMonitorIntervalEventArgs(NetMQMonitor monitor, string address, int interval, SocketEvents socketEvent);
    [CompilerGeneratedAttribute]
public int get_Interval();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Monitoring.NetMQMonitorSocketEventArgs : NetMQMonitorEventArgs {
    [CompilerGeneratedAttribute]
private AsyncSocket <Socket>k__BackingField;
    public AsyncSocket Socket { get; }
    public NetMQMonitorSocketEventArgs(NetMQMonitor monitor, string address, AsyncSocket socket, SocketEvents socketEvent);
    [CompilerGeneratedAttribute]
public AsyncSocket get_Socket();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NetMQ.Msg : ValueType {
    public static int MaxGroupLength;
    [NullableAttribute("2")]
private AtomicCounter m_refCount;
    [NullableAttribute("2")]
private Byte[] m_data;
    private int m_offset;
    private UInt32 m_routingId;
    private string m_group;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    [CompilerGeneratedAttribute]
private MsgType <MsgType>k__BackingField;
    [CompilerGeneratedAttribute]
private MsgFlags <Flags>k__BackingField;
    public int Size { get; private set; }
    public bool IsEmpty { get; }
    public bool IsJoin { get; }
    public bool IsLeave { get; }
    [ObsoleteAttribute("Use implicit casting to Span or Slice instead")]
public int Offset { get; }
    public MsgType MsgType { get; private set; }
    public bool IsDelimiter { get; }
    public bool IsInitialised { get; }
    public MsgFlags Flags { get; private set; }
    public bool HasMore { get; }
    internal bool HasCommand { get; }
    public bool IsShared { get; }
    public bool IsIdentity { get; }
    public UInt32 RoutingId { get; public set; }
    public string Group { get; public set; }
    [NullableAttribute("2")]
[ObsoleteAttribute("Use implicit casting to Span or Slice instead")]
public Byte[] Data { get; }
    public byte Item { get; public set; }
    [NullableAttribute("2")]
internal Byte[] UnsafeData { get; }
    internal int UnsafeOffset { get; }
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_Size();
    [CompilerGeneratedAttribute]
private void set_Size(int value);
    public bool get_IsEmpty();
    public bool get_IsJoin();
    public bool get_IsLeave();
    public int get_Offset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MsgType get_MsgType();
    [CompilerGeneratedAttribute]
private void set_MsgType(MsgType value);
    public bool get_IsDelimiter();
    public bool get_IsInitialised();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public MsgFlags get_Flags();
    [CompilerGeneratedAttribute]
private void set_Flags(MsgFlags value);
    public bool get_HasMore();
    internal bool get_HasCommand();
    public bool get_IsShared();
    public bool get_IsIdentity();
    public void SetFlags(MsgFlags flags);
    public void ResetFlags(MsgFlags flags);
    public UInt32 get_RoutingId();
    public void set_RoutingId(UInt32 value);
    internal void ResetRoutingId();
    public string get_Group();
    public void set_Group(string value);
    [NullableContextAttribute("2")]
public Byte[] get_Data();
    [NullableContextAttribute("0")]
public Span`1<byte> Slice();
    [NullableContextAttribute("0")]
public Memory`1<byte> SliceAsMemory();
    [NullableContextAttribute("0")]
public Span`1<byte> Slice(int offset);
    [NullableContextAttribute("0")]
public Span`1<byte> Slice(int offset, int count);
    [NullableContextAttribute("0")]
public void CopyTo(Span`1<byte> span);
    public Byte[] ToArray();
    [NullableContextAttribute("0")]
public static Span`1<byte> op_Implicit(Msg msg);
    [NullableContextAttribute("0")]
public static ReadOnlySpan`1<byte> op_Implicit(Msg msg);
    [NullableContextAttribute("0")]
public Enumerator<byte> GetEnumerator();
    public void InitEmpty();
    public void InitPool(int size);
    public void InitGC(Byte[] data, int size);
    public void InitGC(Byte[] data, int offset, int size);
    public void InitDelimiter();
    internal void InitJoin();
    internal void InitLeave();
    public void Close();
    public void AddReferences(int amount);
    public void RemoveReferences(int amount);
    public virtual string ToString();
    public string GetString(Encoding encoding);
    public string GetString(Encoding encoding, int offset, int count);
    [NullableContextAttribute("2")]
public void Put(Byte[] src, int dstOffset, int len);
    [NullableContextAttribute("2")]
public void Put(Byte[] src, int srcOffset, int dstOffset, int len);
    public void Put(byte b);
    public void Put(byte b, int i);
    public void Put(Encoding encoding, string str, int index);
    [NullableContextAttribute("0")]
public void Put(Span`1<byte> src, int offset);
    public byte get_Item(int index);
    public void set_Item(int index, byte value);
    public void Copy(Msg& src);
    public void TrimPrefix(int count);
    public void Move(Msg& src);
    public Byte[] CloneData();
    private void EnsureAtomicCounterNull();
    internal Byte[] UnsafeToArray();
    [NullableContextAttribute("2")]
internal Byte[] get_UnsafeData();
    internal int get_UnsafeOffset();
}
[FlagsAttribute]
public enum NetMQ.MsgFlags : Enum {
    public byte value__;
    public static MsgFlags None;
    public static MsgFlags More;
    public static MsgFlags Command;
    public static MsgFlags Identity;
    public static MsgFlags Shared;
}
public enum NetMQ.MsgType : Enum {
    public byte value__;
    public static MsgType Uninitialised;
    public static MsgType Empty;
    public static MsgType GC;
    public static MsgType Join;
    public static MsgType Leave;
    public static MsgType Pool;
    public static MsgType Delimiter;
}
public static class NetMQ.NamespaceDoc : object {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQActor : object {
    public static string EndShimMessage;
    private PairSocket m_self;
    private PairSocket m_shim;
    private Thread m_shimThread;
    private IShimHandler m_shimHandler;
    private EventDelegator`1<NetMQActorEventArgs> m_receiveEvent;
    private EventDelegator`1<NetMQActorEventArgs> m_sendEvent;
    private int m_isDisposed;
    private NetMQSocket NetMQ.ISocketPollable.Socket { get; }
    public bool IsDisposed { get; }
    private NetMQActor(PairSocket self, PairSocket shim, IShimHandler shimHandler);
    public static NetMQActor Create(IShimHandler shimHandler);
    public static NetMQActor Create(ShimAction`1<T> action, T state);
    public static NetMQActor Create(ShimAction action);
    private void RunShim();
    public sealed virtual bool TrySend(Msg& msg, TimeSpan timeout, bool more);
    public sealed virtual bool TryReceive(Msg& msg, TimeSpan timeout);
    public void add_ReceiveReady(EventHandler`1<NetMQActorEventArgs> value);
    public void remove_ReceiveReady(EventHandler`1<NetMQActorEventArgs> value);
    public void add_SendReady(EventHandler`1<NetMQActorEventArgs> value);
    public void remove_SendReady(EventHandler`1<NetMQActorEventArgs> value);
    private sealed virtual override NetMQSocket NetMQ.ISocketPollable.get_Socket();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool get_IsDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQActorEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQActor <Actor>k__BackingField;
    public NetMQActor Actor { get; }
    public NetMQActorEventArgs(NetMQActor actor);
    [CompilerGeneratedAttribute]
public NetMQActor get_Actor();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQBeacon : object {
    private static int UdpFrameMax;
    private static string ConfigureCommand;
    private static string PublishCommand;
    private static string SilenceCommand;
    private static string SubscribeCommand;
    private static string UnsubscribeCommand;
    private NetMQActor m_actor;
    private EventDelegator`1<NetMQBeaconEventArgs> m_receiveEvent;
    [NullableAttribute("2")]
private string m_boundTo;
    [NullableAttribute("2")]
private string m_hostName;
    private int m_isDisposed;
    [NullableAttribute("2")]
public string HostName { get; }
    [NullableAttribute("2")]
public string BoundTo { get; }
    private NetMQSocket NetMQ.ISocketPollable.Socket { get; }
    public bool IsDisposed { get; }
    [NullableContextAttribute("2")]
public string get_HostName();
    [NullableContextAttribute("2")]
public string get_BoundTo();
    private sealed virtual override NetMQSocket NetMQ.ISocketPollable.get_Socket();
    public void add_ReceiveReady(EventHandler`1<NetMQBeaconEventArgs> value);
    public void remove_ReceiveReady(EventHandler`1<NetMQBeaconEventArgs> value);
    public void ConfigureAllInterfaces(int port);
    public void Configure(int port, string interfaceName);
    public void Publish(string transmit, TimeSpan interval, Encoding encoding);
    public void Publish(Byte[] transmit, TimeSpan interval);
    public void Publish(string transmit, Encoding encoding);
    public void Publish(Byte[] transmit);
    public void Silence();
    public void Subscribe(string filter);
    public void Unsubscribe();
    public BeaconMessage Receive();
    public bool TryReceive(TimeSpan timeout, BeaconMessage& message);
    public sealed virtual void Dispose();
    public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void <.ctor>g__OnReceive|12_0(object sender, NetMQActorEventArgs e);
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_1();
    [CompilerGeneratedAttribute]
private void <.ctor>b__12_2();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQBeaconEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQBeacon <Beacon>k__BackingField;
    public NetMQBeacon Beacon { get; }
    public NetMQBeaconEventArgs(NetMQBeacon beacon);
    [CompilerGeneratedAttribute]
public NetMQBeacon get_Beacon();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQCertificate : object {
    private static string Encoder;
    private static Byte[] Decoder;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Byte[] <SecretKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PublicKey>k__BackingField;
    [NullableAttribute("2")]
public Byte[] SecretKey { get; private set; }
    [NullableAttribute("2")]
public string SecretKeyZ85 { get; }
    public bool HasSecretKey { get; }
    public Byte[] PublicKey { get; private set; }
    public string PublicKeyZ85 { get; }
    public NetMQCertificate(Byte[] secretKey, Byte[] publicKey);
    public NetMQCertificate(string secretKey, string publicKey);
    private NetMQCertificate(Byte[] key, bool isSecret);
    private NetMQCertificate(string keystr, bool isSecret);
    private static NetMQCertificate();
    private string Z85Encode(Byte[] data);
    private Byte[] Z85Decode(string key);
    public static NetMQCertificate CreateFromSecretKey(Byte[] secretKey);
    public NetMQCertificate FromSecretKey(Byte[] secretKey);
    public static NetMQCertificate CreateFromSecretKey(string secretKey);
    public NetMQCertificate FromSecretKey(string secretKey);
    public static NetMQCertificate FromPublicKey(Byte[] publicKey);
    public static NetMQCertificate FromPublicKey(string publicKey);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Byte[] get_SecretKey();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set_SecretKey(Byte[] value);
    [NullableContextAttribute("2")]
public string get_SecretKeyZ85();
    public bool get_HasSecretKey();
    [CompilerGeneratedAttribute]
public Byte[] get_PublicKey();
    [CompilerGeneratedAttribute]
private void set_PublicKey(Byte[] value);
    public string get_PublicKeyZ85();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NetMQ.NetMQConfig : object {
    private static TimeSpan s_linger;
    [NullableAttribute("2")]
private static Ctx s_ctx;
    private static int s_threadPoolSize;
    private static int s_maxSockets;
    private static object s_sync;
    internal static Ctx Context { get; }
    public static TimeSpan Linger { get; public set; }
    public static int ThreadPoolSize { get; public set; }
    public static int MaxSockets { get; public set; }
    private static NetMQConfig();
    internal static Ctx get_Context();
    public static void Cleanup(bool block);
    public static TimeSpan get_Linger();
    public static void set_Linger(TimeSpan value);
    public static int get_ThreadPoolSize();
    public static void set_ThreadPoolSize(int value);
    public static int get_MaxSockets();
    public static void set_MaxSockets(int value);
    [ObsoleteAttribute("Use Cleanup method")]
public static void ManualTerminationTakeOver();
    [ObsoleteAttribute("Use Cleanup method")]
internal static void DisableManualTermination();
    [ObsoleteAttribute("Use Cleanup method")]
public static void ContextTerminate(bool block);
    [ObsoleteAttribute("Context is created automatically")]
public static void ContextCreate(bool block);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQException : Exception {
    [CompilerGeneratedAttribute]
private ErrorCode <ErrorCode>k__BackingField;
    public ErrorCode ErrorCode { get; }
    public NetMQException(string message);
    public NetMQException(string message, Exception innerException);
    protected NetMQException(SerializationInfo info, StreamingContext context);
    [NullableContextAttribute("2")]
protected NetMQException(Exception innerException, string message, ErrorCode errorCode);
    [CompilerGeneratedAttribute]
public ErrorCode get_ErrorCode();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public static NetMQException Create(SocketException innerException);
    public static NetMQException Create(SocketError error, Exception innerException);
    public static NetMQException Create(ErrorCode errorCode, Exception innerException);
    public static NetMQException Create(ErrorCode errorCode);
    public static NetMQException Create(string message, ErrorCode errorCode);
    [NullableContextAttribute("2")]
private static NetMQException Create(ErrorCode errorCode, string message, Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQFrame : object {
    private int m_messageSize;
    private int m_hash;
    [CompilerGeneratedAttribute]
private Byte[] <Buffer>k__BackingField;
    public int MessageSize { get; public set; }
    public Byte[] Buffer { get; }
    public int BufferSize { get; }
    public static NetMQFrame Empty { get; }
    public bool IsEmpty { get; }
    [NullableContextAttribute("2")]
public NetMQFrame(Byte[] buffer);
    public NetMQFrame(Byte[] buffer, int length);
    public NetMQFrame(string message);
    public NetMQFrame(string message, Encoding encoding);
    public NetMQFrame(int length);
    public int get_MessageSize();
    public void set_MessageSize(int value);
    [CompilerGeneratedAttribute]
public Byte[] get_Buffer();
    public int get_BufferSize();
    public static NetMQFrame get_Empty();
    public bool get_IsEmpty();
    public static NetMQFrame Copy(Byte[] buffer);
    public string ConvertToString();
    public string ConvertToString(Encoding encoding);
    public int ConvertToInt32();
    public long ConvertToInt64();
    public static NetMQFrame Copy(NetMQFrame frame);
    public NetMQFrame Duplicate();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(Byte[] other);
    [NullableContextAttribute("2")]
public bool Equals(NetMQFrame other);
    private sealed virtual override bool System.IEquatable<NetMQ.NetMQFrame>.Equals(NetMQFrame other);
    public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
public static bool op_Equality(NetMQFrame one, NetMQFrame other);
    [NullableContextAttribute("2")]
public static bool op_Inequality(NetMQFrame one, NetMQFrame other);
    public virtual int GetHashCode();
    public Byte[] ToByteArray(bool copy);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class NetMQ.NetMQMessage : object {
    private List`1<NetMQFrame> m_frames;
    public NetMQFrame First { get; }
    public NetMQFrame Last { get; }
    public bool IsEmpty { get; }
    public int FrameCount { get; }
    public NetMQFrame Item { get; }
    public NetMQMessage(int expectedFrameCount);
    public NetMQMessage(IEnumerable`1<NetMQFrame> frames);
    public NetMQMessage(IEnumerable`1<Byte[]> buffers);
    public NetMQFrame get_First();
    public NetMQFrame get_Last();
    public bool get_IsEmpty();
    public int get_FrameCount();
    public NetMQFrame get_Item(int index);
    public void Append(NetMQFrame frame);
    public void Append(Byte[] buffer);
    public void Append(string message);
    public void Append(string message, Encoding encoding);
    public void Append(int value);
    public void Append(long value);
    public void AppendEmptyFrame();
    public void Push(NetMQFrame frame);
    public void Push(Byte[] buffer);
    public void Push(string message);
    public void Push(string message, Encoding encoding);
    public void Push(int value);
    public void Push(long value);
    public void PushEmptyFrame();
    public NetMQFrame Pop();
    public bool RemoveFrame(NetMQFrame frame);
    public void Clear();
    public sealed virtual IEnumerator`1<NetMQFrame> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQPoller : TaskScheduler {
    private List`1<NetMQSocket> m_sockets;
    private List`1<NetMQTimer> m_timers;
    private Dictionary`2<Socket, Action`1<Socket>> m_pollinSockets;
    private Switch m_switch;
    private NetMQSelector m_netMqSelector;
    private StopSignaler m_stopSignaler;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Item[] m_pollSet;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private NetMQSocket[] m_pollact;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) m_isPollSetDirty;
    private int m_disposeState;
    private NetMQQueue`1<Task> m_tasksQueue;
    private ThreadLocal`1<bool> m_isSchedulerThread;
    public bool CanExecuteTaskInline { get; }
    public int MaximumConcurrencyLevel { get; }
    public bool IsRunning { get; }
    public bool IsDisposed { get; }
    private bool IsPollerThread { get; }
    public bool get_CanExecuteTaskInline();
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    public virtual int get_MaximumConcurrencyLevel();
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual void QueueTask(Task task);
    public void Run(Action action);
    public sealed virtual bool get_IsRunning();
    public bool get_IsDisposed();
    private bool get_IsPollerThread();
    public sealed virtual void Add(ISocketPollable socket);
    public void Add(NetMQTimer timer);
    public void Add(Socket socket, Action`1<Socket> callback);
    public sealed virtual void Remove(ISocketPollable socket);
    public sealed virtual void RemoveAndDispose(T socket);
    public void Remove(NetMQTimer timer);
    public void Remove(Socket socket);
    public Task`1<bool> ContainsAsync(ISocketPollable socket);
    public Task`1<bool> ContainsAsync(NetMQTimer timer);
    public Task`1<bool> ContainsAsync(Socket socket);
    public sealed virtual void RunAsync();
    public void RunAsync(string threadName);
    public void RunAsync(string threadName, bool isBackgroundThread);
    public sealed virtual void Run();
    public void Run(SynchronizationContext syncContext);
    private void RunPoller();
    public sealed virtual void Stop();
    public sealed virtual void StopAsync();
    private void OnSocketEventsChanged(object sender, NetMQSocketEventArgs e);
    private void RebuildPollset();
    [IteratorStateMachineAttribute("NetMQ.NetMQPoller/<System-Collections-IEnumerable-GetEnumerator>d__47")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private void CheckDisposed();
    public sealed virtual void Dispose();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <.ctor>b__20_0(object <p0>, NetMQQueueEventArgs`1<Task> <p1>);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQProactor : object {
    private NetMQActor m_actor;
    private NetMQSocket m_receiveSocket;
    private Action`2<NetMQSocket, NetMQMessage> m_handler;
    [NullableAttribute("2")]
private NetMQPoller m_poller;
    public NetMQProactor(NetMQSocket receiveSocket, Action`2<NetMQSocket, NetMQMessage> handler);
    public sealed virtual void Dispose();
    private void Run(PairSocket shim);
    private void OnShimReady(object sender, NetMQSocketEventArgs e);
    private void OnSocketReady(object sender, NetMQSocketEventArgs e);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQQueue`1 : object {
    private PairSocket m_writer;
    private PairSocket m_reader;
    private ConcurrentQueue`1<T> m_queue;
    private EventDelegator`1<NetMQQueueEventArgs`1<T>> m_eventDelegator;
    private Msg m_dequeueMsg;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private NetMQSocket NetMQ.ISocketPollable.Socket { get; }
    public bool IsDisposed { get; private set; }
    public int Count { get; }
    public bool IsEmpty { get; }
    public NetMQQueue`1(int capacity);
    private void OnReceiveReady(object sender, NetMQSocketEventArgs e);
    public void add_ReceiveReady(EventHandler`1<NetMQQueueEventArgs`1<T>> value);
    public void remove_ReceiveReady(EventHandler`1<NetMQQueueEventArgs`1<T>> value);
    private sealed virtual override NetMQSocket NetMQ.ISocketPollable.get_Socket();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public int get_Count();
    public bool get_IsEmpty();
    public bool TryDequeue(T& result, TimeSpan timeout);
    public T Dequeue();
    public void Enqueue(T value);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQQueueEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQQueue`1<T> <Queue>k__BackingField;
    public NetMQQueue`1<T> Queue { get; }
    internal NetMQQueueEventArgs`1(NetMQQueue`1<T> queue);
    [CompilerGeneratedAttribute]
public NetMQQueue`1<T> get_Queue();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQRuntime : object {
    private NetMQPoller m_poller;
    private NetMQSynchronizationContext m_synchronizationContext;
    private SynchronizationContext m_oldSynchronizationContext;
    private static ThreadLocal`1<NetMQRuntime> s_current;
    private List`1<NetMQSocket> m_sockets;
    public static NetMQRuntime Current { get; }
    internal static NetMQPoller Poller { get; }
    private static NetMQRuntime();
    public static NetMQRuntime get_Current();
    internal static NetMQPoller get_Poller();
    public void Run(Task[] tasks);
    internal void Add(NetMQSocket socket);
    internal void Remove(NetMQSocket socket);
    public void Run(CancellationToken cancellationToken, Task[] tasks);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <Run>b__13_0();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private void <Run>b__13_1(Task t);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQSelector : object {
    private List`1<Socket> m_checkRead;
    private List`1<Socket> m_checkWrite;
    private List`1<Socket> m_checkError;
    public bool Select(Item[] items, int itemsCount, long timeout);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NetMQ.NetMQSocket : object {
    private SocketBase m_socketHandle;
    private NetMQSocketEventArgs m_socketEventArgs;
    private NetMQSelector m_netMqSelector;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<NetMQSocketEventArgs> m_receiveReady;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private EventHandler`1<NetMQSocketEventArgs> m_sendReady;
    private int m_isClosed;
    [NullableAttribute("2")]
private NetMQRuntime m_runtime;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQSocketEventArgs> EventsChanged;
    [CompilerGeneratedAttribute]
private int <Errors>k__BackingField;
    [CompilerGeneratedAttribute]
private SocketOptions <Options>k__BackingField;
    internal int Errors { get; internal set; }
    public SocketOptions Options { get; }
    internal SocketBase SocketHandle { get; }
    private NetMQSocket NetMQ.ISocketPollable.Socket { get; }
    public bool HasIn { get; }
    public bool HasOut { get; }
    public bool IsDisposed { get; }
    [NullableContextAttribute("2")]
internal NetMQSocket(ZmqSocketType socketType, string connectionString, DefaultAction defaultAction);
    internal NetMQSocket(SocketBase socketHandle);
    public sealed virtual void add_ReceiveReady(EventHandler`1<NetMQSocketEventArgs> value);
    public sealed virtual void remove_ReceiveReady(EventHandler`1<NetMQSocketEventArgs> value);
    public sealed virtual void add_SendReady(EventHandler`1<NetMQSocketEventArgs> value);
    public sealed virtual void remove_SendReady(EventHandler`1<NetMQSocketEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_EventsChanged(EventHandler`1<NetMQSocketEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_EventsChanged(EventHandler`1<NetMQSocketEventArgs> value);
    private void InvokeEventsChanged();
    [CompilerGeneratedAttribute]
internal int get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(int value);
    [CompilerGeneratedAttribute]
public sealed virtual SocketOptions get_Options();
    internal SocketBase get_SocketHandle();
    private sealed virtual override NetMQSocket NetMQ.ISocketPollable.get_Socket();
    public sealed virtual void Bind(string address);
    public sealed virtual int BindRandomPort(string address);
    public sealed virtual void Connect(string address);
    public sealed virtual void Disconnect(string address);
    public sealed virtual void Unbind(string address);
    public sealed virtual void Close();
    public sealed virtual void Poll();
    public sealed virtual bool Poll(TimeSpan timeout);
    public sealed virtual PollEvents Poll(PollEvents pollEvents, TimeSpan timeout);
    internal PollEvents GetPollEvents();
    internal void InvokeEvents(object sender, PollEvents events);
    public virtual bool TryReceive(Msg& msg, TimeSpan timeout);
    public virtual bool TrySend(Msg& msg, TimeSpan timeout, bool more);
    internal void AttachToRuntime();
    internal void DetachFromRuntime();
    public sealed virtual void Monitor(string endpoint, SocketEvents events);
    public sealed virtual bool get_HasIn();
    public sealed virtual bool get_HasOut();
    internal int GetSocketOption(ZmqSocketOption option);
    internal T GetSocketOptionX(ZmqSocketOption option);
    internal TimeSpan GetSocketOptionTimeSpan(ZmqSocketOption option);
    internal long GetSocketOptionLong(ZmqSocketOption option);
    internal void SetSocketOption(ZmqSocketOption option, int value);
    internal void SetSocketOptionTimeSpan(ZmqSocketOption option, TimeSpan value);
    [NullableContextAttribute("2")]
internal void SetSocketOption(ZmqSocketOption option, object value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public sealed virtual bool get_IsDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQSocketEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQSocket <Socket>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadyToReceive>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadyToSend>k__BackingField;
    public NetMQSocket Socket { get; }
    public bool IsReadyToReceive { get; private set; }
    public bool IsReadyToSend { get; private set; }
    public NetMQSocketEventArgs(NetMQSocket socket);
    internal void Init(PollEvents events);
    [CompilerGeneratedAttribute]
public NetMQSocket get_Socket();
    [CompilerGeneratedAttribute]
public bool get_IsReadyToReceive();
    [CompilerGeneratedAttribute]
private void set_IsReadyToReceive(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReadyToSend();
    [CompilerGeneratedAttribute]
private void set_IsReadyToSend(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class NetMQ.NetMQSynchronizationContext : SynchronizationContext {
    private NetMQPoller m_poller;
    public NetMQSynchronizationContext(NetMQPoller poller);
    public virtual void Post(SendOrPostCallback d, object state);
    public virtual void Send(SendOrPostCallback d, object state);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQTimer : object {
    private NetMQTimerEventArgs m_timerEventArgs;
    private int m_interval;
    private bool m_enable;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private EventHandler`1<NetMQTimerEventArgs> Elapsed;
    [CompilerGeneratedAttribute]
private long <When>k__BackingField;
    public int Interval { get; public set; }
    public bool Enable { get; public set; }
    internal long When { get; internal set; }
    public NetMQTimer(TimeSpan interval);
    public NetMQTimer(int interval);
    [CompilerGeneratedAttribute]
public void add_Elapsed(EventHandler`1<NetMQTimerEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Elapsed(EventHandler`1<NetMQTimerEventArgs> value);
    public int get_Interval();
    public void set_Interval(int value);
    public bool get_Enable();
    public void set_Enable(bool value);
    [CompilerGeneratedAttribute]
internal long get_When();
    [CompilerGeneratedAttribute]
internal void set_When(long value);
    public void EnableAndReset();
    internal void InvokeElapsed(object sender);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.NetMQTimerEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private NetMQTimer <Timer>k__BackingField;
    public NetMQTimer Timer { get; }
    public NetMQTimerEventArgs(NetMQTimer timer);
    [CompilerGeneratedAttribute]
public NetMQTimer get_Timer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class NetMQ.NetworkOrderBitsConverter : object {
    public static short ToInt16(Byte[] buffer);
    public static ushort ToUInt16(Byte[] buffer, int offset);
    [NullableContextAttribute("0")]
public static ushort ToUInt16(Span`1<byte> buffer, int offset);
    public static Byte[] GetBytes(short value);
    public static void PutInt16(short value, Byte[] buffer);
    public static void PutUInt16(ushort value, Byte[] buffer, int offset);
    [NullableContextAttribute("0")]
public static void PutUInt16(ushort value, Span`1<byte> buffer, int offset);
    public static int ToInt32(Byte[] buffer, int offset);
    [NullableContextAttribute("0")]
public static int ToInt32(Span`1<byte> buffer);
    public static Byte[] GetBytes(int value);
    public static void PutInt32(int value, Byte[] buffer, int offset);
    [NullableContextAttribute("0")]
public static void PutInt32(int value, Span`1<byte> buffer);
    public static long ToInt64(Byte[] buffer);
    [NullableContextAttribute("0")]
public static long ToInt64(Span`1<byte> buffer);
    public static Byte[] GetBytes(long value);
    public static void PutInt64(long value, Byte[] buffer);
    [NullableContextAttribute("0")]
public static void PutInt64(long value, Span`1<byte> buffer);
    [NullableContextAttribute("0")]
public static void PutUInt64(ulong value, Span`1<byte> buffer);
    public static void PutUInt64(ulong value, Byte[] buffer, int offset);
    public static ulong ToUInt64(Byte[] buffer, int offset);
    [NullableContextAttribute("0")]
public static ulong ToUInt64(Span`1<byte> buffer, int offset);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.OutgoingSocketExtensions : object {
    [ExtensionAttribute]
public static void Send(IOutgoingSocket socket, Msg& msg, bool more);
    [ExtensionAttribute]
public static void SendFrame(IOutgoingSocket socket, Byte[] data, bool more);
    [ExtensionAttribute]
public static void SendFrame(IOutgoingSocket socket, Byte[] data, int length, bool more);
    [ExtensionAttribute]
public static IOutgoingSocket SendMoreFrame(IOutgoingSocket socket, Byte[] data);
    [ExtensionAttribute]
public static IOutgoingSocket SendMoreFrame(IOutgoingSocket socket, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, TimeSpan timeout, Byte[] data, int length, bool more);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, TimeSpan timeout, Byte[] data, bool more);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, Byte[] data, bool more);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, Byte[] data, int length, bool more);
    [ExtensionAttribute]
public static void SendMultipartBytes(IOutgoingSocket socket, Byte[][] frames);
    [ExtensionAttribute]
public static void SendMultipartBytes(IOutgoingSocket socket, IEnumerable`1<Byte[]> frames);
    [ExtensionAttribute]
public static bool TrySendMultipartBytes(IOutgoingSocket socket, TimeSpan timeout, Byte[][] frames);
    [ExtensionAttribute]
public static bool TrySendMultipartBytes(IOutgoingSocket socket, TimeSpan timeout, IEnumerable`1<Byte[]> frames);
    [ExtensionAttribute]
public static bool TrySendMultipartBytes(IOutgoingSocket socket, Byte[][] frames);
    [ExtensionAttribute]
public static bool TrySendMultipartBytes(IOutgoingSocket socket, IEnumerable`1<Byte[]> frames);
    [ExtensionAttribute]
public static void SendFrame(IOutgoingSocket socket, string message, bool more);
    [ExtensionAttribute]
public static IOutgoingSocket SendMoreFrame(IOutgoingSocket socket, string message);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, TimeSpan timeout, string message, bool more);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, string message, bool more);
    [ExtensionAttribute]
public static void SendMultipartMessage(IOutgoingSocket socket, NetMQMessage message);
    [ExtensionAttribute]
public static bool TrySendMultipartMessage(IOutgoingSocket socket, TimeSpan timeout, NetMQMessage message);
    [ExtensionAttribute]
public static bool TrySendMultipartMessage(IOutgoingSocket socket, NetMQMessage message);
    [ExtensionAttribute]
public static void SendFrameEmpty(IOutgoingSocket socket, bool more);
    [ExtensionAttribute]
public static IOutgoingSocket SendMoreFrameEmpty(IOutgoingSocket socket);
    [ExtensionAttribute]
public static bool TrySendFrameEmpty(IOutgoingSocket socket, TimeSpan timeout, bool more);
    [ExtensionAttribute]
public static bool TrySendFrameEmpty(IOutgoingSocket socket, bool more);
    [ExtensionAttribute]
private static void Signal(IOutgoingSocket socket, byte status);
    [ExtensionAttribute]
private static bool TrySignal(IOutgoingSocket socket, byte status);
    [ExtensionAttribute]
public static void SignalOK(IOutgoingSocket socket);
    [ExtensionAttribute]
public static bool TrySignalOK(IOutgoingSocket socket);
    [ExtensionAttribute]
public static void SignalError(IOutgoingSocket socket);
    [ExtensionAttribute]
public static bool TrySignalError(IOutgoingSocket socket);
    [ExtensionAttribute]
public static void SendMoreFrame(IOutgoingSocket socket, RoutingKey routingKey);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, RoutingKey routingKey);
    [ExtensionAttribute]
public static bool TrySendFrame(IOutgoingSocket socket, TimeSpan timeout, RoutingKey routingKey);
    [ExtensionAttribute]
public static IOutgoingSocket SendEmptyRoutingKeys(IOutgoingSocket socket);
    [ExtensionAttribute]
public static IOutgoingSocket SendRoutingKeys(IOutgoingSocket socket, RoutingKey[] routingKeys);
    [ExtensionAttribute]
public static IOutgoingSocket SendRoutingKeys(IOutgoingSocket socket, IEnumerable`1<RoutingKey> routingKeys);
    [ExtensionAttribute]
public static bool TrySendRoutingKeys(IOutgoingSocket socket, IEnumerable`1<RoutingKey> routingKeys);
    [ExtensionAttribute]
public static bool TrySendRoutingKeys(IOutgoingSocket socket, TimeSpan timeout, IEnumerable`1<RoutingKey> routingKeys);
}
[FlagsAttribute]
public enum NetMQ.PollEvents : Enum {
    public int value__;
    public static PollEvents None;
    public static PollEvents PollIn;
    public static PollEvents PollOut;
    public static PollEvents PollError;
}
[ExtensionAttribute]
public static class NetMQ.PollEventsExtensions : object {
    [ExtensionAttribute]
public static bool HasIn(PollEvents pollEvents);
    [ExtensionAttribute]
public static bool HasOut(PollEvents pollEvents);
    [ExtensionAttribute]
public static bool HasError(PollEvents pollEvents);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.ProtocolNotSupportedException : NetMQException {
    internal ProtocolNotSupportedException(Exception innerException, string message);
    internal ProtocolNotSupportedException(string message);
    [NullableContextAttribute("1")]
protected ProtocolNotSupportedException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Proxy : object {
    private NetMQSocket m_frontend;
    private NetMQSocket m_backend;
    [NullableAttribute("2")]
private NetMQSocket m_controlIn;
    [NullableAttribute("2")]
private NetMQSocket m_controlOut;
    [NullableAttribute("2")]
private INetMQPoller m_poller;
    private bool m_externalPoller;
    private int m_state;
    private static int StateStopped;
    private static int StateStarting;
    private static int StateStarted;
    private static int StateStopping;
    [NullableContextAttribute("2")]
public Proxy(NetMQSocket frontend, NetMQSocket backend, NetMQSocket controlIn, NetMQSocket controlOut, INetMQPoller poller);
    public Proxy(NetMQSocket frontend, NetMQSocket backend, NetMQSocket control, INetMQPoller poller);
    public void Start();
    public void Stop();
    private void OnFrontendReady(object sender, NetMQSocketEventArgs e);
    private void OnBackendReady(object sender, NetMQSocketEventArgs e);
    private static void ProxyBetween(IReceivingSocket from, IOutgoingSocket to, IOutgoingSocket control);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.ReceiveThreadSafeSocketExtensions : object {
    [ExtensionAttribute]
public static Byte[] ReceiveBytes(IThreadSafeInSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveBytes(IThreadSafeInSocket socket, Byte[]& bytes);
    [ExtensionAttribute]
public static bool TryReceiveBytes(IThreadSafeInSocket socket, TimeSpan timeout, Byte[]& bytes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<Byte[]> ReceiveBytesAsync(IThreadSafeInSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.ReceiveThreadSafeSocketExtensions/<ReceiveBytesAsyncEnumerable>d__4")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<Byte[]> ReceiveBytesAsyncEnumerable(IThreadSafeInSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string ReceiveString(IThreadSafeInSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static string ReceiveString(IThreadSafeInSocket socket, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveString(IThreadSafeInSocket socket, String& str);
    [ExtensionAttribute]
public static bool TryReceiveString(IThreadSafeInSocket socket, Encoding encoding, String& str);
    [ExtensionAttribute]
public static bool TryReceiveString(IThreadSafeInSocket socket, TimeSpan timeout, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveString(IThreadSafeInSocket socket, TimeSpan timeout, Encoding encoding, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<string> ReceiveStringAsync(IThreadSafeInSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.ReceiveThreadSafeSocketExtensions/<ReceiveStringAsyncEnumerable>d__12")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<string> ReceiveStringAsyncEnumerable(IThreadSafeInSocket socket, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.ReceivingSocketExtensions : object {
    [ExtensionAttribute]
public static void Receive(IReceivingSocket socket, Msg& msg);
    [ExtensionAttribute]
public static Byte[] ReceiveFrameBytes(IReceivingSocket socket);
    [ExtensionAttribute]
public static Byte[] ReceiveFrameBytes(IReceivingSocket socket, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameBytes(IReceivingSocket socket, Byte[]& bytes);
    [ExtensionAttribute]
public static bool TryReceiveFrameBytes(IReceivingSocket socket, Byte[]& bytes, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameBytes(IReceivingSocket socket, TimeSpan timeout, Byte[]& bytes);
    [ExtensionAttribute]
public static bool TryReceiveFrameBytes(IReceivingSocket socket, TimeSpan timeout, Byte[]& bytes, Boolean& more);
    [ExtensionAttribute]
public static List`1<Byte[]> ReceiveMultipartBytes(IReceivingSocket socket, int expectedFrameCount);
    [ExtensionAttribute]
public static void ReceiveMultipartBytes(IReceivingSocket socket, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartBytes(IReceivingSocket socket, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartBytes(IReceivingSocket socket, TimeSpan timeout, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static string ReceiveFrameString(IReceivingSocket socket);
    [ExtensionAttribute]
public static string ReceiveFrameString(IReceivingSocket socket, Boolean& more);
    [ExtensionAttribute]
public static string ReceiveFrameString(IReceivingSocket socket, Encoding encoding);
    [ExtensionAttribute]
public static string ReceiveFrameString(IReceivingSocket socket, Encoding encoding, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, String& frameString);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, String& frameString, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, Encoding encoding, String& frameString);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, Encoding encoding, String& frameString, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, TimeSpan timeout, String& frameString);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, TimeSpan timeout, String& frameString, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, TimeSpan timeout, Encoding encoding, String& frameString);
    [ExtensionAttribute]
public static bool TryReceiveFrameString(IReceivingSocket socket, TimeSpan timeout, Encoding encoding, String& frameString, Boolean& more);
    [ExtensionAttribute]
public static List`1<string> ReceiveMultipartStrings(IReceivingSocket socket, int expectedFrameCount);
    [ExtensionAttribute]
public static List`1<string> ReceiveMultipartStrings(IReceivingSocket socket, Encoding encoding, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartStrings(IReceivingSocket socket, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartStrings(IReceivingSocket socket, Encoding encoding, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartStrings(IReceivingSocket socket, TimeSpan timeout, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartStrings(IReceivingSocket socket, TimeSpan timeout, Encoding encoding, List`1& frames, int expectedFrameCount);
    [ExtensionAttribute]
public static NetMQMessage ReceiveMultipartMessage(IReceivingSocket socket, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartMessage(IReceivingSocket socket, NetMQMessage& message, int expectedFrameCount);
    [ExtensionAttribute]
public static bool TryReceiveMultipartMessage(IReceivingSocket socket, TimeSpan timeout, NetMQMessage& message, int expectedFrameCount);
    [ExtensionAttribute]
public static bool ReceiveSignal(IReceivingSocket socket);
    [ExtensionAttribute]
public static bool TryReceiveSignal(IReceivingSocket socket, Boolean& signal);
    [ExtensionAttribute]
public static bool TryReceiveSignal(IReceivingSocket socket, TimeSpan timeout, Boolean& signal);
    [ExtensionAttribute]
public static void SkipFrame(IReceivingSocket socket);
    [ExtensionAttribute]
public static void SkipFrame(IReceivingSocket socket, Boolean& more);
    [ExtensionAttribute]
public static bool TrySkipFrame(IReceivingSocket socket);
    [ExtensionAttribute]
public static bool TrySkipFrame(IReceivingSocket socket, Boolean& more);
    [ExtensionAttribute]
public static bool TrySkipFrame(IReceivingSocket socket, TimeSpan timeout);
    [ExtensionAttribute]
public static bool TrySkipFrame(IReceivingSocket socket, TimeSpan timeout, Boolean& more);
    [ExtensionAttribute]
public static void SkipMultipartMessage(IReceivingSocket socket);
    [ExtensionAttribute]
public static bool TrySkipMultipartMessage(IReceivingSocket socket);
    [ExtensionAttribute]
public static bool TrySkipMultipartMessage(IReceivingSocket socket, TimeSpan timeout);
    [ExtensionAttribute]
public static RoutingKey ReceiveRoutingKey(IReceivingSocket socket);
    [ExtensionAttribute]
public static RoutingKey ReceiveRoutingKey(IReceivingSocket socket, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKey(IReceivingSocket socket, RoutingKey& routingKey);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKey(IReceivingSocket socket, RoutingKey& routingKey, Boolean& more);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKey(IReceivingSocket socket, TimeSpan timeout, RoutingKey& routingKey);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKey(IReceivingSocket socket, TimeSpan timeout, RoutingKey& routingKey, Boolean& more);
    [ExtensionAttribute]
public static IEnumerable`1<RoutingKey> ReceiveRoutingKeys(IReceivingSocket socket);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKeys(IReceivingSocket socket, IEnumerable`1& routingKeys);
    [ExtensionAttribute]
public static bool TryReceiveRoutingKeys(IReceivingSocket socket, TimeSpan timeout, IEnumerable`1& routingKeys);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.RoutingIdSocketExtensions : object {
    [ExtensionAttribute]
public static void Send(IRoutingIdSocket socket, UInt32 routingId, Byte[] data);
    [ExtensionAttribute]
public static void Send(IRoutingIdSocket socket, UInt32 routingId, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, TimeSpan timeout, UInt32 routingId, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, TimeSpan timeout, UInt32 routingId, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, UInt32 routingId, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, UInt32 routingId, Byte[] data, int length);
    [ExtensionAttribute]
public static ValueTask SendAsync(IRoutingIdSocket socket, UInt32 routingId, Byte[] data);
    [ExtensionAttribute]
public static ValueTask SendAsync(IRoutingIdSocket socket, UInt32 routingId, Byte[] data, int length);
    [ExtensionAttribute]
public static void Send(IRoutingIdSocket socket, UInt32 routingId, string message);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, TimeSpan timeout, UInt32 routingId, string message);
    [ExtensionAttribute]
public static bool TrySend(IRoutingIdSocket socket, UInt32 routingId, string message);
    [ExtensionAttribute]
public static ValueTask SendAsync(IRoutingIdSocket socket, UInt32 routingId, string message);
    [ExtensionAttribute]
public static ValueTuple`2<UInt32, Byte[]> ReceiveBytes(IRoutingIdSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveBytes(IRoutingIdSocket socket, UInt32& routingId, Byte[]& bytes);
    [ExtensionAttribute]
public static bool TryReceiveBytes(IRoutingIdSocket socket, TimeSpan timeout, UInt32& routingId, Byte[]& bytes, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<UInt32, Byte[]>> ReceiveBytesAsync(IRoutingIdSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.RoutingIdSocketExtensions/<ReceiveBytesAsyncEnumerable>d__16")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<ValueTuple`2<UInt32, Byte[]>> ReceiveBytesAsyncEnumerable(IRoutingIdSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTuple`2<UInt32, string> ReceiveString(IRoutingIdSocket socket, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTuple`2<UInt32, string> ReceiveString(IRoutingIdSocket socket, Encoding encoding, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveString(IRoutingIdSocket socket, UInt32& routingId, String& str);
    [ExtensionAttribute]
public static bool TryReceiveString(IRoutingIdSocket socket, Encoding encoding, UInt32& routingId, String& str);
    [ExtensionAttribute]
public static bool TryReceiveString(IRoutingIdSocket socket, TimeSpan timeout, UInt32& routingId, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static bool TryReceiveString(IRoutingIdSocket socket, TimeSpan timeout, Encoding encoding, UInt32& routingId, String& str, CancellationToken cancellationToken);
    [ExtensionAttribute]
public static ValueTask`1<ValueTuple`2<UInt32, string>> ReceiveStringAsync(IRoutingIdSocket socket, CancellationToken cancellationToken);
    [AsyncIteratorStateMachineAttribute("NetMQ.RoutingIdSocketExtensions/<ReceiveStringAsyncEnumerable>d__24")]
[ExtensionAttribute]
public static IAsyncEnumerable`1<ValueTuple`2<UInt32, string>> ReceiveStringAsyncEnumerable(IRoutingIdSocket socket, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class NetMQ.RoutingKey : ValueType {
    private Byte[] bytes;
    private static UInt32 C1;
    private static UInt32 C2;
    internal Byte[] Bytes { get; }
    public RoutingKey(Byte[] array);
    public RoutingKey(string b64);
    public RoutingKey(long value);
    internal Byte[] get_Bytes();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(Byte[] x);
    public sealed virtual bool Equals(RoutingKey x);
    public virtual int GetHashCode();
    public virtual string ToString();
}
public static class NetMQ.SendReceiveConstants : object {
    [NullableAttribute("1")]
public static Encoding DefaultEncoding;
    public static TimeSpan InfiniteTimeout;
    private static SendReceiveConstants();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.SendThreadSafeSocketExtensions : object {
    [ExtensionAttribute]
public static void Send(IThreadSafeOutSocket socket, Byte[] data);
    [ExtensionAttribute]
public static void Send(IThreadSafeOutSocket socket, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, TimeSpan timeout, Byte[] data, int length);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, TimeSpan timeout, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, Byte[] data);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, Byte[] data, int length);
    [ExtensionAttribute]
public static ValueTask SendAsync(IThreadSafeOutSocket socket, Byte[] data);
    [ExtensionAttribute]
public static ValueTask SendAsync(IThreadSafeOutSocket socket, Byte[] data, int length);
    [ExtensionAttribute]
public static void Send(IThreadSafeOutSocket socket, string message);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, TimeSpan timeout, string message);
    [ExtensionAttribute]
public static bool TrySend(IThreadSafeOutSocket socket, string message);
    [ExtensionAttribute]
public static ValueTask SendAsync(IThreadSafeOutSocket socket, string message);
}
public class NetMQ.ShimAction : MulticastDelegate {
    public ShimAction(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(PairSocket shim);
    public virtual IAsyncResult BeginInvoke(PairSocket shim, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class NetMQ.ShimAction`1 : MulticastDelegate {
    public ShimAction`1(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual void Invoke(PairSocket shim, T state);
    public virtual IAsyncResult BeginInvoke(PairSocket shim, T state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[FlagsAttribute]
public enum NetMQ.SocketEvents : Enum {
    public int value__;
    public static SocketEvents Connected;
    public static SocketEvents ConnectDelayed;
    public static SocketEvents ConnectRetried;
    public static SocketEvents Listening;
    public static SocketEvents BindFailed;
    public static SocketEvents Accepted;
    public static SocketEvents AcceptFailed;
    public static SocketEvents Closed;
    public static SocketEvents CloseFailed;
    public static SocketEvents Disconnected;
    public static SocketEvents All;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.SocketOptions : object {
    [NullableAttribute("1")]
private NetMQSocket m_socket;
    public long Affinity { get; public set; }
    public Byte[] Identity { get; public set; }
    public int MulticastRate { get; public set; }
    public TimeSpan MulticastRecoveryInterval { get; public set; }
    public int SendBuffer { get; public set; }
    public int ReceiveBuffer { get; public set; }
    public bool ReceiveMore { get; }
    public TimeSpan Linger { get; public set; }
    public TimeSpan ReconnectInterval { get; public set; }
    public TimeSpan ReconnectIntervalMax { get; public set; }
    public int Backlog { get; public set; }
    public long MaxMsgSize { get; public set; }
    public int SendHighWatermark { get; public set; }
    public int ReceiveHighWatermark { get; public set; }
    public int SendLowWatermark { get; public set; }
    public int ReceiveLowWatermark { get; public set; }
    public int MulticastHops { get; public set; }
    public bool IPv4Only { get; public set; }
    public string LastEndpoint { get; }
    unknown bool RouterMandatory {public set; }
    public bool TcpKeepalive { get; public set; }
    public TimeSpan TcpKeepaliveIdle { get; public set; }
    public TimeSpan TcpKeepaliveInterval { get; public set; }
    public bool DelayAttachOnConnect { get; public set; }
    unknown bool XPubVerbose {public set; }
    unknown bool XPubBroadcast {public set; }
    unknown bool RouterRawSocket {public set; }
    unknown bool RouterHandover {public set; }
    public Endianness Endian { get; public set; }
    unknown bool ManualPublisher {public set; }
    public bool DisableTimeWait { get; public set; }
    public Byte[] LastPeerRoutingId { get; }
    public int PgmMaxTransportServiceDataUnitLength { get; public set; }
    public bool CurveServer { get; public set; }
    [NullableAttribute("1")]
unknown NetMQCertificate CurveCertificate {public set; }
    public Byte[] CurveServerKey { get; public set; }
    [NullableAttribute("1")]
unknown NetMQCertificate CurveServerCertificate {public set; }
    public TimeSpan HeartbeatTtl { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public TimeSpan HeartbeatTimeout { get; public set; }
    [NullableAttribute("1")]
unknown Byte[] HelloMessage {public set; }
    public bool Relaxed { get; public set; }
    public bool Correlate { get; public set; }
    [NullableContextAttribute("1")]
public SocketOptions(NetMQSocket socket);
    public long get_Affinity();
    public void set_Affinity(long value);
    public Byte[] get_Identity();
    public void set_Identity(Byte[] value);
    public int get_MulticastRate();
    public void set_MulticastRate(int value);
    public TimeSpan get_MulticastRecoveryInterval();
    public void set_MulticastRecoveryInterval(TimeSpan value);
    public int get_SendBuffer();
    public void set_SendBuffer(int value);
    public int get_ReceiveBuffer();
    public void set_ReceiveBuffer(int value);
    public bool get_ReceiveMore();
    public TimeSpan get_Linger();
    public void set_Linger(TimeSpan value);
    public TimeSpan get_ReconnectInterval();
    public void set_ReconnectInterval(TimeSpan value);
    public TimeSpan get_ReconnectIntervalMax();
    public void set_ReconnectIntervalMax(TimeSpan value);
    public int get_Backlog();
    public void set_Backlog(int value);
    public long get_MaxMsgSize();
    public void set_MaxMsgSize(long value);
    public int get_SendHighWatermark();
    public void set_SendHighWatermark(int value);
    public int get_ReceiveHighWatermark();
    public void set_ReceiveHighWatermark(int value);
    public int get_SendLowWatermark();
    public void set_SendLowWatermark(int value);
    public int get_ReceiveLowWatermark();
    public void set_ReceiveLowWatermark(int value);
    public int get_MulticastHops();
    public void set_MulticastHops(int value);
    public bool get_IPv4Only();
    public void set_IPv4Only(bool value);
    public string get_LastEndpoint();
    public void set_RouterMandatory(bool value);
    public bool get_TcpKeepalive();
    public void set_TcpKeepalive(bool value);
    public TimeSpan get_TcpKeepaliveIdle();
    public void set_TcpKeepaliveIdle(TimeSpan value);
    public TimeSpan get_TcpKeepaliveInterval();
    public void set_TcpKeepaliveInterval(TimeSpan value);
    public bool get_DelayAttachOnConnect();
    public void set_DelayAttachOnConnect(bool value);
    public void set_XPubVerbose(bool value);
    public void set_XPubBroadcast(bool value);
    public void set_RouterRawSocket(bool value);
    public void set_RouterHandover(bool value);
    public Endianness get_Endian();
    public void set_Endian(Endianness value);
    public void set_ManualPublisher(bool value);
    public bool get_DisableTimeWait();
    public void set_DisableTimeWait(bool value);
    public Byte[] get_LastPeerRoutingId();
    public int get_PgmMaxTransportServiceDataUnitLength();
    public void set_PgmMaxTransportServiceDataUnitLength(int value);
    public bool get_CurveServer();
    public void set_CurveServer(bool value);
    [NullableContextAttribute("1")]
public void set_CurveCertificate(NetMQCertificate value);
    public Byte[] get_CurveServerKey();
    public void set_CurveServerKey(Byte[] value);
    [NullableContextAttribute("1")]
public void set_CurveServerCertificate(NetMQCertificate value);
    public TimeSpan get_HeartbeatTtl();
    public void set_HeartbeatTtl(TimeSpan value);
    public TimeSpan get_HeartbeatInterval();
    public void set_HeartbeatInterval(TimeSpan value);
    public TimeSpan get_HeartbeatTimeout();
    public void set_HeartbeatTimeout(TimeSpan value);
    [NullableContextAttribute("1")]
public void set_HelloMessage(Byte[] value);
    public bool get_Relaxed();
    public void set_Relaxed(bool value);
    public bool get_Correlate();
    public void set_Correlate(bool value);
}
public class NetMQ.Sockets.ClientSocket : ThreadSafeSocket {
}
public class NetMQ.Sockets.DealerSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public DealerSocket(string connectionString);
    [NullableContextAttribute("1")]
internal DealerSocket(SocketBase socketHandle);
}
public class NetMQ.Sockets.DishSocket : ThreadSafeSocket {
    [NullableContextAttribute("1")]
public void Join(string group);
    [NullableContextAttribute("1")]
public void Leave(string group);
}
public class NetMQ.Sockets.GatherSocket : ThreadSafeSocket {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.PairSocket : NetMQSocket {
    private static int s_sequence;
    [NullableContextAttribute("2")]
public PairSocket(string connectionString);
    internal PairSocket(SocketBase socketHandle);
    public static void CreateSocketPair(PairSocket& socket1, PairSocket& socket2);
    public static void CreateSocketPair(PairSocket& socket1, PairSocket& socket2, Action`1<PairSocket> initSocket1, Action`1<PairSocket> initSocket2);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.PeerSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public PeerSocket(string connectionString);
    internal PeerSocket(SocketBase socketHandle);
    public Byte[] ConnectPeer(string address);
}
public class NetMQ.Sockets.PublisherSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public PublisherSocket(string connectionString);
    [NullableContextAttribute("1")]
internal PublisherSocket(SocketBase socketHandle);
    public virtual bool TryReceive(Msg& msg, TimeSpan timeout);
}
public class NetMQ.Sockets.PullSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public PullSocket(string connectionString);
    [NullableContextAttribute("1")]
internal PullSocket(SocketBase socketHandle);
    public virtual bool TrySend(Msg& msg, TimeSpan timeout, bool more);
}
public class NetMQ.Sockets.PushSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public PushSocket(string connectionString);
    [NullableContextAttribute("1")]
internal PushSocket(SocketBase socketHandle);
    public virtual bool TryReceive(Msg& msg, TimeSpan timeout);
}
public class NetMQ.Sockets.RadioSocket : ThreadSafeSocket {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.RequestSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public RequestSocket(string connectionString);
    internal RequestSocket(SocketBase socketHandle);
    public static NetMQMessage RequestResponseMultipartMessageWithRetry(string address, NetMQMessage requestMessage, int numTries, TimeSpan requestTimeout, PublisherSocket progressPublisher);
    public static string RequestResponseStringWithRetry(string address, string requestString, int numTries, TimeSpan requestTimeout, PublisherSocket progressPublisher);
}
public class NetMQ.Sockets.ResponseSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public ResponseSocket(string connectionString);
    [NullableContextAttribute("1")]
internal ResponseSocket(SocketBase socketHandle);
}
public class NetMQ.Sockets.RouterSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public RouterSocket(string connectionString);
    [NullableContextAttribute("1")]
internal RouterSocket(SocketBase socketHandle);
}
public class NetMQ.Sockets.ScatterSocket : ThreadSafeSocket {
}
public class NetMQ.Sockets.ServerSocket : ThreadSafeSocket {
}
public class NetMQ.Sockets.StreamSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public StreamSocket(string connectionString);
    [NullableContextAttribute("1")]
internal StreamSocket(SocketBase socketHandle);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.SubscriberSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public SubscriberSocket(string connectionString);
    internal SubscriberSocket(SocketBase socketHandle);
    public virtual bool TrySend(Msg& msg, TimeSpan timeout, bool more);
    public virtual void Subscribe(string topic);
    public virtual void Subscribe(string topic, Encoding encoding);
    public virtual void Subscribe(Byte[] topic);
    public virtual void SubscribeToAnyTopic();
    public virtual void Unsubscribe(string topic);
    public virtual void Unsubscribe(string topic, Encoding encoding);
    public virtual void Unsubscribe(Byte[] topic);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.XPublisherSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public XPublisherSocket(string connectionString);
    internal XPublisherSocket(SocketBase socketHandle);
    public virtual void Subscribe(string topic);
    public virtual void Subscribe(string topic, Encoding encoding);
    public virtual void Subscribe(Byte[] topic);
    public virtual void Unsubscribe(string topic);
    public virtual void Unsubscribe(string topic, Encoding encoding);
    public virtual void Unsubscribe(Byte[] topic);
    public void ClearWelcomeMessage();
    public void SetWelcomeMessage(string welcomeMessage, Encoding encoding);
    public void SetWelcomeMessage(string welcomeMessage);
    public void SetWelcomeMessage(Byte[] welcomeMessage);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.Sockets.XSubscriberSocket : NetMQSocket {
    [NullableContextAttribute("2")]
public XSubscriberSocket(string connectionString);
    internal XSubscriberSocket(SocketBase socketHandle);
    public virtual void Subscribe(string topic);
    public virtual void Subscribe(string topic, Encoding encoding);
    public virtual void Subscribe(Byte[] topic);
    public virtual void SubscribeToAnyTopic();
    public virtual void Unsubscribe(string topic);
    public virtual void Unsubscribe(string topic, Encoding encoding);
    public virtual void Unsubscribe(Byte[] topic);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal static class NetMQ.Strings : object {
    public static bool IsNullOrEmpty(string s);
    public static bool IsNullOrWhiteSpace(string s);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class NetMQ.TerminatingException : NetMQException {
    internal TerminatingException(Exception innerException, string message);
    public TerminatingException(string message);
    [NullableContextAttribute("1")]
protected TerminatingException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class NetMQ.ThreadSafeSocket : object {
    internal SocketBase m_socketHandle;
    private int m_isClosed;
    [CompilerGeneratedAttribute]
private ThreadSafeSocketOptions <Options>k__BackingField;
    public ThreadSafeSocketOptions Options { get; }
    public bool IsDisposed { get; }
    protected internal ThreadSafeSocket(ZmqSocketType socketType);
    [CompilerGeneratedAttribute]
public ThreadSafeSocketOptions get_Options();
    public virtual bool TrySend(Msg& msg, TimeSpan timeout);
    public virtual bool TryReceive(Msg& msg, TimeSpan timeout, CancellationToken cancellationToken);
    public void Bind(string address);
    public int BindRandomPort(string address);
    public void Connect(string address);
    public void Disconnect(string address);
    public void Unbind(string address);
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public bool get_IsDisposed();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class NetMQ.ThreadSafeSocketExtensions : object {
    [ExtensionAttribute]
public static void Send(IThreadSafeSocket socket, Msg& msg);
    [ExtensionAttribute]
public static void Receive(IThreadSafeSocket socket, Msg& msg, CancellationToken cancellationToken);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class NetMQ.ThreadSafeSocketOptions : object {
    private SocketBase m_socket;
    public long Affinity { get; public set; }
    public int SendBuffer { get; public set; }
    public int ReceiveBuffer { get; public set; }
    public TimeSpan Linger { get; public set; }
    public TimeSpan ReconnectInterval { get; public set; }
    public TimeSpan ReconnectIntervalMax { get; public set; }
    public int Backlog { get; public set; }
    public long MaxMsgSize { get; public set; }
    public int SendHighWatermark { get; public set; }
    public int ReceiveHighWatermark { get; public set; }
    public int SendLowWatermark { get; public set; }
    public int ReceiveLowWatermark { get; public set; }
    public bool IPv4Only { get; public set; }
    [NullableAttribute("2")]
public string LastEndpoint { get; }
    public bool DelayAttachOnConnect { get; public set; }
    public bool DisableTimeWait { get; public set; }
    public bool CurveServer { get; public set; }
    unknown NetMQCertificate CurveCertificate {public set; }
    [NullableAttribute("2")]
public Byte[] CurveServerKey { get; public set; }
    unknown NetMQCertificate CurveServerCertificate {public set; }
    public TimeSpan HeartbeatTtl { get; public set; }
    public TimeSpan HeartbeatInterval { get; public set; }
    public TimeSpan HeartbeatTimeout { get; public set; }
    unknown Byte[] HelloMessage {public set; }
    internal ThreadSafeSocketOptions(SocketBase socket);
    internal void SetSocketOption(ZmqSocketOption option, int value);
    internal void SetSocketOptionTimeSpan(ZmqSocketOption option, TimeSpan value);
    internal int GetSocketOption(ZmqSocketOption option);
    internal T GetSocketOptionX(ZmqSocketOption option);
    internal TimeSpan GetSocketOptionTimeSpan(ZmqSocketOption option);
    internal long GetSocketOptionLong(ZmqSocketOption option);
    internal void SetSocketOption(ZmqSocketOption option, object value);
    public long get_Affinity();
    public void set_Affinity(long value);
    public int get_SendBuffer();
    public void set_SendBuffer(int value);
    public int get_ReceiveBuffer();
    public void set_ReceiveBuffer(int value);
    public TimeSpan get_Linger();
    public void set_Linger(TimeSpan value);
    public TimeSpan get_ReconnectInterval();
    public void set_ReconnectInterval(TimeSpan value);
    public TimeSpan get_ReconnectIntervalMax();
    public void set_ReconnectIntervalMax(TimeSpan value);
    public int get_Backlog();
    public void set_Backlog(int value);
    public long get_MaxMsgSize();
    public void set_MaxMsgSize(long value);
    public int get_SendHighWatermark();
    public void set_SendHighWatermark(int value);
    public int get_ReceiveHighWatermark();
    public void set_ReceiveHighWatermark(int value);
    public int get_SendLowWatermark();
    public void set_SendLowWatermark(int value);
    public int get_ReceiveLowWatermark();
    public void set_ReceiveLowWatermark(int value);
    public bool get_IPv4Only();
    public void set_IPv4Only(bool value);
    [NullableContextAttribute("2")]
public string get_LastEndpoint();
    public bool get_DelayAttachOnConnect();
    public void set_DelayAttachOnConnect(bool value);
    public bool get_DisableTimeWait();
    public void set_DisableTimeWait(bool value);
    public bool get_CurveServer();
    public void set_CurveServer(bool value);
    public void set_CurveCertificate(NetMQCertificate value);
    [NullableContextAttribute("2")]
public Byte[] get_CurveServerKey();
    [NullableContextAttribute("2")]
public void set_CurveServerKey(Byte[] value);
    public void set_CurveServerCertificate(NetMQCertificate value);
    public TimeSpan get_HeartbeatTtl();
    public void set_HeartbeatTtl(TimeSpan value);
    public TimeSpan get_HeartbeatInterval();
    public void set_HeartbeatInterval(TimeSpan value);
    public TimeSpan get_HeartbeatTimeout();
    public void set_HeartbeatTimeout(TimeSpan value);
    public void set_HelloMessage(Byte[] value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class NetMQ.Utils.ArrayExtensions : object {
    [ExtensionAttribute]
public static Span`1<T> Slice(T[] array, int offset);
    [ExtensionAttribute]
public static Span`1<T> Slice(T[] array, int offset, int length);
}
public enum NetMQ.ZmqSocketType : Enum {
    public int value__;
    public static ZmqSocketType None;
    public static ZmqSocketType Pair;
    public static ZmqSocketType Pub;
    public static ZmqSocketType Sub;
    public static ZmqSocketType Req;
    public static ZmqSocketType Rep;
    public static ZmqSocketType Dealer;
    public static ZmqSocketType Router;
    public static ZmqSocketType Pull;
    public static ZmqSocketType Push;
    public static ZmqSocketType Xpub;
    public static ZmqSocketType Xsub;
    public static ZmqSocketType Stream;
    public static ZmqSocketType Server;
    public static ZmqSocketType Client;
    public static ZmqSocketType Radio;
    public static ZmqSocketType Dish;
    public static ZmqSocketType Gather;
    public static ZmqSocketType Scatter;
    public static ZmqSocketType Peer;
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
