[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CertificateCommands : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string GetPfxCertPasswordPrompt { get; }
    internal static string NoneOfTheFilesFound { get; }
    internal static string FileNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_GetPfxCertPasswordPrompt();
    internal static string get_NoneOfTheFilesFound();
    internal static string get_FileNotFound();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CertificateProviderStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CertProvidername { get; }
    internal static string CertificateNotFound { get; }
    internal static string CertificateStoreNotFound { get; }
    internal static string CertificateStoreLocationNotFound { get; }
    internal static string InvalidPath { get; }
    internal static string Action_Move { get; }
    internal static string Action_Remove { get; }
    internal static string Action_RemoveAndDeleteKey { get; }
    internal static string Action_Invoke { get; }
    internal static string MoveItemTemplate { get; }
    internal static string CannotMoveContainer { get; }
    internal static string CannotMoveCrossContext { get; }
    internal static string CannotMoveToSameStore { get; }
    internal static string CannotCreateItem { get; }
    internal static string CannotCreateUserStore { get; }
    internal static string CannotDeleteUserStore { get; }
    internal static string InvalidDestStore { get; }
    internal static string RemoveItemTemplate { get; }
    internal static string RemoveStoreTemplate { get; }
    internal static string CannotRemoveContainer { get; }
    internal static string VerboseNoPrivateKey { get; }
    internal static string UINotAllowed { get; }
    internal static string RemoteErrorMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CertProvidername();
    internal static string get_CertificateNotFound();
    internal static string get_CertificateStoreNotFound();
    internal static string get_CertificateStoreLocationNotFound();
    internal static string get_InvalidPath();
    internal static string get_Action_Move();
    internal static string get_Action_Remove();
    internal static string get_Action_RemoveAndDeleteKey();
    internal static string get_Action_Invoke();
    internal static string get_MoveItemTemplate();
    internal static string get_CannotMoveContainer();
    internal static string get_CannotMoveCrossContext();
    internal static string get_CannotMoveToSameStore();
    internal static string get_CannotCreateItem();
    internal static string get_CannotCreateUserStore();
    internal static string get_CannotDeleteUserStore();
    internal static string get_InvalidDestStore();
    internal static string get_RemoveItemTemplate();
    internal static string get_RemoveStoreTemplate();
    internal static string get_CannotRemoveContainer();
    internal static string get_VerboseNoPrivateKey();
    internal static string get_UINotAllowed();
    internal static string get_RemoteErrorMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CmsCommands : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FilePathMustBeFileSystemPath { get; }
    internal static string InputContainedNoEncryptedContent { get; }
    internal static string InputContainedNoEncryptedContentIncludeContext { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FilePathMustBeFileSystemPath();
    internal static string get_InputContainedNoEncryptedContent();
    internal static string get_InputContainedNoEncryptedContentIncludeContext();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ExecutionPolicyCommands : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExecutionPolicyOverridden { get; }
    internal static string ExecutionPolicyOverriddenRecommendedAction { get; }
    internal static string ListAndScopeSpecified { get; }
    internal static string CantSetGroupPolicy { get; }
    internal static string SetExecutionPolicyCaption { get; }
    internal static string SetExecutionPolicyQuery { get; }
    internal static string SetExecutionPolicyAccessDeniedError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExecutionPolicyOverridden();
    internal static string get_ExecutionPolicyOverriddenRecommendedAction();
    internal static string get_ListAndScopeSpecified();
    internal static string get_CantSetGroupPolicy();
    internal static string get_SetExecutionPolicyCaption();
    internal static string get_SetExecutionPolicyQuery();
    internal static string get_SetExecutionPolicyAccessDeniedError();
}
public abstract class Microsoft.PowerShell.Commands.CatalogCommandsBase : PSCmdlet {
    private string catalogFilePath;
    private String[] path;
    private string commandName;
    [ParameterAttribute]
public string CatalogFilePath { get; public set; }
    [ParameterAttribute]
public String[] Path { get; public set; }
    protected CatalogCommandsBase(string name);
    public string get_CatalogFilePath();
    public void set_CatalogFilePath(string value);
    public String[] get_Path();
    public void set_Path(String[] value);
    protected virtual void ProcessRecord();
    protected abstract virtual void PerformAction(Collection`1<string> path, string catalogFilePath);
}
public class Microsoft.PowerShell.Commands.CertificateNotFoundException : CertificateProviderItemNotFoundException {
    public CertificateNotFoundException(string message);
    public CertificateNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CertificateNotFoundException(SerializationInfo info, StreamingContext context);
    internal CertificateNotFoundException(Exception innerException);
}
[CmdletProviderAttribute("Certificate", "16")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.CertificateProvider : NavigationCmdletProvider {
    [TraceSourceAttribute("CertificateProvider", "The core command provider for certificates")]
private static PSTraceSource s_tracer;
    private bool _hasAttemptedToLoadPkiModule;
    private static object s_staticLock;
    private static List`1<X509StoreLocation> s_storeLocations;
    private static Hashtable s_pathCache;
    private static Char[] s_pathSeparators;
    private static string certPathPattern;
    private static X509NativeStore s_storeCache;
    private static Regex s_certPathRegex;
    private static Regex CertPathRegex { get; }
    private static CertificateProvider();
    private static Regex get_CertPathRegex();
    protected virtual void RemoveItem(string path, bool recurse);
    protected virtual object RemoveItemDynamicParameters(string path, bool recurse);
    protected virtual void MoveItem(string path, string destination);
    protected virtual void NewItem(string path, string type, object value);
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    protected virtual bool HasChildItems(string path);
    protected virtual bool IsValidPath(string path);
    protected virtual bool ItemExists(string path);
    protected virtual void GetItem(string path);
    protected virtual string GetParentPath(string path, string root);
    protected virtual string GetChildName(string path);
    private void AttemptToImportPkiModule();
    private static string MyGetChildName(string path);
    protected virtual void InvokeDefaultAction(string path);
    private static string EnsureDriveIsRooted(string path);
    private static ErrorRecord CreateErrorRecord(string path, CertificateProviderItem itemType);
    private void ThrowErrorRemoting(int stat);
    private void ThrowInvalidOperation(string errorId, string message);
    private void ThrowItemNotFound(string path, CertificateProviderItem itemType);
    private static string NormalizePath(string path);
    private static String[] GetPathElements(string path);
    private void DoDeleteKey(IntPtr pProvInfo);
    private void RemoveCertStore(string storeName, bool fDeleteKey, string sourcePath);
    private void RemoveCertItem(X509Certificate2 cert, bool fDeleteKey, bool fMachine, string sourcePath);
    private void DoRemove(X509Certificate2 cert, bool fDeleteKey, bool fMachine, string sourcePath);
    private static void CommitUserDS(IntPtr storeHandle);
    private void DoMove(string destination, X509Certificate2 cert, X509NativeStore store, string sourcePath);
    private object GetItemAtPath(string path, bool test, Boolean& isContainer);
    protected virtual void GetChildItems(string path, bool recurse);
    protected virtual void GetChildNames(string path, ReturnContainers returnContainers);
    protected virtual bool IsItemContainer(string path);
    protected virtual object GetItemDynamicParameters(string path);
    protected virtual object GetChildItemsDynamicParameters(string path, bool recurse);
    private void GetChildItemsOrNames(string path, bool recurse, ReturnContainers returnContainers, bool returnNames, CertificateFilterInfo filter);
    private static string GetCertName(X509Certificate2 cert);
    private void GetCertificatesOrNames(string path, String[] pathElements, bool returnNames, CertificateFilterInfo filter);
    private X509StoreLocation GetStoreLocation(string path);
    private X509NativeStore GetStore(string path, bool test, String[] pathElements);
    private X509NativeStore GetStore(string storePath, string storeName, X509StoreLocation storeLocation);
    private void GetStoresOrNames(string path, bool recurse, bool returnNames, CertificateFilterInfo filter);
    private CertificateFilterInfo GetFilter();
    private bool IncludeArchivedCerts();
    private static bool MatchesFilter(X509Certificate2 cert, CertificateFilterInfo filter);
    internal static bool CertContainsName(X509Certificate2 cert, WildcardPattern pattern);
    internal static bool CertIsSSLServerAuthentication(X509Certificate2 cert);
    internal static bool CertContainsEku(X509Certificate2 cert, List`1<WildcardPattern> ekuPatterns);
    private static object GetCachedItem(string path);
    private static void AddItemToCache(string path, object item);
    private sealed virtual override string System.Management.Automation.Provider.ICmdletProviderSupportsHelp.GetHelpMaml(string helpItemName, string path);
}
internal class Microsoft.PowerShell.Commands.CertificateProviderDynamicParameters : object {
    private SwitchParameter _codeSigningCert;
    [CompilerGeneratedAttribute]
private SwitchParameter <DocumentEncryptionCert>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <SSLServerAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DnsName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Eku>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExpiringInDays>k__BackingField;
    [ParameterAttribute]
public SwitchParameter CodeSigningCert { get; public set; }
    [ParameterAttribute]
public SwitchParameter DocumentEncryptionCert { get; public set; }
    [ParameterAttribute]
public SwitchParameter SSLServerAuthentication { get; public set; }
    [ParameterAttribute]
public string DnsName { get; public set; }
    [ParameterAttribute]
public String[] Eku { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("1")]
public int ExpiringInDays { get; public set; }
    public SwitchParameter get_CodeSigningCert();
    public void set_CodeSigningCert(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_DocumentEncryptionCert();
    [CompilerGeneratedAttribute]
public void set_DocumentEncryptionCert(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_SSLServerAuthentication();
    [CompilerGeneratedAttribute]
public void set_SSLServerAuthentication(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_DnsName();
    [CompilerGeneratedAttribute]
public void set_DnsName(string value);
    [CompilerGeneratedAttribute]
public String[] get_Eku();
    [CompilerGeneratedAttribute]
public void set_Eku(String[] value);
    [CompilerGeneratedAttribute]
public int get_ExpiringInDays();
    [CompilerGeneratedAttribute]
public void set_ExpiringInDays(int value);
}
internal enum Microsoft.PowerShell.Commands.CertificateProviderItem : Enum {
    public int value__;
    public static CertificateProviderItem Unknown;
    public static CertificateProviderItem Certificate;
    public static CertificateProviderItem Store;
    public static CertificateProviderItem StoreLocation;
}
public class Microsoft.PowerShell.Commands.CertificateProviderItemNotFoundException : SystemException {
    public CertificateProviderItemNotFoundException(string message);
    public CertificateProviderItemNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CertificateProviderItemNotFoundException(SerializationInfo info, StreamingContext context);
    internal CertificateProviderItemNotFoundException(Exception innerException);
}
internal class Microsoft.PowerShell.Commands.CertificateStoreHandle : SafeHandle {
    public bool IsInvalid { get; }
    public IntPtr Handle { get; public set; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    public IntPtr get_Handle();
    public void set_Handle(IntPtr value);
}
public class Microsoft.PowerShell.Commands.CertificateStoreLocationNotFoundException : CertificateProviderItemNotFoundException {
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CertificateStoreLocationNotFoundException(SerializationInfo info, StreamingContext context);
    public CertificateStoreLocationNotFoundException(string message);
    public CertificateStoreLocationNotFoundException(string message, Exception innerException);
    internal CertificateStoreLocationNotFoundException(Exception innerException);
}
public class Microsoft.PowerShell.Commands.CertificateStoreNotFoundException : CertificateProviderItemNotFoundException {
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CertificateStoreNotFoundException(SerializationInfo info, StreamingContext context);
    public CertificateStoreNotFoundException(string message);
    public CertificateStoreNotFoundException(string message, Exception innerException);
    internal CertificateStoreNotFoundException(Exception innerException);
}
[CmdletAttribute("ConvertFrom", "SecureString")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.ConvertFromSecureStringCommand : ConvertFromToSecureStringCommandBase {
    [CompilerGeneratedAttribute]
private SwitchParameter <AsPlainText>k__BackingField;
    [ParameterAttribute]
public SecureString SecureString { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsPlainText { get; public set; }
    public SecureString get_SecureString();
    public void set_SecureString(SecureString value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_AsPlainText();
    [CompilerGeneratedAttribute]
public void set_AsPlainText(SwitchParameter value);
    protected virtual void ProcessRecord();
}
public abstract class Microsoft.PowerShell.Commands.ConvertFromToSecureStringCommandBase : SecureStringCommandBase {
    private SecureString _secureKey;
    private Byte[] _key;
    [ParameterAttribute]
public SecureString SecureKey { get; public set; }
    [ParameterAttribute]
public Byte[] Key { get; public set; }
    protected ConvertFromToSecureStringCommandBase(string name);
    public SecureString get_SecureKey();
    public void set_SecureKey(SecureString value);
    public Byte[] get_Key();
    public void set_Key(Byte[] value);
}
[CmdletAttribute("ConvertTo", "SecureString")]
[OutputTypeAttribute("System.Security.SecureString")]
public class Microsoft.PowerShell.Commands.ConvertToSecureStringCommand : ConvertFromToSecureStringCommandBase {
    private string _s;
    private bool _asPlainText;
    private bool _force;
    [ParameterAttribute]
public string String { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsPlainText { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public string get_String();
    public void set_String(string value);
    public SwitchParameter get_AsPlainText();
    public void set_AsPlainText(SwitchParameter value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void ProcessRecord();
}
internal static class Microsoft.PowerShell.Commands.Crypt32Helpers : object {
    private static object s_staticLock;
    internal static List`1<string> storeNames;
    private static Crypt32Helpers();
    internal static List`1<string> GetStoreNamesAtLocation(StoreLocation location);
    internal static bool CertEnumSystemStoreCallBack(string storeName, UInt32 dwFlagsNotUsed, IntPtr notUsed1, IntPtr notUsed2, IntPtr notUsed3);
}
internal static class Microsoft.PowerShell.Commands.DetectUIHelper : object {
    internal static IntPtr GetOwnerWindow(PSHost host);
}
public class Microsoft.PowerShell.Commands.DnsNameProperty : object {
    private List`1<DnsNameRepresentation> _dnsList;
    private IdnMapping idnMapping;
    private static string dnsNamePrefix;
    private static string distinguishedNamePrefix;
    public List`1<DnsNameRepresentation> DnsNameList { get; }
    public DnsNameProperty(X509Certificate2 cert);
    public List`1<DnsNameRepresentation> get_DnsNameList();
}
[IsReadOnlyAttribute]
public class Microsoft.PowerShell.Commands.DnsNameRepresentation : ValueType {
    private string _punycodeName;
    private string _unicodeName;
    public string Punycode { get; }
    public string Unicode { get; }
    public DnsNameRepresentation(string inputDnsName);
    public DnsNameRepresentation(string inputPunycodeName, string inputUnicodeName);
    public bool Equals(DnsNameRepresentation dnsName);
    public string get_Punycode();
    public string get_Unicode();
    public virtual string ToString();
}
internal static class Microsoft.PowerShell.Commands.DownLevelHelper : object {
    private static bool s_isWin8Set;
    private static bool s_isWin8;
    internal static bool IsWin8AndAbove();
    internal static bool TrustedIssuerSupported();
    internal static bool HashLookupSupported();
}
public class Microsoft.PowerShell.Commands.EnhancedKeyUsageProperty : object {
    private List`1<EnhancedKeyUsageRepresentation> _ekuList;
    public List`1<EnhancedKeyUsageRepresentation> EnhancedKeyUsageList { get; }
    public EnhancedKeyUsageProperty(X509Certificate2 cert);
    public List`1<EnhancedKeyUsageRepresentation> get_EnhancedKeyUsageList();
}
[IsReadOnlyAttribute]
public class Microsoft.PowerShell.Commands.EnhancedKeyUsageRepresentation : ValueType {
    private string _friendlyName;
    private string _oid;
    public string FriendlyName { get; }
    public string ObjectId { get; }
    public EnhancedKeyUsageRepresentation(string inputFriendlyName, string inputOid);
    public bool Equals(EnhancedKeyUsageRepresentation keyUsage);
    public string get_FriendlyName();
    public string get_ObjectId();
    public virtual string ToString();
}
[CmdletAttribute("Get", "Acl")]
public class Microsoft.PowerShell.Commands.GetAclCommand : SecurityDescriptorCommandsBase {
    private String[] _path;
    private PSObject _inputObject;
    private bool _isLiteralPath;
    private SwitchParameter _audit;
    [CompilerGeneratedAttribute]
private SwitchParameter <AllCentralAccessPolicies>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter Audit { get; public set; }
    private SwitchParameter AllCentralAccessPolicies { get; private set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public PSObject get_InputObject();
    public void set_InputObject(PSObject value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public SwitchParameter get_Audit();
    public void set_Audit(SwitchParameter value);
    [CompilerGeneratedAttribute]
private SwitchParameter get_AllCentralAccessPolicies();
    [CompilerGeneratedAttribute]
private void set_AllCentralAccessPolicies(SwitchParameter value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "AuthenticodeSignature")]
[OutputTypeAttribute("System.Management.Automation.Signature")]
public class Microsoft.PowerShell.Commands.GetAuthenticodeSignatureCommand : SignatureCommandsBase {
    protected virtual Signature PerformAction(string filePath);
    protected virtual Signature PerformAction(string sourcePathOrExtension, Byte[] content);
}
[CmdletAttribute("Get", "CmsMessage")]
[OutputTypeAttribute("System.Security.Cryptography.Pkcs.EnvelopedCms")]
public class Microsoft.PowerShell.Commands.GetCmsMessageCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    private StringBuilder _contentBuffer;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiteralPath>k__BackingField;
    private string _resolvedPath;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
public string Content { get; public set; }
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
public string LiteralPath { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_LiteralPath();
    [CompilerGeneratedAttribute]
public void set_LiteralPath(string value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Get", "Credential")]
[OutputTypeAttribute("System.Management.Automation.PSCredential")]
public class Microsoft.PowerShell.Commands.GetCredentialCommand : PSCmdlet {
    private static string credentialSet;
    private static string messageSet;
    [CompilerGeneratedAttribute]
private PSCredential <Credential>k__BackingField;
    private string _message;
    private string _userName;
    private string _title;
    [ParameterAttribute]
[ValidateNotNullAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Message { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string UserName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public PSCredential get_Credential();
    [CompilerGeneratedAttribute]
public void set_Credential(PSCredential value);
    public string get_Message();
    public void set_Message(string value);
    public string get_UserName();
    public void set_UserName(string value);
    public string get_Title();
    public void set_Title(string value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Get", "ExecutionPolicy")]
[OutputTypeAttribute("Microsoft.PowerShell.ExecutionPolicy")]
public class Microsoft.PowerShell.Commands.GetExecutionPolicyCommand : PSCmdlet {
    private ExecutionPolicyScope _executionPolicyScope;
    private bool _scopeSpecified;
    private bool _list;
    [ParameterAttribute]
public ExecutionPolicyScope Scope { get; public set; }
    [ParameterAttribute]
public SwitchParameter List { get; public set; }
    public ExecutionPolicyScope get_Scope();
    public void set_Scope(ExecutionPolicyScope value);
    public SwitchParameter get_List();
    public void set_List(SwitchParameter value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Get", "PfxCertificate")]
[OutputTypeAttribute("System.Security.Cryptography.X509Certificates.X509Certificate2")]
public class Microsoft.PowerShell.Commands.GetPfxCertificateCommand : PSCmdlet {
    private String[] _path;
    private bool _isLiteralPath;
    [CompilerGeneratedAttribute]
private SecureString <Password>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoPromptForPassword>k__BackingField;
    private List`1<string> _filesNotFound;
    [ParameterAttribute]
public String[] FilePath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public SecureString Password { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoPromptForPassword { get; public set; }
    public String[] get_FilePath();
    public void set_FilePath(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public SecureString get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(SecureString value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoPromptForPassword();
    [CompilerGeneratedAttribute]
public void set_NoPromptForPassword(SwitchParameter value);
    protected virtual void ProcessRecord();
    private static X509Certificate2 GetCertFromPfxFile(string path, SecureString password);
}
[CmdletAttribute("New", "FileCatalog")]
[OutputTypeAttribute("System.IO.FileInfo")]
public class Microsoft.PowerShell.Commands.NewFileCatalogCommand : CatalogCommandsBase {
    private int catalogVersion;
    [ParameterAttribute]
public int CatalogVersion { get; public set; }
    public int get_CatalogVersion();
    public void set_CatalogVersion(int value);
    protected virtual void PerformAction(Collection`1<string> path, string catalogFilePath);
}
[CmdletAttribute("Protect", "CmsMessage")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.ProtectCmsMessageCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private CmsMessageRecipient[] <To>k__BackingField;
    [CompilerGeneratedAttribute]
private PSObject <Content>k__BackingField;
    private PSDataCollection`1<PSObject> _inputObjects;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiteralPath>k__BackingField;
    private string _resolvedPath;
    [CompilerGeneratedAttribute]
private string <OutFile>k__BackingField;
    private string _resolvedOutFile;
    [ParameterAttribute]
public CmsMessageRecipient[] To { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
public PSObject Content { get; public set; }
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
public string OutFile { get; public set; }
    [CompilerGeneratedAttribute]
public CmsMessageRecipient[] get_To();
    [CompilerGeneratedAttribute]
public void set_To(CmsMessageRecipient[] value);
    [CompilerGeneratedAttribute]
public PSObject get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(PSObject value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_LiteralPath();
    [CompilerGeneratedAttribute]
public void set_LiteralPath(string value);
    [CompilerGeneratedAttribute]
public string get_OutFile();
    [CompilerGeneratedAttribute]
public void set_OutFile(string value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
}
internal class Microsoft.PowerShell.Commands.ProviderRemoveItemDynamicParameters : object {
    private SwitchParameter _deleteKey;
    [ParameterAttribute]
public SwitchParameter DeleteKey { get; public set; }
    public SwitchParameter get_DeleteKey();
    public void set_DeleteKey(SwitchParameter value);
}
public abstract class Microsoft.PowerShell.Commands.SecureStringCommandBase : PSCmdlet {
    private SecureString _ss;
    private string _commandName;
    protected SecureString SecureStringData { get; protected set; }
    protected SecureStringCommandBase(string name);
    protected SecureString get_SecureStringData();
    protected void set_SecureStringData(SecureString value);
}
public abstract class Microsoft.PowerShell.Commands.SecurityDescriptorCommandsBase : PSCmdlet {
    private string _filter;
    private String[] _include;
    private String[] _exclude;
    [ParameterAttribute]
public string Filter { get; public set; }
    [ParameterAttribute]
public String[] Include { get; public set; }
    [ParameterAttribute]
public String[] Exclude { get; public set; }
    internal CmdletProviderContext CmdletProviderContext { get; }
    public string get_Filter();
    public void set_Filter(string value);
    public String[] get_Include();
    public void set_Include(String[] value);
    public String[] get_Exclude();
    public void set_Exclude(String[] value);
    internal CmdletProviderContext get_CmdletProviderContext();
    internal static void AddBrokeredProperties(Collection`1<PSObject> results, bool audit, bool allCentralAccessPolicies);
    public static string GetPath(PSObject instance);
    public static string GetOwner(PSObject instance);
    public static string GetGroup(PSObject instance);
    public static AuthorizationRuleCollection GetAccess(PSObject instance);
    public static AuthorizationRuleCollection GetAudit(PSObject instance);
    public static SecurityIdentifier GetCentralAccessPolicyId(PSObject instance);
    public static string GetSddl(PSObject instance);
}
public class Microsoft.PowerShell.Commands.SendAsTrustedIssuerProperty : object {
    private static Char[] s_separators;
    private static SendAsTrustedIssuerProperty();
    public static bool ReadSendAsTrustedIssuerProperty(X509Certificate2 cert);
    public static void WriteSendAsTrustedIssuerProperty(X509Certificate2 cert, string certPath, bool addProperty);
    private static String[] GetPathElements(string path);
}
[CmdletAttribute("Set", "Acl")]
public class Microsoft.PowerShell.Commands.SetAclCommand : SecurityDescriptorCommandsBase {
    private String[] _path;
    private PSObject _inputObject;
    private bool _isLiteralPath;
    private object _securityDescriptor;
    [CompilerGeneratedAttribute]
private string <CentralAccessPolicy>k__BackingField;
    private SwitchParameter _clearCentralAccessPolicy;
    private SwitchParameter _passthru;
    [ParameterAttribute]
public String[] Path { get; public set; }
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public object AclObject { get; public set; }
    private string CentralAccessPolicy { get; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter ClearCentralAccessPolicy { get; public set; }
    [ParameterAttribute]
public SwitchParameter Passthru { get; public set; }
    public String[] get_Path();
    public void set_Path(String[] value);
    public PSObject get_InputObject();
    public void set_InputObject(PSObject value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public object get_AclObject();
    public void set_AclObject(object value);
    [CompilerGeneratedAttribute]
private string get_CentralAccessPolicy();
    public SwitchParameter get_ClearCentralAccessPolicy();
    public void set_ClearCentralAccessPolicy(SwitchParameter value);
    public SwitchParameter get_Passthru();
    public void set_Passthru(SwitchParameter value);
    private static IntPtr GetEmptySacl();
    private IntPtr GetSaclWithCapId(string capStr);
    private static IntPtr GetTokenWithEnabledPrivilege(string privilege, TOKEN_PRIVILEGE previousState);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Set", "AuthenticodeSignature")]
[OutputTypeAttribute("System.Management.Automation.Signature")]
public class Microsoft.PowerShell.Commands.SetAuthenticodeSignatureCommand : SignatureCommandsBase {
    private X509Certificate2 _certificate;
    private string _includeChain;
    private string _timestampServer;
    private string _hashAlgorithm;
    private bool _force;
    private static SigningOptionInfo[] s_sigOptionInfo;
    [ParameterAttribute]
public X509Certificate2 Certificate { get; public set; }
    [ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string IncludeChain { get; public set; }
    [ParameterAttribute]
public string TimestampServer { get; public set; }
    [ParameterAttribute]
public string HashAlgorithm { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    private static SetAuthenticodeSignatureCommand();
    public X509Certificate2 get_Certificate();
    public void set_Certificate(X509Certificate2 value);
    public string get_IncludeChain();
    public void set_IncludeChain(string value);
    public string get_TimestampServer();
    public void set_TimestampServer(string value);
    public string get_HashAlgorithm();
    public void set_HashAlgorithm(string value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual Signature PerformAction(string filePath);
    protected virtual Signature PerformAction(string sourcePathOrExtension, Byte[] content);
    private static SigningOption GetSigningOption(string optionName);
}
[CmdletAttribute("Set", "ExecutionPolicy")]
public class Microsoft.PowerShell.Commands.SetExecutionPolicyCommand : PSCmdlet {
    private ExecutionPolicy _executionPolicy;
    private ExecutionPolicyScope _executionPolicyScope;
    private SwitchParameter _force;
    [ParameterAttribute]
public ExecutionPolicy ExecutionPolicy { get; public set; }
    [ParameterAttribute]
public ExecutionPolicyScope Scope { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public ExecutionPolicy get_ExecutionPolicy();
    public void set_ExecutionPolicy(ExecutionPolicy value);
    public ExecutionPolicyScope get_Scope();
    public void set_Scope(ExecutionPolicyScope value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private bool ShouldProcessPolicyChange(string localPreference);
    private void OnAccessDeniedError(Exception exception);
}
public abstract class Microsoft.PowerShell.Commands.SignatureCommandsBase : PSCmdlet {
    private String[] _path;
    private bool _isLiteralPath;
    private Signature _signature;
    private String[] _sourcePathOrExtension;
    private Byte[] _content;
    private string _commandName;
    [ParameterAttribute]
public String[] FilePath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] LiteralPath { get; public set; }
    protected Signature Signature { get; protected set; }
    [ParameterAttribute]
public String[] SourcePathOrExtension { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Byte[] Content { get; public set; }
    protected SignatureCommandsBase(string name);
    public String[] get_FilePath();
    public void set_FilePath(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    protected Signature get_Signature();
    protected void set_Signature(Signature value);
    public String[] get_SourcePathOrExtension();
    public void set_SourcePathOrExtension(String[] value);
    public Byte[] get_Content();
    public void set_Content(Byte[] value);
    protected virtual void ProcessRecord();
    protected abstract virtual Signature PerformAction(string filePath);
    protected abstract virtual Signature PerformAction(string fileName, Byte[] content);
}
[CmdletAttribute("Test", "FileCatalog")]
[OutputTypeAttribute("System.Management.Automation.CatalogValidationStatus")]
[OutputTypeAttribute("System.Management.Automation.CatalogInformation")]
public class Microsoft.PowerShell.Commands.TestFileCatalogCommand : CatalogCommandsBase {
    private bool detailed;
    private String[] filesToSkip;
    internal WildcardPattern[] excludedPatterns;
    [ParameterAttribute]
public SwitchParameter Detailed { get; public set; }
    [ParameterAttribute]
public String[] FilesToSkip { get; public set; }
    public SwitchParameter get_Detailed();
    public void set_Detailed(SwitchParameter value);
    public String[] get_FilesToSkip();
    public void set_FilesToSkip(String[] value);
    protected virtual void PerformAction(Collection`1<string> path, string catalogFilePath);
}
[CmdletAttribute("Unprotect", "CmsMessage")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.UnprotectCmsMessageCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private string <Content>k__BackingField;
    private StringBuilder _contentBuffer;
    [CompilerGeneratedAttribute]
private PSObject <EventLogRecord>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LiteralPath>k__BackingField;
    private string _resolvedPath;
    [CompilerGeneratedAttribute]
private SwitchParameter <IncludeContext>k__BackingField;
    [CompilerGeneratedAttribute]
private CmsMessageRecipient[] <To>k__BackingField;
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyStringAttribute]
public string Content { get; public set; }
    [ParameterAttribute]
[PSTypeNameAttribute("System.Diagnostics.Eventing.Reader.EventLogRecord")]
public PSObject EventLogRecord { get; public set; }
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter IncludeContext { get; public set; }
    [ParameterAttribute]
public CmsMessageRecipient[] To { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Content();
    [CompilerGeneratedAttribute]
public void set_Content(string value);
    [CompilerGeneratedAttribute]
public PSObject get_EventLogRecord();
    [CompilerGeneratedAttribute]
public void set_EventLogRecord(PSObject value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_LiteralPath();
    [CompilerGeneratedAttribute]
public void set_LiteralPath(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IncludeContext();
    [CompilerGeneratedAttribute]
public void set_IncludeContext(SwitchParameter value);
    [CompilerGeneratedAttribute]
public CmsMessageRecipient[] get_To();
    [CompilerGeneratedAttribute]
public void set_To(CmsMessageRecipient[] value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private string Decrypt(string actualContent);
}
internal class Microsoft.PowerShell.Commands.X509NativeStore : object {
    private bool _archivedCerts;
    private X509StoreLocation _storeLocation;
    private string _storeName;
    private CertificateStoreHandle _storeHandle;
    private bool _valid;
    private bool _open;
    public IntPtr StoreHandle { get; }
    public X509StoreLocation Location { get; }
    public string StoreName { get; }
    public bool Valid { get; }
    public X509NativeStore(X509StoreLocation StoreLocation, string StoreName);
    public void Open(bool includeArchivedCerts);
    public IntPtr GetFirstCert();
    public IntPtr GetNextCert(IntPtr certContext);
    public IntPtr GetCertByName(string Name);
    public void FreeCert(IntPtr certContext);
    public IntPtr get_StoreHandle();
    public X509StoreLocation get_Location();
    public string get_StoreName();
    public bool get_Valid();
}
public class Microsoft.PowerShell.Commands.X509StoreLocation : object {
    private StoreLocation _location;
    public string LocationName { get; }
    public StoreLocation Location { get; public set; }
    public Hashtable StoreNames { get; }
    public X509StoreLocation(StoreLocation location);
    public string get_LocationName();
    public StoreLocation get_Location();
    public void set_Location(StoreLocation value);
    public Hashtable get_StoreNames();
}
internal static class Microsoft.PowerShell.SecurityUtils : object {
    internal static long GetFileSize(string filePath);
    internal static SecureString PromptForSecureString(PSHostUserInterface hostUI, string prompt);
    internal static ErrorRecord CreateFileNotFoundErrorRecord(string resourceStr, string errorId, Object[] args);
    internal static ErrorRecord CreatePathNotFoundErrorRecord(string path, string errorId);
    internal static ErrorRecord CreateNotSupportedErrorRecord(string resourceStr, string errorId, Object[] args);
    internal static ErrorRecord CreateInvalidArgumentErrorRecord(Exception e, string errorId);
    internal static string GetFilePathOfExistingFile(PSCmdlet cmdlet, string path);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SecureStringCommands : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NewSecureString_Prompt { get; }
    internal static string ForceRequired { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NewSecureString_Prompt();
    internal static string get_ForceRequired();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SignatureCommands : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CertNotGoodForSigning { get; }
    internal static string TimeStampUrlRequired { get; }
    internal static string CannotRetrieveFromContainer { get; }
    internal static string FileNotFound { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CertNotGoodForSigning();
    internal static string get_TimeStampUrlRequired();
    internal static string get_CannotRetrieveFromContainer();
    internal static string get_FileNotFound();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class UtilsStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FileSmallerThan4Bytes { get; }
    internal static string OperationNotSupportedOnPath { get; }
    internal static string GetMethodNotFound { get; }
    internal static string SetMethodNotFound { get; }
    internal static string MethodInvokeFail { get; }
    internal static string GetSaclWithCapIdFail { get; }
    internal static string GetEmptySaclFail { get; }
    internal static string GetTokenWithEnabledPrivilegeFail { get; }
    internal static string SetCentralAccessPolicyFail { get; }
    internal static string InvalidCentralAccessPolicyParameters { get; }
    internal static string InvalidCentralAccessPolicyIdentifier { get; }
    internal static string PromptForCredential_DefaultCaption { get; }
    internal static string PromptForCredential_DefaultMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FileSmallerThan4Bytes();
    internal static string get_OperationNotSupportedOnPath();
    internal static string get_GetMethodNotFound();
    internal static string get_SetMethodNotFound();
    internal static string get_MethodInvokeFail();
    internal static string get_GetSaclWithCapIdFail();
    internal static string get_GetEmptySaclFail();
    internal static string get_GetTokenWithEnabledPrivilegeFail();
    internal static string get_SetCentralAccessPolicyFail();
    internal static string get_InvalidCentralAccessPolicyParameters();
    internal static string get_InvalidCentralAccessPolicyIdentifier();
    internal static string get_PromptForCredential_DefaultCaption();
    internal static string get_PromptForCredential_DefaultMessage();
}
