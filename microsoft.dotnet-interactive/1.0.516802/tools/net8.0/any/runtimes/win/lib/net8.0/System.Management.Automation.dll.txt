[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Authenticode : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Reason_DoNotRun { get; }
    internal static string Reason_NeverRun { get; }
    internal static string Reason_NotTrusted { get; }
    internal static string Reason_RestrictedMode { get; }
    internal static string Reason_Unknown { get; }
    internal static string Reason_DisallowedBySafer { get; }
    internal static string Reason_FileContentUnavailable { get; }
    internal static string CertNotGoodForSigning { get; }
    internal static string TimeStampUrlRequired { get; }
    internal static string InvalidHashAlgorithm { get; }
    internal static string AuthenticodePromptCaption { get; }
    internal static string AuthenticodePromptText { get; }
    internal static string AuthenticodePromptText_UnknownPublisher { get; }
    internal static string RemoteFilePromptCaption { get; }
    internal static string RemoteFilePromptText { get; }
    internal static string Choice_NeverRun { get; }
    internal static string Choice_NeverRun_Help { get; }
    internal static string Choice_DoNotRun { get; }
    internal static string Choice_DoNotRun_Help { get; }
    internal static string Choice_RunOnce { get; }
    internal static string Choice_RunOnce_Help { get; }
    internal static string Choice_AlwaysRun { get; }
    internal static string Choice_AlwaysRun_Help { get; }
    internal static string Choice_Suspend { get; }
    internal static string Choice_Suspend_Help { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Reason_DoNotRun();
    internal static string get_Reason_NeverRun();
    internal static string get_Reason_NotTrusted();
    internal static string get_Reason_RestrictedMode();
    internal static string get_Reason_Unknown();
    internal static string get_Reason_DisallowedBySafer();
    internal static string get_Reason_FileContentUnavailable();
    internal static string get_CertNotGoodForSigning();
    internal static string get_TimeStampUrlRequired();
    internal static string get_InvalidHashAlgorithm();
    internal static string get_AuthenticodePromptCaption();
    internal static string get_AuthenticodePromptText();
    internal static string get_AuthenticodePromptText_UnknownPublisher();
    internal static string get_RemoteFilePromptCaption();
    internal static string get_RemoteFilePromptText();
    internal static string get_Choice_NeverRun();
    internal static string get_Choice_NeverRun_Help();
    internal static string get_Choice_DoNotRun();
    internal static string get_Choice_DoNotRun_Help();
    internal static string get_Choice_RunOnce();
    internal static string get_Choice_RunOnce_Help();
    internal static string get_Choice_AlwaysRun();
    internal static string get_Choice_AlwaysRun_Help();
    internal static string get_Choice_Suspend();
    internal static string get_Choice_Suspend_Help();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class AuthorizationManagerBase : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AuthorizationManagerDefaultFailureReason { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AuthorizationManagerDefaultFailureReason();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class AutomationExceptions : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Argument { get; }
    internal static string InvalidScopeIdArgument { get; }
    internal static string ArgumentNull { get; }
    internal static string ArgumentOutOfRange { get; }
    internal static string InvalidOperation { get; }
    internal static string NotImplemented { get; }
    internal static string NotSupported { get; }
    internal static string ObjectDisposed { get; }
    internal static string ScriptBlockInvokeOnOneClauseOnly { get; }
    internal static string CanConvertOneClauseOnly { get; }
    internal static string CantConvertEmptyPipeline { get; }
    internal static string CanOnlyConvertOnePipeline { get; }
    internal static string CantConvertScriptBlockWithTrap { get; }
    internal static string CantConvertWithUndeclaredVariables { get; }
    internal static string CantConvertWithNonConstantExpression { get; }
    internal static string CantConvertWithDynamicExpression { get; }
    internal static string CantConvertWithScriptBlocks { get; }
    internal static string CantConvertWithCommandInvocations { get; }
    internal static string CantConvertWithDotSourcing { get; }
    internal static string CantConvertWithScriptBlockInvocation { get; }
    internal static string CanConvertOneOutputErrorRedir { get; }
    internal static string CantConvertScriptBlockWithNoContext { get; }
    internal static string HaltCommandException { get; }
    internal static string DynamicParametersWrongType { get; }
    internal static string CantConvertScriptBlockToOpenGenericType { get; }
    internal static string CantConvertPipelineStartsWithExpression { get; }
    internal static string UsingVariableIsUndefined { get; }
    internal static string CantGetUsingExpressionValueWithSpecifiedVariableDictionary { get; }
    internal static string WDACCompiledScriptBlockLogTitle { get; }
    internal static string WDACCompiledScriptBlockLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Argument();
    internal static string get_InvalidScopeIdArgument();
    internal static string get_ArgumentNull();
    internal static string get_ArgumentOutOfRange();
    internal static string get_InvalidOperation();
    internal static string get_NotImplemented();
    internal static string get_NotSupported();
    internal static string get_ObjectDisposed();
    internal static string get_ScriptBlockInvokeOnOneClauseOnly();
    internal static string get_CanConvertOneClauseOnly();
    internal static string get_CantConvertEmptyPipeline();
    internal static string get_CanOnlyConvertOnePipeline();
    internal static string get_CantConvertScriptBlockWithTrap();
    internal static string get_CantConvertWithUndeclaredVariables();
    internal static string get_CantConvertWithNonConstantExpression();
    internal static string get_CantConvertWithDynamicExpression();
    internal static string get_CantConvertWithScriptBlocks();
    internal static string get_CantConvertWithCommandInvocations();
    internal static string get_CantConvertWithDotSourcing();
    internal static string get_CantConvertWithScriptBlockInvocation();
    internal static string get_CanConvertOneOutputErrorRedir();
    internal static string get_CantConvertScriptBlockWithNoContext();
    internal static string get_HaltCommandException();
    internal static string get_DynamicParametersWrongType();
    internal static string get_CantConvertScriptBlockToOpenGenericType();
    internal static string get_CantConvertPipelineStartsWithExpression();
    internal static string get_UsingVariableIsUndefined();
    internal static string get_CantGetUsingExpressionValueWithSpecifiedVariableDictionary();
    internal static string get_WDACCompiledScriptBlockLogTitle();
    internal static string get_WDACCompiledScriptBlockLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CatalogStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CatalogDefinitionFileNotGenerated { get; }
    internal static string AddFileToCatalog { get; }
    internal static string SkipValidationOfCatalogFile { get; }
    internal static string FoundFileHashInCatalogItem { get; }
    internal static string FoundDuplicateFilesRelativePath { get; }
    internal static string FoundFileInPath { get; }
    internal static string SkipValidationOfPathFile { get; }
    internal static string UnableToAcquireHashAlgorithmContext { get; }
    internal static string UnableToCreateFileHash { get; }
    internal static string UnableToOpenCatalogFile { get; }
    internal static string UnKnownCatalogVersion { get; }
    internal static string UnableToOpenCatalogDefinitionFile { get; }
    internal static string FoundDuplicateFileMemberInCatalog { get; }
    internal static string UnableToFindFileNameOrPathForCatalogMember { get; }
    internal static string UnableToFindFileToHash { get; }
    internal static string UnableToReadFileToHash { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CatalogDefinitionFileNotGenerated();
    internal static string get_AddFileToCatalog();
    internal static string get_SkipValidationOfCatalogFile();
    internal static string get_FoundFileHashInCatalogItem();
    internal static string get_FoundDuplicateFilesRelativePath();
    internal static string get_FoundFileInPath();
    internal static string get_SkipValidationOfPathFile();
    internal static string get_UnableToAcquireHashAlgorithmContext();
    internal static string get_UnableToCreateFileHash();
    internal static string get_UnableToOpenCatalogFile();
    internal static string get_UnKnownCatalogVersion();
    internal static string get_UnableToOpenCatalogDefinitionFile();
    internal static string get_FoundDuplicateFileMemberInCatalog();
    internal static string get_UnableToFindFileNameOrPathForCatalogMember();
    internal static string get_UnableToFindFileToHash();
    internal static string get_UnableToReadFileToHash();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CimInstanceTypeAdapterResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BaseObjectNotCimInstance { get; }
    internal static string ReadOnlyCIMProperty { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BaseObjectNotCimInstance();
    internal static string get_ReadOnlyCIMProperty();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CmdletizationCoreResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ScriptWriter_ModuleDescription { get; }
    internal static string ScriptWriter_DuplicateQueryParameterName { get; }
    internal static string ExportCimCommand_ErrorInCmdletizationXmlFile { get; }
    internal static string ScriptWriter_DuplicateParameterSetInStaticCmdlet { get; }
    internal static string ScriptWriter_ObjectModelWrapperDefinesMultipleParameterSets { get; }
    internal static string ScriptWriter_ObjectModelWrapperIsStillGeneric { get; }
    internal static string ScriptWriter_ObjectModelWrapperNotDerivedFromObjectModelWrapper { get; }
    internal static string ScriptWriter_ObjectModelWrapperUsesIgnoredParameterMetadata { get; }
    internal static string ScriptWriter_ParameterNameConflictsWithCommonParameters { get; }
    internal static string ScriptWriter_ParameterNameConflictsWithQueryParameters { get; }
    internal static string ScriptWriter_ConcatenationOfDeserializationExceptions { get; }
    internal static string EnumWriter_InvalidEnumName { get; }
    internal static string EnumWriter_InvalidValueName { get; }
    internal static string ScriptWriter_InvalidEnum { get; }
    internal static string ImportModule_UnsupportedCmdletAdapter { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ScriptWriter_ModuleDescription();
    internal static string get_ScriptWriter_DuplicateQueryParameterName();
    internal static string get_ExportCimCommand_ErrorInCmdletizationXmlFile();
    internal static string get_ScriptWriter_DuplicateParameterSetInStaticCmdlet();
    internal static string get_ScriptWriter_ObjectModelWrapperDefinesMultipleParameterSets();
    internal static string get_ScriptWriter_ObjectModelWrapperIsStillGeneric();
    internal static string get_ScriptWriter_ObjectModelWrapperNotDerivedFromObjectModelWrapper();
    internal static string get_ScriptWriter_ObjectModelWrapperUsesIgnoredParameterMetadata();
    internal static string get_ScriptWriter_ParameterNameConflictsWithCommonParameters();
    internal static string get_ScriptWriter_ParameterNameConflictsWithQueryParameters();
    internal static string get_ScriptWriter_ConcatenationOfDeserializationExceptions();
    internal static string get_EnumWriter_InvalidEnumName();
    internal static string get_EnumWriter_InvalidValueName();
    internal static string get_ScriptWriter_InvalidEnum();
    internal static string get_ImportModule_UnsupportedCmdletAdapter();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CommandBaseStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ShouldContinuePromptCaption { get; }
    internal static string ContinueOneLabel { get; }
    internal static string ContinueOneHelpMessage { get; }
    internal static string ContinueAllLabel { get; }
    internal static string ContinueAllHelpMessage { get; }
    internal static string SkipOneLabel { get; }
    internal static string SkipOneHelpMessage { get; }
    internal static string SkipAllLabel { get; }
    internal static string SkipAllHelpMessage { get; }
    internal static string HaltHelpMessage { get; }
    internal static string HaltLabel { get; }
    internal static string PauseLabel { get; }
    internal static string PauseHelpMessage { get; }
    internal static string ProgramExitedWithNonZeroCode { get; }
    internal static string ShouldProcessMessage { get; }
    internal static string ShouldProcessWhatIfMessage { get; }
    internal static string ShouldProcessWarningFallback { get; }
    internal static string InquireCaptionDefault { get; }
    internal static string ErrorPreferenceStop { get; }
    internal static string PreferenceStop { get; }
    internal static string PreferenceInvalid { get; }
    internal static string InquireHalt { get; }
    internal static string InquireCtrlC { get; }
    internal static string CannotInvokePSCmdletsDirectly { get; }
    internal static string ParameterNotValidInRemoteRunspace { get; }
    internal static string PagingSupportAccurateTotalCountTemplate { get; }
    internal static string PagingSupportEstimatedTotalCountTemplate { get; }
    internal static string PagingSupportUnknownTotalCountTemplate { get; }
    internal static string ObsoleteCommand { get; }
    internal static string UseOfDeprecatedCommandWarning { get; }
    internal static string ExecFailed { get; }
    internal static string NativeCommandNotFound { get; }
    internal static string WDACLogTitle { get; }
    internal static string WDACLogMessage { get; }
    internal static string SearcherWDACLogTitle { get; }
    internal static string SearcherWDACLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ShouldContinuePromptCaption();
    internal static string get_ContinueOneLabel();
    internal static string get_ContinueOneHelpMessage();
    internal static string get_ContinueAllLabel();
    internal static string get_ContinueAllHelpMessage();
    internal static string get_SkipOneLabel();
    internal static string get_SkipOneHelpMessage();
    internal static string get_SkipAllLabel();
    internal static string get_SkipAllHelpMessage();
    internal static string get_HaltHelpMessage();
    internal static string get_HaltLabel();
    internal static string get_PauseLabel();
    internal static string get_PauseHelpMessage();
    internal static string get_ProgramExitedWithNonZeroCode();
    internal static string get_ShouldProcessMessage();
    internal static string get_ShouldProcessWhatIfMessage();
    internal static string get_ShouldProcessWarningFallback();
    internal static string get_InquireCaptionDefault();
    internal static string get_ErrorPreferenceStop();
    internal static string get_PreferenceStop();
    internal static string get_PreferenceInvalid();
    internal static string get_InquireHalt();
    internal static string get_InquireCtrlC();
    internal static string get_CannotInvokePSCmdletsDirectly();
    internal static string get_ParameterNotValidInRemoteRunspace();
    internal static string get_PagingSupportAccurateTotalCountTemplate();
    internal static string get_PagingSupportEstimatedTotalCountTemplate();
    internal static string get_PagingSupportUnknownTotalCountTemplate();
    internal static string get_ObsoleteCommand();
    internal static string get_UseOfDeprecatedCommandWarning();
    internal static string get_ExecFailed();
    internal static string get_NativeCommandNotFound();
    internal static string get_WDACLogTitle();
    internal static string get_WDACLogMessage();
    internal static string get_SearcherWDACLogTitle();
    internal static string get_SearcherWDACLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ConsoleInfoErrorStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string BadMonadVersion { get; }
    internal static string ConsoleLoadFailure { get; }
    internal static string PSSnapInLoadFailure { get; }
    internal static string PSSnapInLoadWarning { get; }
    internal static string PSSnapInAssemblyNameMismatch { get; }
    internal static string PSSnapInDuplicateCmdlets { get; }
    internal static string PSSnapInDuplicateProviders { get; }
    internal static string AddPSSnapInBadMonadVersion { get; }
    internal static string FileExistsNoClobber { get; }
    internal static string ConfigurationFileDoesNotExist { get; }
    internal static string NotConfigurationFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_BadMonadVersion();
    internal static string get_ConsoleLoadFailure();
    internal static string get_PSSnapInLoadFailure();
    internal static string get_PSSnapInLoadWarning();
    internal static string get_PSSnapInAssemblyNameMismatch();
    internal static string get_PSSnapInDuplicateCmdlets();
    internal static string get_PSSnapInDuplicateProviders();
    internal static string get_AddPSSnapInBadMonadVersion();
    internal static string get_FileExistsNoClobber();
    internal static string get_ConfigurationFileDoesNotExist();
    internal static string get_NotConfigurationFile();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CoreClrStubResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgumentIllegalEnvVarName { get; }
    internal static string ArgumentLongEnvVarValue { get; }
    internal static string ArgumentStringFirstCharIsZero { get; }
    internal static string ArgumentStringZeroLength { get; }
    internal static string CannotGetComputerName { get; }
    internal static string CannotGetDomainName { get; }
    internal static string UnknownErrorNumber { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgumentIllegalEnvVarName();
    internal static string get_ArgumentLongEnvVarValue();
    internal static string get_ArgumentStringFirstCharIsZero();
    internal static string get_ArgumentStringZeroLength();
    internal static string get_CannotGetComputerName();
    internal static string get_CannotGetDomainName();
    internal static string get_UnknownErrorNumber();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Credential : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CredentialDisallowed { get; }
    internal static string InvalidUserNameFormat { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CredentialDisallowed();
    internal static string get_InvalidUserNameFormat();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CredentialAttributeStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CredentialAttribute_Prompt_Caption { get; }
    internal static string CredentialAttribute_Prompt { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CredentialAttribute_Prompt_Caption();
    internal static string get_CredentialAttribute_Prompt();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class CredUI : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string PromptForCredential_DefaultCaption { get; }
    internal static string PromptForCredential_DefaultMessage { get; }
    internal static string PromptForCredential_DefaultTarget { get; }
    internal static string PromptForCredential_InvalidCaption { get; }
    internal static string PromptForCredential_InvalidMessage { get; }
    internal static string PromptForCredential_InvalidUserName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_PromptForCredential_DefaultCaption();
    internal static string get_PromptForCredential_DefaultMessage();
    internal static string get_PromptForCredential_DefaultTarget();
    internal static string get_PromptForCredential_InvalidCaption();
    internal static string get_PromptForCredential_InvalidMessage();
    internal static string get_PromptForCredential_InvalidUserName();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DebuggerStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string VariableBreakpointString { get; }
    internal static string VariableScriptBreakpointString { get; }
    internal static string LineBreakpointString { get; }
    internal static string StatementBreakpointString { get; }
    internal static string CommandBreakpointString { get; }
    internal static string CommandScriptBreakpointString { get; }
    internal static string WarningBreakpointWillNotBeHit { get; }
    internal static string StepHelp { get; }
    internal static string StepOverHelp { get; }
    internal static string StepOutHelp { get; }
    internal static string ContinueHelp { get; }
    internal static string StopHelp { get; }
    internal static string GetStackTraceHelp { get; }
    internal static string ListHelp { get; }
    internal static string AdditionalListHelp1 { get; }
    internal static string AdditionalListHelp2 { get; }
    internal static string AdditionalListHelp3 { get; }
    internal static string EnterHelp { get; }
    internal static string HelpCommandHelp { get; }
    internal static string PromptHelp { get; }
    internal static string SessionDoesNotSupportDebugger { get; }
    internal static string LocationFormat { get; }
    internal static string NoSourceCode { get; }
    internal static string BadStartFormat { get; }
    internal static string BadCountFormat { get; }
    internal static string NoFile { get; }
    internal static string StackTraceFormat { get; }
    internal static string CannotProcessDebuggerCommandNotStopped { get; }
    internal static string CannotSetDebuggerAction { get; }
    internal static string CannotSetRemoteDebuggerAction { get; }
    internal static string CannotStartJobDebuggingDebuggerBusy { get; }
    internal static string NoDebuggableJobsFound { get; }
    internal static string CannotEnableDebuggerSteppingInvalidMode { get; }
    internal static string RunspaceDebuggingDebuggerBusy { get; }
    internal static string RunspaceDebuggingDebuggerIsOff { get; }
    internal static string RunspaceDebuggingInvalidRunspaceState { get; }
    internal static string RunspaceDebuggingNoRunspaceDebugger { get; }
    internal static string RemoteServerDebuggerAlreadyPushed { get; }
    internal static string RemoteServerDebuggerCannotPushSelf { get; }
    internal static string CommandNotSupportedForRemoteUseInServerDebugger { get; }
    internal static string NestedRunspaceDebuggerPromptProcessName { get; }
    internal static string DetachHelp { get; }
    internal static string InvalidDetachCommand { get; }
    internal static string InvalidRunspaceId { get; }
    internal static string UnableToGetRunspace { get; }
    internal static string BreakpointOrBreakpointListNotSpecified { get; }
    internal static string BreakpointListContainedANonBreakpoint { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_VariableBreakpointString();
    internal static string get_VariableScriptBreakpointString();
    internal static string get_LineBreakpointString();
    internal static string get_StatementBreakpointString();
    internal static string get_CommandBreakpointString();
    internal static string get_CommandScriptBreakpointString();
    internal static string get_WarningBreakpointWillNotBeHit();
    internal static string get_StepHelp();
    internal static string get_StepOverHelp();
    internal static string get_StepOutHelp();
    internal static string get_ContinueHelp();
    internal static string get_StopHelp();
    internal static string get_GetStackTraceHelp();
    internal static string get_ListHelp();
    internal static string get_AdditionalListHelp1();
    internal static string get_AdditionalListHelp2();
    internal static string get_AdditionalListHelp3();
    internal static string get_EnterHelp();
    internal static string get_HelpCommandHelp();
    internal static string get_PromptHelp();
    internal static string get_SessionDoesNotSupportDebugger();
    internal static string get_LocationFormat();
    internal static string get_NoSourceCode();
    internal static string get_BadStartFormat();
    internal static string get_BadCountFormat();
    internal static string get_NoFile();
    internal static string get_StackTraceFormat();
    internal static string get_CannotProcessDebuggerCommandNotStopped();
    internal static string get_CannotSetDebuggerAction();
    internal static string get_CannotSetRemoteDebuggerAction();
    internal static string get_CannotStartJobDebuggingDebuggerBusy();
    internal static string get_NoDebuggableJobsFound();
    internal static string get_CannotEnableDebuggerSteppingInvalidMode();
    internal static string get_RunspaceDebuggingDebuggerBusy();
    internal static string get_RunspaceDebuggingDebuggerIsOff();
    internal static string get_RunspaceDebuggingInvalidRunspaceState();
    internal static string get_RunspaceDebuggingNoRunspaceDebugger();
    internal static string get_RemoteServerDebuggerAlreadyPushed();
    internal static string get_RemoteServerDebuggerCannotPushSelf();
    internal static string get_CommandNotSupportedForRemoteUseInServerDebugger();
    internal static string get_NestedRunspaceDebuggerPromptProcessName();
    internal static string get_DetachHelp();
    internal static string get_InvalidDetachCommand();
    internal static string get_InvalidRunspaceId();
    internal static string get_UnableToGetRunspace();
    internal static string get_BreakpointOrBreakpointListNotSpecified();
    internal static string get_BreakpointListContainedANonBreakpoint();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DescriptionsStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NullOrEmptyErrorTemplate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NullOrEmptyErrorTemplate();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class DiscoveryExceptions : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CmdletFormatInvalid { get; }
    internal static string ParameterDeclaredInParameterSetMultipleTimes { get; }
    internal static string AliasDeclaredMultipleTimes { get; }
    internal static string CompiledCommandParameterMemberMustBeFieldOrProperty { get; }
    internal static string InvalidCmdletNameFormat { get; }
    internal static string CommandNotFoundException { get; }
    internal static string CmdletNotFoundException { get; }
    internal static string CmdletDoesNotDeriveFromCmdletType { get; }
    internal static string AliasNotResolvedException { get; }
    internal static string CommandNameNotCmdlet { get; }
    internal static string DuplicateCmdletName { get; }
    internal static string DuplicateCmdletProviderName { get; }
    internal static string DuplicateAssemblyName { get; }
    internal static string DuplicateScriptName { get; }
    internal static string ScriptRequiresInvalidFormat { get; }
    internal static string RequiresInterpreterNotCompatible { get; }
    internal static string RequiresInterpreterNotCompatibleNoPath { get; }
    internal static string RequiresPSVersionNotCompatible { get; }
    internal static string RequiresPSEditionNotCompatible { get; }
    internal static string RequiresMissingPSSnapIns { get; }
    internal static string RequiresShellIDInvalidForSingleShell { get; }
    internal static string RequiresElevation { get; }
    internal static string PSSnapInNameVersion { get; }
    internal static string CommandArgsOnlyForSingleCmdlet { get; }
    internal static string ReservedParameterName { get; }
    internal static string RequiresMissingModules { get; }
    internal static string CouldNotAutoImportMatchingModule { get; }
    internal static string CouldNotAutoImportMatchingModuleWithErrorMessage { get; }
    internal static string CouldNotAutoImportModule { get; }
    internal static string CommandParameterNotFound { get; }
    internal static string DotSourceNotSupported { get; }
    internal static string GetCommandShowCommandInfoParamError { get; }
    internal static string ScriptDisabledWhenFeatureOn { get; }
    internal static string ScriptDisabledWhenFeatureOff { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CmdletFormatInvalid();
    internal static string get_ParameterDeclaredInParameterSetMultipleTimes();
    internal static string get_AliasDeclaredMultipleTimes();
    internal static string get_CompiledCommandParameterMemberMustBeFieldOrProperty();
    internal static string get_InvalidCmdletNameFormat();
    internal static string get_CommandNotFoundException();
    internal static string get_CmdletNotFoundException();
    internal static string get_CmdletDoesNotDeriveFromCmdletType();
    internal static string get_AliasNotResolvedException();
    internal static string get_CommandNameNotCmdlet();
    internal static string get_DuplicateCmdletName();
    internal static string get_DuplicateCmdletProviderName();
    internal static string get_DuplicateAssemblyName();
    internal static string get_DuplicateScriptName();
    internal static string get_ScriptRequiresInvalidFormat();
    internal static string get_RequiresInterpreterNotCompatible();
    internal static string get_RequiresInterpreterNotCompatibleNoPath();
    internal static string get_RequiresPSVersionNotCompatible();
    internal static string get_RequiresPSEditionNotCompatible();
    internal static string get_RequiresMissingPSSnapIns();
    internal static string get_RequiresShellIDInvalidForSingleShell();
    internal static string get_RequiresElevation();
    internal static string get_PSSnapInNameVersion();
    internal static string get_CommandArgsOnlyForSingleCmdlet();
    internal static string get_ReservedParameterName();
    internal static string get_RequiresMissingModules();
    internal static string get_CouldNotAutoImportMatchingModule();
    internal static string get_CouldNotAutoImportMatchingModuleWithErrorMessage();
    internal static string get_CouldNotAutoImportModule();
    internal static string get_CommandParameterNotFound();
    internal static string get_DotSourceNotSupported();
    internal static string get_GetCommandShowCommandInfoParamError();
    internal static string get_ScriptDisabledWhenFeatureOn();
    internal static string get_ScriptDisabledWhenFeatureOff();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class EnumExpressionEvaluatorStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string EmptyInputString { get; }
    internal static string EmptyTokenString { get; }
    internal static string InvalidGenericType { get; }
    internal static string MultipleEnumNameMatch { get; }
    internal static string NoEnumNameMatch { get; }
    internal static string NoIdentifierGroupingAllowed { get; }
    internal static string SyntaxErrorBinaryOperatorExpected { get; }
    internal static string SyntaxErrorIdentifierExpected { get; }
    internal static string SyntaxErrorUnexpectedBinaryOperator { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_EmptyInputString();
    internal static string get_EmptyTokenString();
    internal static string get_InvalidGenericType();
    internal static string get_MultipleEnumNameMatch();
    internal static string get_NoEnumNameMatch();
    internal static string get_NoIdentifierGroupingAllowed();
    internal static string get_SyntaxErrorBinaryOperatorExpected();
    internal static string get_SyntaxErrorIdentifierExpected();
    internal static string get_SyntaxErrorUnexpectedBinaryOperator();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ErrorCategoryStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CloseError { get; }
    internal static string DeadlockDetected { get; }
    internal static string DeviceError { get; }
    internal static string InvalidArgument { get; }
    internal static string InvalidData { get; }
    internal static string InvalidOperation { get; }
    internal static string InvalidResult { get; }
    internal static string InvalidType { get; }
    internal static string MetadataError { get; }
    internal static string NotImplemented { get; }
    internal static string NotInstalled { get; }
    internal static string ObjectNotFound { get; }
    internal static string OpenError { get; }
    internal static string OperationStopped { get; }
    internal static string OperationTimeout { get; }
    internal static string ParserError { get; }
    internal static string PermissionDenied { get; }
    internal static string ReadError { get; }
    internal static string ResourceBusy { get; }
    internal static string ResourceExists { get; }
    internal static string ResourceUnavailable { get; }
    internal static string SyntaxError { get; }
    internal static string WriteError { get; }
    internal static string FromStdErr { get; }
    internal static string SecurityError { get; }
    internal static string ProtocolError { get; }
    internal static string ConnectionError { get; }
    internal static string AuthenticationError { get; }
    internal static string LimitsExceeded { get; }
    internal static string QuotaExceeded { get; }
    internal static string NotEnabled { get; }
    internal static string NotSpecified { get; }
    internal static string InvalidErrorCategory { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CloseError();
    internal static string get_DeadlockDetected();
    internal static string get_DeviceError();
    internal static string get_InvalidArgument();
    internal static string get_InvalidData();
    internal static string get_InvalidOperation();
    internal static string get_InvalidResult();
    internal static string get_InvalidType();
    internal static string get_MetadataError();
    internal static string get_NotImplemented();
    internal static string get_NotInstalled();
    internal static string get_ObjectNotFound();
    internal static string get_OpenError();
    internal static string get_OperationStopped();
    internal static string get_OperationTimeout();
    internal static string get_ParserError();
    internal static string get_PermissionDenied();
    internal static string get_ReadError();
    internal static string get_ResourceBusy();
    internal static string get_ResourceExists();
    internal static string get_ResourceUnavailable();
    internal static string get_SyntaxError();
    internal static string get_WriteError();
    internal static string get_FromStdErr();
    internal static string get_SecurityError();
    internal static string get_ProtocolError();
    internal static string get_ConnectionError();
    internal static string get_AuthenticationError();
    internal static string get_LimitsExceeded();
    internal static string get_QuotaExceeded();
    internal static string get_NotEnabled();
    internal static string get_NotSpecified();
    internal static string get_InvalidErrorCategory();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ErrorPackage : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Ellipsize { get; }
    internal static string ErrorDetailsEmptyTemplate { get; }
    internal static string RedirectedException { get; }
    internal static string UnsupportedPreferenceError { get; }
    internal static string ActionPreferenceReservedForFutureUseError { get; }
    internal static string ReservedActionPreferenceReplacedError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Ellipsize();
    internal static string get_ErrorDetailsEmptyTemplate();
    internal static string get_RedirectedException();
    internal static string get_UnsupportedPreferenceError();
    internal static string get_ActionPreferenceReservedForFutureUseError();
    internal static string get_ReservedActionPreferenceReplacedError();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class EtwLoggingStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CommandStateChange { get; }
    internal static string EngineStateChange { get; }
    internal static string ErrorRecordId { get; }
    internal static string ErrorRecordMessage { get; }
    internal static string ErrorRecordRecommendedAction { get; }
    internal static string ExecutionPolicyName { get; }
    internal static string JobCommand { get; }
    internal static string JobId { get; }
    internal static string JobInstanceId { get; }
    internal static string JobLocation { get; }
    internal static string JobName { get; }
    internal static string JobState { get; }
    internal static string LogContextCommandName { get; }
    internal static string LogContextCommandPath { get; }
    internal static string LogContextCommandType { get; }
    internal static string LogContextEngineVersion { get; }
    internal static string LogContextHostId { get; }
    internal static string LogContextHostName { get; }
    internal static string LogContextHostApplication { get; }
    internal static string LogContextHostVersion { get; }
    internal static string LogContextPipelineId { get; }
    internal static string LogContextRunspaceId { get; }
    internal static string LogContextScriptName { get; }
    internal static string LogContextSequenceNumber { get; }
    internal static string LogContextSeverity { get; }
    internal static string LogContextShellId { get; }
    internal static string LogContextTime { get; }
    internal static string LogContextUser { get; }
    internal static string LogContextConnectedUser { get; }
    internal static string NullJobName { get; }
    internal static string ProviderNameString { get; }
    internal static string ProviderStateChange { get; }
    internal static string ScriptStateChange { get; }
    internal static string SettingChange { get; }
    internal static string SettingChangeNoPrevious { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CommandStateChange();
    internal static string get_EngineStateChange();
    internal static string get_ErrorRecordId();
    internal static string get_ErrorRecordMessage();
    internal static string get_ErrorRecordRecommendedAction();
    internal static string get_ExecutionPolicyName();
    internal static string get_JobCommand();
    internal static string get_JobId();
    internal static string get_JobInstanceId();
    internal static string get_JobLocation();
    internal static string get_JobName();
    internal static string get_JobState();
    internal static string get_LogContextCommandName();
    internal static string get_LogContextCommandPath();
    internal static string get_LogContextCommandType();
    internal static string get_LogContextEngineVersion();
    internal static string get_LogContextHostId();
    internal static string get_LogContextHostName();
    internal static string get_LogContextHostApplication();
    internal static string get_LogContextHostVersion();
    internal static string get_LogContextPipelineId();
    internal static string get_LogContextRunspaceId();
    internal static string get_LogContextScriptName();
    internal static string get_LogContextSequenceNumber();
    internal static string get_LogContextSeverity();
    internal static string get_LogContextShellId();
    internal static string get_LogContextTime();
    internal static string get_LogContextUser();
    internal static string get_LogContextConnectedUser();
    internal static string get_NullJobName();
    internal static string get_ProviderNameString();
    internal static string get_ProviderStateChange();
    internal static string get_ScriptStateChange();
    internal static string get_SettingChange();
    internal static string get_SettingChangeNoPrevious();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class EventingResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NonVoidDelegateNotSupported { get; }
    internal static string CouldNotFindEvent { get; }
    internal static string WinRTEventsNotSupported { get; }
    internal static string ReservedIdentifier { get; }
    internal static string RemoteOperationNotSupported { get; }
    internal static string ActionAndForwardNotSupported { get; }
    internal static string SubscriberExists { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NonVoidDelegateNotSupported();
    internal static string get_CouldNotFindEvent();
    internal static string get_WinRTEventsNotSupported();
    internal static string get_ReservedIdentifier();
    internal static string get_RemoteOperationNotSupported();
    internal static string get_ActionAndForwardNotSupported();
    internal static string get_SubscriberExists();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ExperimentalFeatureStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ExperimentalFeatureNameNotFound { get; }
    internal static string ExperimentalFeaturePending { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ExperimentalFeatureNameNotFound();
    internal static string get_ExperimentalFeaturePending();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ExtendedTypeSystem : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MemberAlreadyPresent { get; }
    internal static string MemberAlreadyPresentFromTypesXml { get; }
    internal static string MemberNotPresent { get; }
    internal static string ExceptionWhenSetting { get; }
    internal static string ExceptionWhenGetting { get; }
    internal static string EnumerationException { get; }
    internal static string AccessMemberOutsidePSObject { get; }
    internal static string ChangeStaticMember { get; }
    internal static string ReservedMemberName { get; }
    internal static string CannotChangeReservedMember { get; }
    internal static string MethodInvocationException { get; }
    internal static string CopyToInvocationException { get; }
    internal static string MethodArgumentCountException { get; }
    internal static string MethodGenericArgumentCountException { get; }
    internal static string MethodAmbiguousException { get; }
    internal static string MethodArgumentConversionException { get; }
    internal static string GetWithoutGetterException { get; }
    internal static string SetWithoutSetterException { get; }
    internal static string CodePropertySetterFormat { get; }
    internal static string CodePropertyGetterFormat { get; }
    internal static string CodePropertyGetterAndSetterNull { get; }
    internal static string CodeMethodMethodFormat { get; }
    internal static string CycleInAlias { get; }
    internal static string InvalidCastException { get; }
    internal static string InvalidCastExceptionWithoutValue { get; }
    internal static string InvalidCastExceptionWithInnerException { get; }
    internal static string InvalidCastExceptionEnumerationNoFlagAndComma { get; }
    internal static string InvalidCastExceptionEnumerationNoValue { get; }
    internal static string InvalidCastExceptionEnumerationNull { get; }
    internal static string InvalidCastFromNull { get; }
    internal static string InvalidCastExceptionNoStringForConversion { get; }
    internal static string InvalidCastCannotRetrieveString { get; }
    internal static string ReferenceTypeExpected { get; }
    internal static string NotIcomparable { get; }
    internal static string ComparisonFailure { get; }
    internal static string NotTheSameTypeOrNotIcomparable { get; }
    internal static string InvalidCastExceptionEnumerationMoreThanOneValue { get; }
    internal static string InvalidCastExceptionForBooleanArgumentValue { get; }
    internal static string WriteOnlyProperty { get; }
    internal static string ReadOnlyProperty { get; }
    internal static string XmlNodeSetShouldBeAString { get; }
    internal static string XmlNodeSetRestrictions { get; }
    internal static string CannotAddPropertyOrMethod { get; }
    internal static string TypesXmlError { get; }
    internal static string ToStringException { get; }
    internal static string NotAClsCompliantFieldProperty { get; }
    internal static string ExceptionRetrievingTypeNameHierarchy { get; }
    internal static string ExceptionGettingMember { get; }
    internal static string ExceptionGettingMembers { get; }
    internal static string ExceptionRetrievingPropertyReadState { get; }
    internal static string ExceptionRetrievingPropertyWriteState { get; }
    internal static string ExceptionRetrievingPropertyType { get; }
    internal static string ExceptionRetrievingPropertyString { get; }
    internal static string ExceptionRetrievingPropertyAttributes { get; }
    internal static string ExceptionRetrievingMethodDefinitions { get; }
    internal static string ExceptionRetrievingMethodString { get; }
    internal static string ExceptionRetrievingParameterizedPropertytype { get; }
    internal static string ExceptionRetrievingParameterizedPropertyReadState { get; }
    internal static string ExceptionRetrievingParameterizedPropertyWriteState { get; }
    internal static string ExceptionRetrievingParameterizedPropertyDefinitions { get; }
    internal static string ExceptionRetrievingParameterizedPropertyString { get; }
    internal static string CannotSetValueForMemberType { get; }
    internal static string NonRefArgumentToRefParameter { get; }
    internal static string RefArgumentToNonRefParameter { get; }
    internal static string PropertyNotFoundInTypeDescriptor { get; }
    internal static string InvalidComponent { get; }
    internal static string CannotSetNonManagementObject { get; }
    internal static string WMIMethodInvocationException { get; }
    internal static string InvalidWMIClassPath { get; }
    internal static string InvalidWMIPath { get; }
    internal static string PropertyIsSettableError { get; }
    internal static string PropertyIsGettableError { get; }
    internal static string PropertyGetError { get; }
    internal static string PropertySetError { get; }
    internal static string PropertyTypeError { get; }
    internal static string GetTypeNameHierarchyError { get; }
    internal static string GetProperties { get; }
    internal static string GetProperty { get; }
    internal static string NullReturnValueError { get; }
    internal static string PropertyNotFound { get; }
    internal static string NoSettableProperty { get; }
    internal static string ObjectCreationError { get; }
    internal static string CannotInvokeStaticMethodOnUninstantiatedGenericType { get; }
    internal static string ExceptionConstructingAttribute { get; }
    internal static string CannotConvertValueToStringArray { get; }
    internal static string InvalidCastExceptionNonCoreType { get; }
    internal static string InvalidCastToByRefLikeType { get; }
    internal static string CannotAccessByRefLikePropertyOrField { get; }
    internal static string CannotCallMethodWithByRefLikeReturnType { get; }
    internal static string CannotInstantiateBoxedByRefLikeType { get; }
    internal static string WDACHashTypeLogTitle { get; }
    internal static string WDACHashTypeLogMessage { get; }
    internal static string WDACTypeConversionLogTitle { get; }
    internal static string WDACTypeConversionLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MemberAlreadyPresent();
    internal static string get_MemberAlreadyPresentFromTypesXml();
    internal static string get_MemberNotPresent();
    internal static string get_ExceptionWhenSetting();
    internal static string get_ExceptionWhenGetting();
    internal static string get_EnumerationException();
    internal static string get_AccessMemberOutsidePSObject();
    internal static string get_ChangeStaticMember();
    internal static string get_ReservedMemberName();
    internal static string get_CannotChangeReservedMember();
    internal static string get_MethodInvocationException();
    internal static string get_CopyToInvocationException();
    internal static string get_MethodArgumentCountException();
    internal static string get_MethodGenericArgumentCountException();
    internal static string get_MethodAmbiguousException();
    internal static string get_MethodArgumentConversionException();
    internal static string get_GetWithoutGetterException();
    internal static string get_SetWithoutSetterException();
    internal static string get_CodePropertySetterFormat();
    internal static string get_CodePropertyGetterFormat();
    internal static string get_CodePropertyGetterAndSetterNull();
    internal static string get_CodeMethodMethodFormat();
    internal static string get_CycleInAlias();
    internal static string get_InvalidCastException();
    internal static string get_InvalidCastExceptionWithoutValue();
    internal static string get_InvalidCastExceptionWithInnerException();
    internal static string get_InvalidCastExceptionEnumerationNoFlagAndComma();
    internal static string get_InvalidCastExceptionEnumerationNoValue();
    internal static string get_InvalidCastExceptionEnumerationNull();
    internal static string get_InvalidCastFromNull();
    internal static string get_InvalidCastExceptionNoStringForConversion();
    internal static string get_InvalidCastCannotRetrieveString();
    internal static string get_ReferenceTypeExpected();
    internal static string get_NotIcomparable();
    internal static string get_ComparisonFailure();
    internal static string get_NotTheSameTypeOrNotIcomparable();
    internal static string get_InvalidCastExceptionEnumerationMoreThanOneValue();
    internal static string get_InvalidCastExceptionForBooleanArgumentValue();
    internal static string get_WriteOnlyProperty();
    internal static string get_ReadOnlyProperty();
    internal static string get_XmlNodeSetShouldBeAString();
    internal static string get_XmlNodeSetRestrictions();
    internal static string get_CannotAddPropertyOrMethod();
    internal static string get_TypesXmlError();
    internal static string get_ToStringException();
    internal static string get_NotAClsCompliantFieldProperty();
    internal static string get_ExceptionRetrievingTypeNameHierarchy();
    internal static string get_ExceptionGettingMember();
    internal static string get_ExceptionGettingMembers();
    internal static string get_ExceptionRetrievingPropertyReadState();
    internal static string get_ExceptionRetrievingPropertyWriteState();
    internal static string get_ExceptionRetrievingPropertyType();
    internal static string get_ExceptionRetrievingPropertyString();
    internal static string get_ExceptionRetrievingPropertyAttributes();
    internal static string get_ExceptionRetrievingMethodDefinitions();
    internal static string get_ExceptionRetrievingMethodString();
    internal static string get_ExceptionRetrievingParameterizedPropertytype();
    internal static string get_ExceptionRetrievingParameterizedPropertyReadState();
    internal static string get_ExceptionRetrievingParameterizedPropertyWriteState();
    internal static string get_ExceptionRetrievingParameterizedPropertyDefinitions();
    internal static string get_ExceptionRetrievingParameterizedPropertyString();
    internal static string get_CannotSetValueForMemberType();
    internal static string get_NonRefArgumentToRefParameter();
    internal static string get_RefArgumentToNonRefParameter();
    internal static string get_PropertyNotFoundInTypeDescriptor();
    internal static string get_InvalidComponent();
    internal static string get_CannotSetNonManagementObject();
    internal static string get_WMIMethodInvocationException();
    internal static string get_InvalidWMIClassPath();
    internal static string get_InvalidWMIPath();
    internal static string get_PropertyIsSettableError();
    internal static string get_PropertyIsGettableError();
    internal static string get_PropertyGetError();
    internal static string get_PropertySetError();
    internal static string get_PropertyTypeError();
    internal static string get_GetTypeNameHierarchyError();
    internal static string get_GetProperties();
    internal static string get_GetProperty();
    internal static string get_NullReturnValueError();
    internal static string get_PropertyNotFound();
    internal static string get_NoSettableProperty();
    internal static string get_ObjectCreationError();
    internal static string get_CannotInvokeStaticMethodOnUninstantiatedGenericType();
    internal static string get_ExceptionConstructingAttribute();
    internal static string get_CannotConvertValueToStringArray();
    internal static string get_InvalidCastExceptionNonCoreType();
    internal static string get_InvalidCastToByRefLikeType();
    internal static string get_CannotAccessByRefLikePropertyOrField();
    internal static string get_CannotCallMethodWithByRefLikeReturnType();
    internal static string get_CannotInstantiateBoxedByRefLikeType();
    internal static string get_WDACHashTypeLogTitle();
    internal static string get_WDACHashTypeLogMessage();
    internal static string get_WDACTypeConversionLogTitle();
    internal static string get_WDACTypeConversionLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class FileSystemProviderStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvokeItemAction { get; }
    internal static string InvokeItemResourceFileTemplate { get; }
    internal static string RemoveItemActionFile { get; }
    internal static string RemoveItemActionDirectory { get; }
    internal static string CopyItemActionFile { get; }
    internal static string CopyItemResourceFileTemplate { get; }
    internal static string CopyItemActionDirectory { get; }
    internal static string RenameItemActionFile { get; }
    internal static string RenameItemActionDirectory { get; }
    internal static string RenameItemResourceFileTemplate { get; }
    internal static string MoveItemActionFile { get; }
    internal static string MoveItemActionDirectory { get; }
    internal static string MoveItemResourceFileTemplate { get; }
    internal static string SetPropertyActionFile { get; }
    internal static string SetPropertyActionDirectory { get; }
    internal static string SetPropertyResourceTemplate { get; }
    internal static string ClearPropertyActionFile { get; }
    internal static string ClearPropertyActionDirectory { get; }
    internal static string ClearPropertyResourceTemplate { get; }
    internal static string NewItemActionFile { get; }
    internal static string NewItemActionDirectory { get; }
    internal static string NewItemActionTemplate { get; }
    internal static string ClearContentActionFile { get; }
    internal static string ClearContentesourceTemplate { get; }
    internal static string ItemNotFound { get; }
    internal static string CannotRemoveItem { get; }
    internal static string CannotRestoreAttributes { get; }
    internal static string ItemDoesNotExist { get; }
    internal static string DirectoryNotEmpty { get; }
    internal static string UnknownType { get; }
    internal static string PathOutSideBasePath { get; }
    internal static string DriveRootError { get; }
    internal static string DirectoryExist { get; }
    internal static string DelimiterError { get; }
    internal static string CopyError { get; }
    internal static string RenameError { get; }
    internal static string PropertyNotFound { get; }
    internal static string PermissionError { get; }
    internal static string AttributesNotSupported { get; }
    internal static string CannotClearProperty { get; }
    internal static string TargetCannotContainDeviceName { get; }
    internal static string EncodingNotUsed { get; }
    internal static string ByteEncodingError { get; }
    internal static string FileNotFound { get; }
    internal static string DirectoryDisplayGrouping { get; }
    internal static string ReadBackward_Encoding_NotSupport { get; }
    internal static string AlternateDataStreamNotFound { get; }
    internal static string StreamAction { get; }
    internal static string RawAndWaitCannotCoexist { get; }
    internal static string InvalidDriveName { get; }
    internal static string PersistNotSupported { get; }
    internal static string NoFirstLastWaitForRaw { get; }
    internal static string ItemNotDirectory { get; }
    internal static string NewItemActionJunction { get; }
    internal static string NewItemActionSymbolicLink { get; }
    internal static string ElevationRequired { get; }
    internal static string NewItemActionHardLink { get; }
    internal static string ItemNotFile { get; }
    internal static string HardLinkNotSupported { get; }
    internal static string SymbolicLinkNotSupported { get; }
    internal static string CopyItemRemotelyProgressActivity { get; }
    internal static string CopyItemRemoteDestinationIsFile { get; }
    internal static string CopyItemRemotelyFailed { get; }
    internal static string CopyItemRemotelyStatusDescription { get; }
    internal static string CopyItemRemotelyDestinationIsFile { get; }
    internal static string CopyItemRemotelyFailedToGetDirectoryChildItems { get; }
    internal static string CopyItemRemotelyFailedToReadFile { get; }
    internal static string CopyItemRemotelyFailedToValidateIfDestinationIsFile { get; }
    internal static string CopyItemRemotelyFailedToCreateDirectory { get; }
    internal static string DriveMaxSizeError { get; }
    internal static string SymlinkItemExists { get; }
    internal static string AlreadyListedDirectory { get; }
    internal static string TargetCannotBeSubdirectoryOfSource { get; }
    internal static string NewItemTargetIsSameAsLink { get; }
    internal static string CopyingLocalFileActivity { get; }
    internal static string CopyingLocalBytesStatus { get; }
    internal static string JunctionAbsolutePath { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvokeItemAction();
    internal static string get_InvokeItemResourceFileTemplate();
    internal static string get_RemoveItemActionFile();
    internal static string get_RemoveItemActionDirectory();
    internal static string get_CopyItemActionFile();
    internal static string get_CopyItemResourceFileTemplate();
    internal static string get_CopyItemActionDirectory();
    internal static string get_RenameItemActionFile();
    internal static string get_RenameItemActionDirectory();
    internal static string get_RenameItemResourceFileTemplate();
    internal static string get_MoveItemActionFile();
    internal static string get_MoveItemActionDirectory();
    internal static string get_MoveItemResourceFileTemplate();
    internal static string get_SetPropertyActionFile();
    internal static string get_SetPropertyActionDirectory();
    internal static string get_SetPropertyResourceTemplate();
    internal static string get_ClearPropertyActionFile();
    internal static string get_ClearPropertyActionDirectory();
    internal static string get_ClearPropertyResourceTemplate();
    internal static string get_NewItemActionFile();
    internal static string get_NewItemActionDirectory();
    internal static string get_NewItemActionTemplate();
    internal static string get_ClearContentActionFile();
    internal static string get_ClearContentesourceTemplate();
    internal static string get_ItemNotFound();
    internal static string get_CannotRemoveItem();
    internal static string get_CannotRestoreAttributes();
    internal static string get_ItemDoesNotExist();
    internal static string get_DirectoryNotEmpty();
    internal static string get_UnknownType();
    internal static string get_PathOutSideBasePath();
    internal static string get_DriveRootError();
    internal static string get_DirectoryExist();
    internal static string get_DelimiterError();
    internal static string get_CopyError();
    internal static string get_RenameError();
    internal static string get_PropertyNotFound();
    internal static string get_PermissionError();
    internal static string get_AttributesNotSupported();
    internal static string get_CannotClearProperty();
    internal static string get_TargetCannotContainDeviceName();
    internal static string get_EncodingNotUsed();
    internal static string get_ByteEncodingError();
    internal static string get_FileNotFound();
    internal static string get_DirectoryDisplayGrouping();
    internal static string get_ReadBackward_Encoding_NotSupport();
    internal static string get_AlternateDataStreamNotFound();
    internal static string get_StreamAction();
    internal static string get_RawAndWaitCannotCoexist();
    internal static string get_InvalidDriveName();
    internal static string get_PersistNotSupported();
    internal static string get_NoFirstLastWaitForRaw();
    internal static string get_ItemNotDirectory();
    internal static string get_NewItemActionJunction();
    internal static string get_NewItemActionSymbolicLink();
    internal static string get_ElevationRequired();
    internal static string get_NewItemActionHardLink();
    internal static string get_ItemNotFile();
    internal static string get_HardLinkNotSupported();
    internal static string get_SymbolicLinkNotSupported();
    internal static string get_CopyItemRemotelyProgressActivity();
    internal static string get_CopyItemRemoteDestinationIsFile();
    internal static string get_CopyItemRemotelyFailed();
    internal static string get_CopyItemRemotelyStatusDescription();
    internal static string get_CopyItemRemotelyDestinationIsFile();
    internal static string get_CopyItemRemotelyFailedToGetDirectoryChildItems();
    internal static string get_CopyItemRemotelyFailedToReadFile();
    internal static string get_CopyItemRemotelyFailedToValidateIfDestinationIsFile();
    internal static string get_CopyItemRemotelyFailedToCreateDirectory();
    internal static string get_DriveMaxSizeError();
    internal static string get_SymlinkItemExists();
    internal static string get_AlreadyListedDirectory();
    internal static string get_TargetCannotBeSubdirectoryOfSource();
    internal static string get_NewItemTargetIsSameAsLink();
    internal static string get_CopyingLocalFileActivity();
    internal static string get_CopyingLocalBytesStatus();
    internal static string get_JunctionAbsolutePath();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class FormatAndOut_format_xxx : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotSpecifyViewAndPropertyError { get; }
    internal static string CannotSpecifyAutosizeAndColumnsError { get; }
    internal static string UnknownViewNameError { get; }
    internal static string UnknownViewNameErrorSuffix { get; }
    internal static string NonExistingViewNameError { get; }
    internal static string InvalidViewNameError { get; }
    internal static string SuggestValidViewNamePrefix { get; }
    internal static string GroupStartDataIndentedAutoGeneratedLabel { get; }
    internal static string IEnum_Header { get; }
    internal static string IEnum_NoObjects { get; }
    internal static string IEnum_OneObject { get; }
    internal static string IEnum_ManyObjects { get; }
    internal static string FOD_ClassIdInvalid { get; }
    internal static string FOD_InvalidPropertyType { get; }
    internal static string FOD_NullDataMember { get; }
    internal static string FOD_InvalidClassidProperty { get; }
    internal static string FOD_InvalidClassid { get; }
    internal static string FOD_RecursiveProperty { get; }
    internal static string PSPropertyExpressionError { get; }
    internal static string FormattingError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotSpecifyViewAndPropertyError();
    internal static string get_CannotSpecifyAutosizeAndColumnsError();
    internal static string get_UnknownViewNameError();
    internal static string get_UnknownViewNameErrorSuffix();
    internal static string get_NonExistingViewNameError();
    internal static string get_InvalidViewNameError();
    internal static string get_SuggestValidViewNamePrefix();
    internal static string get_GroupStartDataIndentedAutoGeneratedLabel();
    internal static string get_IEnum_Header();
    internal static string get_IEnum_NoObjects();
    internal static string get_IEnum_OneObject();
    internal static string get_IEnum_ManyObjects();
    internal static string get_FOD_ClassIdInvalid();
    internal static string get_FOD_InvalidPropertyType();
    internal static string get_FOD_NullDataMember();
    internal static string get_FOD_InvalidClassidProperty();
    internal static string get_FOD_InvalidClassid();
    internal static string get_FOD_RecursiveProperty();
    internal static string get_PSPropertyExpressionError();
    internal static string get_FormattingError();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class FormatAndOut_MshParameter : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UnknownParameterTypeError { get; }
    internal static string NullParameterTypeError { get; }
    internal static string DuplicateKeyError { get; }
    internal static string IllegalTypeMultiError { get; }
    internal static string IllegalTypeSingleError { get; }
    internal static string AmbiguousKeyError { get; }
    internal static string DictionaryKeyNullError { get; }
    internal static string DictionaryKeyNonStringError { get; }
    internal static string MissingKeyValueError { get; }
    internal static string MissingKeyMandatoryEntryError { get; }
    internal static string IllegalKeyError { get; }
    internal static string IllegalAlignmentValueError { get; }
    internal static string OutOfRangeWidthValueError { get; }
    internal static string EmptyFormatStringValueError { get; }
    internal static string MshExEmptyStringHashError { get; }
    internal static string MshExEmptyStringError { get; }
    internal static string MshExGlobbingHashError { get; }
    internal static string MshExGlobbingStringError { get; }
    internal static string IllegalEnumerableExpansionValue { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UnknownParameterTypeError();
    internal static string get_NullParameterTypeError();
    internal static string get_DuplicateKeyError();
    internal static string get_IllegalTypeMultiError();
    internal static string get_IllegalTypeSingleError();
    internal static string get_AmbiguousKeyError();
    internal static string get_DictionaryKeyNullError();
    internal static string get_DictionaryKeyNonStringError();
    internal static string get_MissingKeyValueError();
    internal static string get_MissingKeyMandatoryEntryError();
    internal static string get_IllegalKeyError();
    internal static string get_IllegalAlignmentValueError();
    internal static string get_OutOfRangeWidthValueError();
    internal static string get_EmptyFormatStringValueError();
    internal static string get_MshExEmptyStringHashError();
    internal static string get_MshExEmptyStringError();
    internal static string get_MshExGlobbingHashError();
    internal static string get_MshExGlobbingStringError();
    internal static string get_IllegalEnumerableExpansionValue();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class FormatAndOut_out_xxx : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ConsoleLineOutput_PagingPrompt { get; }
    internal static string OutLineOutput_NullLineOutputParameter { get; }
    internal static string OutLineOutput_InvalidLineOutputParameterType { get; }
    internal static string OutLineOutput_OutOfSequencePacket { get; }
    internal static string OutFile_FileOpenFailure { get; }
    internal static string OutFile_Action { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ConsoleLineOutput_PagingPrompt();
    internal static string get_OutLineOutput_NullLineOutputParameter();
    internal static string get_OutLineOutput_InvalidLineOutputParameterType();
    internal static string get_OutLineOutput_OutOfSequencePacket();
    internal static string get_OutFile_FileOpenFailure();
    internal static string get_OutFile_Action();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class FormatAndOutXmlLoadingStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AttributesNotAllowed { get; }
    internal static string NoChildrenAllowed { get; }
    internal static string InvalidNode { get; }
    internal static string NoDefaultShapeEntry { get; }
    internal static string TooManyDefaultShapeEntry { get; }
    internal static string NullControlName { get; }
    internal static string InvalidControlForOutOfBandView { get; }
    internal static string OutOfBandGroupByConflict { get; }
    internal static string ViewNotLoaded { get; }
    internal static string InvalidAlignmentValue { get; }
    internal static string ExpectPositiveInteger { get; }
    internal static string InvalidColumnHeader { get; }
    internal static string IncorrectRowItemCount { get; }
    internal static string IncorrectHeaderItemCount { get; }
    internal static string NoListViewItem { get; }
    internal static string InvalidPropertyEntry { get; }
    internal static string NoDefinitionList { get; }
    internal static string ExpectBoolean { get; }
    internal static string ExpectNaturalNumber { get; }
    internal static string ExpectInteger { get; }
    internal static string MissingInnerText { get; }
    internal static string EmptyCustomControlList { get; }
    internal static string LoadTagFailed { get; }
    internal static string NodeWithoutExpression { get; }
    internal static string NodeWithExpression { get; }
    internal static string NoFormatString { get; }
    internal static string NoScriptBlockText { get; }
    internal static string NoProperty { get; }
    internal static string InvalidScriptBlock { get; }
    internal static string StringResourceNotFound { get; }
    internal static string ResourceNotFound { get; }
    internal static string AssemblyNotFound { get; }
    internal static string NonXmlElementNode { get; }
    internal static string ExpectExpression { get; }
    internal static string ControlLabelWithoutExpression { get; }
    internal static string ControlAndLabel { get; }
    internal static string SelectionSetNameAndTypeName { get; }
    internal static string EmptyAppliesTo { get; }
    internal static string InvalidNodeValue { get; }
    internal static string DuplicatedNode { get; }
    internal static string MutuallyExclusiveNode { get; }
    internal static string ThreeMutuallyExclusiveNode { get; }
    internal static string UnknownNode { get; }
    internal static string UnknownAttribute { get; }
    internal static string MissingAttribute { get; }
    internal static string MissingNode { get; }
    internal static string MissingNodeFromList { get; }
    internal static string EmptyNode { get; }
    internal static string EmptyAttribute { get; }
    internal static string ErrorInFile { get; }
    internal static string TooManyErrors { get; }
    internal static string FormatLoadingErrors { get; }
    internal static string AssemblyInGAC { get; }
    internal static string MshSnapinQualifiedError { get; }
    internal static string FormatFileNotRooted { get; }
    internal static string SharedFormatTableCannotBeUpdated { get; }
    internal static string FormatTableLoadErrors { get; }
    internal static string ErrorInFormattingData { get; }
    internal static string IncorrectHeaderItemCountInFormattingData { get; }
    internal static string InvalidFormattingData { get; }
    internal static string InvalidScriptBlockInFormattingData { get; }
    internal static string LoadTagFailedInFormattingData { get; }
    internal static string MultipleRowEntriesFoundInFormattingData { get; }
    internal static string NoDefaultShapeEntryInFormattingData { get; }
    internal static string NoListViewItemInFormattingData { get; }
    internal static string TooManyDefaultShapeEntryInFormattingData { get; }
    internal static string TooManyErrorsInFormattingData { get; }
    internal static string FormatTableCannotCoExist { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AttributesNotAllowed();
    internal static string get_NoChildrenAllowed();
    internal static string get_InvalidNode();
    internal static string get_NoDefaultShapeEntry();
    internal static string get_TooManyDefaultShapeEntry();
    internal static string get_NullControlName();
    internal static string get_InvalidControlForOutOfBandView();
    internal static string get_OutOfBandGroupByConflict();
    internal static string get_ViewNotLoaded();
    internal static string get_InvalidAlignmentValue();
    internal static string get_ExpectPositiveInteger();
    internal static string get_InvalidColumnHeader();
    internal static string get_IncorrectRowItemCount();
    internal static string get_IncorrectHeaderItemCount();
    internal static string get_NoListViewItem();
    internal static string get_InvalidPropertyEntry();
    internal static string get_NoDefinitionList();
    internal static string get_ExpectBoolean();
    internal static string get_ExpectNaturalNumber();
    internal static string get_ExpectInteger();
    internal static string get_MissingInnerText();
    internal static string get_EmptyCustomControlList();
    internal static string get_LoadTagFailed();
    internal static string get_NodeWithoutExpression();
    internal static string get_NodeWithExpression();
    internal static string get_NoFormatString();
    internal static string get_NoScriptBlockText();
    internal static string get_NoProperty();
    internal static string get_InvalidScriptBlock();
    internal static string get_StringResourceNotFound();
    internal static string get_ResourceNotFound();
    internal static string get_AssemblyNotFound();
    internal static string get_NonXmlElementNode();
    internal static string get_ExpectExpression();
    internal static string get_ControlLabelWithoutExpression();
    internal static string get_ControlAndLabel();
    internal static string get_SelectionSetNameAndTypeName();
    internal static string get_EmptyAppliesTo();
    internal static string get_InvalidNodeValue();
    internal static string get_DuplicatedNode();
    internal static string get_MutuallyExclusiveNode();
    internal static string get_ThreeMutuallyExclusiveNode();
    internal static string get_UnknownNode();
    internal static string get_UnknownAttribute();
    internal static string get_MissingAttribute();
    internal static string get_MissingNode();
    internal static string get_MissingNodeFromList();
    internal static string get_EmptyNode();
    internal static string get_EmptyAttribute();
    internal static string get_ErrorInFile();
    internal static string get_TooManyErrors();
    internal static string get_FormatLoadingErrors();
    internal static string get_AssemblyInGAC();
    internal static string get_MshSnapinQualifiedError();
    internal static string get_FormatFileNotRooted();
    internal static string get_SharedFormatTableCannotBeUpdated();
    internal static string get_FormatTableLoadErrors();
    internal static string get_ErrorInFormattingData();
    internal static string get_IncorrectHeaderItemCountInFormattingData();
    internal static string get_InvalidFormattingData();
    internal static string get_InvalidScriptBlockInFormattingData();
    internal static string get_LoadTagFailedInFormattingData();
    internal static string get_MultipleRowEntriesFoundInFormattingData();
    internal static string get_NoDefaultShapeEntryInFormattingData();
    internal static string get_NoListViewItemInFormattingData();
    internal static string get_TooManyDefaultShapeEntryInFormattingData();
    internal static string get_TooManyErrorsInFormattingData();
    internal static string get_FormatTableCannotCoExist();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class GetErrorText : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ResourceBaseNameFailure { get; }
    internal static string ResourceIdFailure { get; }
    internal static string ActionPreferenceStop { get; }
    internal static string AssemblyNotRegistered { get; }
    internal static string BadTemplate { get; }
    internal static string BlankTemplate { get; }
    internal static string PipelineStoppedException { get; }
    internal static string ScriptCallDepthException { get; }
    internal static string PipelineDepthException { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ResourceBaseNameFailure();
    internal static string get_ResourceIdFailure();
    internal static string get_ActionPreferenceStop();
    internal static string get_AssemblyNotRegistered();
    internal static string get_BadTemplate();
    internal static string get_BlankTemplate();
    internal static string get_PipelineStoppedException();
    internal static string get_ScriptCallDepthException();
    internal static string get_PipelineDepthException();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HelpDisplayStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Name { get; }
    internal static string Synopsis { get; }
    internal static string DetailedDescription { get; }
    internal static string Syntax { get; }
    internal static string Parameters { get; }
    internal static string InputType { get; }
    internal static string ReturnType { get; }
    internal static string TerminatingErrors { get; }
    internal static string NonHyphenTerminatingErrors { get; }
    internal static string Notes { get; }
    internal static string Examples { get; }
    internal static string Example { get; }
    internal static string ExampleUpperCase { get; }
    internal static string Output { get; }
    internal static string RelatedLinks { get; }
    internal static string ShortDescription { get; }
    internal static string TitleColon { get; }
    internal static string QuestionColon { get; }
    internal static string Answer { get; }
    internal static string TermColon { get; }
    internal static string DefinitionColon { get; }
    internal static string ContentColon { get; }
    internal static string ProviderName { get; }
    internal static string BaseCmdletInformation { get; }
    internal static string ParameterRequired { get; }
    internal static string ParameterPosition { get; }
    internal static string TypeColon { get; }
    internal static string TargetObjectTypeColon { get; }
    internal static string ParameterDefaultValue { get; }
    internal static string AcceptsPipelineInput { get; }
    internal static string AcceptsWildCardCharacters { get; }
    internal static string Category { get; }
    internal static string SuggestedActionColon { get; }
    internal static string VerboseHelpInfo { get; }
    internal static string FullHelpInfo { get; }
    internal static string ExampleHelpInfo { get; }
    internal static string RelatedLinksHelpInfo { get; }
    internal static string CommonParameters { get; }
    internal static string RemarksSection { get; }
    internal static string TrueShort { get; }
    internal static string NamedParameter { get; }
    internal static string Drives { get; }
    internal static string Capabilities { get; }
    internal static string Tasks { get; }
    internal static string Task { get; }
    internal static string Filters { get; }
    internal static string DynamicParameters { get; }
    internal static string CmdletsSupported { get; }
    internal static string AliasesSection { get; }
    internal static string GetLatestHelpContent { get; }
    internal static string None { get; }
    internal static string ParameterAliases { get; }
    internal static string ParameterIsDynamic { get; }
    internal static string ParameterSetName { get; }
    internal static string UnableToRetrieveHelpInfoXml { get; }
    internal static string PipelineByPropertyName { get; }
    internal static string PipelineByValue { get; }
    internal static string PipelineFromRemainingArguments { get; }
    internal static string HelpCultureNotSupported { get; }
    internal static string HelpCultureNotSupportedFallback { get; }
    internal static string ModuleBaseMustExist { get; }
    internal static string PathMustBeValidContainers { get; }
    internal static string TooManyRedirections { get; }
    internal static string UpdateProgressActivity { get; }
    internal static string UpdateProgressConnecting { get; }
    internal static string UpdateProgressDownloading { get; }
    internal static string UpdateProgressInstalling { get; }
    internal static string UpdateProgressLocating { get; }
    internal static string AllParameterSetsName { get; }
    internal static string CannotMatchModulePattern { get; }
    internal static string ModuleNotFoundWithFullyQualifiedName { get; }
    internal static string HelpContentNotFound { get; }
    internal static string HelpInfoUriNotFound { get; }
    internal static string ModuleNameNullOrEmpty { get; }
    internal static string PathNullOrEmpty { get; }
    internal static string UpdateHelpCompleted { get; }
    internal static string UnzipFailure { get; }
    internal static string UnableToConnect { get; }
    internal static string HelpContentXmlValidationFailure { get; }
    internal static string HelpInfoXmlValidationFailure { get; }
    internal static string SaveHelpCompleted { get; }
    internal static string HelpContentXsdNotFound { get; }
    internal static string FailedToUpdateHelpForModule { get; }
    internal static string SaveProgressActivity { get; }
    internal static string HelpContentContainsInvalidFiles { get; }
    internal static string FailedToSaveHelpForModule { get; }
    internal static string FailedToSaveHelpForModuleWithCulture { get; }
    internal static string FailedToUpdateHelpForModuleWithCulture { get; }
    internal static string FailedToUpdateHelpWithLocaleNoUICulture { get; }
    internal static string FalseShort { get; }
    internal static string CannotSpecifyRecurseWithoutPath { get; }
    internal static string ProviderIsNotFileSystem { get; }
    internal static string SearchingForHelpContent { get; }
    internal static string CannotMatchUICulturePattern { get; }
    internal static string UseForceToSaveHelp { get; }
    internal static string UseForceToUpdateHelp { get; }
    internal static string NewestContentAlreadyInstalled { get; }
    internal static string SuccessfullyUpdatedHelpContent { get; }
    internal static string UpdatedHelpContent { get; }
    internal static string InvalidHelpInfoUri { get; }
    internal static string HelpContentMustBeInTargetNamespace { get; }
    internal static string GetLatestHelpContentWithoutHelpUri { get; }
    internal static string NewestContentAlreadyDownloaded { get; }
    internal static string SavedHelpContent { get; }
    internal static string InvalidHelpInfoUriFormat { get; }
    internal static string RootElementMustBeHelpItems { get; }
    internal static string SaveProgressActivityForModule { get; }
    internal static string UpdateProgressActivityForModule { get; }
    internal static string UpdateHelpResolveUriVerbose { get; }
    internal static string OnlineHelpUri { get; }
    internal static string UpdateHelpShouldProcessActionMessage { get; }
    internal static string Properties { get; }
    internal static string Methods { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Name();
    internal static string get_Synopsis();
    internal static string get_DetailedDescription();
    internal static string get_Syntax();
    internal static string get_Parameters();
    internal static string get_InputType();
    internal static string get_ReturnType();
    internal static string get_TerminatingErrors();
    internal static string get_NonHyphenTerminatingErrors();
    internal static string get_Notes();
    internal static string get_Examples();
    internal static string get_Example();
    internal static string get_ExampleUpperCase();
    internal static string get_Output();
    internal static string get_RelatedLinks();
    internal static string get_ShortDescription();
    internal static string get_TitleColon();
    internal static string get_QuestionColon();
    internal static string get_Answer();
    internal static string get_TermColon();
    internal static string get_DefinitionColon();
    internal static string get_ContentColon();
    internal static string get_ProviderName();
    internal static string get_BaseCmdletInformation();
    internal static string get_ParameterRequired();
    internal static string get_ParameterPosition();
    internal static string get_TypeColon();
    internal static string get_TargetObjectTypeColon();
    internal static string get_ParameterDefaultValue();
    internal static string get_AcceptsPipelineInput();
    internal static string get_AcceptsWildCardCharacters();
    internal static string get_Category();
    internal static string get_SuggestedActionColon();
    internal static string get_VerboseHelpInfo();
    internal static string get_FullHelpInfo();
    internal static string get_ExampleHelpInfo();
    internal static string get_RelatedLinksHelpInfo();
    internal static string get_CommonParameters();
    internal static string get_RemarksSection();
    internal static string get_TrueShort();
    internal static string get_NamedParameter();
    internal static string get_Drives();
    internal static string get_Capabilities();
    internal static string get_Tasks();
    internal static string get_Task();
    internal static string get_Filters();
    internal static string get_DynamicParameters();
    internal static string get_CmdletsSupported();
    internal static string get_AliasesSection();
    internal static string get_GetLatestHelpContent();
    internal static string get_None();
    internal static string get_ParameterAliases();
    internal static string get_ParameterIsDynamic();
    internal static string get_ParameterSetName();
    internal static string get_UnableToRetrieveHelpInfoXml();
    internal static string get_PipelineByPropertyName();
    internal static string get_PipelineByValue();
    internal static string get_PipelineFromRemainingArguments();
    internal static string get_HelpCultureNotSupported();
    internal static string get_HelpCultureNotSupportedFallback();
    internal static string get_ModuleBaseMustExist();
    internal static string get_PathMustBeValidContainers();
    internal static string get_TooManyRedirections();
    internal static string get_UpdateProgressActivity();
    internal static string get_UpdateProgressConnecting();
    internal static string get_UpdateProgressDownloading();
    internal static string get_UpdateProgressInstalling();
    internal static string get_UpdateProgressLocating();
    internal static string get_AllParameterSetsName();
    internal static string get_CannotMatchModulePattern();
    internal static string get_ModuleNotFoundWithFullyQualifiedName();
    internal static string get_HelpContentNotFound();
    internal static string get_HelpInfoUriNotFound();
    internal static string get_ModuleNameNullOrEmpty();
    internal static string get_PathNullOrEmpty();
    internal static string get_UpdateHelpCompleted();
    internal static string get_UnzipFailure();
    internal static string get_UnableToConnect();
    internal static string get_HelpContentXmlValidationFailure();
    internal static string get_HelpInfoXmlValidationFailure();
    internal static string get_SaveHelpCompleted();
    internal static string get_HelpContentXsdNotFound();
    internal static string get_FailedToUpdateHelpForModule();
    internal static string get_SaveProgressActivity();
    internal static string get_HelpContentContainsInvalidFiles();
    internal static string get_FailedToSaveHelpForModule();
    internal static string get_FailedToSaveHelpForModuleWithCulture();
    internal static string get_FailedToUpdateHelpForModuleWithCulture();
    internal static string get_FailedToUpdateHelpWithLocaleNoUICulture();
    internal static string get_FalseShort();
    internal static string get_CannotSpecifyRecurseWithoutPath();
    internal static string get_ProviderIsNotFileSystem();
    internal static string get_SearchingForHelpContent();
    internal static string get_CannotMatchUICulturePattern();
    internal static string get_UseForceToSaveHelp();
    internal static string get_UseForceToUpdateHelp();
    internal static string get_NewestContentAlreadyInstalled();
    internal static string get_SuccessfullyUpdatedHelpContent();
    internal static string get_UpdatedHelpContent();
    internal static string get_InvalidHelpInfoUri();
    internal static string get_HelpContentMustBeInTargetNamespace();
    internal static string get_GetLatestHelpContentWithoutHelpUri();
    internal static string get_NewestContentAlreadyDownloaded();
    internal static string get_SavedHelpContent();
    internal static string get_InvalidHelpInfoUriFormat();
    internal static string get_RootElementMustBeHelpItems();
    internal static string get_SaveProgressActivityForModule();
    internal static string get_UpdateProgressActivityForModule();
    internal static string get_UpdateHelpResolveUriVerbose();
    internal static string get_OnlineHelpUri();
    internal static string get_UpdateHelpShouldProcessActionMessage();
    internal static string get_Properties();
    internal static string get_Methods();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HelpErrors : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string HelpNotFound { get; }
    internal static string HelpCategoryInvalid { get; }
    internal static string HelpFileLoadFailure { get; }
    internal static string HelpFileNotAccessible { get; }
    internal static string HelpFileNotValid { get; }
    internal static string LoadHelpFileForTargetFailed { get; }
    internal static string ProviderLoadError { get; }
    internal static string HelpLoadError { get; }
    internal static string MamlInvalidChildNodeError { get; }
    internal static string MamlInvalidChildNodeCountError { get; }
    internal static string RegistryPathNotFound { get; }
    internal static string NoParmsFound { get; }
    internal static string ParamNotSupported { get; }
    internal static string NoURIFound { get; }
    internal static string InvalidURI { get; }
    internal static string CannotLaunchURI { get; }
    internal static string ProtocolNotSupported { get; }
    internal static string MultipleOnlineTopicsNotSupported { get; }
    internal static string RemoteRunspaceNotAvailable { get; }
    internal static string UpdatableHelpRequiresElevation { get; }
    internal static string GraphicalHostAssemblyIsNotFound { get; }
    internal static string RemotingNotSupportedForFeature { get; }
    internal static string CircularDependencyInHelpForwarding { get; }
    internal static string NoNetworkCommands { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_HelpNotFound();
    internal static string get_HelpCategoryInvalid();
    internal static string get_HelpFileLoadFailure();
    internal static string get_HelpFileNotAccessible();
    internal static string get_HelpFileNotValid();
    internal static string get_LoadHelpFileForTargetFailed();
    internal static string get_ProviderLoadError();
    internal static string get_HelpLoadError();
    internal static string get_MamlInvalidChildNodeError();
    internal static string get_MamlInvalidChildNodeCountError();
    internal static string get_RegistryPathNotFound();
    internal static string get_NoParmsFound();
    internal static string get_ParamNotSupported();
    internal static string get_NoURIFound();
    internal static string get_InvalidURI();
    internal static string get_CannotLaunchURI();
    internal static string get_ProtocolNotSupported();
    internal static string get_MultipleOnlineTopicsNotSupported();
    internal static string get_RemoteRunspaceNotAvailable();
    internal static string get_UpdatableHelpRequiresElevation();
    internal static string get_GraphicalHostAssemblyIsNotFound();
    internal static string get_RemotingNotSupportedForFeature();
    internal static string get_CircularDependencyInHelpForwarding();
    internal static string get_NoNetworkCommands();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HistoryStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidIdGetHistory { get; }
    internal static string NoHistoryForId { get; }
    internal static string NoCountWithMultipleIds { get; }
    internal static string NoHistoryForCommandline { get; }
    internal static string NoLastHistoryEntryFound { get; }
    internal static string InvokeHistoryLoopDetected { get; }
    internal static string InvokeHistoryMultipleCommandsError { get; }
    internal static string AddHistoryInvalidInput { get; }
    internal static string InvalidCountValue { get; }
    internal static string ClearHistoryWarning { get; }
    internal static string NoCountWithMultipleCmdLine { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidIdGetHistory();
    internal static string get_NoHistoryForId();
    internal static string get_NoCountWithMultipleIds();
    internal static string get_NoHistoryForCommandline();
    internal static string get_NoLastHistoryEntryFound();
    internal static string get_InvokeHistoryLoopDetected();
    internal static string get_InvokeHistoryMultipleCommandsError();
    internal static string get_AddHistoryInvalidInput();
    internal static string get_InvalidCountValue();
    internal static string get_ClearHistoryWarning();
    internal static string get_NoCountWithMultipleCmdLine();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class HostInterfaceExceptionsStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DefaultCtorMessageTemplate { get; }
    internal static string HostFunctionNotImplemented { get; }
    internal static string HostFunctionPromptNotImplemented { get; }
    internal static string RunspacePoolNotOpened { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DefaultCtorMessageTemplate();
    internal static string get_HostFunctionNotImplemented();
    internal static string get_HostFunctionPromptNotImplemented();
    internal static string get_RunspacePoolNotOpened();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class InternalCommandStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AmbiguousMethodName { get; }
    internal static string AmbiguousPropertyOrMethodName { get; }
    internal static string ForEachObjectKeyAction { get; }
    internal static string ForEachObjectMethodActionWithArguments { get; }
    internal static string ForEachObjectMethodActionWithoutArguments { get; }
    internal static string ForEachObjectPropertyAction { get; }
    internal static string ForEachObjectTarget { get; }
    internal static string InputObjectIsNull { get; }
    internal static string MethodNotFound { get; }
    internal static string NoMethodInvocationInRestrictedLanguageMode { get; }
    internal static string NoShouldProcessForScriptBlockSet { get; }
    internal static string OperationNotAllowedInRestrictedLanguageMode { get; }
    internal static string OperatorNotSpecified { get; }
    internal static string PropertyNotFound { get; }
    internal static string PropertyOrMethodNotFound { get; }
    internal static string ValueNotSpecifiedForWhereObject { get; }
    internal static string PSTaskStreamWriterWrongThread { get; }
    internal static string ParallelUsingVariableCannotBeScriptBlock { get; }
    internal static string ParallelPipedInputObjectCannotBeScriptBlock { get; }
    internal static string ParallelCannotUseTimeoutWithJob { get; }
    internal static string ParallelCommonParametersNotSupported { get; }
    internal static string ParallelPipedInputProcessingError { get; }
    internal static string WDACLogTitle { get; }
    internal static string WDACLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AmbiguousMethodName();
    internal static string get_AmbiguousPropertyOrMethodName();
    internal static string get_ForEachObjectKeyAction();
    internal static string get_ForEachObjectMethodActionWithArguments();
    internal static string get_ForEachObjectMethodActionWithoutArguments();
    internal static string get_ForEachObjectPropertyAction();
    internal static string get_ForEachObjectTarget();
    internal static string get_InputObjectIsNull();
    internal static string get_MethodNotFound();
    internal static string get_NoMethodInvocationInRestrictedLanguageMode();
    internal static string get_NoShouldProcessForScriptBlockSet();
    internal static string get_OperationNotAllowedInRestrictedLanguageMode();
    internal static string get_OperatorNotSpecified();
    internal static string get_PropertyNotFound();
    internal static string get_PropertyOrMethodNotFound();
    internal static string get_ValueNotSpecifiedForWhereObject();
    internal static string get_PSTaskStreamWriterWrongThread();
    internal static string get_ParallelUsingVariableCannotBeScriptBlock();
    internal static string get_ParallelPipedInputObjectCannotBeScriptBlock();
    internal static string get_ParallelCannotUseTimeoutWithJob();
    internal static string get_ParallelCommonParametersNotSupported();
    internal static string get_ParallelPipedInputProcessingError();
    internal static string get_WDACLogTitle();
    internal static string get_WDACLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class InternalHostStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string EnterExitNestedPromptOutOfSync { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_EnterExitNestedPromptOutOfSync();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class InternalHostUserInterfaceStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string WriteDebugLineStoppedError { get; }
    internal static string UnsupportedPreferenceError { get; }
    internal static string PromptEmptyDescriptionsError { get; }
    internal static string ShouldContinueYesLabel { get; }
    internal static string ShouldContinueYesHelp { get; }
    internal static string ShouldContinueYesToAllLabel { get; }
    internal static string ShouldContinueYesToAllHelp { get; }
    internal static string ShouldContinueNoLabel { get; }
    internal static string ShouldContinueNoHelp { get; }
    internal static string ShouldContinueNoToAllLabel { get; }
    internal static string ShouldContinueNoToAllHelp { get; }
    internal static string ShouldContinueSuspendLabel { get; }
    internal static string ShouldContinueSuspendHelp { get; }
    internal static string ShouldContinuePromptMessage { get; }
    internal static string DefaultChoice { get; }
    internal static string DefaultChoicesForMultipleChoices { get; }
    internal static string ChoiceMessage { get; }
    internal static string EmptyChoicesError { get; }
    internal static string InvalidDefaultChoiceForMultipleSelection { get; }
    internal static string InvalidChoiceHotKeyError { get; }
    internal static string VerboseFormatString { get; }
    internal static string WarningFormatString { get; }
    internal static string DebugFormatString { get; }
    internal static string HostNotTranscribing { get; }
    internal static string CommandStartTime { get; }
    internal static string TranscriptPrologue { get; }
    internal static string MinimalTranscriptPrologue { get; }
    internal static string TranscriptEpilogue { get; }
    internal static string InvalidTranscriptFilePath { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_WriteDebugLineStoppedError();
    internal static string get_UnsupportedPreferenceError();
    internal static string get_PromptEmptyDescriptionsError();
    internal static string get_ShouldContinueYesLabel();
    internal static string get_ShouldContinueYesHelp();
    internal static string get_ShouldContinueYesToAllLabel();
    internal static string get_ShouldContinueYesToAllHelp();
    internal static string get_ShouldContinueNoLabel();
    internal static string get_ShouldContinueNoHelp();
    internal static string get_ShouldContinueNoToAllLabel();
    internal static string get_ShouldContinueNoToAllHelp();
    internal static string get_ShouldContinueSuspendLabel();
    internal static string get_ShouldContinueSuspendHelp();
    internal static string get_ShouldContinuePromptMessage();
    internal static string get_DefaultChoice();
    internal static string get_DefaultChoicesForMultipleChoices();
    internal static string get_ChoiceMessage();
    internal static string get_EmptyChoicesError();
    internal static string get_InvalidDefaultChoiceForMultipleSelection();
    internal static string get_InvalidChoiceHotKeyError();
    internal static string get_VerboseFormatString();
    internal static string get_WarningFormatString();
    internal static string get_DebugFormatString();
    internal static string get_HostNotTranscribing();
    internal static string get_CommandStartTime();
    internal static string get_TranscriptPrologue();
    internal static string get_MinimalTranscriptPrologue();
    internal static string get_TranscriptEpilogue();
    internal static string get_InvalidTranscriptFilePath();
}
internal static class Interop : object {
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Logging : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string EngineHealthContext { get; }
    internal static string CommandHealthContext { get; }
    internal static string ProviderHealthContext { get; }
    internal static string EngineLifecycleContext { get; }
    internal static string CommandLifecycleContext { get; }
    internal static string ProviderLifecycleContext { get; }
    internal static string SettingsContext { get; }
    internal static string PipelineExecutionDetailContext { get; }
    internal static string UnknownUserName { get; }
    internal static string EngineExperimentalFeatureNotFound { get; }
    internal static string InvalidExperimentalFeatureName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_EngineHealthContext();
    internal static string get_CommandHealthContext();
    internal static string get_ProviderHealthContext();
    internal static string get_EngineLifecycleContext();
    internal static string get_CommandLifecycleContext();
    internal static string get_ProviderLifecycleContext();
    internal static string get_SettingsContext();
    internal static string get_PipelineExecutionDetailContext();
    internal static string get_UnknownUserName();
    internal static string get_EngineExperimentalFeatureNotFound();
    internal static string get_InvalidExperimentalFeatureName();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Metadata : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MetadataMemberInitialization { get; }
    internal static string ValidateRangeElementType { get; }
    internal static string ValidateRangePositiveFailure { get; }
    internal static string ValidateRangeNonNegativeFailure { get; }
    internal static string ValidateRangeNegativeFailure { get; }
    internal static string ValidateRangeNonPositiveFailure { get; }
    internal static string ValidateRangeMinRangeMaxRangeType { get; }
    internal static string ValidateRangeNotIComparable { get; }
    internal static string ValidateRangeMaxRangeSmallerThanMinRange { get; }
    internal static string ValidateRangeGreaterThanMaxRangeFailure { get; }
    internal static string ValidateRangeSmallerThanMinRangeFailure { get; }
    internal static string ValidatePatternFailure { get; }
    internal static string ValidateCountNotInArray { get; }
    internal static string ValidateCountExactFailure { get; }
    internal static string ValidateCountMinMaxFailure { get; }
    internal static string ValidateCountMaxLengthSmallerThanMinLength { get; }
    internal static string ValidateLengthMaxLengthSmallerThanMinLength { get; }
    internal static string ValidateLengthNotString { get; }
    internal static string ValidateLengthMinLengthFailure { get; }
    internal static string ValidateLengthMaxLengthFailure { get; }
    internal static string ValidateSetFailure { get; }
    internal static string ValidateSetGeneratedValidValuesListIsNull { get; }
    internal static string ValidateFailureResult { get; }
    internal static string ParsingTooManyParameterSets { get; }
    internal static string ArgumentTransformationArgumentsShouldBeStrings { get; }
    internal static string InvalidValueFailure { get; }
    internal static string InvalidMetadataForCurrentValue { get; }
    internal static string ValidateNotNullFailure { get; }
    internal static string ValidateNotNullCollectionFailure { get; }
    internal static string ValidateNotNullOrEmptyFailure { get; }
    internal static string ValidateNotNullOrEmptyCollectionFailure { get; }
    internal static string ValidateNotNullOrWhiteSpaceFailure { get; }
    internal static string ValidateNotNullOrWhiteSpaceCollectionFailure { get; }
    internal static string ParameterNameAlreadyExistsForCommand { get; }
    internal static string AliasParameterNameAlreadyExistsForCommand { get; }
    internal static string ParameterNameConflictsWithAlias { get; }
    internal static string ValidateScriptFailure { get; }
    internal static string ValidateVersionFailure { get; }
    internal static string ValidateVariableName { get; }
    internal static string JobDefinitionMustDeriveFromIJobConverter { get; }
    internal static string ValidateDrivePathArgNotString { get; }
    internal static string ValidateDrivePathFailure { get; }
    internal static string ValidateDrivePathInvalidChar { get; }
    internal static string ValidateDrivePathNoRoot { get; }
    internal static string ArgumentNullOrEmpty { get; }
    internal static string InvalidEnumArgument { get; }
    internal static string ValidateTrustedDataFailure { get; }
    internal static string WDACParameterArgNotTrustedLogTitle { get; }
    internal static string WDACParameterArgNotTrustedMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MetadataMemberInitialization();
    internal static string get_ValidateRangeElementType();
    internal static string get_ValidateRangePositiveFailure();
    internal static string get_ValidateRangeNonNegativeFailure();
    internal static string get_ValidateRangeNegativeFailure();
    internal static string get_ValidateRangeNonPositiveFailure();
    internal static string get_ValidateRangeMinRangeMaxRangeType();
    internal static string get_ValidateRangeNotIComparable();
    internal static string get_ValidateRangeMaxRangeSmallerThanMinRange();
    internal static string get_ValidateRangeGreaterThanMaxRangeFailure();
    internal static string get_ValidateRangeSmallerThanMinRangeFailure();
    internal static string get_ValidatePatternFailure();
    internal static string get_ValidateCountNotInArray();
    internal static string get_ValidateCountExactFailure();
    internal static string get_ValidateCountMinMaxFailure();
    internal static string get_ValidateCountMaxLengthSmallerThanMinLength();
    internal static string get_ValidateLengthMaxLengthSmallerThanMinLength();
    internal static string get_ValidateLengthNotString();
    internal static string get_ValidateLengthMinLengthFailure();
    internal static string get_ValidateLengthMaxLengthFailure();
    internal static string get_ValidateSetFailure();
    internal static string get_ValidateSetGeneratedValidValuesListIsNull();
    internal static string get_ValidateFailureResult();
    internal static string get_ParsingTooManyParameterSets();
    internal static string get_ArgumentTransformationArgumentsShouldBeStrings();
    internal static string get_InvalidValueFailure();
    internal static string get_InvalidMetadataForCurrentValue();
    internal static string get_ValidateNotNullFailure();
    internal static string get_ValidateNotNullCollectionFailure();
    internal static string get_ValidateNotNullOrEmptyFailure();
    internal static string get_ValidateNotNullOrEmptyCollectionFailure();
    internal static string get_ValidateNotNullOrWhiteSpaceFailure();
    internal static string get_ValidateNotNullOrWhiteSpaceCollectionFailure();
    internal static string get_ParameterNameAlreadyExistsForCommand();
    internal static string get_AliasParameterNameAlreadyExistsForCommand();
    internal static string get_ParameterNameConflictsWithAlias();
    internal static string get_ValidateScriptFailure();
    internal static string get_ValidateVersionFailure();
    internal static string get_ValidateVariableName();
    internal static string get_JobDefinitionMustDeriveFromIJobConverter();
    internal static string get_ValidateDrivePathArgNotString();
    internal static string get_ValidateDrivePathFailure();
    internal static string get_ValidateDrivePathInvalidChar();
    internal static string get_ValidateDrivePathNoRoot();
    internal static string get_ArgumentNullOrEmpty();
    internal static string get_InvalidEnumArgument();
    internal static string get_ValidateTrustedDataFailure();
    internal static string get_WDACParameterArgNotTrustedLogTitle();
    internal static string get_WDACParameterArgNotTrustedMessage();
}
public static class Microsoft.PowerShell.AdapterCodeMethods : object {
    public static long ConvertLargeIntegerToInt64(PSObject deInstance, PSObject largeIntegerInstance);
    public static string ConvertDNWithBinaryToString(PSObject deInstance, PSObject dnWithBinaryInstance);
}
internal static class Microsoft.PowerShell.CAPI : object {
    internal static UInt32 CRYPTPROTECT_UI_FORBIDDEN;
    internal static UInt32 CRYPTPROTECT_LOCAL_MACHINE;
    internal static int E_FILENOTFOUND;
    internal static int ERROR_FILE_NOT_FOUND;
    internal static bool ErrorMayBeCausedByUnloadedProfile(int errorCode);
    internal static bool CryptProtectData(IntPtr pDataIn, string szDataDescr, IntPtr pOptionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, UInt32 dwFlags, IntPtr pDataBlob);
    internal static bool CryptUnprotectData(IntPtr pDataIn, IntPtr ppszDataDescr, IntPtr pOptionalEntropy, IntPtr pvReserved, IntPtr pPromptStruct, UInt32 dwFlags, IntPtr pDataBlob);
    internal static void ZeroMemory(IntPtr handle, UInt32 length);
    internal static IntPtr LocalFree(IntPtr handle);
}
public class Microsoft.PowerShell.Cim.CimInstanceAdapter : PSPropertyAdapter {
    private static PSAdaptedProperty GetCimPropertyAdapter(CimProperty property, object baseObject, string propertyName);
    private static PSAdaptedProperty GetCimPropertyAdapter(CimProperty property, object baseObject);
    private static PSAdaptedProperty GetPSComputerNameAdapter(CimInstance cimInstance);
    public virtual Collection`1<PSAdaptedProperty> GetProperties(object baseObject);
    public virtual PSAdaptedProperty GetProperty(object baseObject, string propertyName);
    public virtual PSAdaptedProperty GetFirstPropertyOrDefault(object baseObject, MemberNamePredicate predicate);
    internal static string CimTypeToTypeNameDisplayString(CimType cimType);
    public virtual string GetPropertyTypeName(PSAdaptedProperty adaptedProperty);
    public virtual object GetPropertyValue(PSAdaptedProperty adaptedProperty);
    private static void AddTypeNameHierarchy(IList`1<string> typeNamesWithNamespace, IList`1<string> typeNamesWithoutNamespace, string namespaceName, string className);
    private static List`1<CimClass> GetInheritanceChain(CimInstance cimInstance);
    public virtual Collection`1<string> GetTypeNameHierarchy(object baseObject);
    public virtual bool IsGettable(PSAdaptedProperty adaptedProperty);
    public virtual bool IsSettable(PSAdaptedProperty adaptedProperty);
    public virtual void SetPropertyValue(PSAdaptedProperty adaptedProperty, object value);
}
public enum Microsoft.PowerShell.Cmdletization.BehaviorOnNoMatch : Enum {
    public int value__;
    public static BehaviorOnNoMatch Default;
    public static BehaviorOnNoMatch ReportErrors;
    public static BehaviorOnNoMatch SilentlyContinue;
}
internal class Microsoft.PowerShell.Cmdletization.Cim.WildcardPatternToCimQueryParser : WildcardPatternParser {
    private StringBuilder _result;
    private bool _needClientSideFiltering;
    protected virtual void AppendLiteralCharacter(char c);
    protected virtual void AppendAsterix();
    protected virtual void AppendQuestionMark();
    protected virtual void BeginBracketExpression();
    protected virtual void AppendLiteralCharacterToBracketExpression(char c);
    protected virtual void AppendCharacterRangeToBracketExpression(char startOfCharacterRange, char endOfCharacterRange);
    protected virtual void EndBracketExpression();
    internal static string Parse(WildcardPattern wildcardPattern, Boolean& needsClientSideFiltering);
}
public abstract class Microsoft.PowerShell.Cmdletization.CmdletAdapter`1 : object {
    private PSCmdlet _cmdlet;
    private string _className;
    private string _classVersion;
    private Version _moduleVersion;
    private IDictionary`2<string, string> _privateData;
    public PSCmdlet Cmdlet { get; }
    public string ClassName { get; }
    public string ClassVersion { get; }
    public Version ModuleVersion { get; }
    public IDictionary`2<string, string> PrivateData { get; }
    internal void Initialize(PSCmdlet cmdlet, string className, string classVersion, IDictionary`2<string, string> privateData);
    public void Initialize(PSCmdlet cmdlet, string className, string classVersion, Version moduleVersion, IDictionary`2<string, string> privateData);
    public virtual QueryBuilder GetQueryBuilder();
    public virtual void ProcessRecord(QueryBuilder query);
    public virtual void BeginProcessing();
    public virtual void EndProcessing();
    public virtual void StopProcessing();
    public virtual void ProcessRecord(TObjectInstance objectInstance, MethodInvocationInfo methodInvocationInfo, bool passThru);
    public virtual void ProcessRecord(QueryBuilder query, MethodInvocationInfo methodInvocationInfo, bool passThru);
    public virtual void ProcessRecord(MethodInvocationInfo methodInvocationInfo);
    public PSCmdlet get_Cmdlet();
    public string get_ClassName();
    public string get_ClassVersion();
    public Version get_ModuleVersion();
    public IDictionary`2<string, string> get_PrivateData();
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__0_0(object <p0>, EventArgs <p1>);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
private void <Initialize>b__0_1(object <p0>, EventArgs <p1>);
}
internal static class Microsoft.PowerShell.Cmdletization.EnumWriter : object {
    private static string namespacePrefix;
    private static Lazy`1<ModuleBuilder> s_moduleBuilder;
    private static object s_moduleBuilderUsageLock;
    private static EnumWriter();
    private static ModuleBuilder CreateModuleBuilder();
    internal static string GetEnumFullName(EnumMetadataEnum enumMetadata);
    internal static void Compile(EnumMetadataEnum enumMetadata);
}
public class Microsoft.PowerShell.Cmdletization.MethodInvocationInfo : object {
    [CompilerGeneratedAttribute]
private string <MethodName>k__BackingField;
    [CompilerGeneratedAttribute]
private KeyedCollection`2<string, MethodParameter> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodParameter <ReturnValue>k__BackingField;
    public string MethodName { get; }
    public KeyedCollection`2<string, MethodParameter> Parameters { get; }
    public MethodParameter ReturnValue { get; }
    public MethodInvocationInfo(string name, IEnumerable`1<MethodParameter> parameters, MethodParameter returnValue);
    [CompilerGeneratedAttribute]
public string get_MethodName();
    [CompilerGeneratedAttribute]
public KeyedCollection`2<string, MethodParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public MethodParameter get_ReturnValue();
    internal IEnumerable`1<T> GetArgumentsOfType();
}
public class Microsoft.PowerShell.Cmdletization.MethodParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodParameterBindings <Bindings>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValuePresent>k__BackingField;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public string ParameterTypeName { get; public set; }
    public MethodParameterBindings Bindings { get; public set; }
    public object Value { get; public set; }
    public bool IsValuePresent { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public void set_ParameterType(Type value);
    [CompilerGeneratedAttribute]
public string get_ParameterTypeName();
    [CompilerGeneratedAttribute]
public void set_ParameterTypeName(string value);
    [CompilerGeneratedAttribute]
public MethodParameterBindings get_Bindings();
    [CompilerGeneratedAttribute]
public void set_Bindings(MethodParameterBindings value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_IsValuePresent();
    [CompilerGeneratedAttribute]
public void set_IsValuePresent(bool value);
}
[FlagsAttribute]
public enum Microsoft.PowerShell.Cmdletization.MethodParameterBindings : Enum {
    public int value__;
    public static MethodParameterBindings In;
    public static MethodParameterBindings Out;
    public static MethodParameterBindings Error;
}
internal class Microsoft.PowerShell.Cmdletization.MethodParametersCollection : KeyedCollection`2<string, MethodParameter> {
    protected virtual string GetKeyForItem(MethodParameter item);
}
public abstract class Microsoft.PowerShell.Cmdletization.QueryBuilder : object {
    public virtual void FilterByProperty(string propertyName, IEnumerable allowedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void ExcludeByProperty(string propertyName, IEnumerable excludedPropertyValues, bool wildcardsEnabled, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMinPropertyValue(string propertyName, object minPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByMaxPropertyValue(string propertyName, object maxPropertyValue, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void FilterByAssociatedInstance(object associatedInstance, string associationName, string sourceRole, string resultRole, BehaviorOnNoMatch behaviorOnNoMatch);
    public virtual void AddQueryOption(string optionName, object optionValue);
}
internal class Microsoft.PowerShell.Cmdletization.ScriptWriter : object {
    private static XmlReaderSettings s_xmlReaderSettings;
    private PowerShellMetadata _cmdletizationMetadata;
    private string _moduleName;
    private Type _objectModelWrapper;
    private Type _objectInstanceType;
    private InvocationInfo _invocationInfo;
    private GenerationOptions _generationOptions;
    private static string HeaderTemplate;
    private Dictionary`2<CommonMethodMetadata, int> _staticMethodMetadataToUniqueId;
    private static string StaticCommonParameterSetTemplate;
    private static string StaticMethodParameterSetTemplate;
    private static string InstanceCommonParameterSetTemplate;
    private static string InstanceQueryParameterSetTemplate;
    private static string InstanceMethodParameterSetTemplate;
    private static string InputObjectQueryParameterSetName;
    private static string SingleQueryParameterSetName;
    private static string CmdletBeginBlockTemplate;
    private static string CmdletProcessBlockTemplate;
    private static string CmdletEndBlockTemplate;
    private static object s_enumCompilationLock;
    internal static string PrivateDataKey_CmdletsOverObjects;
    internal static string PrivateDataKey_ClassName;
    internal static string PrivateDataKey_ObjectModelWrapper;
    internal static string PrivateDataKey_DefaultSession;
    private static ScriptWriter();
    internal ScriptWriter(TextReader cmdletizationXmlReader, string moduleName, string defaultObjectModelWrapper, InvocationInfo invocationInfo, GenerationOptions generationOptions);
    private void WriteModulePreamble(TextWriter output);
    private void WriteBindCommonParametersFunction(TextWriter output);
    private string GetCmdletName(CommonCmdletMetadata cmdletMetadata);
    private static string GetCmdletAttributes(CommonCmdletMetadata cmdletMetadata);
    private Dictionary`2<string, ParameterMetadata> GetCommonParameters();
    private static List`1<string> GetCommonParameterSets(Dictionary`2<string, ParameterMetadata> commonParameters);
    private string GetMethodParameterSet(StaticMethodMetadata staticMethod);
    private List`1<string> GetMethodParameterSets(StaticCmdletMetadata staticCmdlet);
    private string GetMethodParameterSet(CommonMethodMetadata methodMetadata);
    private List`1<string> GetMethodParameterSets(InstanceCmdletMetadata instanceCmdlet);
    private GetCmdletParameters GetGetCmdletParameters(InstanceCmdletMetadata instanceCmdlet);
    private List`1<string> GetQueryParameterSets(InstanceCmdletMetadata instanceCmdlet);
    private Type GetDotNetType(TypeMetadata typeMetadata);
    private ParameterMetadata GetParameter(string parameterSetName, string objectModelParameterName, TypeMetadata parameterTypeMetadata, CmdletParameterMetadata parameterCmdletization, bool isValueFromPipeline, bool isValueFromPipelineByPropertyName);
    private ParameterMetadata GetParameter(string parameterSetName, string objectModelParameterName, TypeMetadata parameterType, CmdletParameterMetadataForInstanceMethodParameter parameterCmdletization);
    private ParameterMetadata GetParameter(IEnumerable`1<string> queryParameterSets, string objectModelParameterName, TypeMetadata parameterType, CmdletParameterMetadataForGetCmdletParameter parameterCmdletization);
    private ParameterMetadata GetParameter(string parameterSetName, string objectModelParameterName, TypeMetadata parameterType, CmdletParameterMetadataForStaticMethodParameter parameterCmdletization);
    private void SetParameters(CommandMetadata commandMetadata, Dictionary`2[] allParameters);
    private CommandMetadata GetCommandMetadata(CommonCmdletMetadata cmdletMetadata);
    private static string EscapeModuleNameForHelpComment(string name);
    private static List`1<List`1<string>> GetCombinations(IEnumerable`1[] x);
    private static void EnsureOrderOfPositionalParameters(Dictionary`2<string, ParameterMetadata> beforeParameters, Dictionary`2<string, ParameterMetadata> afterParameters);
    private static void MultiplyParameterSets(Dictionary`2<string, ParameterMetadata> parameters, string parameterSetNameTemplate, IEnumerable`1[] otherParameterSets);
    private static IEnumerable`1<string> MultiplyParameterSets(string mainParameterSet, string parameterSetNameTemplate, IEnumerable`1[] otherParameterSets);
    private static MethodParameterBindings GetMethodParameterKind(InstanceMethodParameterMetadata methodParameter);
    private static MethodParameterBindings GetMethodParameterKind(StaticMethodParameterMetadata methodParameter);
    private static MethodParameterBindings GetMethodParameterKind(CommonMethodMetadataReturnValue returnValue);
    private static void GenerateSingleMethodParameterProcessing(TextWriter output, string prefix, string cmdletParameterName, Type cmdletParameterType, string etsParameterTypeName, string cmdletParameterDefaultValue, string methodParameterName, MethodParameterBindings methodParameterBindings);
    private void GenerateMethodParametersProcessing(StaticCmdletMetadata staticCmdlet, IEnumerable`1<string> commonParameterSets, String& scriptCode, Dictionary`2& methodParameters, String& outputTypeAttributeDeclaration);
    private void GenerateMethodParametersProcessing(InstanceCmdletMetadata instanceCmdlet, IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> queryParameterSets, String& scriptCode, Dictionary`2& methodParameters, String& outputTypeAttributeDeclaration);
    private static void GenerateIfBoundParameter(IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> methodParameterSets, ParameterMetadata cmdletParameterMetadata, TextWriter output);
    private ParameterMetadata GenerateQueryClause(IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> queryParameterSets, IEnumerable`1<string> methodParameterSets, string queryBuilderMethodName, PropertyMetadata property, PropertyQuery query, TextWriter output);
    private static BehaviorOnNoMatch GetBehaviorWhenNoMatchesFound(CmdletParameterMetadataForGetCmdletFilteringParameter cmdletParameterMetadata);
    private ParameterMetadata GenerateAssociationClause(IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> queryParameterSets, IEnumerable`1<string> methodParameterSets, Association associationMetadata, AssociationAssociatedInstance associatedInstanceMetadata, TextWriter output);
    private ParameterMetadata GenerateOptionClause(IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> queryParameterSets, IEnumerable`1<string> methodParameterSets, QueryOption queryOptionMetadata, TextWriter output);
    private void GenerateQueryParametersProcessing(InstanceCmdletMetadata instanceCmdlet, IEnumerable`1<string> commonParameterSets, IEnumerable`1<string> queryParameterSets, IEnumerable`1<string> methodParameterSets, String& scriptCode, Dictionary`2& queryParameters);
    private string GetHelpDirectiveForExternalHelp();
    private void WriteCmdlet(TextWriter output, StaticCmdletMetadata staticCmdlet);
    private static void AddPassThruParameter(IDictionary`2<string, ParameterMetadata> commonParameters, InstanceCmdletMetadata instanceCmdletMetadata);
    private void WriteCmdlet(TextWriter output, InstanceCmdletMetadata instanceCmdlet);
    private string GetOutputAttributeForGetCmdlet();
    private CommonCmdletMetadata GetGetCmdletMetadata();
    private void WriteGetCmdlet(TextWriter output);
    private static void CompileEnum(EnumMetadataEnum enumMetadata);
    internal void WriteScriptModule(TextWriter output);
    internal void PopulatePSModuleInfo(PSModuleInfo moduleInfo);
    internal void ReportExportedCommands(PSModuleInfo moduleInfo, string prefix);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.Association : object {
    private AssociationAssociatedInstance _associatedInstanceField;
    private string _association1Field;
    private string _sourceRoleField;
    private string _resultRoleField;
    public AssociationAssociatedInstance AssociatedInstance { get; public set; }
    [XmlAttributeAttribute("Association")]
public string Association1 { get; public set; }
    [XmlAttributeAttribute]
public string SourceRole { get; public set; }
    [XmlAttributeAttribute]
public string ResultRole { get; public set; }
    public AssociationAssociatedInstance get_AssociatedInstance();
    public void set_AssociatedInstance(AssociationAssociatedInstance value);
    public string get_Association1();
    public void set_Association1(string value);
    public string get_SourceRole();
    public void set_SourceRole(string value);
    public string get_ResultRole();
    public void set_ResultRole(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.AssociationAssociatedInstance : object {
    private TypeMetadata _typeField;
    private CmdletParameterMetadataForGetCmdletFilteringParameter _cmdletParameterMetadataField;
    public TypeMetadata Type { get; public set; }
    public CmdletParameterMetadataForGetCmdletFilteringParameter CmdletParameterMetadata { get; public set; }
    public TypeMetadata get_Type();
    public void set_Type(TypeMetadata value);
    public CmdletParameterMetadataForGetCmdletFilteringParameter get_CmdletParameterMetadata();
    public void set_CmdletParameterMetadata(CmdletParameterMetadataForGetCmdletFilteringParameter value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.ClassMetadata : object {
    private string _versionField;
    private string _defaultNounField;
    private ClassMetadataInstanceCmdlets _instanceCmdletsField;
    private StaticCmdletMetadata[] _staticCmdletsField;
    private ClassMetadataData[] _cmdletAdapterPrivateDataField;
    private string _cmdletAdapterField;
    private string _classNameField;
    private string _classVersionField;
    public string Version { get; public set; }
    public string DefaultNoun { get; public set; }
    public ClassMetadataInstanceCmdlets InstanceCmdlets { get; public set; }
    [XmlArrayItemAttribute("Cmdlet")]
public StaticCmdletMetadata[] StaticCmdlets { get; public set; }
    [XmlArrayItemAttribute("Data")]
public ClassMetadataData[] CmdletAdapterPrivateData { get; public set; }
    [XmlAttributeAttribute]
public string CmdletAdapter { get; public set; }
    [XmlAttributeAttribute]
public string ClassName { get; public set; }
    [XmlAttributeAttribute]
public string ClassVersion { get; public set; }
    public string get_Version();
    public void set_Version(string value);
    public string get_DefaultNoun();
    public void set_DefaultNoun(string value);
    public ClassMetadataInstanceCmdlets get_InstanceCmdlets();
    public void set_InstanceCmdlets(ClassMetadataInstanceCmdlets value);
    public StaticCmdletMetadata[] get_StaticCmdlets();
    public void set_StaticCmdlets(StaticCmdletMetadata[] value);
    public ClassMetadataData[] get_CmdletAdapterPrivateData();
    public void set_CmdletAdapterPrivateData(ClassMetadataData[] value);
    public string get_CmdletAdapter();
    public void set_CmdletAdapter(string value);
    public string get_ClassName();
    public void set_ClassName(string value);
    public string get_ClassVersion();
    public void set_ClassVersion(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataData : object {
    private string _nameField;
    private string _valueField;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlTextAttribute]
public string Value { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.ClassMetadataInstanceCmdlets : object {
    private GetCmdletParameters _getCmdletParametersField;
    private GetCmdletMetadata _getCmdletField;
    private InstanceCmdletMetadata[] _cmdletField;
    public GetCmdletParameters GetCmdletParameters { get; public set; }
    public GetCmdletMetadata GetCmdlet { get; public set; }
    [XmlElementAttribute("Cmdlet")]
public InstanceCmdletMetadata[] Cmdlet { get; public set; }
    public GetCmdletParameters get_GetCmdletParameters();
    public void set_GetCmdletParameters(GetCmdletParameters value);
    public GetCmdletMetadata get_GetCmdlet();
    public void set_GetCmdlet(GetCmdletMetadata value);
    public InstanceCmdletMetadata[] get_Cmdlet();
    public void set_Cmdlet(InstanceCmdletMetadata[] value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletOutputMetadata : object {
    private object _errorCodeField;
    private string _pSNameField;
    public object ErrorCode { get; public set; }
    [XmlAttributeAttribute]
public string PSName { get; public set; }
    public object get_ErrorCode();
    public void set_ErrorCode(object value);
    public string get_PSName();
    public void set_PSName(string value);
}
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter")]
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter")]
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter")]
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter")]
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadata : object {
    private object _allowEmptyCollectionField;
    private object _allowEmptyStringField;
    private object _allowNullField;
    private object _validateNotNullField;
    private object _validateNotNullOrEmptyField;
    private CmdletParameterMetadataValidateCount _validateCountField;
    private CmdletParameterMetadataValidateLength _validateLengthField;
    private CmdletParameterMetadataValidateRange _validateRangeField;
    private String[] _validateSetField;
    private ObsoleteAttributeMetadata _obsoleteField;
    private bool _isMandatoryField;
    private bool _isMandatoryFieldSpecified;
    private String[] _aliasesField;
    private string _pSNameField;
    private string _positionField;
    public object AllowEmptyCollection { get; public set; }
    public object AllowEmptyString { get; public set; }
    public object AllowNull { get; public set; }
    public object ValidateNotNull { get; public set; }
    public object ValidateNotNullOrEmpty { get; public set; }
    public CmdletParameterMetadataValidateCount ValidateCount { get; public set; }
    public CmdletParameterMetadataValidateLength ValidateLength { get; public set; }
    public CmdletParameterMetadataValidateRange ValidateRange { get; public set; }
    [XmlArrayItemAttribute("AllowedValue")]
public String[] ValidateSet { get; public set; }
    public ObsoleteAttributeMetadata Obsolete { get; public set; }
    [XmlAttributeAttribute]
public bool IsMandatory { get; public set; }
    [XmlIgnoreAttribute]
public bool IsMandatorySpecified { get; public set; }
    [XmlAttributeAttribute]
public String[] Aliases { get; public set; }
    [XmlAttributeAttribute]
public string PSName { get; public set; }
    [XmlAttributeAttribute]
public string Position { get; public set; }
    public object get_AllowEmptyCollection();
    public void set_AllowEmptyCollection(object value);
    public object get_AllowEmptyString();
    public void set_AllowEmptyString(object value);
    public object get_AllowNull();
    public void set_AllowNull(object value);
    public object get_ValidateNotNull();
    public void set_ValidateNotNull(object value);
    public object get_ValidateNotNullOrEmpty();
    public void set_ValidateNotNullOrEmpty(object value);
    public CmdletParameterMetadataValidateCount get_ValidateCount();
    public void set_ValidateCount(CmdletParameterMetadataValidateCount value);
    public CmdletParameterMetadataValidateLength get_ValidateLength();
    public void set_ValidateLength(CmdletParameterMetadataValidateLength value);
    public CmdletParameterMetadataValidateRange get_ValidateRange();
    public void set_ValidateRange(CmdletParameterMetadataValidateRange value);
    public String[] get_ValidateSet();
    public void set_ValidateSet(String[] value);
    public ObsoleteAttributeMetadata get_Obsolete();
    public void set_Obsolete(ObsoleteAttributeMetadata value);
    public bool get_IsMandatory();
    public void set_IsMandatory(bool value);
    public bool get_IsMandatorySpecified();
    public void set_IsMandatorySpecified(bool value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    public string get_PSName();
    public void set_PSName(string value);
    public string get_Position();
    public void set_Position(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter : CmdletParameterMetadataForGetCmdletParameter {
    private bool _errorOnNoMatchField;
    private bool _errorOnNoMatchFieldSpecified;
    [XmlAttributeAttribute]
public bool ErrorOnNoMatch { get; public set; }
    [XmlIgnoreAttribute]
public bool ErrorOnNoMatchSpecified { get; public set; }
    public bool get_ErrorOnNoMatch();
    public void set_ErrorOnNoMatch(bool value);
    public bool get_ErrorOnNoMatchSpecified();
    public void set_ErrorOnNoMatchSpecified(bool value);
}
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletFilteringParameter")]
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForGetCmdletParameter : CmdletParameterMetadata {
    private bool _valueFromPipelineField;
    private bool _valueFromPipelineFieldSpecified;
    private bool _valueFromPipelineByPropertyNameField;
    private bool _valueFromPipelineByPropertyNameFieldSpecified;
    private String[] _cmdletParameterSetsField;
    [XmlAttributeAttribute]
public bool ValueFromPipeline { get; public set; }
    [XmlIgnoreAttribute]
public bool ValueFromPipelineSpecified { get; public set; }
    [XmlAttributeAttribute]
public bool ValueFromPipelineByPropertyName { get; public set; }
    [XmlIgnoreAttribute]
public bool ValueFromPipelineByPropertyNameSpecified { get; public set; }
    [XmlAttributeAttribute]
public String[] CmdletParameterSets { get; public set; }
    public bool get_ValueFromPipeline();
    public void set_ValueFromPipeline(bool value);
    public bool get_ValueFromPipelineSpecified();
    public void set_ValueFromPipelineSpecified(bool value);
    public bool get_ValueFromPipelineByPropertyName();
    public void set_ValueFromPipelineByPropertyName(bool value);
    public bool get_ValueFromPipelineByPropertyNameSpecified();
    public void set_ValueFromPipelineByPropertyNameSpecified(bool value);
    public String[] get_CmdletParameterSets();
    public void set_CmdletParameterSets(String[] value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForInstanceMethodParameter : CmdletParameterMetadata {
    private bool _valueFromPipelineByPropertyNameField;
    private bool _valueFromPipelineByPropertyNameFieldSpecified;
    [XmlAttributeAttribute]
public bool ValueFromPipelineByPropertyName { get; public set; }
    [XmlIgnoreAttribute]
public bool ValueFromPipelineByPropertyNameSpecified { get; public set; }
    public bool get_ValueFromPipelineByPropertyName();
    public void set_ValueFromPipelineByPropertyName(bool value);
    public bool get_ValueFromPipelineByPropertyNameSpecified();
    public void set_ValueFromPipelineByPropertyNameSpecified(bool value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataForStaticMethodParameter : CmdletParameterMetadata {
    private bool _valueFromPipelineField;
    private bool _valueFromPipelineFieldSpecified;
    private bool _valueFromPipelineByPropertyNameField;
    private bool _valueFromPipelineByPropertyNameFieldSpecified;
    [XmlAttributeAttribute]
public bool ValueFromPipeline { get; public set; }
    [XmlIgnoreAttribute]
public bool ValueFromPipelineSpecified { get; public set; }
    [XmlAttributeAttribute]
public bool ValueFromPipelineByPropertyName { get; public set; }
    [XmlIgnoreAttribute]
public bool ValueFromPipelineByPropertyNameSpecified { get; public set; }
    public bool get_ValueFromPipeline();
    public void set_ValueFromPipeline(bool value);
    public bool get_ValueFromPipelineSpecified();
    public void set_ValueFromPipelineSpecified(bool value);
    public bool get_ValueFromPipelineByPropertyName();
    public void set_ValueFromPipelineByPropertyName(bool value);
    public bool get_ValueFromPipelineByPropertyNameSpecified();
    public void set_ValueFromPipelineByPropertyNameSpecified(bool value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateCount : object {
    private string _minField;
    private string _maxField;
    [XmlAttributeAttribute]
public string Min { get; public set; }
    [XmlAttributeAttribute]
public string Max { get; public set; }
    public string get_Min();
    public void set_Min(string value);
    public string get_Max();
    public void set_Max(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateLength : object {
    private string _minField;
    private string _maxField;
    [XmlAttributeAttribute]
public string Min { get; public set; }
    [XmlAttributeAttribute]
public string Max { get; public set; }
    public string get_Min();
    public void set_Min(string value);
    public string get_Max();
    public void set_Max(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CmdletParameterMetadataValidateRange : object {
    private string _minField;
    private string _maxField;
    [XmlAttributeAttribute]
public string Min { get; public set; }
    [XmlAttributeAttribute]
public string Max { get; public set; }
    public string get_Min();
    public void set_Min(string value);
    public string get_Max();
    public void set_Max(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CommonCmdletMetadata : object {
    private ObsoleteAttributeMetadata _obsoleteField;
    private string _verbField;
    private string _nounField;
    private String[] _aliasesField;
    private ConfirmImpact _confirmImpactField;
    private bool _confirmImpactFieldSpecified;
    private string _helpUriField;
    public ObsoleteAttributeMetadata Obsolete { get; public set; }
    [XmlAttributeAttribute]
public string Verb { get; public set; }
    [XmlAttributeAttribute]
public string Noun { get; public set; }
    [XmlAttributeAttribute]
public String[] Aliases { get; public set; }
    [XmlAttributeAttribute]
public ConfirmImpact ConfirmImpact { get; public set; }
    [XmlIgnoreAttribute]
public bool ConfirmImpactSpecified { get; public set; }
    [XmlAttributeAttribute]
public string HelpUri { get; public set; }
    public ObsoleteAttributeMetadata get_Obsolete();
    public void set_Obsolete(ObsoleteAttributeMetadata value);
    public string get_Verb();
    public void set_Verb(string value);
    public string get_Noun();
    public void set_Noun(string value);
    public String[] get_Aliases();
    public void set_Aliases(String[] value);
    public ConfirmImpact get_ConfirmImpact();
    public void set_ConfirmImpact(ConfirmImpact value);
    public bool get_ConfirmImpactSpecified();
    public void set_ConfirmImpactSpecified(bool value);
    public string get_HelpUri();
    public void set_HelpUri(string value);
}
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata")]
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata")]
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadata : object {
    private CommonMethodMetadataReturnValue _returnValueField;
    private string _methodNameField;
    public CommonMethodMetadataReturnValue ReturnValue { get; public set; }
    [XmlAttributeAttribute]
public string MethodName { get; public set; }
    public CommonMethodMetadataReturnValue get_ReturnValue();
    public void set_ReturnValue(CommonMethodMetadataReturnValue value);
    public string get_MethodName();
    public void set_MethodName(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CommonMethodMetadataReturnValue : object {
    private TypeMetadata _typeField;
    private CmdletOutputMetadata _cmdletOutputMetadataField;
    public TypeMetadata Type { get; public set; }
    public CmdletOutputMetadata CmdletOutputMetadata { get; public set; }
    public TypeMetadata get_Type();
    public void set_Type(TypeMetadata value);
    public CmdletOutputMetadata get_CmdletOutputMetadata();
    public void set_CmdletOutputMetadata(CmdletOutputMetadata value);
}
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata")]
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata")]
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.CommonMethodParameterMetadata : object {
    private TypeMetadata _typeField;
    private string _parameterNameField;
    private string _defaultValueField;
    public TypeMetadata Type { get; public set; }
    [XmlAttributeAttribute]
public string ParameterName { get; public set; }
    [XmlAttributeAttribute]
public string DefaultValue { get; public set; }
    public TypeMetadata get_Type();
    public void set_Type(TypeMetadata value);
    public string get_ParameterName();
    public void set_ParameterName(string value);
    public string get_DefaultValue();
    public void set_DefaultValue(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[XmlTypeAttribute]
public enum Microsoft.PowerShell.Cmdletization.Xml.ConfirmImpact : Enum {
    public int value__;
    public static ConfirmImpact None;
    public static ConfirmImpact Low;
    public static ConfirmImpact Medium;
    public static ConfirmImpact High;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnum : object {
    private EnumMetadataEnumValue[] _valueField;
    private string _enumNameField;
    private string _underlyingTypeField;
    private bool _bitwiseFlagsField;
    private bool _bitwiseFlagsFieldSpecified;
    [XmlElementAttribute("Value")]
public EnumMetadataEnumValue[] Value { get; public set; }
    [XmlAttributeAttribute]
public string EnumName { get; public set; }
    [XmlAttributeAttribute]
public string UnderlyingType { get; public set; }
    [XmlAttributeAttribute]
public bool BitwiseFlags { get; public set; }
    [XmlIgnoreAttribute]
public bool BitwiseFlagsSpecified { get; public set; }
    public EnumMetadataEnumValue[] get_Value();
    public void set_Value(EnumMetadataEnumValue[] value);
    public string get_EnumName();
    public void set_EnumName(string value);
    public string get_UnderlyingType();
    public void set_UnderlyingType(string value);
    public bool get_BitwiseFlags();
    public void set_BitwiseFlags(bool value);
    public bool get_BitwiseFlagsSpecified();
    public void set_BitwiseFlagsSpecified(bool value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.EnumMetadataEnumValue : object {
    private string _nameField;
    private string _valueField;
    [XmlAttributeAttribute]
public string Name { get; public set; }
    [XmlAttributeAttribute]
public string Value { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public string get_Value();
    public void set_Value(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.GetCmdletMetadata : object {
    private CommonCmdletMetadata _cmdletMetadataField;
    private GetCmdletParameters _getCmdletParametersField;
    public CommonCmdletMetadata CmdletMetadata { get; public set; }
    public GetCmdletParameters GetCmdletParameters { get; public set; }
    public CommonCmdletMetadata get_CmdletMetadata();
    public void set_CmdletMetadata(CommonCmdletMetadata value);
    public GetCmdletParameters get_GetCmdletParameters();
    public void set_GetCmdletParameters(GetCmdletParameters value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.GetCmdletParameters : object {
    private PropertyMetadata[] _queryablePropertiesField;
    private Association[] _queryableAssociationsField;
    private QueryOption[] _queryOptionsField;
    private string _defaultCmdletParameterSetField;
    [XmlArrayItemAttribute("Property")]
public PropertyMetadata[] QueryableProperties { get; public set; }
    [XmlArrayItemAttribute]
public Association[] QueryableAssociations { get; public set; }
    [XmlArrayItemAttribute("Option")]
public QueryOption[] QueryOptions { get; public set; }
    [XmlAttributeAttribute]
public string DefaultCmdletParameterSet { get; public set; }
    public PropertyMetadata[] get_QueryableProperties();
    public void set_QueryableProperties(PropertyMetadata[] value);
    public Association[] get_QueryableAssociations();
    public void set_QueryableAssociations(Association[] value);
    public QueryOption[] get_QueryOptions();
    public void set_QueryOptions(QueryOption[] value);
    public string get_DefaultCmdletParameterSet();
    public void set_DefaultCmdletParameterSet(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.InstanceCmdletMetadata : object {
    private CommonCmdletMetadata _cmdletMetadataField;
    private InstanceMethodMetadata _methodField;
    private GetCmdletParameters _getCmdletParametersField;
    public CommonCmdletMetadata CmdletMetadata { get; public set; }
    public InstanceMethodMetadata Method { get; public set; }
    public GetCmdletParameters GetCmdletParameters { get; public set; }
    public CommonCmdletMetadata get_CmdletMetadata();
    public void set_CmdletMetadata(CommonCmdletMetadata value);
    public InstanceMethodMetadata get_Method();
    public void set_Method(InstanceMethodMetadata value);
    public GetCmdletParameters get_GetCmdletParameters();
    public void set_GetCmdletParameters(GetCmdletParameters value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodMetadata : CommonMethodMetadata {
    private InstanceMethodParameterMetadata[] _parametersField;
    [XmlArrayItemAttribute("Parameter")]
public InstanceMethodParameterMetadata[] Parameters { get; public set; }
    public InstanceMethodParameterMetadata[] get_Parameters();
    public void set_Parameters(InstanceMethodParameterMetadata[] value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.InstanceMethodParameterMetadata : CommonMethodParameterMetadata {
    private CmdletParameterMetadataForInstanceMethodParameter _cmdletParameterMetadataField;
    private CmdletOutputMetadata _cmdletOutputMetadataField;
    public CmdletParameterMetadataForInstanceMethodParameter CmdletParameterMetadata { get; public set; }
    public CmdletOutputMetadata CmdletOutputMetadata { get; public set; }
    public CmdletParameterMetadataForInstanceMethodParameter get_CmdletParameterMetadata();
    public void set_CmdletParameterMetadata(CmdletParameterMetadataForInstanceMethodParameter value);
    public CmdletOutputMetadata get_CmdletOutputMetadata();
    public void set_CmdletOutputMetadata(CmdletOutputMetadata value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[XmlTypeAttribute]
public enum Microsoft.PowerShell.Cmdletization.Xml.ItemsChoiceType : Enum {
    public int value__;
    public static ItemsChoiceType ExcludeQuery;
    public static ItemsChoiceType MaxValueQuery;
    public static ItemsChoiceType MinValueQuery;
    public static ItemsChoiceType RegularQuery;
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.ObsoleteAttributeMetadata : object {
    private string _messageField;
    [XmlAttributeAttribute]
public string Message { get; public set; }
    public string get_Message();
    public void set_Message(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
[XmlRootAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.PowerShellMetadata : object {
    private ClassMetadata _classField;
    private EnumMetadataEnum[] _enumsField;
    public ClassMetadata Class { get; public set; }
    [XmlArrayItemAttribute("Enum")]
public EnumMetadataEnum[] Enums { get; public set; }
    public ClassMetadata get_Class();
    public void set_Class(ClassMetadata value);
    public EnumMetadataEnum[] get_Enums();
    public void set_Enums(EnumMetadataEnum[] value);
}
internal class Microsoft.PowerShell.Cmdletization.Xml.PowerShellMetadataSerializer : object {
    internal object Deserialize(XmlReader reader);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.PropertyMetadata : object {
    private TypeMetadata _typeField;
    private PropertyQuery[] _itemsField;
    private ItemsChoiceType[] _itemsElementNameField;
    private string _propertyNameField;
    public TypeMetadata Type { get; public set; }
    [XmlElementAttribute("ExcludeQuery", "Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery")]
[XmlElementAttribute("MaxValueQuery", "Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery")]
[XmlElementAttribute("MinValueQuery", "Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery")]
[XmlElementAttribute("RegularQuery", "Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery")]
[XmlChoiceIdentifierAttribute("ItemsElementName")]
public PropertyQuery[] Items { get; public set; }
    [XmlElementAttribute("ItemsElementName")]
[XmlIgnoreAttribute]
public ItemsChoiceType[] ItemsElementName { get; public set; }
    [XmlAttributeAttribute]
public string PropertyName { get; public set; }
    public TypeMetadata get_Type();
    public void set_Type(TypeMetadata value);
    public PropertyQuery[] get_Items();
    public void set_Items(PropertyQuery[] value);
    public ItemsChoiceType[] get_ItemsElementName();
    public void set_ItemsElementName(ItemsChoiceType[] value);
    public string get_PropertyName();
    public void set_PropertyName(string value);
}
[XmlIncludeAttribute("Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery")]
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.PropertyQuery : object {
    private CmdletParameterMetadataForGetCmdletFilteringParameter _cmdletParameterMetadataField;
    public CmdletParameterMetadataForGetCmdletFilteringParameter CmdletParameterMetadata { get; public set; }
    public CmdletParameterMetadataForGetCmdletFilteringParameter get_CmdletParameterMetadata();
    public void set_CmdletParameterMetadata(CmdletParameterMetadataForGetCmdletFilteringParameter value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.QueryOption : object {
    private TypeMetadata _typeField;
    private CmdletParameterMetadataForGetCmdletParameter _cmdletParameterMetadataField;
    private string _optionNameField;
    public TypeMetadata Type { get; public set; }
    public CmdletParameterMetadataForGetCmdletParameter CmdletParameterMetadata { get; public set; }
    [XmlAttributeAttribute]
public string OptionName { get; public set; }
    public TypeMetadata get_Type();
    public void set_Type(TypeMetadata value);
    public CmdletParameterMetadataForGetCmdletParameter get_CmdletParameterMetadata();
    public void set_CmdletParameterMetadata(CmdletParameterMetadataForGetCmdletParameter value);
    public string get_OptionName();
    public void set_OptionName(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadata : object {
    private StaticCmdletMetadataCmdletMetadata _cmdletMetadataField;
    private StaticMethodMetadata[] _methodField;
    public StaticCmdletMetadataCmdletMetadata CmdletMetadata { get; public set; }
    [XmlElementAttribute("Method")]
public StaticMethodMetadata[] Method { get; public set; }
    public StaticCmdletMetadataCmdletMetadata get_CmdletMetadata();
    public void set_CmdletMetadata(StaticCmdletMetadataCmdletMetadata value);
    public StaticMethodMetadata[] get_Method();
    public void set_Method(StaticMethodMetadata[] value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.StaticCmdletMetadataCmdletMetadata : CommonCmdletMetadata {
    private string _defaultCmdletParameterSetField;
    [XmlAttributeAttribute]
public string DefaultCmdletParameterSet { get; public set; }
    public string get_DefaultCmdletParameterSet();
    public void set_DefaultCmdletParameterSet(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.StaticMethodMetadata : CommonMethodMetadata {
    private StaticMethodParameterMetadata[] _parametersField;
    private string _cmdletParameterSetField;
    [XmlArrayItemAttribute("Parameter")]
public StaticMethodParameterMetadata[] Parameters { get; public set; }
    [XmlAttributeAttribute]
public string CmdletParameterSet { get; public set; }
    public StaticMethodParameterMetadata[] get_Parameters();
    public void set_Parameters(StaticMethodParameterMetadata[] value);
    public string get_CmdletParameterSet();
    public void set_CmdletParameterSet(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.StaticMethodParameterMetadata : CommonMethodParameterMetadata {
    private CmdletParameterMetadataForStaticMethodParameter _cmdletParameterMetadataField;
    private CmdletOutputMetadata _cmdletOutputMetadataField;
    public CmdletParameterMetadataForStaticMethodParameter CmdletParameterMetadata { get; public set; }
    public CmdletOutputMetadata CmdletOutputMetadata { get; public set; }
    public CmdletParameterMetadataForStaticMethodParameter get_CmdletParameterMetadata();
    public void set_CmdletParameterMetadata(CmdletParameterMetadataForStaticMethodParameter value);
    public CmdletOutputMetadata get_CmdletOutputMetadata();
    public void set_CmdletOutputMetadata(CmdletOutputMetadata value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.TypeMetadata : object {
    private string _pSTypeField;
    private string _eTSTypeField;
    [XmlAttributeAttribute]
public string PSType { get; public set; }
    [XmlAttributeAttribute]
public string ETSType { get; public set; }
    public string get_PSType();
    public void set_PSType(string value);
    public string get_ETSType();
    public void set_ETSType(string value);
}
[GeneratedCodeAttribute("xsd", "4.0.30319.17929")]
[DebuggerStepThroughAttribute]
[XmlTypeAttribute]
internal class Microsoft.PowerShell.Cmdletization.Xml.WildcardablePropertyQuery : PropertyQuery {
    private bool _allowGlobbingField;
    private bool _allowGlobbingFieldSpecified;
    [XmlAttributeAttribute]
public bool AllowGlobbing { get; public set; }
    [XmlIgnoreAttribute]
public bool AllowGlobbingSpecified { get; public set; }
    public bool get_AllowGlobbing();
    public void set_AllowGlobbing(bool value);
    public bool get_AllowGlobbingSpecified();
    public void set_AllowGlobbingSpecified(bool value);
}
internal class Microsoft.PowerShell.Cmdletization.Xml.XmlSerializationReader1 : object {
    private XmlReader _r;
    private XmlDocument _d;
    private bool _soap12;
    private bool _isReturnValue;
    private bool _decodeName;
    private string _schemaNsID;
    private string _schemaNs1999ID;
    private string _schemaNs2000ID;
    private string _schemaNonXsdTypesNsID;
    private string _instanceNsID;
    private string _instanceNs2000ID;
    private string _instanceNs1999ID;
    private string _soapNsID;
    private string _soap12NsID;
    private string _schemaID;
    private string _wsdlNsID;
    private string _wsdlArrayTypeID;
    private string _nullID;
    private string _nilID;
    private string _typeID;
    private string _arrayTypeID;
    private string _itemTypeID;
    private string _arraySizeID;
    private string _arrayID;
    private string _urTypeID;
    private string _stringID;
    private string _intID;
    private string _booleanID;
    private string _shortID;
    private string _longID;
    private string _floatID;
    private string _doubleID;
    private string _decimalID;
    private string _dateTimeID;
    private string _qnameID;
    private string _dateID;
    private string _timeID;
    private string _hexBinaryID;
    private string _base64BinaryID;
    private string _base64ID;
    private string _unsignedByteID;
    private string _byteID;
    private string _unsignedShortID;
    private string _unsignedIntID;
    private string _unsignedLongID;
    private string _oldDecimalID;
    private string _oldTimeInstantID;
    private string _anyURIID;
    private string _durationID;
    private string _ENTITYID;
    private string _ENTITIESID;
    private string _gDayID;
    private string _gMonthID;
    private string _gMonthDayID;
    private string _gYearID;
    private string _gYearMonthID;
    private string _IDID;
    private string _IDREFID;
    private string _IDREFSID;
    private string _integerID;
    private string _languageID;
    private string _nameID;
    private string _NCNameID;
    private string _NMTOKENID;
    private string _NMTOKENSID;
    private string _negativeIntegerID;
    private string _nonPositiveIntegerID;
    private string _nonNegativeIntegerID;
    private string _normalizedStringID;
    private string _NOTATIONID;
    private string _positiveIntegerID;
    private string _tokenID;
    private string _charID;
    private string _guidID;
    private static object s_primitiveTypedObject;
    private string _id72_ArrayOfAssociation;
    private string _id46_AllowGlobbing;
    private string _id6_GetCmdletParameters;
    private string _id25_Item;
    private string _id62_ValidateRange;
    private string _id118_StaticCmdlets;
    private string _id58_ValidateNotNull;
    private string _id17_ObsoleteAttributeMetadata;
    private string _id49_PSName;
    private string _id116_DefaultNoun;
    private string _id38_ClassMetadataData;
    private string _id114_ClassVersion;
    private string _id66_Message;
    private string _id65_Obsolete;
    private string _id51_ValueFromPipeline;
    private string _id108_MinValueQuery;
    private string _id119_CmdletAdapterPrivateData;
    private string _id21_GetCmdletMetadata;
    private string _id120_GetCmdlet;
    private string _id67_Min;
    private string _id56_AllowEmptyString;
    private string _id30_CmdletOutputMetadata;
    private string _id106_RegularQuery;
    private string _id74_Option;
    private string _id75_Item;
    private string _id23_ConfirmImpact;
    private string _id117_InstanceCmdlets;
    private string _id83_Enum;
    private string _id40_EnumMetadataEnumValue;
    private string _id111_QueryOptions;
    private string _id34_InstanceCmdletMetadata;
    private string _id60_ValidateCount;
    private string _id45_BitwiseFlags;
    private string _id81_Data;
    private string _id31_Item;
    private string _id1_PowerShellMetadata;
    private string _id98_HelpUri;
    private string _id91_DefaultValue;
    private string _id4_Item;
    private string _id32_Item;
    private string _id43_EnumName;
    private string _id122_Enums;
    private string _id82_ArrayOfEnumMetadataEnum;
    private string _id14_Item;
    private string _id48_Aliases;
    private string _id115_Version;
    private string _id11_CmdletParameterMetadata;
    private string _id70_ArrayOfPropertyMetadata;
    private string _id9_Association;
    private string _id102_ResultRole;
    private string _id29_StaticMethodParameterMetadata;
    private string _id97_Noun;
    private string _id47_IsMandatory;
    private string _id35_PropertyQuery;
    private string _id54_ErrorOnNoMatch;
    private string _id3_ClassMetadata;
    private string _id77_Item;
    private string _id2_Item;
    private string _id22_CommonCmdletMetadata;
    private string _id37_ItemsChoiceType;
    private string _id36_WildcardablePropertyQuery;
    private string _id113_ClassName;
    private string _id64_AllowedValue;
    private string _id52_Item;
    private string _id55_AllowEmptyCollection;
    private string _id13_Item;
    private string _id76_Parameter;
    private string _id19_Item;
    private string _id105_MaxValueQuery;
    private string _id101_SourceRole;
    private string _id5_ClassMetadataInstanceCmdlets;
    private string _id112_CmdletAdapter;
    private string _id10_AssociationAssociatedInstance;
    private string _id93_ErrorCode;
    private string _id41_Name;
    private string _id68_Max;
    private string _id50_Position;
    private string _id100_OptionName;
    private string _id84_CmdletMetadata;
    private string _id87_CmdletParameterSet;
    private string _id104_PropertyName;
    private string _id28_CommonMethodParameterMetadata;
    private string _id107_ExcludeQuery;
    private string _id92_Type;
    private string _id33_InstanceMethodMetadata;
    private string _id63_ValidateSet;
    private string _id53_CmdletParameterSets;
    private string _id15_Item;
    private string _id109_QueryableProperties;
    private string _id57_AllowNull;
    private string _id80_ArrayOfClassMetadataData;
    private string _id99_DefaultCmdletParameterSet;
    private string _id20_QueryOption;
    private string _id89_Parameters;
    private string _id90_ParameterName;
    private string _id61_ValidateLength;
    private string _id78_ArrayOfStaticCmdletMetadata;
    private string _id16_Item;
    private string _id39_EnumMetadataEnum;
    private string _id7_PropertyMetadata;
    private string _id110_QueryableAssociations;
    private string _id86_MethodName;
    private string _id8_TypeMetadata;
    private string _id71_Property;
    private string _id27_StaticMethodMetadata;
    private string _id94_PSType;
    private string _id44_UnderlyingType;
    private string _id103_AssociatedInstance;
    private string _id79_Cmdlet;
    private string _id18_Item;
    private string _id85_Method;
    private string _id95_ETSType;
    private string _id26_CommonMethodMetadata;
    private string _id88_ReturnValue;
    private string _id69_ArrayOfString;
    private string _id24_StaticCmdletMetadata;
    private string _id59_ValidateNotNullOrEmpty;
    private string _id96_Verb;
    private string _id121_Class;
    private string _id73_ArrayOfQueryOption;
    private string _id12_Item;
    private string _id42_Value;
    internal XmlReader Reader { get; }
    internal int ReaderCount { get; }
    internal bool DecodeName { get; internal set; }
    protected XmlDocument Document { get; }
    internal XmlSerializationReader1(XmlReader reader);
    private static XmlSerializationReader1();
    internal XmlReader get_Reader();
    internal int get_ReaderCount();
    internal bool get_DecodeName();
    internal void set_DecodeName(bool value);
    protected XmlDocument get_Document();
    internal void InitPrimitiveIDs();
    protected void CheckReaderCount(Int32& whileIterations, Int32& readerCount);
    private string CurrentTag();
    protected Exception CreateUnknownNodeException();
    protected Exception CreateUnknownTypeException(XmlQualifiedName type);
    protected Exception CreateUnknownConstantException(string value, Type enumType);
    protected Array ShrinkArray(Array a, int length, Type elementType, bool isNullable);
    protected Array EnsureArrayIndex(Array a, int index, Type elementType);
    protected string CollapseWhitespace(string value);
    protected bool IsXmlnsAttribute(string name);
    protected void UnknownNode(object o);
    protected void UnknownNode(object o, string qnames);
    private void UnknownNode(XmlNode unknownNode, object o, string qnames);
    protected void ReadEndElement();
    protected string ReadString(string value, bool trim);
    protected XmlQualifiedName ToXmlQualifiedName(string value);
    internal XmlQualifiedName ToXmlQualifiedName(string value, bool decodeName);
    protected XmlQualifiedName GetXsiType();
    protected bool GetNullAttr();
    protected bool ReadNull();
    private bool IsPrimitiveNamespace(string ns);
    protected object ReadTypedPrimitive(XmlQualifiedName type);
    protected object ReadTypedNull(XmlQualifiedName type);
    public object Read50_PowerShellMetadata();
    public object Read51_ClassMetadata();
    public object Read52_ClassMetadataInstanceCmdlets();
    public object Read53_GetCmdletParameters();
    public object Read54_PropertyMetadata();
    public object Read55_TypeMetadata();
    public object Read56_Association();
    public object Read57_AssociationAssociatedInstance();
    public object Read58_CmdletParameterMetadata();
    public object Read59_Item();
    public object Read60_Item();
    public object Read61_Item();
    public object Read62_Item();
    public object Read63_Item();
    public object Read64_ObsoleteAttributeMetadata();
    public object Read65_Item();
    public object Read66_Item();
    public object Read67_QueryOption();
    public object Read68_GetCmdletMetadata();
    public object Read69_CommonCmdletMetadata();
    public object Read70_ConfirmImpact();
    public object Read71_StaticCmdletMetadata();
    public object Read72_Item();
    public object Read73_CommonMethodMetadata();
    public object Read74_StaticMethodMetadata();
    public object Read75_CommonMethodParameterMetadata();
    public object Read76_StaticMethodParameterMetadata();
    public object Read77_CmdletOutputMetadata();
    public object Read78_Item();
    public object Read79_Item();
    public object Read80_InstanceMethodMetadata();
    public object Read81_InstanceCmdletMetadata();
    public object Read82_PropertyQuery();
    public object Read83_WildcardablePropertyQuery();
    public object Read84_ItemsChoiceType();
    public object Read85_ClassMetadataData();
    public object Read86_EnumMetadataEnum();
    public object Read87_EnumMetadataEnumValue();
    private EnumMetadataEnumValue Read49_EnumMetadataEnumValue(bool isNullable, bool checkType);
    private EnumMetadataEnum Read48_EnumMetadataEnum(bool isNullable, bool checkType);
    private EnumMetadataEnumValue Read37_EnumMetadataEnumValue(bool isNullable, bool checkType);
    private ClassMetadataData Read47_ClassMetadataData(bool isNullable, bool checkType);
    private ItemsChoiceType Read3_ItemsChoiceType(string s);
    private WildcardablePropertyQuery Read13_WildcardablePropertyQuery(bool isNullable, bool checkType);
    private CmdletParameterMetadataForGetCmdletFilteringParameter Read12_Item(bool isNullable, bool checkType);
    private ObsoleteAttributeMetadata Read7_ObsoleteAttributeMetadata(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateRange Read6_Item(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateLength Read5_Item(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateCount Read4_Item(bool isNullable, bool checkType);
    private object Read1_Object(bool isNullable, bool checkType);
    private EnumMetadataEnum Read38_EnumMetadataEnum(bool isNullable, bool checkType);
    private ClassMetadataData Read35_ClassMetadataData(bool isNullable, bool checkType);
    private StaticCmdletMetadata Read34_StaticCmdletMetadata(bool isNullable, bool checkType);
    private StaticMethodMetadata Read28_StaticMethodMetadata(bool isNullable, bool checkType);
    private StaticMethodParameterMetadata Read27_StaticMethodParameterMetadata(bool isNullable, bool checkType);
    private CmdletOutputMetadata Read23_CmdletOutputMetadata(bool isNullable, bool checkType);
    private CmdletParameterMetadataForStaticMethodParameter Read8_Item(bool isNullable, bool checkType);
    private TypeMetadata Read2_TypeMetadata(bool isNullable, bool checkType);
    private CommonMethodMetadataReturnValue Read24_Item(bool isNullable, bool checkType);
    private StaticCmdletMetadataCmdletMetadata Read33_Item(bool isNullable, bool checkType);
    private ConfirmImpact Read20_ConfirmImpact(string s);
    private InstanceMethodParameterMetadata Read25_Item(bool isNullable, bool checkType);
    private CmdletParameterMetadataForInstanceMethodParameter Read9_Item(bool isNullable, bool checkType);
    private QueryOption Read18_QueryOption(bool isNullable, bool checkType);
    private CmdletParameterMetadataForGetCmdletParameter Read11_Item(bool isNullable, bool checkType);
    private Association Read17_Association(bool isNullable, bool checkType);
    private AssociationAssociatedInstance Read16_AssociationAssociatedInstance(bool isNullable, bool checkType);
    private PropertyMetadata Read15_PropertyMetadata(bool isNullable, bool checkType);
    private PropertyQuery Read14_PropertyQuery(bool isNullable, bool checkType);
    private CmdletParameterMetadata Read10_CmdletParameterMetadata(bool isNullable, bool checkType);
    private GetCmdletParameters Read19_GetCmdletParameters(bool isNullable, bool checkType);
    private StaticCmdletMetadataCmdletMetadata Read45_Item(bool isNullable, bool checkType);
    private CommonCmdletMetadata Read21_CommonCmdletMetadata(bool isNullable, bool checkType);
    private GetCmdletMetadata Read22_GetCmdletMetadata(bool isNullable, bool checkType);
    private InstanceMethodMetadata Read30_InstanceMethodMetadata(bool isNullable, bool checkType);
    private CommonMethodMetadata Read29_CommonMethodMetadata(bool isNullable, bool checkType);
    private CommonMethodParameterMetadata Read26_CommonMethodParameterMetadata(bool isNullable, bool checkType);
    private InstanceCmdletMetadata Read31_InstanceCmdletMetadata(bool isNullable, bool checkType);
    private ClassMetadata Read36_ClassMetadata(bool isNullable, bool checkType);
    private ClassMetadataInstanceCmdlets Read32_ClassMetadataInstanceCmdlets(bool isNullable, bool checkType);
    private ClassMetadataInstanceCmdlets Read40_ClassMetadataInstanceCmdlets(bool isNullable, bool checkType);
    private AssociationAssociatedInstance Read41_AssociationAssociatedInstance(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateCount Read42_Item(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateLength Read43_Item(bool isNullable, bool checkType);
    private CmdletParameterMetadataValidateRange Read44_Item(bool isNullable, bool checkType);
    private CommonMethodMetadataReturnValue Read46_Item(bool isNullable, bool checkType);
    private PowerShellMetadata Read39_PowerShellMetadata(bool isNullable, bool checkType);
    private void InitIDs();
}
[CmdletAttribute("Add", "History")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.HistoryInfo")]
public class Microsoft.PowerShell.Commands.AddHistoryCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private PSObject[] <InputObject>k__BackingField;
    private bool _passthru;
    [ParameterAttribute]
public PSObject[] InputObject { get; public set; }
    [ParameterAttribute]
public SwitchParameter Passthru { get; public set; }
    [CompilerGeneratedAttribute]
public PSObject[] get_InputObject();
    [CompilerGeneratedAttribute]
public void set_InputObject(PSObject[] value);
    public SwitchParameter get_Passthru();
    public void set_Passthru(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private HistoryInfo GetHistoryInfoObject(PSObject mshObject);
    private static object GetPropertyValue(PSObject mshObject, string propertyName);
}
[CmdletProviderAttribute("Alias", "16")]
[OutputTypeAttribute("System.Management.Automation.AliasInfo")]
[OutputTypeAttribute("System.Management.Automation.AliasInfo")]
[OutputTypeAttribute("System.Management.Automation.AliasInfo")]
[OutputTypeAttribute("System.Management.Automation.AliasInfo")]
[OutputTypeAttribute("System.Management.Automation.AliasInfo")]
public class Microsoft.PowerShell.Commands.AliasProvider : SessionStateProviderBase {
    public static string ProviderName;
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    protected virtual object NewItemDynamicParameters(string path, string type, object newItemValue);
    protected virtual object SetItemDynamicParameters(string path, object value);
    internal virtual object GetSessionStateItem(string name);
    internal virtual object GetValueOfItem(object item);
    internal virtual void SetSessionStateItem(string name, object value, bool writeItem);
    internal virtual void RemoveSessionStateItem(string name);
    internal virtual IDictionary GetSessionStateTable();
    internal virtual bool CanRenameItem(object item);
}
public class Microsoft.PowerShell.Commands.AliasProviderDynamicParameters : object {
    private ScopedItemOptions _options;
    private bool _optionsSet;
    [ParameterAttribute]
public ScopedItemOptions Options { get; public set; }
    internal bool OptionsSet { get; }
    public ScopedItemOptions get_Options();
    public void set_Options(ScopedItemOptions value);
    internal bool get_OptionsSet();
}
internal class Microsoft.PowerShell.Commands.ArgumentToModuleTransformationAttribute : ArgumentTransformationAttribute {
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
    private static bool TryConvertFromDeserializedModuleInfo(object inputData, PSModuleInfo& moduleInfo);
}
internal class Microsoft.PowerShell.Commands.BackReaderEncodingNotSupportedException : NotSupportedException {
    [CompilerGeneratedAttribute]
private string <EncodingName>k__BackingField;
    internal string EncodingName { get; }
    internal BackReaderEncodingNotSupportedException(string message, string encodingName);
    internal BackReaderEncodingNotSupportedException(string encodingName);
    [CompilerGeneratedAttribute]
internal string get_EncodingName();
}
internal class Microsoft.PowerShell.Commands.BinaryAnalysisResult : object {
    [CompilerGeneratedAttribute]
private List`1<string> <DetectedCmdlets>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Tuple`2<string, string>> <DetectedAliases>k__BackingField;
    internal List`1<string> DetectedCmdlets { get; internal set; }
    internal List`1<Tuple`2<string, string>> DetectedAliases { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<string> get_DetectedCmdlets();
    [CompilerGeneratedAttribute]
internal void set_DetectedCmdlets(List`1<string> value);
    [CompilerGeneratedAttribute]
internal List`1<Tuple`2<string, string>> get_DetectedAliases();
    [CompilerGeneratedAttribute]
internal void set_DetectedAliases(List`1<Tuple`2<string, string>> value);
}
internal enum Microsoft.PowerShell.Commands.CertificatePurpose : Enum {
    public int value__;
    public static CertificatePurpose NotSpecified;
    public static CertificatePurpose CodeSigning;
    public static CertificatePurpose DocumentEncryption;
    public static CertificatePurpose All;
}
[CmdletAttribute("Clear", "History")]
public class Microsoft.PowerShell.Commands.ClearHistoryCommand : PSCmdlet {
    private Int32[] _id;
    private String[] _commandline;
    private int _count;
    private bool _countParameterSpecified;
    private SwitchParameter _newest;
    private History _history;
    private HistoryInfo[] _entries;
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] CommandLine { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Count { get; public set; }
    [ParameterAttribute]
public SwitchParameter Newest { get; public set; }
    public Int32[] get_Id();
    public void set_Id(Int32[] value);
    public String[] get_CommandLine();
    public void set_CommandLine(String[] value);
    public int get_Count();
    public void set_Count(int value);
    public SwitchParameter get_Newest();
    public void set_Newest(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private void ClearHistoryByID();
    private void ClearHistoryByCmdLine();
    private void ClearHistoryEntries(long id, int count, string cmdline, SwitchParameter newest);
}
[CmdletAttribute("Connect", "PSSession")]
[OutputTypeAttribute("System.Management.Automation.Runspaces.PSSession")]
public class Microsoft.PowerShell.Commands.ConnectPSSessionCommand : PSRunspaceCmdlet {
    private static string ComputerNameGuidParameterSet;
    private static string ConnectionUriParameterSet;
    private static string ConnectionUriGuidParameterSet;
    [CompilerGeneratedAttribute]
private PSSession[] <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ComputerName>k__BackingField;
    private string _appName;
    private string _shell;
    [CompilerGeneratedAttribute]
private Uri[] <ConnectionUri>k__BackingField;
    private bool _allowRedirection;
    private PSCredential _psCredential;
    private AuthenticationMechanism _authentication;
    private string _thumbprint;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseSSL>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSessionOption <SessionOption>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    private Collection`1<PSSession> _allSessions;
    private ThrottleManager _throttleManager;
    private ManualResetEvent _operationsComplete;
    private QueryRunspaces _queryRunspaces;
    private ObjectStream _stream;
    private ThrottleManager _retryThrottleManager;
    private Collection`1<PSSession> _failedSessions;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string ApplicationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri[] ConnectionUri { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter AllowRedirection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public Guid[] InstanceId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string CertificateThumbprint { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Port { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter UseSSL { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public PSSessionOption SessionOption { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int ThrottleLimit { get; public set; }
    public String[] ContainerId { get; }
    public Guid[] VMId { get; }
    public String[] VMName { get; }
    [CompilerGeneratedAttribute]
public PSSession[] get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(PSSession[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(String[] value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public Uri[] get_ConnectionUri();
    [CompilerGeneratedAttribute]
public void set_ConnectionUri(Uri[] value);
    public SwitchParameter get_AllowRedirection();
    public void set_AllowRedirection(SwitchParameter value);
    public virtual Guid[] get_InstanceId();
    public virtual void set_InstanceId(Guid[] value);
    public virtual String[] get_Name();
    public virtual void set_Name(String[] value);
    public PSCredential get_Credential();
    public void set_Credential(PSCredential value);
    public AuthenticationMechanism get_Authentication();
    public void set_Authentication(AuthenticationMechanism value);
    public string get_CertificateThumbprint();
    public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseSSL();
    [CompilerGeneratedAttribute]
public void set_UseSSL(SwitchParameter value);
    [CompilerGeneratedAttribute]
public PSSessionOption get_SessionOption();
    [CompilerGeneratedAttribute]
public void set_SessionOption(PSSessionOption value);
    [CompilerGeneratedAttribute]
public int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public void set_ThrottleLimit(int value);
    public virtual String[] get_ContainerId();
    public virtual Guid[] get_VMId();
    public virtual String[] get_VMName();
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private Collection`1<PSSession> QueryForDisconnectedSessions();
    private Collection`1<PSSession> CollectDisconnectedSessions(OverrideParameter overrideParam);
    private void ConnectSessions(Collection`1<PSSession> psSessions);
    private void HandleThrottleConnectComplete(object sender, EventArgs eventArgs);
    private Collection`1<WSManConnectionInfo> GetConnectionObjects();
    private void UpdateConnectionInfo(WSManConnectionInfo connectionInfo);
    private void RetryFailedSessions();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class Microsoft.PowerShell.Commands.CopyItemDynamicParameters : object {
    [CompilerGeneratedAttribute]
private PSSession <FromSession>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSession <ToSession>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession FromSession { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession ToSession { get; public set; }
    [CompilerGeneratedAttribute]
public PSSession get_FromSession();
    [CompilerGeneratedAttribute]
public void set_FromSession(PSSession value);
    [CompilerGeneratedAttribute]
public PSSession get_ToSession();
    [CompilerGeneratedAttribute]
public void set_ToSession(PSSession value);
}
[CmdletAttribute("Debug", "Job")]
public class Microsoft.PowerShell.Commands.DebugJobCommand : PSCmdlet {
    private static string JobParameterSet;
    private static string JobNameParameterSet;
    private static string JobIdParameterSet;
    private static string JobInstanceIdParameterSet;
    private Job _job;
    private Debugger _debugger;
    private PSDataCollection`1<PSStreamObject> _debugCollection;
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <BreakAll>k__BackingField;
    [ParameterAttribute]
public Job Job { get; public set; }
    [ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public int Id { get; public set; }
    [ParameterAttribute]
public Guid InstanceId { get; public set; }
    [ParameterAttribute]
public SwitchParameter BreakAll { get; public set; }
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
public void set_InstanceId(Guid value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_BreakAll();
    [CompilerGeneratedAttribute]
public void set_BreakAll(SwitchParameter value);
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private bool CheckForDebuggableJob();
    private static bool GetJobDebuggable(Job job);
    private void WaitAndReceiveJobOutput();
    private void HandleJobStateChangedEvent(object sender, JobStateEventArgs stateChangedArgs);
    private void HandleResultsDataAdding(object sender, DataAddingEventArgs dataAddingArgs);
    private void HandleDebuggerNestedDebuggingCancelledEvent(object sender, EventArgs e);
    private void AddEventHandlers();
    private void RemoveEventHandlers();
    private Job GetJobByName(string name);
    private Job GetJobById(int id);
    private Job GetJobByInstanceId(Guid instanceId);
}
[CmdletAttribute("Disable", "ExperimentalFeature")]
public class Microsoft.PowerShell.Commands.DisableExperimentalFeatureCommand : EnableDisableExperimentalFeatureCommandBase {
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Disable", "PSRemoting")]
public class Microsoft.PowerShell.Commands.DisablePSRemotingCommand : PSCmdlet {
    private static string disablePSRemotingFormat;
    private static ScriptBlock s_disableRemotingSb;
    private bool _force;
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    private static DisablePSRemotingCommand();
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Disable", "PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.DisablePSSessionConfigurationCommand : PSCmdlet {
    private static string disablePluginSbFormat;
    private static ScriptBlock s_disablePluginSb;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    private Collection`1<string> _shellsToDisable;
    private bool _force;
    private bool _noRestart;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoServiceRestart { get; public set; }
    private static DisablePSSessionConfigurationCommand();
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public SwitchParameter get_NoServiceRestart();
    public void set_NoServiceRestart(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Disconnect", "PSSession")]
[OutputTypeAttribute("System.Management.Automation.Runspaces.PSSession")]
public class Microsoft.PowerShell.Commands.DisconnectPSSessionCommand : PSRunspaceCmdlet {
    [CompilerGeneratedAttribute]
private PSSession[] <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ComputerName>k__BackingField;
    private PSSessionOption _sessionOption;
    private ThrottleManager _throttleManager;
    private ManualResetEvent _operationsComplete;
    private ObjectStream _stream;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int IdleTimeoutSec { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public OutputBufferingMode OutputBufferingMode { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int ThrottleLimit { get; public set; }
    public String[] ComputerName { get; public set; }
    private PSSessionOption PSSessionOption { get; }
    public String[] ContainerId { get; }
    public Guid[] VMId { get; }
    public String[] VMName { get; }
    [CompilerGeneratedAttribute]
public PSSession[] get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(PSSession[] value);
    public int get_IdleTimeoutSec();
    public void set_IdleTimeoutSec(int value);
    public OutputBufferingMode get_OutputBufferingMode();
    public void set_OutputBufferingMode(OutputBufferingMode value);
    [CompilerGeneratedAttribute]
public int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public void set_ThrottleLimit(int value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(String[] value);
    private PSSessionOption get_PSSessionOption();
    public virtual String[] get_ContainerId();
    public virtual Guid[] get_VMId();
    public virtual String[] get_VMName();
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private void HandleThrottleDisconnectComplete(object sender, EventArgs eventArgs);
    private bool ValidateIdleTimeout(PSSession session);
    private static string GetLocalhostWithNetworkAccessEnabled(Dictionary`2<Guid, PSSession> psSessions);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal class Microsoft.PowerShell.Commands.DynamicPropertyGetter : ValueType {
    private CallSite`1<Func`3<CallSite, object, object>> _getValueDynamicSite;
    private string _lastUsedPropertyName;
    public object GetValue(PSObject inputObject, string propertyName);
}
public class Microsoft.PowerShell.Commands.EnableDisableExperimentalFeatureCommandBase : PSCmdlet {
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigScope <Scope>k__BackingField;
    [ParameterAttribute]
[ArgumentCompleterAttribute("Microsoft.PowerShell.Commands.ExperimentalFeatureNameCompleter")]
public String[] Name { get; public set; }
    [ParameterAttribute]
public ConfigScope Scope { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public ConfigScope get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(ConfigScope value);
    protected virtual void EndProcessing();
}
[CmdletAttribute("Enable", "ExperimentalFeature")]
public class Microsoft.PowerShell.Commands.EnableExperimentalFeatureCommand : EnableDisableExperimentalFeatureCommandBase {
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Enable", "PSRemoting")]
public class Microsoft.PowerShell.Commands.EnablePSRemotingCommand : PSCmdlet {
    private static string enableRemotingSbFormat;
    private static ScriptBlock s_enableRemotingSb;
    private bool _force;
    private bool _skipNetworkProfileCheck;
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter SkipNetworkProfileCheck { get; public set; }
    private static EnablePSRemotingCommand();
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public SwitchParameter get_SkipNetworkProfileCheck();
    public void set_SkipNetworkProfileCheck(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Enable", "PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.EnablePSSessionConfigurationCommand : PSCmdlet {
    private static string setWSManConfigCommand;
    private static string enablePluginSbFormat;
    private static ScriptBlock s_enablePluginSb;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    private Collection`1<string> _shellsToEnable;
    private bool _force;
    internal string sddl;
    internal bool isSddlSpecified;
    private bool _skipNetworkProfileCheck;
    private bool _noRestart;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public string SecurityDescriptorSddl { get; public set; }
    [ParameterAttribute]
public SwitchParameter SkipNetworkProfileCheck { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoServiceRestart { get; public set; }
    private static EnablePSSessionConfigurationCommand();
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public string get_SecurityDescriptorSddl();
    public void set_SecurityDescriptorSddl(string value);
    public SwitchParameter get_SkipNetworkProfileCheck();
    public void set_SkipNetworkProfileCheck(SwitchParameter value);
    public SwitchParameter get_NoServiceRestart();
    public void set_NoServiceRestart(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Enter", "PSHostProcess")]
public class Microsoft.PowerShell.Commands.EnterPSHostProcessCommand : PSCmdlet {
    private IHostSupportsInteractiveSession _interactiveHost;
    private RemoteRunspace _connectingRemoteRunspace;
    private static string ProcessParameterSet;
    private static string ProcessNameParameterSet;
    private static string ProcessIdParameterSet;
    private static string PipeNameParameterSet;
    private static string PSHostProcessInfoParameterSet;
    private static string NamedPipeRunspaceName;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PSHostProcessInfo <HostProcessInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomPipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainName>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Process Process { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Id { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public PSHostProcessInfo HostProcessInfo { get; public set; }
    [ParameterAttribute]
public string CustomPipeName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string AppDomainName { get; public set; }
    [CompilerGeneratedAttribute]
public Process get_Process();
    [CompilerGeneratedAttribute]
public void set_Process(Process value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public PSHostProcessInfo get_HostProcessInfo();
    [CompilerGeneratedAttribute]
public void set_HostProcessInfo(PSHostProcessInfo value);
    [CompilerGeneratedAttribute]
public string get_CustomPipeName();
    [CompilerGeneratedAttribute]
public void set_CustomPipeName(string value);
    [CompilerGeneratedAttribute]
public string get_AppDomainName();
    [CompilerGeneratedAttribute]
public void set_AppDomainName(string value);
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private Runspace CreateNamedPipeRunspace(string customPipeName);
    private Runspace CreateNamedPipeRunspace(int procId, string appDomainName);
    private Runspace CreateNamedPipeRunspace(NamedPipeConnectionInfo connectionInfo);
    private static void PrepareRunspace(Runspace runspace);
    private Process GetProcessById(int procId);
    private Process GetProcessByHostProcessInfo(PSHostProcessInfo hostProcessInfo);
    private Process GetProcessByName(string name);
    private void VerifyProcess(Process process);
    private void VerifyPipeName(string customPipeName);
}
[CmdletAttribute("Enter", "PSSession")]
public class Microsoft.PowerShell.Commands.EnterPSSessionCommand : PSRemotingBaseCmdlet {
    private static string InstanceIdParameterSet;
    private static string IdParameterSet;
    private static string NameParameterSet;
    private ObjectStream _stream;
    private RemoteRunspace _tempRunspace;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ConnectionUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <EnableNetworkAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <VMId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VMName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    public int ThrottleLimit { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string HostName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable Options { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public string ComputerName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession Session { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri ConnectionUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Guid InstanceId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public int Id { get; public set; }
    [ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter EnableNetworkAccess { get; public set; }
    [ValidateNotNullOrEmptyAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Guid VMId { get; public set; }
    [ValidateNotNullOrEmptyAttribute]
[ParameterAttribute]
public string VMName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ValidateNotNullOrEmptyAttribute]
[ParameterAttribute]
public string ContainerId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    public Hashtable[] SSHConnection { get; }
    public int get_ThrottleLimit();
    public void set_ThrottleLimit(int value);
    [CompilerGeneratedAttribute]
public string get_HostName();
    [CompilerGeneratedAttribute]
public void set_HostName(string value);
    public virtual Hashtable get_Options();
    public virtual void set_Options(Hashtable value);
    [CompilerGeneratedAttribute]
public string get_ComputerName();
    [CompilerGeneratedAttribute]
public void set_ComputerName(string value);
    [CompilerGeneratedAttribute]
public PSSession get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(PSSession value);
    [CompilerGeneratedAttribute]
public Uri get_ConnectionUri();
    [CompilerGeneratedAttribute]
public void set_ConnectionUri(Uri value);
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
public void set_InstanceId(Guid value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_EnableNetworkAccess();
    [CompilerGeneratedAttribute]
public void set_EnableNetworkAccess(SwitchParameter value);
    [CompilerGeneratedAttribute]
public Guid get_VMId();
    [CompilerGeneratedAttribute]
public void set_VMId(Guid value);
    [CompilerGeneratedAttribute]
public string get_VMName();
    [CompilerGeneratedAttribute]
public void set_VMName(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    [CompilerGeneratedAttribute]
public string get_ContainerId();
    [CompilerGeneratedAttribute]
public void set_ContainerId(string value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    public virtual Hashtable[] get_SSHConnection();
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private RemoteRunspace CreateTemporaryRemoteRunspace(PSHost host, WSManConnectionInfo connectionInfo);
    private void WriteErrorCreateRemoteRunspaceFailed(Exception exception, object argument);
    private void WriteInvalidArgumentError(PSRemotingErrorId errorId, string resourceString, object errorArgument);
    private void HandleURIDirectionReported(object sender, RemoteDataEventArgs`1<Uri> eventArgs);
    private RemoteRunspace CreateRunspaceWhenComputerNameParameterSpecified();
    private RemoteRunspace CreateRunspaceWhenUriParameterSpecified();
    private RemoteRunspace GetRunspaceMatchingCondition(Predicate`1<PSSession> condition, PSRemotingErrorId tooFew, PSRemotingErrorId tooMany, string tooFewResourceString, string tooManyResourceString, object errorArgument);
    private RemoteRunspace GetRunspaceMatchingRunspaceId(Guid remoteRunspaceId);
    private RemoteRunspace GetRunspaceMatchingSessionId(int sessionId);
    private RemoteRunspace GetRunspaceMatchingName(string name);
    private Job FindJobForRunspace(Guid id);
    private bool IsParameterSetForVM();
    private bool IsParameterSetForContainer();
    private bool IsParameterSetForVMContainerSession();
    private RemoteRunspace GetRunspaceForVMSession();
    private static RemoteRunspace CreateTemporaryRemoteRunspaceForPowerShellDirect(PSHost host, RunspaceConnectionInfo connectionInfo);
    private void SetRunspacePrompt(RemoteRunspace remoteRunspace);
    private RemoteRunspace GetRunspaceForContainerSession();
    private RemoteRunspace GetRunspaceForSSHSession();
    internal static RemotePipeline ConnectRunningPipeline(RemoteRunspace remoteRunspace);
    internal static void ContinueCommand(RemoteRunspace remoteRunspace, Pipeline cmd, PSHost host, bool inDebugMode, ExecutionContext context);
}
internal static class Microsoft.PowerShell.Commands.EnumerableExpansionConversion : object {
    internal static string CoreOnlyString;
    internal static string EnumOnlyString;
    internal static string BothString;
    internal static bool Convert(string expansionString, EnumerableExpansion& expansion);
}
[CmdletProviderAttribute("Environment", "16")]
public class Microsoft.PowerShell.Commands.EnvironmentProvider : SessionStateProviderBase {
    public static string ProviderName;
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    internal virtual object GetSessionStateItem(string name);
    internal virtual void SetSessionStateItem(string name, object value, bool writeItem);
    internal virtual void RemoveSessionStateItem(string name);
    internal virtual IDictionary GetSessionStateTable();
    internal virtual object GetValueOfItem(object item);
}
internal abstract class Microsoft.PowerShell.Commands.ExecutionCmdletHelper : IThrottleOperation {
    protected Pipeline pipeline;
    protected Exception internalException;
    [CompilerGeneratedAttribute]
private Runspace <PipelineRunspace>k__BackingField;
    internal Pipeline Pipeline { get; }
    internal Exception InternalException { get; }
    internal Runspace PipelineRunspace { get; internal set; }
    internal Pipeline get_Pipeline();
    internal Exception get_InternalException();
    [CompilerGeneratedAttribute]
internal Runspace get_PipelineRunspace();
    [CompilerGeneratedAttribute]
internal void set_PipelineRunspace(Runspace value);
    internal void ConfigureRunspaceDebugging(Runspace runspace);
    internal void CleanupRunspaceDebugging(Runspace runspace);
    private void HandleDebuggerStop(object sender, DebuggerStopEventArgs args);
}
internal class Microsoft.PowerShell.Commands.ExecutionCmdletHelperComputerName : ExecutionCmdletHelper {
    private bool _invokeAndDisconnect;
    [CompilerGeneratedAttribute]
private RemoteRunspace <RemoteRunspace>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<OperationStateEventArgs> OperationComplete;
    internal RemoteRunspace RemoteRunspace { get; private set; }
    internal ExecutionCmdletHelperComputerName(RemoteRunspace remoteRunspace, Pipeline pipeline, bool invokeAndDisconnect);
    [CompilerGeneratedAttribute]
internal RemoteRunspace get_RemoteRunspace();
    [CompilerGeneratedAttribute]
private void set_RemoteRunspace(RemoteRunspace value);
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void HandleRunspaceStateChanged(object sender, RunspaceStateEventArgs stateEventArgs);
    private void HandlePipelineStateChanged(object sender, PipelineStateEventArgs stateEventArgs);
    private void RaiseOperationCompleteEvent();
    private void RaiseOperationCompleteEvent(EventArgs baseEventArgs);
}
internal class Microsoft.PowerShell.Commands.ExecutionCmdletHelperRunspace : ExecutionCmdletHelper {
    internal bool ShouldUseSteppablePipelineOnServer;
    [CompilerGeneratedAttribute]
private EventHandler`1<OperationStateEventArgs> OperationComplete;
    internal ExecutionCmdletHelperRunspace(Pipeline pipeline);
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void HandlePipelineStateChanged(object sender, PipelineStateEventArgs stateEventArgs);
    private void RaiseOperationCompleteEvent();
    private void RaiseOperationCompleteEvent(EventArgs baseEventArgs);
}
[CmdletAttribute("Exit", "PSHostProcess")]
public class Microsoft.PowerShell.Commands.ExitPSHostProcessCommand : PSCmdlet {
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Exit", "PSSession")]
public class Microsoft.PowerShell.Commands.ExitPSSessionCommand : PSRemotingCmdlet {
    protected virtual void ProcessRecord();
}
internal static class Microsoft.PowerShell.Commands.ExperimentalFeatureConfigHelper : object {
    internal static void UpdateConfig(PSCmdlet cmdlet, String[] name, ConfigScope scope, bool enable);
}
public class Microsoft.PowerShell.Commands.ExperimentalFeatureNameCompleter : object {
    public sealed virtual IEnumerable`1<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
[CmdletAttribute("Export", "ModuleMember")]
public class Microsoft.PowerShell.Commands.ExportModuleMemberCommand : PSCmdlet {
    private String[] _functionList;
    private List`1<WildcardPattern> _functionPatterns;
    private String[] _cmdletList;
    private List`1<WildcardPattern> _cmdletPatterns;
    private String[] _variableExportList;
    private List`1<WildcardPattern> _variablePatterns;
    private String[] _aliasExportList;
    private List`1<WildcardPattern> _aliasPatterns;
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] Function { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] Cmdlet { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Variable { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Alias { get; public set; }
    public String[] get_Function();
    public void set_Function(String[] value);
    public String[] get_Cmdlet();
    public void set_Cmdlet(String[] value);
    public String[] get_Variable();
    public void set_Variable(String[] value);
    public String[] get_Alias();
    public void set_Alias(String[] value);
    protected virtual void ProcessRecord();
}
internal class Microsoft.PowerShell.Commands.FileStreamBackReader : StreamReader {
    private FileStream _stream;
    private Encoding _currentEncoding;
    private Encoding _oemEncoding;
    private Encoding _defaultAnsiEncoding;
    private static int BuffSize;
    private Byte[] _byteBuff;
    private Char[] _charBuff;
    private int _byteCount;
    private int _charCount;
    private long _currentPosition;
    private static byte BothTopBitsSet;
    private static byte TopBitUnset;
    internal FileStreamBackReader(FileStream fileStream, Encoding encoding);
    public virtual int ReadBlock(Char[] buffer, int index, int count);
    public virtual string ReadToEnd();
    internal void DiscardBufferedData();
    internal long GetCurrentPosition();
    internal int GetByteCount(string delimiter);
    public virtual int Peek();
    public virtual int Read();
    public virtual int Read(Char[] buffer, int index, int count);
    public virtual int Read(Span`1<char> buffer);
    private int ReadSpan(Span`1<char> buffer);
    public virtual string ReadLine();
    private int RefillCharBuffer();
    private int RefillByteBuff();
}
public class Microsoft.PowerShell.Commands.FileSystemClearContentDynamicParameters : object {
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [ParameterAttribute]
public string Stream { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(string value);
}
public class Microsoft.PowerShell.Commands.FileSystemContentDynamicParametersBase : object {
    private FileSystemProvider _provider;
    private Encoding _encoding;
    [CompilerGeneratedAttribute]
private SwitchParameter <AsByteStream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WasStreamTypeSpecified>k__BackingField;
    [ParameterAttribute]
[ArgumentToEncodingTransformationAttribute]
[ArgumentEncodingCompletionsAttribute]
[ValidateNotNullOrEmptyAttribute]
public Encoding Encoding { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsByteStream { get; public set; }
    [ParameterAttribute]
public string Stream { get; public set; }
    public bool WasStreamTypeSpecified { get; private set; }
    internal FileSystemContentDynamicParametersBase(FileSystemProvider provider);
    public Encoding get_Encoding();
    public void set_Encoding(Encoding value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_AsByteStream();
    [CompilerGeneratedAttribute]
public void set_AsByteStream(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(string value);
    [CompilerGeneratedAttribute]
public bool get_WasStreamTypeSpecified();
    [CompilerGeneratedAttribute]
private void set_WasStreamTypeSpecified(bool value);
}
public class Microsoft.PowerShell.Commands.FileSystemContentReaderDynamicParameters : FileSystemContentDynamicParametersBase {
    private string _delimiter;
    private bool _wait;
    private bool _isRaw;
    [CompilerGeneratedAttribute]
private bool <DelimiterSpecified>k__BackingField;
    [ParameterAttribute]
public string Delimiter { get; public set; }
    [ParameterAttribute]
public SwitchParameter Wait { get; public set; }
    [ParameterAttribute]
public SwitchParameter Raw { get; public set; }
    public bool DelimiterSpecified { get; private set; }
    internal FileSystemContentReaderDynamicParameters(FileSystemProvider provider);
    public string get_Delimiter();
    public void set_Delimiter(string value);
    public SwitchParameter get_Wait();
    public void set_Wait(SwitchParameter value);
    public SwitchParameter get_Raw();
    public void set_Raw(SwitchParameter value);
    [CompilerGeneratedAttribute]
public bool get_DelimiterSpecified();
    [CompilerGeneratedAttribute]
private void set_DelimiterSpecified(bool value);
}
internal class Microsoft.PowerShell.Commands.FileSystemContentReaderWriter : object {
    [TraceSourceAttribute("FileSystemContentStream", "The provider content reader and writer for the file system")]
private static PSTraceSource s_tracer;
    private string _path;
    private string _streamName;
    private FileMode _mode;
    private FileAccess _access;
    private FileShare _share;
    private Encoding _encoding;
    private CmdletProvider _provider;
    private FileStream _stream;
    private StreamReader _reader;
    private StreamWriter _writer;
    private bool _usingByteEncoding;
    private static char DefaultDelimiter;
    private string _delimiter;
    private Int32[] _offsetDictionary;
    private bool _usingDelimiter;
    private StringBuilder _currentLineContent;
    private bool _waitForChanges;
    private bool _isRawStream;
    private long _fileOffset;
    private FileAttributes _oldAttributes;
    private bool _haveOldAttributes;
    private FileStreamBackReader _backReader;
    private bool _alreadyDetectEncoding;
    private bool _suppressNewline;
    public FileSystemContentReaderWriter(string path, FileMode mode, FileAccess access, FileShare share, Encoding encoding, bool usingByteEncoding, bool waitForChanges, CmdletProvider provider, bool isRawStream);
    public FileSystemContentReaderWriter(string path, string streamName, FileMode mode, FileAccess access, FileShare share, Encoding encoding, bool usingByteEncoding, bool waitForChanges, CmdletProvider provider, bool isRawStream);
    public FileSystemContentReaderWriter(string path, string streamName, FileMode mode, FileAccess access, FileShare share, Encoding encoding, bool usingByteEncoding, bool waitForChanges, CmdletProvider provider, bool isRawStream, bool suppressNewline);
    public FileSystemContentReaderWriter(string path, string streamName, FileMode mode, FileAccess access, FileShare share, string delimiter, Encoding encoding, bool waitForChanges, CmdletProvider provider, bool isRawStream);
    private static FileSystemContentReaderWriter();
    public sealed virtual IList Read(long readCount);
    internal IList ReadWithoutWaitingChanges(long readCount);
    internal void SeekItemsBackward(int backCount);
    private bool ReadByLine(bool waitChanges, List`1<object> blocks, bool readBackward);
    private bool ReadDelimited(bool waitChanges, List`1<object> blocks, bool readBackward, string actualDelimiter);
    private bool ReadByteEncoded(bool waitChanges, List`1<object> blocks, bool readBackward);
    private void CreateStreams(string filePath, string streamName, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, Encoding fileEncoding);
    private void WaitForChanges(string filePath, FileMode fileMode, FileAccess fileAccess, FileShare fileShare, Encoding fileEncoding);
    public sealed virtual void Seek(long offset, SeekOrigin origin);
    public sealed virtual void Close();
    public sealed virtual IList Write(IList content);
    private void WriteObject(object content);
    public sealed virtual void Dispose();
    internal void Dispose(bool isDisposing);
}
public class Microsoft.PowerShell.Commands.FileSystemContentWriterDynamicParameters : FileSystemContentDynamicParametersBase {
    private bool _suppressNewline;
    [ParameterAttribute]
public SwitchParameter NoNewline { get; public set; }
    internal FileSystemContentWriterDynamicParameters(FileSystemProvider provider);
    public SwitchParameter get_NoNewline();
    public void set_NoNewline(SwitchParameter value);
}
public class Microsoft.PowerShell.Commands.FileSystemItemProviderDynamicParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <OlderThan>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NewerThan>k__BackingField;
    [ParameterAttribute]
public Nullable`1<DateTime> OlderThan { get; public set; }
    [ParameterAttribute]
public Nullable`1<DateTime> NewerThan { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_OlderThan();
    [CompilerGeneratedAttribute]
public void set_OlderThan(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NewerThan();
    [CompilerGeneratedAttribute]
public void set_NewerThan(Nullable`1<DateTime> value);
}
[CmdletProviderAttribute("FileSystem", "52")]
[OutputTypeAttribute("System.Security.AccessControl.FileSecurity")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.IO.FileInfo")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.FileSystemProvider : NavigationCmdletProvider {
    private static int FILETRANSFERSIZE;
    private static int COPY_FILE_ACTIVITY_ID;
    private static string SelfCopyDataKey;
    [TraceSourceAttribute("FileSystemProvider", "The namespace navigation provider for the file system")]
private static PSTraceSource s_tracer;
    public static string ProviderName;
    private Collection`1<WildcardPattern> _excludeMatcher;
    private static EnumerationOptions _enumerationOptions;
    private long _totalFiles;
    private long _totalBytes;
    private long _copiedFiles;
    private long _copiedBytes;
    private Stopwatch _copyStopwatch;
    private static FileSystemProvider();
    internal static string NormalizePath(string path);
    private static string GetCorrectCasedPath(string path);
    private static FileSystemInfo GetFileSystemInfo(string path, Boolean& isContainer);
    internal virtual bool IsFilterSet();
    protected virtual object GetChildNamesDynamicParameters(string path);
    protected virtual object GetChildItemsDynamicParameters(string path, bool recurse);
    protected virtual object CopyItemDynamicParameters(string path, string destination, bool recurse);
    public sealed virtual string GetHelpMaml(string helpItemName, string path);
    protected virtual ProviderInfo Start(ProviderInfo providerInfo);
    protected virtual PSDriveInfo NewDrive(PSDriveInfo drive);
    private void MapNetworkDrive(PSDriveInfo drive);
    private static bool IsNetworkMappedDrive(PSDriveInfo drive);
    protected virtual PSDriveInfo RemoveDrive(PSDriveInfo drive);
    private static bool IsSupportedDriveForPersistence(PSDriveInfo drive);
    internal static string GetUNCForNetworkDrive(string driveName);
    internal static string GetSubstitutedPathForNetworkDosDevice(string driveName);
    private static string WinGetSubstitutedPathForNetworkDosDevice(string driveName);
    internal static string GetRootPathForNetworkDriveOrDosDevice(DriveInfo driveInfo);
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    protected virtual object GetItemDynamicParameters(string path);
    protected virtual bool IsValidPath(string path);
    protected virtual void GetItem(string path);
    private FileSystemInfo GetFileSystemItem(string path, Boolean& isContainer, bool showHidden);
    protected virtual void InvokeDefaultAction(string path);
    protected virtual void GetChildItems(string path, bool recurse, UInt32 depth);
    protected virtual void GetChildNames(string path, ReturnContainers returnContainers);
    protected virtual bool ConvertPath(string path, string filter, String& updatedPath, String& updatedFilter);
    private void GetPathItems(string path, bool recurse, UInt32 depth, bool nameOnly, ReturnContainers returnContainers);
    private void Dir(DirectoryInfo directory, bool recurse, UInt32 depth, bool nameOnly, ReturnContainers returnContainers, InodeTracker tracker);
    private FlagsExpression`1<FileAttributes> FormatAttributeSwitchParameters();
    public static string Mode(PSObject instance);
    public static string ModeWithoutHardLink(PSObject instance);
    private static string Mode(PSObject instance, bool excludeHardLink);
    public static string NameString(PSObject instance);
    public static string LengthString(PSObject instance);
    public static string LastWriteTimeString(PSObject instance);
    protected virtual void RenameItem(string path, string newName);
    protected virtual void NewItem(string path, string type, object value);
    private static bool WinCreateSymbolicLink(string path, string strTargetPath, bool isDirectory);
    private static bool WinCreateJunction(string path, string strTargetPath);
    private static ItemType GetItemType(string input);
    private void CreateDirectory(string path, bool streamOutput);
    private bool CreateIntermediateDirectories(string path);
    protected virtual void RemoveItem(string path, bool recurse);
    protected virtual object RemoveItemDynamicParameters(string path, bool recurse);
    private void RemoveDirectoryInfoItem(DirectoryInfo directory, bool recurse, bool force, bool rootOfRemoval);
    private void RemoveFileInfoItem(FileInfo file, bool force);
    private void RemoveFileSystemItem(FileSystemInfo fileSystemInfo, bool force);
    protected virtual bool ItemExists(string path);
    private bool ItemExists(string path, ErrorRecord& error);
    protected virtual object ItemExistsDynamicParameters(string path);
    protected virtual bool HasChildItems(string path);
    private static bool DirectoryInfoHasChildItems(DirectoryInfo directory);
    protected virtual void CopyItem(string path, string destinationPath, bool recurse);
    private void GetTotalFiles(string path, bool recurse);
    private void CopyItemFromRemoteSession(string path, string destinationPath, bool recurse, bool force, PSSession fromSession);
    private void CopyItemLocalOrToSession(string path, string destinationPath, bool recurse, bool Force, PowerShell ps);
    private void CopyDirectoryInfoItem(DirectoryInfo directory, string destination, bool recurse, bool force, PowerShell ps);
    private void CopyFileInfoItem(FileInfo file, string destinationPath, bool force, PowerShell ps);
    private void CopyDirectoryFromRemoteSession(string sourceDirectoryName, string sourceDirectoryFullName, string destination, bool force, bool recurse, PowerShell ps);
    private ArrayList GetRemoteSourceAlternateStreams(PowerShell ps, string path);
    private void InitializeFunctionPSCopyFileFromRemoteSession(PowerShell ps);
    private void RemoveFunctionsPSCopyFileFromRemoteSession(PowerShell ps);
    private static bool ValidRemoteSessionForScripting(Runspace runspace);
    private Hashtable GetRemoteFileMetadata(string filePath, PowerShell ps);
    private void SetFileMetadata(string sourceFileFullName, FileInfo destinationFile, PowerShell ps);
    private void CopyFileFromRemoteSession(string sourceFileName, string sourceFileFullName, string destinationPath, bool force, PowerShell ps, long fileSize);
    private bool PerformCopyFileFromRemoteSession(string sourceFileFullName, FileInfo destinationFile, string destinationPath, bool force, PowerShell ps, long fileSize, bool isAlternateDataStream, string streamName);
    private void InitializeFunctionsPSCopyFileToRemoteSession(PowerShell ps);
    private void RemoveFunctionPSCopyFileToRemoteSession(PowerShell ps);
    private bool RemoteTargetSupportsAlternateStreams(PowerShell ps, string path);
    private string MakeRemotePath(PowerShell ps, string remotePath, string filename);
    private bool RemoteDirectoryExist(PowerShell ps, string path);
    private bool CopyFileStreamToRemoteSession(FileInfo file, string destinationPath, PowerShell ps, bool isAlternateStream, string streamName);
    private static Hashtable GetFileMetadata(FileInfo file);
    private void SetRemoteFileMetadata(FileInfo file, string remoteFilePath, PowerShell ps);
    private bool PerformCopyFileToRemoteSession(FileInfo file, string destinationPath, PowerShell ps);
    private bool RemoteDestinationPathIsFile(string destination, PowerShell ps);
    private string CreateDirectoryOnRemoteSession(string destination, bool force, PowerShell ps);
    private bool PathIsReservedDeviceName(string destinationPath, string errorId);
    protected virtual string GetParentPath(string path, string root);
    private static bool IsAbsolutePath(string path);
    private static bool IsUNCRoot(string path);
    private static bool IsPathRoot(string path);
    protected virtual string NormalizeRelativePath(string path, string basePath);
    private string NormalizeRelativePathHelper(string path, string basePath);
    private string RemoveRelativeTokens(string path);
    private string GetCommonBase(string path1, string path2);
    private Stack`1<string> TokenizePathToStack(string path, string basePath);
    private Stack`1<string> NormalizeThePath(string basepath, Stack`1<string> tokenizedPathStack);
    private string CreateNormalizedRelativePathFromStack(Stack`1<string> normalizedPathStack);
    protected virtual string GetChildName(string path);
    private static string EnsureDriveIsRooted(string path);
    protected virtual bool IsItemContainer(string path);
    protected virtual void MoveItem(string path, string destination);
    private void MoveFileInfoItem(FileInfo file, string destination, bool force, bool output);
    private void MoveDirectoryInfoItem(DirectoryInfo directory, string destination, bool force);
    private void MoveDirectoryInfoUnchecked(DirectoryInfo directory, string destinationPath, bool force);
    private void CopyAndDelete(DirectoryInfo directory, string destination, bool force);
    public sealed virtual void GetProperty(string path, Collection`1<string> providerSpecificPickList);
    public sealed virtual object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList);
    public sealed virtual void SetProperty(string path, PSObject propertyToSet);
    public sealed virtual object SetPropertyDynamicParameters(string path, PSObject propertyValue);
    public sealed virtual void ClearProperty(string path, Collection`1<string> propertiesToClear);
    public sealed virtual object ClearPropertyDynamicParameters(string path, Collection`1<string> propertiesToClear);
    public sealed virtual IContentReader GetContentReader(string path);
    public sealed virtual object GetContentReaderDynamicParameters(string path);
    public sealed virtual IContentWriter GetContentWriter(string path);
    public sealed virtual object GetContentWriterDynamicParameters(string path);
    public sealed virtual void ClearContent(string path);
    public sealed virtual object ClearContentDynamicParameters(string path);
    private void ValidateParameters(bool isRawSpecified);
    internal static bool PathIsNetworkPath(string path);
    internal static bool WinPathIsNetworkPath(string path);
    public sealed virtual void GetSecurityDescriptor(string path, AccessControlSections sections);
    public sealed virtual void SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor);
    private void SetSecurityDescriptor(string path, ObjectSecurity sd, AccessControlSections sections);
    public sealed virtual ObjectSecurity NewSecurityDescriptorFromPath(string path, AccessControlSections sections);
    public sealed virtual ObjectSecurity NewSecurityDescriptorOfType(string type, AccessControlSections sections);
    private static ObjectSecurity NewSecurityDescriptor(ItemType itemType);
    private static ErrorRecord CreateErrorRecord(string path, string errorId);
    [CompilerGeneratedAttribute]
internal static string <Mode>g__ToModeString|40_0(FileSystemInfo fileSystemInfo, <>c__DisplayClass40_0& );
    [CompilerGeneratedAttribute]
private void <RemoveDirectoryInfoItem>g__WriteErrorHelper|54_0(Exception exception, <>c__DisplayClass54_0& );
}
public class Microsoft.PowerShell.Commands.FileSystemProviderGetItemDynamicParameters : object {
    [CompilerGeneratedAttribute]
private String[] <Stream>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Stream { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(String[] value);
}
public class Microsoft.PowerShell.Commands.FileSystemProviderRemoveItemDynamicParameters : object {
    [CompilerGeneratedAttribute]
private String[] <Stream>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Stream { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(String[] value);
}
[CmdletAttribute("ForEach", "Object")]
public class Microsoft.PowerShell.Commands.ForEachObjectCommand : PSCmdlet {
    private static string ParallelParameterSet;
    private static string ScriptBlockSet;
    private static string PropertyAndMethodSet;
    private PSObject _inputObject;
    private List`1<ScriptBlock> _scripts;
    private ScriptBlock _endScript;
    private bool _setEndScript;
    private int _start;
    private int _end;
    private string _propertyOrMethodName;
    private string _targetString;
    private DynamicPropertyGetter _propGetter;
    private Object[] _arguments;
    [CompilerGeneratedAttribute]
private ScriptBlock <Parallel>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TimeoutSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <AsJob>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseNewRunspace>k__BackingField;
    private PSTaskPool _taskPool;
    private PSTaskDataStreamWriter _taskDataStreamWriter;
    private Dictionary`2<string, object> _usingValuesMap;
    private Timer _taskTimer;
    private PSTaskJob _taskJob;
    private PSDataCollection`1<PSTask> _taskCollection;
    private Exception _taskCollectionException;
    private string _currentLocationPath;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public PSObject InputObject { get; public set; }
    [ParameterAttribute]
public ScriptBlock Begin { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
public ScriptBlock[] Process { get; public set; }
    [ParameterAttribute]
public ScriptBlock End { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
public ScriptBlock[] RemainingScripts { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
[ValidateNotNullOrEmptyAttribute]
public string MemberName { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    [ParameterAttribute]
public ScriptBlock Parallel { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int ThrottleLimit { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int TimeoutSeconds { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsJob { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseNewRunspace { get; public set; }
    public PSObject get_InputObject();
    public void set_InputObject(PSObject value);
    public ScriptBlock get_Begin();
    public void set_Begin(ScriptBlock value);
    public ScriptBlock[] get_Process();
    public void set_Process(ScriptBlock[] value);
    public ScriptBlock get_End();
    public void set_End(ScriptBlock value);
    public ScriptBlock[] get_RemainingScripts();
    public void set_RemainingScripts(ScriptBlock[] value);
    public string get_MemberName();
    public void set_MemberName(string value);
    public Object[] get_ArgumentList();
    public void set_ArgumentList(Object[] value);
    [CompilerGeneratedAttribute]
public ScriptBlock get_Parallel();
    [CompilerGeneratedAttribute]
public void set_Parallel(ScriptBlock value);
    [CompilerGeneratedAttribute]
public int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public void set_ThrottleLimit(int value);
    [CompilerGeneratedAttribute]
public int get_TimeoutSeconds();
    [CompilerGeneratedAttribute]
public void set_TimeoutSeconds(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_AsJob();
    [CompilerGeneratedAttribute]
public void set_AsJob(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseNewRunspace();
    [CompilerGeneratedAttribute]
public void set_UseNewRunspace(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    public sealed virtual void Dispose();
    private void InitParallelParameterSet();
    private void ProcessParallelParameterSet();
    private void EndParallelParameterSet();
    private void StopParallelProcessing();
    private void EndBlockParameterSet();
    private void ProcessPropertyAndMethodParameterSet();
    private void ProcessScriptBlockParameterSet();
    private void InitScriptBlockParameterSet();
    private void MethodCallWithArguments();
    private static string GetStringRepresentation(object obj);
    private bool GetValueFromIDictionaryInput();
    private void WriteToPipelineWithUnrolling(object obj);
    private void WriteOutIEnumerator(IEnumerator list);
    private bool BlockMethodInLanguageMode(object inputObject);
    internal static ErrorRecord GenerateNameParameterError(string paraName, string resourceString, string errorId, object target, Object[] args);
    [CompilerGeneratedAttribute]
private void <InitParallelParameterSet>b__67_0(object sender, EventArgs args);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <InitParallelParameterSet>b__67_1(object _);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <InitParallelParameterSet>b__67_2(object _);
}
[CmdletAttribute("Format", "Default")]
public class Microsoft.PowerShell.Commands.FormatDefaultCommand : FrontEndCommandBase {
}
internal class Microsoft.PowerShell.Commands.FormatXmlWriter : object {
    private XmlWriter _writer;
    private bool _exportScriptBlock;
    internal static void WriteToPs1Xml(PSCmdlet cmdlet, List`1<ExtendedTypeDefinition> typeDefinitions, string filepath, bool force, bool noclobber, bool writeScriptBlock, bool isLiteralPath);
    internal static void WriteToXml(XmlWriter writer, IEnumerable`1<ExtendedTypeDefinition> typeDefinitions, bool writeScriptBlock);
    internal void WriteToXml(IEnumerable`1<ExtendedTypeDefinition> typeDefinitions);
    internal void WriteTableControl(TableControl tableControl);
    internal void WriteListControl(ListControl listControl);
    private void WriteEntrySelectedBy(EntrySelectedBy entrySelectedBy);
    internal void WriteWideControl(WideControl wideControl);
    internal void WriteDisplayEntry(DisplayEntry displayEntry);
    internal void WriteCustomControl(CustomControl customControl);
    internal void WriteCustomItem(CustomItemBase item);
}
[CmdletProviderAttribute("Function", "16")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
[OutputTypeAttribute("System.Management.Automation.FunctionInfo")]
public class Microsoft.PowerShell.Commands.FunctionProvider : SessionStateProviderBase {
    public static string ProviderName;
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    protected virtual object NewItemDynamicParameters(string path, string type, object newItemValue);
    protected virtual object SetItemDynamicParameters(string path, object value);
    internal virtual object GetSessionStateItem(string name);
    internal virtual void SetSessionStateItem(string name, object value, bool writeItem);
    private static void SetOptions(CommandInfo function, ScopedItemOptions options);
    internal virtual void RemoveSessionStateItem(string name);
    internal virtual object GetValueOfItem(object item);
    internal virtual IDictionary GetSessionStateTable();
    internal virtual bool CanRenameItem(object item);
}
public class Microsoft.PowerShell.Commands.FunctionProviderDynamicParameters : object {
    private ScopedItemOptions _options;
    private bool _optionsSet;
    [ParameterAttribute]
public ScopedItemOptions Options { get; public set; }
    internal bool OptionsSet { get; }
    public ScopedItemOptions get_Options();
    public void set_Options(ScopedItemOptions value);
    internal bool get_OptionsSet();
}
internal class Microsoft.PowerShell.Commands.GetChildDynamicParameters : object {
    [CompilerGeneratedAttribute]
private FlagsExpression`1<FileAttributes> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <FollowSymlink>k__BackingField;
    private bool _attributeDirectory;
    private bool _attributeFile;
    private bool _attributeHidden;
    private bool _attributeReadOnly;
    private bool _attributeSystem;
    [ParameterAttribute]
public FlagsExpression`1<FileAttributes> Attributes { get; public set; }
    [ParameterAttribute]
public SwitchParameter FollowSymlink { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Directory { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter File { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Hidden { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter ReadOnly { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter System { get; public set; }
    [CompilerGeneratedAttribute]
public FlagsExpression`1<FileAttributes> get_Attributes();
    [CompilerGeneratedAttribute]
public void set_Attributes(FlagsExpression`1<FileAttributes> value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_FollowSymlink();
    [CompilerGeneratedAttribute]
public void set_FollowSymlink(SwitchParameter value);
    public SwitchParameter get_Directory();
    public void set_Directory(SwitchParameter value);
    public SwitchParameter get_File();
    public void set_File(SwitchParameter value);
    public SwitchParameter get_Hidden();
    public void set_Hidden(SwitchParameter value);
    public SwitchParameter get_ReadOnly();
    public void set_ReadOnly(SwitchParameter value);
    public SwitchParameter get_System();
    public void set_System(SwitchParameter value);
}
[CmdletAttribute("Get", "Command")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.GetCommandCommand : PSCmdlet {
    private String[] _names;
    private bool _nameContainsWildcard;
    private String[] _verbs;
    private String[] _nouns;
    private String[] _modules;
    private bool _isModuleSpecified;
    private ModuleSpecification[] _moduleSpecifications;
    private bool _isFullyQualifiedModuleSpecified;
    private CommandTypes _commandType;
    private bool _isCommandTypeSpecified;
    [CompilerGeneratedAttribute]
private int <TotalCount>k__BackingField;
    private bool _usage;
    [CompilerGeneratedAttribute]
private SwitchParameter <ShowCommandInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <ArgumentList>k__BackingField;
    private bool _all;
    private bool _listImported;
    private Collection`1<WildcardPattern> _parameterNameWildcards;
    private String[] _parameterNames;
    private HashSet`1<string> _matchedParameterNames;
    private PSTypeName[] _parameterTypes;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseFuzzyMatching>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FuzzyMinimumDistance>k__BackingField;
    private FuzzyMatcher _fuzzyMatcher;
    private List`1<CommandScore> _commandScores;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseAbbreviationExpansion>k__BackingField;
    private Dictionary`2<string, CommandInfo> _commandsWritten;
    private List`1<CommandInfo> _accumulatedResults;
    private Collection`1<WildcardPattern> _verbPatterns;
    private Collection`1<WildcardPattern> _nounPatterns;
    private Collection`1<WildcardPattern> _modulePatterns;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public String[] Verb { get; public set; }
    [ParameterAttribute]
[ArgumentCompleterAttribute("Microsoft.PowerShell.Commands.NounArgumentCompleter")]
public String[] Noun { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Module { get; public set; }
    [ParameterAttribute]
public ModuleSpecification[] FullyQualifiedModule { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public CommandTypes CommandType { get; public set; }
    [ParameterAttribute]
public int TotalCount { get; public set; }
    [ParameterAttribute]
public SwitchParameter Syntax { get; public set; }
    [ParameterAttribute]
public SwitchParameter ShowCommandInfo { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
[AllowEmptyCollectionAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    [ParameterAttribute]
public SwitchParameter All { get; public set; }
    [ParameterAttribute]
public SwitchParameter ListImported { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ParameterName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSTypeName[] ParameterType { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseFuzzyMatching { get; public set; }
    [ParameterAttribute]
public UInt32 FuzzyMinimumDistance { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseAbbreviationExpansion { get; public set; }
    public String[] get_Name();
    public void set_Name(String[] value);
    public String[] get_Verb();
    public void set_Verb(String[] value);
    public String[] get_Noun();
    public void set_Noun(String[] value);
    public String[] get_Module();
    public void set_Module(String[] value);
    public ModuleSpecification[] get_FullyQualifiedModule();
    public void set_FullyQualifiedModule(ModuleSpecification[] value);
    public CommandTypes get_CommandType();
    public void set_CommandType(CommandTypes value);
    [CompilerGeneratedAttribute]
public int get_TotalCount();
    [CompilerGeneratedAttribute]
public void set_TotalCount(int value);
    public SwitchParameter get_Syntax();
    public void set_Syntax(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_ShowCommandInfo();
    [CompilerGeneratedAttribute]
public void set_ShowCommandInfo(SwitchParameter value);
    [CompilerGeneratedAttribute]
public Object[] get_ArgumentList();
    [CompilerGeneratedAttribute]
public void set_ArgumentList(Object[] value);
    public SwitchParameter get_All();
    public void set_All(SwitchParameter value);
    public SwitchParameter get_ListImported();
    public void set_ListImported(SwitchParameter value);
    public String[] get_ParameterName();
    public void set_ParameterName(String[] value);
    public PSTypeName[] get_ParameterType();
    public void set_ParameterType(PSTypeName[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseFuzzyMatching();
    [CompilerGeneratedAttribute]
public void set_UseFuzzyMatching(SwitchParameter value);
    [CompilerGeneratedAttribute]
public UInt32 get_FuzzyMinimumDistance();
    [CompilerGeneratedAttribute]
public void set_FuzzyMinimumDistance(UInt32 value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseAbbreviationExpansion();
    [CompilerGeneratedAttribute]
public void set_UseAbbreviationExpansion(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private void OutputResultsHelper(IEnumerable`1<CommandInfo> results);
    private PSObject GetSyntaxObject(CommandInfo command);
    private void AccumulateMatchingCmdlets();
    private bool IsNounVerbMatch(CommandInfo command);
    private void AccumulateMatchingCommands();
    private void AccumulateMatchingCommands(IEnumerable`1<string> commandNames);
    private bool FindCommandForName(SearchResolutionOptions options, string commandName, bool isPattern, bool emitErrors, Int32& currentCount, Boolean& isDuplicate);
    private bool IsDuplicate(CommandInfo info);
    private bool IsParameterMatch(CommandInfo commandInfo);
    private bool IsParameterMatch(ParameterMetadata parameterMetadata);
    private bool IsCommandMatch(CommandInfo& current, Boolean& isDuplicate);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetCommandCommand/<GetMatchingCommandsFromModules>d__91")]
private IEnumerable`1<CommandInfo> GetMatchingCommandsFromModules(string commandName);
    private bool IsCommandInResult(CommandInfo command);
    private static PSObject ConvertToShowCommandInfo(CommandInfo cmdInfo);
    private static PSObject GetModuleInfo(CommandInfo cmdInfo);
    private static PSObject[] GetParameterSets(CommandInfo cmdInfo);
    private static PSObject[] GetParameterInfo(ReadOnlyCollection`1<CommandParameterInfo> parameters);
    private static PSObject GetParameterType(Type parameterType);
}
[CmdletAttribute("Get", "ExperimentalFeature")]
[OutputTypeAttribute("System.Management.Automation.ExperimentalFeature")]
public class Microsoft.PowerShell.Commands.GetExperimentalFeatureCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [ParameterAttribute]
[ArgumentCompleterAttribute("Microsoft.PowerShell.Commands.ExperimentalFeatureNameCompleter")]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    protected virtual void ProcessRecord();
    private static ValueTuple`2<int, string> GetSortingString(ExperimentalFeature feature);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetExperimentalFeatureCommand/<GetAvailableExperimentalFeatures>d__6")]
internal IEnumerable`1<ExperimentalFeature> GetAvailableExperimentalFeatures(IEnumerable`1<WildcardPattern> namePatterns);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetExperimentalFeatureCommand/<GetValidModuleFiles>d__7")]
private IEnumerable`1<string> GetValidModuleFiles(HashSet`1<string> moduleNamesToFind);
}
public static class Microsoft.PowerShell.Commands.GetHelpCodeMethods : object {
    private static bool DoesCurrentRunspaceIncludeCoreHelpCmdlet();
    public static string GetHelpUri(PSObject commandInfoPSObject);
}
[CmdletAttribute("Get", "Help")]
public class Microsoft.PowerShell.Commands.GetHelpCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Category>k__BackingField;
    private string _provider;
    [CompilerGeneratedAttribute]
private String[] <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Functionality>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Role>k__BackingField;
    private bool _showOnlineHelp;
    private GraphicalHostReflectionWrapper graphicalHostReflectionWrapper;
    private bool showWindow;
    private HelpView _viewTokenToAdd;
    [TraceSourceAttribute("GetHelpCommand ", "GetHelpCommand ")]
private static PSTraceSource s_tracer;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] Category { get; public set; }
    [ParameterAttribute]
unknown SwitchParameter Detailed {public set; }
    [ParameterAttribute]
unknown SwitchParameter Full {public set; }
    [ParameterAttribute]
unknown SwitchParameter Examples {public set; }
    [ParameterAttribute]
public String[] Parameter { get; public set; }
    [ParameterAttribute]
public String[] Component { get; public set; }
    [ParameterAttribute]
public String[] Functionality { get; public set; }
    [ParameterAttribute]
public String[] Role { get; public set; }
    [ParameterAttribute]
public SwitchParameter Online { get; public set; }
    [ParameterAttribute]
public SwitchParameter ShowWindow { get; public set; }
    private static GetHelpCommand();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public String[] get_Category();
    [CompilerGeneratedAttribute]
public void set_Category(String[] value);
    public void set_Detailed(SwitchParameter value);
    public void set_Full(SwitchParameter value);
    public void set_Examples(SwitchParameter value);
    [CompilerGeneratedAttribute]
public String[] get_Parameter();
    [CompilerGeneratedAttribute]
public void set_Parameter(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Component();
    [CompilerGeneratedAttribute]
public void set_Component(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Functionality();
    [CompilerGeneratedAttribute]
public void set_Functionality(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Role();
    [CompilerGeneratedAttribute]
public void set_Role(String[] value);
    public SwitchParameter get_Online();
    public void set_Online(SwitchParameter value);
    public SwitchParameter get_ShowWindow();
    public void set_ShowWindow(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private HelpCategory ToHelpCategory(String[] category, Boolean& failed);
    private PSObject TransformView(PSObject originalHelpObject);
    private PSObject[] GetParameterInfo(HelpInfo helpInfo);
    private void GetAndWriteParameterInfo(HelpInfo helpInfo);
    private void ValidateAndThrowIfError(HelpCategory cat);
    private void WriteObjectsOrShowOnlineHelp(HelpInfo helpInfo, bool showFullHelp);
    private void LaunchOnlineHelp(Uri uriToLaunch);
    private void HelpSystem_OnProgress(object sender, HelpProgressEventArgs arg);
    private void HelpSystem_OnComplete();
    internal static void VerifyParameterForbiddenInRemoteRunspace(Cmdlet cmdlet, string parameterName);
}
[CmdletAttribute("Get", "History")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.HistoryInfo")]
public class Microsoft.PowerShell.Commands.GetHistoryCommand : PSCmdlet {
    private Int64[] _id;
    private bool _countParameterSpecified;
    private int _count;
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Int64[] Id { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Count { get; public set; }
    public Int64[] get_Id();
    public void set_Id(Int64[] value);
    public int get_Count();
    public void set_Count(int value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("Get", "Job")]
[OutputTypeAttribute("System.Management.Automation.Job")]
public class Microsoft.PowerShell.Commands.GetJobCommand : JobCmdletBase {
    [CompilerGeneratedAttribute]
private SwitchParameter <IncludeChildJob>k__BackingField;
    [CompilerGeneratedAttribute]
private JobState <ChildJobState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasMoreData>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Before>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <After>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Newest>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter IncludeChildJob { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public JobState ChildJobState { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public bool HasMoreData { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public DateTime Before { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public DateTime After { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int Newest { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Int32[] Id { get; public set; }
    [CompilerGeneratedAttribute]
public SwitchParameter get_IncludeChildJob();
    [CompilerGeneratedAttribute]
public void set_IncludeChildJob(SwitchParameter value);
    [CompilerGeneratedAttribute]
public JobState get_ChildJobState();
    [CompilerGeneratedAttribute]
public void set_ChildJobState(JobState value);
    [CompilerGeneratedAttribute]
public bool get_HasMoreData();
    [CompilerGeneratedAttribute]
public void set_HasMoreData(bool value);
    [CompilerGeneratedAttribute]
public DateTime get_Before();
    [CompilerGeneratedAttribute]
public void set_Before(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_After();
    [CompilerGeneratedAttribute]
public void set_After(DateTime value);
    [CompilerGeneratedAttribute]
public int get_Newest();
    [CompilerGeneratedAttribute]
public void set_Newest(int value);
    public virtual Int32[] get_Id();
    public virtual void set_Id(Int32[] value);
    protected virtual void ProcessRecord();
    protected List`1<Job> FindJobs();
    private List`1<Job> ApplyHasMoreDataFiltering(List`1<Job> jobList);
    private List`1<Job> FindChildJobs(List`1<Job> jobList);
    private List`1<Job> ApplyTimeFiltering(List`1<Job> jobList);
}
[CmdletAttribute("Get", "Module")]
[OutputTypeAttribute("System.Management.Automation.PSModuleInfo")]
public class Microsoft.PowerShell.Commands.GetModuleCommand : ModuleCmdletBase {
    private static string ParameterSet_Loaded;
    private static string ParameterSet_AvailableLocally;
    private static string ParameterSet_AvailableInPsrpSession;
    private static string ParameterSet_AvailableInCimSession;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSpecification[] <FullyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <All>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <ListAvailable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PSEdition>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Refresh>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSession <PSSession>k__BackingField;
    [CompilerGeneratedAttribute]
private CimSession <CimSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CimResourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CimNamespace>k__BackingField;
    private CancellationTokenSource _cancellationTokenSource;
    private bool _disposed;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public ModuleSpecification[] FullyQualifiedName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter All { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter ListAvailable { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ArgumentCompleterAttribute("Microsoft.PowerShell.Commands.PSEditionArgumentCompleter")]
public string PSEdition { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter SkipEditionCheck { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter Refresh { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public PSSession PSSession { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public CimSession CimSession { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Uri CimResourceUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string CimNamespace { get; public set; }
    private CancellationToken CancellationToken { get; }
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public ModuleSpecification[] get_FullyQualifiedName();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedName(ModuleSpecification[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_All();
    [CompilerGeneratedAttribute]
public void set_All(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_ListAvailable();
    [CompilerGeneratedAttribute]
public void set_ListAvailable(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_PSEdition();
    [CompilerGeneratedAttribute]
public void set_PSEdition(string value);
    public SwitchParameter get_SkipEditionCheck();
    public void set_SkipEditionCheck(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Refresh();
    [CompilerGeneratedAttribute]
public void set_Refresh(SwitchParameter value);
    [CompilerGeneratedAttribute]
public PSSession get_PSSession();
    [CompilerGeneratedAttribute]
public void set_PSSession(PSSession value);
    [CompilerGeneratedAttribute]
public CimSession get_CimSession();
    [CompilerGeneratedAttribute]
public void set_CimSession(CimSession value);
    [CompilerGeneratedAttribute]
public Uri get_CimResourceUri();
    [CompilerGeneratedAttribute]
public void set_CimResourceUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_CimNamespace();
    [CompilerGeneratedAttribute]
public void set_CimNamespace(string value);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetModuleCommand/<GetAvailableViaPsrpSessionCore>d__47")]
private IEnumerable`1<PSModuleInfo> GetAvailableViaPsrpSessionCore(String[] moduleNames, Runspace remoteRunspace);
    private static PSModuleInfo GetModuleInfoForRemoteModuleWithoutManifest(CimModule cimModule);
    private PSModuleInfo ConvertCimModuleInfoToPSModuleInfo(CimModule cimModule, string computerName);
    private IEnumerable`1<PSModuleInfo> GetAvailableViaCimSessionCore(IEnumerable`1<string> moduleNames, CimSession cimSession, Uri resourceUri, string cimNamespace);
    private CancellationToken get_CancellationToken();
    protected virtual void StopProcessing();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    private void AssertListAvailableMode();
    protected virtual void ProcessRecord();
    private void AssertNameDoesNotResolveToAPath(String[] names, string stringFormat, string resourceId);
    private void GetAvailableViaCimSession(IEnumerable`1<string> names, IDictionary`2<string, ModuleSpecification> moduleSpecTable, CimSession cimSession, Uri resourceUri, string cimNamespace);
    private void GetAvailableViaPsrpSession(String[] names, IDictionary`2<string, ModuleSpecification> moduleSpecTable, PSSession session);
    private void GetAvailableLocallyModules(String[] names, IDictionary`2<string, ModuleSpecification> moduleSpecTable, bool all);
    private void GetLoadedModules(String[] names, IDictionary`2<string, ModuleSpecification> moduleSpecTable, bool all);
    private IEnumerable`1<PSModuleInfo> FilterModulesForEditionAndSpecification(IEnumerable`1<PSModuleInfo> modules, IDictionary`2<string, ModuleSpecification> moduleSpecificationTable);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetModuleCommand/<FilterModulesForSpecificationMatch>d__66")]
private static IEnumerable`1<PSModuleInfo> FilterModulesForSpecificationMatch(IEnumerable`1<PSModuleInfo> modules, IDictionary`2<string, ModuleSpecification> moduleSpecificationTable);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.GetModuleCommand/<GetCandidateModuleSpecs>d__67")]
private static IEnumerable`1<ModuleSpecification> GetCandidateModuleSpecs(IDictionary`2<string, ModuleSpecification> moduleSpecTable, PSModuleInfo module);
    [CompilerGeneratedAttribute]
private bool <FilterModulesForEditionAndSpecification>b__65_1(PSModuleInfo module);
}
[CmdletAttribute("Get", "PSHostProcessInfo")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.PSHostProcessInfo")]
public class Microsoft.PowerShell.Commands.GetPSHostProcessInfoCommand : PSCmdlet {
    private static string ProcessParameterSet;
    private static string ProcessIdParameterSet;
    private static string ProcessNameParameterSet;
    private static string NamedPipePath;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Process[] <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <Id>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Process[] Process { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Int32[] Id { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public Process[] get_Process();
    [CompilerGeneratedAttribute]
public void set_Process(Process[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Int32[] value);
    protected virtual void EndProcessing();
    private static Int32[] GetProcIdsFromProcs(Process[] processes);
    private static Int32[] GetProcIdsFromNames(String[] names);
    internal static IReadOnlyCollection`1<PSHostProcessInfo> GetAppDomainNamesFromProcessId(Int32[] procIds);
}
[CmdletAttribute("Get", "PSSessionCapability")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Microsoft.PowerShell.Commands.GetPSSessionCapabilityCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Full>k__BackingField;
    [ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
public string Username { get; public set; }
    [ParameterAttribute]
public SwitchParameter Full { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Full();
    [CompilerGeneratedAttribute]
public void set_Full(SwitchParameter value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Get", "PSSession")]
[OutputTypeAttribute("System.Management.Automation.Runspaces.PSSession")]
public class Microsoft.PowerShell.Commands.GetPSSessionCommand : PSRunspaceCmdlet {
    private static string ConnectionUriParameterSet;
    private static string ConnectionUriInstanceIdParameterSet;
    [CompilerGeneratedAttribute]
private String[] <ComputerName>k__BackingField;
    private string _appName;
    [CompilerGeneratedAttribute]
private Uri[] <ConnectionUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    private bool _allowRedirection;
    private PSCredential _psCredential;
    private AuthenticationMechanism _authentication;
    private string _thumbprint;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseSSL>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionFilterState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSessionOption <SessionOption>k__BackingField;
    private QueryRunspaces _queryRunspaces;
    private ObjectStream _stream;
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string ApplicationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri[] ConnectionUri { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter AllowRedirection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public Guid[] InstanceId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string CertificateThumbprint { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Port { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter UseSSL { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int ThrottleLimit { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SessionFilterState State { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public PSSessionOption SessionOption { get; public set; }
    [CompilerGeneratedAttribute]
public virtual String[] get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(String[] value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public Uri[] get_ConnectionUri();
    [CompilerGeneratedAttribute]
public void set_ConnectionUri(Uri[] value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    public SwitchParameter get_AllowRedirection();
    public void set_AllowRedirection(SwitchParameter value);
    public virtual String[] get_Name();
    public virtual void set_Name(String[] value);
    public virtual Guid[] get_InstanceId();
    public virtual void set_InstanceId(Guid[] value);
    public PSCredential get_Credential();
    public void set_Credential(PSCredential value);
    public AuthenticationMechanism get_Authentication();
    public void set_Authentication(AuthenticationMechanism value);
    public string get_CertificateThumbprint();
    public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseSSL();
    [CompilerGeneratedAttribute]
public void set_UseSSL(SwitchParameter value);
    [CompilerGeneratedAttribute]
public int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public void set_ThrottleLimit(int value);
    [CompilerGeneratedAttribute]
public SessionFilterState get_State();
    [CompilerGeneratedAttribute]
public void set_State(SessionFilterState value);
    [CompilerGeneratedAttribute]
public PSSessionOption get_SessionOption();
    [CompilerGeneratedAttribute]
public void set_SessionOption(PSSessionOption value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private void QueryForRemoteSessions();
    private Collection`1<WSManConnectionInfo> GetConnectionObjects();
    private void UpdateConnectionInfo(WSManConnectionInfo connectionInfo);
    public sealed virtual void Dispose();
}
[CmdletAttribute("Get", "PSSessionConfiguration")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.PSSessionConfigurationCommands#PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.GetPSSessionConfigurationCommand : PSCmdlet {
    private static string getPluginSbFormat;
    private static string MODULEPATH;
    private static ScriptBlock s_getPluginSb;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    private bool _force;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    private static GetPSSessionConfigurationCommand();
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
}
public class Microsoft.PowerShell.Commands.HelpCategoryInvalidException : ArgumentException {
    private ErrorRecord _errorRecord;
    private string _helpCategory;
    public ErrorRecord ErrorRecord { get; }
    public string HelpCategory { get; }
    public string Message { get; }
    public HelpCategoryInvalidException(string helpCategory);
    public HelpCategoryInvalidException(string helpCategory, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected HelpCategoryInvalidException(SerializationInfo info, StreamingContext context);
    private void CreateErrorRecord();
    public sealed virtual ErrorRecord get_ErrorRecord();
    public string get_HelpCategory();
    public virtual string get_Message();
}
public class Microsoft.PowerShell.Commands.HelpNotFoundException : SystemException {
    private ErrorRecord _errorRecord;
    private string _helpTopic;
    public ErrorRecord ErrorRecord { get; }
    public string HelpTopic { get; }
    public string Message { get; }
    public HelpNotFoundException(string helpTopic);
    public HelpNotFoundException(string helpTopic, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected HelpNotFoundException(SerializationInfo info, StreamingContext context);
    private void CreateErrorRecord();
    public sealed virtual ErrorRecord get_ErrorRecord();
    public string get_HelpTopic();
    public virtual string get_Message();
}
internal class Microsoft.PowerShell.Commands.History : object {
    internal static int DefaultHistorySize;
    private HistoryInfo[] _buffer;
    private int _capacity;
    private int _countEntriesInBuffer;
    private long _countEntriesAdded;
    private object _syncRoot;
    private HashSet`1<long> _invokeHistoryIds;
    internal History(ExecutionContext context);
    internal long AddEntry(long pipelineId, string cmdline, PipelineState status, DateTime startTime, DateTime endTime, bool skipIfLocked);
    internal void UpdateEntry(long id, PipelineState status, DateTime endTime, bool skipIfLocked);
    internal HistoryInfo GetEntry(long id);
    internal HistoryInfo[] GetEntries(long id, long count, SwitchParameter newest);
    internal HistoryInfo[] GetEntries(WildcardPattern wildcardpattern, long count, SwitchParameter newest);
    internal void ClearEntry(long id);
    internal int Buffercapacity();
    private long Add(HistoryInfo entry);
    private HistoryInfo CoreGetEntry(long id);
    private long SmallestIDinBuffer();
    private void ReallocateBufferIfNeeded();
    private int GetIndexForNewEntry();
    private int GetIndexFromId(long id);
    private static int GetIndexFromId(long id, int capacity);
    private void IncrementCountOfEntriesInBuffer();
    private static int GetHistorySize();
    internal long GetNextHistoryId();
    internal bool PresentInInvokeHistoryEntrySet(HistoryInfo entry);
    internal void AddToInvokeHistoryEntrySet(HistoryInfo entry);
    internal void RemoveFromInvokeHistoryEntrySet(HistoryInfo entry);
}
public class Microsoft.PowerShell.Commands.HistoryInfo : object {
    [CompilerGeneratedAttribute]
private long <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineState <ExecutionStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <StartExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <EndExecutionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Cleared>k__BackingField;
    private long _pipelineId;
    public long Id { get; private set; }
    public string CommandLine { get; private set; }
    public PipelineState ExecutionStatus { get; private set; }
    public DateTime StartExecutionTime { get; }
    public DateTime EndExecutionTime { get; private set; }
    public TimeSpan Duration { get; }
    internal bool Cleared { get; internal set; }
    internal HistoryInfo(long pipelineId, string cmdline, PipelineState status, DateTime startTime, DateTime endTime);
    private HistoryInfo(HistoryInfo history);
    [CompilerGeneratedAttribute]
public long get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(long value);
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
private void set_CommandLine(string value);
    [CompilerGeneratedAttribute]
public PipelineState get_ExecutionStatus();
    [CompilerGeneratedAttribute]
private void set_ExecutionStatus(PipelineState value);
    [CompilerGeneratedAttribute]
public DateTime get_StartExecutionTime();
    [CompilerGeneratedAttribute]
public DateTime get_EndExecutionTime();
    [CompilerGeneratedAttribute]
private void set_EndExecutionTime(DateTime value);
    public TimeSpan get_Duration();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal bool get_Cleared();
    [CompilerGeneratedAttribute]
internal void set_Cleared(bool value);
    internal void SetId(long id);
    internal void SetStatus(PipelineState status);
    internal void SetEndTime(DateTime endTime);
    internal void SetCommand(string command);
    public HistoryInfo Clone();
}
[CmdletAttribute("Import", "Module")]
[OutputTypeAttribute("System.Management.Automation.PSModuleInfo")]
public class Microsoft.PowerShell.Commands.ImportModuleCommand : ModuleCmdletBase {
    private static string ParameterSet_Name;
    private static string ParameterSet_FQName;
    private static string ParameterSet_ModuleInfo;
    private static string ParameterSet_Assembly;
    private static string ParameterSet_ViaPsrpSession;
    private static string ParameterSet_ViaCimSession;
    private static string ParameterSet_FQName_ViaPsrpSession;
    private static string ParameterSet_ViaWinCompat;
    private static string ParameterSet_FQName_ViaWinCompat;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSpecification[] <FullyQualifiedName>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly[] <Assembly>k__BackingField;
    private String[] _functionImportList;
    private String[] _cmdletImportList;
    private String[] _variableExportList;
    private String[] _aliasExportList;
    [CompilerGeneratedAttribute]
private PSModuleInfo[] <ModuleInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoClobber>k__BackingField;
    private string _scope;
    private bool _isScopeSpecified;
    [CompilerGeneratedAttribute]
private PSSession <PSSession>k__BackingField;
    [CompilerGeneratedAttribute]
private CimSession <CimSession>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CimResourceUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CimNamespace>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseWindowsPowerShell>k__BackingField;
    private CancellationTokenSource _cancellationTokenSource;
    private bool _disposed;
    [ParameterAttribute]
public SwitchParameter Global { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public string Prefix { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateTrustedDataAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateTrustedDataAttribute]
public ModuleSpecification[] FullyQualifiedName { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
public Assembly[] Assembly { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Function { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Cmdlet { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Variable { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Alias { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter SkipEditionCheck { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsCustomObject { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Version MinimumVersion { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string MaximumVersion { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public Version RequiredVersion { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
public PSModuleInfo[] ModuleInfo { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    [ParameterAttribute]
public SwitchParameter DisableNameChecking { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NoClobber { get; public set; }
    [ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Scope { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public PSSession PSSession { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public CimSession CimSession { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Uri CimResourceUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string CimNamespace { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter UseWindowsPowerShell { get; public set; }
    private CancellationToken CancellationToken { get; }
    public SwitchParameter get_Global();
    public void set_Global(SwitchParameter value);
    public string get_Prefix();
    public void set_Prefix(string value);
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public ModuleSpecification[] get_FullyQualifiedName();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedName(ModuleSpecification[] value);
    [CompilerGeneratedAttribute]
public Assembly[] get_Assembly();
    [CompilerGeneratedAttribute]
public void set_Assembly(Assembly[] value);
    public String[] get_Function();
    public void set_Function(String[] value);
    public String[] get_Cmdlet();
    public void set_Cmdlet(String[] value);
    public String[] get_Variable();
    public void set_Variable(String[] value);
    public String[] get_Alias();
    public void set_Alias(String[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public SwitchParameter get_SkipEditionCheck();
    public void set_SkipEditionCheck(SwitchParameter value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public SwitchParameter get_AsCustomObject();
    public void set_AsCustomObject(SwitchParameter value);
    public Version get_MinimumVersion();
    public void set_MinimumVersion(Version value);
    public string get_MaximumVersion();
    public void set_MaximumVersion(string value);
    public Version get_RequiredVersion();
    public void set_RequiredVersion(Version value);
    [CompilerGeneratedAttribute]
public PSModuleInfo[] get_ModuleInfo();
    [CompilerGeneratedAttribute]
public void set_ModuleInfo(PSModuleInfo[] value);
    public Object[] get_ArgumentList();
    public void set_ArgumentList(Object[] value);
    public SwitchParameter get_DisableNameChecking();
    public void set_DisableNameChecking(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoClobber();
    [CompilerGeneratedAttribute]
public void set_NoClobber(SwitchParameter value);
    public string get_Scope();
    public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public PSSession get_PSSession();
    [CompilerGeneratedAttribute]
public void set_PSSession(PSSession value);
    [CompilerGeneratedAttribute]
public CimSession get_CimSession();
    [CompilerGeneratedAttribute]
public void set_CimSession(CimSession value);
    [CompilerGeneratedAttribute]
public Uri get_CimResourceUri();
    [CompilerGeneratedAttribute]
public void set_CimResourceUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_CimNamespace();
    [CompilerGeneratedAttribute]
public void set_CimNamespace(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseWindowsPowerShell();
    [CompilerGeneratedAttribute]
public void set_UseWindowsPowerShell(SwitchParameter value);
    private void ImportModule_ViaLocalModuleInfo(ImportModuleOptions importModuleOptions, PSModuleInfo module);
    private void ImportModule_ViaAssembly(ImportModuleOptions importModuleOptions, Assembly suppliedAssembly);
    private PSModuleInfo ImportModule_LocallyViaName_WithTelemetry(ImportModuleOptions importModuleOptions, string name);
    private PSModuleInfo ImportModule_LocallyViaName(ImportModuleOptions importModuleOptions, string name);
    private PSModuleInfo ImportModule_LocallyViaFQName(ImportModuleOptions importModuleOptions, ModuleSpecification modulespec);
    private IList`1<PSModuleInfo> ImportModule_RemotelyViaPsrpSession(ImportModuleOptions importModuleOptions, IEnumerable`1<string> moduleNames, IEnumerable`1<ModuleSpecification> fullyQualifiedNames, PSSession psSession, bool usingWinCompat);
    private IList`1<PSModuleInfo> ImportModule_RemotelyViaPsrpSession(ImportModuleOptions importModuleOptions, string moduleName, ModuleSpecification fullyQualifiedName, PSSession psSession);
    private PSModuleInfo ImportModule_RemotelyViaPsrpSession_SinglePreimportedModule(ImportModuleOptions importModuleOptions, string remoteModuleName, Version remoteModuleVersion, PSSession psSession);
    private static bool IsNonEmptyManifestField(Hashtable manifestData, string key);
    private bool IsMixedModePsCimModule(CimModule cimModule);
    private void ImportModule_RemotelyViaCimSession(ImportModuleOptions importModuleOptions, String[] moduleNames, CimSession cimSession, Uri resourceUri, string cimNamespace);
    private bool IsPs1xmlFileHelper_IsPresentInEntries(CimModuleFile cimModuleFile, IEnumerable`1<string> manifestEntries);
    private bool IsPs1xmlFileHelper(CimModuleFile cimModuleFile, Hashtable manifestData, string goodKey, string badKey);
    private bool IsTypesPs1XmlFile(CimModuleFile cimModuleFile, Hashtable manifestData);
    private bool IsFormatPs1XmlFile(CimModuleFile cimModuleFile, Hashtable manifestData);
    private static bool IsCmdletizationFile(CimModuleFile cimModuleFile);
    private static IEnumerable`1<string> CreateCimModuleFiles(CimModule remoteCimModule, CimFileCode fileCode, Func`2<CimModuleFile, bool> filesFilter, string temporaryModuleDirectory);
    private PSModuleInfo ImportModule_RemotelyViaCimModuleData(ImportModuleOptions importModuleOptions, CimModule remoteCimModule, CimSession cimSession);
    private CancellationToken get_CancellationToken();
    protected virtual void StopProcessing();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private bool IsModuleInDenyList(String[] moduleDenyList, string moduleName, ModuleSpecification moduleSpec);
    private IEnumerable`1<T> FilterModuleCollection(IEnumerable`1<T> moduleCollection);
    private void PrepareNoClobberWinCompatModuleImport(string moduleName, ModuleSpecification moduleSpec, ImportModuleOptions& importModuleOptions);
    internal virtual IList`1<PSModuleInfo> ImportModulesUsingWinCompat(IEnumerable`1<string> moduleNames, IEnumerable`1<ModuleSpecification> moduleFullyQualifiedNames, ImportModuleOptions importModuleOptions);
    private static void SetModuleBaseForEngineModules(string moduleName, ExecutionContext context);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.AlignmentEntryDefinition : HashtableEntryDefinition {
    private static String[] s_legalValues;
    private static string LeftAlign;
    private static string CenterAlign;
    private static string RightAlign;
    private static AlignmentEntryDefinition();
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
    private void ProcessIllegalValue(string s, TerminatingErrorContext invocationContext);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.AppliesTo : object {
    internal List`1<TypeOrGroupReference> referenceList;
    internal void AddAppliesToType(string typeName);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.AssociationManager : object {
    internal static List`1<MshResolvedExpressionParameterAssociation> SetupActiveProperties(List`1<MshParameter> rawMshParameterList, PSObject target, PSPropertyExpressionFactory expressionFactory);
    internal static List`1<MshResolvedExpressionParameterAssociation> ExpandTableParameters(List`1<MshParameter> parameters, PSObject target);
    internal static List`1<MshResolvedExpressionParameterAssociation> ExpandParameters(List`1<MshParameter> parameters, PSObject target);
    internal static List`1<MshResolvedExpressionParameterAssociation> ExpandDefaultPropertySet(PSObject target, PSPropertyExpressionFactory expressionFactory);
    private static List`1<string> GetPropertyNamesFromView(PSObject source, PSMemberViewTypes viewType);
    internal static List`1<MshResolvedExpressionParameterAssociation> ExpandAll(PSObject target);
    internal static void HandleComputerNameProperties(PSObject so, List`1<MshResolvedExpressionParameterAssociation> activeAssociationList);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.AutosizeInfo : FormatInfoData {
    internal static string CLSID;
    public int objectCount;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.BooleanEntryDefinition : HashtableEntryDefinition {
    internal BooleanEntryDefinition(string entryKey);
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ColumnWidthManager : object {
    private int _tableWidth;
    private int _minimumColumnWidth;
    private int _separatorWidth;
    internal ColumnWidthManager(int tableWidth, int minimumColumnWidth, int separatorWidth);
    internal void CalculateColumnWidths(Span`1<int> columnWidths);
    private bool AssignColumnWidths(Span`1<int> columnWidths);
    private void TrimToFit(Span`1<int> columnWidths);
    private int CurrentTableWidth(Span`1<int> columnWidths);
    private static int GetLastVisibleColumn(Span`1<int> columnWidths);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.CommandParameterDefinition : object {
    internal List`1<HashtableEntryDefinition> hashEntries;
    protected abstract virtual void SetEntries();
    internal virtual MshParameter CreateInstance();
    internal HashtableEntryDefinition MatchEntry(string keyName, TerminatingErrorContext invocationContext);
    internal static bool FindPartialMatch(string key, string normalizedKey);
    private static void ProcessAmbiguousKey(TerminatingErrorContext invocationContext, string keyName, HashtableEntryDefinition matchingEntry, HashtableEntryDefinition currentEntry);
    private static void ProcessIllegalKey(TerminatingErrorContext invocationContext, string keyName);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.CommandWrapper : object {
    private PipelineProcessor _pp;
    private string _commandName;
    private Type _commandType;
    private List`1<CommandParameterInternal> _commandParameterList;
    private ExecutionContext _context;
    internal void Initialize(ExecutionContext execContext, string nameOfCommand, Type typeOfCommand);
    internal void AddNamedParameter(string parameterName, object parameterValue);
    internal Array Process(object o);
    internal Array ShutDown();
    private void DelayedInternalInitialize();
    public sealed virtual void Dispose();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexControlBody : ControlBody {
    internal ComplexControlEntryDefinition defaultEntry;
    internal List`1<ComplexControlEntryDefinition> optionalEntryList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexControlEntryDefinition : object {
    internal AppliesTo appliesTo;
    internal ComplexControlItemDefinition itemDefinition;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexControlGenerator : object {
    private TypeInfoDataBase _db;
    private DatabaseLoadingInfo _loadingInfo;
    private PSPropertyExpressionFactory _expressionFactory;
    private List`1<ControlDefinition> _controlDefinitionList;
    private FormatErrorManager _errorManager;
    private TerminatingErrorContext _errorContext;
    private int _enumerationLimit;
    internal ComplexControlGenerator(TypeInfoDataBase dataBase, DatabaseLoadingInfo loadingInfo, PSPropertyExpressionFactory expressionFactory, List`1<ControlDefinition> controlDefinitionList, FormatErrorManager resultErrorManager, int enumerationLimit, TerminatingErrorContext errorContext);
    internal void GenerateFormatEntries(int maxTreeDepth, ControlBase control, PSObject so, List`1<FormatValue> formatValueList);
    private bool ExecuteFormatControl(TraversalInfo level, ControlBase control, PSObject so, List`1<FormatValue> formatValueList);
    private void ExecuteFormatControlBody(TraversalInfo level, PSObject so, ComplexControlBody complexBody, List`1<FormatValue> formatValueList);
    private ComplexControlEntryDefinition GetActiveComplexControlEntryDefinition(ComplexControlBody complexBody, PSObject so);
    private void ExecuteFormatTokenList(TraversalInfo level, PSObject so, List`1<FormatToken> formatTokenList, List`1<FormatValue> formatValueList);
    private bool EvaluateDisplayCondition(PSObject so, ExpressionToken conditionToken);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexControlItemDefinition : object {
    internal List`1<FormatToken> formatTokenList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexSpecificParameters : ShapeSpecificParameters {
    internal ClassInfoDisplay classDisplay;
    internal static int maxDepthAllowable;
    internal int maxDepth;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexViewEntry : FreeFormatEntry {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexViewGenerator : ViewGenerator {
    internal virtual void Initialize(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, PSObject so, TypeInfoDataBase db, FormattingCommandLineParameters parameters);
    internal virtual FormatStartData GenerateStartData(PSObject so);
    internal virtual FormatEntryData GeneratePayload(PSObject so, int enumerationLimit);
    private ComplexViewEntry GenerateComplexViewEntryFromProperties(PSObject so, int enumerationLimit);
    private ComplexViewEntry GenerateComplexViewEntryFromDataBaseInfo(PSObject so, int enumerationLimit);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexViewHeaderInfo : ShapeInfo {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexViewObjectBrowser : object {
    private ComplexSpecificParameters _complexSpecificParameters;
    private int _indentationStep;
    private FormatErrorManager _errorManager;
    private PSPropertyExpressionFactory _expressionFactory;
    private int _enumerationLimit;
    internal ComplexViewObjectBrowser(FormatErrorManager resultErrorManager, PSPropertyExpressionFactory mshExpressionFactory, int enumerationLimit);
    internal ComplexViewEntry GenerateView(PSObject so, FormattingCommandLineParameters inputParameters);
    private void DisplayRawObject(PSObject so, List`1<FormatValue> formatValueList);
    private void DisplayObject(PSObject so, TraversalInfo currentLevel, List`1<MshParameter> parameterList, List`1<FormatValue> formatValueList);
    private void ProcessActiveAssociationList(PSObject so, TraversalInfo currentLevel, List`1<MshResolvedExpressionParameterAssociation> activeAssociationList, List`1<FormatValue> formatValueList);
    private void DisplayEnumeration(IEnumerable e, TraversalInfo level, List`1<FormatValue> formatValueList);
    private void DisplayEnumerationInner(IEnumerable e, TraversalInfo level, List`1<FormatValue> formatValueList);
    private void DisplayLeaf(object val, List`1<FormatValue> formatValueList);
    private static bool TreatAsLeafNode(object val, TraversalInfo level);
    private static bool TreatAsScalarType(Collection`1<string> typeNames);
    private string GetObjectDisplayName(PSObject so);
    private static void AddPrologue(List`1<FormatValue> formatValueList, string openTag, string label);
    private static void AddEpilogue(List`1<FormatValue> formatValueList, string closeTag);
    private List`1<FormatValue> AddIndentationLevel(List`1<FormatValue> formatValueList);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ComplexWriter : object {
    private IndentationManager _indentationManager;
    private StringBuilder _stringBuffer;
    private LineOutput _lo;
    private int _textColumns;
    private static int maxRecursionDepth;
    internal void Initialize(LineOutput lineOutput, int numberOfTextColumns);
    internal void WriteString(string s);
    internal void WriteObject(List`1<FormatValue> formatValueList);
    private void GenerateFormatEntryDisplay(FormatEntry fe, int currentDepth);
    private void AddToBuffer(string s);
    private void WriteToScreen();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.CompoundPropertyToken : PropertyTokenBase {
    internal ControlBase control;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ConsoleLineOutput : LineOutput {
    [TraceSourceAttribute("ConsoleLineOutput", "ConsoleLineOutput")]
internal static PSTraceSource tracer;
    private static HashSet`1<string> s_psHost;
    private bool _forceNewLine;
    private int _fallbackRawConsoleColumnNumber;
    private int _fallbackRawConsoleRowNumber;
    private WriteLineHelper _writeLineHelper;
    private PromptHandler _prompt;
    private long _linesWritten;
    private bool _disableLineWrittenEvent;
    private PSHostUserInterface _console;
    private DisplayCells _displayCellsHost;
    private TerminatingErrorContext _errorContext;
    internal int ColumnNumber { get; }
    internal int RowNumber { get; }
    internal DisplayCells DisplayCells { get; }
    private bool NeedToPrompt { get; }
    internal ConsoleLineOutput(PSHost host, bool paging, TerminatingErrorContext errorContext);
    private static ConsoleLineOutput();
    internal virtual int get_ColumnNumber();
    internal virtual int get_RowNumber();
    internal virtual void WriteLine(string s);
    internal virtual DisplayCells get_DisplayCells();
    private void OnWriteLine(string s);
    private void OnWrite(string s);
    private void LineWrittenEvent();
    private bool get_NeedToPrompt();
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ControlBase : object {
    internal static string GetControlShapeName(ControlBase control);
    internal virtual ControlBase Copy();
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ControlBody : ControlBase {
    internal Nullable`1<bool> autosize;
    internal bool repeatHeader;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ControlDefinition : object {
    internal string name;
    internal ControlBody controlBody;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ControlInfoData : PacketInfoData {
    public GroupingEntry groupingEntry;
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ControlReference : ControlBase {
    internal string name;
    internal Type controlType;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.CreateScriptBlockFromString : MulticastDelegate {
    public CreateScriptBlockFromString(object object, IntPtr method);
    public virtual ScriptBlock Invoke(string scriptBlockString);
    public virtual IAsyncResult BeginInvoke(string scriptBlockString, AsyncCallback callback, object object);
    public virtual ScriptBlock EndInvoke(IAsyncResult result);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.DatabaseLoadingInfo : object {
    internal string fileDirectory;
    internal string filePath;
    internal bool isFullyTrusted;
    internal bool isProductCode;
    internal string xPath;
    internal DateTime loadTime;
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.DefaultScalarTypes : object {
    private static HashSet`1<string> s_defaultScalarTypesHash;
    private static DefaultScalarTypes();
    internal static bool IsTypeInList(Collection`1<string> typeNames);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.DefaultSettingsSection : object {
    private Nullable`1<bool> _multilineTables;
    internal FormatErrorPolicy formatErrorPolicy;
    internal ShapeSelectionDirectives shapeSelectionDirectives;
    internal List`1<EnumerableExpansionDirective> enumerableExpansionDirectiveList;
    internal bool MultilineTables { get; internal set; }
    internal bool get_MultilineTables();
    internal void set_MultilineTables(bool value);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.DisplayCells : object {
    internal int Length(string str);
    internal virtual int Length(string str, int offset);
    internal virtual int Length(char character);
    internal int TruncateTail(string str, int displayCells);
    internal int TruncateTail(string str, int offset, int displayCells);
    internal int TruncateHead(string str, int displayCells);
    protected static int CharLengthInBufferCells(char c);
    protected int GetFitLength(string str, int offset, int displayCells, bool startFromHead);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.DisplayCellsHost : DisplayCells {
    private PSHostRawUserInterface _rawUserInterface;
    internal DisplayCellsHost(PSHostRawUserInterface rawUserInterface);
    internal virtual int Length(string str, int offset);
    internal virtual int Length(char character);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.DisplayCondition : object {
    internal static bool Evaluate(PSObject obj, PSPropertyExpression ex, PSPropertyExpressionResult& expressionResult);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.DisplayDataQuery : object {
    [TraceSourceAttribute("DisplayDataQuery", "DisplayDataQuery")]
private static PSTraceSource s_classTracer;
    private static PSTraceSource s_activeTracer;
    private static PSTraceSource ActiveTracer { get; }
    private static DisplayDataQuery();
    private static PSTraceSource get_ActiveTracer();
    internal static void SetTracer(PSTraceSource t);
    internal static void ResetTracer();
    internal static EnumerableExpansion GetEnumerableExpansionFromType(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames);
    internal static FormatShape GetShapeFromType(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames);
    internal static FormatShape GetShapeFromPropertyCount(TypeInfoDataBase db, int propertyCount);
    internal static ViewDefinition GetViewByShapeAndType(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, FormatShape shape, Collection`1<string> typeNames, string viewName);
    internal static ViewDefinition GetOutOfBandView(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames);
    private static ViewDefinition GetView(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Type mainControlType, Collection`1<string> typeNames, string viewName);
    private static void TraceHelper(ViewDefinition vd, bool isMatched);
    private static ViewDefinition GetBestMatch(TypeMatch match);
    private static ViewDefinition GetDefaultView(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames);
    private static bool IsOutOfBandView(ViewDefinition vd);
    internal static AppliesTo GetAllApplicableTypes(TypeInfoDataBase db, AppliesTo appliesTo);
    internal static TypeGroupDefinition FindGroupDefinition(TypeInfoDataBase db, string groupName);
    internal static ControlBody ResolveControlReference(TypeInfoDataBase db, List`1<ControlDefinition> viewControlDefinitionList, ControlReference controlReference);
    private static ControlBody ResolveControlReferenceInList(ControlReference controlReference, List`1<ControlDefinition> controlDefinitionList);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.DisplayResourceManagerCache : object {
    private AssemblyNameResolver _assemblyNameResolver;
    private Hashtable _resourceReferenceToAssemblyCache;
    internal string GetTextTokenString(TextToken tt);
    internal void VerifyResource(StringResourceReference resourceReference, LoadingResult& result, AssemblyBindingStatus& bindingStatus);
    private string GetString(StringResourceReference resourceReference);
    private string GetStringHelper(StringResourceReference resourceReference, LoadingResult& result, AssemblyBindingStatus& bindingStatus);
    private Assembly LoadAssemblyFromResourceReference(StringResourceReference resourceReference, Boolean& foundInGac);
}
internal enum Microsoft.PowerShell.Commands.Internal.Format.EnumerableExpansion : Enum {
    public int value__;
    public static EnumerableExpansion CoreOnly;
    public static EnumerableExpansion EnumOnly;
    public static EnumerableExpansion Both;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.EnumerableExpansionDirective : object {
    internal EnumerableExpansion enumerableExpansion;
    internal AppliesTo appliesTo;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ExpressionEntryDefinition : HashtableEntryDefinition {
    private bool _noGlobbing;
    internal ExpressionEntryDefinition(bool noGlobbing);
    internal virtual Hashtable CreateHashtableFromSingleType(object val);
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
    private void ProcessEmptyStringError(bool originalParameterWasHashTable, TerminatingErrorContext invocationContext);
    private void ProcessGlobbingCharactersError(bool originalParameterWasHashTable, string expression, TerminatingErrorContext invocationContext);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ExpressionToken : object {
    internal bool isScriptBlock;
    internal string expressionValue;
    internal ExpressionToken(string expressionValue, bool isScriptBlock);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FieldControlBody : ControlBody {
    internal FieldFormattingDirective fieldFormattingDirective;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FieldFormattingDirective : object {
    internal string formatString;
    internal bool isTable;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FieldPropertyToken : PropertyTokenBase {
    internal FieldFormattingDirective fieldFormattingDirective;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatControlDefinitionHolder : object {
    internal List`1<ControlDefinition> controlDefinitionList;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatDirective : object {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatEndData : ControlInfoData {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatEntry : FormatValue {
    internal static string CLSID;
    public List`1<FormatValue> formatValueList;
    public FrameInfo frameInfo;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatEntryData : PacketInfoData {
    internal static string CLSID;
    public FormatEntryInfo formatEntryInfo;
    public bool outOfBand;
    public WriteStreamType writeStream;
    internal bool isHelpObject;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatEntryInfo : FormatInfoData {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatErrorManager : object {
    private FormatErrorPolicy _formatErrorPolicy;
    private List`1<FormattingError> _formattingErrorList;
    internal bool DisplayErrorStrings { get; }
    internal bool DisplayFormatErrorString { get; }
    internal string ErrorString { get; }
    internal string FormatErrorString { get; }
    internal FormatErrorManager(FormatErrorPolicy formatErrorPolicy);
    internal void LogPSPropertyExpressionFailedResult(PSPropertyExpressionResult result, object sourceObject);
    internal void LogStringFormatError(StringFormatError error);
    internal bool get_DisplayErrorStrings();
    internal bool get_DisplayFormatErrorString();
    internal string get_ErrorString();
    internal string get_FormatErrorString();
    internal List`1<ErrorRecord> DrainFailedResultList();
    private static ErrorRecord GenerateErrorRecord(FormattingError error);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatErrorPolicy : object {
    private Nullable`1<bool> _showErrorsAsMessages;
    private Nullable`1<bool> _showErrorsInFormattedOutput;
    internal string errorStringInFormattedOutput;
    internal string formatErrorStringInFormattedOutput;
    internal bool ShowErrorsAsMessages { get; internal set; }
    internal bool ShowErrorsInFormattedOutput { get; internal set; }
    internal bool get_ShowErrorsAsMessages();
    internal void set_ShowErrorsAsMessages(bool value);
    internal bool get_ShowErrorsInFormattedOutput();
    internal void set_ShowErrorsInFormattedOutput(bool value);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatGroupByParameterDefinition : CommandParameterDefinition {
    protected virtual void SetEntries();
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatInfoData : object {
    internal static string classidProperty;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public abstract virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.FormatInfoDataClassFactory : object {
    private static Dictionary`2<string, Func`1<FormatInfoData>> s_constructors;
    private static FormatInfoDataClassFactory();
    internal static FormatInfoData CreateInstance(PSObject so, FormatObjectDeserializer deserializer);
    private static FormatInfoData CreateInstance(string clsid, FormatObjectDeserializer deserializer);
    private static void CreateInstanceError(Exception e, string clsid, FormatObjectDeserializer deserializer);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.FormatInfoDataListDeserializer`1 : object {
    private static void ReadListHelper(IEnumerable en, List`1<T> lst, FormatObjectDeserializer deserializer);
    internal static void ReadList(PSObject so, string property, List`1<T> lst, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatListParameterDefinition : FormatParameterDefinitionBase {
    protected virtual void SetEntries();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatMessagesContextManager : object {
    internal FormatContextCreationCallback contextCreation;
    internal FormatStartCallback fs;
    internal FormatEndCallback fe;
    internal GroupStartCallback gs;
    internal GroupEndCallback ge;
    internal PayloadCallback payload;
    private Stack`1<OutputContext> _stack;
    internal OutputContext ActiveOutputContext { get; }
    internal void Process(object o);
    internal OutputContext get_ActiveOutputContext();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatNewLine : FormatValue {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatObjectDeserializer : object {
    [CompilerGeneratedAttribute]
private TerminatingErrorContext <TerminatingErrorContext>k__BackingField;
    private static string TabExpansionString;
    internal TerminatingErrorContext TerminatingErrorContext { get; }
    internal FormatObjectDeserializer(TerminatingErrorContext errorContext);
    [CompilerGeneratedAttribute]
internal TerminatingErrorContext get_TerminatingErrorContext();
    internal bool IsFormatInfoData(PSObject so);
    internal object Deserialize(PSObject so);
    private void ProcessUnknownInvalidClassId(string classId, object obj, string errorId);
    private static bool IsClass(string x, string y);
    internal static object GetProperty(PSObject so, string name);
    internal FormatInfoData DeserializeMemberObject(PSObject so, string property);
    internal FormatInfoData DeserializeMandatoryMemberObject(PSObject so, string property);
    private object DeserializeMemberVariable(PSObject so, string property, Type t, bool cannotBeNull);
    internal string DeserializeStringMemberVariableRaw(PSObject so, string property);
    internal string DeserializeStringMemberVariable(PSObject so, string property);
    internal int DeserializeIntMemberVariable(PSObject so, string property);
    internal bool DeserializeBoolMemberVariable(PSObject so, string property, bool cannotBeNull);
    internal WriteStreamType DeserializeWriteStreamTypeMemberVariable(PSObject so);
    internal FormatInfoData DeserializeObject(PSObject so);
    internal void VerifyDataNotNull(object obj, string name);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatObjectParameterDefinition : CommandParameterDefinition {
    protected virtual void SetEntries();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatParameterDefinitionBase : CommandParameterDefinition {
    protected virtual void SetEntries();
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.FormatParameterDefinitionKeys : object {
    internal static string ExpressionEntryKey;
    internal static string FormatStringEntryKey;
    internal static string AlignmentEntryKey;
    internal static string WidthEntryKey;
    internal static string LabelEntryKey;
    internal static string DepthEntryKey;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatPropertyField : FormatValue {
    internal static string CLSID;
    public string propertyValue;
    public int alignment;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal enum Microsoft.PowerShell.Commands.Internal.Format.FormatShape : Enum {
    public int value__;
    public static FormatShape Table;
    public static FormatShape List;
    public static FormatShape Wide;
    public static FormatShape Complex;
    public static FormatShape Undefined;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatShapeSelectionBase : object {
    internal FormatShape formatShape;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatShapeSelectionOnType : FormatShapeSelectionBase {
    internal AppliesTo appliesTo;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatStartData : StartData {
    internal static string CLSID;
    public PageHeaderEntry pageHeaderEntry;
    public PageFooterEntry pageFooterEntry;
    public AutosizeInfo autosizeInfo;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatStringDefinition : HashtableEntryDefinition {
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatTableParameterDefinition : FormatParameterDefinitionBase {
    protected virtual void SetEntries();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormattedObjectsCache : object {
    private Queue`1<PacketInfoData> _frontEndQueue;
    private OutputGroupQueue _groupQueue;
    internal FormattedObjectsCache(bool cacheFrontEnd);
    internal void EnableGroupCaching(ProcessCachedGroupNotification callBack, int objectCount);
    internal void EnableGroupCaching(ProcessCachedGroupNotification callBack, TimeSpan groupingDuration);
    internal List`1<PacketInfoData> Add(PacketInfoData o);
    internal List`1<PacketInfoData> Drain();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatTextField : FormatValue {
    internal static string CLSID;
    public string text;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormattingCommandLineParameters : object {
    internal List`1<MshParameter> mshParameterList;
    internal MshParameter groupByParameter;
    internal string viewName;
    internal bool forceFormattingAlsoOnOutOfBand;
    internal Nullable`1<bool> autosize;
    internal bool repeatHeader;
    internal Nullable`1<bool> showErrorsAsMessages;
    internal Nullable`1<bool> showErrorsInFormattedOutput;
    internal Nullable`1<EnumerableExpansion> expansion;
    internal ShapeSpecificParameters shapeParameters;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormattingError : object {
    internal object sourceObject;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatToken : object {
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FormatValue : FormatInfoData {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatViewManager : object {
    [TraceSourceAttribute("FormatViewBinding", "Format view binding")]
private static PSTraceSource s_formatViewBindingTracer;
    private ViewGenerator _viewGenerator;
    internal ViewGenerator ViewGenerator { get; }
    private static FormatViewManager();
    private static string PSObjectTypeName(PSObject so);
    internal void Initialize(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, PSObject so, FormatShape shape, FormattingCommandLineParameters parameters);
    private static void PrepareViewForRemoteObjects(ViewGenerator viewGenerator, PSObject so);
    private static void ProcessUnknownViewName(TerminatingErrorContext errorContext, string viewName, PSObject so, TypeInfoDataBase db, FormatShape formatShape);
    internal ViewGenerator get_ViewGenerator();
    private static ViewGenerator SelectViewGeneratorFromViewDefinition(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, ViewDefinition view, FormattingCommandLineParameters parameters);
    private static ViewGenerator SelectViewGeneratorFromProperties(FormatShape shape, PSObject so, TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, FormattingCommandLineParameters parameters);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FormatWideParameterDefinition : FormatParameterDefinitionBase {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FrameInfo : FormatInfoData {
    internal static string CLSID;
    public int leftIndentation;
    public int rightIndentation;
    public int firstLine;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FrameInfoDefinition : object {
    internal int leftIndentation;
    internal int rightIndentation;
    internal int firstLine;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.FrameToken : FormatToken {
    internal ComplexControlItemDefinition itemDefinition;
    internal FrameInfoDefinition frameInfoDefinition;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.FreeFormatEntry : FormatEntryInfo {
    public List`1<FormatValue> formatValueList;
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
public abstract class Microsoft.PowerShell.Commands.Internal.Format.FrontEndCommandBase : PSCmdlet {
    [CompilerGeneratedAttribute]
private PSObject <InputObject>k__BackingField;
    internal ImplementationCommandBase implementation;
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    [CompilerGeneratedAttribute]
public PSObject get_InputObject();
    [CompilerGeneratedAttribute]
public void set_InputObject(PSObject value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    protected virtual PSCmdlet OuterCmdletCall();
    protected virtual PSObject InputObjectCall();
    protected virtual void WriteObjectCall(object value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual void InternalDispose();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GetWordsResult : ValueType {
    internal string Word;
    internal string Delim;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GroupBy : object {
    internal StartGroup startGroup;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GroupEndData : ControlInfoData {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GroupingEntry : FreeFormatEntry {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GroupingInfoManager : object {
    private string _label;
    private string _groupingKeyDisplayName;
    private PSPropertyExpression _groupingKeyExpression;
    private object _currentGroupingKeyPropertyValue;
    internal object CurrentGroupingKeyPropertyValue { get; }
    internal string GroupingKeyDisplayName { get; }
    internal void Initialize(PSPropertyExpression groupingExpression, string displayLabel);
    internal object get_CurrentGroupingKeyPropertyValue();
    internal string get_GroupingKeyDisplayName();
    internal bool UpdateGroupingKeyValue(PSObject so);
    private static bool IsEqual(object first, object second);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.GroupStartData : StartData {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.HashtableEntryDefinition : object {
    [CompilerGeneratedAttribute]
private string <KeyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <AllowedTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SecondaryNames>k__BackingField;
    internal string KeyName { get; }
    internal Type[] AllowedTypes { get; }
    internal bool Mandatory { get; }
    internal IEnumerable`1<string> SecondaryNames { get; }
    internal HashtableEntryDefinition(string name, IEnumerable`1<string> secondaryNames, Type[] types, bool mandatory);
    internal HashtableEntryDefinition(string name, Type[] types, bool mandatory);
    internal HashtableEntryDefinition(string name, Type[] types);
    internal virtual Hashtable CreateHashtableFromSingleType(object val);
    internal bool IsKeyMatch(string key);
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
    internal virtual object ComputeDefaultValue();
    [CompilerGeneratedAttribute]
internal string get_KeyName();
    [CompilerGeneratedAttribute]
internal Type[] get_AllowedTypes();
    [CompilerGeneratedAttribute]
internal bool get_Mandatory();
    [CompilerGeneratedAttribute]
internal IEnumerable`1<string> get_SecondaryNames();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ImplementationCommandBase : object {
    [CompilerGeneratedAttribute]
private TerminatingErrorContext <TerminatingErrorContext>k__BackingField;
    internal OuterCmdletCallback OuterCmdletCall;
    internal InputObjectCallback InputObjectCall;
    internal WriteObjectCallback WriteObjectCall;
    protected TerminatingErrorContext TerminatingErrorContext { get; private set; }
    internal virtual void BeginProcessing();
    internal virtual void ProcessRecord();
    internal virtual void EndProcessing();
    internal virtual void StopProcessing();
    internal virtual PSObject ReadObject();
    internal virtual void WriteObject(object o);
    internal virtual PSCmdlet OuterCmdlet();
    [CompilerGeneratedAttribute]
protected TerminatingErrorContext get_TerminatingErrorContext();
    [CompilerGeneratedAttribute]
private void set_TerminatingErrorContext(TerminatingErrorContext value);
    internal void CreateTerminatingErrorContext();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual void InternalDispose();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.IndentationManager : object {
    private Stack`1<FrameInfo> _frameInfoStack;
    internal int RightIndentation { get; }
    internal int LeftIndentation { get; }
    internal int FirstLineIndentation { get; }
    internal void Clear();
    internal IDisposable StackFrame(FrameInfo frameInfo);
    private void RemoveStackFrame();
    internal int get_RightIndentation();
    internal int get_LeftIndentation();
    internal int get_FirstLineIndentation();
    private int ComputeRightIndentation();
    private int ComputeLeftIndentation();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.InnerFormatShapeCommand : InnerFormatShapeCommandBase {
    private FormatShape _shape;
    private PSPropertyExpressionFactory _expressionFactory;
    private FormatObjectDeserializer _formatObjectDeserializer;
    private TypeInfoDataBase _typeInfoDataBase;
    private FormattingCommandLineParameters _parameters;
    private FormatViewManager _viewManager;
    private int _enumerationLimit;
    private bool ShouldProcessOutOfBand { get; }
    internal InnerFormatShapeCommand(FormatShape shape);
    internal static int FormatEnumerationLimit();
    internal virtual void BeginProcessing();
    internal virtual void ProcessRecord();
    private EnumerableExpansion GetExpansionState(PSObject so);
    private void ProcessCoreOutOfBand(PSObject so, int count);
    private void SendCommentOutOfBand(string msg);
    private void ProcessObject(PSObject so);
    private void WriteNewLineObject();
    private bool get_ShouldProcessOutOfBand();
    private bool ProcessOutOfBandObjectOutsideDocumentSequence(PSObject so);
    private bool ProcessOutOfBandObjectInsideDocumentSequence(PSObject so);
    private bool ProcessOutOfBand(PSObject so, bool isProcessingError);
    protected void WriteInternalErrorMessage(string message);
    private void WriteErrorRecords(List`1<ErrorRecord> errorRecordList);
    internal virtual void EndProcessing();
    internal void SetCommandLineParameters(FormattingCommandLineParameters commandLineParameters);
    private GroupTransition ComputeGroupTransition(PSObject so);
    private void WriteFormatStartData(PSObject so);
    private void WritePayloadObject(PSObject so);
    private void PushGroup(PSObject firstObjectInGroup);
    private void PopGroup();
    internal ScriptBlock CreateScriptBlock(string scriptText);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.InnerFormatShapeCommandBase : ImplementationCommandBase {
    protected Stack`1<FormattingContextState> contextManager;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.LabelEntryDefinition : HashtableEntryDefinition {
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.LineOutput : object {
    [CompilerGeneratedAttribute]
private WriteStreamType <WriteStream>k__BackingField;
    private bool _isStopping;
    protected static DisplayCells _displayCellsDefault;
    internal bool RequiresBuffering { get; }
    internal int ColumnNumber { get; }
    internal int RowNumber { get; }
    internal WriteStreamType WriteStream { get; internal set; }
    internal DisplayCells DisplayCells { get; }
    private static LineOutput();
    internal virtual bool get_RequiresBuffering();
    internal virtual void ExecuteBufferPlayBack(DoPlayBackCall playback);
    internal abstract virtual int get_ColumnNumber();
    internal abstract virtual int get_RowNumber();
    internal abstract virtual void WriteLine(string s);
    internal virtual void WriteRawText(string s);
    [CompilerGeneratedAttribute]
internal WriteStreamType get_WriteStream();
    [CompilerGeneratedAttribute]
internal void set_WriteStream(WriteStreamType value);
    internal void StopProcessing();
    internal void CheckStopProcessing();
    internal virtual DisplayCells get_DisplayCells();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListControlBody : ControlBody {
    internal ListControlEntryDefinition defaultEntryDefinition;
    internal List`1<ListControlEntryDefinition> optionalEntryList;
    internal virtual ControlBase Copy();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListControlEntryDefinition : object {
    internal AppliesTo appliesTo;
    internal List`1<ListControlItemDefinition> itemDefinitionList;
    internal ListControlEntryDefinition Copy();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListControlItemDefinition : object {
    internal ExpressionToken conditionToken;
    internal TextToken label;
    internal List`1<FormatToken> formatTokenList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListViewEntry : FormatEntryInfo {
    internal static string CLSID;
    public List`1<ListViewField> listViewFieldList;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListViewField : FormatInfoData {
    internal static string CLSID;
    public string label;
    public string propertyName;
    public FormatPropertyField formatPropertyField;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListViewGenerator : ViewGenerator {
    private ListControlBody _listBody;
    internal virtual void Initialize(TerminatingErrorContext terminatingErrorContext, PSPropertyExpressionFactory mshExpressionFactory, TypeInfoDataBase db, ViewDefinition view, FormattingCommandLineParameters formatParameters);
    internal virtual void Initialize(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, PSObject so, TypeInfoDataBase db, FormattingCommandLineParameters parameters);
    internal virtual void PrepareForRemoteObjects(PSObject so);
    internal virtual FormatStartData GenerateStartData(PSObject so);
    internal virtual FormatEntryData GeneratePayload(PSObject so, int enumerationLimit);
    private ListViewEntry GenerateListViewEntryFromDataBaseInfo(PSObject so, int enumerationLimit);
    private ListControlEntryDefinition GetActiveListControlEntryDefinition(ListControlBody listBody, PSObject so);
    private ListViewEntry GenerateListViewEntryFromProperties(PSObject so, int enumerationLimit);
    private void SetUpActiveProperties(PSObject so);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListViewHeaderInfo : ShapeInfo {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ListWriter : object {
    private String[] _propertyLabels;
    private int _propertyLabelsDisplayLength;
    private int _columnWidth;
    private StringBuilder _cachedBuilder;
    private bool _disabled;
    private static string Separator;
    private static int MinLabelWidth;
    private static int MinFieldWidth;
    internal void Initialize(String[] propertyNames, int screenColumnWidth, DisplayCells dc);
    internal void WriteProperties(String[] values, LineOutput lo);
    private void WriteProperty(int k, string propertyValue, LineOutput lo);
    private void WriteSingleLineHelper(string prependString, string line, LineOutput lo);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.MshParameter : object {
    internal Hashtable hash;
    internal object GetEntry(string key);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.MshResolvedExpressionParameterAssociation : object {
    [TraceSourceAttribute("MshResolvedExpressionParameterAssociation", "MshResolvedExpressionParameterAssociation")]
internal static PSTraceSource tracer;
    [CompilerGeneratedAttribute]
private PSPropertyExpression <ResolvedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private MshParameter <OriginatingParameter>k__BackingField;
    internal PSPropertyExpression ResolvedExpression { get; }
    internal MshParameter OriginatingParameter { get; }
    internal MshResolvedExpressionParameterAssociation(MshParameter parameter, PSPropertyExpression expression);
    private static MshResolvedExpressionParameterAssociation();
    [CompilerGeneratedAttribute]
internal PSPropertyExpression get_ResolvedExpression();
    [CompilerGeneratedAttribute]
internal MshParameter get_OriginatingParameter();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.NameEntryDefinition : HashtableEntryDefinition {
    internal static string NameEntryKey;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.NewLineToken : FormatToken {
    internal int count;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.OutCommandInner : ImplementationCommandBase {
    [TraceSourceAttribute("format_out_OutCommandInner", "OutCommandInner")]
internal static PSTraceSource tracer;
    private FormattingState _currentFormattingState;
    private CommandWrapper _command;
    private static int DefaultConsoleWidth;
    private static int DefaultConsoleHeight;
    internal static int StackAllocThreshold;
    private LineOutput _lo;
    private FormatMessagesContextManager _ctxManager;
    private FormattedObjectsCache _cache;
    private FormattingHint _formattingHint;
    private FormatObjectDeserializer _formatObjectDeserializer;
    private FormatShape ActiveFormattingShape { get; }
    internal LineOutput LineOutput { get; internal set; }
    private ShapeInfo ShapeInfoOnFormatContext { get; }
    private FormatOutputContext FormatContext { get; }
    private static OutCommandInner();
    internal virtual void BeginProcessing();
    internal virtual void ProcessRecord();
    internal virtual void EndProcessing();
    private void DrainCache();
    private bool ProcessObject(PSObject so);
    private FormatShape get_ActiveFormattingShape();
    protected virtual void InternalDispose();
    private bool NeedsPreprocessing(object o);
    private void ValidateCurrentFormattingState(FormattingState expectedFormattingState, object obj);
    private Array ApplyFormatting(object o);
    private OutputContext CreateOutputContext(OutputContext parentContext, FormatInfoData formatInfoData);
    private void ProcessFormatStart(OutputContext c);
    private void ProcessFormatEnd(FormatEndData fe, OutputContext c);
    private void ProcessGroupStart(OutputContext c);
    private void ProcessGroupEnd(GroupEndData ge, OutputContext c);
    private void ProcessPayload(FormatEntryData fed, OutputContext c);
    private void ProcessOutOfBandPayload(FormatEntryData fed);
    internal LineOutput get_LineOutput();
    internal void set_LineOutput(LineOutput value);
    private ShapeInfo get_ShapeInfoOnFormatContext();
    private FormatOutputContext get_FormatContext();
    private void ProcessCachedGroup(FormatStartData formatStartData, List`1<PacketInfoData> objects);
    private void ProcessCachedGroupOnTable(TableHeaderInfo thi, List`1<PacketInfoData> objects);
    private void ProcessCachedGroupOnWide(WideViewHeaderInfo wvhi, List`1<PacketInfoData> objects);
    private static int GetConsoleWindowWidth(int columnNumber);
    private static int GetConsoleWindowHeight(int rowNumber);
    private FormattingHint RetrieveFormattingHint();
}
public class Microsoft.PowerShell.Commands.Internal.Format.OuterFormatShapeCommandBase : FrontEndCommandBase {
    [CompilerGeneratedAttribute]
private object <GroupBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <View>k__BackingField;
    internal Nullable`1<bool> showErrorsAsMessages;
    internal Nullable`1<bool> showErrorsInFormattedOutput;
    private bool _forceFormattingAlsoOnOutOfBand;
    [CompilerGeneratedAttribute]
private string <Expand>k__BackingField;
    internal Nullable`1<EnumerableExpansion> expansion;
    [ParameterAttribute]
public object GroupBy { get; public set; }
    [ParameterAttribute]
public string View { get; public set; }
    [ParameterAttribute]
public SwitchParameter ShowError { get; public set; }
    [ParameterAttribute]
public SwitchParameter DisplayError { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string Expand { get; public set; }
    [CompilerGeneratedAttribute]
public object get_GroupBy();
    [CompilerGeneratedAttribute]
public void set_GroupBy(object value);
    [CompilerGeneratedAttribute]
public string get_View();
    [CompilerGeneratedAttribute]
public void set_View(string value);
    public SwitchParameter get_ShowError();
    public void set_ShowError(SwitchParameter value);
    public SwitchParameter get_DisplayError();
    public void set_DisplayError(SwitchParameter value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_Expand();
    [CompilerGeneratedAttribute]
public void set_Expand(string value);
    internal Nullable`1<EnumerableExpansion> ProcessExpandParameter();
    internal MshParameter ProcessGroupByParameter();
    protected virtual void BeginProcessing();
    internal virtual FormattingCommandLineParameters GetCommandLineParameters();
    internal void ReportCannotSpecifyViewAndProperty();
}
public class Microsoft.PowerShell.Commands.Internal.Format.OuterFormatTableAndListBase : OuterFormatShapeCommandBase {
    [CompilerGeneratedAttribute]
private Object[] <Property>k__BackingField;
    [ParameterAttribute]
public Object[] Property { get; public set; }
    [CompilerGeneratedAttribute]
public Object[] get_Property();
    [CompilerGeneratedAttribute]
public void set_Property(Object[] value);
    internal virtual FormattingCommandLineParameters GetCommandLineParameters();
    internal void GetCommandLineProperties(FormattingCommandLineParameters parameters, bool isTable);
}
public class Microsoft.PowerShell.Commands.Internal.Format.OuterFormatTableBase : OuterFormatTableAndListBase {
    private Nullable`1<bool> _autosize;
    [CompilerGeneratedAttribute]
private SwitchParameter <RepeatHeader>k__BackingField;
    private Nullable`1<bool> _hideHeaders;
    private Nullable`1<bool> _multiLine;
    [ParameterAttribute]
public SwitchParameter AutoSize { get; public set; }
    [ParameterAttribute]
public SwitchParameter RepeatHeader { get; public set; }
    [ParameterAttribute]
public SwitchParameter HideTableHeaders { get; public set; }
    [ParameterAttribute]
public SwitchParameter Wrap { get; public set; }
    public SwitchParameter get_AutoSize();
    public void set_AutoSize(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_RepeatHeader();
    [CompilerGeneratedAttribute]
public void set_RepeatHeader(SwitchParameter value);
    public SwitchParameter get_HideTableHeaders();
    public void set_HideTableHeaders(SwitchParameter value);
    public SwitchParameter get_Wrap();
    public void set_Wrap(SwitchParameter value);
    internal virtual FormattingCommandLineParameters GetCommandLineParameters();
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.OutOfBandFormatViewManager : object {
    private static MemberNamePredicate NameIsNotRemotingProperty;
    private static OutOfBandFormatViewManager();
    private static bool IsNotRemotingProperty(string name);
    internal static bool HasNonRemotingProperties(PSObject so);
    internal static FormatEntryData GenerateOutOfBandData(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, PSObject so, int enumerationLimit, bool useToStringFallback, List`1& errors);
    internal static FormatEntryData GenerateOutOfBandObjectAsToString(PSObject so);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.OutputGroupQueue : object {
    private Queue`1<PacketInfoData> _queue;
    private int _objectCount;
    private TimeSpan _groupingDuration;
    private Stopwatch _groupingTimer;
    private ProcessCachedGroupNotification _notificationCallBack;
    private FormatStartData _formatStartData;
    private bool _processingGroup;
    private int _currentObjectCount;
    internal OutputGroupQueue(ProcessCachedGroupNotification callBack, int objectCount);
    internal OutputGroupQueue(ProcessCachedGroupNotification callBack, TimeSpan groupingDuration);
    internal List`1<PacketInfoData> Add(PacketInfoData o);
    private void UpdateObjectCount(PacketInfoData o);
    private void Notify();
    internal PacketInfoData Dequeue();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.OutputManagerInner : ImplementationCommandBase {
    [TraceSourceAttribute("format_out_OutputManagerInner", "OutputManagerInner")]
internal static PSTraceSource tracer;
    private LineOutput _lo;
    private SubPipelineManager _mgr;
    private bool _isStopped;
    private object _syncRoot;
    unknown LineOutput LineOutput {internal set; }
    private static OutputManagerInner();
    internal void set_LineOutput(LineOutput value);
    internal virtual void ProcessRecord();
    internal virtual void EndProcessing();
    internal virtual void StopProcessing();
    protected virtual void InternalDispose();
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.PacketInfoData : FormatInfoData {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.PageFooterEntry : FreeFormatEntry {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.PageHeaderEntry : FreeFormatEntry {
    internal static string CLSID;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ParameterProcessor : object {
    [TraceSourceAttribute("ParameterProcessor", "ParameterProcessor")]
internal static PSTraceSource tracer;
    private CommandParameterDefinition _paramDef;
    internal ParameterProcessor(CommandParameterDefinition p);
    private static ParameterProcessor();
    internal static void ThrowParameterBindingException(TerminatingErrorContext invocationContext, string errorId, string msg);
    internal List`1<MshParameter> ProcessParameters(Object[] p, TerminatingErrorContext invocationContext);
    private static bool MatchesAllowedTypes(Type t, Type[] allowedTypes);
    private Hashtable VerifyHashTable(IDictionary hash, TerminatingErrorContext invocationContext);
    private void VerifyAndNormalizeParameter(MshParameter parameter, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
    private static void ProcessUnknownParameterType(TerminatingErrorContext invocationContext, object actualObject, Type[] allowedTypes);
    private static void ProcessDuplicateHashTableKey(TerminatingErrorContext invocationContext, string duplicateKey, string existingKey);
    private static void ProcessNullHashTableKey(TerminatingErrorContext invocationContext);
    private static void ProcessNonStringHashTableKey(TerminatingErrorContext invocationContext, object key);
    private static void ProcessIllegalHashTableKeyValue(TerminatingErrorContext invocationContext, string key, Type actualType, Type[] allowedTypes);
    private static void ProcessMissingKeyValue(TerminatingErrorContext invocationContext, string keyName);
    private static void ProcessMissingMandatoryKey(TerminatingErrorContext invocationContext, string keyName);
    private static string CatenateTypeArray(Type[] arr);
    internal static string CatenateStringArray(String[] arr);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.PropertyTokenBase : FormatToken {
    internal ExpressionToken conditionToken;
    internal ExpressionToken expression;
    internal bool enumerateCollection;
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.PSObjectHelper : object {
    [TraceSourceAttribute("PSObjectHelper", "PSObjectHelper")]
private static PSTraceSource s_tracer;
    internal static char Ellipsis;
    internal static string EllipsisStr;
    private static PSObject s_emptyPSObject;
    private static PSObjectHelper();
    internal static string PSObjectIsOfExactType(Collection`1<string> typeNames);
    internal static bool PSObjectIsEnum(Collection`1<string> typeNames);
    internal static PSPropertyExpression GetDisplayNameExpression(PSObject target, PSPropertyExpressionFactory expressionFactory);
    internal static PSPropertyExpressionResult GetDisplayName(PSObject target, PSPropertyExpressionFactory expressionFactory);
    internal static IEnumerable GetEnumerable(object obj);
    private static string GetSmartToStringDisplayName(object x, PSPropertyExpressionFactory expressionFactory);
    private static string GetObjectName(object x, PSPropertyExpressionFactory expressionFactory);
    internal static string SmartToString(PSObject so, PSPropertyExpressionFactory expressionFactory, int enumerationLimit, StringFormatError formatErrorObject, bool formatFloat);
    internal static PSObject AsPSObject(object obj);
    internal static string FormatField(FieldFormattingDirective directive, object val, int enumerationLimit, StringFormatError formatErrorObject, PSPropertyExpressionFactory expressionFactory);
    private static PSMemberSet MaskDeserializedAndGetStandardMembers(PSObject so);
    private static List`1<PSPropertyExpression> GetDefaultPropertySet(PSMemberSet standardMembersSet);
    internal static List`1<PSPropertyExpression> GetDefaultPropertySet(PSObject so);
    private static PSPropertyExpression GetDefaultNameExpression(PSMemberSet standardMembersSet);
    private static PSPropertyExpression GetDefaultNameExpression(PSObject so);
    internal static string GetExpressionDisplayValue(PSObject so, int enumerationLimit, PSPropertyExpression ex, FieldFormattingDirective directive, StringFormatError formatErrorObject, PSPropertyExpressionFactory expressionFactory, PSPropertyExpressionResult& result);
    internal static bool ShouldShowComputerNameProperty(PSObject so);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.PSPropertyExpressionError : FormattingError {
    internal PSPropertyExpressionResult result;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.PSPropertyExpressionFactory : object {
    private Dictionary`2<ExpressionToken, PSPropertyExpression> _expressionCache;
    internal void VerifyScriptBlockText(string scriptText);
    internal PSPropertyExpression CreateFromExpressionToken(ExpressionToken et);
    internal PSPropertyExpression CreateFromExpressionToken(ExpressionToken et, DatabaseLoadingInfo loadingInfo);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.RawTextFormatEntry : FormatEntryInfo {
    internal static string CLSID;
    public string text;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ShapeInfo : FormatInfoData {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ShapeSelectionDirectives : object {
    private Nullable`1<int> _propertyCountForTable;
    internal List`1<FormatShapeSelectionOnType> formatShapeSelectionOnTypeList;
    internal int PropertyCountForTable { get; internal set; }
    internal int get_PropertyCountForTable();
    internal void set_PropertyCountForTable(int value);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ShapeSpecificParameters : object {
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.StartData : ControlInfoData {
    public ShapeInfo shapeInfo;
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.StartGroup : object {
    internal ExpressionToken expression;
    internal ControlBase control;
    internal TextToken labelTextToken;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.StreamingTextWriter : TextWriter {
    [TraceSourceAttribute("StreamingTextWriter", "StreamingTextWriter")]
private static PSTraceSource s_tracer;
    private WriteLineCallback _writeCall;
    public Encoding Encoding { get; }
    internal StreamingTextWriter(WriteLineCallback writeCall, CultureInfo culture);
    private static StreamingTextWriter();
    public virtual Encoding get_Encoding();
    public virtual void WriteLine(string s);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.StringFormatError : FormattingError {
    internal string formatString;
    internal Exception exception;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.StringManipulationHelper : object {
    private static char SoftHyphen;
    private static char HardHyphen;
    private static char NonBreakingSpace;
    private static Collection`1<string> s_cultureCollection;
    private static StringManipulationHelper();
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.Internal.Format.StringManipulationHelper/<GetWords>d__5")]
private static IEnumerable`1<GetWordsResult> GetWords(string s);
    internal static StringCollection GenerateLines(DisplayCells displayCells, string val, int firstLineLen, int followingLinesLen);
    private static StringCollection GenerateLinesWithoutWordWrap(DisplayCells displayCells, string val, int firstLineLen, int followingLinesLen);
    private static StringCollection GenerateLinesWithWordWrap(DisplayCells displayCells, string val, int firstLineLen, int followingLinesLen);
    internal static List`1<string> SplitLines(string s);
    internal static string TruncateAtNewLine(string s);
    internal static string PadLeft(string val, int count);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.StringResourceReference : object {
    internal DatabaseLoadingInfo loadingInfo;
    internal string assemblyName;
    internal string assemblyLocation;
    internal string baseName;
    internal string resourceId;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.SubPipelineManager : object {
    private LineOutput _lo;
    private List`1<CommandEntry> _commandEntryList;
    private CommandEntry _defaultCommandEntry;
    internal void Initialize(LineOutput lineOutput, ExecutionContext context);
    private void InitializeCommandsHardWired(ExecutionContext context);
    private void RegisterCommandDefault(ExecutionContext context, string commandName, Type commandType);
    internal void Process(PSObject so);
    internal void ShutDown();
    public sealed virtual void Dispose();
    private CommandEntry GetActiveCommandEntry(PSObject so);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableColumnHeaderDefinition : object {
    internal TextToken label;
    internal int alignment;
    internal int width;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableColumnInfo : FormatInfoData {
    internal static string CLSID;
    public int width;
    public int alignment;
    public string label;
    public string propertyName;
    public bool HeaderMatchesProperty;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableControlBody : ControlBody {
    internal TableHeaderDefinition header;
    internal TableRowDefinition defaultDefinition;
    internal List`1<TableRowDefinition> optionalDefinitionList;
    internal virtual ControlBase Copy();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableHeaderDefinition : object {
    internal bool hideHeader;
    internal List`1<TableColumnHeaderDefinition> columnHeaderDefinitionList;
    internal TableHeaderDefinition Copy();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableHeaderInfo : ShapeInfo {
    internal static string CLSID;
    public bool hideHeader;
    public bool repeatHeader;
    public List`1<TableColumnInfo> tableColumnInfoList;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableRowDefinition : object {
    internal AppliesTo appliesTo;
    internal bool multiLine;
    internal List`1<TableRowItemDefinition> rowItemDefinitionList;
    internal TableRowDefinition Copy();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableRowEntry : FormatEntryInfo {
    internal static string CLSID;
    public List`1<FormatPropertyField> formatPropertyFieldList;
    public bool multiLine;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableRowItemDefinition : object {
    internal int alignment;
    internal List`1<FormatToken> formatTokenList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableSpecificParameters : ShapeSpecificParameters {
    internal Nullable`1<bool> hideHeaders;
    internal Nullable`1<bool> multiLine;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableViewGenerator : ViewGenerator {
    private TableControlBody _tableBody;
    private bool HideHeaders { get; }
    private bool RepeatHeaders { get; }
    internal virtual void Initialize(TerminatingErrorContext terminatingErrorContext, PSPropertyExpressionFactory mshExpressionFactory, TypeInfoDataBase db, ViewDefinition view, FormattingCommandLineParameters formatParameters);
    internal virtual void Initialize(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, PSObject so, TypeInfoDataBase db, FormattingCommandLineParameters parameters);
    internal virtual void PrepareForRemoteObjects(PSObject so);
    internal virtual FormatStartData GenerateStartData(PSObject so);
    private void FilterActiveAssociationList();
    private TableHeaderInfo GenerateTableHeaderInfoFromDataBaseInfo(PSObject so);
    private TableHeaderInfo GenerateTableHeaderInfoFromProperties(PSObject so);
    private bool get_HideHeaders();
    private bool get_RepeatHeaders();
    private static int ComputeDefaultAlignment(PSObject so, PSPropertyExpression ex);
    internal virtual FormatEntryData GeneratePayload(PSObject so, int enumerationLimit);
    private List`1<TableRowItemDefinition> GetActiveTableRowDefinition(TableControlBody tableBody, PSObject so, Boolean& multiLine);
    private TableRowEntry GenerateTableRowEntryFromDataBaseInfo(PSObject so, int enumerationLimit);
    private TableRowEntry GenerateTableRowEntryFromFromProperties(PSObject so, int enumerationLimit);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TableWriter : object {
    private ScreenInfo _si;
    private List`1<string> _header;
    private static int EllipsisSize;
    private bool _disabled;
    private bool _hideHeader;
    private int _startColumn;
    internal static int ComputeWideViewBestItemsPerRowFit(int stringLen, int screenColumns);
    internal void Initialize(int leftMarginIndent, int screenColumns, Span`1<int> columnWidths, ReadOnlySpan`1<int> alignment, ReadOnlySpan`1<bool> headerMatchesProperty, bool suppressHeader, int screenRows);
    internal int GenerateHeader(String[] values, LineOutput lo);
    internal void GenerateRow(String[] values, LineOutput lo, bool multiLine, ReadOnlySpan`1<int> alignment, DisplayCells dc, List`1<string> generatedRows, bool isHeader);
    private String[] GenerateTableRow(String[] values, ReadOnlySpan`1<int> alignment, DisplayCells ds, bool isHeader);
    private StringCollection GenerateMultiLineRowField(string val, int k, int alignment, DisplayCells dc, bool addPadding);
    private string GenerateRow(String[] values, ReadOnlySpan`1<int> alignment, DisplayCells dc, bool isHeader);
    private static string GenerateRowField(string val, int width, int alignment, DisplayCells dc, bool addPadding);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TerminatingErrorContext : object {
    private PSCmdlet _command;
    internal TerminatingErrorContext(PSCmdlet command);
    [DoesNotReturnAttribute]
internal void ThrowTerminatingError(ErrorRecord errorRecord);
}
internal static class Microsoft.PowerShell.Commands.Internal.Format.TextAlignment : object {
    internal static int Undefined;
    internal static int Left;
    internal static int Center;
    internal static int Right;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TextToken : FormatToken {
    internal string text;
    internal StringResourceReference resource;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TextWriterLineOutput : LineOutput {
    private int _columns;
    private TextWriter _writer;
    private bool _suppressNewline;
    internal int ColumnNumber { get; }
    internal int RowNumber { get; }
    internal TextWriterLineOutput(TextWriter writer, int columns);
    internal TextWriterLineOutput(TextWriter writer, int columns, bool suppressNewline);
    internal virtual int get_ColumnNumber();
    internal virtual int get_RowNumber();
    internal virtual void WriteLine(string s);
    internal virtual void WriteRawText(string s);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TooManyErrorsException : TypeInfoDataBaseLoaderException {
    internal int errorCount;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TraversalInfo : object {
    private int _level;
    private int _maxDepth;
    internal int Level { get; }
    internal int MaxDepth { get; }
    internal TraversalInfo NextLevel { get; }
    internal TraversalInfo(int level, int maxDepth);
    internal int get_Level();
    internal int get_MaxDepth();
    internal TraversalInfo get_NextLevel();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeGroupDefinition : object {
    internal string name;
    internal List`1<TypeReference> typeReferenceList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeGroupReference : TypeOrGroupReference {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeGroupsSection : object {
    internal List`1<TypeGroupDefinition> typeGroupDefinitionList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeInfoDataBase : object {
    internal DefaultSettingsSection defaultSettingsSection;
    internal TypeGroupsSection typeGroupSection;
    internal ViewDefinitionsSection viewDefinitionsSection;
    internal FormatControlDefinitionHolder formatControlDefinitionHolder;
    internal DisplayResourceManagerCache displayResourceManagerCache;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeInfoDataBaseLoader : XmlLoaderBase {
    private static string resBaseName;
    [TraceSourceAttribute("TypeInfoDataBaseLoader", "TypeInfoDataBaseLoader")]
private static PSTraceSource s_tracer;
    private bool _suppressValidation;
    private static TypeInfoDataBaseLoader();
    internal bool LoadXmlFile(XmlFileLoadInfo info, TypeInfoDataBase db, PSPropertyExpressionFactory expressionFactory, AuthorizationManager authorizationManager, PSHost host, bool preValidated);
    internal bool LoadFormattingData(ExtendedTypeDefinition typeDefinition, TypeInfoDataBase db, PSPropertyExpressionFactory expressionFactory, bool isBuiltInFormatData, bool isForHelp);
    private void LoadData(XmlDocument doc, TypeInfoDataBase db);
    private void LoadData(ExtendedTypeDefinition typeDefinition, TypeInfoDataBase db, bool isForHelpOutput);
    private ViewDefinition LoadViewFromObjectModel(List`1<string> typeNames, FormatViewDefinition formatView, int viewIndex);
    private ControlBase LoadTableControlFromObjectModel(TableControl table, int viewIndex, string typeName);
    private static void LoadHeadersSectionFromObjectModel(TableControlBody tableBody, List`1<TableControlColumnHeader> headers);
    private void LoadRowEntriesSectionFromObjectModel(TableControlBody tableBody, List`1<TableControlRow> rowEntries, int viewIndex, string typeName);
    private void LoadColumnEntriesFromObjectModel(TableRowDefinition trd, List`1<TableControlColumn> columns, int viewIndex, string typeName);
    private ExpressionToken LoadExpressionFromObjectModel(DisplayEntry displayEntry, int viewIndex, string typeName);
    private static AppliesTo LoadAppliesToSectionFromObjectModel(List`1<string> selectedBy, List`1<DisplayEntry> condition);
    private ListControlBody LoadListControlFromObjectModel(ListControl list, int viewIndex, string typeName);
    private void LoadListControlEntriesFromObjectModel(ListControlBody listBody, List`1<ListControlEntry> entries, int viewIndex, string typeName);
    private ListControlEntryDefinition LoadListControlEntryDefinitionFromObjectModel(ListControlEntry listEntry, int viewIndex, string typeName);
    private void LoadListControlItemDefinitionsFromObjectModel(ListControlEntryDefinition lved, List`1<ListControlEntryItem> listItems, int viewIndex, string typeName);
    private WideControlBody LoadWideControlFromObjectModel(WideControl wide, int viewIndex, string typeName);
    private void LoadWideControlEntriesFromObjectModel(WideControlBody wideBody, List`1<WideControlEntryItem> wideEntries, int viewIndex, string typeName);
    private WideControlEntryDefinition LoadWideControlEntryFromObjectModel(WideControlEntryItem wideItem, int viewIndex, string typeName);
    private ComplexControlBody LoadCustomControlFromObjectModel(CustomControl custom, int viewIndex, string typeName);
    private ComplexControlEntryDefinition LoadComplexControlEntryDefinitionFromObjectModel(CustomControlEntry entry, int viewIndex, string typeName);
    private FormatToken LoadFormatTokenFromObjectModel(CustomItemBase item, int viewIndex, string typeName);
    private void LoadDefaultSettings(TypeInfoDataBase db, XmlNode defaultSettingsNode);
    private List`1<EnumerableExpansionDirective> LoadEnumerableExpansionDirectiveList(XmlNode expansionListNode);
    private EnumerableExpansionDirective LoadEnumerableExpansionDirective(XmlNode directive, int index);
    private void LoadTypeGroups(TypeInfoDataBase db, XmlNode typeGroupsNode);
    private void LoadTypeGroup(TypeInfoDataBase db, XmlNode typeGroupNode, int index);
    private void LoadTypeGroupTypeRefs(XmlNode typesNode, TypeGroupDefinition typeGroupDefinition);
    private AppliesTo LoadAppliesToSection(XmlNode appliesToNode, bool allowSelectionCondition);
    private TypeReference LoadTypeReference(XmlNode n);
    private TypeGroupReference LoadTypeGroupReference(XmlNode n);
    private TypeOrGroupReference LoadSelectionConditionNode(XmlNode selectionConditionNode);
    private GroupBy LoadGroupBySection(XmlNode groupByNode);
    private TextToken LoadLabel(XmlNode textNode);
    private TextToken LoadTextToken(XmlNode n);
    private bool LoadStringResourceReference(XmlNode n, StringResourceReference& resource);
    private StringResourceReference LoadResourceAttributes(XmlAttributeCollection attributes);
    private void ReportStringResourceFailure(StringResourceReference resource, LoadingResult result, AssemblyBindingStatus bindingStatus);
    internal bool VerifyScriptBlock(string scriptBlockText);
    private ComplexControlBody LoadComplexControl(XmlNode controlNode);
    private void LoadComplexControlEntries(XmlNode complexControlEntriesNode, ComplexControlBody complexBody);
    private ComplexControlEntryDefinition LoadComplexControlEntryDefinition(XmlNode complexControlEntryNode, int index);
    private List`1<FormatToken> LoadComplexControlTokenListDefinitions(XmlNode bodyNode);
    private bool LoadPropertyBaseHelper(XmlNode propertyBaseNode, PropertyTokenBase ptb, List`1<XmlNode> unprocessedNodes);
    private CompoundPropertyToken LoadCompoundProperty(XmlNode compoundPropertyNode, int index);
    private NewLineToken LoadNewLine(XmlNode newLineNode, int index);
    private TextToken LoadText(XmlNode textNode, int index);
    internal TextToken LoadText(XmlNode textNode);
    private int LoadIntegerValue(XmlNode node, Boolean& success);
    private int LoadPositiveOrZeroIntegerValue(XmlNode node, Boolean& success);
    private FrameToken LoadFrameDefinition(XmlNode frameNode, int index);
    private bool ReadBooleanNode(XmlNode collectionElement, Boolean& val);
    private ListControlBody LoadListControl(XmlNode controlNode);
    private void LoadListControlEntries(XmlNode listViewEntriesNode, ListControlBody listBody);
    private ListControlEntryDefinition LoadListControlEntryDefinition(XmlNode listViewEntryNode, int index);
    private void LoadListControlItemDefinitions(ListControlEntryDefinition lved, XmlNode bodyNode);
    private ListControlItemDefinition LoadListControlItemDefinition(XmlNode propertyEntryNode);
    private ExpressionToken LoadItemSelectionCondition(XmlNode itemNode);
    private ControlBase LoadTableControl(XmlNode controlNode);
    private void LoadHeadersSection(TableControlBody tableBody, XmlNode headersNode);
    private TableColumnHeaderDefinition LoadColumnHeaderDefinition(XmlNode columnHeaderNode, int index);
    private bool ReadPositiveIntegerValue(XmlNode n, Int32& val);
    private bool LoadAlignmentValue(XmlNode n, Int32& alignmentValue);
    private void LoadRowEntriesSection(TableControlBody tableBody, XmlNode rowEntriesNode);
    private TableRowDefinition LoadRowEntryDefinition(XmlNode rowEntryNode, int index);
    private void LoadColumnEntries(XmlNode columnEntriesNode, TableRowDefinition trd);
    private TableRowItemDefinition LoadColumnEntry(XmlNode columnEntryNode, int index);
    private void LoadViewDefinitions(TypeInfoDataBase db, XmlNode viewDefinitionsNode);
    private ViewDefinition LoadView(XmlNode viewNode, int index);
    private bool LoadMainControlDependentData(List`1<XmlNode> unprocessedNodes, ViewDefinition view);
    private bool LoadCommonViewData(XmlNode viewNode, ViewDefinition view, List`1<XmlNode> unprocessedNodes);
    private void LoadControlDefinitions(XmlNode definitionsNode, List`1<ControlDefinition> controlDefinitionList);
    private ControlDefinition LoadControlDefinition(XmlNode controlDefinitionNode, int index);
    private WideControlBody LoadWideControl(XmlNode controlNode);
    private void LoadWideControlEntries(XmlNode wideControlEntriesNode, WideControlBody wideBody);
    private WideControlEntryDefinition LoadWideControlEntry(XmlNode wideControlEntryNode, int index);
    private List`1<FormatToken> LoadPropertyEntry(XmlNode propertyEntryNode);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.TypeInfoDataBaseLoaderException : SystemException {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeInfoDataBaseManager : object {
    [CompilerGeneratedAttribute]
private TypeInfoDataBase <Database>k__BackingField;
    internal object databaseLock;
    internal object updateDatabaseLock;
    internal bool isShared;
    private List`1<string> _formatFileList;
    [CompilerGeneratedAttribute]
private bool <DisableFormatTableUpdates>k__BackingField;
    private static Dictionary`2<string, Tuple`2<bool, TypeGenerator>> s_builtinGenerators;
    internal TypeInfoDataBase Database { get; private set; }
    internal bool DisableFormatTableUpdates { get; internal set; }
    internal TypeInfoDataBaseManager(IEnumerable`1<string> formatFiles, bool isShared, AuthorizationManager authorizationManager, PSHost host);
    [CompilerGeneratedAttribute]
internal TypeInfoDataBase get_Database();
    [CompilerGeneratedAttribute]
private void set_Database(TypeInfoDataBase value);
    [CompilerGeneratedAttribute]
internal bool get_DisableFormatTableUpdates();
    [CompilerGeneratedAttribute]
internal void set_DisableFormatTableUpdates(bool value);
    internal TypeInfoDataBase GetTypeInfoDataBase();
    internal void Add(string formatFile, bool shouldPrepend);
    internal void Remove(string formatFile);
    internal void AddFormatData(IEnumerable`1<ExtendedTypeDefinition> formatData, bool shouldPrepend);
    internal void Update(AuthorizationManager authorizationManager, PSHost host);
    internal void UpdateDataBase(Collection`1<PSSnapInTypeAndFormatErrors> mshsnapins, AuthorizationManager authorizationManager, PSHost host, bool preValidated);
    internal bool LoadFromFile(Collection`1<PSSnapInTypeAndFormatErrors> files, PSPropertyExpressionFactory expressionFactory, bool acceptLoadingErrors, AuthorizationManager authorizationManager, PSHost host, bool preValidated, List`1& logEntries);
    private static TypeInfoDataBase LoadFromFileHelper(Collection`1<PSSnapInTypeAndFormatErrors> files, PSPropertyExpressionFactory expressionFactory, AuthorizationManager authorizationManager, PSHost host, bool preValidated, List`1& logEntries, Boolean& success);
    private static void LoadFormatDataHelper(ExtendedTypeDefinition formatData, PSPropertyExpressionFactory expressionFactory, List`1<XmlLoaderLoggerEntry> logEntries, Boolean& success, PSSnapInTypeAndFormatErrors file, TypeInfoDataBase db, bool isBuiltInFormatData, bool isForHelp);
    private static Tuple`2<bool, TypeGenerator> GetBuiltin(bool isForHelp, TypeGenerator generator);
    private static bool ProcessBuiltin(PSSnapInTypeAndFormatErrors file, TypeInfoDataBase db, PSPropertyExpressionFactory expressionFactory, List`1<XmlLoaderLoggerEntry> logEntries, Boolean& success);
    private static void ProcessBuiltinFormatViewDefinitions(IEnumerable`1<ExtendedTypeDefinition> views, TypeInfoDataBase db, PSPropertyExpressionFactory expressionFactory, PSSnapInTypeAndFormatErrors file, List`1<XmlLoaderLoggerEntry> logEntries, bool isForHelp, Boolean& success);
    private static void AddPreLoadIntrinsics(TypeInfoDataBase db);
    private static void AddPostLoadIntrinsics(TypeInfoDataBase db);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeMatch : object {
    [TraceSourceAttribute("TypeMatch", "F&O TypeMatch")]
private static PSTraceSource s_classTracer;
    private static PSTraceSource s_activeTracer;
    private PSPropertyExpressionFactory _expressionFactory;
    private TypeInfoDataBase _db;
    private Collection`1<string> _typeNameHierarchy;
    private bool _useInheritance;
    private int _bestMatchIndex;
    private TypeMatchItem _bestMatchItem;
    private static int BestMatchIndexUndefined;
    private static int BestMatchIndexPerfect;
    private static PSTraceSource ActiveTracer { get; }
    internal object BestMatch { get; }
    internal TypeMatch(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames);
    internal TypeMatch(PSPropertyExpressionFactory expressionFactory, TypeInfoDataBase db, Collection`1<string> typeNames, bool useInheritance);
    private static TypeMatch();
    private static PSTraceSource get_ActiveTracer();
    internal static void SetTracer(PSTraceSource t);
    internal static void ResetTracer();
    internal bool PerfectMatch(TypeMatchItem item);
    internal object get_BestMatch();
    private int ComputeBestMatch(AppliesTo appliesTo, PSObject currentObject);
    private int ComputeBestMatchInGroup(TypeGroupDefinition tgd, PSObject currentObject, PSPropertyExpression ex);
    private int MatchTypeIndex(string typeName, PSObject currentObject, PSPropertyExpression ex);
    private static bool MatchCondition(PSObject currentObject, PSPropertyExpression ex);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeMatchItem : object {
    [CompilerGeneratedAttribute]
private object <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private AppliesTo <AppliesTo>k__BackingField;
    [CompilerGeneratedAttribute]
private PSObject <CurrentObject>k__BackingField;
    internal object Item { get; }
    internal AppliesTo AppliesTo { get; }
    internal PSObject CurrentObject { get; }
    internal TypeMatchItem(object obj, AppliesTo a);
    internal TypeMatchItem(object obj, AppliesTo a, PSObject currentObject);
    [CompilerGeneratedAttribute]
internal object get_Item();
    [CompilerGeneratedAttribute]
internal AppliesTo get_AppliesTo();
    [CompilerGeneratedAttribute]
internal PSObject get_CurrentObject();
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.TypeOrGroupReference : object {
    internal string name;
    internal ExpressionToken conditionToken;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.TypeReference : TypeOrGroupReference {
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ViewDefinition : object {
    internal DatabaseLoadingInfo loadingInfo;
    internal string name;
    internal AppliesTo appliesTo;
    internal GroupBy groupBy;
    internal FormatControlDefinitionHolder formatControlDefinitionHolder;
    internal ControlBase mainControl;
    internal bool outOfBand;
    internal bool isHelpFormatter;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    internal Guid InstanceId { get; private set; }
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
private void set_InstanceId(Guid value);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.ViewDefinitionsSection : object {
    internal List`1<ViewDefinition> viewDefinitionList;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.ViewGenerator : object {
    private GroupingInfoManager _groupingManager;
    private bool _autosize;
    private bool _repeatHeader;
    protected TerminatingErrorContext errorContext;
    protected FormattingCommandLineParameters parameters;
    protected PSPropertyExpressionFactory expressionFactory;
    protected DataBaseInfo dataBaseInfo;
    protected List`1<MshResolvedExpressionParameterAssociation> activeAssociationList;
    protected FormattingCommandLineParameters inputParameters;
    private FormatErrorManager _errorManager;
    protected bool AutoSize { get; }
    protected bool RepeatHeader { get; }
    internal FormatErrorManager ErrorManager { get; }
    internal virtual void Initialize(TerminatingErrorContext terminatingErrorContext, PSPropertyExpressionFactory mshExpressionFactory, TypeInfoDataBase db, ViewDefinition view, FormattingCommandLineParameters formatParameters);
    internal virtual void Initialize(TerminatingErrorContext terminatingErrorContext, PSPropertyExpressionFactory mshExpressionFactory, PSObject so, TypeInfoDataBase db, FormattingCommandLineParameters formatParameters);
    internal virtual void PrepareForRemoteObjects(PSObject so);
    private void InitializeHelper();
    private void InitializeFormatErrorManager();
    private void InitializeGroupBy();
    private void InitializeAutoSize();
    private void InitializeRepeatHeader();
    internal virtual FormatStartData GenerateStartData(PSObject so);
    internal abstract virtual FormatEntryData GeneratePayload(PSObject so, int enumerationLimit);
    internal GroupStartData GenerateGroupStartData(PSObject firstObjectInGroup, int enumerationLimit);
    internal bool UpdateGroupingKeyValue(PSObject so);
    internal GroupEndData GenerateGroupEndData();
    internal bool IsObjectApplicable(Collection`1<string> typeNames);
    protected bool get_AutoSize();
    protected bool get_RepeatHeader();
    protected string GetExpressionDisplayValue(PSObject so, int enumerationLimit, PSPropertyExpression ex, FieldFormattingDirective directive);
    protected string GetExpressionDisplayValue(PSObject so, int enumerationLimit, PSPropertyExpression ex, FieldFormattingDirective directive, PSPropertyExpressionResult& expressionResult);
    protected bool EvaluateDisplayCondition(PSObject so, ExpressionToken conditionToken);
    internal FormatErrorManager get_ErrorManager();
    protected FormatPropertyField GenerateFormatPropertyField(List`1<FormatToken> formatTokenList, PSObject so, int enumerationLimit);
    protected FormatPropertyField GenerateFormatPropertyField(List`1<FormatToken> formatTokenList, PSObject so, int enumerationLimit, PSPropertyExpressionResult& result);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideControlBody : ControlBody {
    internal int columns;
    internal WideControlEntryDefinition defaultEntryDefinition;
    internal List`1<WideControlEntryDefinition> optionalEntryList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideControlEntryDefinition : object {
    internal AppliesTo appliesTo;
    internal List`1<FormatToken> formatTokenList;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideSpecificParameters : ShapeSpecificParameters {
    internal Nullable`1<int> columns;
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideViewEntry : FormatEntryInfo {
    internal static string CLSID;
    public FormatPropertyField formatPropertyField;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideViewGenerator : ViewGenerator {
    private int Columns { get; }
    internal virtual void Initialize(TerminatingErrorContext errorContext, PSPropertyExpressionFactory expressionFactory, PSObject so, TypeInfoDataBase db, FormattingCommandLineParameters parameters);
    internal virtual FormatStartData GenerateStartData(PSObject so);
    private int get_Columns();
    internal virtual FormatEntryData GeneratePayload(PSObject so, int enumerationLimit);
    private WideViewEntry GenerateWideViewEntryFromDataBaseInfo(PSObject so, int enumerationLimit);
    private WideControlEntryDefinition GetActiveWideControlEntryDefinition(WideControlBody wideBody, PSObject so);
    private WideViewEntry GenerateWideViewEntryFromProperties(PSObject so, int enumerationLimit);
    private void SetUpActiveProperty(PSObject so);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WideViewHeaderInfo : ShapeInfo {
    internal static string CLSID;
    public int columns;
    public string ClassId2e4f51ef21dd47e99d3c952918aff9cd { get; }
    public virtual string get_ClassId2e4f51ef21dd47e99d3c952918aff9cd();
    internal virtual void Deserialize(PSObject so, FormatObjectDeserializer deserializer);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WidthEntryDefinition : HashtableEntryDefinition {
    internal virtual object Verify(object val, TerminatingErrorContext invocationContext, bool originalParameterWasHashTable);
    private void VerifyRange(int width, TerminatingErrorContext invocationContext);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.WriteLineHelper : object {
    private WriteCallback _writeCall;
    private WriteCallback _writeLineCall;
    private bool _lineWrap;
    private DisplayCells _displayCells;
    internal WriteLineHelper(bool lineWrap, WriteCallback wlc, WriteCallback wc, DisplayCells displayCells);
    internal void WriteLine(string s, int cols);
    private void WriteLineInternal(string val, int cols);
}
internal class Microsoft.PowerShell.Commands.Internal.Format.XmlFileLoadInfo : object {
    internal string fileDirectory;
    internal string filePath;
    internal ConcurrentBag`1<string> errors;
    internal string psSnapinName;
    internal XmlFileLoadInfo(string dir, string path, ConcurrentBag`1<string> errors, string psSnapinName);
}
internal abstract class Microsoft.PowerShell.Commands.Internal.Format.XmlLoaderBase : object {
    [TraceSourceAttribute("XmlLoaderBase", "XmlLoaderBase")]
private static PSTraceSource s_tracer;
    private DatabaseLoadingInfo _loadingInfo;
    protected PSPropertyExpressionFactory expressionFactory;
    protected DisplayResourceManagerCache displayResourceManagerCache;
    [CompilerGeneratedAttribute]
private bool <VerifyStringResources>k__BackingField;
    private int _maxNumberOfErrors;
    private int _currentErrorCount;
    private bool _logStackActivity;
    private Stack`1<XmlLoaderStackFrame> _executionStack;
    private XmlLoaderLogger _logger;
    internal List`1<XmlLoaderLoggerEntry> LogEntries { get; }
    internal bool HasErrors { get; }
    protected string FilePath { get; }
    protected DatabaseLoadingInfo LoadingInfo { get; }
    internal bool VerifyStringResources { get; }
    private static XmlLoaderBase();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal List`1<XmlLoaderLoggerEntry> get_LogEntries();
    internal bool get_HasErrors();
    protected IDisposable StackFrame(XmlNode n);
    protected IDisposable StackFrame(XmlNode n, int index);
    private void RemoveStackFrame();
    protected void ProcessUnknownNode(XmlNode n);
    protected void ProcessUnknownAttribute(XmlAttribute a);
    protected static bool IsFilteredOutNode(XmlNode n);
    protected bool VerifyNodeHasNoChildren(XmlNode n);
    internal string GetMandatoryInnerText(XmlNode n);
    internal string GetMandatoryAttributeValue(XmlAttribute a);
    private bool MatchNodeNameHelper(XmlNode n, string s, bool allowAttributes);
    internal bool MatchNodeNameWithAttributes(XmlNode n, string s);
    internal bool MatchNodeName(XmlNode n, string s);
    internal bool MatchAttributeName(XmlAttribute a, string s);
    internal void ProcessDuplicateNode(XmlNode n);
    internal void ProcessDuplicateAlternateNode(string node1, string node2);
    internal void ProcessDuplicateAlternateNode(XmlNode n, string node1, string node2);
    private void ReportIllegalXmlNode(XmlNode n);
    private void ReportIllegalXmlAttribute(XmlAttribute a);
    protected void ReportMissingAttribute(string name);
    protected void ReportMissingNode(string name);
    protected void ReportMissingNodes(String[] names);
    protected void ReportEmptyNode(XmlNode n);
    protected void ReportEmptyAttribute(XmlAttribute a);
    protected void ReportTrace(string message);
    protected void ReportError(string message);
    private void ReportLogEntryHelper(string message, EntryType entryType, bool failToLoadFile);
    protected void ReportErrorForLoadingFromObjectModel(string message, string typeName);
    private void WriteStackLocation(string label);
    protected string ComputeCurrentXPath();
    protected XmlDocument LoadXmlDocumentFromFileLoadingInfo(AuthorizationManager authorizationManager, PSHost host, Boolean& isFullyTrusted);
    protected string get_FilePath();
    protected void SetDatabaseLoadingInfo(XmlFileLoadInfo info);
    protected void SetLoadingInfoIsFullyTrusted(bool isFullyTrusted);
    protected void SetLoadingInfoIsProductCode(bool isProductCode);
    protected DatabaseLoadingInfo get_LoadingInfo();
    [CompilerGeneratedAttribute]
internal bool get_VerifyStringResources();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.XmlLoaderLogger : object {
    [TraceSourceAttribute("FormatFileLoading", "Loading format files")]
private static PSTraceSource s_formatFileLoadingtracer;
    private bool _saveInMemory;
    private List`1<XmlLoaderLoggerEntry> _entries;
    private bool _hasErrors;
    internal List`1<XmlLoaderLoggerEntry> LogEntries { get; }
    internal bool HasErrors { get; }
    private static XmlLoaderLogger();
    internal void LogEntry(XmlLoaderLoggerEntry entry);
    private static void WriteToTracer(XmlLoaderLoggerEntry entry);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal List`1<XmlLoaderLoggerEntry> get_LogEntries();
    internal bool get_HasErrors();
}
internal class Microsoft.PowerShell.Commands.Internal.Format.XmlLoaderLoggerEntry : object {
    internal EntryType entryType;
    internal string filePath;
    internal string xPath;
    internal string message;
    internal bool failToLoadFile;
}
public static class Microsoft.PowerShell.Commands.Internal.RemotingErrorResources : object {
    public static string WinRMRestartWarning { get; }
    public static string CouldNotResolveRoleDefinitionPrincipal { get; }
    public static string get_WinRMRestartWarning();
    public static string get_CouldNotResolveRoleDefinitionPrincipal();
}
internal class Microsoft.PowerShell.Commands.Internal.TransactedRegistry : object {
    internal static TransactedRegistryKey LocalMachine;
    internal static TransactedRegistryKey ClassesRoot;
    internal static TransactedRegistryKey Users;
    internal static TransactedRegistryKey CurrentConfig;
    internal static TransactedRegistryKey CurrentUser;
}
internal abstract class Microsoft.PowerShell.Commands.Internal.TransactedRegistryKey : object {
    public string Name { get; }
    public int SubKeyCount { get; }
    public sealed virtual void Dispose();
    public void SetValue(string name, object value);
    public void SetValue(string name, object value, RegistryValueKind valueKind);
    public String[] GetValueNames();
    public void DeleteValue(string name);
    public String[] GetSubKeyNames();
    public TransactedRegistryKey CreateSubKey(string subkey);
    public TransactedRegistryKey OpenSubKey(string name, bool writable);
    public void DeleteSubKeyTree(string subkey);
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue, RegistryValueOptions options);
    public RegistryValueKind GetValueKind(string name);
    public void Close();
    public abstract virtual string get_Name();
    public abstract virtual int get_SubKeyCount();
    public void SetAccessControl(ObjectSecurity securityDescriptor);
    public ObjectSecurity GetAccessControl(AccessControlSections includeSections);
}
internal class Microsoft.PowerShell.Commands.Internal.TransactedRegistrySecurity : ObjectSecurity {
    public Type AccessRightType { get; }
    public Type AccessRuleType { get; }
    public Type AuditRuleType { get; }
    public virtual Type get_AccessRightType();
    public virtual Type get_AccessRuleType();
    public virtual Type get_AuditRuleType();
    public virtual AccessRule AccessRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AccessControlType type);
    public virtual AuditRule AuditRuleFactory(IdentityReference identityReference, int accessMask, bool isInherited, InheritanceFlags inheritanceFlags, PropagationFlags propagationFlags, AuditFlags flags);
    protected virtual bool ModifyAccess(AccessControlModification modification, AccessRule rule, Boolean& modified);
    protected virtual bool ModifyAudit(AccessControlModification modification, AuditRule rule, Boolean& modified);
}
[SuppressUnmanagedCodeSecurityAttribute]
internal static class Microsoft.PowerShell.Commands.Internal.Win32Native : object {
    internal static int ERROR_INSUFFICIENT_BUFFER;
    private static bool LookupAccountSid(string lpSystemName, IntPtr sid, Char* lpName, Int32& cchName, Char* referencedDomainName, Int32& cchReferencedDomainName, SID_NAME_USE& peUse);
    internal static bool LookupAccountSid(string lpSystemName, IntPtr sid, Span`1<char> userName, Int32& cchName, Span`1<char> domainName, Int32& cchDomainName, SID_NAME_USE& peUse);
    internal static bool CloseHandle(IntPtr handle);
    internal static bool OpenProcessToken(IntPtr processHandle, UInt32 desiredAccess, IntPtr& tokenHandle);
    internal static bool GetTokenInformation(IntPtr tokenHandle, TOKEN_INFORMATION_CLASS tokenInformationClass, IntPtr tokenInformation, int tokenInformationLength, Int32& returnLength);
}
public static class Microsoft.PowerShell.Commands.InternalSymbolicLinkLinkCodeMethods : object {
    private static int FSCTL_GET_REPARSE_POINT;
    private static int FSCTL_SET_REPARSE_POINT;
    private static int FSCTL_DELETE_REPARSE_POINT;
    private static UInt32 IO_REPARSE_TAG_SYMLINK;
    private static UInt32 IO_REPARSE_TAG_MOUNT_POINT;
    private static UInt32 IO_REPARSE_TAG_APPEXECLINK;
    private static string NonInterpretedPathPrefix;
    [LibraryImportAttribute("api-ms-win-core-io-l1-1-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.9.8001")]
[SkipLocalsInitAttribute]
private static bool DeviceIoControl(IntPtr hDevice, UInt32 dwIoControlCode, IntPtr InBuffer, int nInBufferSize, IntPtr OutBuffer, int nOutBufferSize, Int32& pBytesReturned, IntPtr lpOverlapped);
    [LibraryImportAttribute("api-ms-win-core-file-l1-1-0.dll")]
[GeneratedCodeAttribute("Microsoft.Interop.LibraryImportGenerator", "8.0.9.8001")]
[SkipLocalsInitAttribute]
private static bool GetFileInformationByHandle(IntPtr hFile, BY_HANDLE_FILE_INFORMATION& lpFileInformation);
    [ObsoleteAttribute("This method is now obsolete. Please use the .NET API 'FileSystemInfo.LinkTarget'", "True")]
public static string GetTarget(PSObject instance);
    public static string ResolvedTarget(PSObject instance);
    public static string GetLinkType(PSObject instance);
    private static string InternalGetLinkType(FileSystemInfo fileInfo);
    private static string WinInternalGetLinkType(string filePath);
    internal static bool IsHardLink(FileSystemInfo fileInfo);
    internal static bool IsReparsePoint(FileSystemInfo fileInfo);
    internal static bool IsReparsePointLikeSymlink(FileSystemInfo fileInfo);
    internal static bool IsSameFileSystemItem(string pathOne, string pathTwo);
    private static bool WinIsSameFileSystemItem(string pathOne, string pathTwo);
    internal static bool GetInodeData(string path, ValueTuple`2& inodeData);
    private static bool WinGetInodeData(string path, ValueTuple`2& inodeData);
    internal static bool WinIsHardLink(IntPtr& handle);
    internal static bool CreateJunction(string path, string target);
    private static SafeFileHandle WinOpenReparsePoint(string reparsePoint, FileAccess accessMode);
    [CompilerGeneratedAttribute]
internal static int <DeviceIoControl>g____PInvoke|11_0(IntPtr __hDevice_native, UInt32 __dwIoControlCode_native, IntPtr __InBuffer_native, int __nInBufferSize_native, IntPtr __OutBuffer_native, int __nOutBufferSize_native, Int32* __pBytesReturned_native, IntPtr __lpOverlapped_native);
    [CompilerGeneratedAttribute]
internal static int <GetFileInformationByHandle>g____PInvoke|12_0(IntPtr __hFile_native, BY_HANDLE_FILE_INFORMATION* __lpFileInformation_native);
}
[CmdletAttribute("Invoke", "Command")]
public class Microsoft.PowerShell.Commands.InvokeCommandCommand : PSExecutionCmdlet {
    private bool _asjob;
    private bool _hideComputerName;
    private string _name;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoNewScope>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable[] <SSHConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <RemoteDebug>k__BackingField;
    private ThrottleManager _throttleManager;
    private ManualResetEvent _operationsComplete;
    private ManualResetEvent _disconnectComplete;
    private PSInvokeExpressionSyncJob _job;
    private SteppablePipeline _steppablePipeline;
    private bool _pipelineinvoked;
    private bool _inputStreamClosed;
    private static string InProcParameterSet;
    private PSDataCollection`1<object> _input;
    private bool _needToCollect;
    private bool _needToStartSteppablePipelineOnServer;
    private bool _clearInvokeCommandOnRunspace;
    private List`1<PipelineWriter> _inputWriters;
    private object _jobSyncObject;
    private bool _nojob;
    private Guid _instanceId;
    private bool _propagateErrors;
    private static RobustConnectionProgress s_RCProgress;
    internal static string RemoteJobType;
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Port { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter UseSSL { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string ApplicationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int ThrottleLimit { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri[] ConnectionUri { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter AsJob { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter InDisconnectedSession { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] SessionName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter HideComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string JobName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ScriptBlock ScriptBlock { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoNewScope { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string FilePath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter AllowRedirection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public PSSessionOption SessionOption { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter EnableNetworkAccess { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter RunAsAdministrator { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] HostName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string UserName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string KeyFilePath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string Subsystem { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public int ConnectingTimeout { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter SSHTransport { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable[] SSHConnection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable Options { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter RemoteDebug { get; public set; }
    private static InvokeCommandCommand();
    public virtual PSSession[] get_Session();
    public virtual void set_Session(PSSession[] value);
    public virtual String[] get_ComputerName();
    public virtual void set_ComputerName(String[] value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual int get_Port();
    public virtual void set_Port(int value);
    public virtual SwitchParameter get_UseSSL();
    public virtual void set_UseSSL(SwitchParameter value);
    public virtual string get_ConfigurationName();
    public virtual void set_ConfigurationName(string value);
    public virtual string get_ApplicationName();
    public virtual void set_ApplicationName(string value);
    public virtual int get_ThrottleLimit();
    public virtual void set_ThrottleLimit(int value);
    public virtual Uri[] get_ConnectionUri();
    public virtual void set_ConnectionUri(Uri[] value);
    public SwitchParameter get_AsJob();
    public void set_AsJob(SwitchParameter value);
    public SwitchParameter get_InDisconnectedSession();
    public void set_InDisconnectedSession(SwitchParameter value);
    public String[] get_SessionName();
    public void set_SessionName(String[] value);
    public SwitchParameter get_HideComputerName();
    public void set_HideComputerName(SwitchParameter value);
    public string get_JobName();
    public void set_JobName(string value);
    public virtual ScriptBlock get_ScriptBlock();
    public virtual void set_ScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoNewScope();
    [CompilerGeneratedAttribute]
public void set_NoNewScope(SwitchParameter value);
    public virtual string get_FilePath();
    public virtual void set_FilePath(string value);
    public virtual SwitchParameter get_AllowRedirection();
    public virtual void set_AllowRedirection(SwitchParameter value);
    public virtual PSSessionOption get_SessionOption();
    public virtual void set_SessionOption(PSSessionOption value);
    public virtual AuthenticationMechanism get_Authentication();
    public virtual void set_Authentication(AuthenticationMechanism value);
    public virtual SwitchParameter get_EnableNetworkAccess();
    public virtual void set_EnableNetworkAccess(SwitchParameter value);
    public virtual SwitchParameter get_RunAsAdministrator();
    public virtual void set_RunAsAdministrator(SwitchParameter value);
    public virtual String[] get_HostName();
    public virtual void set_HostName(String[] value);
    public virtual string get_UserName();
    public virtual void set_UserName(string value);
    public virtual string get_KeyFilePath();
    public virtual void set_KeyFilePath(string value);
    public virtual string get_Subsystem();
    public virtual void set_Subsystem(string value);
    public virtual int get_ConnectingTimeout();
    public virtual void set_ConnectingTimeout(int value);
    public virtual SwitchParameter get_SSHTransport();
    public virtual void set_SSHTransport(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual Hashtable[] get_SSHConnection();
    [CompilerGeneratedAttribute]
public virtual void set_SSHConnection(Hashtable[] value);
    public virtual Hashtable get_Options();
    public virtual void set_Options(Hashtable value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_RemoteDebug();
    [CompilerGeneratedAttribute]
public virtual void set_RemoteDebug(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private Debugger GetHostDebugger();
    private void HandleThrottleComplete(object sender, EventArgs eventArgs);
    private void ClearInvokeCommandOnRunspaces();
    private void CreateAndRunSyncJob();
    private void HandleRunspaceDebugStop(object sender, StartRunspaceDebugProcessingEventArgs args);
    private void HandleJobStateChanged(object sender, JobStateEventArgs e);
    private void AddConnectionRetryHandler(PSInvokeExpressionSyncJob job);
    private void RemoveConnectionRetryHandler(PSInvokeExpressionSyncJob job);
    private void RCConnectionNotificationHandler(object sender, PSConnectionRetryStatusEventArgs e);
    private void WaitForDisconnectAndDisposeJob();
    private List`1<PSSession> GetDisconnectedSessions(PSInvokeExpressionSyncJob job);
    private void WriteInput(object inputValue);
    private void WriteJobResults(bool nonblocking);
    private void WriteNetworkFailedError(PSSession session);
    private PSSession GetPSSession(Guid runspaceId);
    private void HandlePipelinesStopped();
    private void StartProgressBar(long sourceId, string computerName, int totalSeconds);
    private static void StopProgressBar(long sourceId);
    private void WriteStreamObjectsFromCollection(IEnumerable`1<PSStreamObject> results);
    private void DetermineThrowStatementBehavior();
    private static void PreProcessStreamObject(PSStreamObject streamObject);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[CmdletAttribute("Invoke", "History")]
public class Microsoft.PowerShell.Commands.InvokeHistoryCommand : PSCmdlet {
    private bool _multipleIdProvided;
    private string _id;
    private long _historyId;
    private string _commandLine;
    [ParameterAttribute]
public string Id { get; public set; }
    public string get_Id();
    public void set_Id(string value);
    protected virtual void EndProcessing();
    private HistoryInfo GetHistoryEntryToInvoke(History history);
    private void PopulateIdAndCommandLine();
    private static void ReplaceHistoryString(HistoryInfo entry, LocalRunspace localRunspace);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_0(object sender, DataAddedEventArgs e);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_1(object sender, DataAddedEventArgs e);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_2(object sender, DataAddedEventArgs e);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_3(object sender, DataAddedEventArgs e);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_4(object sender, DataAddedEventArgs e);
    [CompilerGeneratedAttribute]
private void <EndProcessing>b__5_5(object sender, DataAddedEventArgs e);
}
[NullableContextAttribute("1")]
internal interface Microsoft.PowerShell.Commands.IRegistryWrapper {
    public object RegistryKey { get; }
    public string Name { get; }
    public int SubKeyCount { get; }
    public abstract virtual void SetValue(string name, object value);
    public abstract virtual void SetValue(string name, object value, RegistryValueKind valueKind);
    public abstract virtual String[] GetValueNames();
    public abstract virtual void DeleteValue(string name);
    public abstract virtual String[] GetSubKeyNames();
    public abstract virtual IRegistryWrapper CreateSubKey(string subkey);
    public abstract virtual IRegistryWrapper OpenSubKey(string name, bool writable);
    public abstract virtual void DeleteSubKeyTree(string subkey);
    [NullableContextAttribute("2")]
public abstract virtual object GetValue(string name);
    [NullableContextAttribute("2")]
public abstract virtual object GetValue(string name, object defaultValue, RegistryValueOptions options);
    [NullableContextAttribute("2")]
public abstract virtual RegistryValueKind GetValueKind(string name);
    public abstract virtual object get_RegistryKey();
    public abstract virtual void SetAccessControl(ObjectSecurity securityDescriptor);
    public abstract virtual ObjectSecurity GetAccessControl(AccessControlSections includeSections);
    public abstract virtual void Close();
    public abstract virtual string get_Name();
    public abstract virtual int get_SubKeyCount();
}
public class Microsoft.PowerShell.Commands.JobCmdletBase : PSRemotingCmdlet {
    internal static string JobParameterSet;
    internal static string InstanceIdParameterSet;
    internal static string SessionIdParameterSet;
    internal static string NameParameterSet;
    internal static string StateParameterSet;
    internal static string CommandParameterSet;
    internal static string FilterParameterSet;
    internal static string JobParameter;
    internal static string InstanceIdParameter;
    internal static string SessionIdParameter;
    internal static string NameParameter;
    internal static string StateParameter;
    internal static string CommandParameter;
    internal static string FilterParameter;
    private String[] _names;
    private Guid[] _instanceIds;
    private Int32[] _sessionIds;
    private JobState _jobstate;
    private String[] _commands;
    private Hashtable _filter;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Guid[] InstanceId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
public JobState State { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Command { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable Filter { get; public set; }
    internal List`1<Job> FindJobsMatchingByName(bool recurse, bool writeobject, bool writeErrorOnNoMatch, bool checkIfJobCanBeRemoved);
    private bool CheckIfJob2CanBeRemoved(bool checkForRemove, string parameterName, Job2 job2, string resourceString, Object[] args);
    private bool FindJobsMatchingByNameHelper(List`1<Job> matches, IList`1<Job> jobsToSearch, string name, Hashtable duplicateDetector, bool recurse, bool writeobject, bool checkIfJobCanBeRemoved);
    internal List`1<Job> FindJobsMatchingByInstanceId(bool recurse, bool writeobject, bool writeErrorOnNoMatch, bool checkIfJobCanBeRemoved);
    private bool FindJobsMatchingByInstanceIdHelper(List`1<Job> matches, IList`1<Job> jobsToSearch, Guid instanceId, Hashtable duplicateDetector, bool recurse, bool writeobject, bool checkIfJobCanBeRemoved);
    internal List`1<Job> FindJobsMatchingBySessionId(bool recurse, bool writeobject, bool writeErrorOnNoMatch, bool checkIfJobCanBeRemoved);
    private bool FindJobsMatchingBySessionIdHelper(List`1<Job> matches, IList`1<Job> jobsToSearch, int sessionId, Hashtable duplicateDetector, bool recurse, bool writeobject, bool checkIfJobCanBeRemoved);
    internal List`1<Job> FindJobsMatchingByCommand(bool writeobject);
    internal List`1<Job> FindJobsMatchingByState(bool writeobject);
    internal List`1<Job> FindJobsMatchingByFilter(bool writeobject);
    private static bool FindJobsMatchingByFilterHelper(List`1<Job> matches, List`1<Job> jobsToSearch);
    internal List`1<Job> CopyJobsToList(Job[] jobs, bool writeobject, bool checkIfJobCanBeRemoved);
    private bool CheckJobCanBeRemoved(Job job, string parameterName, string resourceString, Object[] list);
    public String[] get_Name();
    public void set_Name(String[] value);
    public Guid[] get_InstanceId();
    public void set_InstanceId(Guid[] value);
    public virtual Int32[] get_Id();
    public virtual void set_Id(Int32[] value);
    public virtual JobState get_State();
    public virtual void set_State(JobState value);
    public virtual String[] get_Command();
    public virtual void set_Command(String[] value);
    public virtual Hashtable get_Filter();
    public virtual void set_Filter(Hashtable value);
    protected virtual void BeginProcessing();
}
public class Microsoft.PowerShell.Commands.ModuleCmdletBase : PSCmdlet {
    [CompilerGeneratedAttribute]
private string <BasePrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseForce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseGlobal>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseSkipEditionCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BasePassThru>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseAsCustomObject>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WildcardPattern> <BaseFunctionPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WildcardPattern> <BaseCmdletPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WildcardPattern> <BaseVariablePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WildcardPattern> <BaseAliasPatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <BaseMinimumVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <BaseMaximumVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <BaseRequiredVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <BaseGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <BaseArgumentList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <BaseDisableNameChecking>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddToAppDomainLevelCache>k__BackingField;
    private List`1<WildcardPattern> _matchAll;
    internal static String[] PermittedCmdlets;
    internal static String[] ModuleManifestMembers;
    private static String[] s_moduleVersionMembers;
    protected static HashSet`1<string> BuiltInModules;
    [CompilerGeneratedAttribute]
private static IReadOnlyList`1<string> <DefaultCompatiblePSEditions>k__BackingField;
    internal static int s_WindowsPowerShellCompatUsageCounter;
    internal static string WindowsPowerShellCompatRemotingSessionName;
    internal static object s_WindowsPowerShellCompatSyncObject;
    private Dictionary`2<string, PSModuleInfo> _currentlyProcessingModules;
    private static String[] s_extraAllowedVariables;
    internal static EventHandler`1<LocationChangedEventArgs> SyncCurrentLocationDelegate;
    private static object s_lockObject;
    private static Dictionary`2<string, Tuple`2<BinaryAnalysisResult, Version>> s_binaryAnalysisCache;
    private static Dictionary`2<string, PSModuleInfo> s_scriptAnalysisCache;
    internal string BasePrefix { get; internal set; }
    internal bool BaseForce { get; internal set; }
    internal bool BaseGlobal { get; internal set; }
    internal bool BaseSkipEditionCheck { get; internal set; }
    internal SessionState TargetSessionState { get; }
    internal bool BasePassThru { get; internal set; }
    internal bool BaseAsCustomObject { get; internal set; }
    internal List`1<WildcardPattern> BaseFunctionPatterns { get; internal set; }
    internal List`1<WildcardPattern> BaseCmdletPatterns { get; internal set; }
    internal List`1<WildcardPattern> BaseVariablePatterns { get; internal set; }
    internal List`1<WildcardPattern> BaseAliasPatterns { get; internal set; }
    internal Version BaseMinimumVersion { get; internal set; }
    internal Version BaseMaximumVersion { get; internal set; }
    internal Version BaseRequiredVersion { get; internal set; }
    internal Nullable`1<Guid> BaseGuid { get; internal set; }
    protected Object[] BaseArgumentList { get; protected set; }
    protected bool BaseDisableNameChecking { get; protected set; }
    protected bool AddToAppDomainLevelCache { get; protected set; }
    internal List`1<WildcardPattern> MatchAll { get; }
    internal static IReadOnlyList`1<string> DefaultCompatiblePSEditions { get; }
    private static ModuleCmdletBase();
    [CompilerGeneratedAttribute]
internal string get_BasePrefix();
    [CompilerGeneratedAttribute]
internal void set_BasePrefix(string value);
    [CompilerGeneratedAttribute]
internal bool get_BaseForce();
    [CompilerGeneratedAttribute]
internal void set_BaseForce(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BaseGlobal();
    [CompilerGeneratedAttribute]
internal void set_BaseGlobal(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BaseSkipEditionCheck();
    [CompilerGeneratedAttribute]
internal void set_BaseSkipEditionCheck(bool value);
    internal SessionState get_TargetSessionState();
    [CompilerGeneratedAttribute]
internal bool get_BasePassThru();
    [CompilerGeneratedAttribute]
internal void set_BasePassThru(bool value);
    [CompilerGeneratedAttribute]
internal bool get_BaseAsCustomObject();
    [CompilerGeneratedAttribute]
internal void set_BaseAsCustomObject(bool value);
    [CompilerGeneratedAttribute]
internal List`1<WildcardPattern> get_BaseFunctionPatterns();
    [CompilerGeneratedAttribute]
internal void set_BaseFunctionPatterns(List`1<WildcardPattern> value);
    [CompilerGeneratedAttribute]
internal List`1<WildcardPattern> get_BaseCmdletPatterns();
    [CompilerGeneratedAttribute]
internal void set_BaseCmdletPatterns(List`1<WildcardPattern> value);
    [CompilerGeneratedAttribute]
internal List`1<WildcardPattern> get_BaseVariablePatterns();
    [CompilerGeneratedAttribute]
internal void set_BaseVariablePatterns(List`1<WildcardPattern> value);
    [CompilerGeneratedAttribute]
internal List`1<WildcardPattern> get_BaseAliasPatterns();
    [CompilerGeneratedAttribute]
internal void set_BaseAliasPatterns(List`1<WildcardPattern> value);
    [CompilerGeneratedAttribute]
internal Version get_BaseMinimumVersion();
    [CompilerGeneratedAttribute]
internal void set_BaseMinimumVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_BaseMaximumVersion();
    [CompilerGeneratedAttribute]
internal void set_BaseMaximumVersion(Version value);
    [CompilerGeneratedAttribute]
internal Version get_BaseRequiredVersion();
    [CompilerGeneratedAttribute]
internal void set_BaseRequiredVersion(Version value);
    [CompilerGeneratedAttribute]
internal Nullable`1<Guid> get_BaseGuid();
    [CompilerGeneratedAttribute]
internal void set_BaseGuid(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
protected Object[] get_BaseArgumentList();
    [CompilerGeneratedAttribute]
protected void set_BaseArgumentList(Object[] value);
    [CompilerGeneratedAttribute]
protected bool get_BaseDisableNameChecking();
    [CompilerGeneratedAttribute]
protected void set_BaseDisableNameChecking(bool value);
    [CompilerGeneratedAttribute]
protected bool get_AddToAppDomainLevelCache();
    [CompilerGeneratedAttribute]
protected void set_AddToAppDomainLevelCache(bool value);
    internal List`1<WildcardPattern> get_MatchAll();
    [CompilerGeneratedAttribute]
internal static IReadOnlyList`1<string> get_DefaultCompatiblePSEditions();
    internal bool LoadUsingModulePath(IEnumerable`1<string> modulePath, string name, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, PSModuleInfo& module);
    internal bool LoadUsingModulePath(PSModuleInfo parentModule, IEnumerable`1<string> modulePath, string name, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, PSModuleInfo& module);
    internal PSModuleInfo LoadUsingMultiVersionModuleBase(string moduleBase, ManifestProcessingFlags manifestProcessingFlags, ImportModuleOptions importModuleOptions, Boolean& found);
    private Hashtable LoadModuleManifestData(ExternalScriptInfo scriptInfo, String[] validMembers, ManifestProcessingFlags manifestProcessingFlags, Boolean& containedErrors);
    internal Hashtable LoadModuleManifestData(string moduleManifestPath, ScriptBlock scriptBlock, String[] validMembers, ManifestProcessingFlags manifestProcessingFlags, Boolean& containedErrors);
    private bool ValidateManifestHash(Hashtable data, String[] validMembers, string moduleManifestPath, ManifestProcessingFlags manifestProcessingFlags);
    private PSModuleInfo LoadModuleNamedInManifest(PSModuleInfo parentModule, ModuleSpecification moduleSpecification, string moduleBase, bool searchModulePath, string prefix, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, object privateData, Boolean& found, string shortModuleName, Nullable`1<PSLanguageMode> manifestLanguageMode);
    internal List`1<PSModuleInfo> GetModule(String[] names, bool all, bool refresh);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.ModuleCmdletBase/<GetModuleForRootedPaths>d__95")]
private IEnumerable`1<PSModuleInfo> GetModuleForRootedPaths(List`1<string> modulePaths, bool all, bool refresh);
    private static ErrorRecord CreateModuleNotFoundError(string modulePath);
    private IEnumerable`1<PSModuleInfo> GetModuleForNames(List`1<string> names, bool all, bool refresh);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.ModuleCmdletBase/<GetModulesFromOneModulePath>d__98")]
private IEnumerable`1<PSModuleInfo> GetModulesFromOneModulePath(List`1<string> names, string modulePath, bool all, bool refresh);
    internal static Version GetMaximumVersion(string stringVersion);
    private PSModuleInfo CreateModuleInfoForGetModule(string file, bool refresh);
    internal PSModuleInfo LoadModuleManifest(ExternalScriptInfo scriptInfo, ManifestProcessingFlags manifestProcessingFlags, Version minimumVersion, Version maximumVersion, Version requiredVersion, Nullable`1<Guid> requiredModuleGuid);
    internal PSModuleInfo LoadModuleManifest(ExternalScriptInfo scriptInfo, ManifestProcessingFlags manifestProcessingFlags, Version minimumVersion, Version maximumVersion, Version requiredVersion, Nullable`1<Guid> requiredModuleGuid, ImportModuleOptions& options);
    internal bool LoadModuleManifestData(ExternalScriptInfo scriptInfo, ManifestProcessingFlags manifestProcessingFlags, Hashtable& data, Hashtable& localizedData, Boolean& containedErrors);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.ModuleCmdletBase/<CreateFakeModuleObject>d__104")]
private IEnumerable`1<PSModuleInfo> CreateFakeModuleObject(IEnumerable`1<ModuleSpecification> moduleSpecs);
    private static ErrorRecord GetErrorRecordIfUnsupportedRootCdxmlAndNestedModuleScenario(Hashtable data, string moduleManifestPath, string rootModulePath);
    internal PSModuleInfo LoadModuleManifest(string moduleManifestPath, ExternalScriptInfo manifestScriptInfo, Hashtable data, Hashtable localizedData, ManifestProcessingFlags manifestProcessingFlags, Version minimumVersion, Version maximumVersion, Version requiredVersion, Nullable`1<Guid> requiredModuleGuid, ImportModuleOptions& options, Boolean& containedErrors);
    private static void PropagateExportedTypesFromNestedModulesToRootModuleScope(ImportModuleOptions options, PSModuleInfo manifestInfo);
    private static void SetDeclaredDscResources(List`1<WildcardPattern> exportedDscResources, PSModuleInfo manifestInfo);
    private static void UpdateCommandCollection(List`1<T> list, List`1<WildcardPattern> patterns);
    private static void UpdateCommandCollection(Collection`1<string> list, List`1<WildcardPattern> patterns);
    private static void WriteInvalidManifestMemberError(PSCmdlet cmdlet, string manifestElement, string moduleManifestPath, Exception e, ManifestProcessingFlags manifestProcessingFlags);
    private static ErrorRecord GenerateInvalidModuleMemberErrorRecord(string manifestElement, string moduleManifestPath, Exception e);
    internal static object IsModuleLoaded(ExecutionContext context, ModuleSpecification requiredModule, ModuleMatchFailure& matchFailureReason, Boolean& loaded);
    internal PSModuleInfo LoadRequiredModule(PSModuleInfo currentModule, ModuleSpecification requiredModule, string moduleManifestPath, ManifestProcessingFlags manifestProcessingFlags, bool containedErrors, ErrorRecord& error);
    internal static PSModuleInfo LoadRequiredModule(ExecutionContext context, PSModuleInfo currentModule, ModuleSpecification requiredModuleSpecification, string moduleManifestPath, ManifestProcessingFlags manifestProcessingFlags, ErrorRecord& error);
    private static PSModuleInfo ImportRequiredModule(ExecutionContext context, ModuleSpecification requiredModule, ErrorRecord& error);
    internal bool VerifyIfNestedModuleIsAvailable(ModuleSpecification nestedModuleSpec, string rootedModulePath, string extension, PSModuleInfo& nestedModuleInfoIfAvailable);
    internal static Collection`1<PSModuleInfo> GetModuleIfAvailable(ModuleSpecification requiredModule, Runspace rsToUse);
    private static bool HasRequiredModulesCyclicReference(ModuleSpecification currentModuleSpecification, List`1<ModuleSpecification> requiredModules, IEnumerable`1<PSModuleInfo> moduleInfoList, Dictionary`2<ModuleSpecification, List`1<ModuleSpecification>> nonCyclicRequiredModules, ErrorRecord& error);
    private static ExternalScriptInfo FindLocalizedModuleManifest(string path);
    internal bool GetListOfStringsFromData(Hashtable data, string moduleManifestPath, string key, ManifestProcessingFlags manifestProcessingFlags, List`1& list);
    private bool GetListOfWildcardsFromData(Hashtable data, string moduleManifestPath, string key, ManifestProcessingFlags manifestProcessingFlags, List`1& list);
    private bool GetListOfFilesFromData(Hashtable data, string moduleManifestPath, string key, ManifestProcessingFlags manifestProcessingFlags, string moduleBase, string extension, bool verifyFilesExist, List`1& list);
    internal void SetModuleLoggingInformation(PSModuleInfo m);
    private static void SetModuleLoggingInformation(ModuleLoggingGroupPolicyStatus status, PSModuleInfo m, IEnumerable`1<string> moduleNames);
    internal static ModuleLoggingGroupPolicyStatus GetModuleLoggingInformation(IEnumerable`1& moduleNames);
    internal bool GetScalarFromData(Hashtable data, string moduleManifestPath, string key, ManifestProcessingFlags manifestProcessingFlags, T& result);
    private string FixFileNameWithoutLoadingAssembly(string moduleBase, string fileName, string extension);
    private string FixFileNameWithoutLoadingAssembly(string moduleBase, string fileName, string extension, Boolean& pathIsResolved);
    private string FixFileName(string moduleName, string moduleBase, string fileName, string extension, bool canLoadAssembly);
    private string FixFileName(string moduleName, string moduleBase, string fileName, string extension, bool canLoadAssembly, Boolean& pathIsResolved);
    internal string GetAbsolutePath(string moduleBase, string path);
    internal static bool IsRooted(string filePath);
    internal static string ResolveRootedFilePath(string filePath, ExecutionContext context);
    internal static string GetResolvedPath(string filePath, ExecutionContext context);
    internal static Collection`1<string> GetResolvedPathCollection(string filePath, ExecutionContext context);
    internal static PSSession GetWindowsPowerShellCompatRemotingSession();
    internal static PSSession CreateWindowsPowerShellCompatResources();
    internal static void CleanupWindowsPowerShellCompatResources(SessionState sessionState);
    internal static void SyncCurrentLocationHandler(object sender, LocationChangedEventArgs args);
    internal virtual IList`1<PSModuleInfo> ImportModulesUsingWinCompat(IEnumerable`1<string> moduleNames, IEnumerable`1<ModuleSpecification> moduleFullyQualifiedNames, ImportModuleOptions importModuleOptions);
    private void RemoveTypesAndFormatting(IList`1<string> formatFilesToRemove, IList`1<string> typeFilesToRemove);
    internal void RemoveModule(PSModuleInfo module);
    internal void RemoveModule(PSModuleInfo module, string moduleNameInRemoveModuleCmdlet);
    private bool ShouldModuleBeRemoved(PSModuleInfo module, string moduleNameInRemoveModuleCmdlet, Boolean& isTopLevelModule);
    internal bool DoesAlreadyLoadedModuleSatisfyConstraints(PSModuleInfo alreadyLoadedModule);
    internal PSModuleInfo IsModuleImportUnnecessaryBecauseModuleIsAlreadyLoaded(string modulePath, string prefix, ImportModuleOptions options);
    internal PSModuleInfo LoadUsingExtensions(PSModuleInfo parentModule, string moduleName, string fileBaseName, string extension, string moduleBase, string prefix, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found);
    internal PSModuleInfo LoadUsingExtensions(PSModuleInfo parentModule, string moduleName, string fileBaseName, string extension, string moduleBase, string prefix, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found, Boolean& moduleFileFound);
    internal string GetDefaultPrefix(PSModuleInfo module);
    internal ExternalScriptInfo GetScriptInfoForFile(string fileName, String& scriptName, bool checkExecutionPolicy);
    internal PSModuleInfo LoadModule(string fileName, string moduleBase, string prefix, SessionState ss, ImportModuleOptions& options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found);
    internal PSModuleInfo LoadModule(PSModuleInfo parentModule, string fileName, string moduleBase, string prefix, SessionState ss, object privateData, ImportModuleOptions& options, ManifestProcessingFlags manifestProcessingFlags, Boolean& found, Boolean& moduleFileFound);
    private void CheckForDisallowedDotSourcing(PSModuleInfo moduleInfo, ExternalScriptInfo scriptInfo, ImportModuleOptions options);
    private static void RemoveNestedModuleFunctions(ExecutionContext context, PSModuleInfo module, SystemEnforcementMode systemLockdownPolicy);
    private static bool ShouldProcessScriptModule(PSModuleInfo parentModule, Boolean& found);
    private static void ClearAnalysisCaches();
    private static BinaryAnalysisResult GetCmdletsFromBinaryModuleImplementation(string path, ManifestProcessingFlags manifestProcessingFlags, Version& assemblyVersion);
    private PSModuleInfo AnalyzeScriptFile(string filename, bool force, ExecutionContext context);
    internal PSModuleInfo LoadBinaryModule(PSModuleInfo parentModule, string moduleName, string fileName, Assembly assemblyToLoad, string moduleBase, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, string prefix, Boolean& found);
    internal PSModuleInfo LoadBinaryModule(PSModuleInfo parentModule, string moduleName, string fileName, Assembly assemblyToLoad, string moduleBase, SessionState ss, ImportModuleOptions options, ManifestProcessingFlags manifestProcessingFlags, string prefix, Boolean& found, string shortModuleName, bool disableFormatUpdates);
    private static Version GetAssemblyVersionNumber(Assembly assemblyToLoad);
    internal static string AddPrefixToCommandName(string commandName, string prefix);
    internal static string RemovePrefixFromCommandName(string commandName, string prefix);
    internal static bool IsPrefixedCommand(CommandInfo commandInfo);
    internal static void AddModuleToModuleTables(ExecutionContext context, SessionStateInternal targetSessionState, PSModuleInfo module);
    protected internal void ImportModuleMembers(PSModuleInfo sourceModule, string prefix);
    protected internal void ImportModuleMembers(PSModuleInfo sourceModule, string prefix, ImportModuleOptions options);
    internal static void ImportModuleMembers(ModuleCmdletBase cmdlet, SessionStateInternal targetSessionState, PSModuleInfo sourceModule, string prefix, List`1<WildcardPattern> functionPatterns, List`1<WildcardPattern> cmdletPatterns, List`1<WildcardPattern> variablePatterns, List`1<WildcardPattern> aliasPatterns, ImportModuleOptions options);
    private static void ImportFunctions(FunctionInfo func, SessionStateInternal targetSessionState, PSModuleInfo sourceModule, List`1<WildcardPattern> functionPatterns, bool noPatternsSpecified, string prefix, ImportModuleOptions options, bool usePrefix, Boolean& checkVerb, Boolean& checkNoun, Dictionary`2<string, string> original2prefixedName, ModuleCmdletBase cmdlet, bool isImportModulePrivate, bool isFunction);
    private static void SetCommandVisibility(bool isImportModulePrivate, CommandInfo command);
    internal static bool CommandFound(string commandName, SessionStateInternal sessionStateInternal);
    private static bool HasInvalidCharacters(string commandName);
    private static void ValidateCommandName(ModuleCmdletBase cmdlet, string commandName, string moduleName, Boolean& checkVerb, Boolean& checkNoun);
    internal bool TryGetFromModuleTable(string key, PSModuleInfo& moduleInfo, bool toRemove);
}
public class Microsoft.PowerShell.Commands.ModuleSpecification : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<Guid> <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MaximumVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <RequiredVersion>k__BackingField;
    public string Name { get; internal set; }
    public Nullable`1<Guid> Guid { get; internal set; }
    public Version Version { get; internal set; }
    public string MaximumVersion { get; internal set; }
    public Version RequiredVersion { get; internal set; }
    public ModuleSpecification(string moduleName);
    public ModuleSpecification(Hashtable moduleSpecification);
    internal ModuleSpecification(PSModuleInfo moduleInfo);
    internal static Exception ModuleSpecificationInitHelper(ModuleSpecification moduleSpecification, Hashtable hashtable);
    public virtual string ToString();
    public static bool TryParse(string input, ModuleSpecification& result);
    internal ModuleSpecification WithNormalizedName(ExecutionContext context, string basePath);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<Guid> get_Guid();
    [CompilerGeneratedAttribute]
internal void set_Guid(Nullable`1<Guid> value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(Version value);
    [CompilerGeneratedAttribute]
public string get_MaximumVersion();
    [CompilerGeneratedAttribute]
internal void set_MaximumVersion(string value);
    [CompilerGeneratedAttribute]
public Version get_RequiredVersion();
    [CompilerGeneratedAttribute]
internal void set_RequiredVersion(Version value);
}
internal class Microsoft.PowerShell.Commands.ModuleSpecificationComparer : object {
    public sealed virtual bool Equals(ModuleSpecification x, ModuleSpecification y);
    public sealed virtual int GetHashCode(ModuleSpecification obj);
}
[CmdletAttribute("New", "Module")]
[OutputTypeAttribute("System.Management.Automation.PSModuleInfo")]
public class Microsoft.PowerShell.Commands.NewModuleCommand : ModuleCmdletBase {
    private string _name;
    private ScriptBlock _scriptBlock;
    private String[] _functionImportList;
    private String[] _cmdletImportList;
    private bool _returnResult;
    private bool _asCustomObject;
    private Object[] _arguments;
    [ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public ScriptBlock ScriptBlock { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Function { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public String[] Cmdlet { get; public set; }
    [ParameterAttribute]
public SwitchParameter ReturnResult { get; public set; }
    [ParameterAttribute]
public SwitchParameter AsCustomObject { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    public string get_Name();
    public void set_Name(string value);
    public ScriptBlock get_ScriptBlock();
    public void set_ScriptBlock(ScriptBlock value);
    public String[] get_Function();
    public void set_Function(String[] value);
    public String[] get_Cmdlet();
    public void set_Cmdlet(String[] value);
    public SwitchParameter get_ReturnResult();
    public void set_ReturnResult(SwitchParameter value);
    public SwitchParameter get_AsCustomObject();
    public void set_AsCustomObject(SwitchParameter value);
    public Object[] get_ArgumentList();
    public void set_ArgumentList(Object[] value);
    protected virtual void EndProcessing();
}
[CmdletAttribute("New", "ModuleManifest")]
[OutputTypeAttribute("System.String")]
public class Microsoft.PowerShell.Commands.NewModuleManifestCommand : PSCmdlet {
    private string _path;
    private Object[] _nestedModules;
    private Guid _guid;
    private string _author;
    private string _companyName;
    private string _copyright;
    private string _rootModule;
    private Version _moduleVersion;
    private string _description;
    private Nullable`1<ProcessorArchitecture> _processorArchitecture;
    private Version _powerShellVersion;
    private Version _ClrVersion;
    private Version _DotNetFrameworkVersion;
    private string _PowerShellHostName;
    private Version _PowerShellHostVersion;
    private Object[] _requiredModules;
    private String[] _types;
    private String[] _formats;
    private String[] _scripts;
    private String[] _requiredAssemblies;
    private String[] _miscFiles;
    private Object[] _moduleList;
    private String[] _exportedFunctions;
    private String[] _exportedAliases;
    private String[] _exportedVariables;
    private String[] _exportedCmdlets;
    private String[] _dscResourcesToExport;
    private String[] _compatiblePSEditions;
    private object _privateData;
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <ProjectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prerelease>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ExternalModuleDependencies>k__BackingField;
    private string _helpInfoUri;
    private bool _passThru;
    private string _defaultCommandPrefix;
    private string _indent;
    [ParameterAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public Object[] NestedModules { get; public set; }
    [ParameterAttribute]
public Guid Guid { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
public string Author { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
public string CompanyName { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
public string Copyright { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string RootModule { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Version ModuleVersion { get; public set; }
    [ParameterAttribute]
[AllowEmptyStringAttribute]
public string Description { get; public set; }
    [ParameterAttribute]
public ProcessorArchitecture ProcessorArchitecture { get; public set; }
    [ParameterAttribute]
public Version PowerShellVersion { get; public set; }
    [ParameterAttribute]
public Version ClrVersion { get; public set; }
    [ParameterAttribute]
public Version DotNetFrameworkVersion { get; public set; }
    [ParameterAttribute]
public string PowerShellHostName { get; public set; }
    [ParameterAttribute]
public Version PowerShellHostVersion { get; public set; }
    [ParameterAttribute]
[ArgumentTypeConverterAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] RequiredModules { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] TypesToProcess { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] FormatsToProcess { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] ScriptsToProcess { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] RequiredAssemblies { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] FileList { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
[ArgumentTypeConverterAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ModuleList { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] FunctionsToExport { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] AliasesToExport { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] VariablesToExport { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] CmdletsToExport { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
public String[] DscResourcesToExport { get; public set; }
    [ParameterAttribute]
[AllowEmptyCollectionAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] CompatiblePSEditions { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public object PrivateData { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Tags { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Uri ProjectUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Uri LicenseUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Uri IconUri { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string ReleaseNotes { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Prerelease { get; public set; }
    [ParameterAttribute]
public SwitchParameter RequireLicenseAcceptance { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ExternalModuleDependencies { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public string HelpInfoUri { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public string DefaultCommandPrefix { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public Object[] get_NestedModules();
    public void set_NestedModules(Object[] value);
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_Author();
    public void set_Author(string value);
    public string get_CompanyName();
    public void set_CompanyName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public string get_RootModule();
    public void set_RootModule(string value);
    public Version get_ModuleVersion();
    public void set_ModuleVersion(Version value);
    public string get_Description();
    public void set_Description(string value);
    public ProcessorArchitecture get_ProcessorArchitecture();
    public void set_ProcessorArchitecture(ProcessorArchitecture value);
    public Version get_PowerShellVersion();
    public void set_PowerShellVersion(Version value);
    public Version get_ClrVersion();
    public void set_ClrVersion(Version value);
    public Version get_DotNetFrameworkVersion();
    public void set_DotNetFrameworkVersion(Version value);
    public string get_PowerShellHostName();
    public void set_PowerShellHostName(string value);
    public Version get_PowerShellHostVersion();
    public void set_PowerShellHostVersion(Version value);
    public Object[] get_RequiredModules();
    public void set_RequiredModules(Object[] value);
    public String[] get_TypesToProcess();
    public void set_TypesToProcess(String[] value);
    public String[] get_FormatsToProcess();
    public void set_FormatsToProcess(String[] value);
    public String[] get_ScriptsToProcess();
    public void set_ScriptsToProcess(String[] value);
    public String[] get_RequiredAssemblies();
    public void set_RequiredAssemblies(String[] value);
    public String[] get_FileList();
    public void set_FileList(String[] value);
    public Object[] get_ModuleList();
    public void set_ModuleList(Object[] value);
    public String[] get_FunctionsToExport();
    public void set_FunctionsToExport(String[] value);
    public String[] get_AliasesToExport();
    public void set_AliasesToExport(String[] value);
    public String[] get_VariablesToExport();
    public void set_VariablesToExport(String[] value);
    public String[] get_CmdletsToExport();
    public void set_CmdletsToExport(String[] value);
    public String[] get_DscResourcesToExport();
    public void set_DscResourcesToExport(String[] value);
    public String[] get_CompatiblePSEditions();
    public void set_CompatiblePSEditions(String[] value);
    public object get_PrivateData();
    public void set_PrivateData(object value);
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public Uri get_ProjectUri();
    [CompilerGeneratedAttribute]
public void set_ProjectUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_LicenseUri();
    [CompilerGeneratedAttribute]
public void set_LicenseUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_IconUri();
    [CompilerGeneratedAttribute]
public void set_IconUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public string get_Prerelease();
    [CompilerGeneratedAttribute]
public void set_Prerelease(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(SwitchParameter value);
    [CompilerGeneratedAttribute]
public String[] get_ExternalModuleDependencies();
    [CompilerGeneratedAttribute]
public void set_ExternalModuleDependencies(String[] value);
    public string get_HelpInfoUri();
    public void set_HelpInfoUri(string value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public string get_DefaultCommandPrefix();
    public void set_DefaultCommandPrefix(string value);
    private static string QuoteName(string name);
    private static string QuoteName(Uri name);
    private static string QuoteName(Version name);
    private static string QuoteNames(IEnumerable names, StreamWriter streamWriter);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.NewModuleManifestCommand/<PreProcessModuleSpec>d__165")]
private static IEnumerable PreProcessModuleSpec(IEnumerable moduleSpecs);
    private static string QuoteModules(IEnumerable moduleSpecs, StreamWriter streamWriter);
    private string QuoteFiles(IEnumerable names, StreamWriter streamWriter);
    private List`1<string> TryResolveFilePath(string filePath);
    private string ManifestFragment(string key, string resourceString, string value, StreamWriter streamWriter);
    private string ManifestFragmentForNonSpecifiedManifestMember(string key, string resourceString, string value, StreamWriter streamWriter);
    private static string ManifestComment(string insert, StreamWriter streamWriter);
    protected virtual void EndProcessing();
    private void BuildModuleManifest(StringBuilder result, string key, string keyDescription, bool hasValue, Func`1<string> action, StreamWriter streamWriter);
    private void BuildPrivateDataInModuleManifest(StringBuilder result, StreamWriter streamWriter);
    private void ValidateUriParameterValue(Uri uri, string parameterName);
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_0();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_1();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_3();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_4();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_5();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_6();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_7();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_8();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_9();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_10();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_11();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_12();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_13();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_27();
    [CompilerGeneratedAttribute]
private string <EndProcessing>b__172_28();
}
[CmdletAttribute("New", "PSRoleCapabilityFile")]
public class Microsoft.PowerShell.Commands.NewPSRoleCapabilityFileCommand : PSCmdlet {
    private string _path;
    private Guid _guid;
    private string _author;
    private string _description;
    private string _companyName;
    private string _copyright;
    private Object[] _modulesToImport;
    private String[] _visibleAliases;
    private Object[] _visibleCmdlets;
    private Object[] _visibleFunctions;
    private String[] _visibleExternalCommands;
    private String[] _visibleProviders;
    private String[] _scriptsToProcess;
    private IDictionary[] _aliasDefinitions;
    private IDictionary[] _functionDefinitions;
    private object _variableDefinitions;
    private IDictionary _environmentVariables;
    private String[] _typesToProcess;
    private String[] _formatsToProcess;
    private String[] _assembliesToLoad;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
public Guid Guid { get; public set; }
    [ParameterAttribute]
public string Author { get; public set; }
    [ParameterAttribute]
public string Description { get; public set; }
    [ParameterAttribute]
public string CompanyName { get; public set; }
    [ParameterAttribute]
public string Copyright { get; public set; }
    [ParameterAttribute]
public Object[] ModulesToImport { get; public set; }
    [ParameterAttribute]
public String[] VisibleAliases { get; public set; }
    [ParameterAttribute]
public Object[] VisibleCmdlets { get; public set; }
    [ParameterAttribute]
public Object[] VisibleFunctions { get; public set; }
    [ParameterAttribute]
public String[] VisibleExternalCommands { get; public set; }
    [ParameterAttribute]
public String[] VisibleProviders { get; public set; }
    [ParameterAttribute]
public String[] ScriptsToProcess { get; public set; }
    [ParameterAttribute]
public IDictionary[] AliasDefinitions { get; public set; }
    [ParameterAttribute]
public IDictionary[] FunctionDefinitions { get; public set; }
    [ParameterAttribute]
public object VariableDefinitions { get; public set; }
    [ParameterAttribute]
public IDictionary EnvironmentVariables { get; public set; }
    [ParameterAttribute]
public String[] TypesToProcess { get; public set; }
    [ParameterAttribute]
public String[] FormatsToProcess { get; public set; }
    [ParameterAttribute]
public String[] AssembliesToLoad { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_CompanyName();
    public void set_CompanyName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public Object[] get_ModulesToImport();
    public void set_ModulesToImport(Object[] value);
    public String[] get_VisibleAliases();
    public void set_VisibleAliases(String[] value);
    public Object[] get_VisibleCmdlets();
    public void set_VisibleCmdlets(Object[] value);
    public Object[] get_VisibleFunctions();
    public void set_VisibleFunctions(Object[] value);
    public String[] get_VisibleExternalCommands();
    public void set_VisibleExternalCommands(String[] value);
    public String[] get_VisibleProviders();
    public void set_VisibleProviders(String[] value);
    public String[] get_ScriptsToProcess();
    public void set_ScriptsToProcess(String[] value);
    public IDictionary[] get_AliasDefinitions();
    public void set_AliasDefinitions(IDictionary[] value);
    public IDictionary[] get_FunctionDefinitions();
    public void set_FunctionDefinitions(IDictionary[] value);
    public object get_VariableDefinitions();
    public void set_VariableDefinitions(object value);
    public IDictionary get_EnvironmentVariables();
    public void set_EnvironmentVariables(IDictionary value);
    public String[] get_TypesToProcess();
    public void set_TypesToProcess(String[] value);
    public String[] get_FormatsToProcess();
    public void set_FormatsToProcess(String[] value);
    public String[] get_AssembliesToLoad();
    public void set_AssembliesToLoad(String[] value);
    protected virtual void ProcessRecord();
}
[CmdletAttribute("New", "PSSession")]
[OutputTypeAttribute("System.Management.Automation.Runspaces.PSSession")]
public class Microsoft.PowerShell.Commands.NewPSSessionCommand : PSRemotingBaseCmdlet {
    [CompilerGeneratedAttribute]
private String[] <ComputerName>k__BackingField;
    private PSSession[] _remoteRunspaceInfos;
    [CompilerGeneratedAttribute]
private String[] <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <EnableNetworkAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseWindowsPowerShell>k__BackingField;
    private ThrottleManager _throttleManager;
    private ObjectStream _stream;
    private ManualResetEvent _operationsComplete;
    private List`1<RemoteRunspace> _toDispose;
    private Collection`1<List`1<IThrottleOperation>> _allOperations;
    private string _defaultFQEID;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter EnableNetworkAccess { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseWindowsPowerShell { get; public set; }
    [CompilerGeneratedAttribute]
public virtual String[] get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(String[] value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual PSSession[] get_Session();
    public virtual void set_Session(PSSession[] value);
    [CompilerGeneratedAttribute]
public String[] get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_EnableNetworkAccess();
    [CompilerGeneratedAttribute]
public void set_EnableNetworkAccess(SwitchParameter value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseWindowsPowerShell();
    [CompilerGeneratedAttribute]
public void set_UseWindowsPowerShell(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    public sealed virtual void Dispose();
    private void OnRunspacePSEventReceived(object sender, PSEventArgs e);
    private void HandleURIDirectionReported(object sender, RemoteDataEventArgs`1<Uri> eventArgs);
    private void HandleRunspaceStateChanged(object sender, OperationStateEventArgs stateEventArgs);
    private List`1<RemoteRunspace> CreateRunspacesWhenRunspaceParameterSpecified();
    private List`1<RemoteRunspace> CreateRunspacesWhenUriParameterSpecified();
    private List`1<RemoteRunspace> CreateRunspacesWhenComputerNameParameterSpecified();
    private List`1<RemoteRunspace> CreateRunspacesWhenVMParameterSpecified();
    private List`1<RemoteRunspace> CreateRunspacesWhenContainerParameterSpecified();
    private List`1<RemoteRunspace> CreateRunspacesForSSHHostParameterSet();
    private List`1<RemoteRunspace> CreateRunspacesForSSHHostHashParameterSet();
    private List`1<RemoteRunspace> CreateRunspacesForUseWindowsPowerShellParameterSet();
    private string GetRunspaceName(int rsIndex, Int32& rsId);
    protected void Dispose(bool disposing);
    private void HandleThrottleComplete(object sender, EventArgs eventArgs);
    private void WriteErrorCreateRemoteRunspaceFailed(Exception e, Uri uri);
}
[CmdletAttribute("New", "PSSessionConfigurationFile")]
public class Microsoft.PowerShell.Commands.NewPSSessionConfigurationFileCommand : PSCmdlet {
    private string _path;
    private Version _schemaVersion;
    private Guid _guid;
    private string _author;
    private string _description;
    private string _companyName;
    private string _copyright;
    private SessionType _sessionType;
    private string _transcriptDirectory;
    [CompilerGeneratedAttribute]
private SwitchParameter <RunAsVirtualAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <RunAsVirtualAccountGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <MountUserDrive>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UserDriveMaximumSize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GroupManagedServiceAccount>k__BackingField;
    private String[] _scriptsToProcess;
    private IDictionary _roleDefinitions;
    private IDictionary _requiredGroups;
    private PSLanguageMode _languageMode;
    private bool _isLanguageModeSpecified;
    private ExecutionPolicy _executionPolicy;
    private Version _powerShellVersion;
    private Object[] _modulesToImport;
    private String[] _visibleAliases;
    private Object[] _visibleCmdlets;
    private Object[] _visibleFunctions;
    private String[] _visibleExternalCommands;
    private String[] _visibleProviders;
    private IDictionary[] _aliasDefinitions;
    private IDictionary[] _functionDefinitions;
    private object _variableDefinitions;
    private IDictionary _environmentVariables;
    private String[] _typesToProcess;
    private String[] _formatsToProcess;
    private String[] _assembliesToLoad;
    [CompilerGeneratedAttribute]
private SwitchParameter <Full>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Path { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Version SchemaVersion { get; public set; }
    [ParameterAttribute]
public Guid Guid { get; public set; }
    [ParameterAttribute]
public string Author { get; public set; }
    [ParameterAttribute]
public string Description { get; public set; }
    [ParameterAttribute]
public string CompanyName { get; public set; }
    [ParameterAttribute]
public string Copyright { get; public set; }
    [ParameterAttribute]
public SessionType SessionType { get; public set; }
    [ParameterAttribute]
public string TranscriptDirectory { get; public set; }
    [ParameterAttribute]
public SwitchParameter RunAsVirtualAccount { get; public set; }
    [ParameterAttribute]
public String[] RunAsVirtualAccountGroups { get; public set; }
    [ParameterAttribute]
public SwitchParameter MountUserDrive { get; public set; }
    [ParameterAttribute]
public long UserDriveMaximumSize { get; public set; }
    [ParameterAttribute]
public string GroupManagedServiceAccount { get; public set; }
    [ParameterAttribute]
public String[] ScriptsToProcess { get; public set; }
    [ParameterAttribute]
public IDictionary RoleDefinitions { get; public set; }
    [ParameterAttribute]
public IDictionary RequiredGroups { get; public set; }
    [ParameterAttribute]
public PSLanguageMode LanguageMode { get; public set; }
    [ParameterAttribute]
public ExecutionPolicy ExecutionPolicy { get; public set; }
    [ParameterAttribute]
public Version PowerShellVersion { get; public set; }
    [ParameterAttribute]
public Object[] ModulesToImport { get; public set; }
    [ParameterAttribute]
public String[] VisibleAliases { get; public set; }
    [ParameterAttribute]
public Object[] VisibleCmdlets { get; public set; }
    [ParameterAttribute]
public Object[] VisibleFunctions { get; public set; }
    [ParameterAttribute]
public String[] VisibleExternalCommands { get; public set; }
    [ParameterAttribute]
public String[] VisibleProviders { get; public set; }
    [ParameterAttribute]
public IDictionary[] AliasDefinitions { get; public set; }
    [ParameterAttribute]
public IDictionary[] FunctionDefinitions { get; public set; }
    [ParameterAttribute]
public object VariableDefinitions { get; public set; }
    [ParameterAttribute]
public IDictionary EnvironmentVariables { get; public set; }
    [ParameterAttribute]
public String[] TypesToProcess { get; public set; }
    [ParameterAttribute]
public String[] FormatsToProcess { get; public set; }
    [ParameterAttribute]
public String[] AssembliesToLoad { get; public set; }
    [ParameterAttribute]
public SwitchParameter Full { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    public Version get_SchemaVersion();
    public void set_SchemaVersion(Version value);
    public Guid get_Guid();
    public void set_Guid(Guid value);
    public string get_Author();
    public void set_Author(string value);
    public string get_Description();
    public void set_Description(string value);
    public string get_CompanyName();
    public void set_CompanyName(string value);
    public string get_Copyright();
    public void set_Copyright(string value);
    public SessionType get_SessionType();
    public void set_SessionType(SessionType value);
    public string get_TranscriptDirectory();
    public void set_TranscriptDirectory(string value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_RunAsVirtualAccount();
    [CompilerGeneratedAttribute]
public void set_RunAsVirtualAccount(SwitchParameter value);
    [CompilerGeneratedAttribute]
public String[] get_RunAsVirtualAccountGroups();
    [CompilerGeneratedAttribute]
public void set_RunAsVirtualAccountGroups(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_MountUserDrive();
    [CompilerGeneratedAttribute]
public void set_MountUserDrive(SwitchParameter value);
    [CompilerGeneratedAttribute]
public long get_UserDriveMaximumSize();
    [CompilerGeneratedAttribute]
public void set_UserDriveMaximumSize(long value);
    [CompilerGeneratedAttribute]
public string get_GroupManagedServiceAccount();
    [CompilerGeneratedAttribute]
public void set_GroupManagedServiceAccount(string value);
    public String[] get_ScriptsToProcess();
    public void set_ScriptsToProcess(String[] value);
    public IDictionary get_RoleDefinitions();
    public void set_RoleDefinitions(IDictionary value);
    public IDictionary get_RequiredGroups();
    public void set_RequiredGroups(IDictionary value);
    public PSLanguageMode get_LanguageMode();
    public void set_LanguageMode(PSLanguageMode value);
    public ExecutionPolicy get_ExecutionPolicy();
    public void set_ExecutionPolicy(ExecutionPolicy value);
    public Version get_PowerShellVersion();
    public void set_PowerShellVersion(Version value);
    public Object[] get_ModulesToImport();
    public void set_ModulesToImport(Object[] value);
    public String[] get_VisibleAliases();
    public void set_VisibleAliases(String[] value);
    public Object[] get_VisibleCmdlets();
    public void set_VisibleCmdlets(Object[] value);
    public Object[] get_VisibleFunctions();
    public void set_VisibleFunctions(Object[] value);
    public String[] get_VisibleExternalCommands();
    public void set_VisibleExternalCommands(String[] value);
    public String[] get_VisibleProviders();
    public void set_VisibleProviders(String[] value);
    public IDictionary[] get_AliasDefinitions();
    public void set_AliasDefinitions(IDictionary[] value);
    public IDictionary[] get_FunctionDefinitions();
    public void set_FunctionDefinitions(IDictionary[] value);
    public object get_VariableDefinitions();
    public void set_VariableDefinitions(object value);
    public IDictionary get_EnvironmentVariables();
    public void set_EnvironmentVariables(IDictionary value);
    public String[] get_TypesToProcess();
    public void set_TypesToProcess(String[] value);
    public String[] get_FormatsToProcess();
    public void set_FormatsToProcess(String[] value);
    public String[] get_AssembliesToLoad();
    public void set_AssembliesToLoad(String[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Full();
    [CompilerGeneratedAttribute]
public void set_Full(SwitchParameter value);
    protected virtual void ProcessRecord();
    private bool ShouldGenerateConfigurationSnippet(string parameterName);
}
[CmdletAttribute("New", "PSSessionOption")]
[OutputTypeAttribute("System.Management.Automation.Remoting.PSSessionOption")]
public class Microsoft.PowerShell.Commands.NewPSSessionOptionCommand : PSCmdlet {
    private Nullable`1<int> _maximumRedirection;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <NoMachineProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <UICulture>k__BackingField;
    private Nullable`1<int> _maxRecvdDataSizePerCommand;
    private Nullable`1<int> _maxRecvdObjectSize;
    [CompilerGeneratedAttribute]
private OutputBufferingMode <OutputBufferingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConnectionRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private PSPrimitiveDictionary <ApplicationArguments>k__BackingField;
    private Nullable`1<int> _openTimeout;
    private Nullable`1<int> _cancelTimeout;
    private Nullable`1<int> _idleTimeout;
    [CompilerGeneratedAttribute]
private ProxyAccessType <ProxyAccessType>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationMechanism <ProxyAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private PSCredential <ProxyCredential>k__BackingField;
    private bool _skipcacheck;
    private bool _skipcncheck;
    private bool _skiprevocationcheck;
    private Nullable`1<int> _operationtimeout;
    private bool _noencryption;
    private bool _useutf16;
    private bool _includePortInSPN;
    [ParameterAttribute]
public int MaximumRedirection { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoCompression { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoMachineProfile { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public CultureInfo Culture { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public CultureInfo UICulture { get; public set; }
    [ParameterAttribute]
public int MaximumReceivedDataSizePerCommand { get; public set; }
    [ParameterAttribute]
public int MaximumReceivedObjectSize { get; public set; }
    [ParameterAttribute]
public OutputBufferingMode OutputBufferingMode { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int MaxConnectionRetryCount { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public PSPrimitiveDictionary ApplicationArguments { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int OpenTimeout { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int CancelTimeout { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public int IdleTimeout { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public ProxyAccessType ProxyAccessType { get; public set; }
    [ParameterAttribute]
public AuthenticationMechanism ProxyAuthentication { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[CredentialAttribute]
public PSCredential ProxyCredential { get; public set; }
    [ParameterAttribute]
public SwitchParameter SkipCACheck { get; public set; }
    [ParameterAttribute]
public SwitchParameter SkipCNCheck { get; public set; }
    [ParameterAttribute]
public SwitchParameter SkipRevocationCheck { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int OperationTimeout { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoEncryption { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseUTF16 { get; public set; }
    [ParameterAttribute]
public SwitchParameter IncludePortInSPN { get; public set; }
    public int get_MaximumRedirection();
    public void set_MaximumRedirection(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoCompression();
    [CompilerGeneratedAttribute]
public void set_NoCompression(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_NoMachineProfile();
    [CompilerGeneratedAttribute]
public void set_NoMachineProfile(SwitchParameter value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public CultureInfo get_UICulture();
    [CompilerGeneratedAttribute]
public void set_UICulture(CultureInfo value);
    public int get_MaximumReceivedDataSizePerCommand();
    public void set_MaximumReceivedDataSizePerCommand(int value);
    public int get_MaximumReceivedObjectSize();
    public void set_MaximumReceivedObjectSize(int value);
    [CompilerGeneratedAttribute]
public OutputBufferingMode get_OutputBufferingMode();
    [CompilerGeneratedAttribute]
public void set_OutputBufferingMode(OutputBufferingMode value);
    [CompilerGeneratedAttribute]
public int get_MaxConnectionRetryCount();
    [CompilerGeneratedAttribute]
public void set_MaxConnectionRetryCount(int value);
    [CompilerGeneratedAttribute]
public PSPrimitiveDictionary get_ApplicationArguments();
    [CompilerGeneratedAttribute]
public void set_ApplicationArguments(PSPrimitiveDictionary value);
    public int get_OpenTimeout();
    public void set_OpenTimeout(int value);
    public int get_CancelTimeout();
    public void set_CancelTimeout(int value);
    public int get_IdleTimeout();
    public void set_IdleTimeout(int value);
    [CompilerGeneratedAttribute]
public ProxyAccessType get_ProxyAccessType();
    [CompilerGeneratedAttribute]
public void set_ProxyAccessType(ProxyAccessType value);
    [CompilerGeneratedAttribute]
public AuthenticationMechanism get_ProxyAuthentication();
    [CompilerGeneratedAttribute]
public void set_ProxyAuthentication(AuthenticationMechanism value);
    [CompilerGeneratedAttribute]
public PSCredential get_ProxyCredential();
    [CompilerGeneratedAttribute]
public void set_ProxyCredential(PSCredential value);
    public SwitchParameter get_SkipCACheck();
    public void set_SkipCACheck(SwitchParameter value);
    public SwitchParameter get_SkipCNCheck();
    public void set_SkipCNCheck(SwitchParameter value);
    public SwitchParameter get_SkipRevocationCheck();
    public void set_SkipRevocationCheck(SwitchParameter value);
    public int get_OperationTimeout();
    public void set_OperationTimeout(int value);
    public SwitchParameter get_NoEncryption();
    public void set_NoEncryption(SwitchParameter value);
    public SwitchParameter get_UseUTF16();
    public void set_UseUTF16(SwitchParameter value);
    public SwitchParameter get_IncludePortInSPN();
    public void set_IncludePortInSPN(SwitchParameter value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("New", "PSTransportOption")]
[OutputTypeAttribute("Microsoft.PowerShell.Commands.WSManConfigurationOption")]
public class Microsoft.PowerShell.Commands.NewPSTransportOptionCommand : PSCmdlet {
    private WSManConfigurationOption _option;
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxIdleTimeoutSec { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> ProcessIdleTimeoutSec { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxSessions { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxConcurrentCommandsPerSession { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxSessionsPerUser { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxMemoryPerSessionMB { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxProcessesPerSession { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> MaxConcurrentUsers { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public Nullable`1<int> IdleTimeoutSec { get; public set; }
    [ParameterAttribute]
public Nullable`1<OutputBufferingMode> OutputBufferingMode { get; public set; }
    public Nullable`1<int> get_MaxIdleTimeoutSec();
    public void set_MaxIdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<int> get_ProcessIdleTimeoutSec();
    public void set_ProcessIdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<int> get_MaxSessions();
    public void set_MaxSessions(Nullable`1<int> value);
    public Nullable`1<int> get_MaxConcurrentCommandsPerSession();
    public void set_MaxConcurrentCommandsPerSession(Nullable`1<int> value);
    public Nullable`1<int> get_MaxSessionsPerUser();
    public void set_MaxSessionsPerUser(Nullable`1<int> value);
    public Nullable`1<int> get_MaxMemoryPerSessionMB();
    public void set_MaxMemoryPerSessionMB(Nullable`1<int> value);
    public Nullable`1<int> get_MaxProcessesPerSession();
    public void set_MaxProcessesPerSession(Nullable`1<int> value);
    public Nullable`1<int> get_MaxConcurrentUsers();
    public void set_MaxConcurrentUsers(Nullable`1<int> value);
    public Nullable`1<int> get_IdleTimeoutSec();
    public void set_IdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<OutputBufferingMode> get_OutputBufferingMode();
    public void set_OutputBufferingMode(Nullable`1<OutputBufferingMode> value);
    protected virtual void ProcessRecord();
}
public class Microsoft.PowerShell.Commands.NounArgumentCompleter : object {
    public sealed virtual IEnumerable`1<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
public abstract class Microsoft.PowerShell.Commands.ObjectEventRegistrationBase : PSCmdlet {
    private string _sourceIdentifier;
    private ScriptBlock _action;
    private PSObject _messageData;
    private SwitchParameter _supportEvent;
    private SwitchParameter _forward;
    private int _maxTriggerCount;
    private PSEventSubscriber _newSubscriber;
    [ParameterAttribute]
public string SourceIdentifier { get; public set; }
    [ParameterAttribute]
public ScriptBlock Action { get; public set; }
    [ParameterAttribute]
public PSObject MessageData { get; public set; }
    [ParameterAttribute]
public SwitchParameter SupportEvent { get; public set; }
    [ParameterAttribute]
public SwitchParameter Forward { get; public set; }
    [ParameterAttribute]
public int MaxTriggerCount { get; public set; }
    protected PSEventSubscriber NewSubscriber { get; }
    public string get_SourceIdentifier();
    public void set_SourceIdentifier(string value);
    public ScriptBlock get_Action();
    public void set_Action(ScriptBlock value);
    public PSObject get_MessageData();
    public void set_MessageData(PSObject value);
    public SwitchParameter get_SupportEvent();
    public void set_SupportEvent(SwitchParameter value);
    public SwitchParameter get_Forward();
    public void set_Forward(SwitchParameter value);
    public int get_MaxTriggerCount();
    public void set_MaxTriggerCount(int value);
    protected abstract virtual object GetSourceObject();
    protected abstract virtual string GetSourceObjectEventName();
    protected PSEventSubscriber get_NewSubscriber();
    protected virtual void BeginProcessing();
    protected virtual void EndProcessing();
}
public enum Microsoft.PowerShell.Commands.OpenMode : Enum {
    public int value__;
    public static OpenMode Add;
    public static OpenMode New;
    public static OpenMode Overwrite;
}
internal class Microsoft.PowerShell.Commands.OpenRunspaceOperation : IThrottleOperation {
    private bool _startComplete;
    private bool _stopComplete;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private RemoteRunspace <OperatedRunspace>k__BackingField;
    private List`1<EventHandler`1<OperationStateEventArgs>> _internalCallbacks;
    internal RemoteRunspace OperatedRunspace { get; }
    internal OpenRunspaceOperation(RemoteRunspace runspace);
    [CompilerGeneratedAttribute]
internal RemoteRunspace get_OperatedRunspace();
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void HandleRunspaceStateChanged(object source, RunspaceStateEventArgs stateEventArgs);
    private void FireEvent(OperationStateEventArgs operationStateEventArgs);
    public sealed virtual void Dispose();
}
[CmdletAttribute("Out", "Default")]
public class Microsoft.PowerShell.Commands.OutDefaultCommand : FrontEndCommandBase {
    [CompilerGeneratedAttribute]
private SwitchParameter <Transcript>k__BackingField;
    private List`1<PSObject> _outVarResults;
    private IDisposable _transcribeOnlyCookie;
    [ParameterAttribute]
public SwitchParameter Transcript { get; public set; }
    [CompilerGeneratedAttribute]
public SwitchParameter get_Transcript();
    [CompilerGeneratedAttribute]
public void set_Transcript(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void InternalDispose();
}
[CmdletAttribute("Out", "Host")]
public class Microsoft.PowerShell.Commands.OutHostCommand : FrontEndCommandBase {
    private bool _paging;
    [ParameterAttribute]
public SwitchParameter Paging { get; public set; }
    public SwitchParameter get_Paging();
    public void set_Paging(SwitchParameter value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Out", "LineOutput")]
public class Microsoft.PowerShell.Commands.OutLineOutputCommand : FrontEndCommandBase {
    private object _lineOutput;
    [ParameterAttribute]
public object LineOutput { get; public set; }
    public object get_LineOutput();
    public void set_LineOutput(object value);
    protected virtual void BeginProcessing();
    private void ProcessNullLineOutput();
    private void ProcessWrongTypeLineOutput(object obj);
}
[CmdletAttribute("Out", "Null")]
public class Microsoft.PowerShell.Commands.OutNullCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private PSObject <InputObject>k__BackingField;
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    [CompilerGeneratedAttribute]
public PSObject get_InputObject();
    [CompilerGeneratedAttribute]
public void set_InputObject(PSObject value);
    protected virtual void ProcessRecord();
}
internal class Microsoft.PowerShell.Commands.OutputProcessingState : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<OutputProcessingStateEventArgs> OutputProcessingStateChanged;
    [CompilerGeneratedAttribute]
public sealed virtual void add_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
    internal void RaiseOutputProcessingStateChangedEvent(bool processingOutput);
}
public enum Microsoft.PowerShell.Commands.OutTarget : Enum {
    public int value__;
    public static OutTarget Default;
    public static OutTarget Host;
    public static OutTarget Job;
}
internal static class Microsoft.PowerShell.Commands.PathResolver : object {
    internal static string ResolveProviderAndPath(string path, bool isLiteralPath, PSCmdlet cmdlet, bool allowNonexistingPaths, string resourceString);
    private static PathInfo ResolvePath(string pathToResolve, bool isLiteralPath, bool allowNonexistingPaths, PSCmdlet cmdlet);
}
public class Microsoft.PowerShell.Commands.PSEditionArgumentCompleter : object {
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.PSEditionArgumentCompleter/<CompleteArgument>d__0")]
public sealed virtual IEnumerable`1<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
public abstract class Microsoft.PowerShell.Commands.PSExecutionCmdlet : PSRemotingBaseCmdlet {
    protected static string FilePathVMIdParameterSet;
    protected static string FilePathVMNameParameterSet;
    protected static string FilePathContainerIdParameterSet;
    protected static string FilePathSSHHostParameterSet;
    protected static string FilePathSSHHostHashParameterSet;
    [CompilerGeneratedAttribute]
private PSObject <InputObject>k__BackingField;
    private ScriptBlock _scriptBlock;
    private string _filePath;
    [CompilerGeneratedAttribute]
private bool <IsLiteralPath>k__BackingField;
    private Object[] _args;
    [CompilerGeneratedAttribute]
private bool <InvokeAndDisconnect>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <DisconnectedSessionName>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <EnableNetworkAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid[] <VMId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VMName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IThrottleOperation> <Operations>k__BackingField;
    protected static string FilePathComputerNameParameterSet;
    protected static string LiteralFilePathComputerNameParameterSet;
    protected static string FilePathSessionParameterSet;
    protected static string FilePathUriParameterSet;
    private static string PSv5OrLater;
    private static string PSv3Orv4;
    private static string PSv2;
    private PowerShell _powershellV2;
    private PowerShell _powershellV3;
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    public ScriptBlock ScriptBlock { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public string FilePath { get; public set; }
    protected bool IsLiteralPath { get; protected set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    protected bool InvokeAndDisconnect { get; protected set; }
    protected String[] DisconnectedSessionName { get; protected set; }
    public SwitchParameter EnableNetworkAccess { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Guid[] VMId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] VMName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ContainerId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    internal List`1<IThrottleOperation> Operations { get; }
    [CompilerGeneratedAttribute]
public virtual PSObject get_InputObject();
    [CompilerGeneratedAttribute]
public virtual void set_InputObject(PSObject value);
    public virtual ScriptBlock get_ScriptBlock();
    public virtual void set_ScriptBlock(ScriptBlock value);
    public virtual string get_FilePath();
    public virtual void set_FilePath(string value);
    [CompilerGeneratedAttribute]
protected bool get_IsLiteralPath();
    [CompilerGeneratedAttribute]
protected void set_IsLiteralPath(bool value);
    public virtual Object[] get_ArgumentList();
    public virtual void set_ArgumentList(Object[] value);
    [CompilerGeneratedAttribute]
protected bool get_InvokeAndDisconnect();
    [CompilerGeneratedAttribute]
protected void set_InvokeAndDisconnect(bool value);
    [CompilerGeneratedAttribute]
protected String[] get_DisconnectedSessionName();
    [CompilerGeneratedAttribute]
protected void set_DisconnectedSessionName(String[] value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_EnableNetworkAccess();
    [CompilerGeneratedAttribute]
public virtual void set_EnableNetworkAccess(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual Guid[] get_VMId();
    [CompilerGeneratedAttribute]
public virtual void set_VMId(Guid[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_VMName();
    [CompilerGeneratedAttribute]
public virtual void set_VMName(String[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ContainerId();
    [CompilerGeneratedAttribute]
public virtual void set_ContainerId(String[] value);
    [CompilerGeneratedAttribute]
public virtual string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public virtual void set_ConfigurationName(string value);
    protected virtual void CreateHelpersForSpecifiedComputerNames();
    protected void CreateHelpersForSpecifiedSSHComputerNames();
    protected void CreateHelpersForSpecifiedSSHHashComputerNames();
    protected void CreateHelpersForSpecifiedRunspaces();
    protected void CreateHelpersForSpecifiedUris();
    protected virtual void CreateHelpersForSpecifiedVMSession();
    protected virtual void CreateHelpersForSpecifiedContainerSession();
    internal Pipeline CreatePipeline(RemoteRunspace remoteRunspace);
    private static string GetRemoteServerPsVersion(RemoteRunspace remoteRunspace);
    internal void OnRunspacePSEventReceived(object sender, PSEventArgs e);
    [CompilerGeneratedAttribute]
internal List`1<IThrottleOperation> get_Operations();
    protected void CloseAllInputStreams();
    private void WriteErrorCreateRemoteRunspaceFailed(Exception e, Uri uri);
    protected ScriptBlock GetScriptBlockFromFile(string filePath, bool isLiteralPath);
    protected virtual void BeginProcessing();
    private PowerShell GetPowerShellForPSv2();
    private PowerShell GetPowerShellForPSv3OrLater(string serverPsVersion);
    private PowerShell ConvertToPowerShell();
    private string GetConvertedScript(List`1& newParameterNames, List`1& newParameterValues);
    private List`1<object> GetUsingVariableValues(List`1<VariableExpressionAst> paramUsingVars);
    private static List`1<VariableExpressionAst> GetUsingVariables(ScriptBlock localScriptBlock);
}
public class Microsoft.PowerShell.Commands.PSHostProcessInfo : object {
    private string _pipeNameFilePath;
    [CompilerGeneratedAttribute]
private string <ProcessName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AppDomainName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MainWindowTitle>k__BackingField;
    public string ProcessName { get; }
    public int ProcessId { get; }
    public string AppDomainName { get; }
    public string MainWindowTitle { get; }
    internal PSHostProcessInfo(string processName, int processId, string appDomainName, string pipeNameFilePath);
    [CompilerGeneratedAttribute]
public string get_ProcessName();
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
public string get_AppDomainName();
    [CompilerGeneratedAttribute]
public string get_MainWindowTitle();
    public string GetPipeNameFilePath();
}
internal static class Microsoft.PowerShell.Commands.PSHostProcessUtils : object {
    public static Process GetProcessById(int procId);
}
public class Microsoft.PowerShell.Commands.PSPropertyExpression : object {
    [CompilerGeneratedAttribute]
private ScriptBlock <Script>k__BackingField;
    private CallSite`1<Func`3<CallSite, object, object>> _getValueDynamicSite;
    private string _stringValue;
    private bool _isResolved;
    public ScriptBlock Script { get; }
    public bool HasWildCardCharacters { get; }
    public PSPropertyExpression(string s);
    public PSPropertyExpression(string s, bool isResolved);
    public PSPropertyExpression(ScriptBlock scriptBlock);
    [CompilerGeneratedAttribute]
public ScriptBlock get_Script();
    public virtual string ToString();
    public List`1<PSPropertyExpression> ResolveNames(PSObject target);
    public bool get_HasWildCardCharacters();
    public List`1<PSPropertyExpression> ResolveNames(PSObject target, bool expand);
    public List`1<PSPropertyExpressionResult> GetValues(PSObject target);
    public List`1<PSPropertyExpressionResult> GetValues(PSObject target, bool expand, bool eatExceptions);
    private PSPropertyExpressionResult GetValue(PSObject target, bool eatExceptions);
    private static PSObject IfHashtableWrapAsPSCustomObject(PSObject target, Boolean& wrapped);
}
public class Microsoft.PowerShell.Commands.PSPropertyExpressionResult : object {
    [CompilerGeneratedAttribute]
private object <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private PSPropertyExpression <ResolvedExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public object Result { get; }
    public PSPropertyExpression ResolvedExpression { get; }
    public Exception Exception { get; }
    public PSPropertyExpressionResult(object res, PSPropertyExpression re, Exception e);
    [CompilerGeneratedAttribute]
public object get_Result();
    [CompilerGeneratedAttribute]
public PSPropertyExpression get_ResolvedExpression();
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public abstract class Microsoft.PowerShell.Commands.PSRemotingBaseCmdlet : PSRemotingCmdlet {
    [CompilerGeneratedAttribute]
private PSSession[] <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ResolvedComputerNames>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid[] <VMId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VMName>k__BackingField;
    private PSCredential _pscredential;
    [CompilerGeneratedAttribute]
private String[] <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <RunAsAdministrator>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseSSL>k__BackingField;
    private string _appName;
    [CompilerGeneratedAttribute]
private int <ThrottleLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri[] <ConnectionUri>k__BackingField;
    private bool _allowRedirection;
    private PSSessionOption _sessionOption;
    internal static string DEFAULT_SESSION_OPTION;
    private AuthenticationMechanism _authMechanism;
    private string _thumbPrint;
    [CompilerGeneratedAttribute]
private String[] <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectingTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <SSHTransport>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable[] <SSHConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Options>k__BackingField;
    private static string ComputerNameParameter;
    private static string HostNameAlias;
    private static string UserNameParameter;
    private static string KeyFilePathParameter;
    private static string IdentityFilePathAlias;
    private static string PortParameter;
    private static string SubsystemParameter;
    private static string ConnectingTimeoutParameter;
    private static string OptionsParameter;
    protected static string UriParameterSet;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ComputerName { get; public set; }
    protected String[] ResolvedComputerNames { get; protected set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Guid[] VMId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] VMName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ContainerId { get; public set; }
    [ParameterAttribute]
public SwitchParameter RunAsAdministrator { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Port { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseSSL { get; public set; }
    [ParameterAttribute]
public string ApplicationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public int ThrottleLimit { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri[] ConnectionUri { get; public set; }
    [ParameterAttribute]
public SwitchParameter AllowRedirection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public PSSessionOption SessionOption { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string CertificateThumbprint { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] HostName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string UserName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string KeyFilePath { get; public set; }
    [ParameterAttribute]
public string Subsystem { get; public set; }
    [ParameterAttribute]
public int ConnectingTimeout { get; public set; }
    [ParameterAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter SSHTransport { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable[] SSHConnection { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Hashtable Options { get; public set; }
    [CompilerGeneratedAttribute]
public virtual PSSession[] get_Session();
    [CompilerGeneratedAttribute]
public virtual void set_Session(PSSession[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(String[] value);
    [CompilerGeneratedAttribute]
protected String[] get_ResolvedComputerNames();
    [CompilerGeneratedAttribute]
protected void set_ResolvedComputerNames(String[] value);
    [CompilerGeneratedAttribute]
public virtual Guid[] get_VMId();
    [CompilerGeneratedAttribute]
public virtual void set_VMId(Guid[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_VMName();
    [CompilerGeneratedAttribute]
public virtual void set_VMName(String[] value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ContainerId();
    [CompilerGeneratedAttribute]
public virtual void set_ContainerId(String[] value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_RunAsAdministrator();
    [CompilerGeneratedAttribute]
public virtual void set_RunAsAdministrator(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual int get_Port();
    [CompilerGeneratedAttribute]
public virtual void set_Port(int value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_UseSSL();
    [CompilerGeneratedAttribute]
public virtual void set_UseSSL(SwitchParameter value);
    public virtual string get_ApplicationName();
    public virtual void set_ApplicationName(string value);
    [CompilerGeneratedAttribute]
public virtual int get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public virtual void set_ThrottleLimit(int value);
    [CompilerGeneratedAttribute]
public virtual Uri[] get_ConnectionUri();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectionUri(Uri[] value);
    public virtual SwitchParameter get_AllowRedirection();
    public virtual void set_AllowRedirection(SwitchParameter value);
    public virtual PSSessionOption get_SessionOption();
    public virtual void set_SessionOption(PSSessionOption value);
    public virtual AuthenticationMechanism get_Authentication();
    public virtual void set_Authentication(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public virtual String[] get_HostName();
    [CompilerGeneratedAttribute]
public virtual void set_HostName(String[] value);
    [CompilerGeneratedAttribute]
public virtual string get_UserName();
    [CompilerGeneratedAttribute]
public virtual void set_UserName(string value);
    [CompilerGeneratedAttribute]
public virtual string get_KeyFilePath();
    [CompilerGeneratedAttribute]
public virtual void set_KeyFilePath(string value);
    [CompilerGeneratedAttribute]
public virtual string get_Subsystem();
    [CompilerGeneratedAttribute]
public virtual void set_Subsystem(string value);
    [CompilerGeneratedAttribute]
public virtual int get_ConnectingTimeout();
    [CompilerGeneratedAttribute]
public virtual void set_ConnectingTimeout(int value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_SSHTransport();
    [CompilerGeneratedAttribute]
public virtual void set_SSHTransport(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual Hashtable[] get_SSHConnection();
    [CompilerGeneratedAttribute]
public virtual void set_SSHConnection(Hashtable[] value);
    [CompilerGeneratedAttribute]
public virtual Hashtable get_Options();
    [CompilerGeneratedAttribute]
public virtual void set_Options(Hashtable value);
    internal static void ValidateSpecifiedAuthentication(PSCredential credential, string thumbprint, AuthenticationMechanism authentication);
    protected void ParseSshHostName(string hostname, String& host, String& userName, Int32& port);
    internal SSHConnection[] ParseSSHConnectionHashTable();
    protected void ValidateRemoteRunspacesSpecified();
    internal void UpdateConnectionInfo(WSManConnectionInfo connectionInfo);
    protected void ValidateComputerName(String[] computerNames);
    private static string GetSSHConnectionStringParameter(object param);
    private static int GetSSHConnectionIntParameter(object param);
    protected virtual void BeginProcessing();
}
public abstract class Microsoft.PowerShell.Commands.PSRemotingCmdlet : PSCmdlet {
    private static string s_LOCALHOST;
    protected static string ComputerNameParameterSet;
    protected static string ComputerInstanceIdParameterSet;
    protected static string ContainerIdParameterSet;
    protected static string VMIdParameterSet;
    protected static string VMNameParameterSet;
    protected static string SSHHostParameterSet;
    protected static string SSHHostHashParameterSet;
    protected static string SessionParameterSet;
    protected static string UseWindowsPowerShellParameterSet;
    protected static string DefaultPowerShellRemoteShellName;
    protected static string DefaultPowerShellRemoteShellAppName;
    [CompilerGeneratedAttribute]
private bool <SkipWinRMCheck>k__BackingField;
    internal bool SkipWinRMCheck { get; internal set; }
    private static PSRemotingCmdlet();
    protected virtual void BeginProcessing();
    internal void WriteStreamObject(Action`1<Cmdlet> action);
    protected void ResolveComputerNames(String[] computerNames, String[]& resolvedComputerNames);
    protected string ResolveComputerName(string computerName);
    internal string GetMessage(string resourceString);
    internal string GetMessage(string resourceString, Object[] args);
    [CompilerGeneratedAttribute]
internal bool get_SkipWinRMCheck();
    [CompilerGeneratedAttribute]
internal void set_SkipWinRMCheck(bool value);
    protected string ResolveShell(string shell);
    protected string ResolveAppName(string appName);
}
public abstract class Microsoft.PowerShell.Commands.PSRunspaceCmdlet : PSRemotingCmdlet {
    protected static string ContainerIdInstanceIdParameterSet;
    protected static string VMIdInstanceIdParameterSet;
    protected static string VMNameInstanceIdParameterSet;
    private Guid[] _remoteRunspaceIds;
    [CompilerGeneratedAttribute]
private Int32[] <Id>k__BackingField;
    private String[] _names;
    private String[] _computerNames;
    [CompilerGeneratedAttribute]
private String[] <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid[] <VMId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VMName>k__BackingField;
    protected static string InstanceIdParameterSet;
    protected static string IdParameterSet;
    protected static string NameParameterSet;
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Guid[] InstanceId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public Int32[] Id { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ContainerId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Guid[] VMId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] VMName { get; public set; }
    public virtual Guid[] get_InstanceId();
    public virtual void set_InstanceId(Guid[] value);
    [CompilerGeneratedAttribute]
public Int32[] get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(Int32[] value);
    public virtual String[] get_Name();
    public virtual void set_Name(String[] value);
    public virtual String[] get_ComputerName();
    public virtual void set_ComputerName(String[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ContainerId();
    [CompilerGeneratedAttribute]
public virtual void set_ContainerId(String[] value);
    [CompilerGeneratedAttribute]
public virtual Guid[] get_VMId();
    [CompilerGeneratedAttribute]
public virtual void set_VMId(Guid[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_VMName();
    [CompilerGeneratedAttribute]
public virtual void set_VMName(String[] value);
    protected Dictionary`2<Guid, PSSession> GetMatchingRunspaces(bool writeobject, bool writeErrorOnNoMatch);
    protected Dictionary`2<Guid, PSSession> GetMatchingRunspaces(bool writeobject, bool writeErrorOnNoMatch, SessionFilterState filterState, string configurationName);
    internal Dictionary`2<Guid, PSSession> GetAllRunspaces(bool writeobject, bool writeErrorOnNoMatch);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesByComputerName(bool writeobject, bool writeErrorOnNoMatch);
    protected Dictionary`2<Guid, PSSession> GetMatchingRunspacesByName(bool writeobject, bool writeErrorOnNoMatch);
    protected Dictionary`2<Guid, PSSession> GetMatchingRunspacesByRunspaceId(bool writeobject, bool writeErrorOnNoMatch);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesBySessionId(bool writeobject, bool writeErrorOnNoMatch);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesByVMNameContainerId(bool writeobject, SessionFilterState filterState, string configurationName, bool isContainer);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesByVMNameContainerIdSessionInstanceId(bool writeobject, SessionFilterState filterState, string configurationName, bool isContainer);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesByVMId(bool writeobject, SessionFilterState filterState, string configurationName);
    private Dictionary`2<Guid, PSSession> GetMatchingRunspacesByVMIdSessionInstanceId(bool writeobject, SessionFilterState filterState, string configurationName);
    private void WriteOrAddMatches(List`1<PSSession> matchingRunspaceInfos, bool writeobject, Dictionary`2& matches);
    private void WriteInvalidArgumentError(PSRemotingErrorId errorId, string resourceString, object errorArgument);
}
public class Microsoft.PowerShell.Commands.PSSessionConfigurationCommandBase : PSCmdlet {
    internal static string NameParameterSetName;
    internal static string AssemblyNameParameterSetName;
    internal static string SessionConfigurationFileParameterSetName;
    private static string localSDDL;
    private static string localSDDL_Win8;
    private static string remoteSDDL;
    private static string remoteSDDL_Win8;
    internal static string RemoteManagementUsersSID;
    internal static string InteractiveUsersSID;
    internal Version MaxPSVersion;
    internal string shellName;
    internal string assemblyName;
    internal bool isAssemblyNameSpecified;
    internal string applicationBase;
    internal bool isApplicationBaseSpecified;
    internal string configurationTypeName;
    internal bool isConfigurationTypeNameSpecified;
    internal PSCredential runAsCredential;
    internal bool isRunAsCredentialSpecified;
    internal Nullable`1<ApartmentState> threadAptState;
    internal Nullable`1<PSThreadOptions> threadOptions;
    private PSSessionConfigurationAccessMode _accessMode;
    internal bool accessModeSpecified;
    private bool _useSharedProcess;
    internal bool isUseSharedProcessSpecified;
    internal string configurationScript;
    internal bool isConfigurationScriptSpecified;
    internal Nullable`1<double> maxCommandSizeMB;
    internal bool isMaxCommandSizeMBSpecified;
    internal Nullable`1<double> maxObjectSizeMB;
    internal bool isMaxObjectSizeMBSpecified;
    internal string sddl;
    internal bool isSddlSpecified;
    private bool _showUI;
    internal bool showUISpecified;
    internal bool force;
    internal bool noRestart;
    internal Version psVersion;
    internal bool isPSVersionSpecified;
    internal PSSessionTypeOption sessionTypeOption;
    internal PSTransportOption transportOption;
    internal Object[] modulesToImport;
    internal bool modulePathSpecified;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunAsVirtualAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunAsVirtualAccountSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RunAsVirtualAccountGroups>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public string AssemblyName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string ApplicationBase { get; public set; }
    [ParameterAttribute]
public string ConfigurationTypeName { get; public set; }
    [ParameterAttribute]
[CredentialAttribute]
public PSCredential RunAsCredential { get; public set; }
    [ParameterAttribute]
public ApartmentState ThreadApartmentState { get; public set; }
    [ParameterAttribute]
public PSThreadOptions ThreadOptions { get; public set; }
    [ParameterAttribute]
public PSSessionConfigurationAccessMode AccessMode { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseSharedProcess { get; public set; }
    [ParameterAttribute]
public string StartupScript { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public Nullable`1<double> MaximumReceivedDataSizePerCommandMB { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public Nullable`1<double> MaximumReceivedObjectSizeMB { get; public set; }
    [ParameterAttribute]
public string SecurityDescriptorSddl { get; public set; }
    [ParameterAttribute]
public SwitchParameter ShowSecurityDescriptorUI { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoServiceRestart { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public Version PSVersion { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public PSSessionTypeOption SessionTypeOption { get; public set; }
    [ParameterAttribute]
public PSTransportOption TransportOption { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public Object[] ModulesToImport { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Path { get; public set; }
    protected bool RunAsVirtualAccount { get; protected set; }
    protected bool RunAsVirtualAccountSpecified { get; protected set; }
    protected string RunAsVirtualAccountGroups { get; protected set; }
    internal static string GetLocalSddl();
    internal static string GetRemoteSddl();
    public string get_Name();
    public void set_Name(string value);
    public string get_AssemblyName();
    public void set_AssemblyName(string value);
    public string get_ApplicationBase();
    public void set_ApplicationBase(string value);
    public string get_ConfigurationTypeName();
    public void set_ConfigurationTypeName(string value);
    public PSCredential get_RunAsCredential();
    public void set_RunAsCredential(PSCredential value);
    public ApartmentState get_ThreadApartmentState();
    public void set_ThreadApartmentState(ApartmentState value);
    public PSThreadOptions get_ThreadOptions();
    public void set_ThreadOptions(PSThreadOptions value);
    public PSSessionConfigurationAccessMode get_AccessMode();
    public void set_AccessMode(PSSessionConfigurationAccessMode value);
    public SwitchParameter get_UseSharedProcess();
    public void set_UseSharedProcess(SwitchParameter value);
    public string get_StartupScript();
    public void set_StartupScript(string value);
    public Nullable`1<double> get_MaximumReceivedDataSizePerCommandMB();
    public void set_MaximumReceivedDataSizePerCommandMB(Nullable`1<double> value);
    public Nullable`1<double> get_MaximumReceivedObjectSizeMB();
    public void set_MaximumReceivedObjectSizeMB(Nullable`1<double> value);
    public string get_SecurityDescriptorSddl();
    public void set_SecurityDescriptorSddl(string value);
    public SwitchParameter get_ShowSecurityDescriptorUI();
    public void set_ShowSecurityDescriptorUI(SwitchParameter value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public SwitchParameter get_NoServiceRestart();
    public void set_NoServiceRestart(SwitchParameter value);
    public Version get_PSVersion();
    public void set_PSVersion(Version value);
    public PSSessionTypeOption get_SessionTypeOption();
    public void set_SessionTypeOption(PSSessionTypeOption value);
    public PSTransportOption get_TransportOption();
    public void set_TransportOption(PSTransportOption value);
    public Object[] get_ModulesToImport();
    public void set_ModulesToImport(Object[] value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
protected bool get_RunAsVirtualAccount();
    [CompilerGeneratedAttribute]
protected void set_RunAsVirtualAccount(bool value);
    [CompilerGeneratedAttribute]
protected bool get_RunAsVirtualAccountSpecified();
    [CompilerGeneratedAttribute]
protected void set_RunAsVirtualAccountSpecified(bool value);
    [CompilerGeneratedAttribute]
protected string get_RunAsVirtualAccountGroups();
    [CompilerGeneratedAttribute]
protected void set_RunAsVirtualAccountGroups(string value);
}
internal static class Microsoft.PowerShell.Commands.PSSessionConfigurationCommandUtilities : object {
    internal static string restartWSManFormat;
    internal static string PSCustomShellTypeName;
    private static char OpenParenChar;
    private static char CloseParenChar;
    private static char ACESeparatorChar;
    private static string ACESeparator;
    private static string ConditionalACEPrefix;
    private static string DACLPrefix;
    private static string AndOperator;
    private static string OrOperator;
    private static string AndCondition;
    private static string OrCondition;
    private static string MemberOfFormat;
    internal static void RestartWinRMService(PSCmdlet cmdlet, bool isErrorReported, bool force, bool noServiceRestart);
    internal static void MoveWinRmToIsolatedServiceHost(bool forVirtualAccount);
    internal static void CollectShouldProcessParameters(PSCmdlet cmdlet, Boolean& whatIf, Boolean& confirm);
    internal static void ThrowIfNotAdministrator();
    internal static PSCredential CreateGMSAAccountCredentials(string gmsaAccount);
    internal static Version CalculateMaxPSVersion(Version psVersion);
    internal static string GetModulePathAsString(Object[] modulePath);
    internal static Version ConstructVersionFormatForConfigXml(Version psVersion);
    internal static string GetRunAsVirtualAccountGroupsString(String[] groups);
    internal static string GetWinrmPluginShellName();
    internal static string GetWinrmPluginDllPath();
    internal static string ComputeSDDLFromConfiguration(Hashtable configTable, PSSessionConfigurationAccessMode accessMode, ErrorRecord& error);
    internal static string UpdateSDDLUsersWithGroupConditional(string sddl, string conditionalGroupACE);
    private static Collection`1<string> ParseDACLACEs(string sddl, String& prologue, String& epilogue);
    internal static string CreateConditionalACEFromConfig(Hashtable configTable);
    private static void AddCondition(StringBuilder sb, Hashtable condition);
    private static void ParseKeyValue(StringBuilder sb, object keyValue, string logicalOperator);
    private static void ParseValues(StringBuilder sb, object inValue);
    private static void ParseValue(StringBuilder sb, object value);
}
internal class Microsoft.PowerShell.Commands.QueryRunspaces : object {
    private bool _stopProcessing;
    private static object s_SyncObject;
    private static TypeTable s_TypeTable;
    internal static TypeTable BuiltInTypesTable { get; }
    private static QueryRunspaces();
    internal Collection`1<PSSession> GetDisconnectedSessions(Collection`1<WSManConnectionInfo> connectionInfos, PSHost host, ObjectStream stream, RunspaceRepository runspaceRepository, int throttleLimit, SessionFilterState filterState, Guid[] matchIds, String[] matchNames, string configurationName);
    private static bool UseExistingRunspace(Runspace existingRunspace, Runspace queriedrunspace);
    internal static string ExtractMessage(Exception e, Int32& errorCode);
    internal void StopAllOperations();
    public static bool TestRunspaceState(Runspace runspace, SessionFilterState filterState);
    internal static TypeTable get_BuiltInTypesTable();
}
[CmdletAttribute("Receive", "Job")]
public class Microsoft.PowerShell.Commands.ReceiveJobCommand : JobCmdletBase {
    private Job[] _jobs;
    private String[] _computerNames;
    private String[] _locations;
    private PSSession[] _remoteRunspaceInfos;
    private bool _flush;
    private bool _recurse;
    [CompilerGeneratedAttribute]
private SwitchParameter <Force>k__BackingField;
    protected static string LocationParameterSet;
    private bool _autoRemoveJob;
    private bool _writeStateChangedEvents;
    private bool _wait;
    private bool _isStopping;
    private bool _isDisposed;
    private ReaderWriterLockSlim _resultsReaderWriterLock;
    private PowerShellTraceSource _tracer;
    private ManualResetEvent _writeExistingData;
    private PSDataCollection`1<PSStreamObject> _results;
    private bool _holdingResultsRef;
    private List`1<Job> _jobsBeingAggregated;
    private List`1<Guid> _jobsSpecifiedInParameters;
    private object _syncObject;
    private bool _outputJobFirst;
    private OutputProcessingState _outputProcessingNotification;
    private bool _processingOutput;
    private static string ClassNameTrace;
    private Dictionary`2<Guid, bool> _eventArgsWritten;
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public Job[] Job { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
public String[] ComputerName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] Location { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
public SwitchParameter Keep { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoRecurse { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public JobState State { get; }
    public Hashtable Filter { get; }
    public String[] Command { get; }
    [ParameterAttribute]
public SwitchParameter Wait { get; public set; }
    [ParameterAttribute]
public SwitchParameter AutoRemoveJob { get; public set; }
    [ParameterAttribute]
public SwitchParameter WriteEvents { get; public set; }
    [ParameterAttribute]
public SwitchParameter WriteJobInResults { get; public set; }
    public Job[] get_Job();
    public void set_Job(Job[] value);
    public String[] get_ComputerName();
    public void set_ComputerName(String[] value);
    public String[] get_Location();
    public void set_Location(String[] value);
    public PSSession[] get_Session();
    public void set_Session(PSSession[] value);
    public SwitchParameter get_Keep();
    public void set_Keep(SwitchParameter value);
    public SwitchParameter get_NoRecurse();
    public void set_NoRecurse(SwitchParameter value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(SwitchParameter value);
    public virtual JobState get_State();
    public virtual Hashtable get_Filter();
    public virtual String[] get_Command();
    public SwitchParameter get_Wait();
    public void set_Wait(SwitchParameter value);
    public SwitchParameter get_AutoRemoveJob();
    public void set_AutoRemoveJob(SwitchParameter value);
    public SwitchParameter get_WriteEvents();
    public void set_WriteEvents(SwitchParameter value);
    public SwitchParameter get_WriteJobInResults();
    public void set_WriteJobInResults(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void StopProcessing();
    protected virtual void EndProcessing();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
    private static void DoUnblockJob(Job job);
    private void WriteJobResults(Job job);
    private void WriteReasonError(Job job);
    private Collection`1<T> ReadAll(PSDataCollection`1<T> psDataCollection);
    private void WriteJobResultsRecursivelyHelper(Hashtable duplicate, Job job, bool registerInsteadOfWrite);
    private void WriteJobsIfRequired(IEnumerable`1<Job> jobsToWrite);
    private void AggregateResultsFromJob(Job job);
    private void ResultsAdded(object sender, DataAddedEventArgs e);
    private void HandleJobStateChanged(object sender, JobStateEventArgs e);
    private void Progress_DataAdded(object sender, DataAddedEventArgs e);
    private void Error_DataAdded(object sender, DataAddedEventArgs e);
    private void Debug_DataAdded(object sender, DataAddedEventArgs e);
    private void Warning_DataAdded(object sender, DataAddedEventArgs e);
    private void Verbose_DataAdded(object sender, DataAddedEventArgs e);
    private void Information_DataAdded(object sender, DataAddedEventArgs e);
    private void Output_DataAdded(object sender, DataAddedEventArgs e);
    private T GetData(PSDataCollection`1<T> collection, int index);
    private void StopAggregateResultsFromJob(Job job);
    private void AutoRemoveJobIfRequired(Job job);
    private void AddRemoveErrorToResults(Job job, Exception ex);
    private void WriteJobResultsRecursively(Job job, bool registerInsteadOfWrite);
    private void WriteResultsForJobsInCollection(List`1<Job> jobs, bool checkForRecurse, bool registerInsteadOfWrite);
    private void WriteJobStateInformation(Job job, JobStateEventArgs args);
    private void WriteJobStateInformationIfRequired(Job job, JobStateEventArgs args);
    private void ValidateWait();
    private void ValidateWriteEvents();
    private void ValidateAutoRemove();
    private void ValidateForce();
    private void ValidateWriteJobInResults();
    private void SetOutputProcessingState(bool processingOutput);
}
[CmdletAttribute("Receive", "PSSession")]
public class Microsoft.PowerShell.Commands.ReceivePSSessionCommand : PSRemotingCmdlet {
    private static string IdParameterSet;
    private static string InstanceIdParameterSet;
    private static string NameParameterSet;
    private static string ComputerSessionNameParameterSet;
    private static string ConnectionUriSessionNameParameterSet;
    private static string ConnectionUriInstanceIdParameterSet;
    [CompilerGeneratedAttribute]
private PSSession <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    private string _appName;
    private string _shell;
    [CompilerGeneratedAttribute]
private Uri <ConnectionUri>k__BackingField;
    private bool _allowRedirection;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private OutTarget <OutTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private string <JobName>k__BackingField;
    private PSCredential _psCredential;
    private AuthenticationMechanism _authentication;
    private string _thumbprint;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <UseSSL>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSessionOption <SessionOption>k__BackingField;
    private bool _stopProcessing;
    private RemotePipeline _remotePipeline;
    private Job _job;
    private ManualResetEvent _stopPipelineReceive;
    private object _syncObject;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public PSSession Session { get; public set; }
    [ParameterAttribute]
public int Id { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string ComputerName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public string ApplicationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string ConfigurationName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Uri ConnectionUri { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter AllowRedirection { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Guid InstanceId { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public OutTarget OutTarget { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string JobName { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string CertificateThumbprint { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Port { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
public SwitchParameter UseSSL { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public PSSessionOption SessionOption { get; public set; }
    [CompilerGeneratedAttribute]
public PSSession get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(PSSession value);
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public void set_Id(int value);
    [CompilerGeneratedAttribute]
public string get_ComputerName();
    [CompilerGeneratedAttribute]
public void set_ComputerName(string value);
    public string get_ApplicationName();
    public void set_ApplicationName(string value);
    public string get_ConfigurationName();
    public void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
public Uri get_ConnectionUri();
    [CompilerGeneratedAttribute]
public void set_ConnectionUri(Uri value);
    public SwitchParameter get_AllowRedirection();
    public void set_AllowRedirection(SwitchParameter value);
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
public void set_InstanceId(Guid value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public OutTarget get_OutTarget();
    [CompilerGeneratedAttribute]
public void set_OutTarget(OutTarget value);
    [CompilerGeneratedAttribute]
public string get_JobName();
    [CompilerGeneratedAttribute]
public void set_JobName(string value);
    public PSCredential get_Credential();
    public void set_Credential(PSCredential value);
    public AuthenticationMechanism get_Authentication();
    public void set_Authentication(AuthenticationMechanism value);
    public string get_CertificateThumbprint();
    public void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_UseSSL();
    [CompilerGeneratedAttribute]
public void set_UseSSL(SwitchParameter value);
    [CompilerGeneratedAttribute]
public PSSessionOption get_SessionOption();
    [CompilerGeneratedAttribute]
public void set_SessionOption(PSSessionOption value);
    protected virtual void ProcessRecord();
    protected virtual void StopProcessing();
    private void QueryForAndConnectCommands(string name, Guid instanceId);
    private WSManConnectionInfo GetConnectionObject();
    private void UpdateConnectionInfo(WSManConnectionInfo connectionInfo);
    private void GetAndConnectSessionCommand();
    private bool CheckForDebugMode(PSSession session, bool monitorAvailabilityChange);
    private void HandleRunspaceAvailabilityChanged(object sender, RunspaceAvailabilityEventArgs e);
    private void DisconnectAndStopRunningCmds(RemoteRunspace remoteRunspace);
    private void WriteDebugStopWarning();
    private void ConnectSessionToHost(PSSession session, PSRemotingJob job);
    private void WriteRemoteObject(PSObject psObject, PSSession session);
    private void ConnectSessionToJob(PSSession session, PSRemotingJob job);
    private static PSSession ConnectSession(PSSession session, Exception& ex);
    private PSSession TryGetSessionFromServer(PSSession session);
    private PSRemotingJob FindJobForSession(PSSession session);
    private PSSession GetSessionById(int id);
    private PSSession GetSessionByName(string name);
    private PSSession GetSessionByInstanceId(Guid instanceId);
    private void WriteInvalidArgumentError(PSRemotingErrorId errorId, string resourceString, object errorArgument);
}
[CmdletAttribute("Register", "PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.RegisterPSSessionConfigurationCommand : PSSessionConfigurationCommandBase {
    private static string newPluginSbFormat;
    private static ScriptBlock s_newPluginSb;
    private static string pluginXmlFormat;
    private static string architectureAttribFormat;
    private static string sharedHostAttribFormat;
    private static string runasVirtualAccountAttribFormat;
    private static string runAsVirtualAccountGroupsAttribFormat;
    private static string allowRemoteShellAccessFormat;
    private static string initParamFormat;
    private static string privateDataFormat;
    private static string securityElementFormat;
    private static string SessionConfigDataFormat;
    private string _gmsaAccount;
    private string _configTableSDDL;
    private bool _isErrorReported;
    [CompilerGeneratedAttribute]
private string <ProcessorArchitecture>k__BackingField;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullOrEmptyAttribute]
[ValidateSetAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string ProcessorArchitecture { get; public set; }
    private static RegisterPSSessionConfigurationCommand();
    [CompilerGeneratedAttribute]
public string get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
public void set_ProcessorArchitecture(string value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private static void DeleteFile(string tmpFileName);
    private static string ConstructTemporaryFile(string pluginContent);
    private string ConstructPluginContent(String& srcConfigFilePath, String& destConfigFilePath);
}
[CmdletProviderAttribute("Registry", "16")]
[OutputTypeAttribute("System.String")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Microsoft.Win32.RegistryKey")]
[OutputTypeAttribute("System.Security.AccessControl.RegistrySecurity")]
[OutputTypeAttribute("Microsoft.Win32.RegistryKey")]
[OutputTypeAttribute("Microsoft.Win32.RegistryKey")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("Microsoft.Win32.RegistryKey")]
[OutputTypeAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
[OutputTypeAttribute("System.Management.Automation.PathInfo")]
public class Microsoft.PowerShell.Commands.RegistryProvider : NavigationCmdletProvider {
    [TraceSourceAttribute("RegistryProvider", "The namespace navigation provider for the Windows Registry")]
private static PSTraceSource s_tracer;
    public static string ProviderName;
    private static string charactersThatNeedEscaping;
    private static String[] s_hiveNames;
    private static String[] s_hiveShortNames;
    private static RegistryKey[] s_wellKnownHives;
    private static TransactedRegistryKey[] s_wellKnownHivesTx;
    public char AltItemSeparator { get; }
    private static string LocalizedDefaultToken { get; }
    private static RegistryProvider();
    public virtual char get_AltItemSeparator();
    protected virtual PSDriveInfo NewDrive(PSDriveInfo drive);
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    protected virtual bool IsValidPath(string path);
    protected virtual void GetItem(string path);
    protected virtual void SetItem(string path, object value);
    protected virtual object SetItemDynamicParameters(string path, object value);
    protected virtual void ClearItem(string path);
    protected virtual void GetChildItems(string path, bool recurse, UInt32 depth);
    protected virtual void GetChildNames(string path, ReturnContainers returnContainers);
    private static string EscapeSpecialChars(string path);
    private static string EscapeChildName(string name);
    protected virtual void RenameItem(string path, string newName);
    protected virtual void NewItem(string path, string type, object newItem);
    protected virtual void RemoveItem(string path, bool recurse);
    protected virtual bool ItemExists(string path);
    protected virtual bool HasChildItems(string path);
    protected virtual void CopyItem(string path, string destination, bool recurse);
    private bool CopyRegistryKey(IRegistryWrapper key, string path, string destination, bool recurse, bool streamResult, bool streamFirstOnly);
    private bool ErrorIfDestinationIsSourceOrChildOfSource(string sourcePath, string destinationPath);
    protected virtual bool IsItemContainer(string path);
    protected virtual void MoveItem(string path, string destination);
    private void MoveRegistryItem(string path, string destination);
    public sealed virtual void GetProperty(string path, Collection`1<string> providerSpecificPickList);
    public sealed virtual void SetProperty(string path, PSObject propertyValue);
    public sealed virtual object SetPropertyDynamicParameters(string path, PSObject propertyValue);
    public sealed virtual void ClearProperty(string path, Collection`1<string> propertyToClear);
    public sealed virtual object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList);
    public sealed virtual object ClearPropertyDynamicParameters(string path, Collection`1<string> propertyToClear);
    public sealed virtual void NewProperty(string path, string propertyName, string type, object value);
    public sealed virtual void RemoveProperty(string path, string propertyName);
    public sealed virtual void RenameProperty(string path, string sourceProperty, string destinationProperty);
    public sealed virtual void CopyProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public sealed virtual void MoveProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    protected virtual string GetParentPath(string path, string root);
    protected virtual string GetChildName(string path);
    private static string EnsureDriveIsRooted(string path);
    public sealed virtual object NewPropertyDynamicParameters(string path, string propertyName, string type, object value);
    public sealed virtual object RemovePropertyDynamicParameters(string path, string propertyName);
    public sealed virtual object RenamePropertyDynamicParameters(string path, string sourceProperty, string destinationProperty);
    public sealed virtual object CopyPropertyDynamicParameters(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public sealed virtual object MovePropertyDynamicParameters(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    private void CopyProperty(IRegistryWrapper sourceKey, IRegistryWrapper destinationKey, string sourceProperty, string destinationProperty, bool writeOnSuccess);
    private void MoveProperty(IRegistryWrapper sourceKey, IRegistryWrapper destinationKey, string sourceProperty, string destinationProperty);
    private string NormalizePath(string path);
    private static bool HasRelativePathTokens(string path);
    private void GetFilteredRegistryKeyProperties(string path, Collection`1<string> propertyNames, bool getAll, bool writeAccess, IRegistryWrapper& key, Collection`1& filteredCollection);
    private void WriteErrorIfPerfectMatchNotFound(bool hadAMatch, string path, string requestedValueName);
    private object ResetRegistryKeyValue(IRegistryWrapper key, string valueName);
    private static bool IsHiveContainer(string path);
    private bool CheckOperationNotAllowedOnHiveContainer(string path);
    private bool CheckOperationNotAllowedOnHiveContainer(string sourcePath, string destinationPath);
    private IRegistryWrapper GetHiveRoot(string path);
    private bool CreateIntermediateKeys(string path);
    private IRegistryWrapper GetRegkeyForPathWriteIfError(string path, bool writeAccess);
    private IRegistryWrapper GetRegkeyForPath(string path, bool writeAccess);
    private void SetRegistryValue(IRegistryWrapper key, string propertyName, object value, RegistryValueKind kind, string path);
    private void SetRegistryValue(IRegistryWrapper key, string propertyName, object value, RegistryValueKind kind, string path, bool writeResult);
    private void WriteWrappedPropertyObject(object value, string propertyName, string path);
    private static object ConvertValueToKind(object value, RegistryValueKind kind);
    private static RegistryValueKind GetValueKindFromObject(object value);
    private static RegistryValueKind GetValueKindForProperty(IRegistryWrapper key, string valueName);
    private static object ReadExistingKeyValue(IRegistryWrapper key, string valueName);
    private void WriteRegistryItemObject(IRegistryWrapper key, string path);
    private bool ParseKind(string type, RegistryValueKind& kind);
    private static string get_LocalizedDefaultToken();
    private string GetPropertyName(string userEnteredPropertyName);
    public sealed virtual void GetSecurityDescriptor(string path, AccessControlSections sections);
    public sealed virtual void SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor);
    public sealed virtual ObjectSecurity NewSecurityDescriptorFromPath(string path, AccessControlSections sections);
    public sealed virtual ObjectSecurity NewSecurityDescriptorOfType(string type, AccessControlSections sections);
}
public class Microsoft.PowerShell.Commands.RegistryProviderSetItemDynamicParameter : object {
    [CompilerGeneratedAttribute]
private RegistryValueKind <Type>k__BackingField;
    [ParameterAttribute]
public RegistryValueKind Type { get; public set; }
    [CompilerGeneratedAttribute]
public RegistryValueKind get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(RegistryValueKind value);
}
internal class Microsoft.PowerShell.Commands.RegistryWrapper : object {
    private RegistryKey _regKey;
    public string Name { get; }
    public int SubKeyCount { get; }
    public object RegistryKey { get; }
    internal RegistryWrapper(RegistryKey regKey);
    public sealed virtual void SetValue(string name, object value);
    public sealed virtual void SetValue(string name, object value, RegistryValueKind valueKind);
    public sealed virtual String[] GetValueNames();
    public sealed virtual void DeleteValue(string name);
    public sealed virtual String[] GetSubKeyNames();
    public sealed virtual IRegistryWrapper CreateSubKey(string subkey);
    public sealed virtual IRegistryWrapper OpenSubKey(string name, bool writable);
    public sealed virtual void DeleteSubKeyTree(string subkey);
    public sealed virtual object GetValue(string name);
    public sealed virtual object GetValue(string name, object defaultValue, RegistryValueOptions options);
    public sealed virtual RegistryValueKind GetValueKind(string name);
    public sealed virtual void Close();
    public sealed virtual string get_Name();
    public sealed virtual int get_SubKeyCount();
    public sealed virtual object get_RegistryKey();
    public sealed virtual void SetAccessControl(ObjectSecurity securityDescriptor);
    public sealed virtual ObjectSecurity GetAccessControl(AccessControlSections includeSections);
}
internal static class Microsoft.PowerShell.Commands.RegistryWrapperUtils : object {
    public static object ConvertValueToUIntFromRegistryIfNeeded(string name, object value, RegistryValueKind kind);
    public static object ConvertUIntToValueForRegistryIfNeeded(object value, RegistryValueKind kind);
}
internal static class Microsoft.PowerShell.Commands.RemotingCommandUtil : object {
    internal static bool HasRepeatingRunspaces(PSSession[] runspaceInfos);
    internal static bool ExceedMaximumAllowableRunspaces(PSSession[] runspaceInfos);
    internal static void CheckRemotingCmdletPrerequisites();
    internal static void CheckHostRemotingPrerequisites();
}
[CmdletAttribute("Remove", "Job")]
[OutputTypeAttribute("System.Management.Automation.Job")]
public class Microsoft.PowerShell.Commands.RemoveJobCommand : JobCmdletBase {
    private Job[] _jobs;
    private bool _force;
    private HashSet`1<Guid> _pendingJobs;
    private ManualResetEvent _waitForJobs;
    private Dictionary`2<Job2, EventHandler`1<AsyncCompletedEventArgs>> _cleanUpActions;
    private object _syncObject;
    private bool _needToCheckForWaitingJobs;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Job[] Job { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Force { get; public set; }
    public Job[] get_Job();
    public void set_Job(Job[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private void RemoveJobAndDispose(Job job, bool jobIsJob2);
    private void HandleStopJobCompleted(object sender, AsyncCompletedEventArgs eventArgs);
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
}
[CmdletAttribute("Remove", "Module")]
public class Microsoft.PowerShell.Commands.RemoveModuleCommand : ModuleCmdletBase {
    private String[] _name;
    [CompilerGeneratedAttribute]
private ModuleSpecification[] <FullyQualifiedName>k__BackingField;
    private PSModuleInfo[] _moduleInfo;
    private int _numberRemoved;
    [ParameterAttribute]
public String[] Name { get; public set; }
    [ParameterAttribute]
public ModuleSpecification[] FullyQualifiedName { get; public set; }
    [ParameterAttribute]
public PSModuleInfo[] ModuleInfo { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public String[] get_Name();
    public void set_Name(String[] value);
    [CompilerGeneratedAttribute]
public ModuleSpecification[] get_FullyQualifiedName();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedName(ModuleSpecification[] value);
    public PSModuleInfo[] get_ModuleInfo();
    public void set_ModuleInfo(PSModuleInfo[] value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    protected virtual void ProcessRecord();
    private bool ModuleProvidesCurrentSessionDrive(PSModuleInfo module);
    private static void GetAllNestedModules(PSModuleInfo module, List`1& nestedModulesWithNoCircularReference);
    private Dictionary`2<PSModuleInfo, List`1<PSModuleInfo>> GetRequiredDependencies();
    protected virtual void EndProcessing();
}
[CmdletAttribute("Remove", "PSSession")]
public class Microsoft.PowerShell.Commands.RemovePSSessionCommand : PSRunspaceCmdlet {
    [CompilerGeneratedAttribute]
private PSSession[] <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid[] <VMId>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <VMName>k__BackingField;
    [ParameterAttribute]
public PSSession[] Session { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] ContainerId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Guid[] VMId { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public String[] VMName { get; public set; }
    [CompilerGeneratedAttribute]
public PSSession[] get_Session();
    [CompilerGeneratedAttribute]
public void set_Session(PSSession[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_ContainerId();
    [CompilerGeneratedAttribute]
public virtual void set_ContainerId(String[] value);
    [CompilerGeneratedAttribute]
public virtual Guid[] get_VMId();
    [CompilerGeneratedAttribute]
public virtual void set_VMId(Guid[] value);
    [CompilerGeneratedAttribute]
public virtual String[] get_VMName();
    [CompilerGeneratedAttribute]
public virtual void set_VMName(String[] value);
    protected virtual void ProcessRecord();
}
internal enum Microsoft.PowerShell.Commands.RunspaceParameterSet : Enum {
    public int value__;
    public static RunspaceParameterSet ComputerName;
    public static RunspaceParameterSet Runspace;
}
internal static class Microsoft.PowerShell.Commands.SafeInvokeCommand : object {
    public static Hashtable Invoke(PowerShell ps, FileSystemProvider fileSystemContext, CmdletProviderContext cmdletContext);
    public static Hashtable Invoke(PowerShell ps, FileSystemProvider fileSystemContext, CmdletProviderContext cmdletContext, bool shouldHaveOutput);
}
[CmdletAttribute("Save", "Help")]
public class Microsoft.PowerShell.Commands.SaveHelpCommand : UpdatableHelpCommandBase {
    private bool _alreadyCheckedOncePerDayPerModule;
    private String[] _path;
    private bool _isLiteralPath;
    [CompilerGeneratedAttribute]
private PSModuleInfo[] <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleSpecification[] <FullyQualifiedModule>k__BackingField;
    [ParameterAttribute]
[ValidateNotNullAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] DestinationPath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullAttribute]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullAttribute]
[ArgumentToModuleTransformationAttribute]
public PSModuleInfo[] Module { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public ModuleSpecification[] FullyQualifiedModule { get; public set; }
    public String[] get_DestinationPath();
    public void set_DestinationPath(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    [CompilerGeneratedAttribute]
public PSModuleInfo[] get_Module();
    [CompilerGeneratedAttribute]
public void set_Module(PSModuleInfo[] value);
    [CompilerGeneratedAttribute]
public ModuleSpecification[] get_FullyQualifiedModule();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedModule(ModuleSpecification[] value);
    protected virtual void ProcessRecord();
    internal virtual bool ProcessModuleWithCulture(UpdatableHelpModuleInfo module, string culture);
}
internal static class Microsoft.PowerShell.Commands.SessionConfigurationUtils : object {
    internal static string ConfigFragment(string key, string resourceString, string value, StreamWriter streamWriter, bool isExample);
    internal static string QuoteName(object name);
    internal static string WrapScriptBlock(object sb);
    internal static string WriteBoolean(bool booleanToEmit);
    internal static string WriteLong(long longToEmit);
    internal static string GetVisibilityDefault(Object[] values, StreamWriter writer, PSCmdlet caller);
    internal static string CombineHashtable(IDictionary table, StreamWriter writer, Nullable`1<int> indent);
    internal static string CombineRequiredGroupsHash(IDictionary table);
    private static void WriteRequiredGroup(object value, StringBuilder sb);
    internal static string CombineHashtableArray(IDictionary[] tables, StreamWriter writer, Nullable`1<int> indent);
    internal static string CombineStringArray(String[] values);
    internal static string CombineHashTableOrStringArray(Object[] values, StreamWriter writer, PSCmdlet caller);
}
public enum Microsoft.PowerShell.Commands.SessionFilterState : Enum {
    public int value__;
    public static SessionFilterState All;
    public static SessionFilterState Opened;
    public static SessionFilterState Disconnected;
    public static SessionFilterState Closed;
    public static SessionFilterState Broken;
}
public abstract class Microsoft.PowerShell.Commands.SessionStateProviderBase : ContainerCmdletProvider {
    [TraceSourceAttribute("SessionStateProvider", "Providers that produce a view of session state data.")]
private static PSTraceSource s_tracer;
    private static SessionStateProviderBase();
    internal abstract virtual object GetSessionStateItem(string name);
    internal abstract virtual void SetSessionStateItem(string name, object value, bool writeItem);
    internal abstract virtual void RemoveSessionStateItem(string name);
    internal abstract virtual IDictionary GetSessionStateTable();
    internal virtual object GetValueOfItem(object item);
    internal virtual bool CanRenameItem(object item);
    protected virtual void GetItem(string name);
    protected virtual void SetItem(string name, object value);
    protected virtual void ClearItem(string path);
    protected virtual void GetChildItems(string path, bool recurse);
    protected virtual void GetChildNames(string path, ReturnContainers returnContainers);
    protected virtual bool HasChildItems(string path);
    protected virtual bool ItemExists(string path);
    protected virtual bool IsValidPath(string path);
    protected virtual void RemoveItem(string path, bool recurse);
    protected virtual void NewItem(string path, string type, object newItem);
    protected virtual void CopyItem(string path, string copyPath, bool recurse);
    protected virtual void RenameItem(string name, string newName);
    public sealed virtual IContentReader GetContentReader(string path);
    public sealed virtual IContentWriter GetContentWriter(string path);
    public sealed virtual void ClearContent(string path);
    public sealed virtual object GetContentReaderDynamicParameters(string path);
    public sealed virtual object GetContentWriterDynamicParameters(string path);
    public sealed virtual object ClearContentDynamicParameters(string path);
}
public class Microsoft.PowerShell.Commands.SessionStateProviderBaseContentReaderWriter : object {
    private string _path;
    private SessionStateProviderBase _provider;
    private bool _contentRead;
    internal SessionStateProviderBaseContentReaderWriter(string path, SessionStateProviderBase provider);
    public sealed virtual IList Read(long readCount);
    public sealed virtual IList Write(IList content);
    public sealed virtual void Seek(long offset, SeekOrigin origin);
    public sealed virtual void Close();
    public sealed virtual void Dispose();
}
[CmdletAttribute("Set", "PSDebug")]
public class Microsoft.PowerShell.Commands.SetPSDebugCommand : PSCmdlet {
    private int _trace;
    private Nullable`1<bool> _step;
    private Nullable`1<bool> _strict;
    private bool _off;
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Trace { get; public set; }
    [ParameterAttribute]
public SwitchParameter Step { get; public set; }
    [ParameterAttribute]
public SwitchParameter Strict { get; public set; }
    [ParameterAttribute]
public SwitchParameter Off { get; public set; }
    public int get_Trace();
    public void set_Trace(int value);
    public SwitchParameter get_Step();
    public void set_Step(SwitchParameter value);
    public SwitchParameter get_Strict();
    public void set_Strict(SwitchParameter value);
    public SwitchParameter get_Off();
    public void set_Off(SwitchParameter value);
    protected virtual void BeginProcessing();
}
[CmdletAttribute("Set", "PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.SetPSSessionConfigurationCommand : PSSessionConfigurationCommandBase {
    private static string getSessionTypeFormat;
    private static string getCurrentIdleTimeoutmsFormat;
    private static string getAssemblyNameDataFormat;
    private static string getSessionConfigurationDataSbFormat;
    private static string setSessionConfigurationDataSbFormat;
    private static string setSessionConfigurationQuotaSbFormat;
    private static string setSessionConfigurationTimeoutQuotasSbFormat;
    private static string setSessionConfigurationOptionsSbFormat;
    private static string setRunAsSbFormat;
    private static string setPluginSbFormat;
    private static string initParamFormat;
    private static string privateDataFormat;
    private static string SessionConfigDataFormat;
    private static string UseSharedProcessToken;
    private static string AllowRemoteAccessToken;
    private static ScriptBlock s_setPluginSb;
    private static String[] s_initParametersMap;
    private bool _isErrorReported;
    private Hashtable _configTable;
    private string _configFilePath;
    private string _gmsaAccount;
    private string _configSddl;
    private static SetPSSessionConfigurationCommand();
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private void SetRunAs();
    private void SetVirtualAccount();
    private void SetQuotas();
    private void SetOptions();
    private void SetSessionConfigurationTypeOptions();
    protected virtual void EndProcessing();
    private PSObject ConstructPropertiesForUpdate();
}
[CmdletAttribute("Set", "StrictMode")]
public class Microsoft.PowerShell.Commands.SetStrictModeCommand : PSCmdlet {
    private SwitchParameter _off;
    private Version _version;
    [ParameterAttribute]
public SwitchParameter Off { get; public set; }
    [ParameterAttribute]
[ArgumentToPSVersionTransformationAttribute]
[ValidateVersionAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Version Version { get; public set; }
    public SwitchParameter get_Off();
    public void set_Off(SwitchParameter value);
    public Version get_Version();
    public void set_Version(Version value);
    protected virtual void EndProcessing();
}
internal class Microsoft.PowerShell.Commands.SSHConnection : ValueType {
    public string ComputerName;
    public string UserName;
    public string KeyFilePath;
    public int Port;
    public string Subsystem;
    public int ConnectingTimeout;
    public Hashtable Options;
}
[CmdletAttribute("Start", "Job")]
[OutputTypeAttribute("System.Management.Automation.PSRemotingJob")]
public class Microsoft.PowerShell.Commands.StartJobCommand : PSExecutionCmdlet {
    private static string s_startJobType;
    private static string DefinitionNameParameterSet;
    private string _definitionName;
    private string _definitionPath;
    private string _definitionType;
    private string _name;
    private ScriptBlock _initScript;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <RunAs32>k__BackingField;
    private Version _psVersion;
    private bool _firstProcessRecord;
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
[ValidateNotNullOrEmptyAttribute]
public string DefinitionName { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string DefinitionPath { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Type { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ScriptBlock ScriptBlock { get; public set; }
    public PSSession[] Session { get; }
    public String[] ComputerName { get; }
    public SwitchParameter EnableNetworkAccess { get; }
    public SwitchParameter SSHTransport { get; }
    public Hashtable[] SSHConnection { get; }
    public string UserName { get; }
    public string KeyFilePath { get; }
    public String[] HostName { get; }
    public string Subsystem { get; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    public int Port { get; }
    public SwitchParameter UseSSL { get; }
    public string ConfigurationName { get; public set; }
    public int ThrottleLimit { get; }
    public string ApplicationName { get; }
    public Uri[] ConnectionUri { get; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
public string FilePath { get; public set; }
    [ParameterAttribute]
[ValidateTrustedDataAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public string LiteralPath { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public AuthenticationMechanism Authentication { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public SwitchParameter AllowRedirection { get; }
    public Guid[] VMId { get; }
    public String[] VMName { get; }
    public String[] ContainerId { get; }
    public SwitchParameter RunAsAdministrator { get; }
    public PSSessionOption SessionOption { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateTrustedDataAttribute]
public ScriptBlock InitializationScript { get; public set; }
    [ParameterAttribute]
[ValidateNotNullOrWhiteSpaceAttribute]
public string WorkingDirectory { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public SwitchParameter RunAs32 { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Version PSVersion { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateTrustedDataAttribute]
public PSObject InputObject { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateTrustedDataAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Object[] ArgumentList { get; public set; }
    private static StartJobCommand();
    public string get_DefinitionName();
    public void set_DefinitionName(string value);
    public string get_DefinitionPath();
    public void set_DefinitionPath(string value);
    public string get_Type();
    public void set_Type(string value);
    public virtual string get_Name();
    public virtual void set_Name(string value);
    public virtual ScriptBlock get_ScriptBlock();
    public virtual void set_ScriptBlock(ScriptBlock value);
    public virtual PSSession[] get_Session();
    public virtual String[] get_ComputerName();
    public virtual SwitchParameter get_EnableNetworkAccess();
    public virtual SwitchParameter get_SSHTransport();
    public virtual Hashtable[] get_SSHConnection();
    public virtual string get_UserName();
    public virtual string get_KeyFilePath();
    public virtual String[] get_HostName();
    public virtual string get_Subsystem();
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual int get_Port();
    public virtual SwitchParameter get_UseSSL();
    public virtual string get_ConfigurationName();
    public virtual void set_ConfigurationName(string value);
    public virtual int get_ThrottleLimit();
    public virtual string get_ApplicationName();
    public virtual Uri[] get_ConnectionUri();
    public virtual string get_FilePath();
    public virtual void set_FilePath(string value);
    public string get_LiteralPath();
    public void set_LiteralPath(string value);
    public virtual AuthenticationMechanism get_Authentication();
    public virtual void set_Authentication(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public virtual SwitchParameter get_AllowRedirection();
    public virtual Guid[] get_VMId();
    public virtual String[] get_VMName();
    public virtual String[] get_ContainerId();
    public virtual SwitchParameter get_RunAsAdministrator();
    public virtual PSSessionOption get_SessionOption();
    public virtual void set_SessionOption(PSSessionOption value);
    public virtual ScriptBlock get_InitializationScript();
    public virtual void set_InitializationScript(ScriptBlock value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public virtual SwitchParameter get_RunAs32();
    [CompilerGeneratedAttribute]
public virtual void set_RunAs32(SwitchParameter value);
    public virtual Version get_PSVersion();
    public virtual void set_PSVersion(Version value);
    public virtual PSObject get_InputObject();
    public virtual void set_InputObject(PSObject value);
    public virtual Object[] get_ArgumentList();
    public virtual void set_ArgumentList(Object[] value);
    protected virtual void BeginProcessing();
    protected virtual void CreateHelpersForSpecifiedComputerNames();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
[CmdletAttribute("Stop", "Job")]
[OutputTypeAttribute("System.Management.Automation.Job")]
public class Microsoft.PowerShell.Commands.StopJobCommand : JobCmdletBase {
    private Job[] _jobs;
    private bool _passThru;
    private HashSet`1<Guid> _pendingJobs;
    private ManualResetEvent _waitForJobs;
    private Dictionary`2<Job2, EventHandler`1<AsyncCompletedEventArgs>> _cleanUpActions;
    private List`1<Job> _allJobsToStop;
    private List`1<ErrorRecord> _errorsToWrite;
    private object _syncObject;
    private bool _needToCheckForWaitingJobs;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Job[] Job { get; public set; }
    [ParameterAttribute]
public SwitchParameter PassThru { get; public set; }
    public String[] Command { get; }
    public Job[] get_Job();
    public void set_Job(Job[] value);
    public SwitchParameter get_PassThru();
    public void set_PassThru(SwitchParameter value);
    public virtual String[] get_Command();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
    private void HandleStopJobCompleted(object sender, AsyncCompletedEventArgs eventArgs);
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
}
[CmdletAttribute("Test", "ModuleManifest")]
[OutputTypeAttribute("System.Management.Automation.PSModuleInfo")]
public class Microsoft.PowerShell.Commands.TestModuleManifestCommand : ModuleCmdletBase {
    private string _path;
    private static IReadOnlyList`1<string> s_validRootModuleExtensions;
    [ParameterAttribute]
public string Path { get; public set; }
    private static TestModuleManifestCommand();
    public string get_Path();
    public void set_Path(string value);
    protected virtual void ProcessRecord();
    private bool HasValidRootModule(PSModuleInfo module);
    private bool IsValidFilePath(string path, PSModuleInfo module, bool verifyPathScope);
    private static bool IsValidGacAssembly(string assemblyName);
}
[CmdletAttribute("Test", "PSSessionConfigurationFile")]
[OutputTypeAttribute("System.Boolean")]
public class Microsoft.PowerShell.Commands.TestPSSessionConfigurationFileCommand : PSCmdlet {
    private string _path;
    [ParameterAttribute]
public string Path { get; public set; }
    public string get_Path();
    public void set_Path(string value);
    protected virtual void ProcessRecord();
}
internal class Microsoft.PowerShell.Commands.TransactedRegistryWrapper : object {
    private TransactedRegistryKey _txRegKey;
    private CmdletProvider _provider;
    public string Name { get; }
    public int SubKeyCount { get; }
    public object RegistryKey { get; }
    internal TransactedRegistryWrapper(TransactedRegistryKey txRegKey, CmdletProvider provider);
    public sealed virtual void SetValue(string name, object value);
    public sealed virtual void SetValue(string name, object value, RegistryValueKind valueKind);
    public sealed virtual String[] GetValueNames();
    public sealed virtual void DeleteValue(string name);
    public sealed virtual String[] GetSubKeyNames();
    public sealed virtual IRegistryWrapper CreateSubKey(string subkey);
    public sealed virtual IRegistryWrapper OpenSubKey(string name, bool writable);
    public sealed virtual void DeleteSubKeyTree(string subkey);
    public sealed virtual object GetValue(string name);
    public sealed virtual object GetValue(string name, object defaultValue, RegistryValueOptions options);
    public sealed virtual RegistryValueKind GetValueKind(string name);
    public sealed virtual void Close();
    public sealed virtual string get_Name();
    public sealed virtual int get_SubKeyCount();
    public sealed virtual object get_RegistryKey();
    public sealed virtual void SetAccessControl(ObjectSecurity securityDescriptor);
    public sealed virtual ObjectSecurity GetAccessControl(AccessControlSections includeSections);
}
[CmdletAttribute("Unregister", "PSSessionConfiguration")]
public class Microsoft.PowerShell.Commands.UnregisterPSSessionConfigurationCommand : PSCmdlet {
    private static string removePluginSbFormat;
    private static ScriptBlock s_removePluginSb;
    private bool _isErrorReported;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private bool _force;
    private bool _noRestart;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Name { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public SwitchParameter NoServiceRestart { get; public set; }
    private static UnregisterPSSessionConfigurationCommand();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    public SwitchParameter get_NoServiceRestart();
    public void set_NoServiceRestart(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
}
public class Microsoft.PowerShell.Commands.UpdatableHelpCommandBase : PSCmdlet {
    internal static string PathParameterSetName;
    internal static string LiteralPathParameterSetName;
    internal UpdatableHelpCommandType _commandType;
    internal UpdatableHelpSystem _helpSystem;
    internal bool _stopping;
    internal int activityId;
    private Dictionary`2<string, UpdatableHelpExceptionContext> _exceptions;
    internal String[] _language;
    internal PSCredential _credential;
    private bool _useDefaultCredentials;
    internal bool _force;
    [CompilerGeneratedAttribute]
private UpdateHelpScope <Scope>k__BackingField;
    private static Dictionary`2<string, string> s_metadataCache;
    [ParameterAttribute]
[ValidateNotNullAttribute]
public CultureInfo[] UICulture { get; public set; }
    [ParameterAttribute]
[CredentialAttribute]
public PSCredential Credential { get; public set; }
    [ParameterAttribute]
public SwitchParameter UseDefaultCredentials { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    [ParameterAttribute]
public UpdateHelpScope Scope { get; public set; }
    private static UpdatableHelpCommandBase();
    internal UpdatableHelpCommandBase(UpdatableHelpCommandType commandType);
    public CultureInfo[] get_UICulture();
    public void set_UICulture(CultureInfo[] value);
    public PSCredential get_Credential();
    public void set_Credential(PSCredential value);
    public SwitchParameter get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(SwitchParameter value);
    public SwitchParameter get_Force();
    public void set_Force(SwitchParameter value);
    [CompilerGeneratedAttribute]
public UpdateHelpScope get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(UpdateHelpScope value);
    private void HandleProgressChanged(object sender, UpdatableHelpProgressEventArgs e);
    internal static bool IsSystemModule(string module);
    private void ProcessSingleModuleObject(PSModuleInfo module, ExecutionContext context, Dictionary`2<Tuple`2<string, Version>, UpdatableHelpModuleInfo> helpModules, bool noErrors);
    private Dictionary`2<Tuple`2<string, Version>, UpdatableHelpModuleInfo> GetModuleInfo(ExecutionContext context, string pattern, ModuleSpecification fullyQualifiedName, bool noErrors);
    protected virtual void StopProcessing();
    protected virtual void EndProcessing();
    internal void Process(IEnumerable`1<string> moduleNames, IEnumerable`1<ModuleSpecification> fullyQualifiedNames);
    internal void Process(IEnumerable`1<PSModuleInfo> modules);
    private void ProcessModuleWithGlobbing(string name);
    private void ProcessModuleWithGlobbing(ModuleSpecification fullyQualifiedName);
    private void ProcessModule(UpdatableHelpModuleInfo module);
    internal virtual bool ProcessModuleWithCulture(UpdatableHelpModuleInfo module, string culture);
    internal Dictionary`2<Tuple`2<string, Version>, UpdatableHelpModuleInfo> GetModuleInfo(string pattern, ModuleSpecification fullyQualifiedName, bool noErrors);
    internal bool IsUpdateNecessary(UpdatableHelpModuleInfo module, UpdatableHelpInfo currentHelpInfo, UpdatableHelpInfo newHelpInfo, CultureInfo culture, bool force);
    internal bool CheckOncePerDayPerModule(string moduleName, string path, string filename, DateTime time, bool force);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.UpdatableHelpCommandBase/<ResolvePath>d__45")]
internal IEnumerable`1<string> ResolvePath(string path, bool recurse, bool isLiteralPath);
    [IteratorStateMachineAttribute("Microsoft.PowerShell.Commands.UpdatableHelpCommandBase/<RecursiveResolvePathHelper>d__46")]
private static IEnumerable`1<string> RecursiveResolvePathHelper(string path);
    internal void ValidatePathProvider(PathInfo path);
    internal void LogMessage(string message);
    internal void ProcessException(string moduleName, string culture, Exception e);
}
[CmdletAttribute("Update", "Help")]
public class Microsoft.PowerShell.Commands.UpdateHelpCommand : UpdatableHelpCommandBase {
    private bool _alreadyCheckedOncePerDayPerModule;
    private String[] _module;
    [CompilerGeneratedAttribute]
private ModuleSpecification[] <FullyQualifiedModule>k__BackingField;
    private String[] _path;
    private bool _isLiteralPath;
    private bool _recurse;
    private bool _isInitialized;
    [ParameterAttribute]
[ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullAttribute]
public String[] Module { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullAttribute]
public ModuleSpecification[] FullyQualifiedModule { get; public set; }
    [ParameterAttribute]
[ValidateNotNullAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public String[] SourcePath { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateNotNullAttribute]
public String[] LiteralPath { get; public set; }
    [ParameterAttribute]
public SwitchParameter Recurse { get; public set; }
    public String[] get_Module();
    public void set_Module(String[] value);
    [CompilerGeneratedAttribute]
public ModuleSpecification[] get_FullyQualifiedModule();
    [CompilerGeneratedAttribute]
public void set_FullyQualifiedModule(ModuleSpecification[] value);
    public String[] get_SourcePath();
    public void set_SourcePath(String[] value);
    public String[] get_LiteralPath();
    public void set_LiteralPath(String[] value);
    public SwitchParameter get_Recurse();
    public void set_Recurse(SwitchParameter value);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    internal virtual bool ProcessModuleWithCulture(UpdatableHelpModuleInfo module, string culture);
    private static void ThrowPathMustBeValidContainersException(string path, Exception e);
}
public enum Microsoft.PowerShell.Commands.UpdateHelpScope : Enum {
    public int value__;
    public static UpdateHelpScope CurrentUser;
    public static UpdateHelpScope AllUsers;
}
[CmdletProviderAttribute("Variable", "16")]
[OutputTypeAttribute("System.Management.Automation.PSVariable")]
[OutputTypeAttribute("System.Management.Automation.PSVariable")]
[OutputTypeAttribute("System.Management.Automation.PSVariable")]
[OutputTypeAttribute("System.Management.Automation.PSVariable")]
[OutputTypeAttribute("System.Management.Automation.PSVariable")]
public class Microsoft.PowerShell.Commands.VariableProvider : SessionStateProviderBase {
    public static string ProviderName;
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
    internal virtual object GetSessionStateItem(string name);
    internal virtual void SetSessionStateItem(string name, object value, bool writeItem);
    internal virtual void RemoveSessionStateItem(string name);
    internal virtual IDictionary GetSessionStateTable();
    internal virtual object GetValueOfItem(object item);
    internal virtual bool CanRenameItem(object item);
}
[CmdletAttribute("Wait", "Job")]
[OutputTypeAttribute("System.Management.Automation.Job")]
public class Microsoft.PowerShell.Commands.WaitJobCommand : JobCmdletBase {
    [CompilerGeneratedAttribute]
private Job[] <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Any>k__BackingField;
    private int _timeoutInSeconds;
    [CompilerGeneratedAttribute]
private SwitchParameter <Force>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Command>k__BackingField;
    private object _endProcessingActionLock;
    private Action _endProcessingAction;
    private ManualResetEventSlim _endProcessingActionIsReady;
    private HashSet`1<Job> _finishedJobs;
    private HashSet`1<Job> _blockedJobs;
    private List`1<Job> _jobsToWaitFor;
    private object _jobTrackingLock;
    private Timer _timer;
    private object _timerLock;
    private bool _isDisposed;
    private object _disposableLock;
    private bool _warnNotTerminal;
    [ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public Job[] Job { get; public set; }
    [ParameterAttribute]
public SwitchParameter Any { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
public int Timeout { get; public set; }
    [ParameterAttribute]
public SwitchParameter Force { get; public set; }
    public String[] Command { get; public set; }
    [CompilerGeneratedAttribute]
public Job[] get_Job();
    [CompilerGeneratedAttribute]
public void set_Job(Job[] value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Any();
    [CompilerGeneratedAttribute]
public void set_Any(SwitchParameter value);
    public int get_Timeout();
    public void set_Timeout(int value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Force();
    [CompilerGeneratedAttribute]
public void set_Force(SwitchParameter value);
    [CompilerGeneratedAttribute]
public virtual String[] get_Command();
    [CompilerGeneratedAttribute]
public virtual void set_Command(String[] value);
    private void SetEndProcessingAction(Action endProcessingAction);
    private void InvokeEndProcessingAction();
    private void CleanUpEndProcessing();
    private void HandleJobStateChangedEvent(object source, JobStateEventArgs eventArgs);
    private void AddJobsThatNeedJobChangesTracking(IEnumerable`1<Job> jobsToAdd);
    private void StartJobChangesTracking();
    private void CleanUpJobChangesTracking();
    private List`1<Job> GetFinishedJobs();
    private Job GetOneBlockedJob();
    private void StartTimeoutTracking(int timeoutInSeconds);
    private void CleanUpTimeoutTracking();
    protected virtual void StopProcessing();
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    private void EndProcessingOutputSingleFinishedJob();
    private void EndProcessingOutputAllFinishedJobs();
    private void EndProcessingBlockedJobsError();
    private void EndProcessingDoNothing();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private bool <GetFinishedJobs>b__34_0(Job j);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <StartTimeoutTracking>b__38_0(object _);
}
[CmdletAttribute("Where", "Object")]
public class Microsoft.PowerShell.Commands.WhereObjectCommand : PSCmdlet {
    private PSObject _inputObject;
    private ScriptBlock _script;
    private string _property;
    private object _convertedValue;
    private object _value;
    private bool _valueNotSpecified;
    private TokenKind _binaryOperator;
    private bool _forceBooleanEvaluation;
    private CallSite`1<Func`3<CallSite, object, bool>> _toBoolSite;
    private Func`3<object, object, object> _operationDelegate;
    private DynamicPropertyGetter _propGetter;
    [ParameterAttribute]
public PSObject InputObject { get; public set; }
    [ParameterAttribute]
public ScriptBlock FilterScript { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ValidateNotNullOrEmptyAttribute]
public string Property { get; public set; }
    [ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
[ParameterAttribute]
public object Value { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter EQ { get; public set; }
    [ParameterAttribute]
public SwitchParameter CEQ { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NE { get; public set; }
    [ParameterAttribute]
public SwitchParameter CNE { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter GT { get; public set; }
    [ParameterAttribute]
public SwitchParameter CGT { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter LT { get; public set; }
    [ParameterAttribute]
public SwitchParameter CLT { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter GE { get; public set; }
    [ParameterAttribute]
public SwitchParameter CGE { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter LE { get; public set; }
    [ParameterAttribute]
public SwitchParameter CLE { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Like { get; public set; }
    [ParameterAttribute]
public SwitchParameter CLike { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NotLike { get; public set; }
    [ParameterAttribute]
public SwitchParameter CNotLike { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Match { get; public set; }
    [ParameterAttribute]
public SwitchParameter CMatch { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NotMatch { get; public set; }
    [ParameterAttribute]
public SwitchParameter CNotMatch { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Contains { get; public set; }
    [ParameterAttribute]
public SwitchParameter CContains { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NotContains { get; public set; }
    [ParameterAttribute]
public SwitchParameter CNotContains { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter In { get; public set; }
    [ParameterAttribute]
public SwitchParameter CIn { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter NotIn { get; public set; }
    [ParameterAttribute]
public SwitchParameter CNotIn { get; public set; }
    [ParameterAttribute]
public SwitchParameter Is { get; public set; }
    [ParameterAttribute]
public SwitchParameter IsNot { get; public set; }
    [ParameterAttribute]
public SwitchParameter Not { get; public set; }
    public PSObject get_InputObject();
    public void set_InputObject(PSObject value);
    public ScriptBlock get_FilterScript();
    public void set_FilterScript(ScriptBlock value);
    public string get_Property();
    public void set_Property(string value);
    public object get_Value();
    public void set_Value(object value);
    public SwitchParameter get_EQ();
    public void set_EQ(SwitchParameter value);
    public SwitchParameter get_CEQ();
    public void set_CEQ(SwitchParameter value);
    public SwitchParameter get_NE();
    public void set_NE(SwitchParameter value);
    public SwitchParameter get_CNE();
    public void set_CNE(SwitchParameter value);
    public SwitchParameter get_GT();
    public void set_GT(SwitchParameter value);
    public SwitchParameter get_CGT();
    public void set_CGT(SwitchParameter value);
    public SwitchParameter get_LT();
    public void set_LT(SwitchParameter value);
    public SwitchParameter get_CLT();
    public void set_CLT(SwitchParameter value);
    public SwitchParameter get_GE();
    public void set_GE(SwitchParameter value);
    public SwitchParameter get_CGE();
    public void set_CGE(SwitchParameter value);
    public SwitchParameter get_LE();
    public void set_LE(SwitchParameter value);
    public SwitchParameter get_CLE();
    public void set_CLE(SwitchParameter value);
    public SwitchParameter get_Like();
    public void set_Like(SwitchParameter value);
    public SwitchParameter get_CLike();
    public void set_CLike(SwitchParameter value);
    public SwitchParameter get_NotLike();
    public void set_NotLike(SwitchParameter value);
    public SwitchParameter get_CNotLike();
    public void set_CNotLike(SwitchParameter value);
    public SwitchParameter get_Match();
    public void set_Match(SwitchParameter value);
    public SwitchParameter get_CMatch();
    public void set_CMatch(SwitchParameter value);
    public SwitchParameter get_NotMatch();
    public void set_NotMatch(SwitchParameter value);
    public SwitchParameter get_CNotMatch();
    public void set_CNotMatch(SwitchParameter value);
    public SwitchParameter get_Contains();
    public void set_Contains(SwitchParameter value);
    public SwitchParameter get_CContains();
    public void set_CContains(SwitchParameter value);
    public SwitchParameter get_NotContains();
    public void set_NotContains(SwitchParameter value);
    public SwitchParameter get_CNotContains();
    public void set_CNotContains(SwitchParameter value);
    public SwitchParameter get_In();
    public void set_In(SwitchParameter value);
    public SwitchParameter get_CIn();
    public void set_CIn(SwitchParameter value);
    public SwitchParameter get_NotIn();
    public void set_NotIn(SwitchParameter value);
    public SwitchParameter get_CNotIn();
    public void set_CNotIn(SwitchParameter value);
    public SwitchParameter get_Is();
    public void set_Is(SwitchParameter value);
    public SwitchParameter get_IsNot();
    public void set_IsNot(SwitchParameter value);
    public SwitchParameter get_Not();
    public void set_Not(SwitchParameter value);
    private static Func`3<object, object, object> GetCallSiteDelegate(ExpressionType expressionType, bool ignoreCase);
    private static Func`3<object, object, object> GetCallSiteDelegateBoolean(ExpressionType expressionType, bool ignoreCase);
    private static Tuple`2<CallSite`1<Func`3<CallSite, object, IEnumerator>>, CallSite`1<Func`4<CallSite, object, object, object>>> GetContainsCallSites(bool ignoreCase);
    private void CheckLanguageMode();
    private object GetLikeRHSOperand(object operand);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    private object GetValue(Boolean& error);
    private ReadOnlyPSMemberInfoCollection`1<PSMemberInfo> GetMatchMembers();
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_0(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_1(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_2(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_3(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_4(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_5(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_6(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_7(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_8(object lval, object rval);
    [CompilerGeneratedAttribute]
private object <BeginProcessing>b__120_9(object lval, object rval);
}
public class Microsoft.PowerShell.Commands.WSManConfigurationOption : PSTransportOption {
    private static string Token;
    private static string QuotasToken;
    internal static string AttribOutputBufferingMode;
    internal static Nullable`1<OutputBufferingMode> DefaultOutputBufferingMode;
    private Nullable`1<OutputBufferingMode> _outputBufferingMode;
    private static string AttribProcessIdleTimeout;
    internal static Nullable`1<int> DefaultProcessIdleTimeout_ForPSRemoting;
    private Nullable`1<int> _processIdleTimeoutSec;
    internal static string AttribMaxIdleTimeout;
    internal static Nullable`1<int> DefaultMaxIdleTimeout;
    private Nullable`1<int> _maxIdleTimeoutSec;
    internal static string AttribIdleTimeout;
    internal static Nullable`1<int> DefaultIdleTimeout;
    private Nullable`1<int> _idleTimeoutSec;
    private static string AttribMaxConcurrentUsers;
    internal static Nullable`1<int> DefaultMaxConcurrentUsers;
    private Nullable`1<int> _maxConcurrentUsers;
    private static string AttribMaxProcessesPerSession;
    internal static Nullable`1<int> DefaultMaxProcessesPerSession;
    private Nullable`1<int> _maxProcessesPerSession;
    private static string AttribMaxMemoryPerSessionMB;
    internal static Nullable`1<int> DefaultMaxMemoryPerSessionMB;
    private Nullable`1<int> _maxMemoryPerSessionMB;
    private static string AttribMaxSessions;
    internal static Nullable`1<int> DefaultMaxSessions;
    private Nullable`1<int> _maxSessions;
    private static string AttribMaxSessionsPerUser;
    internal static Nullable`1<int> DefaultMaxSessionsPerUser;
    private Nullable`1<int> _maxSessionsPerUser;
    private static string AttribMaxConcurrentCommandsPerSession;
    internal static Nullable`1<int> DefaultMaxConcurrentCommandsPerSession;
    private Nullable`1<int> _maxConcurrentCommandsPerSession;
    public Nullable`1<int> ProcessIdleTimeoutSec { get; internal set; }
    public Nullable`1<int> MaxIdleTimeoutSec { get; internal set; }
    public Nullable`1<int> MaxSessions { get; internal set; }
    public Nullable`1<int> MaxConcurrentCommandsPerSession { get; internal set; }
    public Nullable`1<int> MaxSessionsPerUser { get; internal set; }
    public Nullable`1<int> MaxMemoryPerSessionMB { get; internal set; }
    public Nullable`1<int> MaxProcessesPerSession { get; internal set; }
    public Nullable`1<int> MaxConcurrentUsers { get; internal set; }
    public Nullable`1<int> IdleTimeoutSec { get; internal set; }
    public Nullable`1<OutputBufferingMode> OutputBufferingMode { get; internal set; }
    private static WSManConfigurationOption();
    protected internal virtual void LoadFromDefaults(bool keepAssigned);
    public Nullable`1<int> get_ProcessIdleTimeoutSec();
    internal void set_ProcessIdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<int> get_MaxIdleTimeoutSec();
    internal void set_MaxIdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<int> get_MaxSessions();
    internal void set_MaxSessions(Nullable`1<int> value);
    public Nullable`1<int> get_MaxConcurrentCommandsPerSession();
    internal void set_MaxConcurrentCommandsPerSession(Nullable`1<int> value);
    public Nullable`1<int> get_MaxSessionsPerUser();
    internal void set_MaxSessionsPerUser(Nullable`1<int> value);
    public Nullable`1<int> get_MaxMemoryPerSessionMB();
    internal void set_MaxMemoryPerSessionMB(Nullable`1<int> value);
    public Nullable`1<int> get_MaxProcessesPerSession();
    internal void set_MaxProcessesPerSession(Nullable`1<int> value);
    public Nullable`1<int> get_MaxConcurrentUsers();
    internal void set_MaxConcurrentUsers(Nullable`1<int> value);
    public Nullable`1<int> get_IdleTimeoutSec();
    internal void set_IdleTimeoutSec(Nullable`1<int> value);
    public Nullable`1<OutputBufferingMode> get_OutputBufferingMode();
    internal void set_OutputBufferingMode(Nullable`1<OutputBufferingMode> value);
    internal virtual Hashtable ConstructQuotasAsHashtable();
    internal virtual string ConstructQuotas();
    internal virtual string ConstructOptionsAsXmlAttributes();
    internal virtual Hashtable ConstructOptionsAsHashtable();
}
internal enum Microsoft.PowerShell.DataProtectionScope : Enum {
    public int value__;
    public static DataProtectionScope CurrentUser;
    public static DataProtectionScope LocalMachine;
}
internal class Microsoft.PowerShell.DefaultHost : PSHost {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CurrentCulture>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <CurrentUICulture>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public Guid InstanceId { get; }
    public PSHostUserInterface UI { get; }
    public CultureInfo CurrentCulture { get; }
    public CultureInfo CurrentUICulture { get; }
    internal DefaultHost(CultureInfo currentCulture, CultureInfo currentUICulture);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public virtual Version get_Version();
    [CompilerGeneratedAttribute]
public virtual Guid get_InstanceId();
    public virtual PSHostUserInterface get_UI();
    [CompilerGeneratedAttribute]
public virtual CultureInfo get_CurrentCulture();
    [CompilerGeneratedAttribute]
public virtual CultureInfo get_CurrentUICulture();
    public virtual void SetShouldExit(int exitCode);
    public virtual void EnterNestedPrompt();
    public virtual void ExitNestedPrompt();
    public virtual void NotifyBeginApplication();
    public virtual void NotifyEndApplication();
}
public class Microsoft.PowerShell.DeserializingTypeConverter : PSTypeConverter {
    private static Dictionary`2<Type, Func`2<PSObject, object>> s_converter;
    private static DeserializingTypeConverter();
    public virtual bool CanConvertFrom(PSObject sourceValue, Type destinationType);
    public virtual object ConvertFrom(PSObject sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    private static object ConvertFrom(PSObject o, Func`2<PSObject, object> converter);
    public virtual bool CanConvertTo(object sourceValue, Type destinationType);
    public virtual object ConvertTo(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public virtual bool CanConvertFrom(object sourceValue, Type destinationType);
    public virtual bool CanConvertTo(PSObject sourceValue, Type destinationType);
    public virtual object ConvertFrom(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public virtual object ConvertTo(PSObject sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    private static T GetPropertyValue(PSObject pso, string propertyName);
    internal static T GetPropertyValue(PSObject pso, string propertyName, RehydrationFlags flags);
    private static TList RehydrateList(PSObject pso, string propertyName, RehydrationFlags flags);
    private static object RehydratePrimitiveHashtable(PSObject pso);
    private static object RehydrateSwitchParameter(PSObject pso);
    private static CultureInfo RehydrateCultureInfo(PSObject pso);
    private static PSListModifier RehydratePSListModifier(PSObject pso);
    private static CompletionResult RehydrateCompletionResult(PSObject pso);
    private static ModuleSpecification RehydrateModuleSpecification(PSObject pso);
    private static CommandCompletion RehydrateCommandCompletion(PSObject pso);
    private static JobStateInfo RehydrateJobStateInfo(PSObject pso);
    internal static JobStateEventArgs RehydrateJobStateEventArgs(PSObject pso);
    internal static PSSessionOption RehydratePSSessionOption(PSObject pso);
    internal static LineBreakpoint RehydrateLineBreakpoint(PSObject pso);
    internal static CommandBreakpoint RehydrateCommandBreakpoint(PSObject pso);
    internal static VariableBreakpoint RehydrateVariableBreakpoint(PSObject pso);
    internal static BreakpointUpdatedEventArgs RehydrateBreakpointUpdatedEventArgs(PSObject pso);
    internal static DebuggerCommand RehydrateDebuggerCommand(PSObject pso);
    internal static DebuggerCommandResults RehydrateDebuggerCommandResults(PSObject pso);
    internal static DebuggerStopEventArgs RehydrateDebuggerStopEventArgs(PSObject pso);
    private static ScriptBlock RehydrateScriptBlock(string script);
    private static PSCredential RehydratePSCredential(PSObject pso);
    internal static PSSenderInfo RehydratePSSenderInfo(PSObject pso);
    private static X509Certificate2 RehydrateX509Certificate2(PSObject pso);
    private static X500DistinguishedName RehydrateX500DistinguishedName(PSObject pso);
    private static IPAddress RehydrateIPAddress(PSObject pso);
    private static MailAddress RehydrateMailAddress(PSObject pso);
    private static T RehydrateObjectSecurity(PSObject pso);
    public static UInt32 GetParameterSetMetadataFlags(PSObject instance);
    public static PSObject GetInvocationInfo(PSObject instance);
    private static ParameterSetMetadata RehydrateParameterSetMetadata(PSObject pso);
    private static DisplayEntry RehydrateDisplayEntry(PSObject deserializedDisplayEntry);
    private static EntrySelectedBy RehydrateEntrySelectedBy(PSObject deserializedEsb);
    private static WideControlEntryItem RehydrateWideControlEntryItem(PSObject deserializedEntryItem);
    private static ListControlEntryItem RehydrateListControlEntryItem(PSObject deserializedEntryItem);
    private static ListControlEntry RehydrateListControlEntry(PSObject deserializedEntry);
    private static TableControlColumnHeader RehydrateTableControlColumnHeader(PSObject deserializedHeader);
    private static TableControlColumn RehydrateTableControlColumn(PSObject deserializedColumn);
    private static TableControlRow RehydrateTableControlRow(PSObject deserializedRow);
    private static CustomControlEntry RehydrateCustomControlEntry(PSObject deserializedEntry);
    private static CustomItemBase RehydrateCustomItemBase(PSObject deserializedItem);
    private static PSControl RehydratePSControl(PSObject deserializedControl);
    private static PSControlGroupBy RehydrateGroupBy(PSObject deserializedGroupBy);
    public static Guid GetFormatViewDefinitionInstanceId(PSObject instance);
    private static FormatViewDefinition RehydrateFormatViewDefinition(PSObject deserializedViewDefinition);
    private static ExtendedTypeDefinition RehydrateExtendedTypeDefinition(PSObject deserializedTypeDefinition);
}
[AttributeUsageAttribute("2432")]
public class Microsoft.PowerShell.DesiredStateConfiguration.ArgumentToConfigurationDataTransformationAttribute : ArgumentTransformationAttribute {
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
}
internal class Microsoft.PowerShell.DesiredStateConfiguration.CimDSCParser : object {
    private CimMofDeserializer _deserializer;
    private OnClassNeeded _onClassNeeded;
    internal CimDSCParser(OnClassNeeded onClassNeeded);
    internal CimDSCParser(OnClassNeeded onClassNeeded, MofDeserializerSchemaValidationOption validationOptions);
    internal List`1<CimInstance> ParseInstanceMof(string filePath);
    internal static Byte[] GetFileContent(string fullFilePath);
    internal List`1<CimClass> ParseSchemaMofFileBuffer(string mof);
    internal List`1<CimClass> ParseSchemaMof(string filePath);
    internal void ValidateInstanceText(string classText);
}
public static class Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCache : object {
    private static string InboxDscResourceModulePath;
    private static string reservedDynamicKeywords;
    private static string reservedProperties;
    private static PSTraceSource s_tracer;
    private static int IndexModuleName;
    private static int IndexModuleVersion;
    private static int IndexClassName;
    private static int IndexFriendlyName;
    private static String[] s_hiddenResourceList;
    private static HashSet`1<string> s_hiddenResourceCache;
    private static HashSet`1<string> s_currentImportingScriptFiles;
    [ThreadStaticAttribute]
private static Dictionary`2<string, DscClassCacheEntry> t_classCache;
    [ThreadStaticAttribute]
private static Dictionary`2<string, Tuple`2<string, Version>> t_byClassModuleCache;
    [ThreadStaticAttribute]
private static Dictionary`2<string, List`1<CimClass>> t_byFileClassCache;
    [ThreadStaticAttribute]
private static HashSet`1<string> t_scriptKeywordFileCache;
    private static Tuple`2<string, Version> s_defaultModuleInfoForResource;
    internal static Tuple`2<string, Version> DefaultModuleInfoForMetaConfigResource;
    internal static HashSet`1<string> SystemResourceNames;
    [ThreadStaticAttribute]
private static bool t_cacheResourcesFromMultipleModuleVersions;
    private static Dictionary`2<Type, string> s_mapPrimitiveDotNetTypeToMof;
    private static ScriptBlock s_cimKeywordImplementationFunction;
    private static string CimKeywordImplementationFunctionText;
    private static Dictionary`2<string, DscClassCacheEntry> ClassCache { get; }
    private static Dictionary`2<string, Tuple`2<string, Version>> ByClassModuleCache { get; }
    private static Dictionary`2<string, List`1<CimClass>> ByFileClassCache { get; }
    private static HashSet`1<string> ScriptKeywordFileCache { get; }
    private static bool CacheResourcesFromMultipleModuleVersions { get; private set; }
    private static ScriptBlock CimKeywordImplementationFunction { get; }
    private static DscClassCache();
    private static Dictionary`2<string, DscClassCacheEntry> get_ClassCache();
    private static Dictionary`2<string, Tuple`2<string, Version>> get_ByClassModuleCache();
    private static Dictionary`2<string, List`1<CimClass>> get_ByFileClassCache();
    private static HashSet`1<string> get_ScriptKeywordFileCache();
    private static bool get_CacheResourcesFromMultipleModuleVersions();
    private static void set_CacheResourcesFromMultipleModuleVersions(bool value);
    public static void Initialize();
    public static void Initialize(Collection`1<Exception> errors, List`1<string> modulePathList);
    private static void LoadDSCResourceIntoCache(Collection`1<Exception> errors, List`1<string> modulePathList, bool importInBoxResourcesImplicitly);
    private static Tuple`2<string, Version> GetModuleInfoHelper(string moduleFolderPath, bool importInBoxResourcesImplicitly, bool isPsProviderModule);
    private static CimClass MyClassCallback(string serverName, string namespaceName, string className);
    public static List`1<CimClass> ReadCimSchemaMof(string mofPath);
    public static List`1<CimClass> ImportClasses(string path, Tuple`2<string, Version> moduleInfo, Collection`1<Exception> errors, bool importInBoxResourcesImplicitly);
    public static string GetStringFromSecureString(SecureString value);
    public static void ClearCache();
    private static string GetModuleQualifiedResourceName(string moduleName, string moduleVersion, string className, string resourceName);
    private static List`1<KeyValuePair`2<string, DscClassCacheEntry>> FindResourceInCache(string moduleName, string className, string resourceName);
    private static List`1<DscClassCacheEntry> GetCachedClasses();
    public static List`1<CimClass> GetCachedClassesForModule(PSModuleInfo module);
    public static List`1<string> GetFileDefiningClass(string className);
    public static String[] GetLoadedFiles();
    public static List`1<CimClass> GetCachedClassByFileName(string fileName);
    public static List`1<CimClass> GetCachedClassByModuleName(string moduleName);
    public static List`1<CimInstance> ImportInstances(string path);
    public static List`1<CimInstance> ImportInstances(string path, int schemaValidationOption);
    public static void ValidateInstanceText(string instanceText);
    private static bool IsMagicProperty(string propertyName);
    private static string GetFriendlyName(CimClass cimClass);
    public static Collection`1<DynamicKeyword> GetCachedKeywords();
    private static void CreateAndRegisterKeywordFromCimClass(string moduleName, Version moduleVersion, CimClass cimClass, Dictionary`2<string, ScriptBlock> functionsToDefine, DSCResourceRunAsCredential runAsBehavior);
    private static DynamicKeyword CreateKeywordFromCimClass(string moduleName, Version moduleVersion, CimClass cimClass, Dictionary`2<string, ScriptBlock> functionsToDefine, DSCResourceRunAsCredential runAsBehavior);
    private static void UpdateKnownRestriction(DynamicKeyword keyword);
    public static void LoadDefaultCimKeywords();
    public static void LoadDefaultCimKeywords(List`1<string> modulePathList);
    public static void LoadDefaultCimKeywords(Collection`1<Exception> errors);
    public static void LoadDefaultCimKeywords(Dictionary`2<string, ScriptBlock> functionsToDefine);
    public static void LoadDefaultCimKeywords(Collection`1<Exception> errors, bool cacheResourcesFromMultipleModuleVersions);
    private static void LoadDefaultCimKeywords(Dictionary`2<string, ScriptBlock> functionsToDefine, Collection`1<Exception> errors, List`1<string> modulePathList, bool cacheResourcesFromMultipleModuleVersions);
    private static ParseError[] ImportResourcePostParse(DynamicKeywordStatementAst kwAst);
    private static ParseError[] ImportResourceCheckSemantics(DynamicKeywordStatementAst kwAst);
    private static ParseError[] CheckMandatoryPropertiesPresent(DynamicKeywordStatementAst kwAst);
    public static void LoadResourcesFromModule(IScriptExtent scriptExtent, ModuleSpecification[] moduleSpecifications, String[] resourceNames, List`1<ParseError> errorList);
    private static void LoadPowerShellClassResourcesFromModule(PSModuleInfo primaryModuleInfo, PSModuleInfo moduleInfo, ICollection`1<string> resourcesToImport, ICollection`1<string> resourcesFound, List`1<ParseError> errorList, Dictionary`2<string, ScriptBlock> functionsToDefine, bool recurse, IScriptExtent extent);
    public static List`1<string> ImportClassResourcesFromModule(PSModuleInfo moduleInfo, ICollection`1<string> resourcesToImport, Dictionary`2<string, ScriptBlock> functionsToDefine);
    internal static string GenerateMofForAst(TypeDefinitionAst typeAst);
    internal static string MapTypeNameToMofType(ITypeName typeName, string memberName, string className, Boolean& isArrayType, String& embeddedInstanceType, List`1<object> embeddedInstanceTypes, String[]& enumNames);
    private static void GenerateMofForAst(TypeDefinitionAst typeAst, StringBuilder sb, List`1<object> embeddedInstanceTypes);
    private static bool GetResourceMethodsLineNumber(TypeDefinitionAst typeDefinitionAst, Dictionary`2& methodsLinePosition);
    public static bool GetResourceMethodsLinePosition(PSModuleInfo moduleInfo, string resourceName, Dictionary`2& resourceMethodsLinePosition, String& resourceFilePath);
    private static void ProcessMembers(StringBuilder sb, List`1<object> embeddedInstanceTypes, TypeDefinitionAst typeDefinitionAst, string className);
    private static bool GetResourceDefinitionsFromModule(string fileName, IEnumerable`1& resourceDefinitions, List`1<ParseError> errorList, IScriptExtent extent);
    private static bool ImportKeywordsFromScriptFile(string fileName, PSModuleInfo module, ICollection`1<string> resourcesToImport, ICollection`1<string> resourcesFound, Dictionary`2<string, ScriptBlock> functionsToDefine, List`1<ParseError> errorList, IScriptExtent extent);
    private static bool AreQualifiersSame(CimReadOnlyKeyedCollection`1<CimQualifier> oldQualifier, CimReadOnlyKeyedCollection`1<CimQualifier> newQualifiers);
    private static bool ArePropertiesSame(CimReadOnlyKeyedCollection`1<CimPropertyDeclaration> oldProperties, CimReadOnlyKeyedCollection`1<CimPropertyDeclaration> newProperties);
    private static bool IsSameNestedObject(CimClass oldClass, CimClass newClass);
    internal static string MapTypeToMofType(Type type, string memberName, string className, Boolean& isArrayType, String& embeddedInstanceType, List`1<object> embeddedInstanceTypes);
    private static string MapAttributesToMof(String[] enumNames, IEnumerable`1<object> customAttributes, string embeddedInstanceType);
    public static string GenerateMofForType(Type type);
    private static void ProcessEmbeddedInstanceTypes(List`1<object> embeddedInstanceTypes, List`1<object> visitedInstances, StringBuilder sb);
    private static void GenerateMofForType(Type type, StringBuilder sb, List`1<object> embeddedInstanceTypes);
    private static void ProcessMembers(Type type, StringBuilder sb, List`1<object> embeddedInstanceTypes, string className);
    private static bool ImportKeywordsFromAssembly(PSModuleInfo module, ICollection`1<string> resourcesToImport, ICollection`1<string> resourcesFound, Dictionary`2<string, ScriptBlock> functionsToDefine, Assembly assembly);
    private static void ProcessMofForDynamicKeywords(PSModuleInfo module, ICollection`1<string> resourcesFound, Dictionary`2<string, ScriptBlock> functionsToDefine, CimDSCParser parser, string mof, DSCResourceRunAsCredential runAsBehavior);
    public static bool ImportCimKeywordsFromModule(PSModuleInfo module, string resourceName, String& schemaFilePath);
    public static bool ImportCimKeywordsFromModule(PSModuleInfo module, string resourceName, String& schemaFilePath, Dictionary`2<string, ScriptBlock> functionsToDefine);
    public static bool ImportCimKeywordsFromModule(PSModuleInfo module, string resourceName, String& schemaFilePath, Dictionary`2<string, ScriptBlock> functionsToDefine, Collection`1<Exception> errors);
    private static void ClearImplicitlyImportedFlagFromResourceInClassCache(PSModuleInfo module, CimClass cimClass);
    public static bool ImportScriptKeywordsFromModule(PSModuleInfo module, string resourceName, String& schemaFilePath);
    public static bool ImportScriptKeywordsFromModule(PSModuleInfo module, string resourceName, String& schemaFilePath, Dictionary`2<string, ScriptBlock> functionsToDefine);
    public static ErrorRecord GetBadlyFormedRequiredResourceIdErrorRecord(string badDependsOnReference, string definingResource);
    public static ErrorRecord GetBadlyFormedExclusiveResourceIdErrorRecord(string badExclusiveResourcereference, string definingResource);
    public static ErrorRecord GetPullModeNeedConfigurationSource(string resourceId);
    public static ErrorRecord DisabledRefreshModeNotValidForPartialConfig(string resourceId);
    public static ErrorRecord DuplicateResourceIdInNodeStatementErrorRecord(string duplicateResourceId, string nodeName);
    public static ErrorRecord InvalidConfigurationNameErrorRecord(string configurationName);
    public static ErrorRecord InvalidValueForPropertyErrorRecord(string propertyName, string value, string keywordName, string validValues);
    public static ErrorRecord InvalidLocalConfigurationManagerPropertyErrorRecord(string propertyName, string validProperties);
    public static ErrorRecord UnsupportedValueForPropertyErrorRecord(string propertyName, string value, string keywordName, string validValues);
    public static ErrorRecord MissingValueForMandatoryPropertyErrorRecord(string keywordName, string typeName, string propertyName);
    public static ErrorRecord DebugModeShouldHaveOneValue();
    public static ErrorRecord ValueNotInRangeErrorRecord(string property, string name, int providedValue, int lower, int upper);
    public static ErrorRecord PsDscRunAsCredentialMergeErrorForCompositeResources(string resourceId);
    public static string GetDSCResourceUsageString(DynamicKeyword keyword);
    private static StringBuilder FormatCimPropertyType(DynamicKeywordProperty prop, bool isOptionalProperty);
    private static ScriptBlock get_CimKeywordImplementationFunction();
}
internal class Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscClassCacheEntry : object {
    public DSCResourceRunAsCredential DscResRunAsCred;
    public bool IsImportedImplicitly;
    public CimClass CimClassInstance;
    public DscClassCacheEntry(DSCResourceRunAsCredential aDSCResourceRunAsCredential, bool aIsImportedImplicitly, CimClass aCimClassInstance);
}
public static class Microsoft.PowerShell.DesiredStateConfiguration.Internal.DscRemoteOperationsClass : object {
    public static object ConvertCimInstanceToObject(Type targetType, CimInstance instance, string moduleName);
    private static object ConvertCimInstanceHashtable(string providerName, CimInstance[] arrayInstance);
    private static object ConvertCimInstancePsCredential(string providerName, CimInstance propertyInstance);
}
internal class Microsoft.PowerShell.EncryptionResult : object {
    [CompilerGeneratedAttribute]
private string <EncryptedData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IV>k__BackingField;
    internal string EncryptedData { get; }
    internal string IV { get; }
    internal EncryptionResult(string encrypted, string IV);
    [CompilerGeneratedAttribute]
internal string get_EncryptedData();
    [CompilerGeneratedAttribute]
internal string get_IV();
}
public enum Microsoft.PowerShell.ExecutionPolicy : Enum {
    public int value__;
    public static ExecutionPolicy Unrestricted;
    public static ExecutionPolicy RemoteSigned;
    public static ExecutionPolicy AllSigned;
    public static ExecutionPolicy Restricted;
    public static ExecutionPolicy Bypass;
    public static ExecutionPolicy Undefined;
    public static ExecutionPolicy Default;
}
public enum Microsoft.PowerShell.ExecutionPolicyScope : Enum {
    public int value__;
    public static ExecutionPolicyScope Process;
    public static ExecutionPolicyScope CurrentUser;
    public static ExecutionPolicyScope LocalMachine;
    public static ExecutionPolicyScope UserPolicy;
    public static ExecutionPolicyScope MachinePolicy;
}
internal static class Microsoft.PowerShell.NativeCultureResolver : object {
    internal static CultureInfo UICulture { get; }
    internal static CultureInfo Culture { get; }
    internal static void SetThreadUILanguage(short langId);
    internal static CultureInfo get_UICulture();
    internal static CultureInfo get_Culture();
}
[ExtensionAttribute]
public static class Microsoft.PowerShell.ProcessCodeMethods : object {
    private static int InvalidProcessId;
    [ExtensionAttribute]
internal static Process GetParent(Process process);
    public static object GetParentProcess(PSObject obj);
    internal static int GetParentPid(Process process);
}
internal static class Microsoft.PowerShell.ProtectedData : object {
    public static Byte[] Protect(Byte[] userData, Byte[] optionalEntropy, DataProtectionScope scope);
    public static Byte[] Unprotect(Byte[] encryptedData, Byte[] optionalEntropy, DataProtectionScope scope);
}
public class Microsoft.PowerShell.PSAuthorizationManager : AuthorizationManager {
    private ExecutionPolicy _executionPolicy;
    private string _shellId;
    public PSAuthorizationManager(string shellId);
    private static bool IsSupportedExtension(string ext);
    private bool CheckPolicy(ExternalScriptInfo script, PSHost host, Exception& reason);
    private static bool SetPolicyFromAuthenticodePrompt(string path, PSHost host, Exception& reason, Signature signature);
    private static bool IsLocalFile(string filename);
    private static bool IsTrustedPublisher(Signature signature, string file);
    private static bool IsUntrustedPublisher(Signature signature, string file);
    private static void TrustPublisher(Signature signature);
    private static void UntrustPublisher(Signature signature);
    private static Signature GetSignatureWithEncodingRetry(string path, ExternalScriptInfo script);
    private static Byte[] GetContentBytesWithBom(Encoding encoding, string scriptContent);
    protected internal virtual bool ShouldRun(CommandInfo commandInfo, CommandOrigin origin, PSHost host, Exception& reason);
    private static RunPromptDecision AuthenticodePrompt(string path, Signature signature, PSHost host);
    private static RunPromptDecision RemoteFilePrompt(string path, PSHost host);
    private static Collection`1<ChoiceDescription> GetAuthenticodePromptChoices();
    private static Collection`1<ChoiceDescription> GetRemoteFilePromptChoices();
}
internal static class Microsoft.PowerShell.SecureStringHelper : object {
    internal static string SecureStringExportHeader;
    private static SecureStringHelper();
    private static SecureString New(Byte[] data);
    internal static Byte[] GetData(SecureString s);
    internal static string ByteArrayToString(Byte[] data);
    internal static Byte[] ByteArrayFromString(string s);
    internal static string Protect(SecureString input);
    internal static SecureString Unprotect(string input);
    internal static EncryptionResult Encrypt(SecureString input, SecureString key);
    internal static EncryptionResult Encrypt(SecureString input, Byte[] key);
    internal static EncryptionResult Encrypt(SecureString input, Byte[] key, Byte[] iv);
    internal static SecureString Decrypt(string input, SecureString key, Byte[] IV);
    internal static SecureString Decrypt(string input, Byte[] key, Byte[] IV);
    [NullableContextAttribute("1")]
internal static SecureString FromPlainTextString(string plainTextString);
}
public static class Microsoft.PowerShell.Telemetry.ApplicationInsightsTelemetry : object {
    private static string _telemetryOptoutEnvVar;
    private static string _psCoreTelemetryKey;
    private static Guid _defaultNodeIdentifier;
    private static string Anonymous;
    private static string AnonymousVersion;
    private static string NoTag;
    private static string _telemetryFailure;
    [CompilerGeneratedAttribute]
private static TelemetryClient <s_telemetryClient>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <s_uniqueUserIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private static string <s_sessionId>k__BackingField;
    private static int s_startupEventSent;
    private static HashSet`1<string> s_knownModules;
    private static HashSet`1<string> s_knownModuleTags;
    [CompilerGeneratedAttribute]
private static bool <CanSendTelemetry>k__BackingField;
    private static TelemetryClient s_telemetryClient { get; }
    private static string s_uniqueUserIdentifier { get; }
    private static string s_sessionId { get; }
    public static bool CanSendTelemetry { get; private set; }
    private static ApplicationInsightsTelemetry();
    [CompilerGeneratedAttribute]
private static TelemetryClient get_s_telemetryClient();
    [CompilerGeneratedAttribute]
private static string get_s_uniqueUserIdentifier();
    [CompilerGeneratedAttribute]
private static string get_s_sessionId();
    [CompilerGeneratedAttribute]
public static bool get_CanSendTelemetry();
    [CompilerGeneratedAttribute]
private static void set_CanSendTelemetry(bool value);
    private static bool GetEnvironmentVariableAsBool(string name, bool defaultValue);
    internal static void SendModuleTelemetryMetric(TelemetryType telemetryType, PSModuleInfo moduleInfo);
    internal static void SendModuleTelemetryMetric(TelemetryType telemetryType, string moduleName);
    internal static void SendTelemetryMetric(TelemetryType metricId, string data);
    internal static void SendExperimentalUseData(string featureName, string detail);
    private static string GetExperimentalFeatureName(string featureNameToValidate);
    private static string GetModuleName(string moduleNameToValidate);
    internal static void SendPSCoreStartupTelemetry(string mode, double parametersUsed);
    private static bool TryGetIdentifier(string telemetryFilePath, Guid& id);
    private static Guid CreateUniqueIdentifierAndFile(string telemetryFilePath);
    private static Guid GetUniqueIdentifier();
}
internal class Microsoft.PowerShell.Telemetry.NameObscurerTelemetryInitializer : object {
    private static string _notavailable;
    public sealed virtual void Initialize(ITelemetry telemetry);
}
internal enum Microsoft.PowerShell.Telemetry.TelemetryType : Enum {
    public int value__;
    public static TelemetryType ApplicationType;
    public static TelemetryType ModuleLoad;
    public static TelemetryType WinCompatModuleLoad;
    public static TelemetryType ExperimentalEngineFeatureDeactivation;
    public static TelemetryType ExperimentalEngineFeatureActivation;
    public static TelemetryType ExperimentalFeatureUse;
    public static TelemetryType ExperimentalModuleFeatureDeactivation;
    public static TelemetryType ExperimentalModuleFeatureActivation;
    public static TelemetryType PowerShellCreate;
    public static TelemetryType RemoteSessionOpen;
}
public static class Microsoft.PowerShell.ToStringCodeMethods : object {
    public static string PropertyValueCollection(PSObject instance);
    private static void AddGenericArguments(StringBuilder sb, Type[] genericArguments, bool dropNamespaces);
    internal static string Type(Type type, bool dropNamespaces, string key);
    public static string Type(PSObject instance);
    public static string XmlNode(PSObject instance);
    public static string XmlNodeList(PSObject instance);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MiniShellErrors : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string UpdateNotSupportedForConfigurationCategory { get; }
    internal static string UpdateAssemblyErrors { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_UpdateNotSupportedForConfigurationCategory();
    internal static string get_UpdateAssemblyErrors();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Modules : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ModuleNotFound { get; }
    internal static string ModuleWithVersionNotFound { get; }
    internal static string MaximumVersionFormatIncorrect { get; }
    internal static string MaximumVersionNotFound { get; }
    internal static string MinimumVersionAndMaximumVersionNotFound { get; }
    internal static string MinimumVersionAndMaximumVersionInvalidRange { get; }
    internal static string ModuleAssemblyFound { get; }
    internal static string ManifestMemberNotFound { get; }
    internal static string CantUseAsCustomObjectWithBinaryModule { get; }
    internal static string InvalidModuleManifest { get; }
    internal static string EmptyModuleManifest { get; }
    internal static string InvalidModuleManifestMember { get; }
    internal static string InvalidModuleSpecificationMember { get; }
    internal static string ModuleTooDeeplyNested { get; }
    internal static string ModuleManifestMissingModuleVersion { get; }
    internal static string ModuleManifestInvalidValue { get; }
    internal static string ModuleManifestInsufficientModuleVersion { get; }
    internal static string ModuleManifestInsufficientPowerShellVersion { get; }
    internal static string ModuleManifestNestedModulesCantGoWithModuleToProcess { get; }
    internal static string ModuleManifestInvalidManifestMember { get; }
    internal static string InvalidModuleManifestPath { get; }
    internal static string InvalidModuleManifestVersion { get; }
    internal static string InvalidNestedModuleinModuleManifest { get; }
    internal static string InvalidRequiredAssembliesInModuleManifest { get; }
    internal static string InvalidFilePathinModuleManifest { get; }
    internal static string InvalidRequiredModulesinModuleManifest { get; }
    internal static string InvalidModuleListinModuleManifest { get; }
    internal static string InvalidPowerShellVersionInModuleManifest { get; }
    internal static string DuplicateEntriesInCompatiblePSEditions { get; }
    internal static string ModuleVersionEqualsToVersionFolder { get; }
    internal static string SkippingInvalidModuleVersionFolder { get; }
    internal static string RequiredModuleMissingModuleName { get; }
    internal static string RequiredModuleMissingModuleVersion { get; }
    internal static string RequiredModuleNotLoaded { get; }
    internal static string RequiredModuleNotLoadedWrongGuid { get; }
    internal static string RequiredModuleNotLoadedWrongVersion { get; }
    internal static string RequiredModuleNotLoadedWrongMaximumVersion { get; }
    internal static string RequiredModuleNotLoadedWrongMinimumVersionAndMaximumVersion { get; }
    internal static string NoModulesRemoved { get; }
    internal static string UnableToRemoveModuleMember { get; }
    internal static string ModuleIsReadOnly { get; }
    internal static string ModuleIsConstant { get; }
    internal static string ModuleIsRequired { get; }
    internal static string CanOnlyBeUsedFromWithinAModule { get; }
    internal static string InvalidModuleExtension { get; }
    internal static string InvalidOperationOnBinaryModule { get; }
    internal static string ScriptsToProcessIncorrectExtension { get; }
    internal static string DefaultCompanyName { get; }
    internal static string DefaultCopyrightMessage { get; }
    internal static string RemovingImportedFunction { get; }
    internal static string RemovingImportedAlias { get; }
    internal static string RemovingImportedVariable { get; }
    internal static string LoadingModule { get; }
    internal static string LoadingFile { get; }
    internal static string DottingScriptFile { get; }
    internal static string ImportingFunction { get; }
    internal static string ImportingCmdlet { get; }
    internal static string ImportingAlias { get; }
    internal static string ImportingVariable { get; }
    internal static string ExportingCmdlet { get; }
    internal static string ExportingFunction { get; }
    internal static string ExportingAlias { get; }
    internal static string ExportingVariable { get; }
    internal static string ImportingNonStandardVerb { get; }
    internal static string ImportingNonStandardVerbVerbose { get; }
    internal static string ImportingNonStandardVerbVerboseSuggestion { get; }
    internal static string ImportingNonStandardNoun { get; }
    internal static string ImportingNonStandardNounVerbose { get; }
    internal static string CreatingModuleManifestFile { get; }
    internal static string ConfirmRemoveModule { get; }
    internal static string InvalidProcessorArchitecture { get; }
    internal static string InvalidPowerShellHostName { get; }
    internal static string InvalidPowerShellHostVersion { get; }
    internal static string ManifestHeaderLine1 { get; }
    internal static string ManifestHeaderLine2 { get; }
    internal static string ManifestHeaderLine3 { get; }
    internal static string RootModule { get; }
    internal static string NestedModules { get; }
    internal static string GUID { get; }
    internal static string Author { get; }
    internal static string CompanyName { get; }
    internal static string Copyright { get; }
    internal static string ModuleVersion { get; }
    internal static string Description { get; }
    internal static string PowerShellVersion { get; }
    internal static string CLRVersion { get; }
    internal static string RequiredModules { get; }
    internal static string ScriptsToProcess { get; }
    internal static string TypesToProcess { get; }
    internal static string FormatsToProcess { get; }
    internal static string RequiredAssemblies { get; }
    internal static string FileList { get; }
    internal static string PrivateData { get; }
    internal static string Tags { get; }
    internal static string ProjectUri { get; }
    internal static string LicenseUri { get; }
    internal static string IconUri { get; }
    internal static string ReleaseNotes { get; }
    internal static string Prerelease { get; }
    internal static string RequireLicenseAcceptance { get; }
    internal static string ExternalModuleDependencies { get; }
    internal static string EndOfManifestHashTable { get; }
    internal static string PrivateDataValueTypeShouldBeHashTableError { get; }
    internal static string PrivateDataValueTypeShouldBeHashTableWarning { get; }
    internal static string InvalidParameterValue { get; }
    internal static string FunctionsToExport { get; }
    internal static string AliasesToExport { get; }
    internal static string CmdletsToExport { get; }
    internal static string VariablesToExport { get; }
    internal static string DscResourcesToExport { get; }
    internal static string CompatiblePSEditions { get; }
    internal static string ProcessorArchitecture { get; }
    internal static string ModuleList { get; }
    internal static string DotNetFrameworkVersion { get; }
    internal static string PowerShellHostName { get; }
    internal static string PowerShellHostVersion { get; }
    internal static string HelpInfoURI { get; }
    internal static string ModuleDriveInUse { get; }
    internal static string ImportModuleNoClobberForCmdlet { get; }
    internal static string ImportModuleNoClobberForAlias { get; }
    internal static string ImportModuleNoClobberForFunction { get; }
    internal static string ImportModuleNoClobberForVariable { get; }
    internal static string WildCardNotAllowedInModuleToProcessAndInNestedModules { get; }
    internal static string CoreModuleCannotBeRemoved { get; }
    internal static string ModuleManifestCannotContainBothModuleToProcessAndRootModule { get; }
    internal static string ModuleToProcessFieldDeprecated { get; }
    internal static string DefaultCommandPrefix { get; }
    internal static string GlobalAndScopeParameterCannotBeSpecifiedTogether { get; }
    internal static string RequiredModulesCyclicDependency { get; }
    internal static string RequiredModuleNotFound { get; }
    internal static string MixedModuleOverCimSessionWarning { get; }
    internal static string WinCompatModuleWarning { get; }
    internal static string WinCompatRequredVersionError { get; }
    internal static string WinCompatModuleInDenyList { get; }
    internal static string PsModuleOverCimSessionError { get; }
    internal static string InvalidProcessorArchitectureInManifest { get; }
    internal static string RemoteDiscoveryWorksOnlyInListAvailableMode { get; }
    internal static string ModuleLoadedAsASnapin { get; }
    internal static string WildCardNotAllowedInRequiredAssemblies { get; }
    internal static string CmdletizationDoesSupportRexportingNestedModules { get; }
    internal static string RemoteDiscoveryRemotePsrpCommandFailed { get; }
    internal static string RemoteDiscoveryFailedToGenerateProxyForRemoteModule { get; }
    internal static string RemoteDiscoveryFailedToProcessRemoteModule { get; }
    internal static string RemoteDiscoveryFailureFromDiscoveryProvider { get; }
    internal static string RequiredModuleNotFoundWrongGuidVersion { get; }
    internal static string RemoteDiscoveryProviderNotFound { get; }
    internal static string CannotDetectNetFrameworkVersion { get; }
    internal static string ScriptAnalysisModule { get; }
    internal static string ScriptAnalysisPreparing { get; }
    internal static string DeterminingAvailableModules { get; }
    internal static string SearchingUncShare { get; }
    internal static string RemoteDiscoveryWorksOnlyForUnQualifiedNames { get; }
    internal static string ModuleDiscoveryForLoadedModulesWorksOnlyForUnQualifiedNames { get; }
    internal static string ModuleNotFoundForGetModule { get; }
    internal static string PopulatingRepositorySourceLocation { get; }
    internal static string ManifestMemberNotValid { get; }
    internal static string PrerequisiteForDesktopEditionOnly { get; }
    internal static string PSEditionNotSupported { get; }
    internal static string ImplicitWinCompatDisabled { get; }
    internal static string ExperimentalFeatureNameMissingOrEmpty { get; }
    internal static string InvalidExperimentalFeatureName { get; }
    internal static string SkipEditionCheckNotSupportedWithoutListAvailable { get; }
    internal static string ImportPSFileNotAllowedInConstrainedLanguage { get; }
    internal static string MismatchedLanguageModes { get; }
    internal static string CannotUseDotSourceWithWildCardFunctionExport { get; }
    internal static string CannotExportMembersAccrossLanguageBoundaries { get; }
    internal static string CannotCreateModuleWithScriptBlock { get; }
    internal static string CannotFindCoreCompatibleBuiltInModule { get; }
    internal static string WDACExportModuleCommandLogTitle { get; }
    internal static string WDACExportModuleCommandLogMessage { get; }
    internal static string WDACImplicitFunctionExportLogTitle { get; }
    internal static string WDACImplicitFunctionExportLogMessage { get; }
    internal static string WDACScriptFileImportLogTitle { get; }
    internal static string WDACScriptFileImportLogMessage { get; }
    internal static string WDACModuleDotSourceLogTitle { get; }
    internal static string WDACModuleDotSourceLogMessage { get; }
    internal static string WDACModuleFnExportWithNestedModulesLogTitle { get; }
    internal static string WDACModuleFnExportWithNestedModulesLogMessage { get; }
    internal static string WDACNewModuleCommandLogTitle { get; }
    internal static string WDACNewModuleCommandLogMessage { get; }
    internal static string WDACMismatchedLanguageModesTitle { get; }
    internal static string WDACMismatchedLanguageModesMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ModuleNotFound();
    internal static string get_ModuleWithVersionNotFound();
    internal static string get_MaximumVersionFormatIncorrect();
    internal static string get_MaximumVersionNotFound();
    internal static string get_MinimumVersionAndMaximumVersionNotFound();
    internal static string get_MinimumVersionAndMaximumVersionInvalidRange();
    internal static string get_ModuleAssemblyFound();
    internal static string get_ManifestMemberNotFound();
    internal static string get_CantUseAsCustomObjectWithBinaryModule();
    internal static string get_InvalidModuleManifest();
    internal static string get_EmptyModuleManifest();
    internal static string get_InvalidModuleManifestMember();
    internal static string get_InvalidModuleSpecificationMember();
    internal static string get_ModuleTooDeeplyNested();
    internal static string get_ModuleManifestMissingModuleVersion();
    internal static string get_ModuleManifestInvalidValue();
    internal static string get_ModuleManifestInsufficientModuleVersion();
    internal static string get_ModuleManifestInsufficientPowerShellVersion();
    internal static string get_ModuleManifestNestedModulesCantGoWithModuleToProcess();
    internal static string get_ModuleManifestInvalidManifestMember();
    internal static string get_InvalidModuleManifestPath();
    internal static string get_InvalidModuleManifestVersion();
    internal static string get_InvalidNestedModuleinModuleManifest();
    internal static string get_InvalidRequiredAssembliesInModuleManifest();
    internal static string get_InvalidFilePathinModuleManifest();
    internal static string get_InvalidRequiredModulesinModuleManifest();
    internal static string get_InvalidModuleListinModuleManifest();
    internal static string get_InvalidPowerShellVersionInModuleManifest();
    internal static string get_DuplicateEntriesInCompatiblePSEditions();
    internal static string get_ModuleVersionEqualsToVersionFolder();
    internal static string get_SkippingInvalidModuleVersionFolder();
    internal static string get_RequiredModuleMissingModuleName();
    internal static string get_RequiredModuleMissingModuleVersion();
    internal static string get_RequiredModuleNotLoaded();
    internal static string get_RequiredModuleNotLoadedWrongGuid();
    internal static string get_RequiredModuleNotLoadedWrongVersion();
    internal static string get_RequiredModuleNotLoadedWrongMaximumVersion();
    internal static string get_RequiredModuleNotLoadedWrongMinimumVersionAndMaximumVersion();
    internal static string get_NoModulesRemoved();
    internal static string get_UnableToRemoveModuleMember();
    internal static string get_ModuleIsReadOnly();
    internal static string get_ModuleIsConstant();
    internal static string get_ModuleIsRequired();
    internal static string get_CanOnlyBeUsedFromWithinAModule();
    internal static string get_InvalidModuleExtension();
    internal static string get_InvalidOperationOnBinaryModule();
    internal static string get_ScriptsToProcessIncorrectExtension();
    internal static string get_DefaultCompanyName();
    internal static string get_DefaultCopyrightMessage();
    internal static string get_RemovingImportedFunction();
    internal static string get_RemovingImportedAlias();
    internal static string get_RemovingImportedVariable();
    internal static string get_LoadingModule();
    internal static string get_LoadingFile();
    internal static string get_DottingScriptFile();
    internal static string get_ImportingFunction();
    internal static string get_ImportingCmdlet();
    internal static string get_ImportingAlias();
    internal static string get_ImportingVariable();
    internal static string get_ExportingCmdlet();
    internal static string get_ExportingFunction();
    internal static string get_ExportingAlias();
    internal static string get_ExportingVariable();
    internal static string get_ImportingNonStandardVerb();
    internal static string get_ImportingNonStandardVerbVerbose();
    internal static string get_ImportingNonStandardVerbVerboseSuggestion();
    internal static string get_ImportingNonStandardNoun();
    internal static string get_ImportingNonStandardNounVerbose();
    internal static string get_CreatingModuleManifestFile();
    internal static string get_ConfirmRemoveModule();
    internal static string get_InvalidProcessorArchitecture();
    internal static string get_InvalidPowerShellHostName();
    internal static string get_InvalidPowerShellHostVersion();
    internal static string get_ManifestHeaderLine1();
    internal static string get_ManifestHeaderLine2();
    internal static string get_ManifestHeaderLine3();
    internal static string get_RootModule();
    internal static string get_NestedModules();
    internal static string get_GUID();
    internal static string get_Author();
    internal static string get_CompanyName();
    internal static string get_Copyright();
    internal static string get_ModuleVersion();
    internal static string get_Description();
    internal static string get_PowerShellVersion();
    internal static string get_CLRVersion();
    internal static string get_RequiredModules();
    internal static string get_ScriptsToProcess();
    internal static string get_TypesToProcess();
    internal static string get_FormatsToProcess();
    internal static string get_RequiredAssemblies();
    internal static string get_FileList();
    internal static string get_PrivateData();
    internal static string get_Tags();
    internal static string get_ProjectUri();
    internal static string get_LicenseUri();
    internal static string get_IconUri();
    internal static string get_ReleaseNotes();
    internal static string get_Prerelease();
    internal static string get_RequireLicenseAcceptance();
    internal static string get_ExternalModuleDependencies();
    internal static string get_EndOfManifestHashTable();
    internal static string get_PrivateDataValueTypeShouldBeHashTableError();
    internal static string get_PrivateDataValueTypeShouldBeHashTableWarning();
    internal static string get_InvalidParameterValue();
    internal static string get_FunctionsToExport();
    internal static string get_AliasesToExport();
    internal static string get_CmdletsToExport();
    internal static string get_VariablesToExport();
    internal static string get_DscResourcesToExport();
    internal static string get_CompatiblePSEditions();
    internal static string get_ProcessorArchitecture();
    internal static string get_ModuleList();
    internal static string get_DotNetFrameworkVersion();
    internal static string get_PowerShellHostName();
    internal static string get_PowerShellHostVersion();
    internal static string get_HelpInfoURI();
    internal static string get_ModuleDriveInUse();
    internal static string get_ImportModuleNoClobberForCmdlet();
    internal static string get_ImportModuleNoClobberForAlias();
    internal static string get_ImportModuleNoClobberForFunction();
    internal static string get_ImportModuleNoClobberForVariable();
    internal static string get_WildCardNotAllowedInModuleToProcessAndInNestedModules();
    internal static string get_CoreModuleCannotBeRemoved();
    internal static string get_ModuleManifestCannotContainBothModuleToProcessAndRootModule();
    internal static string get_ModuleToProcessFieldDeprecated();
    internal static string get_DefaultCommandPrefix();
    internal static string get_GlobalAndScopeParameterCannotBeSpecifiedTogether();
    internal static string get_RequiredModulesCyclicDependency();
    internal static string get_RequiredModuleNotFound();
    internal static string get_MixedModuleOverCimSessionWarning();
    internal static string get_WinCompatModuleWarning();
    internal static string get_WinCompatRequredVersionError();
    internal static string get_WinCompatModuleInDenyList();
    internal static string get_PsModuleOverCimSessionError();
    internal static string get_InvalidProcessorArchitectureInManifest();
    internal static string get_RemoteDiscoveryWorksOnlyInListAvailableMode();
    internal static string get_ModuleLoadedAsASnapin();
    internal static string get_WildCardNotAllowedInRequiredAssemblies();
    internal static string get_CmdletizationDoesSupportRexportingNestedModules();
    internal static string get_RemoteDiscoveryRemotePsrpCommandFailed();
    internal static string get_RemoteDiscoveryFailedToGenerateProxyForRemoteModule();
    internal static string get_RemoteDiscoveryFailedToProcessRemoteModule();
    internal static string get_RemoteDiscoveryFailureFromDiscoveryProvider();
    internal static string get_RequiredModuleNotFoundWrongGuidVersion();
    internal static string get_RemoteDiscoveryProviderNotFound();
    internal static string get_CannotDetectNetFrameworkVersion();
    internal static string get_ScriptAnalysisModule();
    internal static string get_ScriptAnalysisPreparing();
    internal static string get_DeterminingAvailableModules();
    internal static string get_SearchingUncShare();
    internal static string get_RemoteDiscoveryWorksOnlyForUnQualifiedNames();
    internal static string get_ModuleDiscoveryForLoadedModulesWorksOnlyForUnQualifiedNames();
    internal static string get_ModuleNotFoundForGetModule();
    internal static string get_PopulatingRepositorySourceLocation();
    internal static string get_ManifestMemberNotValid();
    internal static string get_PrerequisiteForDesktopEditionOnly();
    internal static string get_PSEditionNotSupported();
    internal static string get_ImplicitWinCompatDisabled();
    internal static string get_ExperimentalFeatureNameMissingOrEmpty();
    internal static string get_InvalidExperimentalFeatureName();
    internal static string get_SkipEditionCheckNotSupportedWithoutListAvailable();
    internal static string get_ImportPSFileNotAllowedInConstrainedLanguage();
    internal static string get_MismatchedLanguageModes();
    internal static string get_CannotUseDotSourceWithWildCardFunctionExport();
    internal static string get_CannotExportMembersAccrossLanguageBoundaries();
    internal static string get_CannotCreateModuleWithScriptBlock();
    internal static string get_CannotFindCoreCompatibleBuiltInModule();
    internal static string get_WDACExportModuleCommandLogTitle();
    internal static string get_WDACExportModuleCommandLogMessage();
    internal static string get_WDACImplicitFunctionExportLogTitle();
    internal static string get_WDACImplicitFunctionExportLogMessage();
    internal static string get_WDACScriptFileImportLogTitle();
    internal static string get_WDACScriptFileImportLogMessage();
    internal static string get_WDACModuleDotSourceLogTitle();
    internal static string get_WDACModuleDotSourceLogMessage();
    internal static string get_WDACModuleFnExportWithNestedModulesLogTitle();
    internal static string get_WDACModuleFnExportWithNestedModulesLogMessage();
    internal static string get_WDACNewModuleCommandLogTitle();
    internal static string get_WDACNewModuleCommandLogMessage();
    internal static string get_WDACMismatchedLanguageModesTitle();
    internal static string get_WDACMismatchedLanguageModesMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MshHostRawUserInterfaceStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string LessThanErrorTemplate { get; }
    internal static string NonPositiveNumberErrorTemplate { get; }
    internal static string AllNullOrEmptyStringsErrorTemplate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_LessThanErrorTemplate();
    internal static string get_NonPositiveNumberErrorTemplate();
    internal static string get_AllNullOrEmptyStringsErrorTemplate();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MshSignature : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MshSignature_Valid { get; }
    internal static string MshSignature_NotSigned { get; }
    internal static string MshSignature_HashMismatch { get; }
    internal static string MshSignature_NotTrusted { get; }
    internal static string MshSignature_NotSupportedFileFormat { get; }
    internal static string MshSignature_NotSupportedFileFormat_NoExtension { get; }
    internal static string MshSignature_Incompatible { get; }
    internal static string MshSignature_Incompatible_HashAlgorithm { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MshSignature_Valid();
    internal static string get_MshSignature_NotSigned();
    internal static string get_MshSignature_HashMismatch();
    internal static string get_MshSignature_NotTrusted();
    internal static string get_MshSignature_NotSupportedFileFormat();
    internal static string get_MshSignature_NotSupportedFileFormat_NoExtension();
    internal static string get_MshSignature_Incompatible();
    internal static string get_MshSignature_Incompatible_HashAlgorithm();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MshSnapInCmdletResources : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CmdletNotAvailable { get; }
    internal static string NoPSSnapInsFound { get; }
    internal static string InvalidPSSnapInName { get; }
    internal static string LoadSystemSnapinAsModule { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CmdletNotAvailable();
    internal static string get_NoPSSnapInsFound();
    internal static string get_InvalidPSSnapInName();
    internal static string get_LoadSystemSnapinAsModule();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class MshSnapinInfo : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MonadRootRegistryAccessFailed { get; }
    internal static string MonadEngineRegistryAccessFailed { get; }
    internal static string PublicKeyTokenAccessFailed { get; }
    internal static string SpecifiedVersionNotFound { get; }
    internal static string MshSnapinDoesNotExist { get; }
    internal static string MandatoryValueNotPresent { get; }
    internal static string MandatoryValueNotInCorrectFormat { get; }
    internal static string MandatoryValueNotInCorrectFormatMultiString { get; }
    internal static string DefaultMshSnapinNotPresent { get; }
    internal static string NoMshSnapinPresentForVersion { get; }
    internal static string ResourceReaderDisposed { get; }
    internal static string VersionValueInCorrect { get; }
    internal static string PSVersionAttributeNotExist { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MonadRootRegistryAccessFailed();
    internal static string get_MonadEngineRegistryAccessFailed();
    internal static string get_PublicKeyTokenAccessFailed();
    internal static string get_SpecifiedVersionNotFound();
    internal static string get_MshSnapinDoesNotExist();
    internal static string get_MandatoryValueNotPresent();
    internal static string get_MandatoryValueNotInCorrectFormat();
    internal static string get_MandatoryValueNotInCorrectFormatMultiString();
    internal static string get_DefaultMshSnapinNotPresent();
    internal static string get_NoMshSnapinPresentForVersion();
    internal static string get_ResourceReaderDisposed();
    internal static string get_VersionValueInCorrect();
    internal static string get_PSVersionAttributeNotExist();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class NativeCP : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IncorrectValueForCommandParameter { get; }
    internal static string NoValueForCommandParameter { get; }
    internal static string IncorrectValueForFormatParameter { get; }
    internal static string NoValueForInputFormatParameter { get; }
    internal static string NoValueForOutputFormatParameter { get; }
    internal static string StringValueExpectedForFormatParameter { get; }
    internal static string NoValuesSpecifiedForArgs { get; }
    internal static string ParameterSpecifiedAlready { get; }
    internal static string CliXmlError { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IncorrectValueForCommandParameter();
    internal static string get_NoValueForCommandParameter();
    internal static string get_IncorrectValueForFormatParameter();
    internal static string get_NoValueForInputFormatParameter();
    internal static string get_NoValueForOutputFormatParameter();
    internal static string get_StringValueExpectedForFormatParameter();
    internal static string get_NoValuesSpecifiedForArgs();
    internal static string get_ParameterSpecifiedAlready();
    internal static string get_CliXmlError();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ParameterBinderStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NamedParameterNotFound { get; }
    internal static string PositionalParameterNotFound { get; }
    internal static string MissingArgument { get; }
    internal static string AmbiguousParameter { get; }
    internal static string CannotConvertArgument { get; }
    internal static string CannotConvertArgumentNoMessage { get; }
    internal static string AmbiguousPositionalParameter { get; }
    internal static string AmbiguousPositionalParameterNoName { get; }
    internal static string AmbiguousParameterSet { get; }
    internal static string MissingMandatoryParameter { get; }
    internal static string ParameterNotInParameterSet { get; }
    internal static string ParameterAlreadyBound { get; }
    internal static string ScriptBlockArgumentNoInput { get; }
    internal static string ScriptBlockArgumentInvocationFailed { get; }
    internal static string ScriptBlockArgumentNoOutput { get; }
    internal static string InputObjectNotBound { get; }
    internal static string InputObjectMissingMandatory { get; }
    internal static string GetDefaultValueFailed { get; }
    internal static string GetDynamicParametersException { get; }
    internal static string PromptMessage { get; }
    internal static string PromptCaption { get; }
    internal static string ParameterArgumentTransformationError { get; }
    internal static string ParameterArgumentTransformationErrorMessageOnly { get; }
    internal static string ParameterArgumentValidationError { get; }
    internal static string ParameterBindingFailed { get; }
    internal static string ParameterArgumentValidationErrorNullNotAllowed { get; }
    internal static string ParameterArgumentValidationErrorEmptyStringNotAllowed { get; }
    internal static string ParameterArgumentValidationErrorEmptyCollectionNotAllowed { get; }
    internal static string ParameterArgumentValidationErrorEmptyArrayNotAllowed { get; }
    internal static string DuplicateParameterDefinition { get; }
    internal static string CannotExtractAddMethod { get; }
    internal static string RuntimeDefinedParameterNameMismatch { get; }
    internal static string MismatchedPSTypeName { get; }
    internal static string DifferentValuesAssignedToSingleParameter { get; }
    internal static string MultipleParametersMatched { get; }
    internal static string DefaultBindingErrorElaborationMultiple { get; }
    internal static string DefaultBindingErrorElaborationSingle { get; }
    internal static string FailToBindDefaultParameter { get; }
    internal static string SingleKeyInBadFormat { get; }
    internal static string MultipleKeysInBadFormat { get; }
    internal static string UseOfDeprecatedParameterWarning { get; }
    internal static string StringValueKeyExpected { get; }
    internal static string KeyAlreadyAdded { get; }
    internal static string WDACBinderInvocationLogTitle { get; }
    internal static string WDACBinderInvocationLogMessage { get; }
    internal static string WDACBinderTypeCreationLogTitle { get; }
    internal static string WDACBinderTypeCreationLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NamedParameterNotFound();
    internal static string get_PositionalParameterNotFound();
    internal static string get_MissingArgument();
    internal static string get_AmbiguousParameter();
    internal static string get_CannotConvertArgument();
    internal static string get_CannotConvertArgumentNoMessage();
    internal static string get_AmbiguousPositionalParameter();
    internal static string get_AmbiguousPositionalParameterNoName();
    internal static string get_AmbiguousParameterSet();
    internal static string get_MissingMandatoryParameter();
    internal static string get_ParameterNotInParameterSet();
    internal static string get_ParameterAlreadyBound();
    internal static string get_ScriptBlockArgumentNoInput();
    internal static string get_ScriptBlockArgumentInvocationFailed();
    internal static string get_ScriptBlockArgumentNoOutput();
    internal static string get_InputObjectNotBound();
    internal static string get_InputObjectMissingMandatory();
    internal static string get_GetDefaultValueFailed();
    internal static string get_GetDynamicParametersException();
    internal static string get_PromptMessage();
    internal static string get_PromptCaption();
    internal static string get_ParameterArgumentTransformationError();
    internal static string get_ParameterArgumentTransformationErrorMessageOnly();
    internal static string get_ParameterArgumentValidationError();
    internal static string get_ParameterBindingFailed();
    internal static string get_ParameterArgumentValidationErrorNullNotAllowed();
    internal static string get_ParameterArgumentValidationErrorEmptyStringNotAllowed();
    internal static string get_ParameterArgumentValidationErrorEmptyCollectionNotAllowed();
    internal static string get_ParameterArgumentValidationErrorEmptyArrayNotAllowed();
    internal static string get_DuplicateParameterDefinition();
    internal static string get_CannotExtractAddMethod();
    internal static string get_RuntimeDefinedParameterNameMismatch();
    internal static string get_MismatchedPSTypeName();
    internal static string get_DifferentValuesAssignedToSingleParameter();
    internal static string get_MultipleParametersMatched();
    internal static string get_DefaultBindingErrorElaborationMultiple();
    internal static string get_DefaultBindingErrorElaborationSingle();
    internal static string get_FailToBindDefaultParameter();
    internal static string get_SingleKeyInBadFormat();
    internal static string get_MultipleKeysInBadFormat();
    internal static string get_UseOfDeprecatedParameterWarning();
    internal static string get_StringValueKeyExpected();
    internal static string get_KeyAlreadyAdded();
    internal static string get_WDACBinderInvocationLogTitle();
    internal static string get_WDACBinderInvocationLogMessage();
    internal static string get_WDACBinderTypeCreationLogTitle();
    internal static string get_WDACBinderTypeCreationLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ParserStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string TypeNotFound { get; }
    internal static string TypeNotFoundWithMessage { get; }
    internal static string IncompleteString { get; }
    internal static string InvalidUnicodeEscapeSequence { get; }
    internal static string InvalidUnicodeEscapeSequenceValue { get; }
    internal static string MissingUnicodeEscapeSequenceTerminator { get; }
    internal static string TooManyDigitsInUnicodeEscapeSequence { get; }
    internal static string ReferenceNeedsToBeByItselfInTypeConstraint { get; }
    internal static string ReferenceNeedsToBeLastTypeInTypeConversion { get; }
    internal static string ReferenceNeedsToBeByItselfInTypeSequence { get; }
    internal static string BadNumericConstant { get; }
    internal static string InvalidRegularExpression { get; }
    internal static string EmptyVariableReference { get; }
    internal static string InvalidVariableReference { get; }
    internal static string InvokeMethodOnNull { get; }
    internal static string MethodNotFound { get; }
    internal static string ParameterizedPropertyAssignmentFailed { get; }
    internal static string UnexpectedToken { get; }
    internal static string SplattingNotPermitted { get; }
    internal static string InvalidParameter { get; }
    internal static string MissingExpression { get; }
    internal static string BadExpression { get; }
    internal static string ParameterRequiresArgument { get; }
    internal static string ParameterCannotHaveArgument { get; }
    internal static string DuplicateFormalParameter { get; }
    internal static string MissingArgument { get; }
    internal static string SplattingNotPermittedInArgumentList { get; }
    internal static string MissingFileSpecification { get; }
    internal static string RedirectionNotSupported { get; }
    internal static string RedirectionFailed { get; }
    internal static string ExpressionsMustBeFirstInPipeline { get; }
    internal static string EmptyPipeElement { get; }
    internal static string InvalidLeftHandSide { get; }
    internal static string AddHashTableToNonHashTable { get; }
    internal static string IsOperatorRequiresType { get; }
    internal static string AsOperatorRequiresType { get; }
    internal static string FormatError { get; }
    internal static string BadOperatorArgument { get; }
    internal static string OperatorFailed { get; }
    internal static string BadReplaceArgument { get; }
    internal static string ExpectedValueExpression { get; }
    internal static string OperatorRequiresVariableOrProperty { get; }
    internal static string OrderedAttributeOnlyOnHashLiteralNode { get; }
    internal static string MissingArrayIndexExpression { get; }
    internal static string MissingPropertyName { get; }
    internal static string PropertyNotFound { get; }
    internal static string PropertyNotFoundStrict { get; }
    internal static string NullArrayIndex { get; }
    internal static string NullArray { get; }
    internal static string CannotIndex { get; }
    internal static string CannotIndexWithByRefLikeReturnType { get; }
    internal static string ArrayHasTooManyDimensions { get; }
    internal static string ArraySliceAssignmentFailed { get; }
    internal static string NeedMultidimensionalIndex { get; }
    internal static string IndexOutOfRange { get; }
    internal static string MissingExpressionAfterToken { get; }
    internal static string IncompleteDollarVariableReference { get; }
    internal static string IncompleteDollarSubexpressionReference { get; }
    internal static string UnexpectedUnaryOperator { get; }
    internal static string NonExistingVariableReference { get; }
    internal static string VariableIsUndefined { get; }
    internal static string DuplicateKeyInHashLiteral { get; }
    internal static string DuplicateNamedArgument { get; }
    internal static string OperatorRequiresNumber { get; }
    internal static string ExpectedExpression { get; }
    internal static string MissingEqualsInHashLiteral { get; }
    internal static string MissingStatementInHashLiteral { get; }
    internal static string MissingExpressionInNamedArgument { get; }
    internal static string MissingPropertyTerminator { get; }
    internal static string MissingExpressionAfterOperator { get; }
    internal static string IfStatementMissingCondition { get; }
    internal static string MissingStatementBlock { get; }
    internal static string MissingStatementBlockAfterElse { get; }
    internal static string FileReadError { get; }
    internal static string FileOpenError { get; }
    internal static string FileNotFound { get; }
    internal static string AmbiguousPath { get; }
    internal static string KeywordParameterReservedForFutureUse { get; }
    internal static string MissingFilenameOption { get; }
    internal static string InvalidFilenameOption { get; }
    internal static string InvalidSwitchFlag { get; }
    internal static string InvalidForeachFlag { get; }
    internal static string PipelineValueRequired { get; }
    internal static string MissingSwitchConditionExpression { get; }
    internal static string MultipleSwitchDefaultClauses { get; }
    internal static string MissingSwitchStatementClause { get; }
    internal static string MissingForeachExpression { get; }
    internal static string MissingForeachStatement { get; }
    internal static string OnlyOneParameterListAllowed { get; }
    internal static string NotADefinedOperationForType { get; }
    internal static string BadEnumeration { get; }
    internal static string COMException { get; }
    internal static string InvalidComObjectException { get; }
    internal static string ScriptTooComplicated { get; }
    internal static string ScriptsNotAllowed { get; }
    internal static string InvalidSplitOptionCombination { get; }
    internal static string InvalidSplitOptionWithPredicate { get; }
    internal static string InvalidEndOfLine { get; }
    internal static string ReservedKeywordNotAllowed { get; }
    internal static string MissingExpressionAfterKeyword { get; }
    internal static string MissingLoopStatement { get; }
    internal static string MissingTrapStatement { get; }
    internal static string MissingTryStatement { get; }
    internal static string InvalidFunctionParameter { get; }
    internal static string MissingFunctionBody { get; }
    internal static string DuplicateScriptCommandClause { get; }
    internal static string MissingNamedBlocks { get; }
    internal static string MissingEndCurlyBrace { get; }
    internal static string MissingEndParenthesisInMethodCall { get; }
    internal static string MissingEndSquareBracket { get; }
    internal static string MissingEndParenthesisInExpression { get; }
    internal static string MissingEndParenthesisInSubexpression { get; }
    internal static string MissingOpenParenthesisInIfStatement { get; }
    internal static string MissingEndParenthesisInSwitchStatement { get; }
    internal static string MissingCurlyBraceInSwitchStatement { get; }
    internal static string MissingVariableNameAfterForeach { get; }
    internal static string MissingInInForeach { get; }
    internal static string MissingEndParenthesisAfterForeach { get; }
    internal static string MissingOpenParenthesisAfterKeyword { get; }
    internal static string MissingWhileOrUntilInDoWhile { get; }
    internal static string MissingEndParenthesisAfterStatement { get; }
    internal static string MissingNameAfterKeyword { get; }
    internal static string MissingEndParenthesisInFunctionParameterList { get; }
    internal static string BackupParserMessage { get; }
    internal static string BackupParserMessageWithException { get; }
    internal static string ScriptBlockDelegateInvokedFromWrongThread { get; }
    internal static string UnrecognizedToken { get; }
    internal static string ExceptionActionPromptCaption { get; }
    internal static string ContinueLabel { get; }
    internal static string ContinueHelpMessage { get; }
    internal static string SilentlyContinueLabel { get; }
    internal static string SilentlyContinueHelpMessage { get; }
    internal static string BreakLabel { get; }
    internal static string BreakHelpMessage { get; }
    internal static string SuspendLabel { get; }
    internal static string SuspendHelpMessage { get; }
    internal static string CantActivateDocumentInPipeline { get; }
    internal static string ProgramFailedToExecute { get; }
    internal static string CantInvokeInBinaryModule { get; }
    internal static string CantInvokeInNonImportedModule { get; }
    internal static string TokenAfterEndOfValidScriptText { get; }
    internal static string TextForWordLine { get; }
    internal static string TextForPositionMessage { get; }
    internal static string TraceScriptLineMessage { get; }
    internal static string TraceVariableAssignment { get; }
    internal static string TraceEnteringFunction { get; }
    internal static string TraceEnteringFunctionDefinedInFile { get; }
    internal static string TraceMethodCall { get; }
    internal static string TerminatorExpectedAtEndOfString { get; }
    internal static string WhitespaceBeforeHereStringFooter { get; }
    internal static string EndSquareBracketExpectedAtEndOfType { get; }
    internal static string OpenBraceNeedsToBeBackTickedInVariableName { get; }
    internal static string MissingStatementBlockForDataSection { get; }
    internal static string InvalidParameterForDataSectionStatement { get; }
    internal static string ArrayReferenceNotSupportedInDataSection { get; }
    internal static string AssignmentStatementNotSupportedInDataSection { get; }
    internal static string RedirectionNotSupportedInDataSection { get; }
    internal static string DoWhileStatementNotSupportedInDataSection { get; }
    internal static string ExpandableStringNotSupportedInDataSection { get; }
    internal static string OperatorNotSupportedInDataSection { get; }
    internal static string TrapStatementNotSupportedInDataSection { get; }
    internal static string TryStatementNotSupportedInDataSection { get; }
    internal static string FlowControlStatementNotSupportedInDataSection { get; }
    internal static string ForeachStatementNotSupportedInDataSection { get; }
    internal static string ForWhileStatementNotSupportedInDataSection { get; }
    internal static string FunctionDeclarationNotSupportedInDataSection { get; }
    internal static string MethodCallNotSupportedInDataSection { get; }
    internal static string ParameterDeclarationNotSupportedInDataSection { get; }
    internal static string PropertyReferenceNotSupportedInDataSection { get; }
    internal static string ScriptBlockNotSupportedInDataSection { get; }
    internal static string SwitchStatementNotSupportedInDataSection { get; }
    internal static string VariableReferenceNotSupportedInDataSection { get; }
    internal static string CmdletNotInAllowedListForDataSection { get; }
    internal static string DataSectionStatementNotSupportedInDataSection { get; }
    internal static string MissingValueForSupportedCommandInDataSectionStatement { get; }
    internal static string InvalidScriptBlockInDataSection { get; }
    internal static string StringMultiplyToolongInDataSection { get; }
    internal static string ArrayMultiplyToolongInDataSection { get; }
    internal static string DotSourcingNotSupportedInDataSection { get; }
    internal static string ParameterAttributeArgumentNeedsToBeConstantOrScriptBlock { get; }
    internal static string CustomAttributeTypeNotFound { get; }
    internal static string PropertyNotFoundForType { get; }
    internal static string UnexpectedAttribute { get; }
    internal static string EndSquareBracketExpectedAtEndOfAttribute { get; }
    internal static string StrictModeFunctionCallWithParens { get; }
    internal static string MissingTryStatementBlock { get; }
    internal static string MissingCatchOrFinally { get; }
    internal static string MissingCatchHandlerBlock { get; }
    internal static string MissingFinallyStatementBlock { get; }
    internal static string ExceptionTypeAlreadyCaught { get; }
    internal static string EmptyCatchNotLast { get; }
    internal static string MissingTypeLiteralToken { get; }
    internal static string MissingTerminatorMultiLineComment { get; }
    internal static string UnexpectedCharactersAfterHereStringHeader { get; }
    internal static string ErrorCollection { get; }
    internal static string MissingNamedStatementBlock { get; }
    internal static string TypeNotAllowedBeforeParam { get; }
    internal static string TypeNotAllowedBeforeStatement { get; }
    internal static string InvalidNullKey { get; }
    internal static string AttributeNotSupportedInDataSection { get; }
    internal static string TypeNotAllowedInDataSection { get; }
    internal static string PropertyIsReadOnly { get; }
    internal static string MissingAssemblyNameSpecification { get; }
    internal static string ControlLeavingFinally { get; }
    internal static string UnrecoverableParserError { get; }
    internal static string AstIsReused { get; }
    internal static string InvalidUsingExpression { get; }
    internal static string UsingWithoutInvokeCommand { get; }
    internal static string InvalidBracedVariableReference { get; }
    internal static string InvalidVariableReferenceWithDrive { get; }
    internal static string TooManyErrors { get; }
    internal static string MissingTypename { get; }
    internal static string AllStream { get; }
    internal static string DebugStream { get; }
    internal static string ErrorStream { get; }
    internal static string OutputStream { get; }
    internal static string StreamAlreadyRedirected { get; }
    internal static string VerboseStream { get; }
    internal static string WarningStream { get; }
    internal static string MissingStatementAfterKeyword { get; }
    internal static string ParallelAndSequenceBlockNotSupportedInDataSection { get; }
    internal static string UnexpectedKeyword { get; }
    internal static string VoidTypeConstraintNotAllowed { get; }
    internal static string CannotInvoke { get; }
    internal static string HashtableToObjectConversionNotSupportedInDataSection { get; }
    internal static string RequiresArgumentMustBeConstant { get; }
    internal static string RequiresInvalidStringArgument { get; }
    internal static string RequiresModuleInvalid { get; }
    internal static string RequiresVersionInvalid { get; }
    internal static string RequiresPSEditionInvalid { get; }
    internal static string RequiresPSEditionValueIsAlreadySpecified { get; }
    internal static string WildCardModuleNameError { get; }
    internal static string InvokeMethodConstrainedLanguage { get; }
    internal static string PropertySetConstrainedLanguage { get; }
    internal static string ConfigurationInvalidPropertyName { get; }
    internal static string InvalidInstanceProperty { get; }
    internal static string MissingBraceInObjectDefinition { get; }
    internal static string RequiredNameOrExpressionMissing { get; }
    internal static string SchemaFileNotFound { get; }
    internal static string DataSectionAllowedCommandDisallowed { get; }
    internal static string MissingCurlyInConfigurationStatement { get; }
    internal static string ExceptionParsingMOFFile { get; }
    internal static string MissingConfigurationName { get; }
    internal static string ModuleNotFoundDuringParse { get; }
    internal static string MultipleModuleEntriesFoundDuringParse { get; }
    internal static string MissingThrottleLimit { get; }
    internal static string ThrottleLimitRequiresParallelFlag { get; }
    internal static string ConfigurationBodyEmpty { get; }
    internal static string UnexpectedNameForType { get; }
    internal static string IncompletePropertyAssignmentBlock { get; }
    internal static string MissingEqualsInPropertyAssignmentBlock { get; }
    internal static string DuplicatePropertyInInstanceDefinition { get; }
    internal static string DuplicateCimClassDefinition { get; }
    internal static string DuplicateKeywordDefinition { get; }
    internal static string ClassNameNotSameAsDefiningFile { get; }
    internal static string DuplicateResourceIdInNodeStatement { get; }
    internal static string UnexpectedTokenInDynamicKeyword { get; }
    internal static string EmptyFunctionNameInFunctionDefinitionDictionary { get; }
    internal static string GetBadlyFormedRequiredResourceId { get; }
    internal static string GetBadlyFormedExclusiveResourceId { get; }
    internal static string GetPullModeNeedConfigurationSource { get; }
    internal static string NullEntryInVariablesDefinitionList { get; }
    internal static string NullFunctionBodyInFunctionDefinitionDictionary { get; }
    internal static string ImportDscResourceNeedParams { get; }
    internal static string ImportDscResourceMultipleModulesNotSupportedWithName { get; }
    internal static string ImportDscResourcePositionalParamsNotSupported { get; }
    internal static string DscResourcesNotFoundDuringParsing { get; }
    internal static string ConfigurationNotAllowedInConstrainedLanguage { get; }
    internal static string InvalidConfigurationName { get; }
    internal static string UnsupportedNamedBlockInConfiguration { get; }
    internal static string CimDeserializationError { get; }
    internal static string InvalidValueForProperty { get; }
    internal static string UnsupportedValueForProperty { get; }
    internal static string MissingValueForMandatoryProperty { get; }
    internal static string ValueNotInRange { get; }
    internal static string CannotLoadPowerShellDataFile { get; }
    internal static string CannotResolvePowerShellDataFilePath { get; }
    internal static string InvalidPowerShellDataFile { get; }
    internal static string ConfigurationNotAllowedOnWinPE { get; }
    internal static string EmptyExpressionRequiresANonDefaultMode { get; }
    internal static string ForEachBadGenericConversionTypeSpecified { get; }
    internal static string ForEachTypeConversionFailed { get; }
    internal static string ForEachNotSupportCleanBlock { get; }
    internal static string NumberToReturnMustBeGreaterThanZero { get; }
    internal static string RedirectionStreamCanOnlyMergeToOutputStream { get; }
    internal static string ForEachNonexistentMemberReference { get; }
    internal static string UnsupportedReservedKeyword { get; }
    internal static string UnsupportedReservedProperty { get; }
    internal static string DuplicateQualifier { get; }
    internal static string ModifiersCannotBeCombined { get; }
    internal static string MissingUsingStatementDirective { get; }
    internal static string MissingNamespaceAlias { get; }
    internal static string MissingEqualsInUsingAlias { get; }
    internal static string MissingUsingItemName { get; }
    internal static string VariableNotLocal { get; }
    internal static string IncompleteMemberDefinition { get; }
    internal static string MemberAlreadyDefined { get; }
    internal static string TooManyTypes { get; }
    internal static string TypeCreationError { get; }
    internal static string CannotConvertValue { get; }
    internal static string PropertyNotFoundForAttribute { get; }
    internal static string AttributeNotAllowedOnDeclaration { get; }
    internal static string ParameterAttributeArgumentNeedsToBeConstant { get; }
    internal static string ResourceNotDefined { get; }
    internal static string DynamicKeywordPreParseException { get; }
    internal static string DynamicKeywordPostParseException { get; }
    internal static string WorkflowNotSupportedInPowerShellCore { get; }
    internal static string MetaConfigurationUsedInRegularConfig { get; }
    internal static string RegularResourceUsedInMetaConfig { get; }
    internal static string GetSteppablePipelineFromWrongThread { get; }
    internal static string AmbiguousConversion { get; }
    internal static string CannotCall { get; }
    internal static string CannotRetrieveTypeInformation { get; }
    internal static string CouldNotGetDispId { get; }
    internal static string DispBadParamCount { get; }
    internal static string DispMemberNotFound { get; }
    internal static string DispNoNamedArgs { get; }
    internal static string DispOverflow { get; }
    internal static string DispParamNotOptional { get; }
    internal static string DispTypeMismatch { get; }
    internal static string GetIDsOfNamesInvalid { get; }
    internal static string SetComObjectDataFailed { get; }
    internal static string UnexpectedVarEnum { get; }
    internal static string UnsupportedHandlerType { get; }
    internal static string ConfigurationNotSupportedInPowerShellCore { get; }
    internal static string MethodHasCodePathNotReturn { get; }
    internal static string VoidMethodHasReturn { get; }
    internal static string NonVoidMethodMissingReturnValue { get; }
    internal static string MissingTypeBody { get; }
    internal static string CycleInEnumInitializers { get; }
    internal static string EnumeratorValueOutOfBounds { get; }
    internal static string EnumeratorValueMustBeConstant { get; }
    internal static string DynamicKeywordSemanticCheckException { get; }
    internal static string UnsupportedPropertyTypeOfDSCResourceClass { get; }
    internal static string MissingMethodParameterList { get; }
    internal static string NamedBlockNotAllowedInMethod { get; }
    internal static string ParamBlockNotAllowedInMethod { get; }
    internal static string SealedBaseClass { get; }
    internal static string TypeNameExpected { get; }
    internal static string InvalidUnderlyingType { get; }
    internal static string InterfaceNameExpected { get; }
    internal static string BaseClassNoDefaultCtor { get; }
    internal static string SubtypeArray { get; }
    internal static string SubtypeUnclosedGeneric { get; }
    internal static string MissingBaseCtorCall { get; }
    internal static string ConstructorCantHaveReturnType { get; }
    internal static string DscResourceMissingDefaultConstructor { get; }
    internal static string DscResourceMissingGetMethod { get; }
    internal static string DscResourceMissingKeyProperty { get; }
    internal static string DscResourceMissingSetMethod { get; }
    internal static string DscResourceMissingTestMethod { get; }
    internal static string StaticConstructorCantHaveParameters { get; }
    internal static string TypeNotAllowedForProperty { get; }
    internal static string TypeNotAllowedForParameter { get; }
    internal static string NonStaticMemberAccessInStaticMember { get; }
    internal static string FailToParseModuleScriptFile { get; }
    internal static string CantActivateDocumentInPowerShellCore { get; }
    internal static string MultipleTypeConstraintsOnMethodParam { get; }
    internal static string ScriptContainedMaliciousContent { get; }
    internal static string InvalidLocalConfigurationManagerProperty { get; }
    internal static string PropertyInGenericType { get; }
    internal static string AmbiguousTypeReference { get; }
    internal static string UsingMustBeAtStartOfScript { get; }
    internal static string UsingStatementNotSupported { get; }
    internal static string InformationStream { get; }
    internal static string DscResourceInvalidKeyProperty { get; }
    internal static string DscResourceInvalidGetMethod { get; }
    internal static string ErrorLoadingAssembly { get; }
    internal static string CannotLoadAssemblyFromUncPath { get; }
    internal static string CannotLoadAssemblyWithUriSchema { get; }
    internal static string MissingStatementTerminator { get; }
    internal static string MissingThis { get; }
    internal static string InvalidValueForUsingItemName { get; }
    internal static string MissingTypeInStaticPropertyAssignment { get; }
    internal static string DebugModeShouldHaveOneValue { get; }
    internal static string LabelNotFound { get; }
    internal static string ConvertCimPropertyToObjectPropertyFailed { get; }
    internal static string ExpectArrayTypeOfPropertyInPSClass { get; }
    internal static string InstantiatePSClassObjectFailed { get; }
    internal static string InvalidHashtable { get; }
    internal static string InvalidPassword { get; }
    internal static string InvalidUserName { get; }
    internal static string PropertyNotDeclaredInPSClass { get; }
    internal static string DisabledRefreshModeNotValidForPartialConfig { get; }
    internal static string CannotCreateTypeConstrainedLanguage { get; }
    internal static string ImportDscResourceInsideNode { get; }
    internal static string DefaultAllowedVariablesInDataSection { get; }
    internal static string AssignmentStatementToAutomaticNotSupported { get; }
    internal static string PsDscRunAsCredentialMergeErrorForCompositeResources { get; }
    internal static string PsDscMissingSchemaStore { get; }
    internal static string ParserError { get; }
    internal static string ScriptHasAdminBlockedContent { get; }
    internal static string CantInvokeCallOperatorAcrossLanguageBoundaries { get; }
    internal static string ClassesNotAllowedInConstrainedLanguage { get; }
    internal static string MissingColonInTernaryExpression { get; }
    internal static string EmptyPipelineChainElement { get; }
    internal static string BackgroundOperatorInPipelineChain { get; }
    internal static string InvokingCleanBlockNotSupported { get; }
    internal static string WDACParserConfigKeywordLogTitle { get; }
    internal static string WDACParserConfigKeywordLogMessage { get; }
    internal static string WDACParserClassKeywordLogTitle { get; }
    internal static string WDACParserClassKeywordLogMessage { get; }
    internal static string WDACParserDSSupportedCommandLogTitle { get; }
    internal static string WDACParserDSSupportedCommandLogMessage { get; }
    internal static string WDACParserModuleScopeCallOperatorLogTitle { get; }
    internal static string WDACParserModuleScopeCallOperatorLogMessage { get; }
    internal static string WDACParserForEachOperatorLogTitle { get; }
    internal static string WDACParserForEachOperatorLogMessage { get; }
    internal static string WDACGetSteppablePipelineLogTitle { get; }
    internal static string WDACGetSteppablePipelineLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_TypeNotFound();
    internal static string get_TypeNotFoundWithMessage();
    internal static string get_IncompleteString();
    internal static string get_InvalidUnicodeEscapeSequence();
    internal static string get_InvalidUnicodeEscapeSequenceValue();
    internal static string get_MissingUnicodeEscapeSequenceTerminator();
    internal static string get_TooManyDigitsInUnicodeEscapeSequence();
    internal static string get_ReferenceNeedsToBeByItselfInTypeConstraint();
    internal static string get_ReferenceNeedsToBeLastTypeInTypeConversion();
    internal static string get_ReferenceNeedsToBeByItselfInTypeSequence();
    internal static string get_BadNumericConstant();
    internal static string get_InvalidRegularExpression();
    internal static string get_EmptyVariableReference();
    internal static string get_InvalidVariableReference();
    internal static string get_InvokeMethodOnNull();
    internal static string get_MethodNotFound();
    internal static string get_ParameterizedPropertyAssignmentFailed();
    internal static string get_UnexpectedToken();
    internal static string get_SplattingNotPermitted();
    internal static string get_InvalidParameter();
    internal static string get_MissingExpression();
    internal static string get_BadExpression();
    internal static string get_ParameterRequiresArgument();
    internal static string get_ParameterCannotHaveArgument();
    internal static string get_DuplicateFormalParameter();
    internal static string get_MissingArgument();
    internal static string get_SplattingNotPermittedInArgumentList();
    internal static string get_MissingFileSpecification();
    internal static string get_RedirectionNotSupported();
    internal static string get_RedirectionFailed();
    internal static string get_ExpressionsMustBeFirstInPipeline();
    internal static string get_EmptyPipeElement();
    internal static string get_InvalidLeftHandSide();
    internal static string get_AddHashTableToNonHashTable();
    internal static string get_IsOperatorRequiresType();
    internal static string get_AsOperatorRequiresType();
    internal static string get_FormatError();
    internal static string get_BadOperatorArgument();
    internal static string get_OperatorFailed();
    internal static string get_BadReplaceArgument();
    internal static string get_ExpectedValueExpression();
    internal static string get_OperatorRequiresVariableOrProperty();
    internal static string get_OrderedAttributeOnlyOnHashLiteralNode();
    internal static string get_MissingArrayIndexExpression();
    internal static string get_MissingPropertyName();
    internal static string get_PropertyNotFound();
    internal static string get_PropertyNotFoundStrict();
    internal static string get_NullArrayIndex();
    internal static string get_NullArray();
    internal static string get_CannotIndex();
    internal static string get_CannotIndexWithByRefLikeReturnType();
    internal static string get_ArrayHasTooManyDimensions();
    internal static string get_ArraySliceAssignmentFailed();
    internal static string get_NeedMultidimensionalIndex();
    internal static string get_IndexOutOfRange();
    internal static string get_MissingExpressionAfterToken();
    internal static string get_IncompleteDollarVariableReference();
    internal static string get_IncompleteDollarSubexpressionReference();
    internal static string get_UnexpectedUnaryOperator();
    internal static string get_NonExistingVariableReference();
    internal static string get_VariableIsUndefined();
    internal static string get_DuplicateKeyInHashLiteral();
    internal static string get_DuplicateNamedArgument();
    internal static string get_OperatorRequiresNumber();
    internal static string get_ExpectedExpression();
    internal static string get_MissingEqualsInHashLiteral();
    internal static string get_MissingStatementInHashLiteral();
    internal static string get_MissingExpressionInNamedArgument();
    internal static string get_MissingPropertyTerminator();
    internal static string get_MissingExpressionAfterOperator();
    internal static string get_IfStatementMissingCondition();
    internal static string get_MissingStatementBlock();
    internal static string get_MissingStatementBlockAfterElse();
    internal static string get_FileReadError();
    internal static string get_FileOpenError();
    internal static string get_FileNotFound();
    internal static string get_AmbiguousPath();
    internal static string get_KeywordParameterReservedForFutureUse();
    internal static string get_MissingFilenameOption();
    internal static string get_InvalidFilenameOption();
    internal static string get_InvalidSwitchFlag();
    internal static string get_InvalidForeachFlag();
    internal static string get_PipelineValueRequired();
    internal static string get_MissingSwitchConditionExpression();
    internal static string get_MultipleSwitchDefaultClauses();
    internal static string get_MissingSwitchStatementClause();
    internal static string get_MissingForeachExpression();
    internal static string get_MissingForeachStatement();
    internal static string get_OnlyOneParameterListAllowed();
    internal static string get_NotADefinedOperationForType();
    internal static string get_BadEnumeration();
    internal static string get_COMException();
    internal static string get_InvalidComObjectException();
    internal static string get_ScriptTooComplicated();
    internal static string get_ScriptsNotAllowed();
    internal static string get_InvalidSplitOptionCombination();
    internal static string get_InvalidSplitOptionWithPredicate();
    internal static string get_InvalidEndOfLine();
    internal static string get_ReservedKeywordNotAllowed();
    internal static string get_MissingExpressionAfterKeyword();
    internal static string get_MissingLoopStatement();
    internal static string get_MissingTrapStatement();
    internal static string get_MissingTryStatement();
    internal static string get_InvalidFunctionParameter();
    internal static string get_MissingFunctionBody();
    internal static string get_DuplicateScriptCommandClause();
    internal static string get_MissingNamedBlocks();
    internal static string get_MissingEndCurlyBrace();
    internal static string get_MissingEndParenthesisInMethodCall();
    internal static string get_MissingEndSquareBracket();
    internal static string get_MissingEndParenthesisInExpression();
    internal static string get_MissingEndParenthesisInSubexpression();
    internal static string get_MissingOpenParenthesisInIfStatement();
    internal static string get_MissingEndParenthesisInSwitchStatement();
    internal static string get_MissingCurlyBraceInSwitchStatement();
    internal static string get_MissingVariableNameAfterForeach();
    internal static string get_MissingInInForeach();
    internal static string get_MissingEndParenthesisAfterForeach();
    internal static string get_MissingOpenParenthesisAfterKeyword();
    internal static string get_MissingWhileOrUntilInDoWhile();
    internal static string get_MissingEndParenthesisAfterStatement();
    internal static string get_MissingNameAfterKeyword();
    internal static string get_MissingEndParenthesisInFunctionParameterList();
    internal static string get_BackupParserMessage();
    internal static string get_BackupParserMessageWithException();
    internal static string get_ScriptBlockDelegateInvokedFromWrongThread();
    internal static string get_UnrecognizedToken();
    internal static string get_ExceptionActionPromptCaption();
    internal static string get_ContinueLabel();
    internal static string get_ContinueHelpMessage();
    internal static string get_SilentlyContinueLabel();
    internal static string get_SilentlyContinueHelpMessage();
    internal static string get_BreakLabel();
    internal static string get_BreakHelpMessage();
    internal static string get_SuspendLabel();
    internal static string get_SuspendHelpMessage();
    internal static string get_CantActivateDocumentInPipeline();
    internal static string get_ProgramFailedToExecute();
    internal static string get_CantInvokeInBinaryModule();
    internal static string get_CantInvokeInNonImportedModule();
    internal static string get_TokenAfterEndOfValidScriptText();
    internal static string get_TextForWordLine();
    internal static string get_TextForPositionMessage();
    internal static string get_TraceScriptLineMessage();
    internal static string get_TraceVariableAssignment();
    internal static string get_TraceEnteringFunction();
    internal static string get_TraceEnteringFunctionDefinedInFile();
    internal static string get_TraceMethodCall();
    internal static string get_TerminatorExpectedAtEndOfString();
    internal static string get_WhitespaceBeforeHereStringFooter();
    internal static string get_EndSquareBracketExpectedAtEndOfType();
    internal static string get_OpenBraceNeedsToBeBackTickedInVariableName();
    internal static string get_MissingStatementBlockForDataSection();
    internal static string get_InvalidParameterForDataSectionStatement();
    internal static string get_ArrayReferenceNotSupportedInDataSection();
    internal static string get_AssignmentStatementNotSupportedInDataSection();
    internal static string get_RedirectionNotSupportedInDataSection();
    internal static string get_DoWhileStatementNotSupportedInDataSection();
    internal static string get_ExpandableStringNotSupportedInDataSection();
    internal static string get_OperatorNotSupportedInDataSection();
    internal static string get_TrapStatementNotSupportedInDataSection();
    internal static string get_TryStatementNotSupportedInDataSection();
    internal static string get_FlowControlStatementNotSupportedInDataSection();
    internal static string get_ForeachStatementNotSupportedInDataSection();
    internal static string get_ForWhileStatementNotSupportedInDataSection();
    internal static string get_FunctionDeclarationNotSupportedInDataSection();
    internal static string get_MethodCallNotSupportedInDataSection();
    internal static string get_ParameterDeclarationNotSupportedInDataSection();
    internal static string get_PropertyReferenceNotSupportedInDataSection();
    internal static string get_ScriptBlockNotSupportedInDataSection();
    internal static string get_SwitchStatementNotSupportedInDataSection();
    internal static string get_VariableReferenceNotSupportedInDataSection();
    internal static string get_CmdletNotInAllowedListForDataSection();
    internal static string get_DataSectionStatementNotSupportedInDataSection();
    internal static string get_MissingValueForSupportedCommandInDataSectionStatement();
    internal static string get_InvalidScriptBlockInDataSection();
    internal static string get_StringMultiplyToolongInDataSection();
    internal static string get_ArrayMultiplyToolongInDataSection();
    internal static string get_DotSourcingNotSupportedInDataSection();
    internal static string get_ParameterAttributeArgumentNeedsToBeConstantOrScriptBlock();
    internal static string get_CustomAttributeTypeNotFound();
    internal static string get_PropertyNotFoundForType();
    internal static string get_UnexpectedAttribute();
    internal static string get_EndSquareBracketExpectedAtEndOfAttribute();
    internal static string get_StrictModeFunctionCallWithParens();
    internal static string get_MissingTryStatementBlock();
    internal static string get_MissingCatchOrFinally();
    internal static string get_MissingCatchHandlerBlock();
    internal static string get_MissingFinallyStatementBlock();
    internal static string get_ExceptionTypeAlreadyCaught();
    internal static string get_EmptyCatchNotLast();
    internal static string get_MissingTypeLiteralToken();
    internal static string get_MissingTerminatorMultiLineComment();
    internal static string get_UnexpectedCharactersAfterHereStringHeader();
    internal static string get_ErrorCollection();
    internal static string get_MissingNamedStatementBlock();
    internal static string get_TypeNotAllowedBeforeParam();
    internal static string get_TypeNotAllowedBeforeStatement();
    internal static string get_InvalidNullKey();
    internal static string get_AttributeNotSupportedInDataSection();
    internal static string get_TypeNotAllowedInDataSection();
    internal static string get_PropertyIsReadOnly();
    internal static string get_MissingAssemblyNameSpecification();
    internal static string get_ControlLeavingFinally();
    internal static string get_UnrecoverableParserError();
    internal static string get_AstIsReused();
    internal static string get_InvalidUsingExpression();
    internal static string get_UsingWithoutInvokeCommand();
    internal static string get_InvalidBracedVariableReference();
    internal static string get_InvalidVariableReferenceWithDrive();
    internal static string get_TooManyErrors();
    internal static string get_MissingTypename();
    internal static string get_AllStream();
    internal static string get_DebugStream();
    internal static string get_ErrorStream();
    internal static string get_OutputStream();
    internal static string get_StreamAlreadyRedirected();
    internal static string get_VerboseStream();
    internal static string get_WarningStream();
    internal static string get_MissingStatementAfterKeyword();
    internal static string get_ParallelAndSequenceBlockNotSupportedInDataSection();
    internal static string get_UnexpectedKeyword();
    internal static string get_VoidTypeConstraintNotAllowed();
    internal static string get_CannotInvoke();
    internal static string get_HashtableToObjectConversionNotSupportedInDataSection();
    internal static string get_RequiresArgumentMustBeConstant();
    internal static string get_RequiresInvalidStringArgument();
    internal static string get_RequiresModuleInvalid();
    internal static string get_RequiresVersionInvalid();
    internal static string get_RequiresPSEditionInvalid();
    internal static string get_RequiresPSEditionValueIsAlreadySpecified();
    internal static string get_WildCardModuleNameError();
    internal static string get_InvokeMethodConstrainedLanguage();
    internal static string get_PropertySetConstrainedLanguage();
    internal static string get_ConfigurationInvalidPropertyName();
    internal static string get_InvalidInstanceProperty();
    internal static string get_MissingBraceInObjectDefinition();
    internal static string get_RequiredNameOrExpressionMissing();
    internal static string get_SchemaFileNotFound();
    internal static string get_DataSectionAllowedCommandDisallowed();
    internal static string get_MissingCurlyInConfigurationStatement();
    internal static string get_ExceptionParsingMOFFile();
    internal static string get_MissingConfigurationName();
    internal static string get_ModuleNotFoundDuringParse();
    internal static string get_MultipleModuleEntriesFoundDuringParse();
    internal static string get_MissingThrottleLimit();
    internal static string get_ThrottleLimitRequiresParallelFlag();
    internal static string get_ConfigurationBodyEmpty();
    internal static string get_UnexpectedNameForType();
    internal static string get_IncompletePropertyAssignmentBlock();
    internal static string get_MissingEqualsInPropertyAssignmentBlock();
    internal static string get_DuplicatePropertyInInstanceDefinition();
    internal static string get_DuplicateCimClassDefinition();
    internal static string get_DuplicateKeywordDefinition();
    internal static string get_ClassNameNotSameAsDefiningFile();
    internal static string get_DuplicateResourceIdInNodeStatement();
    internal static string get_UnexpectedTokenInDynamicKeyword();
    internal static string get_EmptyFunctionNameInFunctionDefinitionDictionary();
    internal static string get_GetBadlyFormedRequiredResourceId();
    internal static string get_GetBadlyFormedExclusiveResourceId();
    internal static string get_GetPullModeNeedConfigurationSource();
    internal static string get_NullEntryInVariablesDefinitionList();
    internal static string get_NullFunctionBodyInFunctionDefinitionDictionary();
    internal static string get_ImportDscResourceNeedParams();
    internal static string get_ImportDscResourceMultipleModulesNotSupportedWithName();
    internal static string get_ImportDscResourcePositionalParamsNotSupported();
    internal static string get_DscResourcesNotFoundDuringParsing();
    internal static string get_ConfigurationNotAllowedInConstrainedLanguage();
    internal static string get_InvalidConfigurationName();
    internal static string get_UnsupportedNamedBlockInConfiguration();
    internal static string get_CimDeserializationError();
    internal static string get_InvalidValueForProperty();
    internal static string get_UnsupportedValueForProperty();
    internal static string get_MissingValueForMandatoryProperty();
    internal static string get_ValueNotInRange();
    internal static string get_CannotLoadPowerShellDataFile();
    internal static string get_CannotResolvePowerShellDataFilePath();
    internal static string get_InvalidPowerShellDataFile();
    internal static string get_ConfigurationNotAllowedOnWinPE();
    internal static string get_EmptyExpressionRequiresANonDefaultMode();
    internal static string get_ForEachBadGenericConversionTypeSpecified();
    internal static string get_ForEachTypeConversionFailed();
    internal static string get_ForEachNotSupportCleanBlock();
    internal static string get_NumberToReturnMustBeGreaterThanZero();
    internal static string get_RedirectionStreamCanOnlyMergeToOutputStream();
    internal static string get_ForEachNonexistentMemberReference();
    internal static string get_UnsupportedReservedKeyword();
    internal static string get_UnsupportedReservedProperty();
    internal static string get_DuplicateQualifier();
    internal static string get_ModifiersCannotBeCombined();
    internal static string get_MissingUsingStatementDirective();
    internal static string get_MissingNamespaceAlias();
    internal static string get_MissingEqualsInUsingAlias();
    internal static string get_MissingUsingItemName();
    internal static string get_VariableNotLocal();
    internal static string get_IncompleteMemberDefinition();
    internal static string get_MemberAlreadyDefined();
    internal static string get_TooManyTypes();
    internal static string get_TypeCreationError();
    internal static string get_CannotConvertValue();
    internal static string get_PropertyNotFoundForAttribute();
    internal static string get_AttributeNotAllowedOnDeclaration();
    internal static string get_ParameterAttributeArgumentNeedsToBeConstant();
    internal static string get_ResourceNotDefined();
    internal static string get_DynamicKeywordPreParseException();
    internal static string get_DynamicKeywordPostParseException();
    internal static string get_WorkflowNotSupportedInPowerShellCore();
    internal static string get_MetaConfigurationUsedInRegularConfig();
    internal static string get_RegularResourceUsedInMetaConfig();
    internal static string get_GetSteppablePipelineFromWrongThread();
    internal static string get_AmbiguousConversion();
    internal static string get_CannotCall();
    internal static string get_CannotRetrieveTypeInformation();
    internal static string get_CouldNotGetDispId();
    internal static string get_DispBadParamCount();
    internal static string get_DispMemberNotFound();
    internal static string get_DispNoNamedArgs();
    internal static string get_DispOverflow();
    internal static string get_DispParamNotOptional();
    internal static string get_DispTypeMismatch();
    internal static string get_GetIDsOfNamesInvalid();
    internal static string get_SetComObjectDataFailed();
    internal static string get_UnexpectedVarEnum();
    internal static string get_UnsupportedHandlerType();
    internal static string get_ConfigurationNotSupportedInPowerShellCore();
    internal static string get_MethodHasCodePathNotReturn();
    internal static string get_VoidMethodHasReturn();
    internal static string get_NonVoidMethodMissingReturnValue();
    internal static string get_MissingTypeBody();
    internal static string get_CycleInEnumInitializers();
    internal static string get_EnumeratorValueOutOfBounds();
    internal static string get_EnumeratorValueMustBeConstant();
    internal static string get_DynamicKeywordSemanticCheckException();
    internal static string get_UnsupportedPropertyTypeOfDSCResourceClass();
    internal static string get_MissingMethodParameterList();
    internal static string get_NamedBlockNotAllowedInMethod();
    internal static string get_ParamBlockNotAllowedInMethod();
    internal static string get_SealedBaseClass();
    internal static string get_TypeNameExpected();
    internal static string get_InvalidUnderlyingType();
    internal static string get_InterfaceNameExpected();
    internal static string get_BaseClassNoDefaultCtor();
    internal static string get_SubtypeArray();
    internal static string get_SubtypeUnclosedGeneric();
    internal static string get_MissingBaseCtorCall();
    internal static string get_ConstructorCantHaveReturnType();
    internal static string get_DscResourceMissingDefaultConstructor();
    internal static string get_DscResourceMissingGetMethod();
    internal static string get_DscResourceMissingKeyProperty();
    internal static string get_DscResourceMissingSetMethod();
    internal static string get_DscResourceMissingTestMethod();
    internal static string get_StaticConstructorCantHaveParameters();
    internal static string get_TypeNotAllowedForProperty();
    internal static string get_TypeNotAllowedForParameter();
    internal static string get_NonStaticMemberAccessInStaticMember();
    internal static string get_FailToParseModuleScriptFile();
    internal static string get_CantActivateDocumentInPowerShellCore();
    internal static string get_MultipleTypeConstraintsOnMethodParam();
    internal static string get_ScriptContainedMaliciousContent();
    internal static string get_InvalidLocalConfigurationManagerProperty();
    internal static string get_PropertyInGenericType();
    internal static string get_AmbiguousTypeReference();
    internal static string get_UsingMustBeAtStartOfScript();
    internal static string get_UsingStatementNotSupported();
    internal static string get_InformationStream();
    internal static string get_DscResourceInvalidKeyProperty();
    internal static string get_DscResourceInvalidGetMethod();
    internal static string get_ErrorLoadingAssembly();
    internal static string get_CannotLoadAssemblyFromUncPath();
    internal static string get_CannotLoadAssemblyWithUriSchema();
    internal static string get_MissingStatementTerminator();
    internal static string get_MissingThis();
    internal static string get_InvalidValueForUsingItemName();
    internal static string get_MissingTypeInStaticPropertyAssignment();
    internal static string get_DebugModeShouldHaveOneValue();
    internal static string get_LabelNotFound();
    internal static string get_ConvertCimPropertyToObjectPropertyFailed();
    internal static string get_ExpectArrayTypeOfPropertyInPSClass();
    internal static string get_InstantiatePSClassObjectFailed();
    internal static string get_InvalidHashtable();
    internal static string get_InvalidPassword();
    internal static string get_InvalidUserName();
    internal static string get_PropertyNotDeclaredInPSClass();
    internal static string get_DisabledRefreshModeNotValidForPartialConfig();
    internal static string get_CannotCreateTypeConstrainedLanguage();
    internal static string get_ImportDscResourceInsideNode();
    internal static string get_DefaultAllowedVariablesInDataSection();
    internal static string get_AssignmentStatementToAutomaticNotSupported();
    internal static string get_PsDscRunAsCredentialMergeErrorForCompositeResources();
    internal static string get_PsDscMissingSchemaStore();
    internal static string get_ParserError();
    internal static string get_ScriptHasAdminBlockedContent();
    internal static string get_CantInvokeCallOperatorAcrossLanguageBoundaries();
    internal static string get_ClassesNotAllowedInConstrainedLanguage();
    internal static string get_MissingColonInTernaryExpression();
    internal static string get_EmptyPipelineChainElement();
    internal static string get_BackgroundOperatorInPipelineChain();
    internal static string get_InvokingCleanBlockNotSupported();
    internal static string get_WDACParserConfigKeywordLogTitle();
    internal static string get_WDACParserConfigKeywordLogMessage();
    internal static string get_WDACParserClassKeywordLogTitle();
    internal static string get_WDACParserClassKeywordLogMessage();
    internal static string get_WDACParserDSSupportedCommandLogTitle();
    internal static string get_WDACParserDSSupportedCommandLogMessage();
    internal static string get_WDACParserModuleScopeCallOperatorLogTitle();
    internal static string get_WDACParserModuleScopeCallOperatorLogMessage();
    internal static string get_WDACParserForEachOperatorLogTitle();
    internal static string get_WDACParserForEachOperatorLogMessage();
    internal static string get_WDACGetSteppablePipelineLogTitle();
    internal static string get_WDACGetSteppablePipelineLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PathUtilsStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Utf7EncodingObsolete { get; }
    internal static string UtilityFileExistsNoClobber { get; }
    internal static string OutFile_ReadWriteFileNotFileSystemProvider { get; }
    internal static string OutFile_MultipleFilesNotSupported { get; }
    internal static string OutFile_DidNotResolveFile { get; }
    internal static string OutFile_WriteToFileEncodingUnknown { get; }
    internal static string ExportPSSession_ErrorDirectoryExists { get; }
    internal static string ExportPSSession_ErrorModuleNameOrPath { get; }
    internal static string ExportPSSession_CannotCreateOutputDirectory { get; }
    internal static string ExportPSSession_ScriptGeneratorVersionMismatch { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Utf7EncodingObsolete();
    internal static string get_UtilityFileExistsNoClobber();
    internal static string get_OutFile_ReadWriteFileNotFileSystemProvider();
    internal static string get_OutFile_MultipleFilesNotSupported();
    internal static string get_OutFile_DidNotResolveFile();
    internal static string get_OutFile_WriteToFileEncodingUnknown();
    internal static string get_ExportPSSession_ErrorDirectoryExists();
    internal static string get_ExportPSSession_ErrorModuleNameOrPath();
    internal static string get_ExportPSSession_CannotCreateOutputDirectory();
    internal static string get_ExportPSSession_ScriptGeneratorVersionMismatch();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PipelineStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CommandProcessorAlreadyUsed { get; }
    internal static string ExecutionAlreadyStarted { get; }
    internal static string ActionPreferenceStop { get; }
    internal static string FirstCommandCannotHaveInput { get; }
    internal static string InvalidCommandNumber { get; }
    internal static string PipeAlreadyTaken { get; }
    internal static string PipelineExecuteRequiresAtLeastOneCommand { get; }
    internal static string PipelineNotStarted { get; }
    internal static string WriteNotPermitted { get; }
    internal static string SecondFailure { get; }
    internal static string WriteToClosedPipeline { get; }
    internal static string PipelineExecutionInformation { get; }
    internal static string PipelineExecutionNonTerminatingError { get; }
    internal static string PipelineExecutionTerminatingError { get; }
    internal static string PipelineExecutionParameterBinding { get; }
    internal static string CannotCreatePipeline { get; }
    internal static string ConnectNotSupported { get; }
    internal static string PipelineNotDisconnected { get; }
    internal static string InvalidRemoteCommand { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CommandProcessorAlreadyUsed();
    internal static string get_ExecutionAlreadyStarted();
    internal static string get_ActionPreferenceStop();
    internal static string get_FirstCommandCannotHaveInput();
    internal static string get_InvalidCommandNumber();
    internal static string get_PipeAlreadyTaken();
    internal static string get_PipelineExecuteRequiresAtLeastOneCommand();
    internal static string get_PipelineNotStarted();
    internal static string get_WriteNotPermitted();
    internal static string get_SecondFailure();
    internal static string get_WriteToClosedPipeline();
    internal static string get_PipelineExecutionInformation();
    internal static string get_PipelineExecutionNonTerminatingError();
    internal static string get_PipelineExecutionTerminatingError();
    internal static string get_PipelineExecutionParameterBinding();
    internal static string get_CannotCreatePipeline();
    internal static string get_ConnectNotSupported();
    internal static string get_PipelineNotDisconnected();
    internal static string get_InvalidRemoteCommand();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PowerShellStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidPowerShellStateGeneral { get; }
    internal static string ExecutionAlreadyStarted { get; }
    internal static string NoCommandToInvoke { get; }
    internal static string InvalidStateCreateNested { get; }
    internal static string InvalidRunspaceState { get; }
    internal static string NestedPowerShellInvokeAsync { get; }
    internal static string AsyncResultNotOwned { get; }
    internal static string ApartmentStateMismatch { get; }
    internal static string ApartmentStateMismatchCurrentThread { get; }
    internal static string ParameterRequiresCommand { get; }
    internal static string KeyMustBeString { get; }
    internal static string CommandInvokedFromWrongThreadWithCommand { get; }
    internal static string CannotConnect { get; }
    internal static string DiscOnSyncCommand { get; }
    internal static string ExecutionDisconnected { get; }
    internal static string IsDisconnected { get; }
    internal static string ConnectFailed { get; }
    internal static string ExecutionStopping { get; }
    internal static string CommandInvokedFromWrongThreadWithoutCommand { get; }
    internal static string NoDefaultRunspaceForPSCreate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidPowerShellStateGeneral();
    internal static string get_ExecutionAlreadyStarted();
    internal static string get_NoCommandToInvoke();
    internal static string get_InvalidStateCreateNested();
    internal static string get_InvalidRunspaceState();
    internal static string get_NestedPowerShellInvokeAsync();
    internal static string get_AsyncResultNotOwned();
    internal static string get_ApartmentStateMismatch();
    internal static string get_ApartmentStateMismatchCurrentThread();
    internal static string get_ParameterRequiresCommand();
    internal static string get_KeyMustBeString();
    internal static string get_CommandInvokedFromWrongThreadWithCommand();
    internal static string get_CannotConnect();
    internal static string get_DiscOnSyncCommand();
    internal static string get_ExecutionDisconnected();
    internal static string get_IsDisconnected();
    internal static string get_ConnectFailed();
    internal static string get_ExecutionStopping();
    internal static string get_CommandInvokedFromWrongThreadWithoutCommand();
    internal static string get_NoDefaultRunspaceForPSCreate();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ProgressRecordStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ArgMayNotBeNegative { get; }
    internal static string ArgMayNotBeNullOrEmpty { get; }
    internal static string PercentMayNotBeMoreThan100 { get; }
    internal static string ParentActivityIdCantBeActivityId { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ArgMayNotBeNegative();
    internal static string get_ArgMayNotBeNullOrEmpty();
    internal static string get_PercentMayNotBeMoreThan100();
    internal static string get_ParentActivityIdCantBeActivityId();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ProviderBaseSecurity : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ISecurityDescriptorCmdletProvider_NotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ISecurityDescriptorCmdletProvider_NotSupported();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class ProxyCommandStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string HelpInfoObjectRequired { get; }
    internal static string CommandMetadataMissingCommandName { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_HelpInfoObjectRequired();
    internal static string get_CommandMetadataMissingCommandName();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PSCommandStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ParameterRequiresCommand { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ParameterRequiresCommand();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PSConfigurationStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CanNotConfigurationFile { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CanNotConfigurationFile();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PSDataBufferStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IndexOutOfRange { get; }
    internal static string ValueNullReference { get; }
    internal static string CannotConvertToGenericType { get; }
    internal static string WriteToClosedBuffer { get; }
    internal static string SerializationNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IndexOutOfRange();
    internal static string get_ValueNullReference();
    internal static string get_CannotConvertToGenericType();
    internal static string get_WriteToClosedBuffer();
    internal static string get_SerializationNotSupported();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PSListModifierStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string ListModifierDisallowedKey { get; }
    internal static string UpdateFailed { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_ListModifierDisallowedKey();
    internal static string get_UpdateFailed();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class PSStyleStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string TextContainsContent { get; }
    internal static string ProgressWidthTooSmall { get; }
    internal static string ExtensionNotStartingWithPeriod { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_TextContainsContent();
    internal static string get_ProgressWidthTooSmall();
    internal static string get_ExtensionNotStartingWithPeriod();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class RegistryProviderStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SetItemAction { get; }
    internal static string SetItemResourceTemplate { get; }
    internal static string ClearItemAction { get; }
    internal static string ClearItemResourceTemplate { get; }
    internal static string NewItemAction { get; }
    internal static string NewItemResourceTemplate { get; }
    internal static string RemoveKeyAction { get; }
    internal static string RemoveKeyResourceTemplate { get; }
    internal static string CopyKeyAction { get; }
    internal static string CopyKeyResourceTemplate { get; }
    internal static string RenameItemAction { get; }
    internal static string RenameItemResourceTemplate { get; }
    internal static string MoveItemAction { get; }
    internal static string MoveItemResourceTemplate { get; }
    internal static string SetPropertyAction { get; }
    internal static string SetPropertyResourceTemplate { get; }
    internal static string ClearPropertyAction { get; }
    internal static string ClearPropertyResourceTemplate { get; }
    internal static string NewPropertyAction { get; }
    internal static string NewPropertyResourceTemplate { get; }
    internal static string RemovePropertyAction { get; }
    internal static string RemovePropertyResourceTemplate { get; }
    internal static string RenamePropertyAction { get; }
    internal static string RenamePropertyResourceTemplate { get; }
    internal static string CopyPropertyAction { get; }
    internal static string CopyPropertyResourceTemplate { get; }
    internal static string MovePropertyAction { get; }
    internal static string MovePropertyResourceTemplate { get; }
    internal static string ContainerInvalidOperationTemplate { get; }
    internal static string SourceContainerInvalidOperationTemplate { get; }
    internal static string DestinationContainerInvalidOperationTemplate { get; }
    internal static string HKLMDriveDescription { get; }
    internal static string HKCUDriveDescription { get; }
    internal static string KeyAlreadyExists { get; }
    internal static string DestinationChildOfSource { get; }
    internal static string PropertyAlreadyExists { get; }
    internal static string PropertyNotAtPath { get; }
    internal static string KeyDoesNotExist { get; }
    internal static string TypeParameterBindingFailure { get; }
    internal static string KeyCreatedValueFailed { get; }
    internal static string NewDriveRootDoesNotExist { get; }
    internal static string RenameItemAlreadyExists { get; }
    internal static string Arg_RegInvalidKeyName { get; }
    internal static string ArgRegKeyDelHive { get; }
    internal static string Arg_RegSubKeyAbsent { get; }
    internal static string Arg_RegSubKeyValueAbsent { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Arg_Value { get; }
    internal static string Arg_Name { get; }
    internal static string Arg_RegBadKeyKind { get; }
    internal static string Arg_RegSetStrArrNull { get; }
    internal static string Arg_RegKeyStrLenBug { get; }
    internal static string Arg_RegKeyStrEmpty { get; }
    internal static string Arg_RegSetMismatchedKind { get; }
    internal static string Arg_RegSetBadArrType { get; }
    internal static string Arg_RegKeyNotFound { get; }
    internal static string Arg_RegValueNameStrLenBug { get; }
    internal static string Arg_ValueDataLenBug { get; }
    internal static string ArgumentException_RegSubKeyAbsent { get; }
    internal static string Argument_InvalidRegistryKeyPermissionCheck { get; }
    internal static string InvalidOperation_RegRemoveSubKey { get; }
    internal static string InvalidOperation_NeedTransaction { get; }
    internal static string InvalidOperation_MustUseSameTransaction { get; }
    internal static string InvalidOperation_NotAssociatedWithTransaction { get; }
    internal static string Security_RegistryPermission { get; }
    internal static string UnauthorizedAccess_RegistryKeyGeneric_Key { get; }
    internal static string UnauthorizedAccess_RegistryNoWrite { get; }
    internal static string ObjectDisposed_RegKeyClosed { get; }
    internal static string UnknownError_Num { get; }
    internal static string NotSupported_KernelTransactions { get; }
    internal static string AccessControl_InvalidHandle { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SetItemAction();
    internal static string get_SetItemResourceTemplate();
    internal static string get_ClearItemAction();
    internal static string get_ClearItemResourceTemplate();
    internal static string get_NewItemAction();
    internal static string get_NewItemResourceTemplate();
    internal static string get_RemoveKeyAction();
    internal static string get_RemoveKeyResourceTemplate();
    internal static string get_CopyKeyAction();
    internal static string get_CopyKeyResourceTemplate();
    internal static string get_RenameItemAction();
    internal static string get_RenameItemResourceTemplate();
    internal static string get_MoveItemAction();
    internal static string get_MoveItemResourceTemplate();
    internal static string get_SetPropertyAction();
    internal static string get_SetPropertyResourceTemplate();
    internal static string get_ClearPropertyAction();
    internal static string get_ClearPropertyResourceTemplate();
    internal static string get_NewPropertyAction();
    internal static string get_NewPropertyResourceTemplate();
    internal static string get_RemovePropertyAction();
    internal static string get_RemovePropertyResourceTemplate();
    internal static string get_RenamePropertyAction();
    internal static string get_RenamePropertyResourceTemplate();
    internal static string get_CopyPropertyAction();
    internal static string get_CopyPropertyResourceTemplate();
    internal static string get_MovePropertyAction();
    internal static string get_MovePropertyResourceTemplate();
    internal static string get_ContainerInvalidOperationTemplate();
    internal static string get_SourceContainerInvalidOperationTemplate();
    internal static string get_DestinationContainerInvalidOperationTemplate();
    internal static string get_HKLMDriveDescription();
    internal static string get_HKCUDriveDescription();
    internal static string get_KeyAlreadyExists();
    internal static string get_DestinationChildOfSource();
    internal static string get_PropertyAlreadyExists();
    internal static string get_PropertyNotAtPath();
    internal static string get_KeyDoesNotExist();
    internal static string get_TypeParameterBindingFailure();
    internal static string get_KeyCreatedValueFailed();
    internal static string get_NewDriveRootDoesNotExist();
    internal static string get_RenameItemAlreadyExists();
    internal static string get_Arg_RegInvalidKeyName();
    internal static string get_ArgRegKeyDelHive();
    internal static string get_Arg_RegSubKeyAbsent();
    internal static string get_Arg_RegSubKeyValueAbsent();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Arg_Value();
    internal static string get_Arg_Name();
    internal static string get_Arg_RegBadKeyKind();
    internal static string get_Arg_RegSetStrArrNull();
    internal static string get_Arg_RegKeyStrLenBug();
    internal static string get_Arg_RegKeyStrEmpty();
    internal static string get_Arg_RegSetMismatchedKind();
    internal static string get_Arg_RegSetBadArrType();
    internal static string get_Arg_RegKeyNotFound();
    internal static string get_Arg_RegValueNameStrLenBug();
    internal static string get_Arg_ValueDataLenBug();
    internal static string get_ArgumentException_RegSubKeyAbsent();
    internal static string get_Argument_InvalidRegistryKeyPermissionCheck();
    internal static string get_InvalidOperation_RegRemoveSubKey();
    internal static string get_InvalidOperation_NeedTransaction();
    internal static string get_InvalidOperation_MustUseSameTransaction();
    internal static string get_InvalidOperation_NotAssociatedWithTransaction();
    internal static string get_Security_RegistryPermission();
    internal static string get_UnauthorizedAccess_RegistryKeyGeneric_Key();
    internal static string get_UnauthorizedAccess_RegistryNoWrite();
    internal static string get_ObjectDisposed_RegKeyClosed();
    internal static string get_UnknownError_Num();
    internal static string get_NotSupported_KernelTransactions();
    internal static string get_AccessControl_InvalidHandle();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class RemotingErrorIdStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string DefaultRemotingExceptionMessage { get; }
    internal static string OutOfMemory { get; }
    internal static string PipelineIdsDoNotMatch { get; }
    internal static string PipelineNotFoundOnServer { get; }
    internal static string PipelineStopped { get; }
    internal static string RunspaceAlreadyExists { get; }
    internal static string RunspaceIdsDoNotMatch { get; }
    internal static string RemoteRunspaceOpenFailed { get; }
    internal static string RunspaceCannotBeFound { get; }
    internal static string ResponsePromptIdCannotBeFound { get; }
    internal static string RemoteHostCallFailed { get; }
    internal static string RemoteHostMethodNotImplemented { get; }
    internal static string RemoteHostDataEncodingNotSupported { get; }
    internal static string RemoteHostDataDecodingNotSupported { get; }
    internal static string NestedPipelineNotSupported { get; }
    internal static string RelativeUriForRunspacePathNotSupported { get; }
    internal static string RemoteHostDecodingFailed { get; }
    internal static string MustBeAdminToOverrideThreadOptions { get; }
    internal static string RemoteHostPromptForCredentialModifiedCaption { get; }
    internal static string RemoteHostPromptForCredentialModifiedMessage { get; }
    internal static string RemoteHostReadLineAsSecureStringPrompt { get; }
    internal static string RemoteHostGetBufferContents { get; }
    internal static string RemoteHostPromptSecureStringPrompt { get; }
    internal static string ReceivedUnsupportedRemoteHostCall { get; }
    internal static string ReceivedUnsupportedAction { get; }
    internal static string ReceivedUnsupportedDataType { get; }
    internal static string MissingDestination { get; }
    internal static string MissingTarget { get; }
    internal static string MissingRunspaceId { get; }
    internal static string MissingDataType { get; }
    internal static string MissingCallId { get; }
    internal static string MissingMethodName { get; }
    internal static string MissingIsStartFragment { get; }
    internal static string MissingProperty { get; }
    internal static string ObjectIdsNotMatching { get; }
    internal static string ObjectIdCannotBeLessThanZero { get; }
    internal static string FragmentIdsNotInSequence { get; }
    internal static string ObjectIsTooBig { get; }
    internal static string MissingIsEndFragment { get; }
    internal static string DeserializedObjectIsNull { get; }
    internal static string BlobLengthNotInRange { get; }
    internal static string DecodingErrorForErrorRecord { get; }
    internal static string DecodingErrorForPipelineStateInfo { get; }
    internal static string DecodingErrorForRunspaceStateInfo { get; }
    internal static string ReceivedUnsupportedRemotingTargetInterfaceType { get; }
    internal static string UnknownTargetClass { get; }
    internal static string MissingTargetClass { get; }
    internal static string DecodingErrorForRunspacePoolStateInfo { get; }
    internal static string DecodingErrorForMinRunspaces { get; }
    internal static string DecodingErrorForMaxRunspaces { get; }
    internal static string DecodingErrorForPowerShellStateInfo { get; }
    internal static string CantCastPropertyToExpectedType { get; }
    internal static string CantCastRemotingDataToPSObject { get; }
    internal static string CantCastCommandToPSObject { get; }
    internal static string CantCastParameterToPSObject { get; }
    internal static string NotEnoughHeaderForRemoteDataObject { get; }
    internal static string RemotingDestinationNotForMe { get; }
    internal static string ClientNegotiationTimeout { get; }
    internal static string ClientNegotiationFailed { get; }
    internal static string ClientNotFoundCapabilityProperties { get; }
    internal static string ServerRequestedToCloseSession { get; }
    internal static string ServerNegotiationFailed { get; }
    internal static string ServerConnectFailedOnNegotiation { get; }
    internal static string ServerConnectFailedOnInputValidation { get; }
    internal static string ServerConnectFailedOnServerStateValidation { get; }
    internal static string ServerConnectFailedOnMismatchedRunspacePoolProperties { get; }
    internal static string ServerNotFoundCapabilityProperties { get; }
    internal static string ServerNegotiationTimeout { get; }
    internal static string ClientRequestedToCloseSession { get; }
    internal static string FatalErrorCausingClose { get; }
    internal static string ClientKeyExchangeFailed { get; }
    internal static string ServerKeyExchangeFailed { get; }
    internal static string ConnectFailed { get; }
    internal static string CloseIsCalled { get; }
    internal static string ForceClosed { get; }
    internal static string CloseFailed { get; }
    internal static string CloseCompleted { get; }
    internal static string UnsupportedWaitHandleType { get; }
    internal static string ReceivedDataStreamIsNotStdout { get; }
    internal static string StdInIsNotOpen { get; }
    internal static string NativeWriteFileFailed { get; }
    internal static string NativeReadFileFailed { get; }
    internal static string InvalidSchemeValue { get; }
    internal static string ClientReceiveFailed { get; }
    internal static string ClientSendFailed { get; }
    internal static string CommandHandleIsNull { get; }
    internal static string StdInCannotBeSetToNoWait { get; }
    internal static string PortIsOutOfRange { get; }
    internal static string ServerProcessExited { get; }
    internal static string CannotGetStdInHandle { get; }
    internal static string CannotGetStdOutHandle { get; }
    internal static string CannotGetStdErrHandle { get; }
    internal static string ConnectExFailed { get; }
    internal static string ConnectExCallBackError { get; }
    internal static string CloseExCallBackError { get; }
    internal static string SendExFailed { get; }
    internal static string SendExCallBackError { get; }
    internal static string ReceiveExFailed { get; }
    internal static string ReceiveExCallBackError { get; }
    internal static string RunShellCommandExFailed { get; }
    internal static string RunShellCommandExCallBackError { get; }
    internal static string ReconnectShellCommandExCallBackError { get; }
    internal static string CommandSendExFailed { get; }
    internal static string CommandSendExCallBackError { get; }
    internal static string CommandReceiveExFailed { get; }
    internal static string CommandReceiveExCallBackError { get; }
    internal static string GeneralError { get; }
    internal static string TroubleShootingHelpTopic { get; }
    internal static string DisconnectShellExFailed { get; }
    internal static string DisconnectShellExCallBackErrr { get; }
    internal static string ReconnectShellExFailed { get; }
    internal static string ReconnectShellExCallBackErrr { get; }
    internal static string IPCTransportConnectError { get; }
    internal static string NonExistentInitialSessionStateProvider { get; }
    internal static string InitialSessionStateNull { get; }
    internal static string MandatoryValueNotPresent { get; }
    internal static string MandatoryValueNotInCorrectFormat { get; }
    internal static string StartupScriptNotCorrect { get; }
    internal static string DuplicateInitializationParameterFound { get; }
    internal static string NoAttributesFoundForParamElement { get; }
    internal static string AssemblyLoadAttributesNotFound { get; }
    internal static string UnableToLoadAssembly { get; }
    internal static string UnableToLoadType { get; }
    internal static string TypeNeedsAssembly { get; }
    internal static string RedirectedURINotWellFormatted { get; }
    internal static string URIEndPointNotResolved { get; }
    internal static string URIRedirectWarningToHost { get; }
    internal static string URIRedirectionReported { get; }
    internal static string ReceivedObjectSizeExceededMaximumClient { get; }
    internal static string ReceivedDataSizeExceededMaximumClient { get; }
    internal static string ReceivedObjectSizeExceededMaximumServer { get; }
    internal static string ReceivedDataSizeExceededMaximumServer { get; }
    internal static string StartupScriptThrewTerminatingError { get; }
    internal static string RemoteRunspaceInfoHasDuplicates { get; }
    internal static string RemoteRunspaceInfoLimitExceeded { get; }
    internal static string RemoteRunspaceOpenUnknownState { get; }
    internal static string UriSpecifiedNotValid { get; }
    internal static string RemoteRunspaceClosed { get; }
    internal static string RemoteRunspaceNotAvailableForSpecifiedComputer { get; }
    internal static string RemoteRunspaceNotAvailableForSpecifiedRunspaceId { get; }
    internal static string StopPSJobWhatIfTarget { get; }
    internal static string NewRunspaceAmbiguousAuthentication { get; }
    internal static string WildCardErrorFilePathParameter { get; }
    internal static string FilePathNotFromFileSystemProvider { get; }
    internal static string FilePathShouldPS1Extension { get; }
    internal static string InvalidComputerName { get; }
    internal static string InvalidJobStateGeneral { get; }
    internal static string JobWithSpecifiedNameNotFound { get; }
    internal static string JobWithSpecifiedInstanceIdNotFound { get; }
    internal static string JobWithSpecifiedSessionIdNotFound { get; }
    internal static string JobWithSpecifiedNameNotCompleted { get; }
    internal static string JobWithSpecifiedSessionIdNotCompleted { get; }
    internal static string JobWithSpecifiedInstanceIdNotCompleted { get; }
    internal static string RemovePSJobWhatIfTarget { get; }
    internal static string ComputerNameParamNotSupported { get; }
    internal static string RunspaceParamNotSupported { get; }
    internal static string RemoteRunspaceNotAvailableForSpecifiedName { get; }
    internal static string RemoteRunspaceNotAvailableForSpecifiedSessionId { get; }
    internal static string ItemNotFoundInRepository { get; }
    internal static string CannotRemoveJob { get; }
    internal static string CSCDoubleParameterOutOfRange { get; }
    internal static string ProxyAmbiguousAuthentication { get; }
    internal static string ProxyCredentialWithoutAccess { get; }
    internal static string WrongSessionOptionValue { get; }
    internal static string PushedRunspaceMustBeOpen { get; }
    internal static string HostDoesNotSupportPushRunspace { get; }
    internal static string RemoteRunspaceHasMultipleMatchesForSpecifiedRunspaceId { get; }
    internal static string RemoteRunspaceHasMultipleMatchesForSpecifiedSessionId { get; }
    internal static string RemoteRunspaceHasMultipleMatchesForSpecifiedName { get; }
    internal static string RemoteRunspaceDoesNotSupportPushRunspace { get; }
    internal static string HostInNestedPrompt { get; }
    internal static string WsmanMaxRedirectionCountVariableDescription { get; }
    internal static string PSDefaultSessionOptionDescription { get; }
    internal static string PSSessionConfigurationName { get; }
    internal static string PSSessionAppName { get; }
    internal static string PSSenderInfoDescription { get; }
    internal static string CSCmdsTypeNeedsAssembly { get; }
    internal static string CSCmdsShellNotFound { get; }
    internal static string CSCmdsShellNotPowerShellBased { get; }
    internal static string CSCmdsPowerShellCoreShellNotModifiable { get; }
    internal static string CSCmdsWindowsPowerShellCoreNotModifiable { get; }
    internal static string CustomShellNotFound { get; }
    internal static string CSShouldProcessAction { get; }
    internal static string CSShouldProcessTarget { get; }
    internal static string CSShouldProcessTargetAdminEnable { get; }
    internal static string NcsCannotDeleteFile { get; }
    internal static string NcsCannotDeleteFileAfterInstall { get; }
    internal static string NcsCannotWritePluginContent { get; }
    internal static string NcsScriptMessageV { get; }
    internal static string NcsShouldProcessTargetSDDL { get; }
    internal static string RcsScriptMessageV { get; }
    internal static string GcsScriptMessageV { get; }
    internal static string ScsScriptMessageV { get; }
    internal static string ScsShouldProcessTargetSDDL { get; }
    internal static string EcsScriptMessageV { get; }
    internal static string EcsWSManQCCaption { get; }
    internal static string EcsWSManQCQuery { get; }
    internal static string EcsWSManShouldProcessDesc { get; }
    internal static string EcsShouldProcessTarget { get; }
    internal static string DcsScriptMessageV { get; }
    internal static string DcsShouldProcessTarget { get; }
    internal static string DcsWarningMessage { get; }
    internal static string EDcsRequiresElevation { get; }
    internal static string RestartWSManServiceMessageV { get; }
    internal static string RestartWSManServiceAction { get; }
    internal static string RestartWSManServiceTarget { get; }
    internal static string RestartWSManRequiredShowUI { get; }
    internal static string ERemotingCaption { get; }
    internal static string ERemotingQuery { get; }
    internal static string ShowUIAndSDDLCannotExist { get; }
    internal static string RestartWinRMMessage { get; }
    internal static string IPCUnknownNodeType { get; }
    internal static string IPCInsufficientDataforElement { get; }
    internal static string IPCWrongAttributeCountForDataElement { get; }
    internal static string IPCOnlyTextExpectedInDataElement { get; }
    internal static string IPCWrongAttributeCountForElement { get; }
    internal static string IPCUnknownElementReceived { get; }
    internal static string IPCSupportsOnlyDefaultAuth { get; }
    internal static string IPCPwshExecutableNotFound { get; }
    internal static string RunAs32NotSupported { get; }
    internal static string IPCServerProcessReportedError { get; }
    internal static string IPCServerProcessExited { get; }
    internal static string IPCErrorProcessingServerData { get; }
    internal static string IPCUnknownCommandGuid { get; }
    internal static string IPCNoSignalForSession { get; }
    internal static string IPCSignalTimedOut { get; }
    internal static string IPCCloseTimedOut { get; }
    internal static string IPCExceptionLaunchingProcess { get; }
    internal static string ThrottlingJobChildAlreadyRunning { get; }
    internal static string ThrottlingJobChildAddedAfterEndOfChildJobs { get; }
    internal static string ThrottlingJobStatusMessage { get; }
    internal static string NestedPipelineMissingRunspace { get; }
    internal static string JobSourceAdapterError { get; }
    internal static string PSVersionParameterOutOfRange { get; }
    internal static string BlockCannotBeUsedWithKeep { get; }
    internal static string WriteEventsCannotBeUsedWithoutWait { get; }
    internal static string PowerShellVersionNotSupported { get; }
    internal static string JobManagerRegistrationConstructorError { get; }
    internal static string JobSourceAdapterNotFound { get; }
    internal static string NewJobSpecificationError { get; }
    internal static string InvalidJobStateSpecific { get; }
    internal static string JobConnectFailed { get; }
    internal static string RunspaceDisconnectFailed { get; }
    internal static string RunspaceConnectFailed { get; }
    internal static string RunspaceQueryFailed { get; }
    internal static string RunspaceCannotBeConnected { get; }
    internal static string RunspaceCannotBeConnectedForVMContainerSession { get; }
    internal static string RunspaceCannotBeDisconnected { get; }
    internal static string RunspaceCannotBeDisconnectedForVMContainerSession { get; }
    internal static string RunspaceCannotBeReceivedForVMContainerSession { get; }
    internal static string JobActionInvalidWithNullChild { get; }
    internal static string JobSuspendNotSupported { get; }
    internal static string JobResumeNotSupported { get; }
    internal static string AsJobAndDisconnectedError { get; }
    internal static string QueryForRunspacesFailed { get; }
    internal static string JobIdNotYetAssigned { get; }
    internal static string JobSessionIdLessThanOne { get; }
    internal static string JobIdentifierNull { get; }
    internal static string JobBlockedSoWaitJobCannotContinue { get; }
    internal static string RemoveRunspaceNotConnected { get; }
    internal static string RunspaceDisconnectFailedWithReason { get; }
    internal static string StopJobNotConnected { get; }
    internal static string SessionIdMatchFailed { get; }
    internal static string SessionNameMatchFailed { get; }
    internal static string WinPERemotingNotSupported { get; }
    internal static string WinRMRequiresRestart { get; }
    internal static string WinRMRestartWarning { get; }
    internal static string WinRMForceRestartWarning { get; }
    internal static string JobSourceAdapterCannotSaveNullJob { get; }
    internal static string NoPowerShellForJob { get; }
    internal static string NetFrameWorkV2NotInstalled { get; }
    internal static string PipelineFailedWithoutReason { get; }
    internal static string PipelineFailedWithReason { get; }
    internal static string ResumeJobInvalidJobState { get; }
    internal static string RemoteHostNullClientHost { get; }
    internal static string DisableRemotingShouldProcessTarget { get; }
    internal static string SetEnabledFalseTarget { get; }
    internal static string SetEnabledTrueTarget { get; }
    internal static string DISCAliasDefinitionsComment { get; }
    internal static string DISCAssembliesToLoadComment { get; }
    internal static string DISCAuthorComment { get; }
    internal static string DISCCLRVersionComment { get; }
    internal static string DISCCompanyNameComment { get; }
    internal static string DISCCopyrightComment { get; }
    internal static string DISCDescriptionComment { get; }
    internal static string DISCEnvironmentVariablesComment { get; }
    internal static string DISCExecutionPolicyComment { get; }
    internal static string DISCFormatsToProcessComment { get; }
    internal static string DISCFunctionDefinitionsComment { get; }
    internal static string DISCGUIDComment { get; }
    internal static string DISCInitialSessionStateComment { get; }
    internal static string DISCTranscriptDirectoryComment { get; }
    internal static string DISCRunAsVirtualAccountComment { get; }
    internal static string DISCLanguageModeComment { get; }
    internal static string DISCModulesToImportComment { get; }
    internal static string DISCPowerShellVersionComment { get; }
    internal static string DISCProcessorArchitectureComment { get; }
    internal static string DISCSchemaVersionComment { get; }
    internal static string DISCScriptsToProcessComment { get; }
    internal static string DISCTypesToAddComment { get; }
    internal static string DISCTypesToProcessComment { get; }
    internal static string DISCVariableDefinitionsComment { get; }
    internal static string DISCRoleDefinitionsComment { get; }
    internal static string DISCVisibleAliasesComment { get; }
    internal static string DISCVisibleCmdletsComment { get; }
    internal static string DISCCommandModificationSyntax { get; }
    internal static string DISCVisibleFunctionsComment { get; }
    internal static string DISCVisibleProvidersComment { get; }
    internal static string DISCVisibleExternalCommandsComment { get; }
    internal static string InvalidPSSessionConfigurationFilePath { get; }
    internal static string InvalidRoleCapabilityFilePath { get; }
    internal static string InvalidRoleEntry { get; }
    internal static string InvalidRoleValue { get; }
    internal static string CouldNotFindRoleCapability { get; }
    internal static string InvalidRegisterPSSessionConfigurationModulePath { get; }
    internal static string PSSessionConfigurationFileNotFound { get; }
    internal static string RCAutoDisconnected { get; }
    internal static string RCAutoDisconnectingWarning { get; }
    internal static string RCConnectionRetryAttempt { get; }
    internal static string RCInternalError { get; }
    internal static string RCNetworkFailureDetected { get; }
    internal static string RCReconnectSucceeded { get; }
    internal static string AuthenticationMechanismRequiresCredential { get; }
    internal static string BasicAuthOverHttpNotSupported { get; }
    internal static string StartJobDefinitionNotFound1 { get; }
    internal static string StartJobManyDefNameMatches { get; }
    internal static string DISCMissingSchemaVersion { get; }
    internal static string DISCTypeMustBeString { get; }
    internal static string DISCTypeMustBeStringArray { get; }
    internal static string DISCTypeMustBeHashtable { get; }
    internal static string DISCTypeMustBeHashtableArray { get; }
    internal static string DISCInvalidKey { get; }
    internal static string DISCTypeMustBeValidEnum { get; }
    internal static string DISCErrorParsingConfigFile { get; }
    internal static string WriteJobInResultsCannotBeUsedWithoutWait { get; }
    internal static string DISCPathsMustBeAbsolute { get; }
    internal static string DISCTypeContainsInvalidKey { get; }
    internal static string DISCTypeMustContainKey { get; }
    internal static string DISCInvalidExtension { get; }
    internal static string DISCKeyMustBeScriptBlock { get; }
    internal static string InvalidPSSessionConfigurationFile { get; }
    internal static string RCProgressActivity { get; }
    internal static string RCProgressStatus { get; }
    internal static string RCDisconnectedJob { get; }
    internal static string RCDisconnectSession { get; }
    internal static string RCDisconnectSessionCreated { get; }
    internal static string SessionNameWithoutInvokeDisconnected { get; }
    internal static string SessionConnectFailed { get; }
    internal static string VMSessionConnectFailed { get; }
    internal static string ContainerSessionConnectFailed { get; }
    internal static string SessionNotAvailableForConnection { get; }
    internal static string HyperVModuleNotAvailable { get; }
    internal static string CannotCreateProcessInContainer { get; }
    internal static string ContainersFeatureNotEnabled { get; }
    internal static string CannotTerminateProcessInContainer { get; }
    internal static string InvalidContainerId { get; }
    internal static string InvalidVMId { get; }
    internal static string InvalidVMIdNotSingle { get; }
    internal static string InvalidVMNameNoVM { get; }
    internal static string InvalidVMNameMultipleVM { get; }
    internal static string InvalidVMNameNotSingle { get; }
    internal static string InvalidVMState { get; }
    internal static string InvalidCredential { get; }
    internal static string InvalidUsername { get; }
    internal static string EnterPSSessionBrokenSession { get; }
    internal static string EnterPSSessionDisconnected { get; }
    internal static string RCAutoDisconnectingError { get; }
    internal static string RemoteSessionHyperVSocketClientConstructorSetSocketOptionFailure { get; }
    internal static string RemoteSessionHyperVSocketServerConstructorFailure { get; }
    internal static string StopCommandOnRetry { get; }
    internal static string SuspendJobInvalidJobState { get; }
    internal static string AutoRemoveCannotBeUsedWithoutWait { get; }
    internal static string InvalidConfigurationName { get; }
    internal static string BadRunspaceTypeForJob { get; }
    internal static string CannotDisconnectSessionWithInvalidIdleTimeout { get; }
    internal static string InvalidIdleTimeoutOption { get; }
    internal static string DISCVisibilityAndAutoLoadingCannotBeBothSpecified { get; }
    internal static string InvalidConfigurationXMLAttribute { get; }
    internal static string DISCTypeMustBeStringOrHashtableArray { get; }
    internal static string DISCTypeMustBeStringOrHashtableArrayInFile { get; }
    internal static string StartJobDefinitionPathInvalidNotFSProvider { get; }
    internal static string StartJobDefinitionPathInvalidNotSingle { get; }
    internal static string StartJobDefinitionNotFound2 { get; }
    internal static string StartJobWorkingDirectoryNotFound { get; }
    internal static string CannotFindSessionForConnect { get; }
    internal static string RunspaceConnectFailedWithMessage { get; }
    internal static string ForceCannotBeUsedWithoutWait { get; }
    internal static string JobSuspendedDisconnectedWaitWithForce { get; }
    internal static string RunAsSessionConfigurationSecurityWarning { get; }
    internal static string ForceSuspendJob { get; }
    internal static string InvalidPSSessionConfigurationFileErrorProcessing { get; }
    internal static string ErrorParsingTheKeyInPSSessionConfigurationFile { get; }
    internal static string EndpointDoesNotSupportDisconnect { get; }
    internal static string ThrottlingJobFlowControlMemoryWarning { get; }
    internal static string EnableNetworkAccessWarning { get; }
    internal static string CannotStartJobInconsistentLanguageMode { get; }
    internal static string CannotCreateRunspaceInconsistentState { get; }
    internal static string CannotExitNestedPipeline { get; }
    internal static string PowerShellInvokerInvalidState { get; }
    internal static string CannotInvokeNestedCommandNestedCommandRunning { get; }
    internal static string ServerSideNestedCommandInvokeFailed { get; }
    internal static string ReceivePSSessionInDebugMode { get; }
    internal static string RemoteDebuggingEndpointVersionError { get; }
    internal static string ICMInvalidSessionState { get; }
    internal static string ICMNoValidRunspaces { get; }
    internal static string ICMInvalidSessionAvailability { get; }
    internal static string JobActionInvalidWithNoChildJobs { get; }
    internal static string CannotDebugJobNoHostDebugger { get; }
    internal static string CannotFindJobWithId { get; }
    internal static string CannotFindJobWithInstanceId { get; }
    internal static string CannotFindJobWithName { get; }
    internal static string CannotDebugJobNoHostUI { get; }
    internal static string CannotDebugJobInvalidDebuggerMode { get; }
    internal static string FoundMultipleJobsWithId { get; }
    internal static string FoundMultipleJobsWithName { get; }
    internal static string NamedPipeAlreadyListening { get; }
    internal static string EnterPSHostProcessCantEnterSameProcess { get; }
    internal static string EnterPSHostProcessMultipleProcessesFoundWithName { get; }
    internal static string EnterPSHostProcessNoPowerShell { get; }
    internal static string EnterPSHostProcessNoProcessFoundWithId { get; }
    internal static string EnterPSHostProcessNoProcessFoundWithName { get; }
    internal static string EnterPSHostProcessNoNamedPipeFound { get; }
    internal static string CustomPipeNameTooLong { get; }
    internal static string HostDoesNotSupportIASession { get; }
    internal static string NamedPipeTransportProcessEnded { get; }
    internal static string HyperVSocketTransportProcessEnded { get; }
    internal static string EnterPSHostProcessPrompt { get; }
    internal static string EnterVMSessionPrompt { get; }
    internal static string EnterPSHostProcessCannotConnectToProcess { get; }
    internal static string EnterPSHostProcessCannotConnectToPipe { get; }
    internal static string WSManPluginConnectNoNegotiationData { get; }
    internal static string WSManPluginConnectOperationFailed { get; }
    internal static string WSManPluginContextNotFound { get; }
    internal static string WSManPluginInvalidArgSet { get; }
    internal static string WSManPluginInvalidCommandContext { get; }
    internal static string WSManPluginInvalidInputDataType { get; }
    internal static string WSManPluginInvalidInputStream { get; }
    internal static string WSManPluginInvalidOutputStream { get; }
    internal static string WSManPluginInvalidSenderDetails { get; }
    internal static string WSManPluginInvalidShellContext { get; }
    internal static string WSManPluginManagedException { get; }
    internal static string WSManPluginNullInvalidInput { get; }
    internal static string WSManPluginNullInvalidStreamSet { get; }
    internal static string WSManPluginNullPluginContext { get; }
    internal static string WSManPluginNullShellContext { get; }
    internal static string WSManPluginOperationClose { get; }
    internal static string WSManPluginOptionNotUnderstood { get; }
    internal static string WSManPluginProtocolVersionNotFound { get; }
    internal static string WSManPluginProtocolVersionNotMatch { get; }
    internal static string WSManPluginReportContextFailed { get; }
    internal static string WSManPluginSessionCreationFailed { get; }
    internal static string WSManPluginShutdownRegistrationFailed { get; }
    internal static string ServerDriverRemoteHostAlreadyPushed { get; }
    internal static string ServerDriverRemoteHostNoDebuggerToPush { get; }
    internal static string ServerDriverRemoteHostNotRemoteRunspace { get; }
    internal static string RemoteTransportError { get; }
    internal static string CannotConnectContainerNamedPipe { get; }
    internal static string CannotCreateNamedPipe { get; }
    internal static string ConnectNamedPipeTimeout { get; }
    internal static string WSManInitFailed { get; }
    internal static string NamedPipeServerCannotStart { get; }
    internal static string CouldNotResolveRoleDefinitionPrincipal { get; }
    internal static string SessionConfigurationMustBeFileBased { get; }
    internal static string CouldNotResolveUsername { get; }
    internal static string DISCRunAsVirtualAccountGroupsComment { get; }
    internal static string CannotCreateConfiguredRunspace { get; }
    internal static string DISCEnforceInputParameterValidation { get; }
    internal static string DISCMountUserDriveComment { get; }
    internal static string DISCTypeMustBeBoolean { get; }
    internal static string DISCTypeMustBeInteger { get; }
    internal static string UserDriveProcessingThrewTerminatingError { get; }
    internal static string DISCUserDriveMaxSizeComment { get; }
    internal static string UserDriveCannotGetFileSystemProvider { get; }
    internal static string DISCGMSAComment { get; }
    internal static string InvalidGMSAName { get; }
    internal static string DISCRequiredGroupsComment { get; }
    internal static string BadSDDLMismatchedParens { get; }
    internal static string RequiredGroupsHashMultipleKeys { get; }
    internal static string RequiredGroupsNotHashTable { get; }
    internal static string UnknownGroupMembershipKey { get; }
    internal static string UnknownGroupMembershipValue { get; }
    internal static string RequiredGroupsMalformedACE { get; }
    internal static string InvalidUserDriveName { get; }
    internal static string InvalidRoleCapabilityKey { get; }
    internal static string InvalidRoleCapabilityKeyType { get; }
    internal static string InvalidRoleKeyType { get; }
    internal static string RemotingErrorNoLogonSessionExist { get; }
    internal static string CannotStartSSHClient { get; }
    internal static string KeyFileNotFound { get; }
    internal static string SSHClientEndWithErrorMessage { get; }
    internal static string SSHClientConnectTimeout { get; }
    internal static string SSHClientConnectProcessTerminated { get; }
    internal static string MissingRequiredSSHParameter { get; }
    internal static string InvalidSSHConnectionParameter { get; }
    internal static string UnknownSSHConnectionParameter { get; }
    internal static string SSHConnectionDuplicateHostName { get; }
    internal static string SSHConnectionDuplicateKeyPath { get; }
    internal static string CouldNotFindRoleCapabilityFile { get; }
    internal static string InvalidRoleCapabilityFileExtension { get; }
    internal static string SSHAbruptlyTerminated { get; }
    internal static string InvalidProcessorArchitecture { get; }
    internal static string WowComponentNotPresent { get; }
    internal static string UnableToInstallPlugin { get; }
    internal static string PluginDllMissing { get; }
    internal static string WSManClientDllNotAvailable { get; }
    internal static string ProcessExitInfo { get; }
    internal static string ProcessInfoNotRecoverable { get; }
    internal static string CannotGetHostInteropTypes { get; }
    internal static string UnixOnlyHttpsWithoutSkipCACheckNotSupported { get; }
    internal static string PSCoreRemotingDisableWarning { get; }
    internal static string PSCoreRemotingEnableWarning { get; }
    internal static string EnterPSHostProcessCmdletDisabled { get; }
    internal static string RemoteDebuggerError { get; }
    internal static string WindowsPowerShellNotPresent { get; }
    internal static string InvalidPSSessionArgument { get; }
    internal static string DISCInvalidConfigKeyType { get; }
    internal static string DISCUnsupportedConfigName { get; }
    internal static string DISCUnknownConfigName { get; }
    internal static string WDACGetPowerShellLogTitle { get; }
    internal static string WDACGetPowerShellLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_DefaultRemotingExceptionMessage();
    internal static string get_OutOfMemory();
    internal static string get_PipelineIdsDoNotMatch();
    internal static string get_PipelineNotFoundOnServer();
    internal static string get_PipelineStopped();
    internal static string get_RunspaceAlreadyExists();
    internal static string get_RunspaceIdsDoNotMatch();
    internal static string get_RemoteRunspaceOpenFailed();
    internal static string get_RunspaceCannotBeFound();
    internal static string get_ResponsePromptIdCannotBeFound();
    internal static string get_RemoteHostCallFailed();
    internal static string get_RemoteHostMethodNotImplemented();
    internal static string get_RemoteHostDataEncodingNotSupported();
    internal static string get_RemoteHostDataDecodingNotSupported();
    internal static string get_NestedPipelineNotSupported();
    internal static string get_RelativeUriForRunspacePathNotSupported();
    internal static string get_RemoteHostDecodingFailed();
    internal static string get_MustBeAdminToOverrideThreadOptions();
    internal static string get_RemoteHostPromptForCredentialModifiedCaption();
    internal static string get_RemoteHostPromptForCredentialModifiedMessage();
    internal static string get_RemoteHostReadLineAsSecureStringPrompt();
    internal static string get_RemoteHostGetBufferContents();
    internal static string get_RemoteHostPromptSecureStringPrompt();
    internal static string get_ReceivedUnsupportedRemoteHostCall();
    internal static string get_ReceivedUnsupportedAction();
    internal static string get_ReceivedUnsupportedDataType();
    internal static string get_MissingDestination();
    internal static string get_MissingTarget();
    internal static string get_MissingRunspaceId();
    internal static string get_MissingDataType();
    internal static string get_MissingCallId();
    internal static string get_MissingMethodName();
    internal static string get_MissingIsStartFragment();
    internal static string get_MissingProperty();
    internal static string get_ObjectIdsNotMatching();
    internal static string get_ObjectIdCannotBeLessThanZero();
    internal static string get_FragmentIdsNotInSequence();
    internal static string get_ObjectIsTooBig();
    internal static string get_MissingIsEndFragment();
    internal static string get_DeserializedObjectIsNull();
    internal static string get_BlobLengthNotInRange();
    internal static string get_DecodingErrorForErrorRecord();
    internal static string get_DecodingErrorForPipelineStateInfo();
    internal static string get_DecodingErrorForRunspaceStateInfo();
    internal static string get_ReceivedUnsupportedRemotingTargetInterfaceType();
    internal static string get_UnknownTargetClass();
    internal static string get_MissingTargetClass();
    internal static string get_DecodingErrorForRunspacePoolStateInfo();
    internal static string get_DecodingErrorForMinRunspaces();
    internal static string get_DecodingErrorForMaxRunspaces();
    internal static string get_DecodingErrorForPowerShellStateInfo();
    internal static string get_CantCastPropertyToExpectedType();
    internal static string get_CantCastRemotingDataToPSObject();
    internal static string get_CantCastCommandToPSObject();
    internal static string get_CantCastParameterToPSObject();
    internal static string get_NotEnoughHeaderForRemoteDataObject();
    internal static string get_RemotingDestinationNotForMe();
    internal static string get_ClientNegotiationTimeout();
    internal static string get_ClientNegotiationFailed();
    internal static string get_ClientNotFoundCapabilityProperties();
    internal static string get_ServerRequestedToCloseSession();
    internal static string get_ServerNegotiationFailed();
    internal static string get_ServerConnectFailedOnNegotiation();
    internal static string get_ServerConnectFailedOnInputValidation();
    internal static string get_ServerConnectFailedOnServerStateValidation();
    internal static string get_ServerConnectFailedOnMismatchedRunspacePoolProperties();
    internal static string get_ServerNotFoundCapabilityProperties();
    internal static string get_ServerNegotiationTimeout();
    internal static string get_ClientRequestedToCloseSession();
    internal static string get_FatalErrorCausingClose();
    internal static string get_ClientKeyExchangeFailed();
    internal static string get_ServerKeyExchangeFailed();
    internal static string get_ConnectFailed();
    internal static string get_CloseIsCalled();
    internal static string get_ForceClosed();
    internal static string get_CloseFailed();
    internal static string get_CloseCompleted();
    internal static string get_UnsupportedWaitHandleType();
    internal static string get_ReceivedDataStreamIsNotStdout();
    internal static string get_StdInIsNotOpen();
    internal static string get_NativeWriteFileFailed();
    internal static string get_NativeReadFileFailed();
    internal static string get_InvalidSchemeValue();
    internal static string get_ClientReceiveFailed();
    internal static string get_ClientSendFailed();
    internal static string get_CommandHandleIsNull();
    internal static string get_StdInCannotBeSetToNoWait();
    internal static string get_PortIsOutOfRange();
    internal static string get_ServerProcessExited();
    internal static string get_CannotGetStdInHandle();
    internal static string get_CannotGetStdOutHandle();
    internal static string get_CannotGetStdErrHandle();
    internal static string get_ConnectExFailed();
    internal static string get_ConnectExCallBackError();
    internal static string get_CloseExCallBackError();
    internal static string get_SendExFailed();
    internal static string get_SendExCallBackError();
    internal static string get_ReceiveExFailed();
    internal static string get_ReceiveExCallBackError();
    internal static string get_RunShellCommandExFailed();
    internal static string get_RunShellCommandExCallBackError();
    internal static string get_ReconnectShellCommandExCallBackError();
    internal static string get_CommandSendExFailed();
    internal static string get_CommandSendExCallBackError();
    internal static string get_CommandReceiveExFailed();
    internal static string get_CommandReceiveExCallBackError();
    internal static string get_GeneralError();
    internal static string get_TroubleShootingHelpTopic();
    internal static string get_DisconnectShellExFailed();
    internal static string get_DisconnectShellExCallBackErrr();
    internal static string get_ReconnectShellExFailed();
    internal static string get_ReconnectShellExCallBackErrr();
    internal static string get_IPCTransportConnectError();
    internal static string get_NonExistentInitialSessionStateProvider();
    internal static string get_InitialSessionStateNull();
    internal static string get_MandatoryValueNotPresent();
    internal static string get_MandatoryValueNotInCorrectFormat();
    internal static string get_StartupScriptNotCorrect();
    internal static string get_DuplicateInitializationParameterFound();
    internal static string get_NoAttributesFoundForParamElement();
    internal static string get_AssemblyLoadAttributesNotFound();
    internal static string get_UnableToLoadAssembly();
    internal static string get_UnableToLoadType();
    internal static string get_TypeNeedsAssembly();
    internal static string get_RedirectedURINotWellFormatted();
    internal static string get_URIEndPointNotResolved();
    internal static string get_URIRedirectWarningToHost();
    internal static string get_URIRedirectionReported();
    internal static string get_ReceivedObjectSizeExceededMaximumClient();
    internal static string get_ReceivedDataSizeExceededMaximumClient();
    internal static string get_ReceivedObjectSizeExceededMaximumServer();
    internal static string get_ReceivedDataSizeExceededMaximumServer();
    internal static string get_StartupScriptThrewTerminatingError();
    internal static string get_RemoteRunspaceInfoHasDuplicates();
    internal static string get_RemoteRunspaceInfoLimitExceeded();
    internal static string get_RemoteRunspaceOpenUnknownState();
    internal static string get_UriSpecifiedNotValid();
    internal static string get_RemoteRunspaceClosed();
    internal static string get_RemoteRunspaceNotAvailableForSpecifiedComputer();
    internal static string get_RemoteRunspaceNotAvailableForSpecifiedRunspaceId();
    internal static string get_StopPSJobWhatIfTarget();
    internal static string get_NewRunspaceAmbiguousAuthentication();
    internal static string get_WildCardErrorFilePathParameter();
    internal static string get_FilePathNotFromFileSystemProvider();
    internal static string get_FilePathShouldPS1Extension();
    internal static string get_InvalidComputerName();
    internal static string get_InvalidJobStateGeneral();
    internal static string get_JobWithSpecifiedNameNotFound();
    internal static string get_JobWithSpecifiedInstanceIdNotFound();
    internal static string get_JobWithSpecifiedSessionIdNotFound();
    internal static string get_JobWithSpecifiedNameNotCompleted();
    internal static string get_JobWithSpecifiedSessionIdNotCompleted();
    internal static string get_JobWithSpecifiedInstanceIdNotCompleted();
    internal static string get_RemovePSJobWhatIfTarget();
    internal static string get_ComputerNameParamNotSupported();
    internal static string get_RunspaceParamNotSupported();
    internal static string get_RemoteRunspaceNotAvailableForSpecifiedName();
    internal static string get_RemoteRunspaceNotAvailableForSpecifiedSessionId();
    internal static string get_ItemNotFoundInRepository();
    internal static string get_CannotRemoveJob();
    internal static string get_CSCDoubleParameterOutOfRange();
    internal static string get_ProxyAmbiguousAuthentication();
    internal static string get_ProxyCredentialWithoutAccess();
    internal static string get_WrongSessionOptionValue();
    internal static string get_PushedRunspaceMustBeOpen();
    internal static string get_HostDoesNotSupportPushRunspace();
    internal static string get_RemoteRunspaceHasMultipleMatchesForSpecifiedRunspaceId();
    internal static string get_RemoteRunspaceHasMultipleMatchesForSpecifiedSessionId();
    internal static string get_RemoteRunspaceHasMultipleMatchesForSpecifiedName();
    internal static string get_RemoteRunspaceDoesNotSupportPushRunspace();
    internal static string get_HostInNestedPrompt();
    internal static string get_WsmanMaxRedirectionCountVariableDescription();
    internal static string get_PSDefaultSessionOptionDescription();
    internal static string get_PSSessionConfigurationName();
    internal static string get_PSSessionAppName();
    internal static string get_PSSenderInfoDescription();
    internal static string get_CSCmdsTypeNeedsAssembly();
    internal static string get_CSCmdsShellNotFound();
    internal static string get_CSCmdsShellNotPowerShellBased();
    internal static string get_CSCmdsPowerShellCoreShellNotModifiable();
    internal static string get_CSCmdsWindowsPowerShellCoreNotModifiable();
    internal static string get_CustomShellNotFound();
    internal static string get_CSShouldProcessAction();
    internal static string get_CSShouldProcessTarget();
    internal static string get_CSShouldProcessTargetAdminEnable();
    internal static string get_NcsCannotDeleteFile();
    internal static string get_NcsCannotDeleteFileAfterInstall();
    internal static string get_NcsCannotWritePluginContent();
    internal static string get_NcsScriptMessageV();
    internal static string get_NcsShouldProcessTargetSDDL();
    internal static string get_RcsScriptMessageV();
    internal static string get_GcsScriptMessageV();
    internal static string get_ScsScriptMessageV();
    internal static string get_ScsShouldProcessTargetSDDL();
    internal static string get_EcsScriptMessageV();
    internal static string get_EcsWSManQCCaption();
    internal static string get_EcsWSManQCQuery();
    internal static string get_EcsWSManShouldProcessDesc();
    internal static string get_EcsShouldProcessTarget();
    internal static string get_DcsScriptMessageV();
    internal static string get_DcsShouldProcessTarget();
    internal static string get_DcsWarningMessage();
    internal static string get_EDcsRequiresElevation();
    internal static string get_RestartWSManServiceMessageV();
    internal static string get_RestartWSManServiceAction();
    internal static string get_RestartWSManServiceTarget();
    internal static string get_RestartWSManRequiredShowUI();
    internal static string get_ERemotingCaption();
    internal static string get_ERemotingQuery();
    internal static string get_ShowUIAndSDDLCannotExist();
    internal static string get_RestartWinRMMessage();
    internal static string get_IPCUnknownNodeType();
    internal static string get_IPCInsufficientDataforElement();
    internal static string get_IPCWrongAttributeCountForDataElement();
    internal static string get_IPCOnlyTextExpectedInDataElement();
    internal static string get_IPCWrongAttributeCountForElement();
    internal static string get_IPCUnknownElementReceived();
    internal static string get_IPCSupportsOnlyDefaultAuth();
    internal static string get_IPCPwshExecutableNotFound();
    internal static string get_RunAs32NotSupported();
    internal static string get_IPCServerProcessReportedError();
    internal static string get_IPCServerProcessExited();
    internal static string get_IPCErrorProcessingServerData();
    internal static string get_IPCUnknownCommandGuid();
    internal static string get_IPCNoSignalForSession();
    internal static string get_IPCSignalTimedOut();
    internal static string get_IPCCloseTimedOut();
    internal static string get_IPCExceptionLaunchingProcess();
    internal static string get_ThrottlingJobChildAlreadyRunning();
    internal static string get_ThrottlingJobChildAddedAfterEndOfChildJobs();
    internal static string get_ThrottlingJobStatusMessage();
    internal static string get_NestedPipelineMissingRunspace();
    internal static string get_JobSourceAdapterError();
    internal static string get_PSVersionParameterOutOfRange();
    internal static string get_BlockCannotBeUsedWithKeep();
    internal static string get_WriteEventsCannotBeUsedWithoutWait();
    internal static string get_PowerShellVersionNotSupported();
    internal static string get_JobManagerRegistrationConstructorError();
    internal static string get_JobSourceAdapterNotFound();
    internal static string get_NewJobSpecificationError();
    internal static string get_InvalidJobStateSpecific();
    internal static string get_JobConnectFailed();
    internal static string get_RunspaceDisconnectFailed();
    internal static string get_RunspaceConnectFailed();
    internal static string get_RunspaceQueryFailed();
    internal static string get_RunspaceCannotBeConnected();
    internal static string get_RunspaceCannotBeConnectedForVMContainerSession();
    internal static string get_RunspaceCannotBeDisconnected();
    internal static string get_RunspaceCannotBeDisconnectedForVMContainerSession();
    internal static string get_RunspaceCannotBeReceivedForVMContainerSession();
    internal static string get_JobActionInvalidWithNullChild();
    internal static string get_JobSuspendNotSupported();
    internal static string get_JobResumeNotSupported();
    internal static string get_AsJobAndDisconnectedError();
    internal static string get_QueryForRunspacesFailed();
    internal static string get_JobIdNotYetAssigned();
    internal static string get_JobSessionIdLessThanOne();
    internal static string get_JobIdentifierNull();
    internal static string get_JobBlockedSoWaitJobCannotContinue();
    internal static string get_RemoveRunspaceNotConnected();
    internal static string get_RunspaceDisconnectFailedWithReason();
    internal static string get_StopJobNotConnected();
    internal static string get_SessionIdMatchFailed();
    internal static string get_SessionNameMatchFailed();
    internal static string get_WinPERemotingNotSupported();
    internal static string get_WinRMRequiresRestart();
    internal static string get_WinRMRestartWarning();
    internal static string get_WinRMForceRestartWarning();
    internal static string get_JobSourceAdapterCannotSaveNullJob();
    internal static string get_NoPowerShellForJob();
    internal static string get_NetFrameWorkV2NotInstalled();
    internal static string get_PipelineFailedWithoutReason();
    internal static string get_PipelineFailedWithReason();
    internal static string get_ResumeJobInvalidJobState();
    internal static string get_RemoteHostNullClientHost();
    internal static string get_DisableRemotingShouldProcessTarget();
    internal static string get_SetEnabledFalseTarget();
    internal static string get_SetEnabledTrueTarget();
    internal static string get_DISCAliasDefinitionsComment();
    internal static string get_DISCAssembliesToLoadComment();
    internal static string get_DISCAuthorComment();
    internal static string get_DISCCLRVersionComment();
    internal static string get_DISCCompanyNameComment();
    internal static string get_DISCCopyrightComment();
    internal static string get_DISCDescriptionComment();
    internal static string get_DISCEnvironmentVariablesComment();
    internal static string get_DISCExecutionPolicyComment();
    internal static string get_DISCFormatsToProcessComment();
    internal static string get_DISCFunctionDefinitionsComment();
    internal static string get_DISCGUIDComment();
    internal static string get_DISCInitialSessionStateComment();
    internal static string get_DISCTranscriptDirectoryComment();
    internal static string get_DISCRunAsVirtualAccountComment();
    internal static string get_DISCLanguageModeComment();
    internal static string get_DISCModulesToImportComment();
    internal static string get_DISCPowerShellVersionComment();
    internal static string get_DISCProcessorArchitectureComment();
    internal static string get_DISCSchemaVersionComment();
    internal static string get_DISCScriptsToProcessComment();
    internal static string get_DISCTypesToAddComment();
    internal static string get_DISCTypesToProcessComment();
    internal static string get_DISCVariableDefinitionsComment();
    internal static string get_DISCRoleDefinitionsComment();
    internal static string get_DISCVisibleAliasesComment();
    internal static string get_DISCVisibleCmdletsComment();
    internal static string get_DISCCommandModificationSyntax();
    internal static string get_DISCVisibleFunctionsComment();
    internal static string get_DISCVisibleProvidersComment();
    internal static string get_DISCVisibleExternalCommandsComment();
    internal static string get_InvalidPSSessionConfigurationFilePath();
    internal static string get_InvalidRoleCapabilityFilePath();
    internal static string get_InvalidRoleEntry();
    internal static string get_InvalidRoleValue();
    internal static string get_CouldNotFindRoleCapability();
    internal static string get_InvalidRegisterPSSessionConfigurationModulePath();
    internal static string get_PSSessionConfigurationFileNotFound();
    internal static string get_RCAutoDisconnected();
    internal static string get_RCAutoDisconnectingWarning();
    internal static string get_RCConnectionRetryAttempt();
    internal static string get_RCInternalError();
    internal static string get_RCNetworkFailureDetected();
    internal static string get_RCReconnectSucceeded();
    internal static string get_AuthenticationMechanismRequiresCredential();
    internal static string get_BasicAuthOverHttpNotSupported();
    internal static string get_StartJobDefinitionNotFound1();
    internal static string get_StartJobManyDefNameMatches();
    internal static string get_DISCMissingSchemaVersion();
    internal static string get_DISCTypeMustBeString();
    internal static string get_DISCTypeMustBeStringArray();
    internal static string get_DISCTypeMustBeHashtable();
    internal static string get_DISCTypeMustBeHashtableArray();
    internal static string get_DISCInvalidKey();
    internal static string get_DISCTypeMustBeValidEnum();
    internal static string get_DISCErrorParsingConfigFile();
    internal static string get_WriteJobInResultsCannotBeUsedWithoutWait();
    internal static string get_DISCPathsMustBeAbsolute();
    internal static string get_DISCTypeContainsInvalidKey();
    internal static string get_DISCTypeMustContainKey();
    internal static string get_DISCInvalidExtension();
    internal static string get_DISCKeyMustBeScriptBlock();
    internal static string get_InvalidPSSessionConfigurationFile();
    internal static string get_RCProgressActivity();
    internal static string get_RCProgressStatus();
    internal static string get_RCDisconnectedJob();
    internal static string get_RCDisconnectSession();
    internal static string get_RCDisconnectSessionCreated();
    internal static string get_SessionNameWithoutInvokeDisconnected();
    internal static string get_SessionConnectFailed();
    internal static string get_VMSessionConnectFailed();
    internal static string get_ContainerSessionConnectFailed();
    internal static string get_SessionNotAvailableForConnection();
    internal static string get_HyperVModuleNotAvailable();
    internal static string get_CannotCreateProcessInContainer();
    internal static string get_ContainersFeatureNotEnabled();
    internal static string get_CannotTerminateProcessInContainer();
    internal static string get_InvalidContainerId();
    internal static string get_InvalidVMId();
    internal static string get_InvalidVMIdNotSingle();
    internal static string get_InvalidVMNameNoVM();
    internal static string get_InvalidVMNameMultipleVM();
    internal static string get_InvalidVMNameNotSingle();
    internal static string get_InvalidVMState();
    internal static string get_InvalidCredential();
    internal static string get_InvalidUsername();
    internal static string get_EnterPSSessionBrokenSession();
    internal static string get_EnterPSSessionDisconnected();
    internal static string get_RCAutoDisconnectingError();
    internal static string get_RemoteSessionHyperVSocketClientConstructorSetSocketOptionFailure();
    internal static string get_RemoteSessionHyperVSocketServerConstructorFailure();
    internal static string get_StopCommandOnRetry();
    internal static string get_SuspendJobInvalidJobState();
    internal static string get_AutoRemoveCannotBeUsedWithoutWait();
    internal static string get_InvalidConfigurationName();
    internal static string get_BadRunspaceTypeForJob();
    internal static string get_CannotDisconnectSessionWithInvalidIdleTimeout();
    internal static string get_InvalidIdleTimeoutOption();
    internal static string get_DISCVisibilityAndAutoLoadingCannotBeBothSpecified();
    internal static string get_InvalidConfigurationXMLAttribute();
    internal static string get_DISCTypeMustBeStringOrHashtableArray();
    internal static string get_DISCTypeMustBeStringOrHashtableArrayInFile();
    internal static string get_StartJobDefinitionPathInvalidNotFSProvider();
    internal static string get_StartJobDefinitionPathInvalidNotSingle();
    internal static string get_StartJobDefinitionNotFound2();
    internal static string get_StartJobWorkingDirectoryNotFound();
    internal static string get_CannotFindSessionForConnect();
    internal static string get_RunspaceConnectFailedWithMessage();
    internal static string get_ForceCannotBeUsedWithoutWait();
    internal static string get_JobSuspendedDisconnectedWaitWithForce();
    internal static string get_RunAsSessionConfigurationSecurityWarning();
    internal static string get_ForceSuspendJob();
    internal static string get_InvalidPSSessionConfigurationFileErrorProcessing();
    internal static string get_ErrorParsingTheKeyInPSSessionConfigurationFile();
    internal static string get_EndpointDoesNotSupportDisconnect();
    internal static string get_ThrottlingJobFlowControlMemoryWarning();
    internal static string get_EnableNetworkAccessWarning();
    internal static string get_CannotStartJobInconsistentLanguageMode();
    internal static string get_CannotCreateRunspaceInconsistentState();
    internal static string get_CannotExitNestedPipeline();
    internal static string get_PowerShellInvokerInvalidState();
    internal static string get_CannotInvokeNestedCommandNestedCommandRunning();
    internal static string get_ServerSideNestedCommandInvokeFailed();
    internal static string get_ReceivePSSessionInDebugMode();
    internal static string get_RemoteDebuggingEndpointVersionError();
    internal static string get_ICMInvalidSessionState();
    internal static string get_ICMNoValidRunspaces();
    internal static string get_ICMInvalidSessionAvailability();
    internal static string get_JobActionInvalidWithNoChildJobs();
    internal static string get_CannotDebugJobNoHostDebugger();
    internal static string get_CannotFindJobWithId();
    internal static string get_CannotFindJobWithInstanceId();
    internal static string get_CannotFindJobWithName();
    internal static string get_CannotDebugJobNoHostUI();
    internal static string get_CannotDebugJobInvalidDebuggerMode();
    internal static string get_FoundMultipleJobsWithId();
    internal static string get_FoundMultipleJobsWithName();
    internal static string get_NamedPipeAlreadyListening();
    internal static string get_EnterPSHostProcessCantEnterSameProcess();
    internal static string get_EnterPSHostProcessMultipleProcessesFoundWithName();
    internal static string get_EnterPSHostProcessNoPowerShell();
    internal static string get_EnterPSHostProcessNoProcessFoundWithId();
    internal static string get_EnterPSHostProcessNoProcessFoundWithName();
    internal static string get_EnterPSHostProcessNoNamedPipeFound();
    internal static string get_CustomPipeNameTooLong();
    internal static string get_HostDoesNotSupportIASession();
    internal static string get_NamedPipeTransportProcessEnded();
    internal static string get_HyperVSocketTransportProcessEnded();
    internal static string get_EnterPSHostProcessPrompt();
    internal static string get_EnterVMSessionPrompt();
    internal static string get_EnterPSHostProcessCannotConnectToProcess();
    internal static string get_EnterPSHostProcessCannotConnectToPipe();
    internal static string get_WSManPluginConnectNoNegotiationData();
    internal static string get_WSManPluginConnectOperationFailed();
    internal static string get_WSManPluginContextNotFound();
    internal static string get_WSManPluginInvalidArgSet();
    internal static string get_WSManPluginInvalidCommandContext();
    internal static string get_WSManPluginInvalidInputDataType();
    internal static string get_WSManPluginInvalidInputStream();
    internal static string get_WSManPluginInvalidOutputStream();
    internal static string get_WSManPluginInvalidSenderDetails();
    internal static string get_WSManPluginInvalidShellContext();
    internal static string get_WSManPluginManagedException();
    internal static string get_WSManPluginNullInvalidInput();
    internal static string get_WSManPluginNullInvalidStreamSet();
    internal static string get_WSManPluginNullPluginContext();
    internal static string get_WSManPluginNullShellContext();
    internal static string get_WSManPluginOperationClose();
    internal static string get_WSManPluginOptionNotUnderstood();
    internal static string get_WSManPluginProtocolVersionNotFound();
    internal static string get_WSManPluginProtocolVersionNotMatch();
    internal static string get_WSManPluginReportContextFailed();
    internal static string get_WSManPluginSessionCreationFailed();
    internal static string get_WSManPluginShutdownRegistrationFailed();
    internal static string get_ServerDriverRemoteHostAlreadyPushed();
    internal static string get_ServerDriverRemoteHostNoDebuggerToPush();
    internal static string get_ServerDriverRemoteHostNotRemoteRunspace();
    internal static string get_RemoteTransportError();
    internal static string get_CannotConnectContainerNamedPipe();
    internal static string get_CannotCreateNamedPipe();
    internal static string get_ConnectNamedPipeTimeout();
    internal static string get_WSManInitFailed();
    internal static string get_NamedPipeServerCannotStart();
    internal static string get_CouldNotResolveRoleDefinitionPrincipal();
    internal static string get_SessionConfigurationMustBeFileBased();
    internal static string get_CouldNotResolveUsername();
    internal static string get_DISCRunAsVirtualAccountGroupsComment();
    internal static string get_CannotCreateConfiguredRunspace();
    internal static string get_DISCEnforceInputParameterValidation();
    internal static string get_DISCMountUserDriveComment();
    internal static string get_DISCTypeMustBeBoolean();
    internal static string get_DISCTypeMustBeInteger();
    internal static string get_UserDriveProcessingThrewTerminatingError();
    internal static string get_DISCUserDriveMaxSizeComment();
    internal static string get_UserDriveCannotGetFileSystemProvider();
    internal static string get_DISCGMSAComment();
    internal static string get_InvalidGMSAName();
    internal static string get_DISCRequiredGroupsComment();
    internal static string get_BadSDDLMismatchedParens();
    internal static string get_RequiredGroupsHashMultipleKeys();
    internal static string get_RequiredGroupsNotHashTable();
    internal static string get_UnknownGroupMembershipKey();
    internal static string get_UnknownGroupMembershipValue();
    internal static string get_RequiredGroupsMalformedACE();
    internal static string get_InvalidUserDriveName();
    internal static string get_InvalidRoleCapabilityKey();
    internal static string get_InvalidRoleCapabilityKeyType();
    internal static string get_InvalidRoleKeyType();
    internal static string get_RemotingErrorNoLogonSessionExist();
    internal static string get_CannotStartSSHClient();
    internal static string get_KeyFileNotFound();
    internal static string get_SSHClientEndWithErrorMessage();
    internal static string get_SSHClientConnectTimeout();
    internal static string get_SSHClientConnectProcessTerminated();
    internal static string get_MissingRequiredSSHParameter();
    internal static string get_InvalidSSHConnectionParameter();
    internal static string get_UnknownSSHConnectionParameter();
    internal static string get_SSHConnectionDuplicateHostName();
    internal static string get_SSHConnectionDuplicateKeyPath();
    internal static string get_CouldNotFindRoleCapabilityFile();
    internal static string get_InvalidRoleCapabilityFileExtension();
    internal static string get_SSHAbruptlyTerminated();
    internal static string get_InvalidProcessorArchitecture();
    internal static string get_WowComponentNotPresent();
    internal static string get_UnableToInstallPlugin();
    internal static string get_PluginDllMissing();
    internal static string get_WSManClientDllNotAvailable();
    internal static string get_ProcessExitInfo();
    internal static string get_ProcessInfoNotRecoverable();
    internal static string get_CannotGetHostInteropTypes();
    internal static string get_UnixOnlyHttpsWithoutSkipCACheckNotSupported();
    internal static string get_PSCoreRemotingDisableWarning();
    internal static string get_PSCoreRemotingEnableWarning();
    internal static string get_EnterPSHostProcessCmdletDisabled();
    internal static string get_RemoteDebuggerError();
    internal static string get_WindowsPowerShellNotPresent();
    internal static string get_InvalidPSSessionArgument();
    internal static string get_DISCInvalidConfigKeyType();
    internal static string get_DISCUnsupportedConfigName();
    internal static string get_DISCUnknownConfigName();
    internal static string get_WDACGetPowerShellLogTitle();
    internal static string get_WDACGetPowerShellLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class RunspaceInit : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string EnabledExperimentalFeatures { get; }
    internal static string PSHOMEDescription { get; }
    internal static string HOMEDescription { get; }
    internal static string PSHostDescription { get; }
    internal static string ExecutionContextDescription { get; }
    internal static string PSVersionTableDescription { get; }
    internal static string PIDDescription { get; }
    internal static string DollarHookDescription { get; }
    internal static string PPIDDescription { get; }
    internal static string MshShellIdDescription { get; }
    internal static string ConsoleDescription { get; }
    internal static string OutputEncodingDescription { get; }
    internal static string PSStyleDescription { get; }
    internal static string PSEmailServerDescription { get; }
    internal static string ConfirmPreferenceDescription { get; }
    internal static string DebugPreferenceDescription { get; }
    internal static string ErrorActionPreferenceDescription { get; }
    internal static string ProgressPreferenceDescription { get; }
    internal static string VerbosePreferenceDescription { get; }
    internal static string WarningPreferenceDescription { get; }
    internal static string InformationPreferenceDescription { get; }
    internal static string ErrorViewDescription { get; }
    internal static string NestedPromptLevelDescription { get; }
    internal static string PSNativeCommandUseErrorActionPreferenceDescription { get; }
    internal static string WhatIfPreferenceDescription { get; }
    internal static string NativeCommandArgumentPassingDescription { get; }
    internal static string FormatEnumerationLimitDescription { get; }
    internal static string ReportErrorShowStackTraceDescription { get; }
    internal static string ReportErrorShowInnerExceptionDescription { get; }
    internal static string ReportErrorShowSourceDescription { get; }
    internal static string ReportErrorShowExceptionClassDescription { get; }
    internal static string DollarPSCultureDescription { get; }
    internal static string DollarPSUICultureDescription { get; }
    internal static string PSDefaultParameterValuesDescription { get; }
    internal static string PauseDefinitionString { get; }
    internal static string PSEditionDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_EnabledExperimentalFeatures();
    internal static string get_PSHOMEDescription();
    internal static string get_HOMEDescription();
    internal static string get_PSHostDescription();
    internal static string get_ExecutionContextDescription();
    internal static string get_PSVersionTableDescription();
    internal static string get_PIDDescription();
    internal static string get_DollarHookDescription();
    internal static string get_PPIDDescription();
    internal static string get_MshShellIdDescription();
    internal static string get_ConsoleDescription();
    internal static string get_OutputEncodingDescription();
    internal static string get_PSStyleDescription();
    internal static string get_PSEmailServerDescription();
    internal static string get_ConfirmPreferenceDescription();
    internal static string get_DebugPreferenceDescription();
    internal static string get_ErrorActionPreferenceDescription();
    internal static string get_ProgressPreferenceDescription();
    internal static string get_VerbosePreferenceDescription();
    internal static string get_WarningPreferenceDescription();
    internal static string get_InformationPreferenceDescription();
    internal static string get_ErrorViewDescription();
    internal static string get_NestedPromptLevelDescription();
    internal static string get_PSNativeCommandUseErrorActionPreferenceDescription();
    internal static string get_WhatIfPreferenceDescription();
    internal static string get_NativeCommandArgumentPassingDescription();
    internal static string get_FormatEnumerationLimitDescription();
    internal static string get_ReportErrorShowStackTraceDescription();
    internal static string get_ReportErrorShowInnerExceptionDescription();
    internal static string get_ReportErrorShowSourceDescription();
    internal static string get_ReportErrorShowExceptionClassDescription();
    internal static string get_DollarPSCultureDescription();
    internal static string get_DollarPSUICultureDescription();
    internal static string get_PSDefaultParameterValuesDescription();
    internal static string get_PauseDefinitionString();
    internal static string get_PSEditionDescription();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class RunspacePoolStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MaxPoolLessThan1 { get; }
    internal static string MinPoolLessThan1 { get; }
    internal static string MinPoolGreaterThanMaxPool { get; }
    internal static string InvalidRunspacePoolStateGeneral { get; }
    internal static string InvalidRunspacePoolState { get; }
    internal static string CannotOpenAgain { get; }
    internal static string AsyncResultNotOwned { get; }
    internal static string RunspaceNotBelongsToPool { get; }
    internal static string ChangePropertyAfterOpen { get; }
    internal static string RunspaceDisconnectConnectNotSupported { get; }
    internal static string CannotWhileDisconnected { get; }
    internal static string DisconnectNotSupportedOnServer { get; }
    internal static string CannotReconstructCommands { get; }
    internal static string CannotConnect { get; }
    internal static string ResetRunspaceStateNotSupportedOnServer { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MaxPoolLessThan1();
    internal static string get_MinPoolLessThan1();
    internal static string get_MinPoolGreaterThanMaxPool();
    internal static string get_InvalidRunspacePoolStateGeneral();
    internal static string get_InvalidRunspacePoolState();
    internal static string get_CannotOpenAgain();
    internal static string get_AsyncResultNotOwned();
    internal static string get_RunspaceNotBelongsToPool();
    internal static string get_ChangePropertyAfterOpen();
    internal static string get_RunspaceDisconnectConnectNotSupported();
    internal static string get_CannotWhileDisconnected();
    internal static string get_DisconnectNotSupportedOnServer();
    internal static string get_CannotReconstructCommands();
    internal static string get_CannotConnect();
    internal static string get_ResetRunspaceStateNotSupportedOnServer();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class RunspaceStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidRunspaceStateGeneral { get; }
    internal static string CannotOpenAgain { get; }
    internal static string RunspaceNotInOpenedState { get; }
    internal static string RunspaceNotOpenForPipeline { get; }
    internal static string InvalidPipelineStateStateGeneral { get; }
    internal static string PipelineReInvokeNotAllowed { get; }
    internal static string InvalidValueToResultError { get; }
    internal static string NoCommandInPipeline { get; }
    internal static string ConcurrentInvokeNotAllowed { get; }
    internal static string NestedPipelineInvokeAsync { get; }
    internal static string NestedPipelineNoParentPipeline { get; }
    internal static string RunspaceCloseInvalidWhileSessionStateProxy { get; }
    internal static string NoPipelineWhenSessionStateProxyInProgress { get; }
    internal static string AnotherSessionStateProxyInProgress { get; }
    internal static string NoSessionStateProxyWhenPipelineInProgress { get; }
    internal static string ChangePropertyAfterOpen { get; }
    internal static string ErrorLoadingModulesOnRunspaceOpen { get; }
    internal static string InvalidThreadOptionsChange { get; }
    internal static string UseLocalScopeNotAllowed { get; }
    internal static string DisconnectNotSupported { get; }
    internal static string ConnectNotSupported { get; }
    internal static string RunspaceNotReady { get; }
    internal static string NotSupportedOnRestrictedRunspace { get; }
    internal static string DisconnectConnectNotSupported { get; }
    internal static string RunspaceNotOpenForPipelineConnect { get; }
    internal static string InvalidRunspacePool { get; }
    internal static string NoDisconnectedCommand { get; }
    internal static string DisconnectNotSupportedOnServer { get; }
    internal static string CannotConnect { get; }
    internal static string InvalidMyResultError { get; }
    internal static string InvalidValueToResult { get; }
    internal static string DebugRedirectionNotSupported { get; }
    internal static string VerboseRedirectionNotSupported { get; }
    internal static string WarningRedirectionNotSupported { get; }
    internal static string InformationRedirectionNotSupported { get; }
    internal static string RunningCmdWithJob { get; }
    internal static string RunningCmdWithoutJob { get; }
    internal static string RunningCmdDebugStop { get; }
    internal static string RunspaceNotLocal { get; }
    internal static string PrimaryRunspaceAlreadySet { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidRunspaceStateGeneral();
    internal static string get_CannotOpenAgain();
    internal static string get_RunspaceNotInOpenedState();
    internal static string get_RunspaceNotOpenForPipeline();
    internal static string get_InvalidPipelineStateStateGeneral();
    internal static string get_PipelineReInvokeNotAllowed();
    internal static string get_InvalidValueToResultError();
    internal static string get_NoCommandInPipeline();
    internal static string get_ConcurrentInvokeNotAllowed();
    internal static string get_NestedPipelineInvokeAsync();
    internal static string get_NestedPipelineNoParentPipeline();
    internal static string get_RunspaceCloseInvalidWhileSessionStateProxy();
    internal static string get_NoPipelineWhenSessionStateProxyInProgress();
    internal static string get_AnotherSessionStateProxyInProgress();
    internal static string get_NoSessionStateProxyWhenPipelineInProgress();
    internal static string get_ChangePropertyAfterOpen();
    internal static string get_ErrorLoadingModulesOnRunspaceOpen();
    internal static string get_InvalidThreadOptionsChange();
    internal static string get_UseLocalScopeNotAllowed();
    internal static string get_DisconnectNotSupported();
    internal static string get_ConnectNotSupported();
    internal static string get_RunspaceNotReady();
    internal static string get_NotSupportedOnRestrictedRunspace();
    internal static string get_DisconnectConnectNotSupported();
    internal static string get_RunspaceNotOpenForPipelineConnect();
    internal static string get_InvalidRunspacePool();
    internal static string get_NoDisconnectedCommand();
    internal static string get_DisconnectNotSupportedOnServer();
    internal static string get_CannotConnect();
    internal static string get_InvalidMyResultError();
    internal static string get_InvalidValueToResult();
    internal static string get_DebugRedirectionNotSupported();
    internal static string get_VerboseRedirectionNotSupported();
    internal static string get_WarningRedirectionNotSupported();
    internal static string get_InformationRedirectionNotSupported();
    internal static string get_RunningCmdWithJob();
    internal static string get_RunningCmdWithoutJob();
    internal static string get_RunningCmdDebugStop();
    internal static string get_RunspaceNotLocal();
    internal static string get_PrimaryRunspaceAlreadySet();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SecuritySupportStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CertificatePathMustBeFileSystemPath { get; }
    internal static string CertificateCannotBeUsedForEncryption { get; }
    internal static string IdentifierMustReferenceSingleCertificate { get; }
    internal static string NoCertificateFound { get; }
    internal static string CertificateContainsPrivateKey { get; }
    internal static string CouldNotEncryptContent { get; }
    internal static string CouldNotUseCertificate { get; }
    internal static string CannotEncryptSecureString { get; }
    internal static string InvalidOffset { get; }
    internal static string InvalidPublicKey { get; }
    internal static string CannotImportPublicKey { get; }
    internal static string InvalidSessionKey { get; }
    internal static string ScriptFileBlockedBySystemPolicy { get; }
    internal static string UnknownSystemScriptFileEnforcement { get; }
    internal static string ExternalScriptWDACLogTitle { get; }
    internal static string ExternalScriptWDACLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CertificatePathMustBeFileSystemPath();
    internal static string get_CertificateCannotBeUsedForEncryption();
    internal static string get_IdentifierMustReferenceSingleCertificate();
    internal static string get_NoCertificateFound();
    internal static string get_CertificateContainsPrivateKey();
    internal static string get_CouldNotEncryptContent();
    internal static string get_CouldNotUseCertificate();
    internal static string get_CannotEncryptSecureString();
    internal static string get_InvalidOffset();
    internal static string get_InvalidPublicKey();
    internal static string get_CannotImportPublicKey();
    internal static string get_InvalidSessionKey();
    internal static string get_ScriptFileBlockedBySystemPolicy();
    internal static string get_UnknownSystemScriptFileEnforcement();
    internal static string get_ExternalScriptWDACLogTitle();
    internal static string get_ExternalScriptWDACLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Serialization : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string AttributeExpected { get; }
    internal static string InvalidElementTag { get; }
    internal static string InvalidReferenceId { get; }
    internal static string InvalidDictionaryKeyName { get; }
    internal static string InvalidDictionaryValueName { get; }
    internal static string InvalidVersion { get; }
    internal static string UnexpectedVersion { get; }
    internal static string InvalidTypeHierarchyReferenceId { get; }
    internal static string DepthOfOneRequired { get; }
    internal static string InvalidNodeType { get; }
    internal static string DictionaryKeyNotSpecified { get; }
    internal static string DictionaryValueNotSpecified { get; }
    internal static string ReadCalledAfterDone { get; }
    internal static string NullAsDictionaryKey { get; }
    internal static string InvalidPrimitiveType { get; }
    internal static string DeserializationTooDeep { get; }
    internal static string Stopping { get; }
    internal static string DeserializationMemoryQuota { get; }
    internal static string DeserializeSecureStringFailed { get; }
    internal static string PrimitiveHashtableInvalidKey { get; }
    internal static string PrimitiveHashtableInvalidValue { get; }
    internal static string InvalidKey { get; }
    internal static string InvalidEncryptedString { get; }
    internal static string InvalidKeyLength { get; }
    internal static string DeserializeSecureStringNotSupported { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_AttributeExpected();
    internal static string get_InvalidElementTag();
    internal static string get_InvalidReferenceId();
    internal static string get_InvalidDictionaryKeyName();
    internal static string get_InvalidDictionaryValueName();
    internal static string get_InvalidVersion();
    internal static string get_UnexpectedVersion();
    internal static string get_InvalidTypeHierarchyReferenceId();
    internal static string get_DepthOfOneRequired();
    internal static string get_InvalidNodeType();
    internal static string get_DictionaryKeyNotSpecified();
    internal static string get_DictionaryValueNotSpecified();
    internal static string get_ReadCalledAfterDone();
    internal static string get_NullAsDictionaryKey();
    internal static string get_InvalidPrimitiveType();
    internal static string get_DeserializationTooDeep();
    internal static string get_Stopping();
    internal static string get_DeserializationMemoryQuota();
    internal static string get_DeserializeSecureStringFailed();
    internal static string get_PrimitiveHashtableInvalidKey();
    internal static string get_PrimitiveHashtableInvalidValue();
    internal static string get_InvalidKey();
    internal static string get_InvalidEncryptedString();
    internal static string get_InvalidKeyLength();
    internal static string get_DeserializeSecureStringNotSupported();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SessionStateProviderBaseStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string SetItemAction { get; }
    internal static string SetItemResourceTemplate { get; }
    internal static string ClearItemAction { get; }
    internal static string ClearItemResourceTemplate { get; }
    internal static string RemoveItemAction { get; }
    internal static string RemoveItemResourceTemplate { get; }
    internal static string NewItemAction { get; }
    internal static string NewItemResourceTemplate { get; }
    internal static string CopyItemAction { get; }
    internal static string CopyItemResourceTemplate { get; }
    internal static string RenameItemAction { get; }
    internal static string RenameItemResourceTemplate { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_SetItemAction();
    internal static string get_SetItemResourceTemplate();
    internal static string get_ClearItemAction();
    internal static string get_ClearItemResourceTemplate();
    internal static string get_RemoveItemAction();
    internal static string get_RemoveItemResourceTemplate();
    internal static string get_NewItemAction();
    internal static string get_NewItemResourceTemplate();
    internal static string get_CopyItemAction();
    internal static string get_CopyItemResourceTemplate();
    internal static string get_RenameItemAction();
    internal static string get_RenameItemResourceTemplate();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SessionStateStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidProviderInfo { get; }
    internal static string InvalidProviderInfoNull { get; }
    internal static string GetItemProviderException { get; }
    internal static string GetItemDynamicParametersProviderException { get; }
    internal static string SetItemProviderException { get; }
    internal static string SetItemDynamicParametersProviderException { get; }
    internal static string ClearItemProviderException { get; }
    internal static string InvokeDefaultActionProviderException { get; }
    internal static string InvokeDefaultActionDynamicParametersProviderException { get; }
    internal static string ItemExistsProviderException { get; }
    internal static string ItemExistsDynamicParametersProviderException { get; }
    internal static string IsValidPathProviderException { get; }
    internal static string IsItemContainerProviderException { get; }
    internal static string RemoveItemProviderException { get; }
    internal static string GetChildrenProviderException { get; }
    internal static string GetChildrenDynamicParametersProviderException { get; }
    internal static string GetChildNamesProviderException { get; }
    internal static string GetChildNamesDynamicParametersProviderException { get; }
    internal static string RenameItemProviderException { get; }
    internal static string RenameItemDynamicParametersProviderException { get; }
    internal static string NewItemProviderException { get; }
    internal static string NewItemDynamicParametersProviderException { get; }
    internal static string HasChildItemsProviderException { get; }
    internal static string CopyItemProviderException { get; }
    internal static string CopyItemDynamicParametersProviderException { get; }
    internal static string GetParentPathProviderException { get; }
    internal static string NormalizeRelativePathProviderException { get; }
    internal static string MakePathProviderException { get; }
    internal static string GetChildNameProviderException { get; }
    internal static string MoveItemProviderException { get; }
    internal static string MoveItemDynamicParametersProviderException { get; }
    internal static string GetPropertyProviderException { get; }
    internal static string GetPropertyDynamicParametersProviderException { get; }
    internal static string SetPropertyProviderException { get; }
    internal static string SetPropertyDynamicParametersProviderException { get; }
    internal static string ClearPropertyProviderException { get; }
    internal static string ClearPropertyDynamicParametersProviderException { get; }
    internal static string NewPropertyProviderException { get; }
    internal static string NewPropertyDynamicParametersProviderException { get; }
    internal static string RemovePropertyProviderException { get; }
    internal static string RemovePropertyDynamicParametersProviderException { get; }
    internal static string CopyPropertyProviderException { get; }
    internal static string CopyPropertyDynamicParametersProviderException { get; }
    internal static string MovePropertyProviderException { get; }
    internal static string MovePropertyDynamicParametersProviderException { get; }
    internal static string RenamePropertyProviderException { get; }
    internal static string RenamePropertyDynamicParametersProviderException { get; }
    internal static string GetContentReaderProviderException { get; }
    internal static string GetContentReaderDynamicParametersProviderException { get; }
    internal static string GetContentWriterProviderException { get; }
    internal static string GetContentWriterDynamicParametersProviderException { get; }
    internal static string GetContainerContentException { get; }
    internal static string WriteContainerContentException { get; }
    internal static string LocationUndoStackIsEmpty { get; }
    internal static string LocationRedoStackIsEmpty { get; }
    internal static string BoundedStackIsEmpty { get; }
    internal static string ClearContentProviderException { get; }
    internal static string ClearDirectoryContent { get; }
    internal static string ClearContentDynamicParametersProviderException { get; }
    internal static string GetSecurityDescriptorProviderException { get; }
    internal static string SetSecurityDescriptorProviderException { get; }
    internal static string ProviderStartException { get; }
    internal static string InitializeDefaultDrivesException { get; }
    internal static string NewDriveProviderException { get; }
    internal static string NewDriveDynamicParametersProviderException { get; }
    internal static string RemoveDriveProviderException { get; }
    internal static string DriveRemovalPreventedByProvider { get; }
    internal static string NormalizeRelativePathOutsideBase { get; }
    internal static string ProviderSeekError { get; }
    internal static string ProviderContentCloseError { get; }
    internal static string ProviderContentReadError { get; }
    internal static string ProviderContentWriteError { get; }
    internal static string ProviderCannotBeUsedAsVariable { get; }
    internal static string ProviderVariableSyntaxInvalid { get; }
    internal static string AliasNotWritable { get; }
    internal static string FunctionNotWritable { get; }
    internal static string VariableNotWritable { get; }
    internal static string VariableIsPrivate { get; }
    internal static string NamedCommandIsPrivate { get; }
    internal static string CommandIsPrivate { get; }
    internal static string ResourceIsPrivate { get; }
    internal static string AliasNotRemovable { get; }
    internal static string FunctionNotRemovable { get; }
    internal static string VariableNotRemovable { get; }
    internal static string AliasIsConstant { get; }
    internal static string AliasIsReadOnly { get; }
    internal static string FunctionIsConstant { get; }
    internal static string FunctionIsReadOnly { get; }
    internal static string AliasCannotBeMadeConstant { get; }
    internal static string FunctionCannotBeMadeConstant { get; }
    internal static string VariableCannotBeMadeConstant { get; }
    internal static string AliasAllScopeOptionCannotBeRemoved { get; }
    internal static string FunctionAllScopeOptionCannotBeRemoved { get; }
    internal static string VariableAllScopeOptionCannotBeRemoved { get; }
    internal static string ScopedFunctionMustHaveName { get; }
    internal static string RemoveDrivesBeforeRemovingProvider { get; }
    internal static string DriveNameIllegalCharacters { get; }
    internal static string NewDriveProviderFailed { get; }
    internal static string StackNameResolvedToMultiple { get; }
    internal static string StackNotFound { get; }
    internal static string PathNotFound { get; }
    internal static string AliasNotFound { get; }
    internal static string PathResolvedToMultiple { get; }
    internal static string VariablePathResolvedToMultiple { get; }
    internal static string DriveNotFound { get; }
    internal static string ProviderNotFound { get; }
    internal static string ProviderNotFoundBadFormat { get; }
    internal static string ProviderNameAmbiguous { get; }
    internal static string ProviderNotFoundInAssembly { get; }
    internal static string ProviderNameNotValid { get; }
    internal static string ProviderCtorException { get; }
    internal static string VariableNotFound { get; }
    internal static string TraceSourceNotFound { get; }
    internal static string DriveAlreadyExists { get; }
    internal static string VariableAlreadyExists { get; }
    internal static string AliasAlreadyExists { get; }
    internal static string CmdletProviderAlreadyExists { get; }
    internal static string MustBeFileSystemPath { get; }
    internal static string GlobalScopeCannotRemove { get; }
    internal static string ScopeIDExceedsAvailableScopes { get; }
    internal static string OnlyAbleToComparePSDriveInfo { get; }
    internal static string OutputStreamingNotEnabled { get; }
    internal static string ErrorStreamingNotEnabled { get; }
    internal static string HomePathNotSet { get; }
    internal static string NotProviderQualifiedPath { get; }
    internal static string MovePropertyDestinationResolveToSingle { get; }
    internal static string MoveItemSourceAndDestinationNotSameProvider { get; }
    internal static string MoveItemPathMultipleDestinationNotContainer { get; }
    internal static string MoveItemOneDestination { get; }
    internal static string CopyContainerItemToLeafError { get; }
    internal static string CopyContainerToContainerWithoutRecurseOrContainer { get; }
    internal static string CopyItemSourceAndDestinationNotSameProvider { get; }
    internal static string RenameMultipleItemError { get; }
    internal static string ProviderImplementationInconsistent { get; }
    internal static string IContentCmdletProvider_NotSupported { get; }
    internal static string IPropertyCmdletProvider_NotSupported { get; }
    internal static string IDynamicPropertyCmdletProvider_NotSupported { get; }
    internal static string NavigationCmdletProvider_NotSupported { get; }
    internal static string ContainerCmdletProvider_NotSupported { get; }
    internal static string ItemCmdletProvider_NotSupported { get; }
    internal static string DriveCmdletProvider_NotSupported { get; }
    internal static string CmdletProvider_NotSupported { get; }
    internal static string CmdletProvider_NotSupportedRecursionDepth { get; }
    internal static string IContent_Seek_NotSupported { get; }
    internal static string IContent_Clear_NotSupported { get; }
    internal static string Credentials_NotSupported { get; }
    internal static string FileSystemProviderCredentials_NotSupported { get; }
    internal static string Transactions_NotSupported { get; }
    internal static string Filter_NotSupported { get; }
    internal static string NewDriveCredentials_NotSupported { get; }
    internal static string NewItemAlreadyExists { get; }
    internal static string CopyItemDoesntExist { get; }
    internal static string RenameItemDoesntExist { get; }
    internal static string AliasDriveDescription { get; }
    internal static string EnvironmentDriveDescription { get; }
    internal static string FunctionDriveDescription { get; }
    internal static string VariableDriveDescription { get; }
    internal static string TempDriveDescription { get; }
    internal static string NewLinkTargetNotSpecified { get; }
    internal static string DollarNullDescription { get; }
    internal static string MaxHistoryCountDescription { get; }
    internal static string CannotRenameFunction { get; }
    internal static string CannotRenameAlias { get; }
    internal static string CannotRenameVariable { get; }
    internal static string VariableOptionsNotSettable { get; }
    internal static string CmdletIsReadOnly { get; }
    internal static string VariableNotRemovableRare { get; }
    internal static string VariableNotWritableRare { get; }
    internal static string GetContent_TailAndHeadCannotCoexist { get; }
    internal static string GetContent_TailNotSupported { get; }
    internal static string AliasWithCommandNameAlreadyExists { get; }
    internal static string CanNotRun { get; }
    internal static string CopyItemFromSessionToSession { get; }
    internal static string CopyItemRemotelyPathIsNotAbsolute { get; }
    internal static string CopyItemValidateRemotePath { get; }
    internal static string CopyItemSessionProperties { get; }
    internal static string CopyItemRemotelyPathIsNullOrEmpty { get; }
    internal static string WDACSessionStateVarLogTitle { get; }
    internal static string WDACSessionStateVarLogMessage { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidProviderInfo();
    internal static string get_InvalidProviderInfoNull();
    internal static string get_GetItemProviderException();
    internal static string get_GetItemDynamicParametersProviderException();
    internal static string get_SetItemProviderException();
    internal static string get_SetItemDynamicParametersProviderException();
    internal static string get_ClearItemProviderException();
    internal static string get_InvokeDefaultActionProviderException();
    internal static string get_InvokeDefaultActionDynamicParametersProviderException();
    internal static string get_ItemExistsProviderException();
    internal static string get_ItemExistsDynamicParametersProviderException();
    internal static string get_IsValidPathProviderException();
    internal static string get_IsItemContainerProviderException();
    internal static string get_RemoveItemProviderException();
    internal static string get_GetChildrenProviderException();
    internal static string get_GetChildrenDynamicParametersProviderException();
    internal static string get_GetChildNamesProviderException();
    internal static string get_GetChildNamesDynamicParametersProviderException();
    internal static string get_RenameItemProviderException();
    internal static string get_RenameItemDynamicParametersProviderException();
    internal static string get_NewItemProviderException();
    internal static string get_NewItemDynamicParametersProviderException();
    internal static string get_HasChildItemsProviderException();
    internal static string get_CopyItemProviderException();
    internal static string get_CopyItemDynamicParametersProviderException();
    internal static string get_GetParentPathProviderException();
    internal static string get_NormalizeRelativePathProviderException();
    internal static string get_MakePathProviderException();
    internal static string get_GetChildNameProviderException();
    internal static string get_MoveItemProviderException();
    internal static string get_MoveItemDynamicParametersProviderException();
    internal static string get_GetPropertyProviderException();
    internal static string get_GetPropertyDynamicParametersProviderException();
    internal static string get_SetPropertyProviderException();
    internal static string get_SetPropertyDynamicParametersProviderException();
    internal static string get_ClearPropertyProviderException();
    internal static string get_ClearPropertyDynamicParametersProviderException();
    internal static string get_NewPropertyProviderException();
    internal static string get_NewPropertyDynamicParametersProviderException();
    internal static string get_RemovePropertyProviderException();
    internal static string get_RemovePropertyDynamicParametersProviderException();
    internal static string get_CopyPropertyProviderException();
    internal static string get_CopyPropertyDynamicParametersProviderException();
    internal static string get_MovePropertyProviderException();
    internal static string get_MovePropertyDynamicParametersProviderException();
    internal static string get_RenamePropertyProviderException();
    internal static string get_RenamePropertyDynamicParametersProviderException();
    internal static string get_GetContentReaderProviderException();
    internal static string get_GetContentReaderDynamicParametersProviderException();
    internal static string get_GetContentWriterProviderException();
    internal static string get_GetContentWriterDynamicParametersProviderException();
    internal static string get_GetContainerContentException();
    internal static string get_WriteContainerContentException();
    internal static string get_LocationUndoStackIsEmpty();
    internal static string get_LocationRedoStackIsEmpty();
    internal static string get_BoundedStackIsEmpty();
    internal static string get_ClearContentProviderException();
    internal static string get_ClearDirectoryContent();
    internal static string get_ClearContentDynamicParametersProviderException();
    internal static string get_GetSecurityDescriptorProviderException();
    internal static string get_SetSecurityDescriptorProviderException();
    internal static string get_ProviderStartException();
    internal static string get_InitializeDefaultDrivesException();
    internal static string get_NewDriveProviderException();
    internal static string get_NewDriveDynamicParametersProviderException();
    internal static string get_RemoveDriveProviderException();
    internal static string get_DriveRemovalPreventedByProvider();
    internal static string get_NormalizeRelativePathOutsideBase();
    internal static string get_ProviderSeekError();
    internal static string get_ProviderContentCloseError();
    internal static string get_ProviderContentReadError();
    internal static string get_ProviderContentWriteError();
    internal static string get_ProviderCannotBeUsedAsVariable();
    internal static string get_ProviderVariableSyntaxInvalid();
    internal static string get_AliasNotWritable();
    internal static string get_FunctionNotWritable();
    internal static string get_VariableNotWritable();
    internal static string get_VariableIsPrivate();
    internal static string get_NamedCommandIsPrivate();
    internal static string get_CommandIsPrivate();
    internal static string get_ResourceIsPrivate();
    internal static string get_AliasNotRemovable();
    internal static string get_FunctionNotRemovable();
    internal static string get_VariableNotRemovable();
    internal static string get_AliasIsConstant();
    internal static string get_AliasIsReadOnly();
    internal static string get_FunctionIsConstant();
    internal static string get_FunctionIsReadOnly();
    internal static string get_AliasCannotBeMadeConstant();
    internal static string get_FunctionCannotBeMadeConstant();
    internal static string get_VariableCannotBeMadeConstant();
    internal static string get_AliasAllScopeOptionCannotBeRemoved();
    internal static string get_FunctionAllScopeOptionCannotBeRemoved();
    internal static string get_VariableAllScopeOptionCannotBeRemoved();
    internal static string get_ScopedFunctionMustHaveName();
    internal static string get_RemoveDrivesBeforeRemovingProvider();
    internal static string get_DriveNameIllegalCharacters();
    internal static string get_NewDriveProviderFailed();
    internal static string get_StackNameResolvedToMultiple();
    internal static string get_StackNotFound();
    internal static string get_PathNotFound();
    internal static string get_AliasNotFound();
    internal static string get_PathResolvedToMultiple();
    internal static string get_VariablePathResolvedToMultiple();
    internal static string get_DriveNotFound();
    internal static string get_ProviderNotFound();
    internal static string get_ProviderNotFoundBadFormat();
    internal static string get_ProviderNameAmbiguous();
    internal static string get_ProviderNotFoundInAssembly();
    internal static string get_ProviderNameNotValid();
    internal static string get_ProviderCtorException();
    internal static string get_VariableNotFound();
    internal static string get_TraceSourceNotFound();
    internal static string get_DriveAlreadyExists();
    internal static string get_VariableAlreadyExists();
    internal static string get_AliasAlreadyExists();
    internal static string get_CmdletProviderAlreadyExists();
    internal static string get_MustBeFileSystemPath();
    internal static string get_GlobalScopeCannotRemove();
    internal static string get_ScopeIDExceedsAvailableScopes();
    internal static string get_OnlyAbleToComparePSDriveInfo();
    internal static string get_OutputStreamingNotEnabled();
    internal static string get_ErrorStreamingNotEnabled();
    internal static string get_HomePathNotSet();
    internal static string get_NotProviderQualifiedPath();
    internal static string get_MovePropertyDestinationResolveToSingle();
    internal static string get_MoveItemSourceAndDestinationNotSameProvider();
    internal static string get_MoveItemPathMultipleDestinationNotContainer();
    internal static string get_MoveItemOneDestination();
    internal static string get_CopyContainerItemToLeafError();
    internal static string get_CopyContainerToContainerWithoutRecurseOrContainer();
    internal static string get_CopyItemSourceAndDestinationNotSameProvider();
    internal static string get_RenameMultipleItemError();
    internal static string get_ProviderImplementationInconsistent();
    internal static string get_IContentCmdletProvider_NotSupported();
    internal static string get_IPropertyCmdletProvider_NotSupported();
    internal static string get_IDynamicPropertyCmdletProvider_NotSupported();
    internal static string get_NavigationCmdletProvider_NotSupported();
    internal static string get_ContainerCmdletProvider_NotSupported();
    internal static string get_ItemCmdletProvider_NotSupported();
    internal static string get_DriveCmdletProvider_NotSupported();
    internal static string get_CmdletProvider_NotSupported();
    internal static string get_CmdletProvider_NotSupportedRecursionDepth();
    internal static string get_IContent_Seek_NotSupported();
    internal static string get_IContent_Clear_NotSupported();
    internal static string get_Credentials_NotSupported();
    internal static string get_FileSystemProviderCredentials_NotSupported();
    internal static string get_Transactions_NotSupported();
    internal static string get_Filter_NotSupported();
    internal static string get_NewDriveCredentials_NotSupported();
    internal static string get_NewItemAlreadyExists();
    internal static string get_CopyItemDoesntExist();
    internal static string get_RenameItemDoesntExist();
    internal static string get_AliasDriveDescription();
    internal static string get_EnvironmentDriveDescription();
    internal static string get_FunctionDriveDescription();
    internal static string get_VariableDriveDescription();
    internal static string get_TempDriveDescription();
    internal static string get_NewLinkTargetNotSpecified();
    internal static string get_DollarNullDescription();
    internal static string get_MaxHistoryCountDescription();
    internal static string get_CannotRenameFunction();
    internal static string get_CannotRenameAlias();
    internal static string get_CannotRenameVariable();
    internal static string get_VariableOptionsNotSettable();
    internal static string get_CmdletIsReadOnly();
    internal static string get_VariableNotRemovableRare();
    internal static string get_VariableNotWritableRare();
    internal static string get_GetContent_TailAndHeadCannotCoexist();
    internal static string get_GetContent_TailNotSupported();
    internal static string get_AliasWithCommandNameAlreadyExists();
    internal static string get_CanNotRun();
    internal static string get_CopyItemFromSessionToSession();
    internal static string get_CopyItemRemotelyPathIsNotAbsolute();
    internal static string get_CopyItemValidateRemotePath();
    internal static string get_CopyItemSessionProperties();
    internal static string get_CopyItemRemotelyPathIsNullOrEmpty();
    internal static string get_WDACSessionStateVarLogTitle();
    internal static string get_WDACSessionStateVarLogMessage();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class StringDecoratedStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string RequireExplicitRendering { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_RequireExplicitRendering();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SubsystemStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string MultipleRegistrationNotAllowed { get; }
    internal static string ImplementationAlreadyRegistered { get; }
    internal static string UnregistrationNotAllowed { get; }
    internal static string NoImplementationRegistered { get; }
    internal static string ImplementationNotFound { get; }
    internal static string SubsystemTypeUnknown { get; }
    internal static string MustUseConcreteSubsystemType { get; }
    internal static string SubsystemKindUnknown { get; }
    internal static string ConcreteSubsystemNotImplemented { get; }
    internal static string InvalidSubsystemInfo { get; }
    internal static string EmptyImplementationId { get; }
    internal static string NullOrEmptyImplementationName { get; }
    internal static string NullOrEmptyImplementationDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_MultipleRegistrationNotAllowed();
    internal static string get_ImplementationAlreadyRegistered();
    internal static string get_UnregistrationNotAllowed();
    internal static string get_NoImplementationRegistered();
    internal static string get_ImplementationNotFound();
    internal static string get_SubsystemTypeUnknown();
    internal static string get_MustUseConcreteSubsystemType();
    internal static string get_SubsystemKindUnknown();
    internal static string get_ConcreteSubsystemNotImplemented();
    internal static string get_InvalidSubsystemInfo();
    internal static string get_EmptyImplementationId();
    internal static string get_NullOrEmptyImplementationName();
    internal static string get_NullOrEmptyImplementationDescription();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class SuggestionStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Suggestion_CommandExistsInCurrentDirectory { get; }
    internal static string Suggestion_CommandNotFound { get; }
    internal static string RuleMustBeScriptBlock { get; }
    internal static string InvalidMatchType { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Suggestion_CommandExistsInCurrentDirectory();
    internal static string get_Suggestion_CommandNotFound();
    internal static string get_RuleMustBeScriptBlock();
    internal static string get_InvalidMatchType();
}
public enum System.Management.Automation.ActionPreference : Enum {
    public int value__;
    public static ActionPreference SilentlyContinue;
    public static ActionPreference Stop;
    public static ActionPreference Continue;
    public static ActionPreference Inquire;
    public static ActionPreference Ignore;
    public static ActionPreference Suspend;
    public static ActionPreference Break;
}
public class System.Management.Automation.ActionPreferenceStopException : RuntimeException {
    private ErrorRecord _errorRecord;
    public ErrorRecord ErrorRecord { get; }
    internal ActionPreferenceStopException(ErrorRecord error);
    internal ActionPreferenceStopException(InvocationInfo invocationInfo, string message);
    internal ActionPreferenceStopException(InvocationInfo invocationInfo, ErrorRecord errorRecord, string message);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ActionPreferenceStopException(SerializationInfo info, StreamingContext context);
    public ActionPreferenceStopException(string message);
    public ActionPreferenceStopException(string message, Exception innerException);
    public virtual ErrorRecord get_ErrorRecord();
}
internal abstract class System.Management.Automation.Adapter : object {
    [TraceSourceAttribute("ETS", "Extended Type System")]
protected static PSTraceSource tracer;
    private static Adapter();
    internal virtual bool CanSiteBinderOptimize(MemberTypes typeToOperateOn);
    [IteratorStateMachineAttribute("System.Management.Automation.Adapter/<GetDotNetTypeNameHierarchy>d__2")]
protected static IEnumerable`1<string> GetDotNetTypeNameHierarchy(Type type);
    protected static IEnumerable`1<string> GetDotNetTypeNameHierarchy(object obj);
    protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual ConsolidatedString GetInternedTypeNameHierarchy(object obj);
    protected abstract virtual T GetMember(object obj, string memberName);
    protected abstract virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected abstract virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected abstract virtual object PropertyGet(PSProperty property);
    protected abstract virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected abstract virtual bool PropertyIsSettable(PSProperty property);
    protected abstract virtual bool PropertyIsGettable(PSProperty property);
    protected abstract virtual string PropertyType(PSProperty property, bool forDisplay);
    protected abstract virtual string PropertyToString(PSProperty property);
    protected abstract virtual AttributeCollection PropertyAttributes(PSProperty property);
    protected virtual object MethodInvoke(PSMethod method, PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    protected abstract virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected abstract virtual Collection`1<string> MethodDefinitions(PSMethod method);
    protected virtual string MethodToString(PSMethod method);
    protected virtual string ParameterizedPropertyType(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsSettable(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsGettable(PSParameterizedProperty property);
    protected virtual Collection`1<string> ParameterizedPropertyDefinitions(PSParameterizedProperty property);
    protected virtual object ParameterizedPropertyGet(PSParameterizedProperty property, Object[] arguments);
    protected virtual void ParameterizedPropertySet(PSParameterizedProperty property, object setValue, Object[] arguments);
    protected virtual string ParameterizedPropertyToString(PSParameterizedProperty property);
    private static Exception NewException(Exception e, string errorId, string targetErrorId, string resourceString, Object[] parameters);
    internal ConsolidatedString BaseGetTypeNameHierarchy(object obj);
    internal T BaseGetMember(object obj, string memberName);
    internal T BaseGetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    internal PSMemberInfoInternalCollection`1<T> BaseGetMembers(object obj);
    internal object BasePropertyGet(PSProperty property);
    internal void BasePropertySet(PSProperty property, object setValue, bool convert);
    internal bool BasePropertyIsSettable(PSProperty property);
    internal bool BasePropertyIsGettable(PSProperty property);
    internal string BasePropertyType(PSProperty property);
    internal string BasePropertyToString(PSProperty property);
    internal AttributeCollection BasePropertyAttributes(PSProperty property);
    internal object BaseMethodInvoke(PSMethod method, PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    internal Collection`1<string> BaseMethodDefinitions(PSMethod method);
    internal string BaseMethodToString(PSMethod method);
    internal string BaseParameterizedPropertyType(PSParameterizedProperty property);
    internal bool BaseParameterizedPropertyIsSettable(PSParameterizedProperty property);
    internal bool BaseParameterizedPropertyIsGettable(PSParameterizedProperty property);
    internal Collection`1<string> BaseParameterizedPropertyDefinitions(PSParameterizedProperty property);
    internal object BaseParameterizedPropertyGet(PSParameterizedProperty property, Object[] arguments);
    internal void BaseParameterizedPropertySet(PSParameterizedProperty property, object setValue, Object[] arguments);
    internal string BaseParameterizedPropertyToString(PSParameterizedProperty property);
    private static Type GetArgumentType(object argument, bool isByRefParameter);
    internal static ConversionRank GetArgumentConversionRank(object argument, Type parameterType, bool isByRef, bool allowCastingToByRefLikeType);
    private static ParameterInformation[] ExpandParameters(int argCount, ParameterInformation[] parameters, Type elementType);
    private static int CompareOverloadCandidates(OverloadCandidate candidate1, OverloadCandidate candidate2, Object[] arguments);
    private static OverloadCandidate FindBestCandidate(List`1<OverloadCandidate> candidates, Object[] arguments);
    private static OverloadCandidate FindBestCandidate(List`1<OverloadCandidate> candidates, Object[] arguments, PSMethodInvocationConstraints invocationConstraints);
    private static int CompareTypeSpecificity(Type type1, Type type2);
    private static int CompareTypeSpecificity(Type[] params1, Type[] params2);
    private static int CompareTypeSpecificity(OverloadCandidate candidate1, OverloadCandidate candidate2);
    private static MethodBase GetGenericMethodDefinitionIfPossible(MethodBase method);
    private static bool IsInvocationTargetConstraintSatisfied(MethodInformation method, PSMethodInvocationConstraints invocationConstraints);
    private static bool IsInvocationConstraintSatisfied(OverloadCandidate overloadCandidate, PSMethodInvocationConstraints invocationConstraints);
    internal static MethodInformation FindBestMethod(MethodInformation[] methods, PSMethodInvocationConstraints invocationConstraints, bool allowCastingToByRefLikeType, Object[] arguments, String& errorId, String& errorMsg, Boolean& expandParamsOnBest, Boolean& callNonVirtually);
    private static Type[] ResolveGenericTypeParameters(Object[] genericTypeParameters);
    private static MethodInformation FindBestMethodImpl(MethodInformation[] methods, PSMethodInvocationConstraints invocationConstraints, bool allowCastingToByRefLikeType, Object[] arguments, String& errorId, String& errorMsg, Boolean& expandParamsOnBest);
    internal static Type EffectiveArgumentType(object arg);
    internal static Type GetObjectType(object obj, bool debase);
    internal static void SetReferences(Object[] arguments, MethodInformation methodInformation, Object[] originalArguments);
    internal static MethodInformation GetBestMethodAndArguments(string methodName, MethodInformation[] methods, Object[] arguments, Object[]& newArguments);
    internal static MethodInformation GetBestMethodAndArguments(string methodName, MethodInformation[] methods, PSMethodInvocationConstraints invocationConstraints, Object[] arguments, Object[]& newArguments);
    internal static Object[] GetMethodArgumentsBase(string methodName, ParameterInformation[] parameters, Object[] arguments, bool expandParamsOnBest);
    internal static void SetNewArgument(string methodName, Object[] arguments, Object[] newArguments, ParameterInformation parameter, int index);
    internal static object MethodArgumentConvertTo(object valueToConvert, bool isParameterByRef, int parameterIndex, Type resultType, IFormatProvider formatProvider);
    internal static object UnReference(object obj, Boolean& isArgumentByRef);
    internal static object PropertySetAndMethodArgumentConvertTo(object valueToConvert, Type resultType, IFormatProvider formatProvider);
    internal static void DoBoxingIfNecessary(ILGenerator generator, Type type);
}
[AttributeUsageAttribute("388")]
public class System.Management.Automation.AliasAttribute : ParsingBaseAttribute {
    internal String[] aliasNames;
    public IList`1<string> AliasNames { get; }
    public AliasAttribute(String[] aliasNames);
    public IList`1<string> get_AliasNames();
}
internal class System.Management.Automation.AliasHelpInfo : HelpInfo {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Synopsis>k__BackingField;
    private PSObject _fullHelpObject;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSObject FullHelp { get; }
    private AliasHelpInfo(AliasInfo aliasInfo);
    [CompilerGeneratedAttribute]
internal virtual string get_Name();
    [CompilerGeneratedAttribute]
internal virtual string get_Synopsis();
    internal virtual HelpCategory get_HelpCategory();
    internal virtual PSObject get_FullHelp();
    internal static AliasHelpInfo GetHelpInfo(AliasInfo aliasInfo);
}
internal class System.Management.Automation.AliasHelpProvider : HelpProvider {
    private ExecutionContext _context;
    private SessionState _sessionState;
    private CommandDiscovery _commandDiscovery;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal AliasHelpProvider(HelpSystem helpSystem);
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    [IteratorStateMachineAttribute("System.Management.Automation.AliasHelpProvider/<ExactMatchHelp>d__8")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.AliasHelpProvider/<SearchHelp>d__9")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    private static bool Match(HelpInfo helpInfo, HelpRequest helpRequest);
    private static bool Match(string target, String[] patterns);
    private static bool Match(string target, string pattern);
}
public class System.Management.Automation.AliasInfo : CommandInfo {
    private string _definition;
    private ScopedItemOptions _options;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnresolvedCommandName>k__BackingField;
    internal HelpCategory HelpCategory { get; }
    public CommandInfo ReferencedCommand { get; }
    public CommandInfo ResolvedCommand { get; }
    public string Definition { get; }
    public ScopedItemOptions Options { get; public set; }
    public string Description { get; public set; }
    internal string UnresolvedCommandName { get; private set; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal AliasInfo(string name, string definition, ExecutionContext context);
    internal AliasInfo(string name, string definition, ExecutionContext context, ScopedItemOptions options);
    internal virtual HelpCategory get_HelpCategory();
    public CommandInfo get_ReferencedCommand();
    public CommandInfo get_ResolvedCommand();
    public virtual string get_Definition();
    internal void SetDefinition(string definition, bool force);
    public ScopedItemOptions get_Options();
    public void set_Options(ScopedItemOptions value);
    internal void SetOptions(ScopedItemOptions newOptions, bool force);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
internal string get_UnresolvedCommandName();
    [CompilerGeneratedAttribute]
private void set_UnresolvedCommandName(string value);
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
}
internal class System.Management.Automation.AliasScopeItemSearcher : ScopedItemSearcher`1<AliasInfo> {
    public AliasScopeItemSearcher(SessionStateInternal sessionState, VariablePath lookupPath);
    protected virtual bool GetScopeItem(SessionStateScope scope, VariablePath name, AliasInfo& alias);
}
public enum System.Management.Automation.Alignment : Enum {
    public int value__;
    public static Alignment Undefined;
    public static Alignment Left;
    public static Alignment Center;
    public static Alignment Right;
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.AllowEmptyCollectionAttribute : CmdletMetadataAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.AllowEmptyStringAttribute : CmdletMetadataAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.AllowNullAttribute : CmdletMetadataAttribute {
}
internal static class System.Management.Automation.AmsiUtils : object {
    private static IntPtr s_amsiContext;
    private static IntPtr s_amsiSession;
    private static bool s_amsiInitFailed;
    private static bool s_amsiNotifyFailed;
    private static object s_amsiLockObject;
    public static bool AmsiUninitializeCalled;
    public static bool AmsiInitialized;
    public static bool AmsiCleanedUp;
    private static AmsiUtils();
    internal static int Init();
    internal static AMSI_RESULT ScanContent(string content, string sourceMetadata);
    internal static AMSI_RESULT WinScanContent(string content, string sourceMetadata, bool warmUp);
    internal static bool ReportContent(string name, string content);
    private static bool WinReportContent(string name, string content);
    private static bool CheckAmsiInit();
    internal static void CurrentDomain_ProcessExit(object sender, EventArgs e);
    internal static void CloseSession();
    internal static void WinCloseSession();
    internal static void Uninitialize();
    internal static void WinUninitialize();
}
internal static class System.Management.Automation.AnalysisCache : object {
    private static AnalysisCacheData s_cacheData;
    private static ConcurrentDictionary`2<string, string> s_modulesBeingAnalyzed;
    internal static Char[] InvalidCommandNameCharacters;
    private static AnalysisCache();
    internal static ConcurrentDictionary`2<string, CommandTypes> GetExportedCommands(string modulePath, bool testOnly, ExecutionContext context);
    private static ConcurrentDictionary`2<string, CommandTypes> AnalyzeManifestModule(string modulePath, ExecutionContext context, DateTime lastWriteTime, bool etwEnabled);
    internal static bool ModuleIsEditionIncompatible(string modulePath, Hashtable moduleManifestProperties);
    internal static bool ModuleAnalysisViaGetModuleRequired(object modulePathObj, bool hadCmdlets, bool hadFunctions, bool hadAliases);
    private static bool CheckModulesTypesInManifestAgainstExportedCommands(Hashtable moduleManifestProperties, bool hadCmdlets, bool hadFunctions, bool hadAliases);
    private static bool AddPsd1EntryToResult(ConcurrentDictionary`2<string, CommandTypes> result, string command, CommandTypes commandTypeToAdd, Boolean& sawWildcard);
    private static bool AddPsd1EntryToResult(ConcurrentDictionary`2<string, CommandTypes> result, object value, CommandTypes commandTypeToAdd, Boolean& sawWildcard);
    private static ConcurrentDictionary`2<string, CommandTypes> AnalyzeScriptModule(string modulePath, ExecutionContext context, DateTime lastWriteTime);
    private static ConcurrentDictionary`2<string, CommandTypes> AnalyzeCdxmlModule(string modulePath, ExecutionContext context, DateTime lastWriteTime);
    private static ConcurrentDictionary`2<string, CommandTypes> AnalyzeDllModule(string modulePath, ExecutionContext context, DateTime lastWriteTime);
    private static ConcurrentDictionary`2<string, CommandTypes> AnalyzeTheOldWay(string modulePath, ExecutionContext context, DateTime lastWriteTime);
    internal static ConcurrentDictionary`2<string, TypeAttributes> GetExportedClasses(string modulePath, ExecutionContext context);
    internal static void CacheModuleExports(PSModuleInfo module, ExecutionContext context);
    private static void CallGetModuleDashList(ExecutionContext context, string modulePath);
    private static bool GetModuleEntryFromCache(string modulePath, DateTime& lastWriteTime, ModuleCacheEntry& moduleCacheEntry);
}
internal class System.Management.Automation.AnalysisCacheData : object {
    [CompilerGeneratedAttribute]
private DateTime <LastReadTime>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentDictionary`2<string, ModuleCacheEntry> <Entries>k__BackingField;
    private int _saveCacheToDiskQueued;
    private bool _saveCacheToDisk;
    private static string TruncatedErrorMessage;
    private static string InvalidSignatureErrorMessage;
    private static string PossibleCorruptionErrorMessage;
    private static string s_cacheStoreLocation;
    public DateTime LastReadTime { get; public set; }
    public ConcurrentDictionary`2<string, ModuleCacheEntry> Entries { get; public set; }
    private static AnalysisCacheData();
    private static Byte[] GetHeader();
    [CompilerGeneratedAttribute]
public DateTime get_LastReadTime();
    [CompilerGeneratedAttribute]
public void set_LastReadTime(DateTime value);
    [CompilerGeneratedAttribute]
public ConcurrentDictionary`2<string, ModuleCacheEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(ConcurrentDictionary`2<string, ModuleCacheEntry> value);
    public void QueueSerialization();
    private void Cleanup();
    private static void Write(int val, Byte[] bytes, FileStream stream);
    private static void Write(long val, Byte[] bytes, FileStream stream);
    private static void Write(string val, Byte[] bytes, FileStream stream);
    private void Serialize(string filename);
    private static long ReadLong(FileStream stream, Byte[] bytes);
    private static int ReadInt(FileStream stream, Byte[] bytes);
    private static string ReadString(FileStream stream, Byte[]& bytes);
    private static void ReadHeader(FileStream stream, Byte[] bytes);
    public static AnalysisCacheData Deserialize(string filename);
    internal static AnalysisCacheData Get();
    [NullableContextAttribute("2")]
[AsyncStateMachineAttribute("System.Management.Automation.AnalysisCacheData/<<QueueSerialization>b__11_0>d")]
[CompilerGeneratedAttribute]
private Task <QueueSerialization>b__11_0();
}
public class System.Management.Automation.ApplicationFailedException : RuntimeException {
    private static string errorIdString;
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ApplicationFailedException(SerializationInfo info, StreamingContext context);
    public ApplicationFailedException(string message);
    internal ApplicationFailedException(string message, string errorId);
    internal ApplicationFailedException(string message, string errorId, Exception innerException);
    public ApplicationFailedException(string message, Exception innerException);
}
public class System.Management.Automation.ApplicationInfo : CommandInfo {
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Extension>k__BackingField;
    private Version _version;
    private ReadOnlyCollection`1<PSTypeName> _outputType;
    public string Path { get; }
    public string Extension { get; }
    public string Definition { get; }
    public string Source { get; }
    public Version Version { get; }
    public SessionStateEntryVisibility Visibility { get; public set; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal ApplicationInfo(string name, string path, ExecutionContext context);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Extension();
    public virtual string get_Definition();
    public virtual string get_Source();
    public virtual Version get_Version();
    public virtual SessionStateEntryVisibility get_Visibility();
    public virtual void set_Visibility(SessionStateEntryVisibility value);
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ArgumentCompleterAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    public Type Type { get; }
    public ScriptBlock ScriptBlock { get; }
    public ArgumentCompleterAttribute(Type type);
    public ArgumentCompleterAttribute(ScriptBlock scriptBlock);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public ScriptBlock get_ScriptBlock();
    internal IArgumentCompleter CreateArgumentCompleter();
}
[AttributeUsageAttribute("384")]
public abstract class System.Management.Automation.ArgumentCompleterFactoryAttribute : ArgumentCompleterAttribute {
    public abstract virtual IArgumentCompleter Create();
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ArgumentCompletionsAttribute : Attribute {
    private String[] _completions;
    public ArgumentCompletionsAttribute(String[] completions);
    [IteratorStateMachineAttribute("System.Management.Automation.ArgumentCompletionsAttribute/<CompleteArgument>d__2")]
public IEnumerable`1<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
internal class System.Management.Automation.ArgumentEncodingCompletionsAttribute : ArgumentCompletionsAttribute {
}
internal class System.Management.Automation.ArgumentToEncodingTransformationAttribute : ArgumentTransformationAttribute {
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.ArgumentToVersionTransformationAttribute : ArgumentTransformationAttribute {
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
    protected virtual bool TryConvertFromString(string versionString, Version& version);
}
[AttributeUsageAttribute("384")]
public abstract class System.Management.Automation.ArgumentTransformationAttribute : CmdletMetadataAttribute {
    public bool TransformNullOptionalParameters { get; }
    public abstract virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
    internal object TransformInternal(EngineIntrinsics engineIntrinsics, object inputData, bool trackDataInputSource);
    public virtual bool get_TransformNullOptionalParameters();
}
public class System.Management.Automation.ArgumentTransformationMetadataException : MetadataException {
    internal static string ArgumentTransformationArgumentsShouldBeStrings;
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ArgumentTransformationMetadataException(SerializationInfo info, StreamingContext context);
    public ArgumentTransformationMetadataException(string message);
    public ArgumentTransformationMetadataException(string message, Exception innerException);
    internal ArgumentTransformationMetadataException(string errorId, Exception innerException, string resourceStr, Object[] arguments);
}
internal class System.Management.Automation.ArgumentTypeConverterAttribute : ArgumentTransformationAttribute {
    private Type[] _convertTypes;
    internal Type TargetType { get; }
    internal ArgumentTypeConverterAttribute(Type[] types);
    internal Type get_TargetType();
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
    internal object Transform(EngineIntrinsics engineIntrinsics, object inputData, bool bindingParameters, bool bindingScriptCmdlet);
    private static void CheckBoolValue(object value, Type boolType);
    internal static void ThrowPSInvalidBooleanArgumentCastException(Type resultType, Type convertType);
}
internal static class System.Management.Automation.ArrayOps : object {
    internal static Object[] SlicingIndex(object target, Object[] indexes, Func`3<object, object, object> indexer);
    internal static T[] Multiply(T[] array, UInt32 times);
    internal static object GetMDArrayValue(Array array, Int32[] indexes, bool slicing);
    internal static object GetMDArrayValueOrSlice(Array array, object indexes);
    private static void ReportIndexingError(Array array, object index, Exception reason);
    internal static string IndexStringMessage(object index);
    internal static object SetMDArrayValue(Array array, Int32[] indexes, object value);
    internal static object GetNonIndexable(object target, Object[] indices);
}
internal class System.Management.Automation.AssertException : SystemException {
    [CompilerGeneratedAttribute]
private string <StackTrace>k__BackingField;
    public string StackTrace { get; }
    internal AssertException(string message);
    [CompilerGeneratedAttribute]
public virtual string get_StackTrace();
}
internal static class System.Management.Automation.AstTypeInference : object {
    public static IList`1<PSTypeName> InferTypeOf(Ast ast);
    public static IList`1<PSTypeName> InferTypeOf(Ast ast, TypeInferenceRuntimePermissions evalPermissions);
    public static IList`1<PSTypeName> InferTypeOf(Ast ast, PowerShell powerShell);
    public static IList`1<PSTypeName> InferTypeOf(Ast ast, PowerShell powerShell, TypeInferenceRuntimePermissions evalPersmissions);
    internal static IList`1<PSTypeName> InferTypeOf(Ast ast, TypeInferenceContext context, TypeInferenceRuntimePermissions evalPersmissions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.AsyncByteStreamTransfer : object {
    private static int DefaultBufferSize;
    private BytePipe _bytePipe;
    private BytePipe _destinationPipe;
    [NullableAttribute("0")]
private Memory`1<byte> _buffer;
    private CancellationTokenSource _cts;
    [NullableAttribute("2")]
private Task _readToBufferTask;
    public Task EOF { get; }
    public AsyncByteStreamTransfer(BytePipe bytePipe, BytePipe destinationPipe);
    public Task get_EOF();
    public void BeginReadChunks();
    public sealed virtual void Dispose();
    [AsyncStateMachineAttribute("System.Management.Automation.AsyncByteStreamTransfer/<ReadBufferAsync>d__11")]
private Task ReadBufferAsync();
}
public class System.Management.Automation.AuthorizationManager : object {
    private object _policyCheckLock;
    [CompilerGeneratedAttribute]
private string <ShellId>k__BackingField;
    internal string ShellId { get; }
    public AuthorizationManager(string shellId);
    internal void ShouldRunInternal(CommandInfo commandInfo, CommandOrigin origin, PSHost host);
    [CompilerGeneratedAttribute]
internal string get_ShellId();
    protected internal virtual bool ShouldRun(CommandInfo commandInfo, CommandOrigin origin, PSHost host, Exception& reason);
}
internal enum System.Management.Automation.AutomaticVariable : Enum {
    public int value__;
    public static AutomaticVariable Underbar;
    public static AutomaticVariable Args;
    public static AutomaticVariable This;
    public static AutomaticVariable Input;
    public static AutomaticVariable PSCmdlet;
    public static AutomaticVariable PSBoundParameters;
    public static AutomaticVariable MyInvocation;
    public static AutomaticVariable PSScriptRoot;
    public static AutomaticVariable PSCommandPath;
    public static AutomaticVariable NumberOfAutomaticVariables;
}
internal class System.Management.Automation.AutomationEngine : object {
    internal Parser EngineParser;
    [CompilerGeneratedAttribute]
private ExecutionContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandDiscovery <CommandDiscovery>k__BackingField;
    internal ExecutionContext Context { get; }
    internal CommandDiscovery CommandDiscovery { get; }
    private static AutomationEngine();
    internal AutomationEngine(PSHost hostInterface, InitialSessionState iss);
    [CompilerGeneratedAttribute]
internal ExecutionContext get_Context();
    [CompilerGeneratedAttribute]
internal CommandDiscovery get_CommandDiscovery();
    internal string Expand(string s);
    internal ScriptBlock ParseScriptBlock(string script, bool addToHistory);
    internal ScriptBlock ParseScriptBlock(string script, string fileName, bool addToHistory);
}
internal abstract class System.Management.Automation.BaseCommandHelpInfo : HelpInfo {
    [CompilerGeneratedAttribute]
private HelpCategory <HelpCategory>k__BackingField;
    internal PSObject Details { get; }
    internal string Name { get; }
    internal string Synopsis { get; }
    internal HelpCategory HelpCategory { get; }
    internal string DetailedDescription { get; }
    internal BaseCommandHelpInfo(HelpCategory helpCategory);
    internal PSObject get_Details();
    internal virtual string get_Name();
    internal virtual string get_Synopsis();
    [CompilerGeneratedAttribute]
internal virtual HelpCategory get_HelpCategory();
    internal virtual Uri GetUriForOnlineHelp();
    internal Uri LookupUriFromCommandInfo();
    internal static Uri GetUriFromCommandPSObject(PSObject commandFullHelp);
    internal virtual bool MatchPatternInContent(WildcardPattern pattern);
    internal virtual PSObject[] GetParameter(string pattern);
    internal string get_DetailedDescription();
}
internal class System.Management.Automation.BaseDotNetAdapterForAdaptedObjects : DotNetAdapter {
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
}
internal abstract class System.Management.Automation.BaseWMIAdapter : Adapter {
    private static HybridDictionary s_instanceMethodCacheTable;
    private static BaseWMIAdapter();
    [IteratorStateMachineAttribute("System.Management.Automation.BaseWMIAdapter/<GetTypeNameHierarchyFromDerivation>d__2")]
private static IEnumerable`1<string> GetTypeNameHierarchyFromDerivation(ManagementBaseObject managementObj, string dotnetBaseType, bool shouldIncludeNamespace);
    [IteratorStateMachineAttribute("System.Management.Automation.BaseWMIAdapter/<GetTypeNameHierarchy>d__3")]
protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected virtual Collection`1<string> MethodDefinitions(PSMethod method);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual string PropertyToString(PSProperty property);
    protected virtual AttributeCollection PropertyAttributes(PSProperty property);
    protected static CacheTable GetInstanceMethodTable(ManagementBaseObject wmiObject, bool staticBinding);
    private static void PopulateMethodTable(ManagementClass mgmtClass, CacheTable methodTable, bool staticBinding);
    private static ManagementClass CreateClassFrmObject(ManagementBaseObject mgmtBaseObject);
    protected static string GetEmbeddedObjectTypeName(PropertyData pData);
    protected static Type GetDotNetType(PropertyData pData);
    protected static bool IsStaticMethod(MethodData mdata);
    private object AuxillaryInvokeMethod(ManagementObject obj, WMIMethodCacheEntry mdata, Object[] arguments);
    internal static void UpdateParameters(ManagementBaseObject parameters, SortedList`2<int, WMIParameterInformation> parametersList);
    internal static MethodInformation GetMethodInformation(MethodData mData);
    internal static string GetMethodDefinition(MethodData mData);
    protected abstract virtual void AddAllProperties(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected abstract virtual void AddAllMethods(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected abstract virtual object InvokeManagementMethod(ManagementObject wmiObject, string methodName, ManagementBaseObject inParams);
    protected abstract virtual T GetManagementObjectMethod(ManagementBaseObject wmiObject, string methodName);
    protected abstract virtual PSProperty DoGetProperty(ManagementBaseObject wmiObject, string propertyName);
    protected abstract virtual T GetFirstOrDefaultProperty(ManagementBaseObject wmiObject, MemberNamePredicate predicate);
    protected abstract virtual T GetFirstOrDefaultMethod(ManagementBaseObject wmiObject, MemberNamePredicate predicate);
}
internal class System.Management.Automation.BatchInvocationContext : object {
    private AutoResetEvent _completionEvent;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<PSObject> <Output>k__BackingField;
    [CompilerGeneratedAttribute]
private PSCommand <Command>k__BackingField;
    internal PSDataCollection`1<PSObject> Output { get; }
    internal PSCommand Command { get; }
    internal BatchInvocationContext(PSCommand command, PSDataCollection`1<PSObject> output);
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<PSObject> get_Output();
    [CompilerGeneratedAttribute]
internal PSCommand get_Command();
    internal void Wait();
    internal void Signal();
}
internal static class System.Management.Automation.Boxed : object {
    internal static object True;
    internal static object False;
    private static Boxed();
}
public class System.Management.Automation.BreakException : LoopFlowException {
    internal BreakException(string label);
    internal BreakException(string label, Exception innerException);
}
public abstract class System.Management.Automation.Breakpoint : object {
    [CompilerGeneratedAttribute]
private ScriptBlock <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    [CompilerGeneratedAttribute]
private int <HitCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Script>k__BackingField;
    private static int s_lastID;
    public ScriptBlock Action { get; }
    public bool Enabled { get; private set; }
    public int HitCount { get; private set; }
    public int Id { get; }
    internal bool IsScriptBreakpoint { get; }
    public string Script { get; }
    protected Breakpoint(string script);
    protected Breakpoint(string script, ScriptBlock action);
    protected Breakpoint(string script, int id);
    protected Breakpoint(string script, ScriptBlock action, int id);
    [CompilerGeneratedAttribute]
public ScriptBlock get_Action();
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    internal void SetEnabled(bool value);
    [CompilerGeneratedAttribute]
public int get_HitCount();
    [CompilerGeneratedAttribute]
private void set_HitCount(int value);
    [CompilerGeneratedAttribute]
public int get_Id();
    internal bool get_IsScriptBreakpoint();
    [CompilerGeneratedAttribute]
public string get_Script();
    internal BreakpointAction Trigger();
    internal virtual bool RemoveSelf(ScriptDebugger debugger);
}
public class System.Management.Automation.BreakpointUpdatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Breakpoint <Breakpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private BreakpointUpdateType <UpdateType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BreakpointCount>k__BackingField;
    public Breakpoint Breakpoint { get; }
    public BreakpointUpdateType UpdateType { get; }
    public int BreakpointCount { get; }
    internal BreakpointUpdatedEventArgs(Breakpoint breakpoint, BreakpointUpdateType updateType, int breakpointCount);
    [CompilerGeneratedAttribute]
public Breakpoint get_Breakpoint();
    [CompilerGeneratedAttribute]
public BreakpointUpdateType get_UpdateType();
    [CompilerGeneratedAttribute]
public int get_BreakpointCount();
}
public enum System.Management.Automation.BreakpointUpdateType : Enum {
    public int value__;
    public static BreakpointUpdateType Set;
    public static BreakpointUpdateType Removed;
    public static BreakpointUpdateType Enabled;
    public static BreakpointUpdateType Disabled;
}
internal static class System.Management.Automation.ByRefOps : object {
    internal static object GetByRefPropertyValue(object target, PropertyInfo property);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class System.Management.Automation.BytePipe : object {
    public abstract virtual Task`1<Stream> GetStream(CancellationToken cancellationToken);
    internal AsyncByteStreamTransfer Bind(BytePipe bytePipe);
}
public abstract class System.Management.Automation.CachedValidValuesGeneratorBase : object {
    private String[] _validValues;
    private int _validValuesCacheExpiration;
    protected CachedValidValuesGeneratorBase(int cacheExpirationInSeconds);
    public abstract virtual String[] GenerateValidValues();
    public sealed virtual String[] GetValidValues();
    [CompilerGeneratedAttribute]
private String[] <GetValidValues>b__4_0(Task task);
}
internal abstract class System.Management.Automation.CacheEntry : object {
    internal bool IsHidden { get; }
    internal virtual bool get_IsHidden();
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.CacheTable : object {
    internal Collection`1<object> memberCollection;
    private Dictionary`2<string, int> _indexes;
    internal object Item { get; }
    internal void Add(string name, object member);
    internal object get_Item(string name);
    internal object GetFirstOrDefault(MemberNamePredicate predicate);
}
public class System.Management.Automation.CallStackFrame : object {
    [CompilerGeneratedAttribute]
private InvocationInfo <InvocationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private FunctionContext <FunctionContext>k__BackingField;
    public string ScriptName { get; }
    public int ScriptLineNumber { get; }
    public InvocationInfo InvocationInfo { get; }
    public IScriptExtent Position { get; }
    public string FunctionName { get; }
    internal FunctionContext FunctionContext { get; }
    public CallStackFrame(InvocationInfo invocationInfo);
    internal CallStackFrame(FunctionContext functionContext, InvocationInfo invocationInfo);
    public string get_ScriptName();
    public int get_ScriptLineNumber();
    [CompilerGeneratedAttribute]
public InvocationInfo get_InvocationInfo();
    [CompilerGeneratedAttribute]
public IScriptExtent get_Position();
    public string get_FunctionName();
    [CompilerGeneratedAttribute]
internal FunctionContext get_FunctionContext();
    public string GetScriptLocation();
    public Dictionary`2<string, PSVariable> GetFrameVariables();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool <GetFrameVariables>b__18_0(MutableTuple s);
}
internal static class System.Management.Automation.CatalogHelper : object {
    private static int catalogVersion1;
    private static int catalogVersion2;
    private static string HashAlgorithmSHA1;
    private static string HashAlgorithmSHA256;
    private static PSCmdlet _cmdlet;
    private static int GetCatalogVersion(SafeCATHandle catalogHandle);
    private static string GetCatalogHashAlgorithm(int catalogVersion);
    internal static string GenerateCDFFile(Collection`1<string> Path, string catalogFilePath, string cdfFilePath, int catalogVersion, string hashAlgorithm);
    internal static void ProcessFileToBeAddedInCatalogDefinitionFile(FileInfo fileToHash, DirectoryInfo dirInfo, HashSet`1& relativePaths, String& cdfHeaderContent, String& cdfFilesContent, Int32& catAttributeCount);
    internal static void GenerateCatalogFile(string cdfFilePath);
    internal static FileInfo GenerateCatalog(PSCmdlet cmdlet, Collection`1<string> Path, string catalogFilePath, int catalogVersion);
    internal static string ProcessFilePathAttributeInCatalog(IntPtr memberAttrInfo);
    internal static string CalculateFileHash(string filePath, string hashAlgorithm);
    internal static Dictionary`2<string, string> GetHashesFromCatalog(string catalogFilePath, WildcardPattern[] excludedPatterns, Int32& catalogVersion);
    internal static void ProcessCatalogFile(string relativePath, string fileHash, WildcardPattern[] excludedPatterns, Dictionary`2& catalogHashes);
    internal static void ProcessPathFile(FileInfo fileToHash, DirectoryInfo dirInfo, string hashAlgorithm, WildcardPattern[] excludedPatterns, Dictionary`2& fileHashes);
    internal static Dictionary`2<string, string> CalculateHashesFromPath(Collection`1<string> folderPaths, string catalogFilePath, string hashAlgorithm, WildcardPattern[] excludedPatterns);
    internal static bool CompareDictionaries(Dictionary`2<string, string> catalogItems, Dictionary`2<string, string> pathItems);
    internal static CatalogInformation ValidateCatalog(PSCmdlet cmdlet, Collection`1<string> catalogFolders, string catalogFilePath, WildcardPattern[] excludedPatterns);
    internal static bool CheckExcludedCriteria(string filename, WildcardPattern[] excludedPatterns);
    private static void ParseErrorCallback(UInt32 dwErrorArea, UInt32 dwLocalError, string pwszLine);
}
public class System.Management.Automation.CatalogInformation : object {
    [CompilerGeneratedAttribute]
private CatalogValidationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <CatalogItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <PathItems>k__BackingField;
    [CompilerGeneratedAttribute]
private Signature <Signature>k__BackingField;
    public CatalogValidationStatus Status { get; public set; }
    public string HashAlgorithm { get; public set; }
    public Dictionary`2<string, string> CatalogItems { get; public set; }
    public Dictionary`2<string, string> PathItems { get; public set; }
    public Signature Signature { get; public set; }
    [CompilerGeneratedAttribute]
public CatalogValidationStatus get_Status();
    [CompilerGeneratedAttribute]
public void set_Status(CatalogValidationStatus value);
    [CompilerGeneratedAttribute]
public string get_HashAlgorithm();
    [CompilerGeneratedAttribute]
public void set_HashAlgorithm(string value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_CatalogItems();
    [CompilerGeneratedAttribute]
public void set_CatalogItems(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, string> get_PathItems();
    [CompilerGeneratedAttribute]
public void set_PathItems(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public Signature get_Signature();
    [CompilerGeneratedAttribute]
public void set_Signature(Signature value);
}
public enum System.Management.Automation.CatalogValidationStatus : Enum {
    public int value__;
    public static CatalogValidationStatus Valid;
    public static CatalogValidationStatus ValidationFailed;
}
internal static class System.Management.Automation.CharOps : object {
    internal static object CompareStringIeq(char lhs, string rhs);
    internal static object CompareStringIne(char lhs, string rhs);
    internal static object CompareIeq(char lhs, char rhs);
    internal static object CompareIne(char lhs, char rhs);
    internal static Object[] Range(char start, char end);
}
internal class System.Management.Automation.CharRangeEnumerator : object {
    private int _increment;
    private bool _firstElement;
    [CompilerGeneratedAttribute]
private char <LowerBound>k__BackingField;
    [CompilerGeneratedAttribute]
private char <UpperBound>k__BackingField;
    [CompilerGeneratedAttribute]
private char <Current>k__BackingField;
    private object System.Collections.IEnumerator.Current { get; }
    internal char LowerBound { get; }
    internal char UpperBound { get; }
    public char Current { get; private set; }
    public CharRangeEnumerator(char lowerBound, char upperBound);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    [CompilerGeneratedAttribute]
internal char get_LowerBound();
    [CompilerGeneratedAttribute]
internal char get_UpperBound();
    [CompilerGeneratedAttribute]
public char get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(char value);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
}
public class System.Management.Automation.ChildItemCmdletProviderIntrinsics : object {
    private Cmdlet _cmdlet;
    private SessionStateInternal _sessionState;
    internal ChildItemCmdletProviderIntrinsics(Cmdlet cmdlet);
    internal ChildItemCmdletProviderIntrinsics(SessionStateInternal sessionState);
    public Collection`1<PSObject> Get(string path, bool recurse);
    public Collection`1<PSObject> Get(String[] path, bool recurse, UInt32 depth, bool force, bool literalPath);
    public Collection`1<PSObject> Get(String[] path, bool recurse, bool force, bool literalPath);
    internal void Get(string path, bool recurse, UInt32 depth, CmdletProviderContext context);
    internal object GetChildItemsDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    public Collection`1<string> GetNames(string path, ReturnContainers returnContainers, bool recurse);
    public Collection`1<string> GetNames(String[] path, ReturnContainers returnContainers, bool recurse, bool force, bool literalPath);
    public Collection`1<string> GetNames(String[] path, ReturnContainers returnContainers, bool recurse, UInt32 depth, bool force, bool literalPath);
    internal void GetNames(string path, ReturnContainers returnContainers, bool recurse, UInt32 depth, CmdletProviderContext context);
    internal object GetChildNamesDynamicParameters(string path, CmdletProviderContext context);
    public bool HasChild(string path);
    public bool HasChild(string path, bool force, bool literalPath);
    internal bool HasChild(string path, CmdletProviderContext context);
}
internal class System.Management.Automation.CimClassDeserializationCache`1 : object {
    private Dictionary`2<TKey, CimClass> _cimClassIdToClass;
    internal void AddCimClassToCache(TKey key, CimClass cimClass);
    internal CimClass GetCimClassFromCache(TKey key);
}
internal class System.Management.Automation.CimClassSerializationCache`1 : object {
    private HashSet`1<TKey> _cimClassesHeldByDeserializer;
    internal bool DoesDeserializerAlreadyHaveCimClass(TKey key);
    internal void AddClassToCache(TKey key);
}
internal class System.Management.Automation.CimClassSerializationId : Tuple`4<string, string, string, int> {
    public string ClassName { get; }
    public string NamespaceName { get; }
    public string ComputerName { get; }
    public int ClassHashCode { get; }
    public CimClassSerializationId(string className, string namespaceName, string computerName, int hashCode);
    public string get_ClassName();
    public string get_NamespaceName();
    public string get_ComputerName();
    public int get_ClassHashCode();
}
internal static class System.Management.Automation.ClrFacade : object {
    private static Encoding modreq(System.Runtime.CompilerServices.IsVolatile) s_oemEncoding;
    internal static IEnumerable`1<string> AvailableDotNetTypeNames { get; }
    internal static HashSet`1<string> AvailableDotNetAssemblyNames { get; }
    private static PowerShellAssemblyLoadContext PSAssemblyLoadContext { get; }
    private static ClrFacade();
    internal static IEnumerable`1<Assembly> GetAssemblies(TypeResolutionState typeResolutionState, TypeName typeName);
    internal static IEnumerable`1<Assembly> GetAssemblies(string namespaceQualifiedTypeName);
    [IteratorStateMachineAttribute("System.Management.Automation.ClrFacade/<GetPSVisibleAssemblies>d__3")]
private static IEnumerable`1<Assembly> GetPSVisibleAssemblies();
    internal static IEnumerable`1<string> get_AvailableDotNetTypeNames();
    internal static HashSet`1<string> get_AvailableDotNetAssemblyNames();
    private static PowerShellAssemblyLoadContext get_PSAssemblyLoadContext();
    internal static Encoding GetOEMEncoding();
    internal static SecurityZone GetFileSecurityZone(string filePath);
    private static SecurityZone MapSecurityZone(string filePath);
    private static SecurityZone ReadFromZoneIdentifierDataStream(string filePath);
    internal static string ToDmtfDateTime(DateTime date);
}
public abstract class System.Management.Automation.Cmdlet : InternalCommand {
    private static Lazy`1<HashSet`1<string>> s_commonParameters;
    private static Lazy`1<HashSet`1<string>> s_optionalCommonParameters;
    private string _parameterSetName;
    public static HashSet`1<string> CommonParameters { get; }
    public static HashSet`1<string> OptionalCommonParameters { get; }
    public bool Stopping { get; }
    internal string _ParameterSetName { get; }
    public ICommandRuntime CommandRuntime { get; public set; }
    public PSTransactionContext CurrentPSTransaction { get; }
    private static Cmdlet();
    public static HashSet`1<string> get_CommonParameters();
    public static HashSet`1<string> get_OptionalCommonParameters();
    public bool get_Stopping();
    internal string get__ParameterSetName();
    internal void SetParameterSetName(string parameterSetName);
    internal virtual void DoBeginProcessing();
    internal virtual void DoProcessRecord();
    internal virtual void DoEndProcessing();
    internal virtual void DoStopProcessing();
    public virtual string GetResourceString(string baseName, string resourceId);
    public ICommandRuntime get_CommandRuntime();
    public void set_CommandRuntime(ICommandRuntime value);
    public void WriteError(ErrorRecord errorRecord);
    public void WriteObject(object sendToPipeline);
    public void WriteObject(object sendToPipeline, bool enumerateCollection);
    public void WriteVerbose(string text);
    public void WriteWarning(string text);
    public void WriteCommandDetail(string text);
    public void WriteProgress(ProgressRecord progressRecord);
    internal void WriteProgress(long sourceId, ProgressRecord progressRecord);
    public void WriteDebug(string text);
    public void WriteInformation(object messageData, String[] tags);
    public void WriteInformation(InformationRecord informationRecord);
    public bool ShouldProcess(string target);
    public bool ShouldProcess(string target, string action);
    public bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    public bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    public bool ShouldContinue(string query, string caption);
    public bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    public bool ShouldContinue(string query, string caption, bool hasSecurityImpact, Boolean& yesToAll, Boolean& noToAll);
    internal List`1<object> GetResults();
    [IteratorStateMachineAttribute("System.Management.Automation.Cmdlet/<Invoke>d__40")]
public IEnumerable Invoke();
    [IteratorStateMachineAttribute("System.Management.Automation.Cmdlet/<Invoke>d__41`1")]
public IEnumerable`1<T> Invoke();
    public bool TransactionAvailable();
    public PSTransactionContext get_CurrentPSTransaction();
    [DoesNotReturnAttribute]
public void ThrowTerminatingError(ErrorRecord errorRecord);
    protected virtual void BeginProcessing();
    protected virtual void ProcessRecord();
    protected virtual void EndProcessing();
    protected virtual void StopProcessing();
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.CmdletAttribute : CmdletCommonMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <NounName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerbName>k__BackingField;
    public string NounName { get; }
    public string VerbName { get; }
    public CmdletAttribute(string verbName, string nounName);
    [CompilerGeneratedAttribute]
public string get_NounName();
    [CompilerGeneratedAttribute]
public string get_VerbName();
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.CmdletBindingAttribute : CmdletCommonMetadataAttribute {
    [CompilerGeneratedAttribute]
private bool <PositionalBinding>k__BackingField;
    public bool PositionalBinding { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_PositionalBinding();
    [CompilerGeneratedAttribute]
public void set_PositionalBinding(bool value);
}
[AttributeUsageAttribute("4")]
public abstract class System.Management.Automation.CmdletCommonMetadataAttribute : CmdletMetadataAttribute {
    [CompilerGeneratedAttribute]
private string <DefaultParameterSetName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsShouldProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsPaging>k__BackingField;
    private bool _supportsTransactions;
    private ConfirmImpact _confirmImpact;
    [CompilerGeneratedAttribute]
private string <HelpUri>k__BackingField;
    [CompilerGeneratedAttribute]
private RemotingCapability <RemotingCapability>k__BackingField;
    public string DefaultParameterSetName { get; public set; }
    public bool SupportsShouldProcess { get; public set; }
    public bool SupportsPaging { get; public set; }
    public bool SupportsTransactions { get; public set; }
    public ConfirmImpact ConfirmImpact { get; public set; }
    public string HelpUri { get; public set; }
    public RemotingCapability RemotingCapability { get; public set; }
    [CompilerGeneratedAttribute]
public string get_DefaultParameterSetName();
    [CompilerGeneratedAttribute]
public void set_DefaultParameterSetName(string value);
    [CompilerGeneratedAttribute]
public bool get_SupportsShouldProcess();
    [CompilerGeneratedAttribute]
public void set_SupportsShouldProcess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsPaging();
    [CompilerGeneratedAttribute]
public void set_SupportsPaging(bool value);
    public bool get_SupportsTransactions();
    public void set_SupportsTransactions(bool value);
    public ConfirmImpact get_ConfirmImpact();
    public void set_ConfirmImpact(ConfirmImpact value);
    [CompilerGeneratedAttribute]
public string get_HelpUri();
    [CompilerGeneratedAttribute]
public void set_HelpUri(string value);
    [CompilerGeneratedAttribute]
public RemotingCapability get_RemotingCapability();
    [CompilerGeneratedAttribute]
public void set_RemotingCapability(RemotingCapability value);
}
public class System.Management.Automation.CmdletInfo : CommandInfo {
    private string _verb;
    private string _noun;
    private string _helpFilePath;
    private PSSnapInInfo _PSSnapin;
    private Version _version;
    private Type _implementingType;
    private List`1<PSTypeName> _outputType;
    private ScopedItemOptions _options;
    private CommandMetadata _cmdletMetadata;
    public string Verb { get; }
    public string Noun { get; }
    public string HelpFile { get; internal set; }
    internal HelpCategory HelpCategory { get; }
    public PSSnapInInfo PSSnapIn { get; }
    internal string PSSnapInName { get; }
    public Version Version { get; }
    public Type ImplementingType { get; }
    public string Definition { get; }
    public string DefaultParameterSet { get; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    public ScopedItemOptions Options { get; public set; }
    internal string FullName { get; }
    internal CommandMetadata CommandMetadata { get; }
    internal bool ImplementsDynamicParameters { get; }
    internal CmdletInfo(string name, Type implementingType, string helpFile, PSSnapInInfo PSSnapin, ExecutionContext context);
    internal CmdletInfo(CmdletInfo other);
    public CmdletInfo(string name, Type implementingType);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] arguments);
    public string get_Verb();
    public string get_Noun();
    internal static bool SplitCmdletName(string name, String& verb, String& noun);
    public string get_HelpFile();
    internal void set_HelpFile(string value);
    internal virtual HelpCategory get_HelpCategory();
    public PSSnapInInfo get_PSSnapIn();
    internal string get_PSSnapInName();
    public virtual Version get_Version();
    public Type get_ImplementingType();
    public virtual string get_Definition();
    public string get_DefaultParameterSet();
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
    public ScopedItemOptions get_Options();
    public void set_Options(ScopedItemOptions value);
    internal void SetOptions(ScopedItemOptions newOptions, bool force);
    private static string GetFullName(string moduleName, string cmdletName);
    private static string GetFullName(CmdletInfo cmdletInfo);
    internal static string GetFullName(PSObject psObject);
    internal string get_FullName();
    internal virtual CommandMetadata get_CommandMetadata();
    internal virtual bool get_ImplementsDynamicParameters();
}
public class System.Management.Automation.CmdletInvocationException : RuntimeException {
    private ErrorRecord _errorRecord;
    public ErrorRecord ErrorRecord { get; }
    internal CmdletInvocationException(ErrorRecord errorRecord);
    internal CmdletInvocationException(Exception innerException, InvocationInfo invocationInfo);
    public CmdletInvocationException(string message);
    public CmdletInvocationException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CmdletInvocationException(SerializationInfo info, StreamingContext context);
    public virtual ErrorRecord get_ErrorRecord();
}
internal class System.Management.Automation.CmdletParameterBinderController : ParameterBinderController {
    [TraceSourceAttribute("ParameterBinderController", "Controls the interaction between the command processor and the parameter binder(s).")]
private static PSTraceSource s_tracer;
    [CompilerGeneratedAttribute]
private IDictionary <DefaultParameterValues>k__BackingField;
    [CompilerGeneratedAttribute]
private Cmdlet <Command>k__BackingField;
    private static string Separator;
    private List`1<string> _aliasList;
    private HashSet`1<string> _warningSet;
    private Dictionary`2<MergedCompiledCommandParameter, object> _allDefaultParameterValuePairs;
    private bool _useDefaultParameterBinding;
    private UInt32 _parameterSetToBePrioritizedInPipelineBinding;
    private CommandMetadata _commandMetadata;
    private MshCommandRuntime _commandRuntime;
    [CompilerGeneratedAttribute]
private List`1<WarningRecord> <ObsoleteParameterWarningList>k__BackingField;
    private HashSet`1<string> _boundObsoleteParameterNames;
    private ParameterBinderBase _dynamicParameterBinder;
    private ReflectionParameterBinder _shouldProcessParameterBinder;
    private ReflectionParameterBinder _pagingParameterBinder;
    private ReflectionParameterBinder _transactionParameterBinder;
    private ReflectionParameterBinder _commonParametersBinder;
    private Dictionary`2<MergedCompiledCommandParameter, DelayedScriptBlockArgument> _delayBindScriptBlocks;
    private Dictionary`2<string, CommandParameterInternal> _defaultParameterValues;
    internal IDictionary DefaultParameterValues { get; internal set; }
    internal string CurrentParameterSetName { get; }
    internal Cmdlet Command { get; }
    internal List`1<WarningRecord> ObsoleteParameterWarningList { get; private set; }
    private HashSet`1<string> BoundObsoleteParameterNames { get; }
    internal ReflectionParameterBinder ShouldProcessParametersBinder { get; }
    internal ReflectionParameterBinder PagingParametersBinder { get; }
    internal ReflectionParameterBinder TransactionParametersBinder { get; }
    internal ReflectionParameterBinder CommonParametersBinder { get; }
    internal CmdletParameterBinderController(Cmdlet cmdlet, CommandMetadata commandMetadata, ParameterBinderBase parameterBinder);
    private static CmdletParameterBinderController();
    internal void BindCommandLineParameters(Collection`1<CommandParameterInternal> arguments);
    internal void BindCommandLineParametersNoValidation(Collection`1<CommandParameterInternal> arguments);
    private UInt32 FilterParameterSetsTakingNoPipelineInput();
    private void ApplyDefaultParameterBinding(string bindingStage, bool isDynamic);
    private bool BindDefaultParameters(UInt32 validParameterSetFlag, Dictionary`2<MergedCompiledCommandParameter, object> defaultParameterValues);
    private PSObject WrapBindingState();
    private Dictionary`2<MergedCompiledCommandParameter, object> GetQualifiedParameterValuePairs(UInt32 currentParameterSetFlag, Dictionary`2<MergedCompiledCommandParameter, object> availableParameterValuePairs);
    private List`1<string> GetAliasOfCurrentCmdlet();
    private bool MatchAnyAlias(string aliasName);
    [CompilerGeneratedAttribute]
internal IDictionary get_DefaultParameterValues();
    [CompilerGeneratedAttribute]
internal void set_DefaultParameterValues(IDictionary value);
    private Dictionary`2<MergedCompiledCommandParameter, object> GetDefaultParameterValuePairs(bool needToGetAlias);
    private void GetDefaultParameterValuePairsHelper(string cmdletName, string paramName, object paramValue, IDictionary`2<string, MergedCompiledCommandParameter> bindableParameters, IDictionary`2<string, MergedCompiledCommandParameter> bindableAlias, Dictionary`2<MergedCompiledCommandParameter, object> result, HashSet`1<MergedCompiledCommandParameter> parametersToRemove);
    private void VerifyArgumentsProcessed(ParameterBindingException originalBindingException);
    private void VerifyParameterSetSelected();
    private bool RestoreParameter(CommandParameterInternal argumentToBind, MergedCompiledCommandParameter parameter);
    protected virtual void BindNamedParameter(UInt32 parameterSets, CommandParameterInternal argument, MergedCompiledCommandParameter parameter);
    private static bool IsParameterScriptBlockBindable(MergedCompiledCommandParameter parameter);
    internal virtual bool BindParameter(UInt32 parameterSets, CommandParameterInternal argument, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    private bool BindParameter(CommandParameterInternal argument, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    private void HandleRemainingArguments();
    private void HandleCommandLineDynamicParameters(ParameterBindingException& outgoingBindingException);
    private Collection`1<MergedCompiledCommandParameter> GetMissingMandatoryParameters(int validParameterSetCount, bool isPipelineInputExpected);
    private void PreservePotentialParameterSets(UInt32 chosenMandatorySet, UInt32 otherMandatorySetsToBeIgnored, bool chosenSetContainsNonpipelineableMandatoryParameters);
    private void IgnoreOtherMandatoryParameterSets(UInt32 otherMandatorySetsToBeIgnored);
    private static UInt32 NewParameterSetPromptingData(Dictionary`2<UInt32, ParameterSetPromptingData> promptingData, MergedCompiledCommandParameter parameter, ParameterSetSpecificMetadata parameterSetMetadata, UInt32 defaultParameterSet, bool pipelineInputExpected);
    private int ValidateParameterSets(bool prePipelineInput, bool setDefault);
    private int ResolveParameterSetAmbiguityBasedOnMandatoryParameters();
    internal static int ResolveParameterSetAmbiguityBasedOnMandatoryParameters(Dictionary`2<string, MergedCompiledCommandParameter> boundParameters, ICollection`1<MergedCompiledCommandParameter> unboundParameters, MergedCommandParameterMetadata bindableParameters, UInt32& _currentParameterSetFlag, Cmdlet command);
    private void ThrowAmbiguousParameterSetException(UInt32 parameterSetFlags, MergedCommandParameterMetadata bindableParameters);
    private bool AtLeastOneUnboundValidParameterSetTakesPipelineInput(UInt32 validParameterSetFlags);
    internal bool HandleUnboundMandatoryParameters(Collection`1& missingMandatoryParameters);
    internal bool HandleUnboundMandatoryParameters(int validParameterSetCount, bool processMissingMandatory, bool promptForMandatory, bool isPipelineInputExpected, Collection`1& missingMandatoryParameters);
    private Dictionary`2<string, PSObject> PromptForMissingMandatoryParameters(Collection`1<FieldDescription> fieldDescriptionList, Collection`1<MergedCompiledCommandParameter> missingMandatoryParameters);
    internal static string BuildMissingParamsString(Collection`1<MergedCompiledCommandParameter> missingMandatoryParameters);
    private Collection`1<FieldDescription> CreatePromptDataStructures(Collection`1<MergedCompiledCommandParameter> missingMandatoryParameters);
    private static string BuildLabel(string parameterName, StringBuilder usedHotKeys);
    internal string get_CurrentParameterSetName();
    internal bool BindPipelineParameters(PSObject inputToOperateOn);
    private bool BindPipelineParametersPrivate(PSObject inputToOperateOn);
    private bool BindUnboundParametersForBindingState(PSObject inputToOperateOn, CurrentlyBinding currentlyBinding, UInt32 validParameterSets);
    private bool BindUnboundParametersForBindingStateInParameterSet(PSObject inputToOperateOn, CurrentlyBinding currentlyBinding, UInt32 validParameterSets);
    private bool BindValueFromPipeline(PSObject inputToOperateOn, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    private bool BindValueFromPipelineByPropertyName(PSObject inputToOperateOn, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    private bool InvokeAndBindDelayBindScriptBlock(PSObject inputToOperateOn, Boolean& thereWasSomethingToBind);
    private static int ValidParameterSetCount(UInt32 parameterSetFlags);
    internal object GetDefaultParameterValue(string name);
    [CompilerGeneratedAttribute]
internal Cmdlet get_Command();
    [CompilerGeneratedAttribute]
internal List`1<WarningRecord> get_ObsoleteParameterWarningList();
    [CompilerGeneratedAttribute]
private void set_ObsoleteParameterWarningList(List`1<WarningRecord> value);
    private HashSet`1<string> get_BoundObsoleteParameterNames();
    internal ReflectionParameterBinder get_ShouldProcessParametersBinder();
    internal ReflectionParameterBinder get_PagingParametersBinder();
    internal ReflectionParameterBinder get_TransactionParametersBinder();
    internal ReflectionParameterBinder get_CommonParametersBinder();
    private bool BindPipelineParameter(object parameterValue, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    protected virtual void SaveDefaultScriptParameterValue(string name, object value);
    private void BackupDefaultParameter(MergedCompiledCommandParameter parameter);
    private void RestoreDefaultParameterValues(IEnumerable`1<MergedCompiledCommandParameter> parameters);
}
internal class System.Management.Automation.CmdletProviderContext : object {
    [TraceSourceAttribute("CmdletProviderContext", "The context under which a core command is being run.")]
private static PSTraceSource s_tracer;
    private CmdletProviderContext _copiedContext;
    private PSCredential _credentials;
    private bool _force;
    private Cmdlet _command;
    [CompilerGeneratedAttribute]
private CommandOrigin <Origin>k__BackingField;
    private bool _streamErrors;
    private Collection`1<PSObject> _accumulatedObjects;
    private Collection`1<ErrorRecord> _accumulatedErrorObjects;
    private CmdletProvider _providerInstance;
    [CompilerGeneratedAttribute]
private ExecutionContext <ExecutionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DynamicParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PassThru>k__BackingField;
    [CompilerGeneratedAttribute]
private PSDriveInfo <Drive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Filter>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <Include>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <Exclude>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressWildcardExpansion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Stopping>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CmdletProviderContext> <StopReferrals>k__BackingField;
    internal CommandOrigin Origin { get; }
    internal ExecutionContext ExecutionContext { get; }
    internal CmdletProvider ProviderInstance { get; internal set; }
    internal object DynamicParameters { get; internal set; }
    internal InvocationInfo MyInvocation { get; }
    internal bool PassThru { get; internal set; }
    internal PSDriveInfo Drive { get; internal set; }
    internal PSCredential Credential { get; }
    internal bool UseTransaction { get; }
    public PSTransactionContext CurrentPSTransaction { get; }
    internal SwitchParameter Force { get; internal set; }
    internal string Filter { get; internal set; }
    internal Collection`1<string> Include { get; private set; }
    internal Collection`1<string> Exclude { get; private set; }
    public bool SuppressWildcardExpansion { get; internal set; }
    internal bool Stopping { get; private set; }
    internal Collection`1<CmdletProviderContext> StopReferrals { get; }
    internal bool HasIncludeOrExclude { get; }
    internal CmdletProviderContext(ExecutionContext executionContext);
    internal CmdletProviderContext(ExecutionContext executionContext, CommandOrigin origin);
    internal CmdletProviderContext(PSCmdlet command, PSCredential credentials, PSDriveInfo drive);
    internal CmdletProviderContext(PSCmdlet command, PSCredential credentials);
    internal CmdletProviderContext(Cmdlet command);
    internal CmdletProviderContext(CmdletProviderContext contextToCopyFrom);
    private static CmdletProviderContext();
    [CompilerGeneratedAttribute]
internal CommandOrigin get_Origin();
    [CompilerGeneratedAttribute]
internal ExecutionContext get_ExecutionContext();
    internal CmdletProvider get_ProviderInstance();
    internal void set_ProviderInstance(CmdletProvider value);
    private void CopyFilters(CmdletProviderContext context);
    internal void RemoveStopReferral();
    [CompilerGeneratedAttribute]
internal object get_DynamicParameters();
    [CompilerGeneratedAttribute]
internal void set_DynamicParameters(object value);
    internal InvocationInfo get_MyInvocation();
    [CompilerGeneratedAttribute]
internal bool get_PassThru();
    [CompilerGeneratedAttribute]
internal void set_PassThru(bool value);
    [CompilerGeneratedAttribute]
internal PSDriveInfo get_Drive();
    [CompilerGeneratedAttribute]
internal void set_Drive(PSDriveInfo value);
    internal PSCredential get_Credential();
    internal bool get_UseTransaction();
    public bool TransactionAvailable();
    public PSTransactionContext get_CurrentPSTransaction();
    internal SwitchParameter get_Force();
    internal void set_Force(SwitchParameter value);
    [CompilerGeneratedAttribute]
internal string get_Filter();
    [CompilerGeneratedAttribute]
internal void set_Filter(string value);
    [CompilerGeneratedAttribute]
internal Collection`1<string> get_Include();
    [CompilerGeneratedAttribute]
private void set_Include(Collection`1<string> value);
    [CompilerGeneratedAttribute]
internal Collection`1<string> get_Exclude();
    [CompilerGeneratedAttribute]
private void set_Exclude(Collection`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_SuppressWildcardExpansion();
    [CompilerGeneratedAttribute]
internal void set_SuppressWildcardExpansion(bool value);
    internal bool ShouldProcess(string target);
    internal bool ShouldProcess(string target, string action);
    internal bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    internal bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    internal bool ShouldContinue(string query, string caption);
    internal bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    internal void WriteVerbose(string text);
    internal void WriteWarning(string text);
    internal void WriteProgress(ProgressRecord record);
    internal void WriteDebug(string text);
    internal void WriteInformation(InformationRecord record);
    internal void WriteInformation(object messageData, String[] tags);
    internal void SetFilters(Collection`1<string> include, Collection`1<string> exclude, string filter);
    internal Collection`1<PSObject> GetAccumulatedObjects();
    internal Collection`1<ErrorRecord> GetAccumulatedErrorObjects();
    internal void ThrowFirstErrorOrDoNothing();
    internal void ThrowFirstErrorOrDoNothing(bool wrapExceptionInProviderException);
    internal void WriteErrorsToContext(CmdletProviderContext errorContext);
    internal void WriteObject(object obj);
    internal void WriteError(ErrorRecord errorRecord);
    internal bool HasErrors();
    internal void StopProcessing();
    [CompilerGeneratedAttribute]
internal bool get_Stopping();
    [CompilerGeneratedAttribute]
private void set_Stopping(bool value);
    [CompilerGeneratedAttribute]
internal Collection`1<CmdletProviderContext> get_StopReferrals();
    internal bool get_HasIncludeOrExclude();
}
public class System.Management.Automation.CmdletProviderInvocationException : CmdletInvocationException {
    private ProviderInvocationException _providerInvocationException;
    public ProviderInvocationException ProviderInvocationException { get; }
    public ProviderInfo ProviderInfo { get; }
    internal CmdletProviderInvocationException(ProviderInvocationException innerException, InvocationInfo myInvocation);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CmdletProviderInvocationException(SerializationInfo info, StreamingContext context);
    public CmdletProviderInvocationException(string message);
    public CmdletProviderInvocationException(string message, Exception innerException);
    public ProviderInvocationException get_ProviderInvocationException();
    public ProviderInfo get_ProviderInfo();
    private static Exception GetInnerException(Exception e);
}
public class System.Management.Automation.CmdletProviderManagementIntrinsics : object {
    private SessionStateInternal _sessionState;
    internal int Count { get; }
    internal CmdletProviderManagementIntrinsics(SessionStateInternal sessionState);
    public Collection`1<ProviderInfo> Get(string name);
    public ProviderInfo GetOne(string name);
    public IEnumerable`1<ProviderInfo> GetAll();
    internal static bool CheckProviderCapabilities(ProviderCapabilities capability, ProviderInfo provider);
    internal int get_Count();
}
public class System.Management.Automation.CmsMessageRecipient : object {
    private string _identifier;
    private X509Certificate2 _pendingCertificate;
    [CompilerGeneratedAttribute]
private X509Certificate2Collection <Certificates>k__BackingField;
    public X509Certificate2Collection Certificates { get; internal set; }
    public CmsMessageRecipient(string identifier);
    public CmsMessageRecipient(X509Certificate2 certificate);
    [CompilerGeneratedAttribute]
public X509Certificate2Collection get_Certificates();
    [CompilerGeneratedAttribute]
internal void set_Certificates(X509Certificate2Collection value);
    public void Resolve(SessionState sessionState, ResolutionPurpose purpose, ErrorRecord& error);
    private void ResolveFromBase64Encoding(ResolutionPurpose purpose, ErrorRecord& error);
    private void ResolveFromPath(SessionState sessionState, ResolutionPurpose purpose, ErrorRecord& error);
    private void ResolveFromStoreById(ResolutionPurpose purpose, ErrorRecord& error);
    private void ProcessResolvedCertificates(ResolutionPurpose purpose, X509Certificate2Collection certificatesToProcess, ErrorRecord& error);
}
internal static class System.Management.Automation.CmsUtils : object {
    internal static string BEGIN_CMS_SIGIL;
    internal static string END_CMS_SIGIL;
    internal static string BEGIN_CERTIFICATE_SIGIL;
    internal static string END_CERTIFICATE_SIGIL;
    private static CmsUtils();
    internal static string Encrypt(Byte[] contentBytes, CmsMessageRecipient[] recipients, SessionState sessionState, ErrorRecord& error);
    internal static string GetAsciiArmor(Byte[] bytes);
    internal static Byte[] RemoveAsciiArmor(string actualContent, string beginMarker, string endMarker, Int32& startIndex, Int32& endIndex);
}
internal class System.Management.Automation.CollectionEntry`1 : object {
    [CompilerGeneratedAttribute]
private GetMembersDelegate<T> <GetMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private GetMemberDelegate<T> <GetMember>k__BackingField;
    [CompilerGeneratedAttribute]
private GetFirstOrDefaultDelegate<T> <GetFirstOrDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CollectionNameForTracing>k__BackingField;
    private bool _shouldReplicateWhenReturning;
    private bool _shouldCloneWhenReturning;
    internal GetMembersDelegate<T> GetMembers { get; }
    internal GetMemberDelegate<T> GetMember { get; }
    internal GetFirstOrDefaultDelegate<T> GetFirstOrDefault { get; }
    internal string CollectionNameForTracing { get; }
    internal CollectionEntry`1(GetMembersDelegate<T> getMembers, GetMemberDelegate<T> getMember, GetFirstOrDefaultDelegate<T> getFirstOrDefault, bool shouldReplicateWhenReturning, bool shouldCloneWhenReturning, string collectionNameForTracing);
    [CompilerGeneratedAttribute]
internal GetMembersDelegate<T> get_GetMembers();
    [CompilerGeneratedAttribute]
internal GetMemberDelegate<T> get_GetMember();
    [CompilerGeneratedAttribute]
internal GetFirstOrDefaultDelegate<T> get_GetFirstOrDefault();
    [CompilerGeneratedAttribute]
internal string get_CollectionNameForTracing();
    internal T CloneOrReplicateObject(object owner, T member);
}
internal class System.Management.Automation.ComAdapter : Adapter {
    private ComTypeInfo _comTypeInfo;
    internal ComAdapter(ComTypeInfo typeinfo);
    internal static string GetComTypeName(string clsid);
    [IteratorStateMachineAttribute("System.Management.Automation.ComAdapter/<GetTypeNameHierarchy>d__3")]
protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected virtual AttributeCollection PropertyAttributes(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual string PropertyToString(PSProperty property);
    protected virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected virtual Collection`1<string> MethodDefinitions(PSMethod method);
    protected virtual string ParameterizedPropertyType(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsSettable(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsGettable(PSParameterizedProperty property);
    protected virtual object ParameterizedPropertyGet(PSParameterizedProperty property, Object[] arguments);
    protected virtual void ParameterizedPropertySet(PSParameterizedProperty property, object setValue, Object[] arguments);
    protected virtual string ParameterizedPropertyToString(PSParameterizedProperty property);
    protected virtual Collection`1<string> ParameterizedPropertyDefinitions(PSParameterizedProperty property);
}
internal abstract class System.Management.Automation.ComInterop.ArgBuilder : object {
    internal abstract virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class System.Management.Automation.ComInterop.BoolArgBuilder : SimpleArgBuilder {
    internal BoolArgBuilder(Type parameterType);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.BoundDispEvent : DynamicObject {
    private object _rcw;
    private Guid _sourceIid;
    private int _dispid;
    internal BoundDispEvent(object rcw, Guid sourceIid, int dispid);
    public virtual bool TryBinaryOperation(BinaryOperationBinder binder, object handler, Object& result);
    private static void VerifyHandler(object handler);
    private object InPlaceAdd(object handler);
    private object InPlaceSubtract(object handler);
}
[ExtensionAttribute]
internal static class System.Management.Automation.ComInterop.CollectionExtensions : object {
    [ExtensionAttribute]
internal static T[] RemoveFirst(T[] array);
    [ExtensionAttribute]
internal static T[] AddFirst(IList`1<T> list, T item);
    [ExtensionAttribute]
internal static T[] ToArray(IList`1<T> list);
    [ExtensionAttribute]
internal static T[] AddLast(IList`1<T> list, T item);
}
internal static class System.Management.Automation.ComInterop.ComBinder : object {
    public static bool IsComObject(object value);
    public static bool TryBindGetMember(GetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject& result, bool delayInvocation);
    public static bool TryBindSetMember(SetMemberBinder binder, DynamicMetaObject instance, DynamicMetaObject value, DynamicMetaObject& result);
    public static bool TryBindInvoke(InvokeBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindInvokeMember(InvokeMemberBinder binder, bool isSetProperty, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindGetIndex(GetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject& result);
    public static bool TryBindSetIndex(SetIndexBinder binder, DynamicMetaObject instance, DynamicMetaObject[] args, DynamicMetaObject value, DynamicMetaObject& result);
    public static bool TryConvert(ConvertBinder binder, DynamicMetaObject instance, DynamicMetaObject& result);
    internal static IList`1<string> GetDynamicDataMemberNames(object value);
    internal static IList`1<KeyValuePair`2<string, object>> GetDynamicDataMembers(object value, IEnumerable`1<string> names);
    private static bool TryGetMetaObject(DynamicMetaObject& instance);
    private static bool TryGetMetaObjectInvoke(DynamicMetaObject& instance);
}
internal static class System.Management.Automation.ComInterop.ComBinderHelpers : object {
    internal static bool PreferPut(Type type, bool holdsNull);
    internal static bool IsByRef(DynamicMetaObject mo);
    internal static bool IsPSReferenceArg(DynamicMetaObject o);
    internal static Boolean[] ProcessArgumentsForCom(ComMethodDesc method, DynamicMetaObject[]& args, List`1<ParameterExpression> temps, List`1<Expression> initTemps);
    internal static BindingRestrictions GetTypeRestrictionForDynamicMetaObject(DynamicMetaObject obj);
}
internal class System.Management.Automation.ComInterop.ComClassMetaObject : DynamicMetaObject {
    internal ComClassMetaObject(Expression expression, ComTypeClassDesc cls);
    public virtual DynamicMetaObject BindCreateInstance(CreateInstanceBinder binder, DynamicMetaObject[] args);
}
internal static class System.Management.Automation.ComInterop.ComDispIds : object {
    internal static int DISPID_VALUE;
    internal static int DISPID_PROPERTYPUT;
    internal static int DISPID_NEWENUM;
}
internal class System.Management.Automation.ComInterop.ComEventDesc : object {
    public Guid SourceIID;
    public int Dispid;
}
internal class System.Management.Automation.ComInterop.ComEventSinksContainer : List`1<ComEventsSink> {
    private static object s_comObjectEventSinksKey;
    private static ComEventSinksContainer();
    public static ComEventSinksContainer FromRuntimeCallableWrapper(object rcw, bool createIfNotFound);
    public sealed virtual void Dispose();
    private void DisposeAll();
    protected virtual override void Finalize();
}
internal class System.Management.Automation.ComInterop.ComFallbackMetaObject : DynamicMetaObject {
    internal ComFallbackMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
internal static class System.Management.Automation.ComInterop.ComHresults : object {
    internal static int S_OK;
    internal static int DISP_E_UNKNOWNINTERFACE;
    internal static int DISP_E_MEMBERNOTFOUND;
    internal static int DISP_E_PARAMNOTFOUND;
    internal static int DISP_E_TYPEMISMATCH;
    internal static int DISP_E_UNKNOWNNAME;
    internal static int DISP_E_NONAMEDARGS;
    internal static int DISP_E_BADVARTYPE;
    internal static int DISP_E_EXCEPTION;
    internal static int DISP_E_OVERFLOW;
    internal static int DISP_E_BADINDEX;
    internal static int DISP_E_UNKNOWNLCID;
    internal static int DISP_E_ARRAYISLOCKED;
    internal static int DISP_E_BADPARAMCOUNT;
    internal static int DISP_E_PARAMNOTOPTIONAL;
    internal static int E_NOTIMPL;
    internal static int E_NOINTERFACE;
    internal static int E_FAIL;
    internal static int TYPE_E_LIBNOTREGISTERED;
    internal static bool IsSuccess(int hresult);
}
internal class System.Management.Automation.ComInterop.ComInvokeAction : InvokeBinder {
    internal ComInvokeAction(CallInfo callInfo);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.ComInterop.ComInvokeBinder : object {
    private ComMethodDesc _methodDesc;
    private Expression _method;
    private Expression _dispatch;
    private CallInfo _callInfo;
    private DynamicMetaObject[] _args;
    private Boolean[] _isByRef;
    private Expression _instance;
    private BindingRestrictions _restrictions;
    private VarEnumSelector _varEnumSelector;
    private String[] _keywordArgNames;
    private int _totalExplicitArgs;
    private ParameterExpression _dispatchObject;
    private ParameterExpression _dispatchPointer;
    private ParameterExpression _dispId;
    private ParameterExpression _dispParams;
    private ParameterExpression _paramVariants;
    private ParameterExpression _invokeResult;
    private ParameterExpression _returnValue;
    private ParameterExpression _dispIdsOfKeywordArgsPinned;
    private ParameterExpression _propertyPutDispId;
    private ParameterExpression DispatchObjectVariable { get; }
    private ParameterExpression DispatchPointerVariable { get; }
    private ParameterExpression DispIdVariable { get; }
    private ParameterExpression DispParamsVariable { get; }
    private ParameterExpression InvokeResultVariable { get; }
    private ParameterExpression ReturnValueVariable { get; }
    private ParameterExpression DispIdsOfKeywordArgsPinnedVariable { get; }
    private ParameterExpression PropertyPutDispIdVariable { get; }
    private ParameterExpression ParamVariantsVariable { get; }
    internal ComInvokeBinder(CallInfo callInfo, DynamicMetaObject[] args, Boolean[] isByRef, BindingRestrictions restrictions, Expression method, Expression dispatch, ComMethodDesc methodDesc);
    private ParameterExpression get_DispatchObjectVariable();
    private ParameterExpression get_DispatchPointerVariable();
    private ParameterExpression get_DispIdVariable();
    private ParameterExpression get_DispParamsVariable();
    private ParameterExpression get_InvokeResultVariable();
    private ParameterExpression get_ReturnValueVariable();
    private ParameterExpression get_DispIdsOfKeywordArgsPinnedVariable();
    private ParameterExpression get_PropertyPutDispIdVariable();
    private ParameterExpression get_ParamVariantsVariable();
    private static ParameterExpression EnsureVariable(ParameterExpression& var, Type type, string name);
    private static Type MarshalType(DynamicMetaObject mo, bool isByRef);
    internal DynamicMetaObject Invoke();
    private static void AddNotNull(List`1<ParameterExpression> list, ParameterExpression var);
    private Expression CreateScope(Expression expression);
    private Expression GenerateTryBlock();
    private Expression GenerateFinallyBlock();
    private Expression MakeIDispatchInvokeTarget();
    private Expression[] MakeArgumentExpressions();
}
internal class System.Management.Automation.ComInterop.ComMetaObject : DynamicMetaObject {
    internal ComMetaObject(Expression expression, BindingRestrictions restrictions, object arg);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    private DynamicMetaObject WrapSelf();
}
internal class System.Management.Automation.ComInterop.ComMethodDesc : object {
    internal INVOKEKIND InvokeKind;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DispId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParamCount>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <InputType>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterInformation[] <ParameterInformation>k__BackingField;
    public string Name { get; }
    public int DispId { get; }
    public bool IsPropertyGet { get; }
    public bool IsDataMember { get; }
    public bool IsPropertyPut { get; }
    public bool IsPropertyPutRef { get; }
    internal int ParamCount { get; }
    public Type ReturnType { get; public set; }
    public Type InputType { get; public set; }
    public ParameterInformation[] ParameterInformation { get; public set; }
    private ComMethodDesc(int dispId);
    internal ComMethodDesc(string name, int dispId);
    internal ComMethodDesc(string name, int dispId, INVOKEKIND invkind);
    internal ComMethodDesc(ITypeInfo typeInfo, FUNCDESC funcDesc);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_DispId();
    public bool get_IsPropertyGet();
    public bool get_IsDataMember();
    public bool get_IsPropertyPut();
    public bool get_IsPropertyPutRef();
    [CompilerGeneratedAttribute]
internal int get_ParamCount();
    [CompilerGeneratedAttribute]
public Type get_ReturnType();
    [CompilerGeneratedAttribute]
public void set_ReturnType(Type value);
    [CompilerGeneratedAttribute]
public Type get_InputType();
    [CompilerGeneratedAttribute]
public void set_InputType(Type value);
    [CompilerGeneratedAttribute]
public ParameterInformation[] get_ParameterInformation();
    [CompilerGeneratedAttribute]
public void set_ParameterInformation(ParameterInformation[] value);
}
internal class System.Management.Automation.ComInterop.ComObject : object {
    [CompilerGeneratedAttribute]
private object <RuntimeCallableWrapper>k__BackingField;
    private static object s_comObjectInfoKey;
    internal object RuntimeCallableWrapper { get; }
    internal ComObject(object rcw);
    private static ComObject();
    [CompilerGeneratedAttribute]
internal object get_RuntimeCallableWrapper();
    public static ComObject ObjectToComObject(object rcw);
    internal static MemberExpression RcwFromComObject(Expression comObject);
    internal static MethodCallExpression RcwToComObject(Expression rcw);
    private static ComObject CreateComObject(object rcw);
    internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
}
internal static class System.Management.Automation.ComInterop.ComRuntimeHelpers : object {
    public static void CheckThrowException(int hresult, ExcepInfo& excepInfo, ComMethodDesc method, Object[] args, UInt32 argErr);
    private static void ThrowWrappedInvocationException(ComMethodDesc method, Exception parameterException);
    internal static void GetInfoFromType(ITypeInfo typeInfo, String& name, String& documentation);
    internal static string GetNameOfMethod(ITypeInfo typeInfo, int memid);
    internal static string GetNameOfLib(ITypeLib typeLib);
    internal static string GetNameOfType(ITypeInfo typeInfo);
    internal static ITypeInfo GetITypeInfoFromIDispatch(IDispatch dispatch);
    internal static TYPEATTR GetTypeAttrForTypeInfo(ITypeInfo typeInfo);
    internal static TYPELIBATTR GetTypeAttrForTypeLib(ITypeLib typeLib);
    public static BoundDispEvent CreateComEvent(object rcw, Guid sourceIid, int dispid);
    public static DispCallable CreateDispCallable(IDispatchComObject dispatch, ComMethodDesc method);
}
internal class System.Management.Automation.ComInterop.ComTypeClassDesc : ComTypeDesc {
    private LinkedList`1<string> _itfs;
    private LinkedList`1<string> _sourceItfs;
    private Type _typeObj;
    internal ComTypeClassDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    public object CreateInstance();
    private void AddInterface(ITypeInfo itfTypeInfo, bool isSourceItf);
    internal bool Implements(string itfName, bool isSourceItf);
    public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
}
internal class System.Management.Automation.ComInterop.ComTypeDesc : object {
    private string _typeName;
    private string _documentation;
    private ComMethodDesc _getItem;
    private ComMethodDesc _setItem;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, ComEventDesc> <EmptyEvents>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Funcs>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Puts>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <PutRefs>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ComEventDesc> <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private ComTypeLibDesc <TypeLib>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    internal static Dictionary`2<string, ComEventDesc> EmptyEvents { get; }
    internal Hashtable Funcs { get; internal set; }
    internal Hashtable Puts { get; internal set; }
    internal Hashtable PutRefs { get; internal set; }
    internal Dictionary`2<string, ComEventDesc> Events { get; internal set; }
    public string TypeName { get; }
    internal string Documentation { get; }
    public ComTypeLibDesc TypeLib { get; }
    internal Guid Guid { get; internal set; }
    internal ComMethodDesc GetItem { get; }
    internal ComMethodDesc SetItem { get; }
    internal ComTypeDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    private static ComTypeDesc();
    internal static ComTypeDesc FromITypeInfo(ITypeInfo typeInfo, TYPEATTR typeAttr);
    internal static ComTypeDesc CreateEmptyTypeDesc();
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, ComEventDesc> get_EmptyEvents();
    [CompilerGeneratedAttribute]
internal Hashtable get_Funcs();
    [CompilerGeneratedAttribute]
internal void set_Funcs(Hashtable value);
    [CompilerGeneratedAttribute]
internal Hashtable get_Puts();
    [CompilerGeneratedAttribute]
internal void set_Puts(Hashtable value);
    [CompilerGeneratedAttribute]
internal Hashtable get_PutRefs();
    [CompilerGeneratedAttribute]
internal void set_PutRefs(Hashtable value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ComEventDesc> get_Events();
    [CompilerGeneratedAttribute]
internal void set_Events(Dictionary`2<string, ComEventDesc> value);
    internal bool TryGetFunc(string name, ComMethodDesc& method);
    internal void AddFunc(string name, ComMethodDesc method);
    internal bool TryGetPut(string name, ComMethodDesc& method);
    internal void AddPut(string name, ComMethodDesc method);
    internal bool TryGetPutRef(string name, ComMethodDesc& method);
    internal void AddPutRef(string name, ComMethodDesc method);
    internal bool TryGetEvent(string name, ComEventDesc& event);
    internal String[] GetMemberNames(bool dataOnly);
    public string get_TypeName();
    internal string get_Documentation();
    [CompilerGeneratedAttribute]
public ComTypeLibDesc get_TypeLib();
    [CompilerGeneratedAttribute]
internal Guid get_Guid();
    [CompilerGeneratedAttribute]
internal void set_Guid(Guid value);
    internal ComMethodDesc get_GetItem();
    internal void EnsureGetItem(ComMethodDesc candidate);
    internal ComMethodDesc get_SetItem();
    internal void EnsureSetItem(ComMethodDesc candidate);
}
internal class System.Management.Automation.ComInterop.ComTypeEnumDesc : ComTypeDesc {
    private String[] _memberNames;
    private Object[] _memberValues;
    internal ComTypeEnumDesc(ITypeInfo typeInfo, ComTypeLibDesc typeLibDesc);
    public virtual string ToString();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    public object GetValue(string enumValueName);
    internal bool HasMember(string name);
    public String[] GetMemberNames();
}
internal class System.Management.Automation.ComInterop.ComTypeLibDesc : object {
    private LinkedList`1<ComTypeClassDesc> _classes;
    private Dictionary`2<string, ComTypeEnumDesc> _enums;
    private TYPELIBATTR _typeLibAttributes;
    private static Dictionary`2<Guid, ComTypeLibDesc> s_cachedTypeLibDesc;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Documentation { get; }
    public Guid Guid { get; }
    public string Name { get; private set; }
    private static ComTypeLibDesc();
    public virtual string ToString();
    public string get_Documentation();
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    internal static ComTypeLibDesc GetFromTypeLib(ITypeLib typeLib);
    public object GetTypeLibObjectDesc(string member);
    public String[] GetMemberNames();
    internal bool HasMember(string member);
    public Guid get_Guid();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    internal ComTypeClassDesc GetCoClassForInterface(string itfName);
}
internal class System.Management.Automation.ComInterop.ComUnwrappedMetaObject : DynamicMetaObject {
    internal ComUnwrappedMetaObject(Expression expression, BindingRestrictions restrictions, object value);
}
internal class System.Management.Automation.ComInterop.ConversionArgBuilder : ArgBuilder {
    private SimpleArgBuilder _innerBuilder;
    private Type _parameterType;
    internal ConversionArgBuilder(Type parameterType, SimpleArgBuilder innerBuilder);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
}
internal class System.Management.Automation.ComInterop.ConvertArgBuilder : SimpleArgBuilder {
    private Type _marshalType;
    internal ConvertArgBuilder(Type parameterType, Type marshalType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class System.Management.Automation.ComInterop.ConvertibleArgBuilder : ArgBuilder {
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
}
internal class System.Management.Automation.ComInterop.CurrencyArgBuilder : SimpleArgBuilder {
    internal CurrencyArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.DateTimeArgBuilder : SimpleArgBuilder {
    internal DateTimeArgBuilder(Type parameterType);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.DispatchArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal DispatchArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.DispCallable : object {
    [CompilerGeneratedAttribute]
private IDispatchComObject <DispatchComObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <DispId>k__BackingField;
    public IDispatchComObject DispatchComObject { get; }
    public IDispatch DispatchObject { get; }
    public string MemberName { get; }
    public int DispId { get; }
    internal DispCallable(IDispatchComObject dispatch, string memberName, int dispId);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public IDispatchComObject get_DispatchComObject();
    public IDispatch get_DispatchObject();
    [CompilerGeneratedAttribute]
public string get_MemberName();
    [CompilerGeneratedAttribute]
public int get_DispId();
    public sealed virtual DynamicMetaObject GetMetaObject(Expression parameter);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Management.Automation.ComInterop.DispCallableMetaObject : DynamicMetaObject {
    private DispCallable _callable;
    internal DispCallableMetaObject(Expression expression, DispCallable callable);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    private DynamicMetaObject BindGetOrInvoke(DynamicMetaObject[] args, CallInfo callInfo);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    private DynamicMetaObject BindComInvoke(ComMethodDesc method, DynamicMetaObject[] indexes, CallInfo callInfo, Boolean[] isByRef, List`1<ParameterExpression> temps, List`1<Expression> initTemps);
    private BindingRestrictions DispCallableRestrictions();
}
internal static class System.Management.Automation.ComInterop.Error : object {
    internal static Exception SetComObjectDataFailed();
    internal static Exception UnexpectedVarEnum(object p0);
    internal static Exception DispBadParamCount(object p0, int parameterCount);
    internal static Exception DispMemberNotFound(object p0);
    internal static Exception DispNoNamedArgs(object p0);
    internal static Exception DispOverflow(object p0);
    internal static Exception DispTypeMismatch(object method, string value, string originalTypeName, string destinationTypeName);
    internal static Exception DispParamNotOptional(object p0);
    internal static Exception CannotRetrieveTypeInformation();
    internal static Exception GetIDsOfNamesInvalid(object p0);
    internal static Exception UnsupportedHandlerType();
    internal static Exception CouldNotGetDispId(object p0, object p1);
    internal static Exception AmbiguousConversion(object p0, object p1);
}
internal class System.Management.Automation.ComInterop.ErrorArgBuilder : SimpleArgBuilder {
    internal ErrorArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.ExcepInfo : ValueType {
    private short _wCode;
    private short _wReserved;
    private IntPtr _bstrSource;
    private IntPtr _bstrDescription;
    private IntPtr _bstrHelpFile;
    private int _dwHelpContext;
    private IntPtr _pvReserved;
    private IntPtr _pfnDeferredFillIn;
    private int _scode;
    private static string ConvertAndFreeBstr(IntPtr& bstr);
    internal Exception GetException();
}
internal static class System.Management.Automation.ComInterop.Helpers : object {
    [NullableContextAttribute("1")]
internal static Expression Convert(Expression expression, Type type);
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
internal interface System.Management.Automation.ComInterop.IDispatch {
    public abstract virtual int TryGetTypeInfoCount(UInt32& pctinfo);
    public abstract virtual int TryGetTypeInfo(UInt32 iTInfo, int lcid, IntPtr& info);
    public abstract virtual int TryGetIDsOfNames(Guid& iid, String[] names, UInt32 cNames, int lcid, Int32[] rgDispId);
    public abstract virtual int TryInvoke(int dispIdMember, Guid& riid, int lcid, INVOKEKIND wFlags, DISPPARAMS& pDispParams, IntPtr VarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
internal class System.Management.Automation.ComInterop.IDispatchComObject : ComObject {
    private ComTypeDesc _comTypeDesc;
    private static Dictionary`2<Guid, ComTypeDesc> s_cacheComTypeDesc;
    [CompilerGeneratedAttribute]
private IDispatch <DispatchObject>k__BackingField;
    public ComTypeDesc ComTypeDesc { get; }
    public IDispatch DispatchObject { get; }
    internal IDispatchComObject(IDispatch rcw);
    private static IDispatchComObject();
    public virtual string ToString();
    public ComTypeDesc get_ComTypeDesc();
    [CompilerGeneratedAttribute]
public IDispatch get_DispatchObject();
    private static int GetIDsOfNames(IDispatch dispatch, string name, Int32& dispId);
    internal bool TryGetGetItem(ComMethodDesc& value);
    private bool SlowTryGetGetItem(ComMethodDesc& value);
    internal bool TryGetSetItem(ComMethodDesc& value);
    private bool SlowTryGetSetItem(ComMethodDesc& value);
    internal bool TryGetMemberMethod(string name, ComMethodDesc& method);
    internal bool TryGetMemberEvent(string name, ComEventDesc& event);
    internal bool TryGetMemberMethodExplicit(string name, ComMethodDesc& method);
    internal bool TryGetPropertySetterExplicit(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
    internal virtual IList`1<string> GetMemberNames(bool dataOnly);
    internal virtual IList`1<KeyValuePair`2<string, object>> GetMembers(IEnumerable`1<string> names);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    private static void GetFuncDescForDescIndex(ITypeInfo typeInfo, int funcIndex, FUNCDESC& funcDesc, IntPtr& funcDescHandle);
    private void EnsureScanDefinedEvents();
    private static void ScanSourceInterface(ITypeInfo sourceTypeInfo, Dictionary`2& events);
    private static ITypeInfo GetCoClassTypeInfo(object rcw, ITypeInfo typeInfo);
    private void EnsureScanDefinedMethods();
    internal bool TryGetPropertySetter(string name, ComMethodDesc& method, Type limitType, bool holdsNull);
}
internal class System.Management.Automation.ComInterop.IDispatchMetaObject : ComFallbackMetaObject {
    private IDispatchComObject _self;
    internal IDispatchMetaObject(Expression expression, IDispatchComObject self);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual DynamicMetaObject BindInvoke(InvokeBinder binder, DynamicMetaObject[] args);
    private DynamicMetaObject BindComInvoke(DynamicMetaObject[] args, ComMethodDesc method, CallInfo callInfo, Boolean[] isByRef, List`1<ParameterExpression> temps, List`1<Expression> initTemps);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    private DynamicMetaObject BindGetMember(ComMethodDesc method, bool canReturnCallables);
    private DynamicMetaObject BindEvent(ComEventDesc eventDesc);
    public virtual DynamicMetaObject BindGetIndex(GetIndexBinder binder, DynamicMetaObject[] indexes);
    public virtual DynamicMetaObject BindSetIndex(SetIndexBinder binder, DynamicMetaObject[] indexes, DynamicMetaObject value);
    public virtual DynamicMetaObject BindSetMember(SetMemberBinder binder, DynamicMetaObject value);
    private DynamicMetaObject TryPropertyPut(SetMemberBinder binder, DynamicMetaObject value);
    private DynamicMetaObject TryEventHandlerNoop(SetMemberBinder binder, DynamicMetaObject value);
    private BindingRestrictions IDispatchRestriction();
    internal static BindingRestrictions IDispatchRestriction(Expression expr, ComTypeDesc typeDesc);
    protected virtual ComUnwrappedMetaObject UnwrapSelf();
}
[InterfaceTypeAttribute("1")]
[GuidAttribute("B196B283-BAB4-101A-B69C-00AA00341D07")]
internal interface System.Management.Automation.ComInterop.IProvideClassInfo {
    public abstract virtual void GetClassInfo(IntPtr& info);
}
internal interface System.Management.Automation.ComInterop.IPseudoComObject {
    public abstract virtual DynamicMetaObject GetMetaObject(Expression expression);
}
internal class System.Management.Automation.ComInterop.NullArgBuilder : ArgBuilder {
    internal virtual Expression Marshal(Expression parameter);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class System.Management.Automation.ComInterop.Requires : object {
    [ConditionalAttribute("DEBUG")]
internal static void NotNull(object value, string paramName);
    [ConditionalAttribute("DEBUG")]
internal static void Condition(bool precondition, string paramName);
}
internal class System.Management.Automation.ComInterop.SimpleArgBuilder : ArgBuilder {
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    protected Type ParameterType { get; }
    internal SimpleArgBuilder(Type parameterType);
    [CompilerGeneratedAttribute]
protected Type get_ParameterType();
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression newValue);
}
internal class System.Management.Automation.ComInterop.SplatCallSite : object {
    internal object _callable;
    private CallSite`1<Func`4<CallSite, object, Object[], object>> _site;
    internal SplatCallSite(object callable);
    internal object Invoke(Object[] args);
}
internal class System.Management.Automation.ComInterop.SplatInvokeBinder : CallSiteBinder {
    internal static SplatInvokeBinder Instance;
    private static SplatInvokeBinder();
    public virtual Expression Bind(Object[] args, ReadOnlyCollection`1<ParameterExpression> parameters, LabelTarget returnLabel);
}
internal class System.Management.Automation.ComInterop.StringArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal StringArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal class System.Management.Automation.ComInterop.TypeEnumMetaObject : DynamicMetaObject {
    private ComTypeEnumDesc _desc;
    internal TypeEnumMetaObject(ComTypeEnumDesc desc, Expression expression);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
    private BindingRestrictions EnumRestrictions();
}
internal class System.Management.Automation.ComInterop.TypeLibMetaObject : DynamicMetaObject {
    private ComTypeLibDesc _lib;
    internal TypeLibMetaObject(Expression expression, ComTypeLibDesc lib);
    private DynamicMetaObject TryBindGetMember(string name);
    public virtual DynamicMetaObject BindGetMember(GetMemberBinder binder);
    public virtual DynamicMetaObject BindInvokeMember(InvokeMemberBinder binder, DynamicMetaObject[] args);
    public virtual IEnumerable`1<string> GetDynamicMemberNames();
}
[ExtensionAttribute]
internal static class System.Management.Automation.ComInterop.TypeUtils : object {
    internal static Type GetNonNullableType(Type type);
    [ExtensionAttribute]
internal static bool IsNullableType(Type type);
    internal static bool AreReferenceAssignable(Type dest, Type src);
    internal static bool AreAssignable(Type dest, Type src);
    internal static bool IsImplicitlyConvertible(Type source, Type destination);
    internal static bool IsImplicitlyConvertible(Type source, Type destination, bool considerUserDefined);
    internal static MethodInfo GetUserDefinedCoercionMethod(Type convertFrom, Type convertToType, bool implicitOnly);
    internal static MethodInfo FindConversionOperator(MethodInfo[] methods, Type typeFrom, Type typeTo, bool implicitOnly);
    private static bool IsIdentityConversion(Type source, Type destination);
    private static bool IsImplicitNumericConversion(Type source, Type destination);
    private static bool IsImplicitReferenceConversion(Type source, Type destination);
    private static bool IsImplicitBoxingConversion(Type source, Type destination);
}
internal class System.Management.Automation.ComInterop.UnknownArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal UnknownArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class System.Management.Automation.ComInterop.UnsafeMethods : object {
    private static object s_lock;
    private static ModuleBuilder s_dynamicModule;
    internal static ModuleBuilder DynamicModule { get; }
    private static UnsafeMethods();
    public static IntPtr ConvertInt32ByrefToPtr(Int32& value);
    public static IntPtr ConvertVariantByrefToPtr(Variant& value);
    internal static Variant GetVariantForObject(object obj);
    internal static void InitVariantForObject(object obj, Variant& variant);
    public static object GetObjectForVariant(Variant variant);
    public static int IUnknownRelease(IntPtr interfacePointer);
    public static void IUnknownReleaseNotZero(IntPtr interfacePointer);
    public static int IDispatchInvoke(IntPtr dispatchPointer, int memberDispId, INVOKEKIND flags, DISPPARAMS& dispParams, Variant& result, ExcepInfo& excepInfo, UInt32& argErr);
    public static IntPtr GetIdsOfNamedParameters(IDispatch dispatch, String[] names, int methodDispId, GCHandle& pinningHandle);
    internal static ModuleBuilder get_DynamicModule();
}
internal class System.Management.Automation.ComInterop.VarEnumSelector : object {
    private static Dictionary`2<VarEnum, Type> s_comToManagedPrimitiveTypes;
    private static IList`1<IList`1<VarEnum>> s_comPrimitiveTypeFamilies;
    [CompilerGeneratedAttribute]
private VariantBuilder[] <VariantBuilders>k__BackingField;
    private static VarEnum VT_DEFAULT;
    internal VariantBuilder[] VariantBuilders { get; }
    internal VarEnumSelector(Type[] explicitArgTypes);
    private static VarEnumSelector();
    [CompilerGeneratedAttribute]
internal VariantBuilder[] get_VariantBuilders();
    internal static Type GetTypeForVarEnum(VarEnum vt);
    internal static Type GetManagedMarshalType(VarEnum varEnum);
    private static Dictionary`2<VarEnum, Type> CreateComToManagedPrimitiveTypes();
    private static IList`1<IList`1<VarEnum>> CreateComPrimitiveTypeFamilies();
    private static List`1<VarEnum> GetConversionsToComPrimitiveTypeFamilies(Type argumentType);
    private static void CheckForAmbiguousMatch(Type argumentType, List`1<VarEnum> compatibleComTypes);
    private static bool TryGetPrimitiveComType(Type argumentType, VarEnum& primitiveVarEnum);
    private static bool TryGetPrimitiveComTypeViaConversion(Type argumentType, VarEnum& primitiveVarEnum);
    private static VarEnum GetComType(Type& argumentType);
    private static VariantBuilder GetVariantBuilder(Type argumentType);
    private static ArgBuilder GetByValArgBuilder(Type elementType, VarEnum& elementVarEnum);
    private static SimpleArgBuilder GetSimpleArgBuilder(Type elementType, VarEnum elementVarEnum);
}
internal class System.Management.Automation.ComInterop.VariantArgBuilder : SimpleArgBuilder {
    private bool _isWrapper;
    internal VariantArgBuilder(Type parameterType);
    internal virtual Expression Marshal(Expression parameter);
    internal virtual Expression MarshalToRef(Expression parameter);
    internal virtual Expression UnmarshalFromRef(Expression value);
}
internal static class System.Management.Automation.ComInterop.VariantArray : object {
    private static List`1<Type> s_generatedTypes;
    private static VariantArray();
    internal static MemberExpression GetStructField(ParameterExpression variantArray, int field);
    internal static Type GetStructType(int args);
    private static Type CreateCustomType(int size);
}
internal class System.Management.Automation.ComInterop.VariantArray1 : ValueType {
    public Variant Element0;
}
internal class System.Management.Automation.ComInterop.VariantArray2 : ValueType {
    public Variant Element0;
    public Variant Element1;
}
internal class System.Management.Automation.ComInterop.VariantArray4 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
}
internal class System.Management.Automation.ComInterop.VariantArray8 : ValueType {
    public Variant Element0;
    public Variant Element1;
    public Variant Element2;
    public Variant Element3;
    public Variant Element4;
    public Variant Element5;
    public Variant Element6;
    public Variant Element7;
}
internal class System.Management.Automation.ComInterop.VariantBuilder : object {
    private MemberExpression _variant;
    private ArgBuilder _argBuilder;
    private VarEnum _targetComType;
    [CompilerGeneratedAttribute]
private ParameterExpression <TempVariable>k__BackingField;
    internal ParameterExpression TempVariable { get; private set; }
    internal bool IsByRef { get; }
    internal VariantBuilder(VarEnum targetComType, ArgBuilder builder);
    [CompilerGeneratedAttribute]
internal ParameterExpression get_TempVariable();
    [CompilerGeneratedAttribute]
private void set_TempVariable(ParameterExpression value);
    internal bool get_IsByRef();
    internal Expression InitializeArgumentVariant(MemberExpression variant, Expression parameter);
    private static Expression Release(Expression pUnk);
    internal Expression Clear();
    internal Expression UpdateFromReturn(Expression parameter);
}
internal static class System.Management.Automation.ComInvoker : object {
    private static int DISP_E_EXCEPTION;
    private static int LCID_DEFAULT;
    private static int DISPID_PROPERTYPUT;
    private static Guid s_IID_NULL;
    private static int s_variantSize;
    private static ComInvoker();
    private static void MakeByRefVariant(IntPtr srcVariantPtr, IntPtr destVariantPtr);
    private static IntPtr NewVariantArray(int length);
    internal static Boolean[] GetByRefArray(ParameterInformation[] parameters, int argumentCount, bool isPropertySet);
    internal static object Invoke(IDispatch target, int dispId, Object[] args, Boolean[] byRef, INVOKEKIND invokeKind);
}
public class System.Management.Automation.CommandBreakpoint : Breakpoint {
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private WildcardPattern <CommandPattern>k__BackingField;
    public string Command { get; }
    internal WildcardPattern CommandPattern { get; }
    public CommandBreakpoint(string script, WildcardPattern command, string commandString);
    public CommandBreakpoint(string script, WildcardPattern command, string commandString, ScriptBlock action);
    public CommandBreakpoint(string script, WildcardPattern command, string commandString, int id);
    public CommandBreakpoint(string script, WildcardPattern command, string commandString, ScriptBlock action, int id);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
internal WildcardPattern get_CommandPattern();
    public virtual string ToString();
    internal virtual bool RemoveSelf(ScriptDebugger debugger);
    private bool CommandInfoMatches(CommandInfo commandInfo);
    internal bool Trigger(InvocationInfo invocationInfo);
}
public class System.Management.Automation.CommandCompletion : object {
    [CompilerGeneratedAttribute]
private int <CurrentMatchIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplacementIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplacementLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CompletionResult> <CompletionMatches>k__BackingField;
    internal static IList`1<CompletionResult> EmptyCompletionResult;
    private static CommandCompletion s_emptyCommandCompletion;
    public int CurrentMatchIndex { get; public set; }
    public int ReplacementIndex { get; public set; }
    public int ReplacementLength { get; public set; }
    public Collection`1<CompletionResult> CompletionMatches { get; public set; }
    public CommandCompletion(Collection`1<CompletionResult> matches, int currentMatchIndex, int replacementIndex, int replacementLength);
    private static CommandCompletion();
    [CompilerGeneratedAttribute]
public int get_CurrentMatchIndex();
    [CompilerGeneratedAttribute]
public void set_CurrentMatchIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ReplacementIndex();
    [CompilerGeneratedAttribute]
public void set_ReplacementIndex(int value);
    [CompilerGeneratedAttribute]
public int get_ReplacementLength();
    [CompilerGeneratedAttribute]
public void set_ReplacementLength(int value);
    [CompilerGeneratedAttribute]
public Collection`1<CompletionResult> get_CompletionMatches();
    [CompilerGeneratedAttribute]
public void set_CompletionMatches(Collection`1<CompletionResult> value);
    public static Tuple`3<Ast, Token[], IScriptPosition> MapStringInputToParsedInput(string input, int cursorIndex);
    public static CommandCompletion CompleteInput(string input, int cursorIndex, Hashtable options);
    public static CommandCompletion CompleteInput(Ast ast, Token[] tokens, IScriptPosition positionOfCursor, Hashtable options);
    public static CommandCompletion CompleteInput(string input, int cursorIndex, Hashtable options, PowerShell powershell);
    public static CommandCompletion CompleteInput(Ast ast, Token[] tokens, IScriptPosition cursorPosition, Hashtable options, PowerShell powershell);
    public CompletionResult GetNextResult(bool forward);
    internal static CommandCompletion CompleteInputInDebugger(string input, int cursorIndex, Hashtable options, Debugger debugger);
    internal static CommandCompletion CompleteInputInDebugger(Ast ast, Token[] tokens, IScriptPosition cursorPosition, Hashtable options, Debugger debugger);
    private static CommandCompletion ProcessCompleteInputCommand(Command cmd, Debugger debugger);
    private static void CheckScriptCallOnRemoteRunspace(RemoteRunspace remoteRunspace);
    private static CommandCompletion CallScriptWithStringParameterSet(string input, int cursorIndex, Hashtable options, PowerShell powershell);
    private static CommandCompletion CallScriptWithAstParameterSet(Ast ast, Token[] tokens, IScriptPosition cursorPosition, Hashtable options, PowerShell powershell);
    private static CommandCompletion CompleteInputImpl(Ast ast, Token[] tokens, IScriptPosition positionOfCursor, Hashtable options);
}
internal class System.Management.Automation.CommandDiscovery : object {
    [TraceSourceAttribute("CommandDiscovery", "Traces the discovery of cmdlets, scripts, functions, applications, etc.")]
internal static PSTraceSource discoveryTracer;
    private HashSet`1<string> _activePreLookup;
    private HashSet`1<string> _activeModuleSearch;
    private HashSet`1<string> _activeCommandNotFound;
    private HashSet`1<string> _activePostCommand;
    private LookupPathCollection _cachedLookupPaths;
    private string _pathCacheKey;
    private Collection`1<string> _cachedPath;
    private static object s_lockObject;
    private static string s_pathExtCacheKey;
    private static String[] s_cachedPathExtCollection;
    private static String[] s_cachedPathExtCollectionWithPs1;
    [CompilerGeneratedAttribute]
private ExecutionContext <Context>k__BackingField;
    internal static String[] PathExtensionsWithPs1Prepended { get; }
    internal static String[] PathExtensions { get; }
    internal ExecutionContext Context { get; }
    internal CommandDiscovery(ExecutionContext context);
    private static CommandDiscovery();
    private static bool IsSpecialCmdlet(Type implementingType);
    private CmdletInfo NewCmdletInfo(SessionStateCmdletEntry entry);
    internal static CmdletInfo NewCmdletInfo(SessionStateCmdletEntry entry, ExecutionContext context);
    internal static AliasInfo NewAliasInfo(SessionStateAliasEntry entry, ExecutionContext context);
    internal CmdletInfo AddCmdletInfoToCache(string name, CmdletInfo newCmdletInfo, bool isGlobal);
    internal void AddSessionStateCmdletEntryToCache(SessionStateCmdletEntry entry);
    internal void AddSessionStateCmdletEntryToCache(SessionStateCmdletEntry entry, bool local);
    internal CommandProcessorBase LookupCommandProcessor(string commandName, CommandOrigin commandOrigin, Nullable`1<bool> useLocalScope);
    internal static void VerifyRequiredModules(ExternalScriptInfo scriptInfo, ExecutionContext context);
    private CommandProcessorBase CreateScriptProcessorForSingleShell(ExternalScriptInfo scriptInfo, ExecutionContext context, bool useLocalScope, SessionStateInternal sessionState);
    internal static void VerifyScriptRequirements(ExternalScriptInfo scriptInfo, ExecutionContext context);
    internal static void VerifyPSVersion(ExternalScriptInfo scriptInfo);
    internal static void VerifyPSEdition(ExternalScriptInfo scriptInfo);
    internal static void VerifyElevatedPrivileges(ExternalScriptInfo scriptInfo);
    internal CommandProcessorBase LookupCommandProcessor(CommandInfo commandInfo, CommandOrigin commandOrigin, Nullable`1<bool> useLocalScope, SessionStateInternal sessionState);
    internal static void ShouldRun(ExecutionContext context, PSHost host, CommandInfo commandInfo, CommandOrigin commandOrigin);
    private static CommandProcessorBase CreateCommandProcessorForScript(ScriptInfo scriptInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    private static CommandProcessorBase CreateCommandProcessorForScript(ExternalScriptInfo scriptInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    internal static CommandProcessorBase CreateCommandProcessorForScript(FunctionInfo functionInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    internal static CommandProcessorBase CreateCommandProcessorForScript(ScriptBlock scriptblock, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    private static CommandProcessorBase GetScriptAsCmdletProcessor(IScriptCommandInfo scriptCommandInfo, ExecutionContext context, bool useNewScope, bool fromScriptFile, SessionStateInternal sessionState);
    internal CommandInfo LookupCommandInfo(string commandName);
    internal CommandInfo LookupCommandInfo(string commandName, CommandOrigin commandOrigin);
    internal static CommandInfo LookupCommandInfo(string commandName, CommandOrigin commandOrigin, ExecutionContext context);
    internal static CommandInfo LookupCommandInfo(string commandName, CommandTypes commandTypes, SearchResolutionOptions searchResolutionOptions, CommandOrigin commandOrigin, ExecutionContext context);
    internal static void AutoloadModulesWithJobSourceAdapters(ExecutionContext context, CommandOrigin commandOrigin);
    internal static Collection`1<PSModuleInfo> AutoloadSpecifiedModule(string moduleName, ExecutionContext context, SessionStateEntryVisibility visibility, Exception& exception);
    private static CommandInfo InvokeCommandNotFoundHandler(string commandName, ExecutionContext context, string originalCommandName, CommandOrigin commandOrigin);
    private static CommandInfo TryNormalSearch(string commandName, ExecutionContext context, CommandOrigin commandOrigin, SearchResolutionOptions searchResolutionOptions, CommandTypes commandTypes, Exception& lastError);
    private static CommandInfo TryModuleAutoDiscovery(string commandName, ExecutionContext context, string originalCommandName, CommandOrigin commandOrigin, SearchResolutionOptions searchResolutionOptions, CommandTypes commandTypes, Exception& lastError);
    private static CommandInfo TryModuleAutoLoading(string commandName, ExecutionContext context, string originalCommandName, CommandOrigin commandOrigin, Exception& lastError);
    internal void RegisterLookupCommandInfoAction(string currentAction, string command);
    internal void UnregisterLookupCommandInfoAction(string currentAction, string command);
    internal LookupPathCollection GetLookupDirectoryPaths();
    internal static String[] get_PathExtensionsWithPs1Prepended();
    internal static String[] get_PathExtensions();
    private static void InitPathExtCache(string pathExt);
    [IteratorStateMachineAttribute("System.Management.Automation.CommandDiscovery/<GetCmdletInfo>d__52")]
internal IEnumerator`1<CmdletInfo> GetCmdletInfo(string cmdletName, bool searchAllScopes);
    [CompilerGeneratedAttribute]
internal ExecutionContext get_Context();
    internal static PSModuleAutoLoadingPreference GetCommandDiscoveryPreference(ExecutionContext context, VariablePath variablePath, string environmentVariable);
}
[EventSourceAttribute]
internal class System.Management.Automation.CommandDiscoveryEventSource : EventSource {
    internal static CommandDiscoveryEventSource Log;
    private static CommandDiscoveryEventSource();
    public void CommandLookupStart(string CommandName);
    public void CommandLookupStop(string CommandName);
    public void ModuleAutoLoadingStart(string CommandName);
    public void ModuleAutoLoadingStop(string CommandName);
    public void ModuleAutoDiscoveryStart(string CommandName);
    public void ModuleAutoDiscoveryStop(string CommandName);
    public void SearchingForModuleFilesStart();
    public void SearchingForModuleFilesStop();
    public void GetModuleExportedCommandsStart(string ModulePath);
    public void GetModuleExportedCommandsStop(string ModulePath);
    public void ModuleManifestAnalysisResult(string ModulePath, bool Success);
    public void ModuleManifestAnalysisException(string ModulePath, string Exception);
}
internal class System.Management.Automation.CommandHelpProvider : HelpProviderWithCache {
    private static Dictionary`2<string, string> s_engineModuleHelpFileCache;
    private ExecutionContext _context;
    private Hashtable _helpFiles;
    [TraceSourceAttribute("CommandHelpProvider", "CommandHelpProvider")]
private static PSTraceSource s_tracer;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal CommandHelpProvider(HelpSystem helpSystem);
    private static CommandHelpProvider();
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    private static void GetModulePaths(CommandInfo commandInfo, String& moduleName, String& moduleDir, String& nestedModulePath);
    private static string GetHelpName(CommandInfo commandInfo);
    private HelpInfo GetHelpInfoFromHelpFile(CommandInfo commandInfo, string helpFileToFind, Collection`1<string> searchPaths, bool reportErrors, String& helpFile);
    private HelpInfo GetHelpInfo(CommandInfo commandInfo, bool reportErrors, bool searchOnlyContent);
    [IteratorStateMachineAttribute("System.Management.Automation.CommandHelpProvider/<ExactMatchHelp>d__12")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    private static string GetCmdletAssemblyPath(CmdletInfo cmdletInfo);
    private string GetHelpFile(string helpFile, CmdletInfo cmdletInfo);
    private string FindHelpFile(CmdletInfo cmdletInfo);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier, string commandName, bool reportErrors);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier);
    private void ProcessUserDefinedHelpData(string mshSnapInId, UserDefinedHelpData userDefinedHelpData);
    private HelpInfo GetFromCommandCache(string helpFileIdentifier, string commandName, HelpCategory helpCategory);
    private HelpInfo GetFromCommandCache(string helpFileIdentifier, CommandInfo commandInfo);
    private HelpInfo GetFromCommandCacheOrCmdletInfo(CmdletInfo cmdletInfo);
    private MamlCommandHelpInfo GetFromCommandCacheByRemovingPrefix(string helpIdentifier, CommandInfo cmdInfo);
    private void AddToCommandCache(string mshSnapInId, string cmdletName, MamlCommandHelpInfo helpInfo);
    internal static bool IsMamlHelp(string helpFile, XmlNode helpItemsNode);
    [IteratorStateMachineAttribute("System.Management.Automation.CommandHelpProvider/<SearchHelp>d__26")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    private static bool Match(HelpInfo helpInfo, HelpRequest helpRequest, CommandInfo commandInfo);
    private static bool Match(string target, string pattern);
    private static bool Match(string target, ICollection`1<string> patterns);
    [IteratorStateMachineAttribute("System.Management.Automation.CommandHelpProvider/<ProcessForwardedHelp>d__30")]
internal virtual IEnumerable`1<HelpInfo> ProcessForwardedHelp(HelpInfo helpInfo, HelpRequest helpRequest);
    internal virtual void Reset();
    internal virtual CommandSearcher GetCommandSearcherForExactMatch(string commandName, ExecutionContext context);
    internal virtual CommandSearcher GetCommandSearcherForSearch(string pattern, ExecutionContext context);
}
public abstract class System.Management.Automation.CommandInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandTypes <CommandType>k__BackingField;
    private Version _version;
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private Nullable`1<PSLanguageMode> <DefiningLanguageMode>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandInfo <CopiedCommand>k__BackingField;
    private SessionStateEntryVisibility _visibility;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    private CommandMetadata _externalCommandMetadata;
    internal ReadOnlyCollection`1<CommandParameterSetInfo> _parameterSets;
    [CompilerGeneratedAttribute]
private bool <IsImported>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGetCommandCopy>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Arguments>k__BackingField;
    public string Name { get; private set; }
    public CommandTypes CommandType { get; private set; }
    public string Source { get; }
    public Version Version { get; }
    internal ExecutionContext Context { get; internal set; }
    internal Nullable`1<PSLanguageMode> DefiningLanguageMode { get; internal set; }
    internal HelpCategory HelpCategory { get; }
    internal CommandInfo CopiedCommand { get; internal set; }
    public string Definition { get; }
    public SessionStateEntryVisibility Visibility { get; public set; }
    internal CommandMetadata CommandMetadata { get; }
    internal string Syntax { get; }
    public string ModuleName { get; }
    public PSModuleInfo Module { get; internal set; }
    public RemotingCapability RemotingCapability { get; }
    internal bool ImplementsDynamicParameters { get; }
    public Dictionary`2<string, ParameterMetadata> Parameters { get; }
    internal CommandMetadata ExternalCommandMetadata { get; internal set; }
    public ReadOnlyCollection`1<CommandParameterSetInfo> ParameterSets { get; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal bool IsImported { get; internal set; }
    internal string Prefix { get; internal set; }
    internal bool IsGetCommandCopy { get; internal set; }
    internal Object[] Arguments { get; internal set; }
    internal CommandInfo(string name, CommandTypes type);
    internal CommandInfo(string name, CommandTypes type, ExecutionContext context);
    internal CommandInfo(CommandInfo other);
    internal CommandInfo(string name, CommandInfo other);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public CommandTypes get_CommandType();
    [CompilerGeneratedAttribute]
private void set_CommandType(CommandTypes value);
    public virtual string get_Source();
    public virtual Version get_Version();
    internal ExecutionContext get_Context();
    internal void set_Context(ExecutionContext value);
    [CompilerGeneratedAttribute]
internal Nullable`1<PSLanguageMode> get_DefiningLanguageMode();
    [CompilerGeneratedAttribute]
internal void set_DefiningLanguageMode(Nullable`1<PSLanguageMode> value);
    internal virtual HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
internal CommandInfo get_CopiedCommand();
    [CompilerGeneratedAttribute]
internal void set_CopiedCommand(CommandInfo value);
    internal void SetCommandType(CommandTypes newType);
    public abstract virtual string get_Definition();
    internal void Rename(string newName);
    public virtual string ToString();
    public virtual SessionStateEntryVisibility get_Visibility();
    public virtual void set_Visibility(SessionStateEntryVisibility value);
    internal virtual CommandMetadata get_CommandMetadata();
    internal virtual string get_Syntax();
    public string get_ModuleName();
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
internal void set_Module(PSModuleInfo value);
    public RemotingCapability get_RemotingCapability();
    internal virtual bool get_ImplementsDynamicParameters();
    private MergedCommandParameterMetadata GetMergedCommandParameterMetadataSafely();
    private void OnGetMergedCommandParameterMetadataSafelyEventHandler(object sender, PSEventArgs args);
    private void GetMergedCommandParameterMetadata(MergedCommandParameterMetadata& result);
    public virtual Dictionary`2<string, ParameterMetadata> get_Parameters();
    internal CommandMetadata get_ExternalCommandMetadata();
    internal void set_ExternalCommandMetadata(CommandMetadata value);
    public ParameterMetadata ResolveParameter(string name);
    public ReadOnlyCollection`1<CommandParameterSetInfo> get_ParameterSets();
    public abstract virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
    [CompilerGeneratedAttribute]
internal bool get_IsImported();
    [CompilerGeneratedAttribute]
internal void set_IsImported(bool value);
    [CompilerGeneratedAttribute]
internal string get_Prefix();
    [CompilerGeneratedAttribute]
internal void set_Prefix(string value);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] argumentList);
    internal Collection`1<CommandParameterSetInfo> GenerateCommandParameterSetInfo();
    [CompilerGeneratedAttribute]
internal bool get_IsGetCommandCopy();
    [CompilerGeneratedAttribute]
internal void set_IsGetCommandCopy(bool value);
    [CompilerGeneratedAttribute]
internal Object[] get_Arguments();
    [CompilerGeneratedAttribute]
internal void set_Arguments(Object[] value);
    internal static Collection`1<CommandParameterSetInfo> GetCacheableMetadata(CommandMetadata metadata);
    internal static Collection`1<CommandParameterSetInfo> GetParameterMetadata(CommandMetadata metadata, MergedCommandParameterMetadata parameterMetadata);
}
public class System.Management.Automation.CommandInvocationIntrinsics : object {
    private ExecutionContext _context;
    private PSCmdlet _cmdlet;
    private MshCommandRuntime _commandRuntime;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommandLookupEventArgs> <CommandNotFoundAction>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommandLookupEventArgs> <PreCommandLookupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<CommandLookupEventArgs> <PostCommandLookupAction>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LocationChangedEventArgs> <LocationChangedAction>k__BackingField;
    public bool HasErrors { get; public set; }
    public EventHandler`1<CommandLookupEventArgs> CommandNotFoundAction { get; public set; }
    public EventHandler`1<CommandLookupEventArgs> PreCommandLookupAction { get; public set; }
    public EventHandler`1<CommandLookupEventArgs> PostCommandLookupAction { get; public set; }
    public EventHandler`1<LocationChangedEventArgs> LocationChangedAction { get; public set; }
    internal CommandInvocationIntrinsics(ExecutionContext context, PSCmdlet cmdlet);
    internal CommandInvocationIntrinsics(ExecutionContext context);
    public bool get_HasErrors();
    public void set_HasErrors(bool value);
    public string ExpandString(string source);
    public CommandInfo GetCommand(string commandName, CommandTypes type);
    public CommandInfo GetCommand(string commandName, CommandTypes type, Object[] arguments);
    [CompilerGeneratedAttribute]
public EventHandler`1<CommandLookupEventArgs> get_CommandNotFoundAction();
    [CompilerGeneratedAttribute]
public void set_CommandNotFoundAction(EventHandler`1<CommandLookupEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<CommandLookupEventArgs> get_PreCommandLookupAction();
    [CompilerGeneratedAttribute]
public void set_PreCommandLookupAction(EventHandler`1<CommandLookupEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<CommandLookupEventArgs> get_PostCommandLookupAction();
    [CompilerGeneratedAttribute]
public void set_PostCommandLookupAction(EventHandler`1<CommandLookupEventArgs> value);
    [CompilerGeneratedAttribute]
public EventHandler`1<LocationChangedEventArgs> get_LocationChangedAction();
    [CompilerGeneratedAttribute]
public void set_LocationChangedAction(EventHandler`1<LocationChangedEventArgs> value);
    public CmdletInfo GetCmdlet(string commandName);
    internal static CmdletInfo GetCmdlet(string commandName, ExecutionContext context);
    public CmdletInfo GetCmdletByTypeName(string cmdletTypeName);
    public List`1<CmdletInfo> GetCmdlets();
    public List`1<CmdletInfo> GetCmdlets(string pattern);
    public List`1<string> GetCommandName(string name, bool nameIsPattern, bool returnFullName);
    public IEnumerable`1<CommandInfo> GetCommands(string name, CommandTypes commandTypes, bool nameIsPattern);
    [IteratorStateMachineAttribute("System.Management.Automation.CommandInvocationIntrinsics/<GetCommands>d__34")]
internal IEnumerable`1<CommandInfo> GetCommands(string name, CommandTypes commandTypes, SearchResolutionOptions options, Nullable`1<CommandOrigin> commandOrigin);
    public Collection`1<PSObject> InvokeScript(string script);
    public Collection`1<PSObject> InvokeScript(string script, Object[] args);
    public Collection`1<PSObject> InvokeScript(SessionState sessionState, ScriptBlock scriptBlock, Object[] args);
    public Collection`1<PSObject> InvokeScript(bool useLocalScope, ScriptBlock scriptBlock, IList input, Object[] args);
    public Collection`1<PSObject> InvokeScript(string script, bool useNewScope, PipelineResultTypes writeToPipeline, IList input, Object[] args);
    private Collection`1<PSObject> InvokeScript(ScriptBlock sb, bool useNewScope, PipelineResultTypes writeToPipeline, IList input, Object[] args);
    public ScriptBlock NewScriptBlock(string scriptText);
}
internal class System.Management.Automation.CommandLineParameters : object {
    private PSBoundParametersDictionary _dictionary;
    internal bool ContainsKey(string name);
    internal void Add(string name, object value);
    internal void MarkAsBoundPositionally(string name);
    internal void SetPSBoundParametersVariable(ExecutionContext context);
    internal void SetImplicitUsingParameters(object obj);
    internal IDictionary GetImplicitUsingParameters();
    internal object GetValueToBindToPSBoundParameters();
    internal void UpdateInvocationInfo(InvocationInfo invocationInfo);
    internal HashSet`1<string> CopyBoundPositionalParameters();
}
public class System.Management.Automation.CommandLookupEventArgs : EventArgs {
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandOrigin <CommandOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <StopSearch>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandInfo <Command>k__BackingField;
    private ScriptBlock _scriptBlock;
    public string CommandName { get; }
    public CommandOrigin CommandOrigin { get; }
    public bool StopSearch { get; public set; }
    public CommandInfo Command { get; public set; }
    public ScriptBlock CommandScriptBlock { get; public set; }
    internal CommandLookupEventArgs(string commandName, CommandOrigin commandOrigin, ExecutionContext context);
    [CompilerGeneratedAttribute]
public string get_CommandName();
    [CompilerGeneratedAttribute]
public CommandOrigin get_CommandOrigin();
    [CompilerGeneratedAttribute]
public bool get_StopSearch();
    [CompilerGeneratedAttribute]
public void set_StopSearch(bool value);
    [CompilerGeneratedAttribute]
public CommandInfo get_Command();
    [CompilerGeneratedAttribute]
public void set_Command(CommandInfo value);
    public ScriptBlock get_CommandScriptBlock();
    public void set_CommandScriptBlock(ScriptBlock value);
}
[DebuggerDisplayAttribute("CommandName = {Name}; Type = {CommandType}")]
public class System.Management.Automation.CommandMetadata : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <CommandType>k__BackingField;
    private ScriptBlock _scriptBlock;
    private string _defaultParameterSetName;
    [CompilerGeneratedAttribute]
private bool <SupportsShouldProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsPaging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PositionalBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsTransactions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpUri>k__BackingField;
    private RemotingCapability _remotingCapability;
    [CompilerGeneratedAttribute]
private ConfirmImpact <ConfirmImpact>k__BackingField;
    private Dictionary`2<string, ParameterMetadata> _parameters;
    private bool _shouldGenerateCommonParameters;
    [CompilerGeneratedAttribute]
private ObsoleteAttribute <Obsolete>k__BackingField;
    private MergedCommandParameterMetadata _staticCommandParameterMetadata;
    private bool _implementsDynamicParameters;
    private UInt32 _defaultParameterSetFlag;
    private Collection`1<Attribute> _otherAttributes;
    private string _wrappedCommand;
    private CommandTypes _wrappedCommandType;
    private bool _wrappedAnyCmdlet;
    internal static string isSafeNameOrIdentifierRegex;
    private static ConcurrentDictionary`2<string, CommandMetadata> s_commandMetadataCache;
    public string Name { get; public set; }
    public Type CommandType { get; private set; }
    public string DefaultParameterSetName { get; public set; }
    public bool SupportsShouldProcess { get; public set; }
    public bool SupportsPaging { get; public set; }
    public bool PositionalBinding { get; public set; }
    public bool SupportsTransactions { get; public set; }
    public string HelpUri { get; public set; }
    public RemotingCapability RemotingCapability { get; public set; }
    public ConfirmImpact ConfirmImpact { get; public set; }
    public Dictionary`2<string, ParameterMetadata> Parameters { get; private set; }
    internal ObsoleteAttribute Obsolete { get; internal set; }
    internal MergedCommandParameterMetadata StaticCommandParameterMetadata { get; }
    internal bool ImplementsDynamicParameters { get; }
    internal UInt32 DefaultParameterSetFlag { get; internal set; }
    internal bool WrappedAnyCmdlet { get; }
    internal CommandTypes WrappedCommandType { get; }
    public CommandMetadata(Type commandType);
    public CommandMetadata(CommandInfo commandInfo);
    public CommandMetadata(CommandInfo commandInfo, bool shouldGenerateCommonParameters);
    public CommandMetadata(string path);
    public CommandMetadata(CommandMetadata other);
    internal CommandMetadata(string name, CommandTypes commandType, bool isProxyForCmdlet, string defaultParameterSetName, bool supportsShouldProcess, ConfirmImpact confirmImpact, bool supportsPaging, bool supportsTransactions, bool positionalBinding, Dictionary`2<string, ParameterMetadata> parameters);
    internal CommandMetadata(string commandName, Type cmdletType, ExecutionContext context);
    internal CommandMetadata(ScriptBlock scriptblock, string commandName, ExecutionContext context);
    private static CommandMetadata();
    private void Init(string name, string fullyQualifiedName, Type commandType, bool shouldGenerateCommonParameters);
    private void Init(ScriptBlock scriptBlock, string name, bool shouldGenerateCommonParameters);
    internal static CommandMetadata Get(string commandName, Type cmdletType, ExecutionContext context);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_CommandType();
    [CompilerGeneratedAttribute]
private void set_CommandType(Type value);
    public string get_DefaultParameterSetName();
    public void set_DefaultParameterSetName(string value);
    [CompilerGeneratedAttribute]
public bool get_SupportsShouldProcess();
    [CompilerGeneratedAttribute]
public void set_SupportsShouldProcess(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsPaging();
    [CompilerGeneratedAttribute]
public void set_SupportsPaging(bool value);
    [CompilerGeneratedAttribute]
public bool get_PositionalBinding();
    [CompilerGeneratedAttribute]
public void set_PositionalBinding(bool value);
    [CompilerGeneratedAttribute]
public bool get_SupportsTransactions();
    [CompilerGeneratedAttribute]
public void set_SupportsTransactions(bool value);
    [CompilerGeneratedAttribute]
public string get_HelpUri();
    [CompilerGeneratedAttribute]
public void set_HelpUri(string value);
    public RemotingCapability get_RemotingCapability();
    public void set_RemotingCapability(RemotingCapability value);
    [CompilerGeneratedAttribute]
public ConfirmImpact get_ConfirmImpact();
    [CompilerGeneratedAttribute]
public void set_ConfirmImpact(ConfirmImpact value);
    public Dictionary`2<string, ParameterMetadata> get_Parameters();
    private void set_Parameters(Dictionary`2<string, ParameterMetadata> value);
    [CompilerGeneratedAttribute]
internal ObsoleteAttribute get_Obsolete();
    [CompilerGeneratedAttribute]
internal void set_Obsolete(ObsoleteAttribute value);
    internal MergedCommandParameterMetadata get_StaticCommandParameterMetadata();
    internal bool get_ImplementsDynamicParameters();
    internal UInt32 get_DefaultParameterSetFlag();
    internal void set_DefaultParameterSetFlag(UInt32 value);
    internal bool get_WrappedAnyCmdlet();
    internal CommandTypes get_WrappedCommandType();
    private void ConstructCmdletMetadataUsingReflection();
    private void ProcessCmdletAttribute(CmdletCommonMetadataAttribute attribute);
    private MergedCommandParameterMetadata MergeParameterMetadata(ExecutionContext context, InternalParameterMetadata parameterMetadata, bool shouldGenerateCommonParameters);
    internal string GetProxyCommand(string helpComment, bool generateDynamicParameters);
    internal string GetDecl();
    internal string GetParamBlock();
    internal string GetBeginBlock();
    internal string GetProcessBlock();
    internal string GetDynamicParamBlock();
    internal string GetEndBlock();
    internal string GetCleanBlock();
    private static CommandMetadata GetRestrictedCmdlet(string cmdletName, string defaultParameterSet, string helpUri, ParameterMetadata[] parameters);
    private static CommandMetadata GetRestrictedGetCommand();
    private static CommandMetadata GetRestrictedGetFormatData();
    private static CommandMetadata GetRestrictedGetHelp();
    private static CommandMetadata GetRestrictedSelectObject();
    private static CommandMetadata GetRestrictedMeasureObject();
    private static CommandMetadata GetRestrictedOutDefault();
    private static CommandMetadata GetRestrictedExitPSSession();
    public static Dictionary`2<string, CommandMetadata> GetRestrictedCommands(SessionCapabilities sessionCapabilities);
    private static Collection`1<CommandMetadata> GetRestrictedRemotingCommands();
}
public class System.Management.Automation.CommandNotFoundException : RuntimeException {
    private ErrorRecord _errorRecord;
    private string _commandName;
    private string _errorId;
    private ErrorCategory _errorCategory;
    public ErrorRecord ErrorRecord { get; }
    public string CommandName { get; public set; }
    internal CommandNotFoundException(string commandName, Exception innerException, string errorIdAndResourceId, string resourceStr, Object[] messageArgs);
    public CommandNotFoundException(string message);
    public CommandNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected CommandNotFoundException(SerializationInfo info, StreamingContext context);
    public virtual ErrorRecord get_ErrorRecord();
    public string get_CommandName();
    public void set_CommandName(string value);
    private static string BuildMessage(string commandName, string resourceStr, Object[] messageArgs);
}
public enum System.Management.Automation.CommandOrigin : Enum {
    public int value__;
    public static CommandOrigin Runspace;
    public static CommandOrigin Internal;
}
public class System.Management.Automation.CommandParameterInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ParameterType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromPipelineByPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromRemainingArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Aliases>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Attribute> <Attributes>k__BackingField;
    public string Name { get; }
    public Type ParameterType { get; }
    public bool IsMandatory { get; private set; }
    public bool IsDynamic { get; }
    public int Position { get; private set; }
    public bool ValueFromPipeline { get; private set; }
    public bool ValueFromPipelineByPropertyName { get; private set; }
    public bool ValueFromRemainingArguments { get; private set; }
    public string HelpMessage { get; private set; }
    public ReadOnlyCollection`1<string> Aliases { get; }
    public ReadOnlyCollection`1<Attribute> Attributes { get; private set; }
    internal CommandParameterInfo(CompiledCommandParameter parameter, UInt32 parameterSetFlag);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Type get_ParameterType();
    [CompilerGeneratedAttribute]
public bool get_IsMandatory();
    [CompilerGeneratedAttribute]
private void set_IsMandatory(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDynamic();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
private void set_Position(int value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromPipeline();
    [CompilerGeneratedAttribute]
private void set_ValueFromPipeline(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromPipelineByPropertyName();
    [CompilerGeneratedAttribute]
private void set_ValueFromPipelineByPropertyName(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromRemainingArguments();
    [CompilerGeneratedAttribute]
private void set_ValueFromRemainingArguments(bool value);
    [CompilerGeneratedAttribute]
public string get_HelpMessage();
    [CompilerGeneratedAttribute]
private void set_HelpMessage(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Aliases();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Attribute> get_Attributes();
    [CompilerGeneratedAttribute]
private void set_Attributes(ReadOnlyCollection`1<Attribute> value);
    private void SetAttributes(IList`1<Attribute> attributeMetadata);
    private void SetParameterSetData(ParameterSetSpecificMetadata parameterMetadata);
}
[DebuggerDisplayAttribute("{ParameterName}")]
internal class System.Management.Automation.CommandParameterInternal : object {
    private Parameter _parameter;
    private Argument _argument;
    private bool _spaceAfterParameter;
    private bool _fromHashtableSplatting;
    internal bool SpaceAfterParameter { get; }
    internal bool ParameterNameSpecified { get; }
    internal bool ArgumentSpecified { get; }
    internal bool ParameterAndArgumentSpecified { get; }
    internal bool FromHashtableSplatting { get; }
    internal string ParameterName { get; internal set; }
    internal string ParameterText { get; }
    internal Ast ParameterAst { get; }
    internal IScriptExtent ParameterExtent { get; }
    internal Ast ArgumentAst { get; }
    internal IScriptExtent ArgumentExtent { get; }
    internal object ArgumentValue { get; }
    internal bool ArgumentToBeSplatted { get; }
    internal IScriptExtent ErrorExtent { get; }
    internal bool get_SpaceAfterParameter();
    internal bool get_ParameterNameSpecified();
    internal bool get_ArgumentSpecified();
    internal bool get_ParameterAndArgumentSpecified();
    internal bool get_FromHashtableSplatting();
    internal string get_ParameterName();
    internal void set_ParameterName(string value);
    internal string get_ParameterText();
    internal Ast get_ParameterAst();
    internal IScriptExtent get_ParameterExtent();
    internal Ast get_ArgumentAst();
    internal IScriptExtent get_ArgumentExtent();
    internal object get_ArgumentValue();
    internal bool get_ArgumentToBeSplatted();
    internal void SetArgumentValue(Ast ast, object value);
    internal IScriptExtent get_ErrorExtent();
    internal static CommandParameterInternal CreateParameter(string parameterName, string parameterText, Ast ast);
    internal static CommandParameterInternal CreateArgument(object value, Ast ast, bool splatted);
    internal static CommandParameterInternal CreateParameterWithArgument(Ast parameterAst, string parameterName, string parameterText, Ast argumentAst, object value, bool spaceAfterParameter, bool fromSplatting);
    internal bool IsDashQuestion();
}
public class System.Management.Automation.CommandParameterSetInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CommandParameterInfo> <Parameters>k__BackingField;
    public string Name { get; }
    public bool IsDefault { get; }
    public ReadOnlyCollection`1<CommandParameterInfo> Parameters { get; private set; }
    internal CommandParameterSetInfo(string name, bool isDefaultParameterSet, UInt32 parameterSetFlag, MergedCommandParameterMetadata parameterMetadata);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CommandParameterInfo> get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(ReadOnlyCollection`1<CommandParameterInfo> value);
    public virtual string ToString();
    internal void GenerateParametersInDisplayOrder(Action`1<CommandParameterInfo> parameterAction, Action`1<string> commonParameterAction);
    private static void AppendFormatCommandParameterInfo(CommandParameterInfo parameter, StringBuilder result);
    internal static string GetParameterTypeString(Type type, IEnumerable`1<Attribute> attributes);
    private void Initialize(MergedCommandParameterMetadata parameterMetadata, UInt32 parameterSetFlag);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.CommandPathSearch : object {
    [TraceSourceAttribute("CommandSearch", "CommandSearch")]
private static PSTraceSource s_tracer;
    private LookupPathCollection _lookupPaths;
    private IEnumerator`1<string> _lookupPathsEnumerator;
    private IEnumerable`1<string> _currentDirectoryResults;
    private IEnumerator`1<string> _currentDirectoryResultsEnumerator;
    private IEnumerable`1<string> _patterns;
    private IEnumerator`1<string> _patternEnumerator;
    private ExecutionContext _context;
    private bool _justReset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Func`2<String[], IEnumerable`1<string>> _postProcessEnumeratedFiles;
    private String[] _orderedPathExt;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Collection`1<string> _acceptableCommandNames;
    [NullableAttribute("2")]
private FuzzyMatcher _fuzzyMatcher;
    private string System.Collections.Generic.IEnumerator<System.String>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal CommandPathSearch(string commandName, LookupPathCollection lookupPaths, ExecutionContext context, Collection`1<string> acceptableCommandNames, FuzzyMatcher fuzzyMatcher);
    private static CommandPathSearch();
    private void ResolveCurrentDirectoryInLookupPaths();
    private sealed virtual override IEnumerator`1<string> System.Collections.Generic.IEnumerable<System.String>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override string System.Collections.Generic.IEnumerator<System.String>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private void GetNewDirectoryResults(string pattern, string directory);
    private IEnumerable`1<string> CheckAgainstAcceptableCommandNames(String[] fileNames);
    private IEnumerable`1<string> JustCheckExtensions(String[] fileNames);
}
internal class System.Management.Automation.CommandProcessor : CommandProcessorBase {
    private CmdletParameterBinderController _cmdletParameterBinderController;
    private ObsoleteAttribute _obsoleteAttribute;
    private bool _firstCallToRead;
    private bool _bailInNextCall;
    private static ConcurrentDictionary`2<Type, Func`1<Cmdlet>> s_constructInstanceCache;
    internal CmdletParameterBinderController CmdletParameterBinderController { get; }
    internal ObsoleteAttribute ObsoleteAttribute { get; }
    private static CommandProcessor();
    internal CommandProcessor(CmdletInfo cmdletInfo, ExecutionContext context);
    internal CommandProcessor(IScriptCommandInfo scriptCommandInfo, ExecutionContext context, bool useLocalScope, bool fromScriptFile, SessionStateInternal sessionState);
    internal ParameterBinderController NewParameterBinderController(InternalCommand command);
    internal CmdletParameterBinderController get_CmdletParameterBinderController();
    internal virtual ObsoleteAttribute get_ObsoleteAttribute();
    internal void BindCommandLineParameters();
    internal virtual void Prepare(IDictionary psDefaultParameterValues);
    protected virtual void OnSetCurrentScope();
    protected virtual void OnRestorePreviousScope();
    internal virtual void DoBegin();
    internal virtual void ProcessRecord();
    internal sealed virtual bool Read();
    private void WriteInputObjectError(object inputObject, string resourceString, string errorId, Object[] args);
    private bool ProcessInputPipelineObject(object inputObject);
    private static Cmdlet ConstructInstance(Type type);
    private void Init(CmdletInfo cmdletInformation);
    private void Init(IScriptCommandInfo scriptCommandInfo);
    private void InitCommon();
    internal virtual bool IsHelpRequested(String& helpTarget, HelpCategory& helpCategory);
}
internal abstract class System.Management.Automation.CommandProcessorBase : object {
    private InternalCommand _command;
    internal bool RanBeginAlready;
    internal bool _addedToPipelineAlready;
    [CompilerGeneratedAttribute]
private CommandInfo <CommandInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasCleanBlock>k__BackingField;
    protected bool _fromScriptFile;
    [CompilerGeneratedAttribute]
private bool <RedirectShellErrorOutputPipe>k__BackingField;
    private static string FQIDCommandObsolete;
    protected MshCommandRuntime commandRuntime;
    protected bool _useLocalScope;
    protected ExecutionContext _context;
    [CompilerGeneratedAttribute]
private Guid <PipelineActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateInternal <CommandSessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateScope <CommandScope>k__BackingField;
    private SessionStateScope _previousScope;
    private SessionStateInternal _previousCommandSessionState;
    internal Collection`1<CommandParameterInternal> arguments;
    private bool _firstCallToRead;
    private bool _disposed;
    internal bool AddedToPipelineAlready { get; internal set; }
    internal CommandInfo CommandInfo { get; internal set; }
    internal bool HasCleanBlock { get; }
    public bool FromScriptFile { get; }
    internal bool RedirectShellErrorOutputPipe { get; internal set; }
    internal InternalCommand Command { get; internal set; }
    internal ObsoleteAttribute ObsoleteAttribute { get; }
    internal MshCommandRuntime CommandRuntime { get; internal set; }
    internal bool UseLocalScope { get; internal set; }
    internal ExecutionContext Context { get; internal set; }
    internal Guid PipelineActivityId { get; internal set; }
    internal SessionStateInternal CommandSessionState { get; internal set; }
    protected internal SessionStateScope CommandScope { get; protected set; }
    internal CommandProcessorBase(CommandInfo commandInfo);
    internal bool get_AddedToPipelineAlready();
    internal void set_AddedToPipelineAlready(bool value);
    [CompilerGeneratedAttribute]
internal CommandInfo get_CommandInfo();
    [CompilerGeneratedAttribute]
internal void set_CommandInfo(CommandInfo value);
    [CompilerGeneratedAttribute]
internal bool get_HasCleanBlock();
    public bool get_FromScriptFile();
    [CompilerGeneratedAttribute]
internal bool get_RedirectShellErrorOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_RedirectShellErrorOutputPipe(bool value);
    internal InternalCommand get_Command();
    internal void set_Command(InternalCommand value);
    internal virtual ObsoleteAttribute get_ObsoleteAttribute();
    internal MshCommandRuntime get_CommandRuntime();
    internal void set_CommandRuntime(MshCommandRuntime value);
    internal bool get_UseLocalScope();
    internal void set_UseLocalScope(bool value);
    protected static void ValidateCompatibleLanguageMode(ScriptBlock scriptBlock, ExecutionContext context, InvocationInfo invocationInfo);
    internal ExecutionContext get_Context();
    internal void set_Context(ExecutionContext value);
    [CompilerGeneratedAttribute]
internal Guid get_PipelineActivityId();
    [CompilerGeneratedAttribute]
internal void set_PipelineActivityId(Guid value);
    internal virtual bool IsHelpRequested(String& helpTarget, HelpCategory& helpCategory);
    internal static CommandProcessorBase CreateGetHelpCommandProcessor(ExecutionContext context, string helpTarget, HelpCategory helpCategory);
    internal bool IsPipelineInputExpected();
    [CompilerGeneratedAttribute]
internal SessionStateInternal get_CommandSessionState();
    [CompilerGeneratedAttribute]
internal void set_CommandSessionState(SessionStateInternal value);
    [CompilerGeneratedAttribute]
protected internal SessionStateScope get_CommandScope();
    [CompilerGeneratedAttribute]
protected void set_CommandScope(SessionStateScope value);
    protected virtual void OnSetCurrentScope();
    protected virtual void OnRestorePreviousScope();
    internal void SetCurrentScopeToExecutionScope();
    internal void RestorePreviousScope();
    internal void AddParameter(CommandParameterInternal parameter);
    internal abstract virtual void Prepare(IDictionary psDefaultParameterValues);
    private void HandleObsoleteCommand(ObsoleteAttribute obsoleteAttr);
    internal void DoPrepare(IDictionary psDefaultParameterValues);
    internal virtual void DoBegin();
    internal abstract virtual void ProcessRecord();
    internal void DoExecute();
    internal virtual void Complete();
    internal void DoComplete();
    protected virtual void CleanResource();
    internal void DoCleanup();
    internal void ReportCleanupError(Exception exception);
    public virtual string ToString();
    internal virtual bool Read();
    internal PipelineStoppedException ManageInvocationException(Exception e);
    internal void ManageScriptException(RuntimeException e);
    internal void ForgetScriptException();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
internal abstract class System.Management.Automation.CommandRedirection : object {
    [CompilerGeneratedAttribute]
private RedirectionStream <FromStream>k__BackingField;
    internal RedirectionStream FromStream { get; }
    protected CommandRedirection(RedirectionStream from);
    [CompilerGeneratedAttribute]
internal RedirectionStream get_FromStream();
    internal abstract virtual void Bind(PipelineProcessor pipelineProcessor, CommandProcessorBase commandProcessor, ExecutionContext context);
    internal void UnbindForExpression(FunctionContext funcContext, Pipe[] pipes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class System.Management.Automation.CommandSearcher : object {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerator`1<CmdletInfo> _matchingCmdlet;
    [NullableAttribute("1")]
private string _commandName;
    private SearchResolutionOptions _commandResolutionOptions;
    private CommandTypes _commandTypes;
    private CommandPathSearch _pathSearcher;
    [NullableAttribute("1")]
private ExecutionContext _context;
    private FuzzyMatcher _fuzzyMatcher;
    private CommandOrigin _commandOrigin;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private IEnumerator`1<AliasInfo> _matchingAlias;
    private IEnumerator`1<CommandInfo> _matchingFunctionEnumerator;
    private CommandInfo _currentMatch;
    private bool _canDoPathLookup;
    private CanDoPathLookupResult _canDoPathLookupResult;
    private SearchState _currentState;
    [NullableAttribute("1")]
private CommandInfo System.Collections.Generic.IEnumerator<System.Management.Automation.CommandInfo>.Current { get; }
    [NullableAttribute("1")]
private object System.Collections.IEnumerator.Current { get; }
    internal CommandOrigin CommandOrigin { get; internal set; }
    [NullableContextAttribute("1")]
internal CommandSearcher(string commandName, SearchResolutionOptions options, CommandTypes commandTypes, ExecutionContext context, FuzzyMatcher fuzzyMatcher);
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator`1<CommandInfo> System.Collections.Generic.IEnumerable<System.Management.Automation.CommandInfo>.GetEnumerator();
    [NullableContextAttribute("1")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    private CommandInfo SearchForAliases();
    private CommandInfo SearchForFunctions();
    private CommandInfo SearchForCmdlets();
    private CommandInfo ProcessBuiltinScriptState();
    private CommandInfo ProcessPathResolutionState();
    private CommandInfo ProcessQualifiedFileSystemState();
    private CommandInfo ProcessPathSearchState();
    [NullableContextAttribute("1")]
private sealed virtual override CommandInfo System.Collections.Generic.IEnumerator<System.Management.Automation.CommandInfo>.get_Current();
    [NullableContextAttribute("1")]
private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
    private CommandInfo GetNextFromPath();
    private Collection`1<string> GetNextFromPathUsingWildcards(string command, ProviderInfo& provider);
    [NullableContextAttribute("1")]
private static bool checkPath(string path, string commandName);
    [NullableContextAttribute("1")]
private CommandInfo GetInfoFromPath(string path);
    private CommandInfo GetNextAlias();
    private CommandInfo GetNextFunction();
    [NullableContextAttribute("1")]
private static bool ShouldSkipCommandResolutionForConstrainedLanguage(CommandInfo result, ExecutionContext executionContext);
    [NullableContextAttribute("1")]
private AliasInfo GetAliasFromModules(string command);
    [NullableContextAttribute("1")]
private CommandInfo GetFunctionFromModules(string command);
    [NullableContextAttribute("1")]
private PSModuleInfo GetImportedModuleByName(string moduleName);
    [NullableContextAttribute("1")]
private CommandInfo GetFunction(string function);
    private CmdletInfo GetNextCmdlet();
    private static CmdletInfo traceResult(CmdletInfo result);
    private string DoPowerShellRelativePathLookup();
    private string ResolvePSPath(string path);
    private string GetNextLiteralPathThatExistsAndHandleExceptions(string command, ProviderInfo& provider);
    private string GetNextLiteralPathThatExists(string command, ProviderInfo& provider);
    [NullableContextAttribute("1")]
internal LookupPathCollection ConstructSearchPatternsFromName(string name, bool commandDiscovery);
    [NullableContextAttribute("1")]
private static bool IsQualifiedPSPath(string commandName);
    [NullableContextAttribute("1")]
private static CanDoPathLookupResult CanDoPathLookup(string possiblePath);
    private void setupPathSearcher();
    public sealed virtual void Reset();
    internal CommandOrigin get_CommandOrigin();
    internal void set_CommandOrigin(CommandOrigin value);
}
internal enum System.Management.Automation.CommandState : Enum {
    public int value__;
    public static CommandState Started;
    public static CommandState Stopped;
    public static CommandState Terminated;
}
[FlagsAttribute]
public enum System.Management.Automation.CommandTypes : Enum {
    public int value__;
    public static CommandTypes Alias;
    public static CommandTypes Function;
    public static CommandTypes Filter;
    public static CommandTypes Cmdlet;
    public static CommandTypes ExternalScript;
    public static CommandTypes Application;
    public static CommandTypes Script;
    public static CommandTypes Configuration;
    public static CommandTypes All;
}
internal class System.Management.Automation.ComMethod : object {
    private Collection`1<int> _methods;
    private ITypeInfo _typeInfo;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; }
    internal ComMethod(ITypeInfo typeinfo, string name);
    [CompilerGeneratedAttribute]
internal string get_Name();
    internal void AddFuncDesc(int index);
    internal Collection`1<string> MethodDefinitions();
    internal object InvokeMethod(PSMethod method, Object[] arguments);
}
internal class System.Management.Automation.ComMethodInformation : MethodInformation {
    internal Type ReturnType;
    internal int DispId;
    internal INVOKEKIND InvokeKind;
    internal ComMethodInformation(bool hasvarargs, bool hasoptional, ParameterInformation[] arguments, Type returnType, int dispId, INVOKEKIND invokekind);
}
internal class System.Management.Automation.CompiledCommandParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PSTypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <DeclaringType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDynamic>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterCollectionTypeInformation <CollectionTypeInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Attribute> <CompiledAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ArgumentTransformationAttribute[] <ArgumentTransformationAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidateArgumentsAttribute[] <ValidationAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ObsoleteAttribute <ObsoleteAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsNullArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CannotBeNull>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsEmptyStringArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowsEmptyCollectionArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInAllSets>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPipelineParameterInSomeParameterSet>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMandatoryInSomeParameterSet>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ParameterSetFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<object, object> <Setter>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ParameterSetSpecificMetadata> <ParameterSetData>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    internal string Name { get; }
    internal string PSTypeName { get; private set; }
    internal Type Type { get; }
    internal Type DeclaringType { get; }
    internal bool IsDynamic { get; }
    internal ParameterCollectionTypeInformation CollectionTypeInformation { get; }
    internal Collection`1<Attribute> CompiledAttributes { get; }
    internal ArgumentTransformationAttribute[] ArgumentTransformationAttributes { get; }
    internal ValidateArgumentsAttribute[] ValidationAttributes { get; }
    internal ObsoleteAttribute ObsoleteAttribute { get; private set; }
    internal bool AllowsNullArgument { get; private set; }
    internal bool CannotBeNull { get; private set; }
    internal bool AllowsEmptyStringArgument { get; private set; }
    internal bool AllowsEmptyCollectionArgument { get; private set; }
    internal bool IsInAllSets { get; internal set; }
    internal bool IsPipelineParameterInSomeParameterSet { get; private set; }
    internal bool IsMandatoryInSomeParameterSet { get; private set; }
    internal UInt32 ParameterSetFlags { get; internal set; }
    internal Action`2<object, object> Setter { get; internal set; }
    internal Dictionary`2<string, ParameterSetSpecificMetadata> ParameterSetData { get; }
    internal String[] Aliases { get; }
    internal CompiledCommandParameter(RuntimeDefinedParameter runtimeDefinedParameter, bool processingDynamicParameters);
    internal CompiledCommandParameter(MemberInfo member, bool processingDynamicParameters);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal string get_PSTypeName();
    [CompilerGeneratedAttribute]
private void set_PSTypeName(string value);
    [CompilerGeneratedAttribute]
internal Type get_Type();
    [CompilerGeneratedAttribute]
internal Type get_DeclaringType();
    [CompilerGeneratedAttribute]
internal bool get_IsDynamic();
    [CompilerGeneratedAttribute]
internal ParameterCollectionTypeInformation get_CollectionTypeInformation();
    [CompilerGeneratedAttribute]
internal Collection`1<Attribute> get_CompiledAttributes();
    [CompilerGeneratedAttribute]
internal ArgumentTransformationAttribute[] get_ArgumentTransformationAttributes();
    [CompilerGeneratedAttribute]
internal ValidateArgumentsAttribute[] get_ValidationAttributes();
    [CompilerGeneratedAttribute]
internal ObsoleteAttribute get_ObsoleteAttribute();
    [CompilerGeneratedAttribute]
private void set_ObsoleteAttribute(ObsoleteAttribute value);
    [CompilerGeneratedAttribute]
internal bool get_AllowsNullArgument();
    [CompilerGeneratedAttribute]
private void set_AllowsNullArgument(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CannotBeNull();
    [CompilerGeneratedAttribute]
private void set_CannotBeNull(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AllowsEmptyStringArgument();
    [CompilerGeneratedAttribute]
private void set_AllowsEmptyStringArgument(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AllowsEmptyCollectionArgument();
    [CompilerGeneratedAttribute]
private void set_AllowsEmptyCollectionArgument(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsInAllSets();
    [CompilerGeneratedAttribute]
internal void set_IsInAllSets(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsPipelineParameterInSomeParameterSet();
    [CompilerGeneratedAttribute]
private void set_IsPipelineParameterInSomeParameterSet(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsMandatoryInSomeParameterSet();
    [CompilerGeneratedAttribute]
private void set_IsMandatoryInSomeParameterSet(bool value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ParameterSetFlags();
    [CompilerGeneratedAttribute]
internal void set_ParameterSetFlags(UInt32 value);
    [CompilerGeneratedAttribute]
internal Action`2<object, object> get_Setter();
    [CompilerGeneratedAttribute]
internal void set_Setter(Action`2<object, object> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ParameterSetSpecificMetadata> get_ParameterSetData();
    [CompilerGeneratedAttribute]
internal String[] get_Aliases();
    internal bool DoesParameterSetTakePipelineInput(UInt32 validParameterSetFlags);
    internal ParameterSetSpecificMetadata GetParameterSetData(UInt32 parameterSetFlag);
    [IteratorStateMachineAttribute("System.Management.Automation.CompiledCommandParameter/<GetMatchingParameterSetData>d__78")]
internal IEnumerable`1<ParameterSetSpecificMetadata> GetMatchingParameterSetData(UInt32 parameterSetFlags);
    private void ProcessAttribute(string memberName, Attribute attribute, Collection`1& validationAttributes, Collection`1& argTransformationAttributes, String[]& aliases);
    private void ProcessParameterAttribute(string parameterName, ParameterAttribute parameter);
    public virtual string ToString();
}
internal class System.Management.Automation.CompiledScriptBlockData : object {
    private string _scriptText;
    private IParameterMetadataProvider _ast;
    [CompilerGeneratedAttribute]
private Type <LocalsMutableTupleType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <UnoptimizedLocalsMutableTupleType>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<MutableTuple> <LocalsMutableTupleCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<MutableTuple> <UnoptimizedLocalsMutableTupleCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, int> <NameToIndexMap>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <DynamicParamBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <UnoptimizedDynamicParamBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <BeginBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <UnoptimizedBeginBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <ProcessBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <UnoptimizedProcessBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <EndBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <UnoptimizedEndBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <CleanBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<FunctionContext> <UnoptimizedCleanBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent[] <SequencePoints>k__BackingField;
    private RuntimeDefinedParameterDictionary _runtimeDefinedParameterDictionary;
    private Attribute[] _attributes;
    private bool _usesCmdletBinding;
    private bool _compiledOptimized;
    private bool _compiledUnoptimized;
    private bool _hasSuspiciousContent;
    private Nullable`1<bool> _isProductCode;
    [CompilerGeneratedAttribute]
private bool <DebuggerHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DebuggerStepThrough>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasLogged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFilter>k__BackingField;
    private MergedCommandParameterMetadata _parameterMetadata;
    private ExperimentalAttribute _expAttribute;
    internal IParameterMetadataProvider Ast { get; }
    internal Type LocalsMutableTupleType { get; internal set; }
    internal Type UnoptimizedLocalsMutableTupleType { get; internal set; }
    internal Func`1<MutableTuple> LocalsMutableTupleCreator { get; internal set; }
    internal Func`1<MutableTuple> UnoptimizedLocalsMutableTupleCreator { get; internal set; }
    internal Dictionary`2<string, int> NameToIndexMap { get; internal set; }
    internal Action`1<FunctionContext> DynamicParamBlock { get; internal set; }
    internal Action`1<FunctionContext> UnoptimizedDynamicParamBlock { get; internal set; }
    internal Action`1<FunctionContext> BeginBlock { get; internal set; }
    internal Action`1<FunctionContext> UnoptimizedBeginBlock { get; internal set; }
    internal Action`1<FunctionContext> ProcessBlock { get; internal set; }
    internal Action`1<FunctionContext> UnoptimizedProcessBlock { get; internal set; }
    internal Action`1<FunctionContext> EndBlock { get; internal set; }
    internal Action`1<FunctionContext> UnoptimizedEndBlock { get; internal set; }
    internal Action`1<FunctionContext> CleanBlock { get; internal set; }
    internal Action`1<FunctionContext> UnoptimizedCleanBlock { get; internal set; }
    internal IScriptExtent[] SequencePoints { get; internal set; }
    internal bool DebuggerHidden { get; internal set; }
    internal bool DebuggerStepThrough { get; internal set; }
    internal Guid Id { get; private set; }
    internal bool HasLogged { get; internal set; }
    internal bool SkipLogging { get; internal set; }
    internal bool IsFilter { get; }
    internal bool IsProductCode { get; }
    internal bool HasSuspiciousContent { get; internal set; }
    internal bool UsesCmdletBinding { get; }
    internal RuntimeDefinedParameterDictionary RuntimeDefinedParameters { get; }
    internal CmdletBindingAttribute CmdletBindingAttribute { get; }
    internal ObsoleteAttribute ObsoleteAttribute { get; }
    internal ExperimentalAttribute ExperimentalAttribute { get; }
    internal CompiledScriptBlockData(IParameterMetadataProvider ast, bool isFilter);
    internal CompiledScriptBlockData(string scriptText, bool isProductCode);
    internal bool Compile(bool optimized);
    private void InitializeMetadata();
    private void CompileUnoptimized();
    private void CompileOptimized();
    private void ReallyCompile(bool optimize);
    private void PerformSecurityChecks();
    internal IParameterMetadataProvider get_Ast();
    private IParameterMetadataProvider DelayParseScriptText();
    [CompilerGeneratedAttribute]
internal Type get_LocalsMutableTupleType();
    [CompilerGeneratedAttribute]
internal void set_LocalsMutableTupleType(Type value);
    [CompilerGeneratedAttribute]
internal Type get_UnoptimizedLocalsMutableTupleType();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedLocalsMutableTupleType(Type value);
    [CompilerGeneratedAttribute]
internal Func`1<MutableTuple> get_LocalsMutableTupleCreator();
    [CompilerGeneratedAttribute]
internal void set_LocalsMutableTupleCreator(Func`1<MutableTuple> value);
    [CompilerGeneratedAttribute]
internal Func`1<MutableTuple> get_UnoptimizedLocalsMutableTupleCreator();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedLocalsMutableTupleCreator(Func`1<MutableTuple> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, int> get_NameToIndexMap();
    [CompilerGeneratedAttribute]
internal void set_NameToIndexMap(Dictionary`2<string, int> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_DynamicParamBlock();
    [CompilerGeneratedAttribute]
internal void set_DynamicParamBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_UnoptimizedDynamicParamBlock();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedDynamicParamBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_BeginBlock();
    [CompilerGeneratedAttribute]
internal void set_BeginBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_UnoptimizedBeginBlock();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedBeginBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_ProcessBlock();
    [CompilerGeneratedAttribute]
internal void set_ProcessBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_UnoptimizedProcessBlock();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedProcessBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_EndBlock();
    [CompilerGeneratedAttribute]
internal void set_EndBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_UnoptimizedEndBlock();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedEndBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_CleanBlock();
    [CompilerGeneratedAttribute]
internal void set_CleanBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal Action`1<FunctionContext> get_UnoptimizedCleanBlock();
    [CompilerGeneratedAttribute]
internal void set_UnoptimizedCleanBlock(Action`1<FunctionContext> value);
    [CompilerGeneratedAttribute]
internal IScriptExtent[] get_SequencePoints();
    [CompilerGeneratedAttribute]
internal void set_SequencePoints(IScriptExtent[] value);
    [CompilerGeneratedAttribute]
internal bool get_DebuggerHidden();
    [CompilerGeneratedAttribute]
internal void set_DebuggerHidden(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DebuggerStepThrough();
    [CompilerGeneratedAttribute]
internal void set_DebuggerStepThrough(bool value);
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
private void set_Id(Guid value);
    [CompilerGeneratedAttribute]
internal bool get_HasLogged();
    [CompilerGeneratedAttribute]
internal void set_HasLogged(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SkipLogging();
    [CompilerGeneratedAttribute]
internal void set_SkipLogging(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsFilter();
    internal bool get_IsProductCode();
    internal bool GetIsConfiguration();
    internal bool get_HasSuspiciousContent();
    internal void set_HasSuspiciousContent(bool value);
    internal List`1<Attribute> GetAttributes();
    internal bool get_UsesCmdletBinding();
    internal RuntimeDefinedParameterDictionary get_RuntimeDefinedParameters();
    internal CmdletBindingAttribute get_CmdletBindingAttribute();
    internal ObsoleteAttribute get_ObsoleteAttribute();
    internal ExperimentalAttribute get_ExperimentalAttribute();
    public MergedCommandParameterMetadata GetParameterMetadata(ScriptBlock scriptBlock);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal static bool <PerformSecurityChecks>g__IsScriptBlockInFactASafeHashtable|7_0(<>c__DisplayClass7_0& );
}
internal enum System.Management.Automation.CompileInterpretChoice : Enum {
    public int value__;
    public static CompileInterpretChoice NeverCompile;
    public static CompileInterpretChoice AlwaysCompile;
    public static CompileInterpretChoice CompileOnDemand;
}
internal class System.Management.Automation.CompletionAnalysis : object {
    private Ast _ast;
    private Token[] _tokens;
    private IScriptPosition _cursorPosition;
    private Hashtable _options;
    private static String[] s_usingKeywords;
    internal CompletionAnalysis(Ast ast, Token[] tokens, IScriptPosition cursorPosition, Hashtable options);
    private static CompletionAnalysis();
    private static bool IsInterestingToken(Token token);
    private static bool IsCursorWithinOrJustAfterExtent(IScriptPosition cursor, IScriptExtent extent);
    private static bool IsCursorRightAfterExtent(IScriptPosition cursor, IScriptExtent extent);
    private static bool IsCursorAfterExtentAndInTheSameLine(IScriptPosition cursor, IScriptExtent extent);
    private static bool IsCursorBeforeExtent(IScriptPosition cursor, IScriptExtent extent);
    private static bool IsCursorAfterExtent(IScriptPosition cursor, IScriptExtent extent);
    private static bool IsCursorOutsideOfExtent(IScriptPosition cursor, IScriptExtent extent);
    internal static AstAnalysisContext ExtractAstContext(Ast inputAst, Token[] inputTokens, IScriptPosition cursor);
    internal CompletionContext CreateCompletionContext(PowerShell powerShell);
    internal CompletionContext CreateCompletionContext(TypeInferenceContext typeInferenceContext);
    private CompletionContext InitializeCompletionContext(TypeInferenceContext typeInferenceContext);
    private static Token InterstingTokenAtCursorOrDefault(IReadOnlyList`1<Token> tokens, IScriptPosition cursorPosition);
    private static Token InterstingTokenBeforeCursorOrDefault(IReadOnlyList`1<Token> tokens, IScriptPosition cursorPosition);
    private static Ast GetLastAstAtCursor(ScriptBlockAst scriptBlockAst, IScriptPosition cursorPosition);
    private static bool CompleteAgainstSwitchFile(Ast lastAst, Token tokenBeforeCursor);
    private static bool CompleteOperator(Token tokenAtCursor, Ast lastAst);
    private static bool CompleteAgainstStatementFlags(Ast scriptAst, Ast lastAst, Token token, TokenKind& kind);
    private static bool IsTokenTheSame(Token x, Token y);
    internal List`1<CompletionResult> GetResults(PowerShell powerShell, Int32& replacementIndex, Int32& replacementLength);
    internal List`1<CompletionResult> GetResultHelper(CompletionContext completionContext, Int32& replacementIndex, Int32& replacementLength);
    private static List`1<CompletionResult> GetResultForHashtable(CompletionContext completionContext);
    private static bool CheckForPendingAssignment(HashtableAst hashTableAst);
    internal static TypeName FindTypeNameToComplete(ITypeName type, IScriptPosition cursor);
    private static string GetFirstLineSubString(string stringToComplete, Boolean& hasNewLine);
    private static Tuple`2<ExpressionAst, StatementAst> GetHashEntryContainsCursor(IScriptPosition cursor, HashtableAst hashTableAst, bool isCursorInString);
    private static VariableExpressionAst GetVariableFromExpressionAst(ExpressionAst expression, Type& typeConstraint, ValidateSetAttribute& setConstraint);
    private static bool TryGetTypeConstraintOnVariable(CompletionContext completionContext, string variableName, Type& typeConstraint, ValidateSetAttribute& setConstraint);
    private static List`1<CompletionResult> CompletePropertyAssignment(MemberExpressionAst memberExpression, CompletionContext context);
    private static bool TryGetCompletionsForVariableAssignment(CompletionContext completionContext, AssignmentStatementAst assignmentAst, List`1& completions);
    private static List`1<CompletionResult> GetResultForSet(Type typeConstraint, IList`1<string> validValues, CompletionContext completionContext);
    private static List`1<CompletionResult> GetMatchedResults(List`1<string> allValues, CompletionContext completionContext);
    private static string GetQuotedString(string value, CompletionContext completionContext);
    private static List`1<CompletionResult> GetResultForEnum(Type type, CompletionContext completionContext);
    private static List`1<CompletionResult> GetResultForEnumPropertyValueOfDSCResource(CompletionContext completionContext, string stringToComplete, Int32& replacementIndex, Int32& replacementLength, Boolean& shouldContinue);
    private static List`1<CompletionResult> GetResultForString(CompletionContext completionContext, Int32& replacementIndex, Int32& replacementLength);
    private static ConfigurationDefinitionAst GetAncestorConfigurationAstAndKeywordAst(IScriptPosition cursorPosition, Ast ast, DynamicKeywordStatementAst& keywordAst);
    private static List`1<CompletionResult> GetResultForIdentifierInConfiguration(CompletionContext completionContext, ConfigurationDefinitionAst configureAst, DynamicKeywordStatementAst keywordAst, Boolean& matched);
    private static List`1<CompletionResult> GetResultForIdentifier(CompletionContext completionContext, Int32& replacementIndex, Int32& replacementLength);
    private static List`1<CompletionResult> GetResultForAttributeArgument(CompletionContext completionContext, Int32& replacementIndex, Int32& replacementLength);
    private static List`1<CompletionResult> CompleteFileNameAsCommand(CompletionContext completionContext);
    private static List`1<CompletionResult> CompleteLoopLabel(CompletionContext completionContext);
    private static List`1<CompletionResult> CompleteUsingKeywords(int cursorOffset, Token[] tokens, Int32& replacementIndex, Int32& replacementLength);
    private static string GetUsingKeywordToolTip(string keyword);
    [CompilerGeneratedAttribute]
internal static bool <TryGetCompletionsForVariableAssignment>g__TryGetResultForEnum|34_0(Type typeConstraint, CompletionContext completionContext, List`1& completions);
    [CompilerGeneratedAttribute]
internal static bool <TryGetCompletionsForVariableAssignment>g__TryGetResultForSet|34_1(Type typeConstraint, ValidateSetAttribute setConstraint, CompletionContext completionContext1, List`1& completions, <>c__DisplayClass34_0& );
}
public static class System.Management.Automation.CompletionCompleters : object {
    private static HashSet`1<string> s_keywordsToExcludeFromAddingAmpersand;
    private static String[] s_parameterNamesOfImportDSCResource;
    private static ConcurrentDictionary`2<string, IEnumerable`1<string>> s_cimNamespaceAndClassNameToAssociationResultClassNames;
    private static ConcurrentDictionary`2<string, IEnumerable`1<string>> s_cimNamespaceToClassNames;
    private static EnumerationOptions _enumerationOptions;
    private static String[] s_variableScopes;
    private static Char[] s_charactersRequiringQuotes;
    private static HashSet`1<string> s_varModificationCommands;
    private static String[] s_varModificationParameters;
    private static String[] s_outVarParameters;
    private static String[] s_pipelineVariableParameters;
    private static HashSet`1<string> s_localScopeCommandNames;
    private static Lazy`1<SortedSet`1<string>> s_specialVariablesCache;
    private static IReadOnlyDictionary`2<string, string> s_requiresParameters;
    private static IReadOnlyDictionary`2<string, string> s_requiresPSEditions;
    private static IReadOnlyDictionary`2<string, string> s_requiresModuleSpecKeys;
    private static Char[] s_hashtableKeyPrefixes;
    private static IReadOnlyDictionary`2<string, string> s_commentHelpKeywords;
    private static HashSet`1<string> s_commentHelpAllowedDuplicateKeywords;
    private static String[] s_commentHelpForwardCategories;
    private static List`1<Tuple`2<string, string>> s_extensionMethods;
    private static HashSet`1<string> s_dscCollectionVariables;
    private static TypeCompletionMapping[][] s_typeCache;
    private static CompletionCompleters();
    private static void UpdateTypeCacheOnAssemblyLoad(object sender, AssemblyLoadEventArgs args);
    public static IEnumerable`1<CompletionResult> CompleteCommand(string commandName);
    public static IEnumerable`1<CompletionResult> CompleteCommand(string commandName, string moduleName, CommandTypes commandTypes);
    internal static List`1<CompletionResult> CompleteCommand(CompletionContext context);
    private static List`1<CompletionResult> CompleteCommand(CompletionContext context, string moduleName, CommandTypes types);
    internal static CompletionResult GetCommandNameCompletionResult(string name, object command, bool addAmpersandIfNecessary, string quote);
    internal static List`1<CompletionResult> MakeCommandsUnique(IEnumerable`1<PSObject> commandInfoPsObjs, bool includeModulePrefix, bool addAmpersandIfNecessary, string quote);
    internal static List`1<CompletionResult> CompleteModuleName(CompletionContext context, bool loadedModulesOnly, bool skipEditionCheck);
    internal static List`1<CompletionResult> CompleteCommandParameter(CompletionContext context);
    private static List`1<CompletionResult> GetParameterCompletionResults(string parameterName, PseudoBindingInfo bindingInfo, CommandParameterAst parameterAst, bool withColon);
    private static List`1<CompletionResult> GetParameterCompletionResults(string parameterName, UInt32 validParameterSetFlags, IEnumerable`1<MergedCompiledCommandParameter> parameters, bool withColon);
    public static List`1<CompletionResult> CompleteOperator(string wordToComplete);
    private static string GetOperatorDescription(string op);
    internal static List`1<CompletionResult> CompleteCommandArgument(CompletionContext context);
    internal static string ConcatenateStringPathArguments(CommandElementAst stringAst, string partialPath, CompletionContext completionContext);
    private static List`1<CompletionResult> GetArgumentCompletionResultsWithFailedPseudoBinding(CompletionContext context, ArgumentLocation argLocation, CommandAst commandAst);
    private static List`1<CompletionResult> GetArgumentCompletionResultsWithSuccessfulPseudoBinding(CompletionContext context, ArgumentLocation argLocation, CommandAst commandAst);
    private static void CompletePositionalArgument(string commandName, CommandAst commandAst, CompletionContext context, List`1<CompletionResult> result, IEnumerable`1<MergedCompiledCommandParameter> parameters, UInt32 defaultParameterSetFlag, UInt32 validParameterSetFlags, int position, Dictionary`2<string, AstParameterArgumentPair> boundArguments);
    private static void ProcessParameter(string commandName, CommandAst commandAst, CompletionContext context, List`1<CompletionResult> result, MergedCompiledCommandParameter parameter, Dictionary`2<string, AstParameterArgumentPair> boundArguments);
    [IteratorStateMachineAttribute("System.Management.Automation.CompletionCompleters/<NativeCommandArgumentCompletion_InferTypesOfArgument>d__23")]
private static IEnumerable`1<PSTypeName> NativeCommandArgumentCompletion_InferTypesOfArgument(Dictionary`2<string, AstParameterArgumentPair> boundArguments, CommandAst commandAst, CompletionContext context, string parameterName);
    internal static IList`1<string> NativeCommandArgumentCompletion_ExtractSecondaryArgument(Dictionary`2<string, AstParameterArgumentPair> boundArguments, string parameterName);
    private static void NativeCommandArgumentCompletion(string commandName, CompiledCommandParameter parameter, List`1<CompletionResult> result, CommandAst commandAst, CompletionContext context, Dictionary`2<string, AstParameterArgumentPair> boundArguments);
    private static Hashtable GetBoundArgumentsAsHashtable(CompletionContext context);
    private static ScriptBlock GetCustomArgumentCompleter(string optionKey, IEnumerable`1<string> keys, CompletionContext context);
    private static bool InvokeScriptArgumentCompleter(ScriptBlock scriptBlock, string commandName, string parameterName, string wordToComplete, CommandAst commandAst, CompletionContext context, List`1<CompletionResult> resultList);
    private static bool InvokeScriptArgumentCompleter(ScriptBlock scriptBlock, Object[] argumentsToCompleter, List`1<CompletionResult> result);
    private static void RemoveLastNullCompletionResult(List`1<CompletionResult> result);
    private static void NativeCompletionCimCommands(string parameter, Dictionary`2<string, AstParameterArgumentPair> boundArguments, List`1<CompletionResult> result, CommandAst commandAst, CompletionContext context, HashSet`1<string> excludedValues, string commandName);
    private static IEnumerable`1<string> NativeCompletionCimAssociationResultClassName_GetResultClassNames(string cimNamespaceOfSource, string cimClassNameOfSource);
    private static void NativeCompletionCimAssociationResultClassName(string pseudoboundNamespace, string pseudoboundClassName, List`1<CompletionResult> result, CompletionContext context);
    private static void NativeCompletionCimMethodName(string pseudoboundNamespace, string pseudoboundClassName, bool staticMethod, List`1<CompletionResult> result, CompletionContext context);
    private static void NativeCompletionCimMethodArgumentName(string pseudoboundNamespace, string pseudoboundClassName, string pseudoboundMethodName, HashSet`1<string> excludedParameters, List`1<CompletionResult> result, CompletionContext context);
    private static void NativeCompletionCimPropertyName(string pseudoboundNamespace, string pseudoboundClassName, bool includeReadOnly, HashSet`1<string> excludedProperties, List`1<CompletionResult> result, CompletionContext context);
    private static IEnumerable`1<string> NativeCompletionCimClassName_GetClassNames(string targetNamespace);
    private static void NativeCompletionCimClassName(string pseudoBoundNamespace, List`1<CompletionResult> result, CompletionContext context);
    private static void NativeCompletionCimNamespace(List`1<CompletionResult> result, CompletionContext context);
    private static void NativeCompletionGetCommand(CompletionContext context, string moduleName, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionGetHelpCommand(CompletionContext context, string paramName, bool isHelpRelated, List`1<CompletionResult> result);
    private static void NativeCompletionEventLogCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionJobCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionScheduledJobCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionModuleCommands(CompletionContext context, string paramName, List`1<CompletionResult> result, bool loadedModulesOnly, bool isImportModule, bool skipEditionCheck);
    private static void NativeCompletionProcessCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionProviderCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionDriveCommands(CompletionContext context, string psProvider, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionServiceCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionVariableCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionAliasCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionTraceSourceCommands(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionSetLocationCommand(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionNewItemCommand(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionCopyMoveItemCommand(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static void NativeCompletionPathArgument(CompletionContext context, string paramName, List`1<CompletionResult> result);
    private static IEnumerable`1<PSTypeName> GetInferenceTypes(CompletionContext context, CommandAst commandAst);
    private static void NativeCompletionMemberName(CompletionContext context, List`1<CompletionResult> result, CommandAst commandAst, AstParameterArgumentPair parameterInfo, bool propertiesOnly);
    private static void NativeCompletionMemberValue(CompletionContext context, List`1<CompletionResult> result, CommandAst commandAst, string propertyName);
    private static HashSet`1<string> GetParameterValues(AstPair parameter, int cursorOffset);
    private static void NativeCompletionFormatViewName(CompletionContext context, Dictionary`2<string, AstParameterArgumentPair> boundArguments, List`1<CompletionResult> result, CommandAst commandAst, string commandName);
    private static void NativeCompletionTypeName(CompletionContext context, List`1<CompletionResult> result);
    private static AstPair FindTargetPositionalArgument(Collection`1<AstParameterArgumentPair> parsedArguments, int position, AstPair& lastPositionalArgument);
    private static ArgumentLocation FindTargetArgumentLocation(Collection`1<AstParameterArgumentPair> parsedArguments, Token token);
    private static ArgumentLocation GenerateArgumentLocation(AstParameterArgumentPair prev, int position);
    private static ArgumentLocation FindTargetArgumentLocation(Collection`1<AstParameterArgumentPair> parsedArguments, ExpressionAst expAst);
    public static IEnumerable`1<CompletionResult> CompleteFilename(string fileName);
    internal static IEnumerable`1<CompletionResult> CompleteFilename(CompletionContext context);
    internal static IEnumerable`1<CompletionResult> CompleteFilename(CompletionContext context, bool containerOnly, HashSet`1<string> extension);
    private static List`1<CompletionResult> GetFileSystemProviderResults(CompletionContext context, ProviderInfo provider, Collection`1<PSObject> resolvedPaths, string filterText, HashSet`1<string> includedExtensions, bool containersOnly, bool relativePaths, bool literalPaths, bool inputUsedHome, string providerPrefix, StringConstantType stringType);
    private static List`1<CompletionResult> GetDefaultProviderResults(CompletionContext context, ProviderInfo provider, Collection`1<PSObject> resolvedPaths, string filterText, bool containersOnly, bool relativePaths, bool literalPaths, bool inputUsedHome, string providerPrefix, StringConstantType stringType);
    private static string GetChildNameFromPsObject(object psObject, char separator);
    private static string RebuildPathWithVars(string path, string homePath, StringConstantType stringType, bool literalPath, Boolean& quotesAreNeeded);
    private static string EscapePath(string path, StringConstantType stringType, bool literalPath, Boolean& quotesAreNeeded);
    private static void EscapeCharIfNeeded(StringBuilder sb, string path, int index, StringConstantType stringType, bool literalPath, bool useSingleQuoteEscapeRules, Boolean& quotesAreNeeded);
    private static string NewPathCompletionText(string parent, string leaf, StringConstantType stringType, bool containsNestedExpressions, bool forceQuotes, bool addAmpersand);
    internal static List`1<string> GetFileShares(string machine, bool ignoreHidden);
    private static bool CheckFileExtension(string path, HashSet`1<string> extension);
    public static IEnumerable`1<CompletionResult> CompleteVariable(string variableName);
    internal static List`1<CompletionResult> CompleteVariable(CompletionContext context);
    private static void AddUniqueVariable(HashSet`1<string> hashedResults, List`1<CompletionResult> results, string completionText, string listItemText, string tooltip);
    private static SortedSet`1<string> BuildSpecialVariablesCache();
    internal static List`1<CompletionResult> CompleteComment(CompletionContext context, Int32& replacementIndex, Int32& replacementLength);
    private static List`1<CompletionResult> CompleteRequires(CompletionContext context, Int32& replacementIndex, Int32& replacementLength);
    private static List`1<CompletionResult> CompleteCommentHelp(CompletionContext context, Int32& replacementIndex, Int32& replacementLength);
    private static FunctionDefinitionAst GetCommentHelpFunctionTarget(CompletionContext context);
    private static List`1<CompletionResult> CompleteCommentParameterValue(CompletionContext context, string wordToComplete);
    internal static List`1<CompletionResult> CompleteMember(CompletionContext context, bool static, Int32& replacementLength);
    internal static List`1<CompletionResult> CompleteComparisonOperatorValues(CompletionContext context, ExpressionAst operatorLeftValue);
    private static void CompleteExtensionMethods(string memberName, List`1<CompletionResult> results, bool addMethodParenthesis);
    private static void CompleteExtensionMethods(WildcardPattern pattern, List`1<CompletionResult> results, bool addMethodParenthesis);
    private static bool IsConfigurationDataVariable(ExpressionAst targetExpr);
    private static bool IsInDscContext(ExpressionAst expression);
    internal static List`1<CompletionResult> CompleteIndexExpression(CompletionContext context, ExpressionAst indexTarget);
    private static void CompleteFormatViewByInferredType(CompletionContext context, String[] inferredTypeNames, List`1<CompletionResult> results, string commandName);
    internal static void CompleteMemberByInferredType(TypeInferenceContext context, IEnumerable`1<PSTypeName> inferredTypes, List`1<CompletionResult> results, string memberName, Func`2<object, bool> filter, bool isStatic, HashSet`1<string> excludedMembers, bool addMethodParenthesis, bool ignoreTypesWithoutDefaultConstructor);
    private static void AddInferredMember(object member, WildcardPattern memberNamePattern, List`1<CompletionResult> results, HashSet`1<string> excludedMembers, bool addMethodParenthesis);
    private static string GetCimPropertyToString(CimPropertyDeclaration cimProperty);
    private static bool IsWriteablePropertyMember(object member);
    internal static bool IsPropertyMember(object member);
    private static bool IsMemberHidden(object member);
    private static bool IsConstructor(object member);
    private static TypeCompletionMapping[][] InitializeTypeCache();
    private static void HandleNamespace(Dictionary`2<string, TypeCompletionMapping> entryCache, string namespace);
    private static void HandleType(Dictionary`2<string, TypeCompletionMapping> entryCache, string fullTypeName, string shortTypeName, Type actualType);
    internal static List`1<CompletionResult> CompleteNamespace(CompletionContext context, string prefix, string suffix);
    public static IEnumerable`1<CompletionResult> CompleteType(string typeName);
    internal static List`1<CompletionResult> CompleteType(CompletionContext context, string prefix, string suffix);
    private static string GetNamespaceToRemove(CompletionContext context, TypeCompletionBase completion);
    internal static List`1<CompletionResult> CompleteHelpTopics(CompletionContext context);
    internal static List`1<CompletionResult> CompleteStatementFlags(TokenKind kind, string wordToComplete);
    internal static List`1<CompletionResult> CompleteHashtableKeyForDynamicKeyword(CompletionContext completionContext, DynamicKeywordStatementAst ast, HashtableAst hashtableAst);
    private static PSTypeName GetNestedHashtableKeyType(TypeInferenceContext typeContext, PSTypeName parentType, IList`1<string> nestedKeys);
    internal static List`1<CompletionResult> CompleteHashtableKey(CompletionContext completionContext, HashtableAst hashtableAst);
    private static List`1<CompletionResult> GetSpecialHashTableKeyMembers(HashSet`1<string> excludedKeys, string wordToComplete, String[] keys);
    internal static bool IsPathSafelyExpandable(ExpandableStringExpressionAst expandableStringAst, string extraText, ExecutionContext executionContext, String& expandedString);
    internal static string CombineVariableWithPartialPath(VariableExpressionAst variableAst, string extraText, ExecutionContext executionContext);
    internal static string HandleDoubleAndSingleQuote(String& wordToComplete);
    internal static bool IsSplattedVariable(Ast targetExpr);
    internal static void CompleteMemberHelper(bool static, string memberName, ExpressionAst targetExpr, CompletionContext context, List`1<CompletionResult> results);
    private static bool IsValueEnumerable(object value);
    private static bool IsStaticTypeEnumerable(Type type);
    private static bool CompletionRequiresQuotes(string completion, bool escape);
    private static bool ProviderSpecified(string path);
    private static Type GetEffectiveParameterType(Type type);
    private static bool TurnOnLiteralPathOption(CompletionContext completionContext);
    internal static bool IsAmpersandNeeded(CompletionContext context, bool defaultChoice);
    [CompilerGeneratedAttribute]
internal static List`1<CompletionResult> <CompleteCommand>g__ExecuteGetCommandCommand|5_0(bool useModulePrefix, <>c__DisplayClass5_0& );
}
internal class System.Management.Automation.CompletionContext : object {
    [CompilerGeneratedAttribute]
private List`1<Ast> <RelatedAsts>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <TokenAtCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <TokenBeforeCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptPosition <CursorPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShellExecutionHelper <Helper>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScriptBlock> <CustomArgumentCompleters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScriptBlock> <NativeArgumentCompleters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WordToComplete>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplacementIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ReplacementLength>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionContext <ExecutionContext>k__BackingField;
    [CompilerGeneratedAttribute]
private PseudoBindingInfo <PseudoBindingInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInferenceContext <TypeInferenceContext>k__BackingField;
    internal List`1<Ast> RelatedAsts { get; internal set; }
    internal Token TokenAtCursor { get; internal set; }
    internal Token TokenBeforeCursor { get; internal set; }
    internal IScriptPosition CursorPosition { get; internal set; }
    internal PowerShellExecutionHelper Helper { get; internal set; }
    internal Hashtable Options { get; internal set; }
    internal Dictionary`2<string, ScriptBlock> CustomArgumentCompleters { get; internal set; }
    internal Dictionary`2<string, ScriptBlock> NativeArgumentCompleters { get; internal set; }
    internal string WordToComplete { get; internal set; }
    internal int ReplacementIndex { get; internal set; }
    internal int ReplacementLength { get; internal set; }
    internal ExecutionContext ExecutionContext { get; internal set; }
    internal PseudoBindingInfo PseudoBindingInfo { get; internal set; }
    internal TypeInferenceContext TypeInferenceContext { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<Ast> get_RelatedAsts();
    [CompilerGeneratedAttribute]
internal void set_RelatedAsts(List`1<Ast> value);
    [CompilerGeneratedAttribute]
internal Token get_TokenAtCursor();
    [CompilerGeneratedAttribute]
internal void set_TokenAtCursor(Token value);
    [CompilerGeneratedAttribute]
internal Token get_TokenBeforeCursor();
    [CompilerGeneratedAttribute]
internal void set_TokenBeforeCursor(Token value);
    [CompilerGeneratedAttribute]
internal IScriptPosition get_CursorPosition();
    [CompilerGeneratedAttribute]
internal void set_CursorPosition(IScriptPosition value);
    [CompilerGeneratedAttribute]
internal PowerShellExecutionHelper get_Helper();
    [CompilerGeneratedAttribute]
internal void set_Helper(PowerShellExecutionHelper value);
    [CompilerGeneratedAttribute]
internal Hashtable get_Options();
    [CompilerGeneratedAttribute]
internal void set_Options(Hashtable value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ScriptBlock> get_CustomArgumentCompleters();
    [CompilerGeneratedAttribute]
internal void set_CustomArgumentCompleters(Dictionary`2<string, ScriptBlock> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ScriptBlock> get_NativeArgumentCompleters();
    [CompilerGeneratedAttribute]
internal void set_NativeArgumentCompleters(Dictionary`2<string, ScriptBlock> value);
    [CompilerGeneratedAttribute]
internal string get_WordToComplete();
    [CompilerGeneratedAttribute]
internal void set_WordToComplete(string value);
    [CompilerGeneratedAttribute]
internal int get_ReplacementIndex();
    [CompilerGeneratedAttribute]
internal void set_ReplacementIndex(int value);
    [CompilerGeneratedAttribute]
internal int get_ReplacementLength();
    [CompilerGeneratedAttribute]
internal void set_ReplacementLength(int value);
    [CompilerGeneratedAttribute]
internal ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
internal void set_ExecutionContext(ExecutionContext value);
    [CompilerGeneratedAttribute]
internal PseudoBindingInfo get_PseudoBindingInfo();
    [CompilerGeneratedAttribute]
internal void set_PseudoBindingInfo(PseudoBindingInfo value);
    [CompilerGeneratedAttribute]
internal TypeInferenceContext get_TypeInferenceContext();
    [CompilerGeneratedAttribute]
internal void set_TypeInferenceContext(TypeInferenceContext value);
    internal bool GetOption(string option, bool default);
}
public class System.Management.Automation.CompletionResult : object {
    private string _completionText;
    private string _listItemText;
    private string _toolTip;
    private CompletionResultType _resultType;
    private static CompletionResult s_nullInstance;
    public string CompletionText { get; }
    public string ListItemText { get; }
    public CompletionResultType ResultType { get; }
    public string ToolTip { get; }
    internal static CompletionResult Null { get; }
    public CompletionResult(string completionText, string listItemText, CompletionResultType resultType, string toolTip);
    public CompletionResult(string completionText);
    private static CompletionResult();
    public string get_CompletionText();
    public string get_ListItemText();
    public CompletionResultType get_ResultType();
    public string get_ToolTip();
    internal static CompletionResult get_Null();
}
public enum System.Management.Automation.CompletionResultType : Enum {
    public int value__;
    public static CompletionResultType Text;
    public static CompletionResultType History;
    public static CompletionResultType Command;
    public static CompletionResultType ProviderItem;
    public static CompletionResultType ProviderContainer;
    public static CompletionResultType Property;
    public static CompletionResultType Method;
    public static CompletionResultType ParameterName;
    public static CompletionResultType ParameterValue;
    public static CompletionResultType Variable;
    public static CompletionResultType Namespace;
    public static CompletionResultType Type;
    public static CompletionResultType Keyword;
    public static CompletionResultType DynamicKeyword;
}
internal class System.Management.Automation.ComProperty : object {
    private bool _hasSetter;
    private bool _hasSetterByRef;
    private int _dispId;
    private int _setterIndex;
    private int _setterByRefIndex;
    private int _getterIndex;
    private ITypeInfo _typeInfo;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Type _cachedType;
    [CompilerGeneratedAttribute]
private bool <IsParameterized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGettable>k__BackingField;
    internal string Name { get; }
    internal Type Type { get; }
    internal bool IsParameterized { get; private set; }
    internal int ParamCount { get; }
    internal bool IsSettable { get; }
    internal bool IsGettable { get; private set; }
    internal ComProperty(ITypeInfo typeinfo, string name);
    [CompilerGeneratedAttribute]
internal string get_Name();
    internal Type get_Type();
    private int GetFuncDescIndex();
    [CompilerGeneratedAttribute]
internal bool get_IsParameterized();
    [CompilerGeneratedAttribute]
private void set_IsParameterized(bool value);
    internal int get_ParamCount();
    internal bool get_IsSettable();
    [CompilerGeneratedAttribute]
internal bool get_IsGettable();
    [CompilerGeneratedAttribute]
private void set_IsGettable(bool value);
    internal object GetValue(object target);
    internal object GetValue(object target, Object[] arguments);
    internal void SetValue(object target, object setValue);
    internal void SetValue(object target, object setValue, Object[] arguments);
    internal void UpdateFuncDesc(FUNCDESC desc, int index);
    internal string GetDefinition();
    public virtual string ToString();
}
internal class System.Management.Automation.ComTypeInfo : object {
    internal static int DISPID_NEWENUM;
    internal static int DISPID_DEFAULTMEMBER;
    private Dictionary`2<string, ComProperty> _properties;
    private Dictionary`2<string, ComMethod> _methods;
    private ITypeInfo _typeinfo;
    private Guid _guid;
    [CompilerGeneratedAttribute]
private Nullable`1<INVOKEKIND> <NewEnumInvokeKind>k__BackingField;
    internal Dictionary`2<string, ComProperty> Properties { get; }
    internal Dictionary`2<string, ComMethod> Methods { get; }
    internal string Clsid { get; }
    internal Nullable`1<INVOKEKIND> NewEnumInvokeKind { get; private set; }
    internal ComTypeInfo(ITypeInfo info);
    internal Dictionary`2<string, ComProperty> get_Properties();
    internal Dictionary`2<string, ComMethod> get_Methods();
    internal string get_Clsid();
    [CompilerGeneratedAttribute]
internal Nullable`1<INVOKEKIND> get_NewEnumInvokeKind();
    [CompilerGeneratedAttribute]
private void set_NewEnumInvokeKind(Nullable`1<INVOKEKIND> value);
    private void Initialize();
    internal static ComTypeInfo GetDispatchTypeInfo(object comObject);
    private void AddProperty(string strName, FUNCDESC funcdesc, int index);
    private void AddMethod(string strName, int index);
    internal static TYPEATTR GetTypeAttr(ITypeInfo typeinfo);
    internal static FUNCDESC GetFuncDesc(ITypeInfo typeinfo, int index);
    internal static ITypeInfo GetDispatchTypeInfoFromCustomInterfaceTypeInfo(ITypeInfo typeinfo);
    internal static ITypeInfo GetDispatchTypeInfoFromCoClassTypeInfo(ITypeInfo typeinfo);
}
internal static class System.Management.Automation.ComUtil : object {
    internal static int DISP_E_MEMBERNOTFOUND;
    internal static int DISP_E_UNKNOWNNAME;
    internal static int TYPE_E_ELEMENTNOTFOUND;
    internal static string GetMethodSignatureFromFuncDesc(ITypeInfo typeinfo, FUNCDESC funcdesc, bool isPropertyPut);
    internal static string GetNameFromFuncDesc(ITypeInfo typeinfo, FUNCDESC funcdesc);
    private static string GetStringFromCustomType(ITypeInfo typeinfo, IntPtr refptr);
    private static string GetStringFromTypeDesc(ITypeInfo typeinfo, TYPEDESC typedesc);
    internal static Type GetTypeFromTypeDesc(TYPEDESC typedesc);
    private static ComMethodInformation GetMethodInformation(FUNCDESC funcdesc, bool skipLastParameter);
    internal static ParameterInformation[] GetParameterInformation(FUNCDESC funcdesc, bool skipLastParameter);
    internal static ComMethodInformation[] GetMethodInformationArray(ITypeInfo typeInfo, Collection`1<int> methods, bool skipLastParameters);
}
public enum System.Management.Automation.Configuration.ConfigScope : Enum {
    public int value__;
    public static ConfigScope AllUsers;
    public static ConfigScope CurrentUser;
}
internal class System.Management.Automation.Configuration.ConsoleSessionConfiguration : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableConsoleSessionConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConsoleSessionConfigurationName>k__BackingField;
    public Nullable`1<bool> EnableConsoleSessionConfiguration { get; public set; }
    public string ConsoleSessionConfigurationName { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableConsoleSessionConfiguration();
    [CompilerGeneratedAttribute]
public void set_EnableConsoleSessionConfiguration(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_ConsoleSessionConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConsoleSessionConfigurationName(string value);
}
internal class System.Management.Automation.Configuration.ModuleLogging : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableModuleLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ModuleNames>k__BackingField;
    public Nullable`1<bool> EnableModuleLogging { get; public set; }
    public String[] ModuleNames { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableModuleLogging();
    [CompilerGeneratedAttribute]
public void set_EnableModuleLogging(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public String[] get_ModuleNames();
    [CompilerGeneratedAttribute]
public void set_ModuleNames(String[] value);
}
internal abstract class System.Management.Automation.Configuration.PolicyBase : object {
}
internal class System.Management.Automation.Configuration.PowerShellConfig : object {
    private static string ConfigFileName;
    private static string ExecutionPolicyDefaultShellKey;
    private static string DisableImplicitWinCompatKey;
    private static string WindowsPowerShellCompatibilityModuleDenyListKey;
    private static string WindowsPowerShellCompatibilityNoClobberModuleListKey;
    internal static PowerShellConfig Instance;
    private string systemWideConfigFile;
    private string systemWideConfigDirectory;
    private string perUserConfigFile;
    private string perUserConfigDirectory;
    private JObject[] configRoots;
    private JObject emptyConfig;
    private JsonSerializer serializer;
    private ReaderWriterLockSlim fileLock;
    private static PowerShellConfig();
    private string GetConfigFilePath(ConfigScope scope);
    internal void SetSystemConfigFilePath(string value);
    internal string GetModulePath(ConfigScope scope);
    internal string GetExecutionPolicy(ConfigScope scope, string shellId);
    internal void RemoveExecutionPolicy(ConfigScope scope, string shellId);
    internal void SetExecutionPolicy(ConfigScope scope, string shellId, string executionPolicy);
    private static string GetExecutionPolicySettingKey(string shellId);
    internal String[] GetExperimentalFeatures();
    internal void SetExperimentalFeatures(ConfigScope scope, string featureName, bool setEnabled);
    internal bool IsImplicitWinCompatEnabled();
    internal String[] GetWindowsPowerShellCompatibilityModuleDenyList();
    internal String[] GetWindowsPowerShellCompatibilityNoClobberModuleList();
    internal PowerShellPolicies GetPowerShellPolicies(ConfigScope scope);
    private T ReadValueFromFile(ConfigScope scope, string key, T defaultValue);
    private static FileStream OpenFileStreamWithRetry(string fullPath, FileMode mode, FileAccess access, FileShare share);
    private void UpdateValueInFile(ConfigScope scope, string key, T value, bool addValue);
    private void WriteValueToFile(ConfigScope scope, string key, T value);
    private void RemoveValueFromFile(ConfigScope scope, string key);
}
internal class System.Management.Automation.Configuration.PowerShellPolicies : object {
    [CompilerGeneratedAttribute]
private ScriptExecution <ScriptExecution>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlockLogging <ScriptBlockLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleLogging <ModuleLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private ProtectedEventLogging <ProtectedEventLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private Transcription <Transcription>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdatableHelp <UpdatableHelp>k__BackingField;
    [CompilerGeneratedAttribute]
private ConsoleSessionConfiguration <ConsoleSessionConfiguration>k__BackingField;
    public ScriptExecution ScriptExecution { get; public set; }
    public ScriptBlockLogging ScriptBlockLogging { get; public set; }
    public ModuleLogging ModuleLogging { get; public set; }
    public ProtectedEventLogging ProtectedEventLogging { get; public set; }
    public Transcription Transcription { get; public set; }
    public UpdatableHelp UpdatableHelp { get; public set; }
    public ConsoleSessionConfiguration ConsoleSessionConfiguration { get; public set; }
    [CompilerGeneratedAttribute]
public ScriptExecution get_ScriptExecution();
    [CompilerGeneratedAttribute]
public void set_ScriptExecution(ScriptExecution value);
    [CompilerGeneratedAttribute]
public ScriptBlockLogging get_ScriptBlockLogging();
    [CompilerGeneratedAttribute]
public void set_ScriptBlockLogging(ScriptBlockLogging value);
    [CompilerGeneratedAttribute]
public ModuleLogging get_ModuleLogging();
    [CompilerGeneratedAttribute]
public void set_ModuleLogging(ModuleLogging value);
    [CompilerGeneratedAttribute]
public ProtectedEventLogging get_ProtectedEventLogging();
    [CompilerGeneratedAttribute]
public void set_ProtectedEventLogging(ProtectedEventLogging value);
    [CompilerGeneratedAttribute]
public Transcription get_Transcription();
    [CompilerGeneratedAttribute]
public void set_Transcription(Transcription value);
    [CompilerGeneratedAttribute]
public UpdatableHelp get_UpdatableHelp();
    [CompilerGeneratedAttribute]
public void set_UpdatableHelp(UpdatableHelp value);
    [CompilerGeneratedAttribute]
public ConsoleSessionConfiguration get_ConsoleSessionConfiguration();
    [CompilerGeneratedAttribute]
public void set_ConsoleSessionConfiguration(ConsoleSessionConfiguration value);
}
internal class System.Management.Automation.Configuration.ProtectedEventLogging : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableProtectedEventLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <EncryptionCertificate>k__BackingField;
    public Nullable`1<bool> EnableProtectedEventLogging { get; public set; }
    public String[] EncryptionCertificate { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableProtectedEventLogging();
    [CompilerGeneratedAttribute]
public void set_EnableProtectedEventLogging(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public String[] get_EncryptionCertificate();
    [CompilerGeneratedAttribute]
public void set_EncryptionCertificate(String[] value);
}
internal class System.Management.Automation.Configuration.ScriptBlockLogging : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableScriptBlockInvocationLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableScriptBlockLogging>k__BackingField;
    public Nullable`1<bool> EnableScriptBlockInvocationLogging { get; public set; }
    public Nullable`1<bool> EnableScriptBlockLogging { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableScriptBlockInvocationLogging();
    [CompilerGeneratedAttribute]
public void set_EnableScriptBlockInvocationLogging(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableScriptBlockLogging();
    [CompilerGeneratedAttribute]
public void set_EnableScriptBlockLogging(Nullable`1<bool> value);
}
internal class System.Management.Automation.Configuration.ScriptExecution : PolicyBase {
    [CompilerGeneratedAttribute]
private string <ExecutionPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableScripts>k__BackingField;
    public string ExecutionPolicy { get; public set; }
    public Nullable`1<bool> EnableScripts { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ExecutionPolicy();
    [CompilerGeneratedAttribute]
public void set_ExecutionPolicy(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableScripts();
    [CompilerGeneratedAttribute]
public void set_EnableScripts(Nullable`1<bool> value);
}
internal class System.Management.Automation.Configuration.Transcription : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableTranscripting>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableInvocationHeader>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    public Nullable`1<bool> EnableTranscripting { get; public set; }
    public Nullable`1<bool> EnableInvocationHeader { get; public set; }
    public string OutputDirectory { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableTranscripting();
    [CompilerGeneratedAttribute]
public void set_EnableTranscripting(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableInvocationHeader();
    [CompilerGeneratedAttribute]
public void set_EnableInvocationHeader(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
}
internal class System.Management.Automation.Configuration.UpdatableHelp : PolicyBase {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EnableUpdateHelpDefaultSourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultSourcePath>k__BackingField;
    public Nullable`1<bool> EnableUpdateHelpDefaultSourcePath { get; public set; }
    public string DefaultSourcePath { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EnableUpdateHelpDefaultSourcePath();
    [CompilerGeneratedAttribute]
public void set_EnableUpdateHelpDefaultSourcePath(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_DefaultSourcePath();
    [CompilerGeneratedAttribute]
public void set_DefaultSourcePath(string value);
}
public class System.Management.Automation.ConfigurationInfo : FunctionInfo {
    [CompilerGeneratedAttribute]
private bool <IsMetaConfiguration>k__BackingField;
    internal HelpCategory HelpCategory { get; }
    public bool IsMetaConfiguration { get; internal set; }
    internal ConfigurationInfo(string name, ScriptBlock configuration, ExecutionContext context);
    internal ConfigurationInfo(string name, ScriptBlock configuration, ExecutionContext context, string helpFile);
    internal ConfigurationInfo(string name, ScriptBlock configuration, ScopedItemOptions options, ExecutionContext context);
    internal ConfigurationInfo(string name, ScriptBlock configuration, ScopedItemOptions options, ExecutionContext context, string helpFile, bool isMetaConfig);
    internal ConfigurationInfo(string name, ScriptBlock configuration, ScopedItemOptions options, ExecutionContext context, string helpFile);
    internal ConfigurationInfo(ConfigurationInfo other);
    internal ConfigurationInfo(string name, ConfigurationInfo other);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] arguments);
    internal virtual HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
public bool get_IsMetaConfiguration();
    [CompilerGeneratedAttribute]
internal void set_IsMetaConfiguration(bool value);
}
public enum System.Management.Automation.ConfirmImpact : Enum {
    public int value__;
    public static ConfirmImpact None;
    public static ConfirmImpact Low;
    public static ConfirmImpact Medium;
    public static ConfirmImpact High;
}
internal static class System.Management.Automation.ConsoleVisibility : object {
    [CompilerGeneratedAttribute]
private static bool <AlwaysCaptureApplicationIO>k__BackingField;
    public static bool AlwaysCaptureApplicationIO { get; public set; }
    [CompilerGeneratedAttribute]
public static bool get_AlwaysCaptureApplicationIO();
    [CompilerGeneratedAttribute]
public static void set_AlwaysCaptureApplicationIO(bool value);
    internal static bool AllocateHiddenConsole();
}
internal static class System.Management.Automation.Constants : object {
    public static string PSModulePathEnvVar;
}
public class System.Management.Automation.ContainerParentJob : Job2 {
    private static string TraceClassName;
    private bool _moreData;
    private object _syncObject;
    private int _isDisposed;
    private static int DisposedTrue;
    private static int DisposedFalse;
    private int _finishedChildJobsCount;
    private int _blockedChildJobsCount;
    private int _suspendedChildJobsCount;
    private int _suspendingChildJobsCount;
    private int _failedChildJobsCount;
    private int _stoppedChildJobsCount;
    private PowerShellTraceSource _tracer;
    private PSDataCollection`1<ErrorRecord> _executionError;
    private PSEventManager _eventManager;
    private ManualResetEvent _jobRunning;
    private ManualResetEvent _jobSuspendedOrAborted;
    private static Tracer s_structuredTracer;
    internal PSEventManager EventManager { get; internal set; }
    private ManualResetEvent JobRunning { get; }
    private ManualResetEvent JobSuspendedOrAborted { get; }
    internal PSDataCollection`1<ErrorRecord> ExecutionError { get; }
    public bool HasMoreData { get; }
    public string StatusMessage { get; }
    public string Location { get; }
    public ContainerParentJob(string command, string name);
    public ContainerParentJob(string command);
    public ContainerParentJob(string command, string name, JobIdentifier jobId);
    public ContainerParentJob(string command, string name, Guid instanceId);
    public ContainerParentJob(string command, string name, JobIdentifier jobId, string jobType);
    public ContainerParentJob(string command, string name, Guid instanceId, string jobType);
    public ContainerParentJob(string command, string name, string jobType);
    private static ContainerParentJob();
    internal PSEventManager get_EventManager();
    internal void set_EventManager(PSEventManager value);
    private ManualResetEvent get_JobRunning();
    private ManualResetEvent get_JobSuspendedOrAborted();
    internal PSDataCollection`1<ErrorRecord> get_ExecutionError();
    public void AddChildJob(Job2 childJob);
    public virtual bool get_HasMoreData();
    public virtual string get_StatusMessage();
    public virtual void StartJob();
    public virtual void StartJobAsync();
    public virtual void ResumeJob();
    public virtual void ResumeJobAsync();
    public virtual void SuspendJob();
    public virtual void SuspendJob(bool force, string reason);
    public virtual void SuspendJobAsync();
    public virtual void SuspendJobAsync(bool force, string reason);
    public virtual void StopJob();
    public virtual void StopJobAsync();
    public virtual void StopJob(bool force, string reason);
    public virtual void StopJobAsync(bool force, string reason);
    public virtual void UnblockJob();
    public virtual void UnblockJobAsync();
    private void SuspendJobInternal(Nullable`1<bool> force, string reason);
    private void SuspendJobAsyncInternal(Nullable`1<bool> force, string reason);
    private void StopJobInternal(Nullable`1<bool> force, string reason);
    private void StopJobAsyncInternal(Nullable`1<bool> force, string reason);
    private void HandleMyStateChanged(object sender, JobStateEventArgs e);
    private void HandleChildJobStateChanged(object sender, JobStateEventArgs e);
    private void ParentJobStateCalculation(JobStateEventArgs e);
    internal static bool ComputeJobStateFromChildJobStates(string traceClassName, JobStateEventArgs e, Int32& blockedChildJobsCount, Int32& suspendedChildJobsCount, Int32& suspendingChildJobsCount, Int32& finishedChildJobsCount, Int32& failedChildJobsCount, Int32& stoppedChildJobsCount, int childJobsCount, JobState& computedJobState);
    protected virtual void Dispose(bool disposing);
    private string ConstructLocation();
    private string ConstructStatusMessage();
    public virtual string get_Location();
    private void UnregisterJobEvent(Job job);
    private void UnregisterAllJobEvents();
}
internal enum System.Management.Automation.ContainerType : Enum {
    public int value__;
    public static ContainerType Dictionary;
    public static ContainerType Queue;
    public static ContainerType Stack;
    public static ContainerType List;
    public static ContainerType Enumerable;
    public static ContainerType None;
}
public class System.Management.Automation.ContentCmdletProviderIntrinsics : object {
    private Cmdlet _cmdlet;
    private SessionStateInternal _sessionState;
    internal ContentCmdletProviderIntrinsics(Cmdlet cmdlet);
    internal ContentCmdletProviderIntrinsics(SessionStateInternal sessionState);
    public Collection`1<IContentReader> GetReader(string path);
    public Collection`1<IContentReader> GetReader(String[] path, bool force, bool literalPath);
    internal Collection`1<IContentReader> GetReader(string path, CmdletProviderContext context);
    internal object GetContentReaderDynamicParameters(string path, CmdletProviderContext context);
    public Collection`1<IContentWriter> GetWriter(string path);
    public Collection`1<IContentWriter> GetWriter(String[] path, bool force, bool literalPath);
    internal Collection`1<IContentWriter> GetWriter(string path, CmdletProviderContext context);
    internal object GetContentWriterDynamicParameters(string path, CmdletProviderContext context);
    public void Clear(string path);
    public void Clear(String[] path, bool force, bool literalPath);
    internal void Clear(string path, CmdletProviderContext context);
    internal object ClearContentDynamicParameters(string path, CmdletProviderContext context);
}
public class System.Management.Automation.ContinueException : LoopFlowException {
    internal ContinueException(string label);
    internal ContinueException(string label, Exception innerException);
}
internal enum System.Management.Automation.ConversionRank : Enum {
    public int value__;
    public static ConversionRank None;
    public static ConversionRank UnrelatedArraysS2A;
    public static ConversionRank UnrelatedArrays;
    public static ConversionRank ToStringS2A;
    public static ConversionRank ToString;
    public static ConversionRank CustomS2A;
    public static ConversionRank Custom;
    public static ConversionRank IConvertibleS2A;
    public static ConversionRank IConvertible;
    public static ConversionRank ImplicitCastS2A;
    public static ConversionRank ImplicitCast;
    public static ConversionRank ExplicitCastS2A;
    public static ConversionRank ExplicitCast;
    public static ConversionRank ConstructorS2A;
    public static ConversionRank Constructor;
    public static ConversionRank Create;
    public static ConversionRank ParseS2A;
    public static ConversionRank Parse;
    public static ConversionRank PSObjectS2A;
    public static ConversionRank PSObject;
    public static ConversionRank LanguageS2A;
    public static ConversionRank Language;
    public static ConversionRank NullToValue;
    public static ConversionRank NullToRef;
    public static ConversionRank NumericExplicitS2A;
    public static ConversionRank NumericExplicit;
    public static ConversionRank NumericExplicit1S2A;
    public static ConversionRank NumericExplicit1;
    public static ConversionRank NumericStringS2A;
    public static ConversionRank NumericString;
    public static ConversionRank NumericImplicitS2A;
    public static ConversionRank NumericImplicit;
    public static ConversionRank AssignableS2A;
    public static ConversionRank Assignable;
    public static ConversionRank IdentityS2A;
    public static ConversionRank StringToCharArray;
    public static ConversionRank Identity;
    public static ConversionRank ValueDependent;
}
public class System.Management.Automation.ConvertThroughString : PSTypeConverter {
    public virtual bool CanConvertFrom(object sourceValue, Type destinationType);
    public virtual object ConvertFrom(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public virtual bool CanConvertTo(object sourceValue, Type destinationType);
    public virtual object ConvertTo(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
}
public enum System.Management.Automation.CopyContainers : Enum {
    public int value__;
    public static CopyContainers CopyTargetContainer;
    public static CopyContainers CopyChildrenOfTargetContainer;
}
internal static class System.Management.Automation.CoreTypes : object {
    internal static Lazy`1<Dictionary`2<Type, String[]>> Items;
    private static CoreTypes();
    internal static bool Contains(Type inputType);
}
internal static class System.Management.Automation.CRC32Hash : object {
    private static UInt32 polynomial;
    private static UInt32[] table;
    private static CRC32Hash();
    private static UInt32 Compute(Byte[] buffer);
    internal static Byte[] ComputeHash(Byte[] buffer);
    internal static string ComputeHash(string input);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.CredentialAttribute : ArgumentTransformationAttribute {
    public bool TransformNullOptionalParameters { get; }
    public virtual object Transform(EngineIntrinsics engineIntrinsics, object inputData);
    public virtual bool get_TransformNullOptionalParameters();
}
public class System.Management.Automation.CustomControl : PSControl {
    [CompilerGeneratedAttribute]
private List`1<CustomControlEntry> <Entries>k__BackingField;
    internal ComplexControlBody _cachedBody;
    public List`1<CustomControlEntry> Entries { get; public set; }
    internal CustomControl(ComplexControlBody body, ViewDefinition viewDefinition);
    [CompilerGeneratedAttribute]
public List`1<CustomControlEntry> get_Entries();
    [CompilerGeneratedAttribute]
public void set_Entries(List`1<CustomControlEntry> value);
    public static CustomControlBuilder Create(bool outOfBand);
    internal virtual void WriteToXml(FormatXmlWriter writer);
    internal virtual bool SafeForExport();
    internal virtual bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.CustomControlBuilder : object {
    internal CustomControl _control;
    internal CustomControlBuilder(CustomControl control);
    public CustomControlBuilder GroupByProperty(string property, CustomControl customControl, string label);
    public CustomControlBuilder GroupByScriptBlock(string scriptBlock, CustomControl customControl, string label);
    public CustomEntryBuilder StartEntry(IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    public CustomControl EndControl();
}
public class System.Management.Automation.CustomControlEntry : object {
    [CompilerGeneratedAttribute]
private EntrySelectedBy <SelectedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CustomItemBase> <CustomItems>k__BackingField;
    public EntrySelectedBy SelectedBy { get; public set; }
    public List`1<CustomItemBase> CustomItems { get; public set; }
    internal CustomControlEntry(ComplexControlEntryDefinition entry);
    [CompilerGeneratedAttribute]
public EntrySelectedBy get_SelectedBy();
    [CompilerGeneratedAttribute]
public void set_SelectedBy(EntrySelectedBy value);
    [CompilerGeneratedAttribute]
public List`1<CustomItemBase> get_CustomItems();
    [CompilerGeneratedAttribute]
public void set_CustomItems(List`1<CustomItemBase> value);
    internal bool SafeForExport();
}
public class System.Management.Automation.CustomEntryBuilder : object {
    private Stack`1<List`1<CustomItemBase>> _entryStack;
    private CustomControlBuilder _controlBuilder;
    internal CustomEntryBuilder(CustomControlBuilder controlBuilder, CustomControlEntry entry);
    public CustomEntryBuilder AddNewline(int count);
    public CustomEntryBuilder AddText(string text);
    private void AddDisplayExpressionBinding(string value, DisplayEntryValueType valueType, bool enumerateCollection, string selectedByType, string selectedByScript, CustomControl customControl);
    public CustomEntryBuilder AddPropertyExpressionBinding(string property, bool enumerateCollection, string selectedByType, string selectedByScript, CustomControl customControl);
    public CustomEntryBuilder AddScriptBlockExpressionBinding(string scriptBlock, bool enumerateCollection, string selectedByType, string selectedByScript, CustomControl customControl);
    public CustomEntryBuilder AddCustomControlExpressionBinding(CustomControl customControl, bool enumerateCollection, string selectedByType, string selectedByScript);
    public CustomEntryBuilder StartFrame(UInt32 leftIndent, UInt32 rightIndent, UInt32 firstLineHanging, UInt32 firstLineIndent);
    public CustomEntryBuilder EndFrame();
    public CustomControlBuilder EndEntry();
}
public abstract class System.Management.Automation.CustomItemBase : object {
    internal virtual bool SafeForExport();
    internal static CustomItemBase Create(FormatToken token);
}
public class System.Management.Automation.CustomItemExpression : CustomItemBase {
    [CompilerGeneratedAttribute]
private DisplayEntry <ItemSelectionCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayEntry <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumerateCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomControl <CustomControl>k__BackingField;
    public DisplayEntry ItemSelectionCondition { get; public set; }
    public DisplayEntry Expression { get; public set; }
    public bool EnumerateCollection { get; public set; }
    public CustomControl CustomControl { get; public set; }
    [CompilerGeneratedAttribute]
public DisplayEntry get_ItemSelectionCondition();
    [CompilerGeneratedAttribute]
public void set_ItemSelectionCondition(DisplayEntry value);
    [CompilerGeneratedAttribute]
public DisplayEntry get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(DisplayEntry value);
    [CompilerGeneratedAttribute]
public bool get_EnumerateCollection();
    [CompilerGeneratedAttribute]
public void set_EnumerateCollection(bool value);
    [CompilerGeneratedAttribute]
public CustomControl get_CustomControl();
    [CompilerGeneratedAttribute]
public void set_CustomControl(CustomControl value);
    internal virtual bool SafeForExport();
}
public class System.Management.Automation.CustomItemFrame : CustomItemBase {
    [CompilerGeneratedAttribute]
private UInt32 <LeftIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <RightIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FirstLineHanging>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <FirstLineIndent>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CustomItemBase> <CustomItems>k__BackingField;
    public UInt32 LeftIndent { get; public set; }
    public UInt32 RightIndent { get; public set; }
    public UInt32 FirstLineHanging { get; public set; }
    public UInt32 FirstLineIndent { get; public set; }
    public List`1<CustomItemBase> CustomItems { get; public set; }
    [CompilerGeneratedAttribute]
public UInt32 get_LeftIndent();
    [CompilerGeneratedAttribute]
public void set_LeftIndent(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_RightIndent();
    [CompilerGeneratedAttribute]
public void set_RightIndent(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_FirstLineHanging();
    [CompilerGeneratedAttribute]
public void set_FirstLineHanging(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_FirstLineIndent();
    [CompilerGeneratedAttribute]
public void set_FirstLineIndent(UInt32 value);
    [CompilerGeneratedAttribute]
public List`1<CustomItemBase> get_CustomItems();
    [CompilerGeneratedAttribute]
public void set_CustomItems(List`1<CustomItemBase> value);
    internal virtual bool SafeForExport();
}
public class System.Management.Automation.CustomItemNewline : CustomItemBase {
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; public set; }
    [CompilerGeneratedAttribute]
public int get_Count();
    [CompilerGeneratedAttribute]
public void set_Count(int value);
}
public class System.Management.Automation.CustomItemText : CustomItemBase {
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public string Text { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Text();
    [CompilerGeneratedAttribute]
public void set_Text(string value);
}
public class System.Management.Automation.DataAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <PowerShellInstanceId>k__BackingField;
    public int Index { get; }
    public Guid PowerShellInstanceId { get; }
    internal DataAddedEventArgs(Guid psInstanceId, int index);
    [CompilerGeneratedAttribute]
public int get_Index();
    [CompilerGeneratedAttribute]
public Guid get_PowerShellInstanceId();
}
public class System.Management.Automation.DataAddingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private object <ItemAdded>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <PowerShellInstanceId>k__BackingField;
    public object ItemAdded { get; }
    public Guid PowerShellInstanceId { get; }
    internal DataAddingEventArgs(Guid psInstanceId, object itemAdded);
    [CompilerGeneratedAttribute]
public object get_ItemAdded();
    [CompilerGeneratedAttribute]
public Guid get_PowerShellInstanceId();
}
internal class System.Management.Automation.DataRowAdapter : PropertyOnlyAdapter {
    protected virtual void DoAddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(object obj, string propertyName);
    protected virtual PSProperty DoGetFirstPropertyOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
}
internal class System.Management.Automation.DataRowViewAdapter : PropertyOnlyAdapter {
    protected virtual void DoAddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(object obj, string propertyName);
    protected virtual PSProperty DoGetFirstPropertyOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
}
public abstract class System.Management.Automation.Debugger : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<DebuggerStopEventArgs> DebuggerStop;
    [CompilerGeneratedAttribute]
private EventHandler`1<BreakpointUpdatedEventArgs> BreakpointUpdated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> NestedDebuggingCancelledEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<StartRunspaceDebugProcessingEventArgs> StartRunspaceDebugProcessing;
    [CompilerGeneratedAttribute]
private EventHandler`1<ProcessRunspaceDebugEndEventArgs> RunspaceDebugProcessingCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> CancelRunspaceDebugProcessing;
    [CompilerGeneratedAttribute]
private bool <DebuggerStopped>k__BackingField;
    [CompilerGeneratedAttribute]
private DebugModes <DebugMode>k__BackingField;
    internal static string CannotProcessCommandNotStopped;
    internal static string CannotEnableDebuggerSteppingInvalidMode;
    private static Guid s_instanceId;
    protected bool DebuggerStopped { get; private set; }
    internal bool IsPushed { get; }
    internal bool IsRemote { get; }
    internal bool IsPendingDebugStopEvent { get; }
    internal bool IsDebuggerSteppingEnabled { get; }
    internal bool IsDebugHandlerSubscribed { get; }
    internal UnhandledBreakpointProcessingMode UnhandledBreakpointMode { get; internal set; }
    public DebugModes DebugMode { get; protected set; }
    public bool IsActive { get; }
    public Guid InstanceId { get; }
    public bool InBreakpoint { get; }
    private static Debugger();
    [CompilerGeneratedAttribute]
public void add_DebuggerStop(EventHandler`1<DebuggerStopEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DebuggerStop(EventHandler`1<DebuggerStopEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_BreakpointUpdated(EventHandler`1<BreakpointUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_BreakpointUpdated(EventHandler`1<BreakpointUpdatedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_NestedDebuggingCancelledEvent(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_NestedDebuggingCancelledEvent(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void add_StartRunspaceDebugProcessing(EventHandler`1<StartRunspaceDebugProcessingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StartRunspaceDebugProcessing(EventHandler`1<StartRunspaceDebugProcessingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RunspaceDebugProcessingCompleted(EventHandler`1<ProcessRunspaceDebugEndEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RunspaceDebugProcessingCompleted(EventHandler`1<ProcessRunspaceDebugEndEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_CancelRunspaceDebugProcessing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_CancelRunspaceDebugProcessing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
protected bool get_DebuggerStopped();
    [CompilerGeneratedAttribute]
private void set_DebuggerStopped(bool value);
    internal virtual bool get_IsPushed();
    internal virtual bool get_IsRemote();
    internal virtual bool get_IsPendingDebugStopEvent();
    internal virtual bool get_IsDebuggerSteppingEnabled();
    internal bool get_IsDebugHandlerSubscribed();
    internal virtual UnhandledBreakpointProcessingMode get_UnhandledBreakpointMode();
    internal virtual void set_UnhandledBreakpointMode(UnhandledBreakpointProcessingMode value);
    [CompilerGeneratedAttribute]
public DebugModes get_DebugMode();
    [CompilerGeneratedAttribute]
protected void set_DebugMode(DebugModes value);
    public virtual bool get_IsActive();
    public virtual Guid get_InstanceId();
    public virtual bool get_InBreakpoint();
    protected void RaiseDebuggerStopEvent(DebuggerStopEventArgs args);
    protected bool IsDebuggerStopEventSubscribed();
    protected void RaiseBreakpointUpdatedEvent(BreakpointUpdatedEventArgs args);
    protected bool IsDebuggerBreakpointUpdatedEventSubscribed();
    protected void RaiseStartRunspaceDebugProcessingEvent(StartRunspaceDebugProcessingEventArgs args);
    protected void RaiseRunspaceProcessingCompletedEvent(ProcessRunspaceDebugEndEventArgs args);
    protected bool IsStartRunspaceDebugProcessingEventSubscribed();
    protected void RaiseCancelRunspaceDebugProcessingEvent();
    public abstract virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public abstract virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public abstract virtual void StopProcessCommand();
    public abstract virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual void SetParent(Debugger parent, IEnumerable`1<Breakpoint> breakPoints, Nullable`1<DebuggerResumeAction> startAction, PSHost host, PathInfo path);
    public virtual void SetDebugMode(DebugModes mode);
    public virtual IEnumerable`1<CallStackFrame> GetCallStack();
    public Breakpoint GetBreakpoint(int id);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints);
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public List`1<Breakpoint> GetBreakpoints();
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public bool RemoveBreakpoint(Breakpoint breakpoint);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public Breakpoint EnableBreakpoint(Breakpoint breakpoint);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public Breakpoint DisableBreakpoint(Breakpoint breakpoint);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void ResetCommandProcessorSource();
    public virtual void SetDebuggerStepMode(bool enabled);
    internal virtual void Break(object triggerObject);
    internal virtual string GetCurrentScriptPosition();
    internal virtual DebuggerCommand InternalProcessCommand(string command, IList`1<PSObject> output);
    internal virtual bool InternalProcessListCommand(int lineNum, IList`1<PSObject> output);
    internal virtual void DebugJob(Job job, bool breakAll);
    internal virtual void StopDebugJob(Job job);
    internal virtual CallStackFrame[] GetActiveDebuggerCallStack();
    internal virtual void StartMonitoringRunspace(PSMonitorRunspaceInfo args);
    internal virtual void EndMonitoringRunspace(PSMonitorRunspaceInfo args);
    internal virtual void ReleaseSavedDebugStop();
    internal virtual void DebugRunspace(Runspace runspace, bool breakAll);
    internal virtual void StopDebugRunspace(Runspace runspace);
    internal void RaiseNestedDebuggingCancelEvent();
    internal virtual void QueueRunspaceForDebug(Runspace runspace);
    public virtual void CancelDebuggerProcessing();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <RaiseNestedDebuggingCancelEvent>b__92_0(object state);
}
internal class System.Management.Automation.DebuggerCommand : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DebuggerResumeAction> <ResumeAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RepeatOnEnter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExecutedByDebugger>k__BackingField;
    public Nullable`1<DebuggerResumeAction> ResumeAction { get; }
    public string Command { get; }
    public bool RepeatOnEnter { get; }
    public bool ExecutedByDebugger { get; }
    public DebuggerCommand(string command, Nullable`1<DebuggerResumeAction> action, bool repeatOnEnter, bool executedByDebugger);
    [CompilerGeneratedAttribute]
public Nullable`1<DebuggerResumeAction> get_ResumeAction();
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public bool get_RepeatOnEnter();
    [CompilerGeneratedAttribute]
public bool get_ExecutedByDebugger();
}
internal class System.Management.Automation.DebuggerCommandProcessor : object {
    private static string ContinueCommand;
    private static string ContinueShortcut;
    private static string GetStackTraceShortcut;
    private static string HelpCommand;
    private static string HelpShortcut;
    private static string ListCommand;
    private static string ListShortcut;
    private static string StepCommand;
    private static string StepShortcut;
    private static string StepOutCommand;
    private static string StepOutShortcut;
    private static string StepOverCommand;
    private static string StepOverShortcut;
    private static string StopCommand;
    private static string StopShortcut;
    private static string DetachCommand;
    private static string DetachShortcut;
    private static int DefaultListLineCount;
    private Dictionary`2<string, DebuggerCommand> _commandTable;
    private DebuggerCommand _helpCommand;
    private DebuggerCommand _listCommand;
    private DebuggerCommand _lastCommand;
    private String[] _lines;
    private int _lastLineDisplayed;
    private static string Crlf;
    public void Reset();
    public DebuggerCommand ProcessCommand(PSHost host, string command, InvocationInfo invocationInfo);
    public DebuggerCommand ProcessCommand(PSHost host, string command, InvocationInfo invocationInfo, IList`1<PSObject> output);
    public void ProcessListCommand(InvocationInfo invocationInfo, IList`1<PSObject> output);
    public DebuggerCommand ProcessBasicCommand(string command);
    private DebuggerCommand DoProcessCommand(PSHost host, string command, InvocationInfo invocationInfo, IList`1<PSObject> output);
    private static void DisplayHelp(PSHost host, IList`1<PSObject> output);
    private void DisplayScript(PSHost host, IList`1<PSObject> output, InvocationInfo invocationInfo, Match match);
    private void DisplayScript(PSHost host, IList`1<PSObject> output, InvocationInfo invocationInfo, int start, int count);
    private static void WriteLine(string line, PSHost host, IList`1<PSObject> output);
    private static void WriteCR(PSHost host, IList`1<PSObject> output);
    private static void WriteErrorLine(string error, PSHost host, IList`1<PSObject> output);
}
public class System.Management.Automation.DebuggerCommandResults : object {
    [CompilerGeneratedAttribute]
private Nullable`1<DebuggerResumeAction> <ResumeAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EvaluatedByDebugger>k__BackingField;
    public Nullable`1<DebuggerResumeAction> ResumeAction { get; private set; }
    public bool EvaluatedByDebugger { get; }
    public DebuggerCommandResults(Nullable`1<DebuggerResumeAction> resumeAction, bool evaluatedByDebugger);
    [CompilerGeneratedAttribute]
public Nullable`1<DebuggerResumeAction> get_ResumeAction();
    [CompilerGeneratedAttribute]
private void set_ResumeAction(Nullable`1<DebuggerResumeAction> value);
    [CompilerGeneratedAttribute]
public bool get_EvaluatedByDebugger();
}
public enum System.Management.Automation.DebuggerResumeAction : Enum {
    public int value__;
    public static DebuggerResumeAction Continue;
    public static DebuggerResumeAction StepInto;
    public static DebuggerResumeAction StepOut;
    public static DebuggerResumeAction StepOver;
    public static DebuggerResumeAction Stop;
}
public class System.Management.Automation.DebuggerStopEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private InvocationInfo <InvocationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Breakpoint> <Breakpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private DebuggerResumeAction <ResumeAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuspendRemote>k__BackingField;
    public InvocationInfo InvocationInfo { get; internal set; }
    public ReadOnlyCollection`1<Breakpoint> Breakpoints { get; }
    public DebuggerResumeAction ResumeAction { get; public set; }
    internal bool SuspendRemote { get; internal set; }
    internal DebuggerStopEventArgs(InvocationInfo invocationInfo, List`1<Breakpoint> breakpoints);
    public DebuggerStopEventArgs(InvocationInfo invocationInfo, Collection`1<Breakpoint> breakpoints, DebuggerResumeAction resumeAction);
    [CompilerGeneratedAttribute]
public InvocationInfo get_InvocationInfo();
    [CompilerGeneratedAttribute]
internal void set_InvocationInfo(InvocationInfo value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Breakpoint> get_Breakpoints();
    [CompilerGeneratedAttribute]
public DebuggerResumeAction get_ResumeAction();
    [CompilerGeneratedAttribute]
public void set_ResumeAction(DebuggerResumeAction value);
    [CompilerGeneratedAttribute]
internal bool get_SuspendRemote();
    [CompilerGeneratedAttribute]
internal void set_SuspendRemote(bool value);
}
[FlagsAttribute]
public enum System.Management.Automation.DebugModes : Enum {
    public int value__;
    public static DebugModes None;
    public static DebugModes Default;
    public static DebugModes LocalScript;
    public static DebugModes RemoteScript;
}
[DataContractAttribute]
public class System.Management.Automation.DebugRecord : InformationalRecord {
    public DebugRecord(string message);
    public DebugRecord(PSObject record);
}
internal static class System.Management.Automation.DecimalOps : object {
    internal static object Add(decimal lhs, decimal rhs);
    internal static object Sub(decimal lhs, decimal rhs);
    internal static object Multiply(decimal lhs, decimal rhs);
    internal static object Divide(decimal lhs, decimal rhs);
    internal static object Remainder(decimal lhs, decimal rhs);
    internal static object BNot(decimal val);
    internal static object BOr(decimal lhs, decimal rhs);
    internal static object BXor(decimal lhs, decimal rhs);
    internal static object BAnd(decimal lhs, decimal rhs);
    private static ulong ConvertToUlong(decimal val);
    internal static object LeftShift(decimal val, int count);
    internal static object RightShift(decimal val, int count);
    internal static object CompareEq(decimal lhs, decimal rhs);
    internal static object CompareNe(decimal lhs, decimal rhs);
    internal static object CompareLt(decimal lhs, decimal rhs);
    internal static object CompareLe(decimal lhs, decimal rhs);
    internal static object CompareGt(decimal lhs, decimal rhs);
    internal static object CompareGe(decimal lhs, decimal rhs);
    private static object CompareWithDouble(decimal left, double right, Func`3<double, double, object> doubleComparer, Func`3<decimal, decimal, object> decimalComparer);
    private static object CompareWithDouble(double left, decimal right, Func`3<double, double, object> doubleComparer, Func`3<decimal, decimal, object> decimalComparer);
    internal static object CompareEq1(double lhs, decimal rhs);
    internal static object CompareNe1(double lhs, decimal rhs);
    internal static object CompareLt1(double lhs, decimal rhs);
    internal static object CompareLe1(double lhs, decimal rhs);
    internal static object CompareGt1(double lhs, decimal rhs);
    internal static object CompareGe1(double lhs, decimal rhs);
    internal static object CompareEq2(decimal lhs, double rhs);
    internal static object CompareNe2(decimal lhs, double rhs);
    internal static object CompareLt2(decimal lhs, double rhs);
    internal static object CompareLe2(decimal lhs, double rhs);
    internal static object CompareGt2(decimal lhs, double rhs);
    internal static object CompareGe2(decimal lhs, double rhs);
}
internal class System.Management.Automation.DefaultCommandRuntime : object {
    private List`1<object> _output;
    [CompilerGeneratedAttribute]
private PSHost <Host>k__BackingField;
    public PSHost Host { get; public set; }
    public PSTransactionContext CurrentPSTransaction { get; }
    public DefaultCommandRuntime(List`1<object> outputList);
    [CompilerGeneratedAttribute]
public sealed virtual PSHost get_Host();
    [CompilerGeneratedAttribute]
public void set_Host(PSHost value);
    public sealed virtual void WriteDebug(string text);
    public sealed virtual void WriteError(ErrorRecord errorRecord);
    public sealed virtual void WriteObject(object sendToPipeline);
    public sealed virtual void WriteObject(object sendToPipeline, bool enumerateCollection);
    public sealed virtual void WriteProgress(ProgressRecord progressRecord);
    public sealed virtual void WriteProgress(long sourceId, ProgressRecord progressRecord);
    public sealed virtual void WriteVerbose(string text);
    public sealed virtual void WriteWarning(string text);
    public sealed virtual void WriteCommandDetail(string text);
    public sealed virtual void WriteInformation(InformationRecord informationRecord);
    public sealed virtual bool ShouldProcess(string target);
    public sealed virtual bool ShouldProcess(string target, string action);
    public sealed virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    public sealed virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    public sealed virtual bool ShouldContinue(string query, string caption);
    public sealed virtual bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    public sealed virtual bool ShouldContinue(string query, string caption, bool hasSecurityImpact, Boolean& yesToAll, Boolean& noToAll);
    public sealed virtual bool TransactionAvailable();
    public sealed virtual PSTransactionContext get_CurrentPSTransaction();
    [DoesNotReturnAttribute]
public sealed virtual void ThrowTerminatingError(ErrorRecord errorRecord);
}
internal class System.Management.Automation.DefaultHelpProvider : HelpFileHelpProvider {
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal DefaultHelpProvider(HelpSystem helpSystem);
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.DefaultParameterDictionary : Hashtable {
    private bool _isChanged;
    public object Item { get; public set; }
    public DefaultParameterDictionary(IDictionary dictionary);
    public bool ChangeSinceLastCheck();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    public virtual void Add(object key, object value);
    private void AddImpl(object key, object value, bool isSelfIndexing);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual void Remove(object key);
    public virtual void Clear();
    internal static bool CheckKeyIsValid(string key, String& cmdletName, String& parameterName);
    private static int GetValueToken(int index, string key, String& name, bool getCmdletName);
    private static int SkipWhiteSpace(int index, string key);
}
internal class System.Management.Automation.DeserializationContext : object {
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumAllowedMemory>k__BackingField;
    private int _totalDataProcessedSoFar;
    internal DeserializationOptions options;
    internal PSRemotingCryptoHelper cryptoHelper;
    internal static int MaxItemsInCimClassCache;
    internal CimClassDeserializationCache`1<CimClassSerializationId> cimClassSerializationIdCache;
    internal Nullable`1<int> MaximumAllowedMemory { get; internal set; }
    internal DeserializationContext(DeserializationOptions options, PSRemotingCryptoHelper cryptoHelper);
    private static DeserializationContext();
    [CompilerGeneratedAttribute]
internal Nullable`1<int> get_MaximumAllowedMemory();
    [CompilerGeneratedAttribute]
internal void set_MaximumAllowedMemory(Nullable`1<int> value);
    internal void LogExtraMemoryUsage(int amountOfExtraMemory);
}
[FlagsAttribute]
internal enum System.Management.Automation.DeserializationOptions : Enum {
    public int value__;
    public static DeserializationOptions None;
    public static DeserializationOptions NoRootElement;
    public static DeserializationOptions NoNamespace;
    public static DeserializationOptions DeserializeScriptBlocks;
    public static DeserializationOptions RemotingOptions;
}
internal class System.Management.Automation.Deserializer : object {
    private XmlReader _reader;
    private InternalDeserializer _deserializer;
    private DeserializationContext _context;
    private bool _done;
    private static string DeserializationTypeNamePrefix;
    internal TypeTable TypeTable { get; internal set; }
    internal Deserializer(XmlReader reader);
    internal Deserializer(XmlReader reader, DeserializationContext context);
    private static void ReportExceptionForETW(XmlException exception);
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    private void Start();
    internal bool Done();
    internal void Stop();
    internal object Deserialize();
    internal object Deserialize(String& streamName);
    internal static void AddDeserializationPrefix(String& type);
    internal static bool IsInstanceOfType(object o, Type type);
    internal static bool IsDeserializedInstanceOfType(object o, Type type);
    internal static string MaskDeserializationPrefix(string typeName);
    internal static Collection`1<string> MaskDeserializationPrefix(Collection`1<string> typeNames);
}
internal class System.Management.Automation.Diagnostics : object {
    private static object s_throwInsteadOfAssertLock;
    private static bool s_throwInsteadOfAssert;
    internal static bool ThrowInsteadOfAssert { get; internal set; }
    private static Diagnostics();
    internal static string StackTrace(int framesToSkip);
    internal static bool get_ThrowInsteadOfAssert();
    internal static void set_ThrowInsteadOfAssert(bool value);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("ASSERTIONS_TRACE")]
internal static void Assert(bool condition, string whyThisShouldNeverHappen);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("ASSERTIONS_TRACE")]
internal static void Assert(bool condition, string whyThisShouldNeverHappen, string detailMessage);
}
internal class System.Management.Automation.DirectoryEntryAdapter : DotNetAdapter {
    private static DotNetAdapter s_dotNetAdapter;
    private static DirectoryEntryAdapter();
    internal virtual bool CanSiteBinderOptimize(MemberTypes typeToOperateOn);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual object MethodInvoke(PSMethod method, PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    protected virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected virtual string MethodToString(PSMethod method);
}
internal class System.Management.Automation.DisconnectedJobOperation : ExecutionCmdletHelper {
    [CompilerGeneratedAttribute]
private EventHandler`1<OperationStateEventArgs> OperationComplete;
    internal DisconnectedJobOperation(Pipeline pipeline);
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void HandlePipelineStateChanged(object sender, PipelineStateEventArgs stateEventArgs);
    private void SendStopComplete(EventArgs eventArgs);
}
public class System.Management.Automation.DisplayEntry : object {
    [CompilerGeneratedAttribute]
private DisplayEntryValueType <ValueType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public DisplayEntryValueType ValueType { get; internal set; }
    public string Value { get; internal set; }
    public DisplayEntry(string value, DisplayEntryValueType type);
    internal DisplayEntry(ExpressionToken expression);
    [CompilerGeneratedAttribute]
public DisplayEntryValueType get_ValueType();
    [CompilerGeneratedAttribute]
internal void set_ValueType(DisplayEntryValueType value);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(string value);
    public virtual string ToString();
    internal bool SafeForExport();
}
public enum System.Management.Automation.DisplayEntryValueType : Enum {
    public int value__;
    public static DisplayEntryValueType Property;
    public static DisplayEntryValueType ScriptBlock;
}
internal class System.Management.Automation.DlrScriptCommandProcessor : ScriptCommandProcessorBase {
    private ArrayList _input;
    private object _dollarUnderbar;
    private ScriptBlock _scriptBlock;
    private MutableTuple _localsTuple;
    private bool _runOptimizedCode;
    private bool _argsBound;
    private bool _anyClauseExecuted;
    private FunctionContext _functionContext;
    private ObsoleteAttribute _obsoleteAttribute;
    internal ObsoleteAttribute ObsoleteAttribute { get; }
    internal DlrScriptCommandProcessor(ScriptBlock scriptBlock, ExecutionContext context, bool useNewScope, CommandOrigin origin, SessionStateInternal sessionState, object dollarUnderbar);
    internal DlrScriptCommandProcessor(ScriptBlock scriptBlock, ExecutionContext context, bool useNewScope, CommandOrigin origin, SessionStateInternal sessionState);
    internal DlrScriptCommandProcessor(FunctionInfo functionInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    internal DlrScriptCommandProcessor(ScriptInfo scriptInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    internal DlrScriptCommandProcessor(ExternalScriptInfo scriptInfo, ExecutionContext context, bool useNewScope, SessionStateInternal sessionState);
    private void Init();
    internal virtual ObsoleteAttribute get_ObsoleteAttribute();
    internal virtual void Prepare(IDictionary psDefaultParameterValues);
    internal virtual void DoBegin();
    internal virtual void ProcessRecord();
    internal virtual void Complete();
    protected virtual void CleanResource();
    private void DoProcessRecordWithInput();
    private void RunClause(Action`1<FunctionContext> clause, object dollarUnderbar, object inputToProcess);
    private void EnterScope();
    protected virtual void OnSetCurrentScope();
    protected virtual void OnRestorePreviousScope();
}
internal class System.Management.Automation.DotNetAdapter : Adapter {
    private static BindingFlags instanceBindingFlags;
    private static BindingFlags staticBindingFlags;
    private bool _isStatic;
    private static Dictionary`2<Type, CacheTable> s_instancePropertyCacheTable;
    private static Dictionary`2<Type, CacheTable> s_staticPropertyCacheTable;
    private static Dictionary`2<Type, CacheTable> s_instanceMethodCacheTable;
    private static Dictionary`2<Type, CacheTable> s_staticMethodCacheTable;
    private static Dictionary`2<Type, Dictionary`2<string, EventCacheEntry>> s_instanceEventCacheTable;
    private static Dictionary`2<Type, Dictionary`2<string, EventCacheEntry>> s_staticEventCacheTable;
    private static ConcurrentDictionary`2<Type, ConsolidatedString> s_typeToTypeNameDictionary;
    internal DotNetAdapter(bool isStatic);
    private static DotNetAdapter();
    private static bool SameSignature(MethodBase method1, MethodBase method2);
    private static void AddOverload(List`1<MethodBase> previousMethodEntry, MethodInfo method);
    private static void PopulateMethodReflectionTable(Type type, MethodInfo[] methods, CacheTable typeMethods);
    private static void PopulateMethodReflectionTable(ConstructorInfo[] ctors, CacheTable typeMethods);
    private static void PopulateMethodReflectionTable(Type type, CacheTable typeMethods, BindingFlags bindingFlags);
    private static void PopulateEventReflectionTable(Type type, Dictionary`2<string, EventCacheEntry> typeEvents, BindingFlags bindingFlags);
    private static bool PropertyAlreadyPresent(List`1<PropertyInfo> previousProperties, PropertyInfo property);
    private static void PopulatePropertyReflectionTable(Type type, CacheTable typeProperties, BindingFlags bindingFlags);
    private static void PopulateSingleProperty(Type type, PropertyInfo property, Dictionary`2<string, List`1<PropertyInfo>> tempTable, string propertyName);
    private static CacheTable GetStaticPropertyReflectionTable(Type type);
    private static CacheTable GetStaticMethodReflectionTable(Type type);
    private static Dictionary`2<string, EventCacheEntry> GetStaticEventReflectionTable(Type type);
    private static CacheTable GetInstancePropertyReflectionTable(Type type);
    private static CacheTable GetInstanceMethodReflectionTable(Type type);
    [IteratorStateMachineAttribute("System.Management.Automation.DotNetAdapter/<GetPropertiesAndMethods>d__29")]
internal IEnumerable`1<object> GetPropertiesAndMethods(Type type, bool static);
    private static Dictionary`2<string, EventCacheEntry> GetInstanceEventReflectionTable(Type type);
    internal static bool IsTypeParameterizedProperty(Type t);
    private T GetDotNetPropertyImpl(object obj, string propertyName, MemberNamePredicate predicate);
    private T GetDotNetMethodImpl(object obj, string methodName, MemberNamePredicate predicate);
    internal T GetDotNetProperty(object obj, string propertyName);
    internal T GetDotNetMethod(object obj, string methodName);
    protected T GetFirstDotNetPropertyOrDefault(object obj, MemberNamePredicate predicate);
    protected T GetFirstDotNetMethodOrDefault(object obj, MemberNamePredicate predicate);
    protected T GetFirstDotNetEventOrDefault(object obj, MemberNamePredicate predicate);
    protected T GetFirstDynamicMemberOrDefault(object obj, MemberNamePredicate predicate);
    internal void AddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members, bool ignoreDuplicates);
    internal void AddAllMethods(object obj, PSMemberInfoInternalCollection`1<T> members, bool ignoreDuplicates);
    internal void AddAllEvents(object obj, PSMemberInfoInternalCollection`1<T> members, bool ignoreDuplicates);
    internal void AddAllDynamicMembers(object obj, PSMemberInfoInternalCollection`1<T> members, bool ignoreDuplicates);
    private static bool PropertyIsStatic(PSProperty property);
    private static string GetDefaultValueStringRepresentation(ParameterInfo parameterInfo);
    internal virtual bool CanSiteBinderOptimize(MemberTypes typeToOperateOn);
    internal static ConsolidatedString GetInternedTypeNameHierarchy(Type type);
    protected virtual ConsolidatedString GetInternedTypeNameHierarchy(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
    protected virtual AttributeCollection PropertyAttributes(PSProperty property);
    protected virtual string PropertyToString(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    internal static object AuxiliaryConstructorInvoke(MethodInformation methodInformation, Object[] arguments, Object[] originalArguments);
    internal static object AuxiliaryMethodInvoke(object target, Object[] arguments, MethodInformation methodInformation, Object[] originalArguments);
    internal static MethodInformation[] GetMethodInformationArray(IList`1<MethodBase> methods);
    internal static object MethodInvokeDotNet(string methodName, object target, MethodInformation[] methodInformation, PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    internal static object ConstructorInvokeDotNet(Type type, ConstructorInfo[] constructors, Object[] arguments);
    private static object InvokeResolvedConstructor(MethodInformation bestMethod, Object[] newArguments, Object[] arguments);
    internal static void ParameterizedPropertyInvokeSet(string propertyName, object target, object valuetoSet, MethodInformation[] methodInformation, Object[] arguments);
    internal static string GetMethodInfoOverloadDefinition(string memberName, MethodBase methodEntry, int parametersToIgnore);
    protected virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected virtual object MethodInvoke(PSMethod method, PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    protected virtual Collection`1<string> MethodDefinitions(PSMethod method);
    protected virtual string ParameterizedPropertyType(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsSettable(PSParameterizedProperty property);
    protected virtual bool ParameterizedPropertyIsGettable(PSParameterizedProperty property);
    protected virtual object ParameterizedPropertyGet(PSParameterizedProperty property, Object[] arguments);
    protected virtual void ParameterizedPropertySet(PSParameterizedProperty property, object setValue, Object[] arguments);
    protected virtual Collection`1<string> ParameterizedPropertyDefinitions(PSParameterizedProperty property);
    protected virtual string ParameterizedPropertyToString(PSParameterizedProperty property);
}
internal class System.Management.Automation.DotNetAdapterWithComTypeName : DotNetAdapter {
    private ComTypeInfo _comTypeInfo;
    internal DotNetAdapterWithComTypeName(ComTypeInfo comTypeInfo);
    [IteratorStateMachineAttribute("System.Management.Automation.DotNetAdapterWithComTypeName/<GetTypeNameHierarchy>d__2")]
protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual ConsolidatedString GetInternedTypeNameHierarchy(object obj);
}
internal static class System.Management.Automation.DoubleOps : object {
    internal static object Add(double lhs, double rhs);
    internal static object Sub(double lhs, double rhs);
    internal static object Multiply(double lhs, double rhs);
    internal static object Divide(double lhs, double rhs);
    internal static object Remainder(double lhs, double rhs);
    internal static object BNot(double val);
    internal static object BOr(double lhs, double rhs);
    internal static object BXor(double lhs, double rhs);
    internal static object BAnd(double lhs, double rhs);
    private static ulong ConvertToUlong(double val);
    internal static object LeftShift(double val, int count);
    internal static object RightShift(double val, int count);
    internal static object CompareEq(double lhs, double rhs);
    internal static object CompareNe(double lhs, double rhs);
    internal static object CompareLt(double lhs, double rhs);
    internal static object CompareLe(double lhs, double rhs);
    internal static object CompareGt(double lhs, double rhs);
    internal static object CompareGe(double lhs, double rhs);
}
public class System.Management.Automation.DriveManagementIntrinsics : object {
    private SessionStateInternal _sessionState;
    public PSDriveInfo Current { get; }
    internal DriveManagementIntrinsics(SessionStateInternal sessionState);
    public PSDriveInfo get_Current();
    public PSDriveInfo New(PSDriveInfo drive, string scope);
    internal void New(PSDriveInfo drive, string scope, CmdletProviderContext context);
    internal object NewDriveDynamicParameters(string providerId, CmdletProviderContext context);
    public void Remove(string driveName, bool force, string scope);
    internal void Remove(string driveName, bool force, string scope, CmdletProviderContext context);
    public PSDriveInfo Get(string driveName);
    public PSDriveInfo GetAtScope(string driveName, string scope);
    public Collection`1<PSDriveInfo> GetAll();
    public Collection`1<PSDriveInfo> GetAllAtScope(string scope);
    public Collection`1<PSDriveInfo> GetAllForProvider(string providerName);
}
internal static class System.Management.Automation.DriveNames : object {
    internal static string VariableDrive;
    internal static string EnvironmentDrive;
    internal static string AliasDrive;
    internal static string FunctionDrive;
    internal static string TempDrive;
}
public class System.Management.Automation.DriveNotFoundException : SessionStateException {
    internal DriveNotFoundException(string itemName, string errorIdAndResourceId, string resourceStr);
    public DriveNotFoundException(string message);
    public DriveNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected DriveNotFoundException(SerializationInfo info, StreamingContext context);
}
internal class System.Management.Automation.DriveScopeItemSearcher : ScopedItemSearcher`1<PSDriveInfo> {
    public DriveScopeItemSearcher(SessionStateInternal sessionState, VariablePath lookupPath);
    protected virtual bool GetScopeItem(SessionStateScope scope, VariablePath name, PSDriveInfo& drive);
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.DscLocalConfigurationManagerAttribute : CmdletMetadataAttribute {
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.DscPropertyAttribute : CmdletMetadataAttribute {
    [CompilerGeneratedAttribute]
private bool <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotConfigurable>k__BackingField;
    public bool Key { get; public set; }
    public bool Mandatory { get; public set; }
    public bool NotConfigurable { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Key();
    [CompilerGeneratedAttribute]
public void set_Key(bool value);
    [CompilerGeneratedAttribute]
public bool get_Mandatory();
    [CompilerGeneratedAttribute]
public void set_Mandatory(bool value);
    [CompilerGeneratedAttribute]
public bool get_NotConfigurable();
    [CompilerGeneratedAttribute]
public void set_NotConfigurable(bool value);
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.DscResourceAttribute : CmdletMetadataAttribute {
    [CompilerGeneratedAttribute]
private DSCResourceRunAsCredential <RunAsCredential>k__BackingField;
    public DSCResourceRunAsCredential RunAsCredential { get; public set; }
    [CompilerGeneratedAttribute]
public DSCResourceRunAsCredential get_RunAsCredential();
    [CompilerGeneratedAttribute]
public void set_RunAsCredential(DSCResourceRunAsCredential value);
}
internal class System.Management.Automation.DscResourceHelpProvider : HelpProviderWithCache {
    private ExecutionContext _context;
    private Hashtable _helpFiles;
    [TraceSourceAttribute("DscResourceHelpProvider", "DscResourceHelpProvider")]
private static PSTraceSource s_tracer;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal DscResourceHelpProvider(HelpSystem helpSystem);
    private static DscResourceHelpProvider();
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    [IteratorStateMachineAttribute("System.Management.Automation.DscResourceHelpProvider/<SearchHelp>d__8")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    [IteratorStateMachineAttribute("System.Management.Automation.DscResourceHelpProvider/<ExactMatchHelp>d__9")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.DscResourceHelpProvider/<GetHelpInfo>d__10")]
private IEnumerable`1<HelpInfo> GetHelpInfo(DscResourceSearcher searcher);
    internal static bool IsMamlHelp(string helpFile, XmlNode helpItemsNode);
    private HelpInfo GetHelpInfoFromHelpFile(DscResourceInfo resourceInfo, string helpFileToFind, Collection`1<string> searchPaths, bool reportErrors, String& helpFile);
    private HelpInfo GetFromResourceHelpCache(string helpFileIdentifier, HelpCategory helpCategory);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier, string commandName, bool reportErrors);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier);
}
public class System.Management.Automation.DscResourceInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParentPath>k__BackingField;
    [CompilerGeneratedAttribute]
private ImplementedAsType <ImplementedAs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompanyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<DscResourcePropertyInfo> <Properties>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    public string Name { get; }
    public string ResourceType { get; public set; }
    public string FriendlyName { get; public set; }
    public string Path { get; public set; }
    public string ParentPath { get; public set; }
    public ImplementedAsType ImplementedAs { get; public set; }
    public string CompanyName { get; public set; }
    public ReadOnlyCollection`1<DscResourcePropertyInfo> Properties { get; private set; }
    public PSModuleInfo Module { get; internal set; }
    public string HelpFile { get; internal set; }
    internal DscResourceInfo(string name, string friendlyName, string path, string parentPath, ExecutionContext context);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_ResourceType();
    [CompilerGeneratedAttribute]
public void set_ResourceType(string value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
public void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_ParentPath();
    [CompilerGeneratedAttribute]
public void set_ParentPath(string value);
    [CompilerGeneratedAttribute]
public ImplementedAsType get_ImplementedAs();
    [CompilerGeneratedAttribute]
public void set_ImplementedAs(ImplementedAsType value);
    [CompilerGeneratedAttribute]
public string get_CompanyName();
    [CompilerGeneratedAttribute]
public void set_CompanyName(string value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<DscResourcePropertyInfo> get_Properties();
    [CompilerGeneratedAttribute]
private void set_Properties(ReadOnlyCollection`1<DscResourcePropertyInfo> value);
    public void UpdateProperties(IList`1<DscResourcePropertyInfo> properties);
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
internal void set_Module(PSModuleInfo value);
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
internal void set_HelpFile(string value);
}
public class System.Management.Automation.DscResourcePropertyInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Values>k__BackingField;
    public string Name { get; public set; }
    public string PropertyType { get; public set; }
    public bool IsMandatory { get; public set; }
    public ReadOnlyCollection`1<string> Values { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_PropertyType();
    [CompilerGeneratedAttribute]
public void set_PropertyType(string value);
    [CompilerGeneratedAttribute]
public bool get_IsMandatory();
    [CompilerGeneratedAttribute]
public void set_IsMandatory(bool value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Values();
    [CompilerGeneratedAttribute]
private void set_Values(ReadOnlyCollection`1<string> value);
    internal void UpdateValues(IList`1<string> values);
}
public enum System.Management.Automation.DSCResourceRunAsCredential : Enum {
    public int value__;
    public static DSCResourceRunAsCredential Default;
    public static DSCResourceRunAsCredential NotSupported;
    public static DSCResourceRunAsCredential Mandatory;
    public static DSCResourceRunAsCredential Optional;
}
internal class System.Management.Automation.DscResourceSearcher : object {
    private string _resourceName;
    private ExecutionContext _context;
    private DscResourceInfo _currentMatch;
    private IEnumerator`1<DscResourceInfo> _matchingResource;
    private Collection`1<DscResourceInfo> _matchingResourceList;
    private DscResourceInfo System.Collections.Generic.IEnumerator<System.Management.Automation.DscResourceInfo>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal DscResourceSearcher(string resourceName, ExecutionContext context);
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator`1<DscResourceInfo> System.Collections.Generic.IEnumerable<System.Management.Automation.DscResourceInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override DscResourceInfo System.Collections.Generic.IEnumerator<System.Management.Automation.DscResourceInfo>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private DscResourceInfo GetNextDscResource();
}
internal class System.Management.Automation.DummyLogProvider : LogProvider {
    internal virtual void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary`2<string, string> additionalInfo);
    internal virtual void LogEngineLifecycleEvent(LogContext logContext, EngineState newState, EngineState previousState);
    internal virtual void LogCommandHealthEvent(LogContext logContext, Exception exception);
    internal virtual void LogCommandLifecycleEvent(Func`1<LogContext> getLogContext, CommandState newState);
    internal virtual void LogPipelineExecutionDetailEvent(LogContext logContext, List`1<string> pipelineExecutionDetail);
    internal virtual void LogProviderHealthEvent(LogContext logContext, string providerName, Exception exception);
    internal virtual void LogProviderLifecycleEvent(LogContext logContext, string providerName, ProviderState newState);
    internal virtual void LogSettingsEvent(LogContext logContext, string variableName, string value, string previousValue);
    internal virtual void LogAmsiUtilStateEvent(string state, string context);
    internal virtual void LogWDACQueryEvent(string queryName, string fileName, int querySuccess, int queryResult);
    internal virtual void LogWDACAuditEvent(string title, string message, string fqid);
}
[AttributeUsageAttribute("1")]
public class System.Management.Automation.DynamicClassImplementationAssemblyAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ScriptFile>k__BackingField;
    public string ScriptFile { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ScriptFile();
    [CompilerGeneratedAttribute]
public void set_ScriptFile(string value);
}
internal class System.Management.Automation.EmbeddedRunspaceDebugger : NestedRunspaceDebugger {
    private PowerShell _command;
    private Debugger _rootDebugger;
    private ScriptBlockAst _parentScriptBlockAst;
    private DebuggerStopEventArgs _sendDebuggerArgs;
    public EmbeddedRunspaceDebugger(Runspace runspace, PowerShell command, Debugger rootDebugger, PSMonitorRunspaceType runspaceType, Guid parentDebuggerId);
    protected virtual void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    protected virtual DebuggerCommandResults HandleCallStack(PSDataCollection`1<PSObject> output);
    protected virtual bool HandleListCommand(PSDataCollection`1<PSObject> output);
    internal virtual InvocationInfo FixupInvocationInfo(InvocationInfo debugStopInvocationInfo);
    public virtual void Dispose();
    private InvocationInfo CreateInvocationInfoFromParent(CallStackFrame parentStackFrame, int debugLineNumber, int debugStartColNumber, int debugEndColNumber);
    private static string FixUpStatementExtent(int startColNum, string stateExtentText);
    private object DrainAndBlockRemoteOutput();
    private static void RestoreRemoteOutput(object runningCmd);
}
internal static class System.Management.Automation.EncodingConversion : object {
    internal static string ANSI;
    internal static string Ascii;
    internal static string BigEndianUnicode;
    internal static string BigEndianUtf32;
    internal static string Default;
    internal static string OEM;
    internal static string String;
    internal static string Unicode;
    internal static string Unknown;
    internal static string Utf7;
    internal static string Utf8;
    internal static string Utf8Bom;
    internal static string Utf8NoBom;
    internal static string Utf32;
    internal static String[] TabCompletionResults;
    internal static Dictionary`2<string, Encoding> encodingMap;
    private static EncodingConversion();
    internal static Encoding Convert(Cmdlet cmdlet, string encoding);
    internal static void WarnIfObsolete(Cmdlet cmdlet, Encoding encoding);
}
public class System.Management.Automation.EngineIntrinsics : object {
    private ExecutionContext _context;
    private PSHost _host;
    private CommandInvocationIntrinsics _invokeCommand;
    public PSHost Host { get; }
    public PSEventManager Events { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    public SessionState SessionState { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    internal EngineIntrinsics(ExecutionContext context);
    public PSHost get_Host();
    public PSEventManager get_Events();
    public ProviderIntrinsics get_InvokeProvider();
    public SessionState get_SessionState();
    public CommandInvocationIntrinsics get_InvokeCommand();
}
internal enum System.Management.Automation.EngineState : Enum {
    public int value__;
    public static EngineState None;
    public static EngineState Available;
    public static EngineState Degraded;
    public static EngineState OutOfService;
    public static EngineState Stopped;
}
public class System.Management.Automation.EntrySelectedBy : object {
    [CompilerGeneratedAttribute]
private List`1<string> <TypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DisplayEntry> <SelectionCondition>k__BackingField;
    public List`1<string> TypeNames { get; public set; }
    public List`1<DisplayEntry> SelectionCondition { get; public set; }
    [CompilerGeneratedAttribute]
public List`1<string> get_TypeNames();
    [CompilerGeneratedAttribute]
public void set_TypeNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<DisplayEntry> get_SelectionCondition();
    [CompilerGeneratedAttribute]
public void set_SelectionCondition(List`1<DisplayEntry> value);
    internal static EntrySelectedBy Get(IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    internal static EntrySelectedBy Get(List`1<TypeOrGroupReference> references);
    internal bool SafeForExport();
    internal bool CompatibleWithOldPowerShell();
}
[ExtensionAttribute]
internal static class System.Management.Automation.EnumerableExtensions : object {
    [IteratorStateMachineAttribute("System.Management.Automation.EnumerableExtensions/<Prepend>d__0`1")]
[ExtensionAttribute]
internal static IEnumerable`1<T> Prepend(IEnumerable`1<T> collection, T element);
    [ExtensionAttribute]
internal static int SequenceGetHashCode(IEnumerable`1<T> xs);
}
internal static class System.Management.Automation.EnumerableOps : object {
    internal static object Where(IEnumerator enumerator, ScriptBlock expressionSB, WhereOperatorSelectionMode selectionMode, int numberToReturn);
    internal static object ForEach(IEnumerator enumerator, object expression, Object[] arguments);
    internal static object SlicingIndex(object target, IEnumerator indexes, Func`3<object, object, object> indexer);
    private static void FlattenResults(object o, List`1<object> result);
    private static void PropertyGetterWorker(CallSite`1<Func`3<CallSite, object, object>> getMemberBinderSite, IEnumerator enumerator, ExecutionContext context, List`1<object> result);
    internal static object PropertyGetter(PSGetMemberBinder binder, IEnumerator enumerator);
    private static void MethodInvokerWorker(CallSite invokeMemberSite, IEnumerator enumerator, Object[] args, ExecutionContext context, List`1<object> result, Boolean& foundMethod);
    internal static object MethodInvoker(PSInvokeMemberBinder binder, Type delegateType, IEnumerator enumerator, Object[] args, Type typeForMessage);
    internal static object Multiply(IEnumerator enumerator, UInt32 times);
    internal static IEnumerator GetEnumerator(IEnumerable enumerable);
    internal static IEnumerator GetCOMEnumerator(object obj);
    internal static IEnumerator GetGenericEnumerator(IEnumerable`1<T> enumerable);
    internal static bool MoveNext(ExecutionContext context, IEnumerator enumerator);
    internal static object Current(IEnumerator enumerator);
    internal static object AddFakeEnumerable(NonEnumerableObjectEnumerator fakeEnumerator, object rhs);
    internal static object AddEnumerable(ExecutionContext context, IEnumerator lhs, IEnumerator rhs);
    internal static object AddObject(ExecutionContext context, IEnumerator lhs, object rhs);
    internal static object Compare(IEnumerator enumerator, object valueToCompareTo, Func`3<object, object, bool> compareDelegate);
    internal static void WriteEnumerableToPipe(IEnumerator enumerator, Pipe pipe, ExecutionContext context, bool dispose);
    internal static Object[] ToArray(IEnumerator enumerator);
    internal static Object[] GetSlice(IList list, int startIndex);
}
internal static class System.Management.Automation.EnumMinimumDisambiguation : object {
    private static Dictionary`2<Type, String[]> s_specialDisambiguateCases;
    private static EnumMinimumDisambiguation();
    internal static string EnumDisambiguate(string text, Type enumType);
    internal static string EnumAllValues(Type enumType);
}
public enum System.Management.Automation.ErrorCategory : Enum {
    public int value__;
    public static ErrorCategory NotSpecified;
    public static ErrorCategory OpenError;
    public static ErrorCategory CloseError;
    public static ErrorCategory DeviceError;
    public static ErrorCategory DeadlockDetected;
    public static ErrorCategory InvalidArgument;
    public static ErrorCategory InvalidData;
    public static ErrorCategory InvalidOperation;
    public static ErrorCategory InvalidResult;
    public static ErrorCategory InvalidType;
    public static ErrorCategory MetadataError;
    public static ErrorCategory NotImplemented;
    public static ErrorCategory NotInstalled;
    public static ErrorCategory ObjectNotFound;
    public static ErrorCategory OperationStopped;
    public static ErrorCategory OperationTimeout;
    public static ErrorCategory SyntaxError;
    public static ErrorCategory ParserError;
    public static ErrorCategory PermissionDenied;
    public static ErrorCategory ResourceBusy;
    public static ErrorCategory ResourceExists;
    public static ErrorCategory ResourceUnavailable;
    public static ErrorCategory ReadError;
    public static ErrorCategory WriteError;
    public static ErrorCategory FromStdErr;
    public static ErrorCategory SecurityError;
    public static ErrorCategory ProtocolError;
    public static ErrorCategory ConnectionError;
    public static ErrorCategory AuthenticationError;
    public static ErrorCategory LimitsExceeded;
    public static ErrorCategory QuotaExceeded;
    public static ErrorCategory NotEnabled;
}
public class System.Management.Automation.ErrorCategoryInfo : object {
    private bool _reasonIsExceptionType;
    private ErrorRecord _errorRecord;
    public ErrorCategory Category { get; }
    public string Activity { get; public set; }
    public string Reason { get; public set; }
    public string TargetName { get; public set; }
    public string TargetType { get; public set; }
    internal ErrorCategoryInfo(ErrorRecord errorRecord);
    public ErrorCategory get_Category();
    public string get_Activity();
    public void set_Activity(string value);
    public string get_Reason();
    public void set_Reason(string value);
    public string get_TargetName();
    public void set_TargetName(string value);
    public string get_TargetType();
    public void set_TargetType(string value);
    public string GetMessage();
    public string GetMessage(CultureInfo uiCultureInfo);
    public virtual string ToString();
    internal static string Ellipsize(CultureInfo uiCultureInfo, string original);
}
public class System.Management.Automation.ErrorDetails : object {
    private string _message;
    private string _recommendedAction;
    private Exception _textLookupError;
    public string Message { get; }
    public string RecommendedAction { get; public set; }
    internal Exception TextLookupError { get; internal set; }
    public ErrorDetails(string message);
    public ErrorDetails(Cmdlet cmdlet, string baseName, string resourceId, Object[] args);
    public ErrorDetails(IResourceSupplier resourceSupplier, string baseName, string resourceId, Object[] args);
    public ErrorDetails(Assembly assembly, string baseName, string resourceId, Object[] args);
    internal ErrorDetails(ErrorDetails errorDetails);
    protected ErrorDetails(SerializationInfo info, StreamingContext context);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_Message();
    public string get_RecommendedAction();
    public void set_RecommendedAction(string value);
    internal Exception get_TextLookupError();
    internal void set_TextLookupError(Exception value);
    public virtual string ToString();
    private string BuildMessage(Cmdlet cmdlet, string baseName, string resourceId, Object[] args);
    private string BuildMessage(IResourceSupplier resourceSupplier, string baseName, string resourceId, Object[] args);
    private string BuildMessage(Assembly assembly, string baseName, string resourceId, Object[] args);
    private string BuildMessage(string template, string baseName, string resourceId, Object[] args);
}
public class System.Management.Automation.ErrorRecord : object {
    private bool _isSerialized;
    private string _serializedFullyQualifiedErrorId;
    internal string _serializedErrorCategoryMessageOverride;
    private Exception _error;
    private object _target;
    private ErrorCategoryInfo _categoryInfo;
    [CompilerGeneratedAttribute]
private ErrorDetails <ErrorDetails>k__BackingField;
    private InvocationInfo _invocationInfo;
    [CompilerGeneratedAttribute]
private bool <PreserveInvocationInfoOnce>k__BackingField;
    private string _scriptStackTrace;
    private ReadOnlyCollection`1<int> _pipelineIterationInfo;
    private bool _serializeExtendedInfo;
    private string _errorId;
    internal ErrorCategory _category;
    internal string _activityOverride;
    internal string _reasonOverride;
    internal string _targetNameOverride;
    internal string _targetTypeOverride;
    internal bool IsSerialized { get; }
    public Exception Exception { get; }
    public object TargetObject { get; }
    public ErrorCategoryInfo CategoryInfo { get; }
    public string FullyQualifiedErrorId { get; }
    public ErrorDetails ErrorDetails { get; public set; }
    public InvocationInfo InvocationInfo { get; }
    internal bool PreserveInvocationInfoOnce { get; internal set; }
    public string ScriptStackTrace { get; }
    public ReadOnlyCollection`1<int> PipelineIterationInfo { get; }
    internal bool SerializeExtendedInfo { get; internal set; }
    public ErrorRecord(Exception exception, string errorId, ErrorCategory errorCategory, object targetObject);
    protected ErrorRecord(SerializationInfo info, StreamingContext context);
    internal ErrorRecord(Exception exception, object targetObject, string fullyQualifiedErrorId, ErrorCategory errorCategory, string errorCategory_Activity, string errorCategory_Reason, string errorCategory_TargetName, string errorCategory_TargetType, string errorCategory_Message, string errorDetails_Message, string errorDetails_RecommendedAction);
    public ErrorRecord(ErrorRecord errorRecord, Exception replaceParentContainsErrorRecordException);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal bool get_IsSerialized();
    private void PopulateProperties(Exception exception, object targetObject, string fullyQualifiedErrorId, ErrorCategory errorCategory, string errorCategory_Activity, string errorCategory_Reason, string errorCategory_TargetName, string errorCategory_TargetType, string errorCategory_Message, string errorDetails_Message, string errorDetails_RecommendedAction, string errorDetails_ScriptStackTrace);
    internal void ToPSObjectForRemoting(PSObject dest);
    private void ToPSObjectForRemoting(PSObject dest, bool serializeExtInfo);
    private static object GetNoteValue(PSObject mshObject, string note);
    internal static ErrorRecord FromPSObjectForRemoting(PSObject serializedErrorRecord);
    private void ConstructFromPSObjectForRemoting(PSObject serializedErrorRecord);
    internal virtual ErrorRecord WrapException(Exception replaceParentContainsErrorRecordException);
    public Exception get_Exception();
    public object get_TargetObject();
    internal void SetTargetObject(object target);
    public ErrorCategoryInfo get_CategoryInfo();
    public string get_FullyQualifiedErrorId();
    [CompilerGeneratedAttribute]
public ErrorDetails get_ErrorDetails();
    [CompilerGeneratedAttribute]
public void set_ErrorDetails(ErrorDetails value);
    public InvocationInfo get_InvocationInfo();
    internal void SetInvocationInfo(InvocationInfo invocationInfo);
    [CompilerGeneratedAttribute]
internal bool get_PreserveInvocationInfoOnce();
    [CompilerGeneratedAttribute]
internal void set_PreserveInvocationInfoOnce(bool value);
    public string get_ScriptStackTrace();
    internal void LockScriptStackTrace();
    public ReadOnlyCollection`1<int> get_PipelineIterationInfo();
    internal bool get_SerializeExtendedInfo();
    internal void set_SerializeExtendedInfo(bool value);
    internal static string NotNull(string s);
    private string GetInvocationTypeName();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
private Exception <ToPSObjectForRemoting>b__12_0();
    [CompilerGeneratedAttribute]
private object <ToPSObjectForRemoting>b__12_1();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_2();
    [CompilerGeneratedAttribute]
private InvocationInfo <ToPSObjectForRemoting>b__12_3();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__12_4();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_5();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_6();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_7();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_8();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_9();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_10();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_11();
    [CompilerGeneratedAttribute]
private object <ToPSObjectForRemoting>b__12_14();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__12_15();
}
internal class System.Management.Automation.ErrorRecord`1 : ErrorRecord {
    [CompilerGeneratedAttribute]
private TException <Exception>k__BackingField;
    public TException Exception { get; }
    public ErrorRecord`1(Exception exception, string errorId, ErrorCategory errorCategory, object targetObject);
    [CompilerGeneratedAttribute]
public TException get_Exception();
}
public enum System.Management.Automation.ErrorView : Enum {
    public int value__;
    public static ErrorView NormalView;
    public static ErrorView CategoryView;
    public static ErrorView ConciseView;
    public static ErrorView DetailedView;
}
internal class System.Management.Automation.EventAction : object {
    [CompilerGeneratedAttribute]
private PSEventSubscriber <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private PSEventArgs <Args>k__BackingField;
    public PSEventSubscriber Sender { get; }
    public PSEventArgs Args { get; }
    public EventAction(PSEventSubscriber sender, PSEventArgs args);
    [CompilerGeneratedAttribute]
public PSEventSubscriber get_Sender();
    [CompilerGeneratedAttribute]
public PSEventArgs get_Args();
}
internal static class System.Management.Automation.ExceptionHandlingOps : object {
    private static Int32[] RankExceptionTypes(Type[] types);
    private static void FindAndProcessHandler(Type[] types, Int32[] ranks, HandlerSearchResult current, Exception exception, ErrorRecord errorRecord);
    internal static int FindMatchingHandler(MutableTuple tuple, RuntimeException rte, Type[] types, ExecutionContext context);
    private static int FindMatchingHandlerByType(Type exceptionType, Type[] types);
    internal static bool SuspendStoppingPipeline(ExecutionContext context);
    internal static void RestoreStoppingPipeline(ExecutionContext context, bool oldIsStopping);
    internal static bool SuspendStoppingPipelineImpl(LocalPipeline localPipeline);
    internal static void RestoreStoppingPipelineImpl(LocalPipeline localPipeline, bool oldIsStopping);
    internal static void CheckActionPreference(FunctionContext funcContext, Exception exception);
    private static ActionPreference ProcessTraps(FunctionContext funcContext, RuntimeException rte);
    internal static ActionPreference GetErrorActionPreference(ExecutionContext context);
    internal static ActionPreference QueryForAction(RuntimeException rte, string message, ExecutionContext context);
    internal static ActionPreference InquireForActionPreference(string message, ExecutionContext context);
    internal static void SetErrorVariables(IScriptExtent extent, RuntimeException rte, ExecutionContext context, Pipe outputPipe);
    internal static bool ExceptionCannotBeStoppedContinuedOrIgnored(RuntimeException rte, ExecutionContext context);
    internal static bool ReportErrorRecord(IScriptExtent extent, RuntimeException rte, ExecutionContext context);
    internal static RuntimeException ConvertToException(object result, IScriptExtent extent, bool rethrow);
    internal static RuntimeException ConvertToRuntimeException(Exception exception, IScriptExtent extent);
    internal static void ConvertToArgumentConversionException(Exception exception, string parameterName, object argument, string method, Type toType);
    internal static void ConvertToMethodInvocationException(Exception exception, Type typeToThrow, string methodName, int numArgs, MemberInfo memberInfo);
}
internal class System.Management.Automation.ExecutionContext : object {
    [CompilerGeneratedAttribute]
private PSLocalEventManager <Events>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AutoLoadingModuleInProgress>k__BackingField;
    internal ScriptDebugger _debugger;
    internal int _debuggingMode;
    private int _debugTraceLevel;
    private bool _debugTraceStep;
    [CompilerGeneratedAttribute]
private bool <ScriptCommandProcessorShouldRethrowExit>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreScriptDebug>k__BackingField;
    [CompilerGeneratedAttribute]
private AutomationEngine <Engine>k__BackingField;
    [CompilerGeneratedAttribute]
private InitialSessionState <InitialSessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreviousModuleProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <previousModuleImported>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleBeingProcessed>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorizationManager <AuthorizationManager>k__BackingField;
    private ProviderNames _providerNames;
    [CompilerGeneratedAttribute]
private ModuleIntrinsics <Modules>k__BackingField;
    private string _shellId;
    [CompilerGeneratedAttribute]
private SessionStateInternal <EngineSessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateInternal <TopLevelSessionState>k__BackingField;
    private PSLanguageMode _languageMode;
    [CompilerGeneratedAttribute]
private bool <HasRunspaceEverUsedConstrainedLanguageMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LanguageModeTransitionInParameterBinding>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <HasEverUsedConstrainedLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private static ConditionalWeakTable`2<object, object> <UntrustedObjects>k__BackingField;
    internal static List`1<string> ModulesWithJobSourceAdapters;
    [CompilerGeneratedAttribute]
private bool <IsModuleWithJobSourceAdapterLoaded>k__BackingField;
    private LocationGlobber _locationGlobber;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Assembly> <AssemblyCache>k__BackingField;
    [CompilerGeneratedAttribute]
private EngineState <EngineState>k__BackingField;
    private HelpSystem _helpSystem;
    [CompilerGeneratedAttribute]
private object <FormatInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScriptBlock> <CustomArgumentCompleters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ScriptBlock> <NativeArgumentCompleters>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandProcessorBase <CurrentCommandProcessor>k__BackingField;
    [CompilerGeneratedAttribute]
private InternalHost <EngineHostInterface>k__BackingField;
    private EngineIntrinsics _engineIntrinsics;
    [CompilerGeneratedAttribute]
private LogContextCache <LogContextCache>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineWriter <ExternalSuccessOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineWriter <ExternalErrorOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineWriter <ExternalProgressOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <ShellFunctionErrorOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <ExpressionWarningOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <ExpressionVerboseOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <ExpressionDebugOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <ExpressionInformationOutputPipe>k__BackingField;
    private Runspace _currentRunspace;
    [CompilerGeneratedAttribute]
private bool <PropagateExceptionsToEnclosingStatementBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeException <CurrentExceptionBeingHandled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <QuestionMarkVariableValue>k__BackingField;
    private TypeTable _typeTable;
    private WeakReference`1<TypeTable> _typeTableWeakReference;
    private TypeInfoDataBaseManager _formatDBManager;
    internal PSTransactionManager transactionManager;
    private static object lockObject;
    internal PSLocalEventManager Events { get; private set; }
    internal HashSet`1<string> AutoLoadingModuleInProgress { get; }
    internal ScriptDebugger Debugger { get; }
    internal int PSDebugTraceLevel { get; internal set; }
    internal bool PSDebugTraceStep { get; internal set; }
    internal bool ShouldTraceStatement { get; }
    internal bool ScriptCommandProcessorShouldRethrowExit { get; internal set; }
    internal bool IgnoreScriptDebug { get; internal set; }
    internal AutomationEngine Engine { get; private set; }
    internal InitialSessionState InitialSessionState { get; }
    internal string PreviousModuleProcessed { get; internal set; }
    internal Hashtable previousModuleImported { get; internal set; }
    internal string ModuleBeingProcessed { get; internal set; }
    internal AuthorizationManager AuthorizationManager { get; private set; }
    internal ProviderNames ProviderNames { get; }
    internal ModuleIntrinsics Modules { get; private set; }
    internal string ShellID { get; }
    internal SessionStateInternal EngineSessionState { get; internal set; }
    internal SessionStateInternal TopLevelSessionState { get; private set; }
    internal SessionState SessionState { get; }
    internal PSLanguageMode LanguageMode { get; internal set; }
    internal bool HasRunspaceEverUsedConstrainedLanguageMode { get; private set; }
    internal bool LanguageModeTransitionInParameterBinding { get; internal set; }
    internal static bool HasEverUsedConstrainedLanguage { get; private set; }
    private static ConditionalWeakTable`2<object, object> UntrustedObjects { get; private set; }
    internal bool UseFullLanguageModeInDebugger { get; }
    internal bool IsModuleWithJobSourceAdapterLoaded { get; internal set; }
    internal LocationGlobber LocationGlobber { get; }
    internal Dictionary`2<string, Assembly> AssemblyCache { get; private set; }
    internal EngineState EngineState { get; internal set; }
    internal HelpSystem HelpSystem { get; }
    internal object FormatInfo { get; internal set; }
    internal Dictionary`2<string, ScriptBlock> CustomArgumentCompleters { get; internal set; }
    internal Dictionary`2<string, ScriptBlock> NativeArgumentCompleters { get; internal set; }
    internal CommandProcessorBase CurrentCommandProcessor { get; internal set; }
    internal CommandDiscovery CommandDiscovery { get; }
    internal InternalHost EngineHostInterface { get; private set; }
    internal InternalHost InternalHost { get; }
    internal EngineIntrinsics EngineIntrinsics { get; }
    internal LogContextCache LogContextCache { get; }
    internal PipelineWriter ExternalSuccessOutput { get; internal set; }
    internal PipelineWriter ExternalErrorOutput { get; internal set; }
    internal PipelineWriter ExternalProgressOutput { get; internal set; }
    internal Pipe ShellFunctionErrorOutputPipe { get; internal set; }
    internal Pipe ExpressionWarningOutputPipe { get; internal set; }
    internal Pipe ExpressionVerboseOutputPipe { get; internal set; }
    internal Pipe ExpressionDebugOutputPipe { get; internal set; }
    internal Pipe ExpressionInformationOutputPipe { get; internal set; }
    internal Runspace CurrentRunspace { get; internal set; }
    internal bool CurrentPipelineStopping { get; }
    internal bool PropagateExceptionsToEnclosingStatementBlock { get; internal set; }
    internal RuntimeException CurrentExceptionBeingHandled { get; internal set; }
    internal bool QuestionMarkVariableValue { get; internal set; }
    internal object DollarErrorVariable { get; internal set; }
    internal ActionPreference DebugPreferenceVariable { get; internal set; }
    internal ActionPreference VerbosePreferenceVariable { get; internal set; }
    internal ActionPreference ErrorActionPreferenceVariable { get; internal set; }
    internal ActionPreference WarningActionPreferenceVariable { get; internal set; }
    internal ActionPreference InformationActionPreferenceVariable { get; internal set; }
    internal object WhatIfPreferenceVariable { get; internal set; }
    internal ConfirmImpact ConfirmPreferenceVariable { get; internal set; }
    internal TypeTable TypeTable { get; internal set; }
    internal WeakReference`1<TypeTable> TypeTableWeakReference { get; }
    internal TypeInfoDataBaseManager FormatDBManager { get; internal set; }
    internal PSTransactionManager TransactionManager { get; }
    internal ExecutionContext(AutomationEngine engine, PSHost hostInterface, InitialSessionState initialSessionState);
    private static ExecutionContext();
    [CompilerGeneratedAttribute]
internal PSLocalEventManager get_Events();
    [CompilerGeneratedAttribute]
private void set_Events(PSLocalEventManager value);
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_AutoLoadingModuleInProgress();
    internal ScriptDebugger get_Debugger();
    internal void ResetManagers();
    internal int get_PSDebugTraceLevel();
    internal void set_PSDebugTraceLevel(int value);
    internal bool get_PSDebugTraceStep();
    internal void set_PSDebugTraceStep(bool value);
    internal static bool IsStrictVersion(ExecutionContext context, int majorVersion);
    internal bool IsStrictVersion(int majorVersion);
    internal bool get_ShouldTraceStatement();
    [CompilerGeneratedAttribute]
internal bool get_ScriptCommandProcessorShouldRethrowExit();
    [CompilerGeneratedAttribute]
internal void set_ScriptCommandProcessorShouldRethrowExit(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreScriptDebug();
    [CompilerGeneratedAttribute]
internal void set_IgnoreScriptDebug(bool value);
    [CompilerGeneratedAttribute]
internal AutomationEngine get_Engine();
    [CompilerGeneratedAttribute]
private void set_Engine(AutomationEngine value);
    [CompilerGeneratedAttribute]
internal InitialSessionState get_InitialSessionState();
    [CompilerGeneratedAttribute]
internal string get_PreviousModuleProcessed();
    [CompilerGeneratedAttribute]
internal void set_PreviousModuleProcessed(string value);
    [CompilerGeneratedAttribute]
internal Hashtable get_previousModuleImported();
    [CompilerGeneratedAttribute]
internal void set_previousModuleImported(Hashtable value);
    [CompilerGeneratedAttribute]
internal string get_ModuleBeingProcessed();
    [CompilerGeneratedAttribute]
internal void set_ModuleBeingProcessed(string value);
    [CompilerGeneratedAttribute]
internal AuthorizationManager get_AuthorizationManager();
    [CompilerGeneratedAttribute]
private void set_AuthorizationManager(AuthorizationManager value);
    internal ProviderNames get_ProviderNames();
    [CompilerGeneratedAttribute]
internal ModuleIntrinsics get_Modules();
    [CompilerGeneratedAttribute]
private void set_Modules(ModuleIntrinsics value);
    internal string get_ShellID();
    [CompilerGeneratedAttribute]
internal SessionStateInternal get_EngineSessionState();
    [CompilerGeneratedAttribute]
internal void set_EngineSessionState(SessionStateInternal value);
    [CompilerGeneratedAttribute]
internal SessionStateInternal get_TopLevelSessionState();
    [CompilerGeneratedAttribute]
private void set_TopLevelSessionState(SessionStateInternal value);
    internal SessionState get_SessionState();
    internal PSLanguageMode get_LanguageMode();
    internal void set_LanguageMode(PSLanguageMode value);
    [CompilerGeneratedAttribute]
internal bool get_HasRunspaceEverUsedConstrainedLanguageMode();
    [CompilerGeneratedAttribute]
private void set_HasRunspaceEverUsedConstrainedLanguageMode(bool value);
    [CompilerGeneratedAttribute]
internal bool get_LanguageModeTransitionInParameterBinding();
    [CompilerGeneratedAttribute]
internal void set_LanguageModeTransitionInParameterBinding(bool value);
    [CompilerGeneratedAttribute]
internal static bool get_HasEverUsedConstrainedLanguage();
    [CompilerGeneratedAttribute]
private static void set_HasEverUsedConstrainedLanguage(bool value);
    [CompilerGeneratedAttribute]
private static ConditionalWeakTable`2<object, object> get_UntrustedObjects();
    [CompilerGeneratedAttribute]
private static void set_UntrustedObjects(ConditionalWeakTable`2<object, object> value);
    internal static bool IsMarkedAsUntrusted(object value);
    internal static void MarkObjectAsUntrusted(object value);
    internal static void MarkObjectAsUntrustedForVariableAssignment(PSVariable variable, SessionStateScope scope, SessionStateInternal sessionState);
    internal static void PropagateInputSource(object originalObject, object resultObject, PSLanguageMode currentLanguageMode);
    internal bool get_UseFullLanguageModeInDebugger();
    [CompilerGeneratedAttribute]
internal bool get_IsModuleWithJobSourceAdapterLoaded();
    [CompilerGeneratedAttribute]
internal void set_IsModuleWithJobSourceAdapterLoaded(bool value);
    internal LocationGlobber get_LocationGlobber();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, Assembly> get_AssemblyCache();
    [CompilerGeneratedAttribute]
private void set_AssemblyCache(Dictionary`2<string, Assembly> value);
    [CompilerGeneratedAttribute]
internal EngineState get_EngineState();
    [CompilerGeneratedAttribute]
internal void set_EngineState(EngineState value);
    internal object GetVariableValue(VariablePath path);
    internal object GetVariableValue(VariablePath path, object defaultValue);
    internal void SetVariable(VariablePath path, object newValue);
    internal T GetEnumPreference(VariablePath preferenceVariablePath, T defaultPref, Boolean& defaultUsed);
    private void CheckActionPreference(VariablePath preferenceVariablePath, ActionPreference preference, object defaultValue);
    internal bool GetBooleanPreference(VariablePath preferenceVariablePath, bool defaultPref, Boolean& defaultUsed);
    internal HelpSystem get_HelpSystem();
    [CompilerGeneratedAttribute]
internal object get_FormatInfo();
    [CompilerGeneratedAttribute]
internal void set_FormatInfo(object value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ScriptBlock> get_CustomArgumentCompleters();
    [CompilerGeneratedAttribute]
internal void set_CustomArgumentCompleters(Dictionary`2<string, ScriptBlock> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, ScriptBlock> get_NativeArgumentCompleters();
    [CompilerGeneratedAttribute]
internal void set_NativeArgumentCompleters(Dictionary`2<string, ScriptBlock> value);
    internal CommandProcessorBase CreateCommand(string command, bool dotSource);
    [CompilerGeneratedAttribute]
internal CommandProcessorBase get_CurrentCommandProcessor();
    [CompilerGeneratedAttribute]
internal void set_CurrentCommandProcessor(CommandProcessorBase value);
    internal CommandDiscovery get_CommandDiscovery();
    [CompilerGeneratedAttribute]
internal InternalHost get_EngineHostInterface();
    [CompilerGeneratedAttribute]
private void set_EngineHostInterface(InternalHost value);
    internal InternalHost get_InternalHost();
    internal EngineIntrinsics get_EngineIntrinsics();
    [CompilerGeneratedAttribute]
internal LogContextCache get_LogContextCache();
    [CompilerGeneratedAttribute]
internal PipelineWriter get_ExternalSuccessOutput();
    [CompilerGeneratedAttribute]
internal void set_ExternalSuccessOutput(PipelineWriter value);
    [CompilerGeneratedAttribute]
internal PipelineWriter get_ExternalErrorOutput();
    [CompilerGeneratedAttribute]
internal void set_ExternalErrorOutput(PipelineWriter value);
    [CompilerGeneratedAttribute]
internal PipelineWriter get_ExternalProgressOutput();
    [CompilerGeneratedAttribute]
internal void set_ExternalProgressOutput(PipelineWriter value);
    internal SavedContextData SaveContextData();
    internal void ResetShellFunctionErrorOutputPipe();
    internal Pipe RedirectErrorPipe(Pipe newPipe);
    internal void ResetRedirection();
    [CompilerGeneratedAttribute]
internal Pipe get_ShellFunctionErrorOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_ShellFunctionErrorOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_ExpressionWarningOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_ExpressionWarningOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_ExpressionVerboseOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_ExpressionVerboseOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_ExpressionDebugOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_ExpressionDebugOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_ExpressionInformationOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_ExpressionInformationOutputPipe(Pipe value);
    internal void AppendDollarError(object obj);
    internal static void CheckStackDepth();
    internal Runspace get_CurrentRunspace();
    internal void set_CurrentRunspace(Runspace value);
    internal void PushPipelineProcessor(PipelineProcessor pp);
    internal void PopPipelineProcessor(bool fromSteppablePipeline);
    internal bool get_CurrentPipelineStopping();
    [CompilerGeneratedAttribute]
internal bool get_PropagateExceptionsToEnclosingStatementBlock();
    [CompilerGeneratedAttribute]
internal void set_PropagateExceptionsToEnclosingStatementBlock(bool value);
    [CompilerGeneratedAttribute]
internal RuntimeException get_CurrentExceptionBeingHandled();
    [CompilerGeneratedAttribute]
internal void set_CurrentExceptionBeingHandled(RuntimeException value);
    [CompilerGeneratedAttribute]
internal bool get_QuestionMarkVariableValue();
    [CompilerGeneratedAttribute]
internal void set_QuestionMarkVariableValue(bool value);
    internal object get_DollarErrorVariable();
    internal void set_DollarErrorVariable(object value);
    internal ActionPreference get_DebugPreferenceVariable();
    internal void set_DebugPreferenceVariable(ActionPreference value);
    internal ActionPreference get_VerbosePreferenceVariable();
    internal void set_VerbosePreferenceVariable(ActionPreference value);
    internal ActionPreference get_ErrorActionPreferenceVariable();
    internal void set_ErrorActionPreferenceVariable(ActionPreference value);
    internal ActionPreference get_WarningActionPreferenceVariable();
    internal void set_WarningActionPreferenceVariable(ActionPreference value);
    internal ActionPreference get_InformationActionPreferenceVariable();
    internal void set_InformationActionPreferenceVariable(ActionPreference value);
    internal object get_WhatIfPreferenceVariable();
    internal void set_WhatIfPreferenceVariable(object value);
    internal ConfirmImpact get_ConfirmPreferenceVariable();
    internal void set_ConfirmPreferenceVariable(ConfirmImpact value);
    internal void RunspaceClosingNotification();
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    internal WeakReference`1<TypeTable> get_TypeTableWeakReference();
    internal TypeInfoDataBaseManager get_FormatDBManager();
    internal void set_FormatDBManager(TypeInfoDataBaseManager value);
    internal PSTransactionManager get_TransactionManager();
    internal Assembly AddAssembly(string source, string assemblyName, string filePath, Exception& error);
    internal void AddToAssemblyCache(string source, Assembly assembly);
    internal void RemoveFromAssemblyCache(string source);
    private bool TryGetFromAssemblyCache(string source, string filePath, Assembly& assembly);
    private static Assembly LoadAssembly(string name, string filePath, Exception& error);
    internal void ReportEngineStartupError(string resourceString, Object[] arguments);
    internal void ReportEngineStartupError(string error);
    internal void ReportEngineStartupError(Exception e);
    internal void ReportEngineStartupError(ErrorRecord errorRecord);
    private bool IsModuleCommandCurrentlyRunning(Cmdlet& command, String& errorId);
    private void InitializeCommon(AutomationEngine engine, PSHost hostInterface);
}
internal class System.Management.Automation.ExecutionContextForStepping : object {
    private ExecutionContext _executionContext;
    private PSInformationalBuffers _originalInformationalBuffers;
    private PSHost _originalHost;
    private ExecutionContextForStepping(ExecutionContext ctxt);
    internal static ExecutionContextForStepping PrepareExecutionContext(ExecutionContext ctxt, PSInformationalBuffers newBuffers, PSHost newHost);
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Management.Automation.ExitException : FlowControlException {
    [CompilerGeneratedAttribute]
private object <Argument>k__BackingField;
    public object Argument { get; internal set; }
    internal ExitException(object argument);
    [CompilerGeneratedAttribute]
public object get_Argument();
    [CompilerGeneratedAttribute]
internal void set_Argument(object value);
}
internal class System.Management.Automation.ExitNestedPromptException : FlowControlException {
}
public enum System.Management.Automation.ExperimentAction : Enum {
    public int value__;
    public static ExperimentAction None;
    public static ExperimentAction Hide;
    public static ExperimentAction Show;
}
[AttributeUsageAttribute("388")]
public class System.Management.Automation.ExperimentalAttribute : ParsingBaseAttribute {
    [CompilerGeneratedAttribute]
private string <ExperimentName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExperimentAction <ExperimentAction>k__BackingField;
    internal static ExperimentalAttribute None;
    private ExperimentAction _effectiveAction;
    public string ExperimentName { get; }
    public ExperimentAction ExperimentAction { get; }
    internal bool ToHide { get; }
    internal bool ToShow { get; }
    private ExperimentAction EffectiveAction { get; }
    public ExperimentalAttribute(string experimentName, ExperimentAction experimentAction);
    private static ExperimentalAttribute();
    [CompilerGeneratedAttribute]
public string get_ExperimentName();
    [CompilerGeneratedAttribute]
public ExperimentAction get_ExperimentAction();
    internal static void ValidateArguments(string experimentName, ExperimentAction experimentAction);
    internal bool get_ToHide();
    internal bool get_ToShow();
    private ExperimentAction get_EffectiveAction();
}
public class System.Management.Automation.ExperimentalFeature : object {
    internal static string EngineSource;
    internal static string PSModuleAutoLoadSkipOfflineFilesFeatureName;
    internal static string PSFeedbackProvider;
    internal static string PSCommandWithArgs;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Enabled>k__BackingField;
    internal static ReadOnlyCollection`1<ExperimentalFeature> EngineExperimentalFeatures;
    internal static ReadOnlyDictionary`2<string, ExperimentalFeature> EngineExperimentalFeatureMap;
    internal static ReadOnlyBag`1<string> EnabledExperimentalFeatureNames;
    public string Name { get; }
    public string Description { get; }
    public string Source { get; }
    public bool Enabled { get; private set; }
    internal ExperimentalFeature(string name, string description, string source, bool isEnabled);
    private ExperimentalFeature(string name, string description);
    private static ExperimentalFeature();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public bool get_Enabled();
    [CompilerGeneratedAttribute]
private void set_Enabled(bool value);
    private static void SendTelemetryForDeactivatedFeatures(ReadOnlyBag`1<string> enabledFeatures);
    private static ReadOnlyBag`1<string> ProcessEnabledFeatures(String[] enabledFeatures);
    private static bool LogException(Exception e);
    private static void LogError(PSEventId eventId, Object[] args);
    internal static bool IsEngineFeatureName(string featureName);
    internal static bool IsModuleFeatureName(string featureName, string moduleName);
    internal static ExperimentAction GetActionToTake(string experimentName, ExperimentAction experimentAction);
    public static bool IsEnabled(string featureName);
}
internal class System.Management.Automation.ExportVisitor : AstVisitor2 {
    private bool _forCompletion;
    [CompilerGeneratedAttribute]
private List`1<string> <DiscoveredExports>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RequiredModuleInfo> <DiscoveredModules>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, FunctionDefinitionAst> <DiscoveredFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <DiscoveredAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DiscoveredCommandFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddsSelfToPath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TypeDefinitionAst> <DiscoveredClasses>k__BackingField;
    private static Dictionary`2<string, ParameterBindingInfo> s_parameterBindingInfoTable;
    internal List`1<string> DiscoveredExports { get; internal set; }
    internal List`1<RequiredModuleInfo> DiscoveredModules { get; internal set; }
    internal Dictionary`2<string, FunctionDefinitionAst> DiscoveredFunctions { get; internal set; }
    internal Dictionary`2<string, string> DiscoveredAliases { get; internal set; }
    internal List`1<string> DiscoveredCommandFilters { get; internal set; }
    internal bool AddsSelfToPath { get; internal set; }
    internal List`1<TypeDefinitionAst> DiscoveredClasses { get; internal set; }
    internal ExportVisitor(bool forCompletion);
    private static ExportVisitor();
    [CompilerGeneratedAttribute]
internal List`1<string> get_DiscoveredExports();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredExports(List`1<string> value);
    [CompilerGeneratedAttribute]
internal List`1<RequiredModuleInfo> get_DiscoveredModules();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredModules(List`1<RequiredModuleInfo> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, FunctionDefinitionAst> get_DiscoveredFunctions();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredFunctions(Dictionary`2<string, FunctionDefinitionAst> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_DiscoveredAliases();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredAliases(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_DiscoveredCommandFilters();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredCommandFilters(List`1<string> value);
    [CompilerGeneratedAttribute]
internal bool get_AddsSelfToPath();
    [CompilerGeneratedAttribute]
internal void set_AddsSelfToPath(bool value);
    [CompilerGeneratedAttribute]
internal List`1<TypeDefinitionAst> get_DiscoveredClasses();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredClasses(List`1<TypeDefinitionAst> value);
    public virtual AstVisitAction VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual AstVisitAction VisitIfStatement(IfStatementAst ifStmtAst);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual AstVisitAction VisitForStatement(ForStatementAst forStatementAst);
    public virtual AstVisitAction VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public virtual AstVisitAction VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public virtual AstVisitAction VisitWhileStatement(WhileStatementAst whileStatementAst);
    public virtual AstVisitAction VisitInvokeMemberExpression(InvokeMemberExpressionAst methodCallAst);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual AstVisitAction VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public virtual AstVisitAction VisitCommand(CommandAst commandAst);
    private static void ProcessCmdletArguments(object value, Action`1<string> onEachArgument);
    private static Hashtable DoPsuedoParameterBinding(CommandAst commandAst, string commandName);
    [CompilerGeneratedAttribute]
private void <VisitCommand>b__44_2(string exportedCommandName);
    [CompilerGeneratedAttribute]
private void <VisitCommand>b__44_3(string exportedAlias);
}
public class System.Management.Automation.ExtendedTypeDefinition : object {
    [CompilerGeneratedAttribute]
private List`1<string> <TypeNames>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<FormatViewDefinition> <FormatViewDefinition>k__BackingField;
    public string TypeName { get; }
    public List`1<string> TypeNames { get; internal set; }
    public List`1<FormatViewDefinition> FormatViewDefinition { get; internal set; }
    public ExtendedTypeDefinition(string typeName, IEnumerable`1<FormatViewDefinition> viewDefinitions);
    public ExtendedTypeDefinition(string typeName);
    public string get_TypeName();
    [CompilerGeneratedAttribute]
public List`1<string> get_TypeNames();
    [CompilerGeneratedAttribute]
internal void set_TypeNames(List`1<string> value);
    [CompilerGeneratedAttribute]
public List`1<FormatViewDefinition> get_FormatViewDefinition();
    [CompilerGeneratedAttribute]
internal void set_FormatViewDefinition(List`1<FormatViewDefinition> value);
    public virtual string ToString();
}
public class System.Management.Automation.ExtendedTypeSystemException : RuntimeException {
    public ExtendedTypeSystemException(string message);
    public ExtendedTypeSystemException(string message, Exception innerException);
    internal ExtendedTypeSystemException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ExtendedTypeSystemException(SerializationInfo info, StreamingContext context);
}
[ExtensionAttribute]
internal static class System.Management.Automation.ExtensionMethods : object {
    [ExtensionAttribute]
public static void SafeInvoke(EventHandler eventHandler, object sender, EventArgs eventArgs);
    [ExtensionAttribute]
public static void SafeInvoke(EventHandler`1<T> eventHandler, object sender, T eventArgs);
}
public class System.Management.Automation.ExternalScriptInfo : CommandInfo {
    private string _path;
    private ScriptBlock _scriptBlock;
    private ScriptBlockAst _scriptBlockAst;
    private bool _signatureChecked;
    private CommandMetadata _commandMetadata;
    private string _scriptContents;
    private Encoding _originalEncoding;
    internal HelpCategory HelpCategory { get; }
    public string Path { get; }
    public string Definition { get; }
    public string Source { get; }
    internal string Syntax { get; }
    public SessionStateEntryVisibility Visibility { get; public set; }
    public ScriptBlock ScriptBlock { get; private set; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    unknown bool SignatureChecked {internal set; }
    internal CommandMetadata CommandMetadata { get; }
    internal bool ImplementsDynamicParameters { get; }
    internal string RequiresApplicationID { get; }
    internal UInt32 ApplicationIDLineNumber { get; }
    internal Version RequiresPSVersion { get; }
    internal IEnumerable`1<string> RequiresPSEditions { get; }
    internal IEnumerable`1<ModuleSpecification> RequiresModules { get; }
    internal bool RequiresElevation { get; }
    internal UInt32 PSVersionLineNumber { get; }
    public string ScriptContents { get; }
    public Encoding OriginalEncoding { get; }
    internal ExternalScriptInfo(string name, string path, ExecutionContext context);
    internal ExternalScriptInfo(string name, string path);
    internal ExternalScriptInfo(ExternalScriptInfo other);
    private void CommonInitialization();
    internal virtual CommandInfo CreateGetCommandCopy(Object[] argumentList);
    internal virtual HelpCategory get_HelpCategory();
    public string get_Path();
    public virtual string get_Definition();
    public virtual string get_Source();
    internal virtual string get_Syntax();
    public virtual SessionStateEntryVisibility get_Visibility();
    public virtual void set_Visibility(SessionStateEntryVisibility value);
    public sealed virtual ScriptBlock get_ScriptBlock();
    private void set_ScriptBlock(ScriptBlock value);
    private static ScriptBlock ParseScriptContents(Parser parser, string fileName, string fileContents, Nullable`1<PSLanguageMode> definingLanguageMode);
    internal ScriptBlockAst GetScriptBlockAst();
    public void ValidateScriptInfo(PSHost host);
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
    internal void set_SignatureChecked(bool value);
    internal virtual CommandMetadata get_CommandMetadata();
    internal virtual bool get_ImplementsDynamicParameters();
    private ScriptRequirements GetRequiresData();
    internal string get_RequiresApplicationID();
    internal UInt32 get_ApplicationIDLineNumber();
    internal Version get_RequiresPSVersion();
    internal IEnumerable`1<string> get_RequiresPSEditions();
    internal IEnumerable`1<ModuleSpecification> get_RequiresModules();
    internal bool get_RequiresElevation();
    internal UInt32 get_PSVersionLineNumber();
    public string get_ScriptContents();
    public Encoding get_OriginalEncoding();
    private void ReadScriptContents();
    private static void ThrowCommandNotFoundException(Exception innerException);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.FileBytePipe : BytePipe {
    private Stream _stream;
    private FileBytePipe(Stream stream);
    internal static FileBytePipe Create(string fileName, bool append);
    public virtual Task`1<Stream> GetStream(CancellationToken cancellationToken);
}
internal class System.Management.Automation.FileRedirection : CommandRedirection {
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Appending>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineProcessor <PipelineProcessor>k__BackingField;
    private bool _disposed;
    internal string File { get; }
    internal bool Appending { get; }
    private PipelineProcessor PipelineProcessor { get; private set; }
    internal FileRedirection(RedirectionStream from, bool appending, string file);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal string get_File();
    [CompilerGeneratedAttribute]
internal bool get_Appending();
    [CompilerGeneratedAttribute]
private PipelineProcessor get_PipelineProcessor();
    [CompilerGeneratedAttribute]
private void set_PipelineProcessor(PipelineProcessor value);
    internal virtual void Bind(PipelineProcessor pipelineProcessor, CommandProcessorBase commandProcessor, ExecutionContext context);
    internal Pipe[] BindForExpression(FunctionContext funcContext);
    internal Pipe GetRedirectionPipe(ExecutionContext context, PipelineProcessor parentPipelineProcessor);
    internal void CallDoCompleteForExpression();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class System.Management.Automation.FilterInfo : FunctionInfo {
    internal HelpCategory HelpCategory { get; }
    internal FilterInfo(string name, ScriptBlock filter, ExecutionContext context);
    internal FilterInfo(string name, ScriptBlock filter, ExecutionContext context, string helpFile);
    internal FilterInfo(string name, ScriptBlock filter, ScopedItemOptions options, ExecutionContext context);
    internal FilterInfo(string name, ScriptBlock filter, ScopedItemOptions options, ExecutionContext context, string helpFile);
    internal FilterInfo(FilterInfo other);
    internal FilterInfo(string name, FilterInfo other);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] arguments);
    internal virtual HelpCategory get_HelpCategory();
}
public class System.Management.Automation.FlagsExpression`1 : object {
    private Type _underType;
    [CompilerGeneratedAttribute]
private Node<T> <Root>k__BackingField;
    internal Node<T> Root { get; internal set; }
    public FlagsExpression`1(string expression);
    public FlagsExpression`1(Object[] expression);
    [CompilerGeneratedAttribute]
internal Node<T> get_Root();
    [CompilerGeneratedAttribute]
internal void set_Root(Node<T> value);
    public bool Evaluate(T value);
    internal bool ExistsInExpression(T flagName);
    private static List`1<Token<T>> TokenizeInput(string input);
    private static void FindNextToken(string input, Int32& _offset);
    private static Token<T> GetNextToken(string input, Int32& _offset);
    private static void CheckSyntaxError(List`1<Token<T>> tokenList);
    private static Node<T> ConstructExpressionTree(List`1<Token<T>> tokenList);
}
public abstract class System.Management.Automation.FlowControlException : SystemException {
}
[DebuggerDisplayAttribute("{Name}")]
public class System.Management.Automation.FormatViewDefinition : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PSControl <Control>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    public string Name { get; }
    public PSControl Control { get; }
    internal Guid InstanceId { get; internal set; }
    internal FormatViewDefinition(string name, PSControl control, Guid instanceid);
    public FormatViewDefinition(string name, PSControl control);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public PSControl get_Control();
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
internal void set_InstanceId(Guid value);
}
public class System.Management.Automation.ForwardedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PSObject <SerializedRemoteEventArgs>k__BackingField;
    public PSObject SerializedRemoteEventArgs { get; }
    internal ForwardedEventArgs(PSObject serializedRemoteEventArgs);
    [CompilerGeneratedAttribute]
public PSObject get_SerializedRemoteEventArgs();
    internal static bool IsRemoteSourceEventArgs(object argument);
}
public class System.Management.Automation.FunctionInfo : CommandInfo {
    private ScriptBlock _scriptBlock;
    private ScopedItemOptions _options;
    private string _description;
    private string _verb;
    private string _noun;
    private string _helpFile;
    private CommandMetadata _commandMetadata;
    internal HelpCategory HelpCategory { get; }
    public ScriptBlock ScriptBlock { get; }
    public bool CmdletBinding { get; }
    public string DefaultParameterSet { get; }
    public string Definition { get; }
    public ScopedItemOptions Options { get; public set; }
    public string Description { get; public set; }
    public string Verb { get; }
    public string Noun { get; }
    public string HelpFile { get; internal set; }
    internal string Syntax { get; }
    internal bool ImplementsDynamicParameters { get; }
    internal CommandMetadata CommandMetadata { get; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal FunctionInfo(string name, ScriptBlock function, ExecutionContext context);
    internal FunctionInfo(string name, ScriptBlock function, ExecutionContext context, string helpFile);
    internal FunctionInfo(string name, ScriptBlock function, ScopedItemOptions options, ExecutionContext context);
    internal FunctionInfo(string name, ScriptBlock function, ScopedItemOptions options, ExecutionContext context, string helpFile);
    internal FunctionInfo(FunctionInfo other);
    internal FunctionInfo(string name, FunctionInfo other);
    private void CopyFieldsFromOther(FunctionInfo other);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] arguments);
    internal virtual HelpCategory get_HelpCategory();
    public sealed virtual ScriptBlock get_ScriptBlock();
    internal void Update(ScriptBlock newFunction, bool force, ScopedItemOptions options);
    protected internal virtual void Update(FunctionInfo newFunction, bool force, ScopedItemOptions options, string helpFile);
    internal void Update(ScriptBlock newFunction, bool force, ScopedItemOptions options, string helpFile);
    public bool get_CmdletBinding();
    public string get_DefaultParameterSet();
    public virtual string get_Definition();
    public ScopedItemOptions get_Options();
    public void set_Options(ScopedItemOptions value);
    public string get_Description();
    public void set_Description(string value);
    public string get_Verb();
    public string get_Noun();
    public string get_HelpFile();
    internal void set_HelpFile(string value);
    internal virtual string get_Syntax();
    internal virtual bool get_ImplementsDynamicParameters();
    internal virtual CommandMetadata get_CommandMetadata();
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
}
internal class System.Management.Automation.FunctionLookupPath : VariablePath {
    internal FunctionLookupPath(string path);
}
internal static class System.Management.Automation.FunctionOps : object {
    internal static void DefineFunction(ExecutionContext context, FunctionDefinitionAst functionDefinitionAst, ScriptBlockExpressionWrapper scriptBlockExpressionWrapper);
}
internal class System.Management.Automation.FunctionScopeItemSearcher : ScopedItemSearcher`1<FunctionInfo> {
    private CommandOrigin _origin;
    private string _name;
    internal string Name { get; }
    public FunctionScopeItemSearcher(SessionStateInternal sessionState, VariablePath lookupPath, CommandOrigin origin);
    protected virtual bool GetScopeItem(SessionStateScope scope, VariablePath path, FunctionInfo& script);
    internal string get_Name();
}
internal class System.Management.Automation.FuzzyMatcher : object {
    internal UInt32 MinimumDistance;
    internal FuzzyMatcher(UInt32 minimumDistance);
    internal bool IsFuzzyMatch(string candidate, string pattern);
    internal bool IsFuzzyMatch(string candidate, string pattern, Int32& score);
    internal static int GetDamerauLevenshteinDistance(string string1, string string2);
}
public class System.Management.Automation.GetSymmetricEncryptionKey : MulticastDelegate {
    public GetSymmetricEncryptionKey(object object, IntPtr method);
    public virtual bool Invoke(StreamingContext context, Byte[]& key, Byte[]& iv);
    public virtual IAsyncResult BeginInvoke(StreamingContext context, Byte[]& key, Byte[]& iv, AsyncCallback callback, object object);
    public virtual bool EndInvoke(Byte[]& key, Byte[]& iv, IAsyncResult result);
}
public class System.Management.Automation.GettingValueExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <ShouldThrow>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ValueReplacement>k__BackingField;
    public bool ShouldThrow { get; public set; }
    public Exception Exception { get; }
    public object ValueReplacement { get; public set; }
    internal GettingValueExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public bool get_ShouldThrow();
    [CompilerGeneratedAttribute]
public void set_ShouldThrow(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
    [CompilerGeneratedAttribute]
public object get_ValueReplacement();
    [CompilerGeneratedAttribute]
public void set_ValueReplacement(object value);
}
public class System.Management.Automation.GetValueException : ExtendedTypeSystemException {
    internal static string GetWithoutGetterExceptionMsg;
    internal static string WriteOnlyProperty;
    public GetValueException(string message);
    public GetValueException(string message, Exception innerException);
    internal GetValueException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected GetValueException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.GetValueInvocationException : GetValueException {
    internal static string ExceptionWhenGettingMsg;
    public GetValueInvocationException(string message);
    public GetValueInvocationException(string message, Exception innerException);
    internal GetValueInvocationException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected GetValueInvocationException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.HaltCommandException : SystemException {
    public HaltCommandException(string message);
    public HaltCommandException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected HaltCommandException(SerializationInfo info, StreamingContext context);
}
internal static class System.Management.Automation.HashtableOps : object {
    internal static void AddKeyValuePair(IDictionary hashtable, object key, object value, IScriptExtent errorExtent);
    internal static object Add(IDictionary lvalDict, IDictionary rvalDict);
}
internal class System.Management.Automation.Help.CultureSpecificUpdatableHelp : object {
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    internal Version Version { get; internal set; }
    internal CultureInfo Culture { get; internal set; }
    internal CultureSpecificUpdatableHelp(CultureInfo culture, Version version);
    [CompilerGeneratedAttribute]
internal Version get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(Version value);
    [CompilerGeneratedAttribute]
internal CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal void set_Culture(CultureInfo value);
    [IteratorStateMachineAttribute("System.Management.Automation.Help.CultureSpecificUpdatableHelp/<GetCultureFallbackChain>d__9")]
internal static IEnumerable`1<string> GetCultureFallbackChain(CultureInfo culture);
    internal bool IsCultureSupported(string cultureName);
}
internal static class System.Management.Automation.Help.DefaultCommandHelpObjectBuilder : object {
    internal static string TypeNameForDefaultHelp;
    private static DefaultCommandHelpObjectBuilder();
    internal static PSObject GetPSObjectFromCmdletInfo(CommandInfo input);
    internal static void AddDetailsProperties(PSObject obj, string name, string noun, string verb, string typeNameForHelp, string synopsis);
    internal static void AddSyntaxProperties(PSObject obj, string cmdletName, ReadOnlyCollection`1<CommandParameterSetInfo> parameterSets, bool common, string typeNameForHelp);
    private static void AddSyntaxItemProperties(PSObject obj, string cmdletName, ReadOnlyCollection`1<CommandParameterSetInfo> parameterSets, bool common, string typeNameForHelp);
    private static void AddSyntaxParametersProperties(PSObject obj, IEnumerable`1<CommandParameterInfo> parameters, bool common, string parameterSetName);
    private static void AddParameterValueGroupProperties(PSObject obj, String[] values);
    internal static void AddParametersProperties(PSObject obj, Dictionary`2<string, ParameterMetadata> parameters, bool common, string typeNameForHelp);
    private static void AddParameterProperties(PSObject obj, string name, Collection`1<string> aliases, bool dynamic, Type type, Collection`1<Attribute> attributes, string parameterSetName);
    private static void AddParameterGlobbingProperties(PSObject obj, IEnumerable`1<Attribute> attributes);
    private static void AddParameterTypeProperties(PSObject obj, Type parameterType, IEnumerable`1<Attribute> attributes);
    private static void AddParameterValueProperties(PSObject obj, Type parameterType, IEnumerable`1<Attribute> attributes);
    internal static void AddInputTypesProperties(PSObject obj, Dictionary`2<string, ParameterMetadata> parameters);
    private static void AddOutputTypesProperties(PSObject obj, ReadOnlyCollection`1<PSTypeName> outputTypes);
    private static void AddAliasesProperties(PSObject obj, string name, ExecutionContext context);
    private static void AddRemarksProperties(PSObject obj, string cmdletName, string helpUri);
    internal static void AddRelatedLinksProperties(PSObject obj, string relatedLink);
    private static Collection`1<ParameterAttribute> GetParameterAttribute(Collection`1<Attribute> attributes);
    private static Collection`1<ValidateSetAttribute> GetValidateSetAttribute(Collection`1<Attribute> attributes);
    private static string GetPipelineInputString(ParameterAttribute paramAttrib);
    internal static bool HasCommonParameters(Dictionary`2<string, ParameterMetadata> parameters);
    private static bool HasHelpInfoUri(PSModuleInfo module, string moduleName);
}
internal class System.Management.Automation.Help.PositionalParameterComparer : object {
    public sealed virtual int Compare(object x, object y);
}
internal enum System.Management.Automation.Help.UpdatableHelpCommandType : Enum {
    public int value__;
    public static UpdatableHelpCommandType UnknownCommand;
    public static UpdatableHelpCommandType UpdateHelpCommand;
    public static UpdatableHelpCommandType SaveHelpCommand;
}
internal class System.Management.Automation.Help.UpdatableHelpExceptionContext : object {
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Modules>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Cultures>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdatableHelpSystemException <Exception>k__BackingField;
    internal HashSet`1<string> Modules { get; internal set; }
    internal HashSet`1<string> Cultures { get; internal set; }
    internal UpdatableHelpSystemException Exception { get; }
    internal UpdatableHelpExceptionContext(UpdatableHelpSystemException exception);
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_Modules();
    [CompilerGeneratedAttribute]
internal void set_Modules(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_Cultures();
    [CompilerGeneratedAttribute]
internal void set_Cultures(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
internal UpdatableHelpSystemException get_Exception();
    internal ErrorRecord CreateErrorRecord(UpdatableHelpCommandType commandType);
    internal string GetExceptionMessage(UpdatableHelpCommandType commandType);
}
internal class System.Management.Automation.Help.UpdatableHelpInfo : object {
    [CompilerGeneratedAttribute]
private string <UnresolvedUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<UpdatableHelpUri> <HelpContentUriCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureSpecificUpdatableHelp[] <UpdatableHelpItems>k__BackingField;
    internal string UnresolvedUri { get; }
    internal Collection`1<UpdatableHelpUri> HelpContentUriCollection { get; }
    internal CultureSpecificUpdatableHelp[] UpdatableHelpItems { get; }
    internal UpdatableHelpInfo(string unresolvedUri, CultureSpecificUpdatableHelp[] cultures);
    [CompilerGeneratedAttribute]
internal string get_UnresolvedUri();
    [CompilerGeneratedAttribute]
internal Collection`1<UpdatableHelpUri> get_HelpContentUriCollection();
    [CompilerGeneratedAttribute]
internal CultureSpecificUpdatableHelp[] get_UpdatableHelpItems();
    internal bool IsNewerVersion(UpdatableHelpInfo helpInfo, CultureInfo culture);
    internal bool IsCultureSupported(string cultureName);
    internal string GetSupportedCultures();
    internal Version GetCultureVersion(CultureInfo culture);
}
internal class System.Management.Automation.Help.UpdatableHelpModuleInfo : object {
    internal static string HelpContentZipName;
    internal static string HelpIntoXmlName;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    private Guid _moduleGuid;
    [CompilerGeneratedAttribute]
private string <ModuleBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpInfoUri>k__BackingField;
    internal string ModuleName { get; }
    internal Guid ModuleGuid { get; }
    internal string ModuleBase { get; }
    internal string HelpInfoUri { get; }
    internal UpdatableHelpModuleInfo(string name, Guid guid, string path, string uri);
    private static UpdatableHelpModuleInfo();
    [CompilerGeneratedAttribute]
internal string get_ModuleName();
    internal Guid get_ModuleGuid();
    [CompilerGeneratedAttribute]
internal string get_ModuleBase();
    [CompilerGeneratedAttribute]
internal string get_HelpInfoUri();
    internal string GetHelpContentName(CultureInfo culture);
    internal string GetHelpInfoName();
}
internal class System.Management.Automation.Help.UpdatableHelpProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <ProgressStatus>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProgressPercent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private UpdatableHelpCommandType <CommandType>k__BackingField;
    internal string ProgressStatus { get; }
    internal int ProgressPercent { get; }
    internal string ModuleName { get; }
    internal UpdatableHelpCommandType CommandType { get; internal set; }
    internal UpdatableHelpProgressEventArgs(string moduleName, string status, int percent);
    internal UpdatableHelpProgressEventArgs(string moduleName, UpdatableHelpCommandType type, string status, int percent);
    [CompilerGeneratedAttribute]
internal string get_ProgressStatus();
    [CompilerGeneratedAttribute]
internal int get_ProgressPercent();
    [CompilerGeneratedAttribute]
internal string get_ModuleName();
    [CompilerGeneratedAttribute]
internal UpdatableHelpCommandType get_CommandType();
    [CompilerGeneratedAttribute]
internal void set_CommandType(UpdatableHelpCommandType value);
}
internal class System.Management.Automation.Help.UpdatableHelpSystem : object {
    private TimeSpan _defaultTimeout;
    private Collection`1<UpdatableHelpProgressEventArgs> _progressEvents;
    private bool _stopping;
    private object _syncObject;
    private UpdatableHelpCommandBase _cmdlet;
    private CancellationTokenSource _cancelTokenSource;
    [CompilerGeneratedAttribute]
private HttpClient <HttpClient>k__BackingField;
    internal bool UseDefaultCredentials;
    [CompilerGeneratedAttribute]
private string <CurrentModule>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Exception> <Errors>k__BackingField;
    private static string HelpInfoXmlSchema;
    private static string HelpInfoXmlNamespace;
    private static string HelpInfoXmlValidationFailure;
    private static string MamlXmlNamespace;
    private static string CommandXmlNamespace;
    private static string DscResourceXmlNamespace;
    [CompilerGeneratedAttribute]
private EventHandler`1<UpdatableHelpProgressEventArgs> OnProgressChanged;
    internal HttpClient HttpClient { get; }
    internal string CurrentModule { get; internal set; }
    internal Collection`1<Exception> Errors { get; }
    internal UpdatableHelpSystem(UpdatableHelpCommandBase cmdlet, bool useDefaultCredentials);
    [CompilerGeneratedAttribute]
internal HttpClient get_HttpClient();
    [CompilerGeneratedAttribute]
internal string get_CurrentModule();
    [CompilerGeneratedAttribute]
internal void set_CurrentModule(string value);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal Collection`1<Exception> get_Errors();
    internal IEnumerable`1<string> GetCurrentUICulture();
    internal UpdatableHelpUri GetHelpInfoUri(UpdatableHelpModuleInfo module, CultureInfo culture);
    internal UpdatableHelpInfo GetHelpInfo(UpdatableHelpCommandType commandType, string uri, string moduleName, Guid moduleGuid, string culture);
    private string ResolveUri(string baseUri, bool verbose);
    internal UpdatableHelpInfo CreateHelpInfo(string xml, string moduleName, Guid moduleGuid, string currentCulture, string pathOverride, bool verbose, bool shouldResolveUri, bool ignoreValidationException);
    private static XmlDocument CreateValidXmlDocument(string xml, string ns, string schema, ValidationEventHandler handler, bool helpInfo);
    private void HelpInfoValidationHandler(object sender, ValidationEventArgs arg);
    private void HelpContentValidationHandler(object sender, ValidationEventArgs arg);
    internal void CancelDownload();
    internal bool DownloadAndInstallHelpContent(UpdatableHelpCommandType commandType, ExecutionContext context, Collection`1<string> destPaths, string fileName, CultureInfo culture, string helpContentUri, string xsdPath, Collection`1& installed);
    internal bool DownloadHelpContent(UpdatableHelpCommandType commandType, string path, string helpContentUri, string fileName, string culture);
    private bool DownloadHelpContentHttpClient(string uri, string fileName, UpdatableHelpCommandType commandType);
    private void WriteResponseToFile(HttpResponseMessage response, string fileName);
    private void SendProgressEvents(UpdatableHelpCommandType commandType);
    internal void GenerateHelpInfo(string moduleName, Guid moduleGuid, string contentUri, string culture, Version version, string destPath, string fileName, bool force);
    private static void RemoveReadOnly(string path);
    internal void InstallHelpContent(UpdatableHelpCommandType commandType, ExecutionContext context, string sourcePath, Collection`1<string> destPaths, string fileName, string tempPath, CultureInfo culture, string xsdPath, Collection`1& installed);
    private static void UnzipHelpContent(ExecutionContext context, string srcPath, string destPath, Boolean& needToCopy);
    private void ValidateAndCopyHelpContent(string sourcePath, Collection`1<string> destPaths, string culture, string xsdPath, Collection`1& installed);
    internal static string LoadStringFromPath(PSCmdlet cmdlet, string path, PSCredential credential);
    internal static string GetFilePath(string path);
    internal string GetDefaultSourcePath();
    [CompilerGeneratedAttribute]
internal void add_OnProgressChanged(EventHandler`1<UpdatableHelpProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_OnProgressChanged(EventHandler`1<UpdatableHelpProgressEventArgs> value);
}
internal class System.Management.Automation.Help.UpdatableHelpSystemDrive : object {
    private string _driveName;
    private PSCmdlet _cmdlet;
    internal string DriveName { get; }
    internal UpdatableHelpSystemDrive(PSCmdlet cmdlet, string path, PSCredential credential);
    internal string get_DriveName();
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.Help.UpdatableHelpSystemException : Exception {
    [CompilerGeneratedAttribute]
private string <FullyQualifiedErrorId>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorCategory <ErrorCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private object <TargetObject>k__BackingField;
    internal string FullyQualifiedErrorId { get; }
    internal ErrorCategory ErrorCategory { get; }
    internal object TargetObject { get; }
    internal UpdatableHelpSystemException(string errorId, string message, ErrorCategory cat, object targetObject, Exception innerException);
    [CompilerGeneratedAttribute]
internal string get_FullyQualifiedErrorId();
    [CompilerGeneratedAttribute]
internal ErrorCategory get_ErrorCategory();
    [CompilerGeneratedAttribute]
internal object get_TargetObject();
}
internal class System.Management.Automation.Help.UpdatableHelpUri : object {
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ModuleGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedUri>k__BackingField;
    internal string ModuleName { get; }
    internal Guid ModuleGuid { get; }
    internal CultureInfo Culture { get; }
    internal string ResolvedUri { get; }
    internal UpdatableHelpUri(string moduleName, Guid moduleGuid, CultureInfo culture, string resolvedUri);
    [CompilerGeneratedAttribute]
internal string get_ModuleName();
    [CompilerGeneratedAttribute]
internal Guid get_ModuleGuid();
    [CompilerGeneratedAttribute]
internal CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal string get_ResolvedUri();
}
[FlagsAttribute]
internal enum System.Management.Automation.HelpCategory : Enum {
    public int value__;
    public static HelpCategory None;
    public static HelpCategory Alias;
    public static HelpCategory Cmdlet;
    public static HelpCategory Provider;
    public static HelpCategory General;
    public static HelpCategory FAQ;
    public static HelpCategory Glossary;
    public static HelpCategory HelpFile;
    public static HelpCategory ScriptCommand;
    public static HelpCategory Function;
    public static HelpCategory Filter;
    public static HelpCategory ExternalScript;
    public static HelpCategory All;
    public static HelpCategory DefaultHelp;
    public static HelpCategory Configuration;
    public static HelpCategory DscResource;
    public static HelpCategory Class;
}
internal class System.Management.Automation.HelpCommentsParser : object {
    private CommentHelpInfo _sections;
    private Dictionary`2<string, string> _parameters;
    private List`1<string> _examples;
    private List`1<string> _inputs;
    private List`1<string> _outputs;
    private List`1<string> _links;
    internal bool isExternalHelpSet;
    private ScriptBlock _scriptBlock;
    private CommandMetadata _commandMetadata;
    private string _commandName;
    private List`1<string> _parameterDescriptions;
    private XmlDocument _doc;
    internal static string mshURI;
    internal static string mamlURI;
    internal static string commandURI;
    internal static string devURI;
    private static string directive;
    private static string blankline;
    internal static string ProviderHelpCommandXPath;
    internal static int CommentBlockProximity;
    private HelpCommentsParser(List`1<string> parameterDescriptions);
    private HelpCommentsParser(CommandInfo commandInfo, List`1<string> parameterDescriptions);
    private static HelpCommentsParser();
    private void DetermineParameterDescriptions();
    private string GetParameterDescription(string parameterName);
    private XmlElement BuildXmlForParameter(string parameterName, bool isMandatory, bool valueFromPipeline, bool valueFromPipelineByPropertyName, string position, Type type, string description, bool supportsWildcards, string defaultValue, bool forSyntax);
    internal XmlDocument BuildXmlFromComments();
    private void BuildSyntaxForParameterSet(XmlElement command, XmlElement syntax, MergedCommandParameterMetadata parameterMetadata, int i);
    private static void GetExampleSections(string content, String& prompt_str, String& code_str, String& remarks_str);
    private static void CollectCommentText(Token comment, List`1<string> commentLines);
    private static void CollectCommentText(string text, List`1<string> commentLines);
    private static string GetSection(List`1<string> commentLines, Int32& i);
    internal string GetHelpFile(CommandInfo commandInfo);
    internal RemoteHelpInfo GetRemoteHelpInfo(ExecutionContext context, CommandInfo commandInfo);
    internal bool AnalyzeCommentBlock(List`1<Token> comments);
    private bool AnalyzeCommentBlock(List`1<string> commentLines);
    internal void SetAdditionalData(MamlCommandHelpInfo helpInfo);
    internal static CommentHelpInfo GetHelpContents(List`1<Token> comments, List`1<string> parameterDescriptions);
    internal static HelpInfo CreateFromComments(ExecutionContext context, CommandInfo commandInfo, List`1<Token> comments, List`1<string> parameterDescriptions, bool dontSearchOnRemoteComputer, String& helpFile, String& helpUriFromDotLink);
    internal static HelpInfo CreateFromComments(ExecutionContext context, CommandInfo commandInfo, HelpCommentsParser helpCommentsParser, bool dontSearchOnRemoteComputer);
    internal static bool IsCommentHelpText(List`1<Token> commentBlock);
    private static List`1<Token> GetCommentBlock(Token[] tokens, Int32& startIndex);
    private static List`1<Token> GetPrecedingCommentBlock(Token[] tokens, int tokenIndex, int proximity);
    private static int FirstTokenInExtent(Token[] tokens, IScriptExtent extent, int startIndex);
    private static int LastTokenInExtent(Token[] tokens, IScriptExtent extent, int startIndex);
    private static List`1<string> GetParameterComments(Token[] tokens, IParameterMetadataProvider ipmp, int startIndex);
    internal static Tuple`2<List`1<Token>, List`1<string>> GetHelpCommentTokens(IParameterMetadataProvider ipmp, Dictionary`2<Ast, Token[]> scriptBlockTokenCache);
}
internal class System.Management.Automation.HelpErrorTracer : object {
    [CompilerGeneratedAttribute]
private HelpSystem <HelpSystem>k__BackingField;
    private List`1<TraceFrame> _traceFrames;
    internal HelpSystem HelpSystem { get; }
    internal bool IsOn { get; }
    internal HelpErrorTracer(HelpSystem helpSystem);
    [CompilerGeneratedAttribute]
internal HelpSystem get_HelpSystem();
    internal IDisposable Trace(string helpFile);
    internal void TraceError(ErrorRecord errorRecord);
    internal void TraceErrors(Collection`1<ErrorRecord> errorRecords);
    internal void PopFrame(TraceFrame traceFrame);
    internal bool get_IsOn();
}
internal class System.Management.Automation.HelpFileHelpInfo : HelpInfo {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private string _filename;
    private string _synopsis;
    [CompilerGeneratedAttribute]
private PSObject <FullHelp>k__BackingField;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSObject FullHelp { get; }
    private HelpFileHelpInfo(string name, string text, string filename);
    [CompilerGeneratedAttribute]
internal virtual string get_Name();
    internal virtual string get_Synopsis();
    internal virtual HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
internal virtual PSObject get_FullHelp();
    internal static HelpFileHelpInfo GetHelpInfo(string name, string text, string filename);
    private static string GetLine(string text, int line);
    internal virtual bool MatchPatternInContent(WildcardPattern pattern);
}
internal class System.Management.Automation.HelpFileHelpProvider : HelpProviderWithCache {
    private Hashtable _helpFiles;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal HelpFileHelpProvider(HelpSystem helpSystem);
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    [IteratorStateMachineAttribute("System.Management.Automation.HelpFileHelpProvider/<ExactMatchHelp>d__5")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    private Collection`1<string> FilterToLatestModuleVersion(Collection`1<string> filesMatched);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpFileHelpProvider/<SearchHelp>d__7")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    private static void GetModuleNameAndVersion(string psmodulePathRoot, string filePath, String& moduleName, Version& moduleVersion);
    private HelpInfo LoadHelpFile(string path);
    internal Collection`1<string> GetExtendedSearchPaths();
    internal virtual void Reset();
}
internal abstract class System.Management.Automation.HelpInfo : object {
    [CompilerGeneratedAttribute]
private HelpCategory <ForwardHelpCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForwardTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ErrorRecord> <Errors>k__BackingField;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal string Component { get; }
    internal string Role { get; }
    internal string Functionality { get; }
    internal HelpCategory HelpCategory { get; }
    internal HelpCategory ForwardHelpCategory { get; internal set; }
    internal string ForwardTarget { get; internal set; }
    internal PSObject FullHelp { get; }
    internal PSObject ShortHelp { get; }
    internal Collection`1<ErrorRecord> Errors { get; internal set; }
    internal abstract virtual string get_Name();
    internal abstract virtual string get_Synopsis();
    internal virtual string get_Component();
    internal virtual string get_Role();
    internal virtual string get_Functionality();
    internal abstract virtual HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
internal HelpCategory get_ForwardHelpCategory();
    [CompilerGeneratedAttribute]
internal void set_ForwardHelpCategory(HelpCategory value);
    [CompilerGeneratedAttribute]
internal string get_ForwardTarget();
    [CompilerGeneratedAttribute]
internal void set_ForwardTarget(string value);
    internal abstract virtual PSObject get_FullHelp();
    internal PSObject get_ShortHelp();
    internal virtual PSObject[] GetParameter(string pattern);
    internal virtual Uri GetUriForOnlineHelp();
    internal virtual bool MatchPatternInContent(WildcardPattern pattern);
    protected void AddCommonHelpProperties();
    protected void UpdateUserDefinedDataProperties();
    [CompilerGeneratedAttribute]
internal Collection`1<ErrorRecord> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(Collection`1<ErrorRecord> value);
}
internal class System.Management.Automation.HelpProgressEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <Completed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Activity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PercentComplete>k__BackingField;
    internal bool Completed { get; internal set; }
    internal string Activity { get; internal set; }
    internal int PercentComplete { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_Completed();
    [CompilerGeneratedAttribute]
internal void set_Completed(bool value);
    [CompilerGeneratedAttribute]
internal string get_Activity();
    [CompilerGeneratedAttribute]
internal void set_Activity(string value);
    [CompilerGeneratedAttribute]
internal int get_PercentComplete();
    [CompilerGeneratedAttribute]
internal void set_PercentComplete(int value);
}
internal abstract class System.Management.Automation.HelpProvider : object {
    private HelpSystem _helpSystem;
    internal HelpSystem HelpSystem { get; }
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal HelpProvider(HelpSystem helpSystem);
    internal HelpSystem get_HelpSystem();
    internal abstract virtual string get_Name();
    internal abstract virtual HelpCategory get_HelpCategory();
    internal abstract virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    internal abstract virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpProvider/<ProcessForwardedHelp>d__10")]
internal virtual IEnumerable`1<HelpInfo> ProcessForwardedHelp(HelpInfo helpInfo, HelpRequest helpRequest);
    internal virtual void Reset();
    internal void ReportHelpFileError(Exception exception, string target, string helpFile);
    internal string GetDefaultShellSearchPath();
    internal Collection`1<string> GetSearchPaths();
}
internal class System.Management.Automation.HelpProviderInfo : object {
    internal string AssemblyName;
    internal string ClassName;
    internal HelpCategory HelpCategory;
    internal HelpProviderInfo(string assemblyName, string className, HelpCategory helpCategory);
}
internal abstract class System.Management.Automation.HelpProviderWithCache : HelpProvider {
    private Hashtable _helpCache;
    [CompilerGeneratedAttribute]
private bool <HasCustomMatch>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheFullyLoaded>k__BackingField;
    protected bool HasCustomMatch { get; protected set; }
    protected internal bool CacheFullyLoaded { get; protected internal set; }
    internal HelpProviderWithCache(HelpSystem helpSystem);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpProviderWithCache/<ExactMatchHelp>d__2")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    [CompilerGeneratedAttribute]
protected bool get_HasCustomMatch();
    [CompilerGeneratedAttribute]
protected void set_HasCustomMatch(bool value);
    protected virtual bool CustomMatch(string target, string key);
    internal virtual void DoExactMatchHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpProviderWithCache/<SearchHelp>d__9")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    internal virtual string GetWildCardPattern(string target);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpProviderWithCache/<DoSearchHelp>d__11")]
internal virtual IEnumerable`1<HelpInfo> DoSearchHelp(HelpRequest helpRequest);
    internal void AddCache(string target, HelpInfo helpInfo);
    internal HelpInfo GetCache(string target);
    [CompilerGeneratedAttribute]
protected internal bool get_CacheFullyLoaded();
    [CompilerGeneratedAttribute]
protected internal void set_CacheFullyLoaded(bool value);
    internal virtual void Reset();
}
internal abstract class System.Management.Automation.HelpProviderWithFullCache : HelpProviderWithCache {
    internal HelpProviderWithFullCache(HelpSystem helpSystem);
    internal sealed virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    internal sealed virtual void DoExactMatchHelp(HelpRequest helpRequest);
    internal sealed virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    internal sealed virtual IEnumerable`1<HelpInfo> DoSearchHelp(HelpRequest helpRequest);
    internal virtual void LoadCache();
}
internal class System.Management.Automation.HelpRequest : object {
    [CompilerGeneratedAttribute]
private ProviderContext <ProviderContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private HelpCategory <HelpCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxResults>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Role>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Functionality>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandOrigin <CommandOrigin>k__BackingField;
    internal ProviderContext ProviderContext { get; internal set; }
    internal string Target { get; internal set; }
    internal HelpCategory HelpCategory { get; internal set; }
    internal string Provider { get; internal set; }
    internal int MaxResults { get; internal set; }
    internal String[] Component { get; internal set; }
    internal String[] Role { get; internal set; }
    internal String[] Functionality { get; internal set; }
    internal CommandOrigin CommandOrigin { get; internal set; }
    internal HelpRequest(string target, HelpCategory helpCategory);
    internal HelpRequest Clone();
    [CompilerGeneratedAttribute]
internal ProviderContext get_ProviderContext();
    [CompilerGeneratedAttribute]
internal void set_ProviderContext(ProviderContext value);
    [CompilerGeneratedAttribute]
internal string get_Target();
    [CompilerGeneratedAttribute]
internal void set_Target(string value);
    [CompilerGeneratedAttribute]
internal HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
internal void set_HelpCategory(HelpCategory value);
    [CompilerGeneratedAttribute]
internal string get_Provider();
    [CompilerGeneratedAttribute]
internal void set_Provider(string value);
    [CompilerGeneratedAttribute]
internal int get_MaxResults();
    [CompilerGeneratedAttribute]
internal void set_MaxResults(int value);
    [CompilerGeneratedAttribute]
internal String[] get_Component();
    [CompilerGeneratedAttribute]
internal void set_Component(String[] value);
    [CompilerGeneratedAttribute]
internal String[] get_Role();
    [CompilerGeneratedAttribute]
internal void set_Role(String[] value);
    [CompilerGeneratedAttribute]
internal String[] get_Functionality();
    [CompilerGeneratedAttribute]
internal void set_Functionality(String[] value);
    [CompilerGeneratedAttribute]
internal CommandOrigin get_CommandOrigin();
    [CompilerGeneratedAttribute]
internal void set_CommandOrigin(CommandOrigin value);
    internal void Validate();
}
internal class System.Management.Automation.HelpSystem : object {
    private ExecutionContext _executionContext;
    [CompilerGeneratedAttribute]
private EventHandler`1<HelpProgressEventArgs> OnProgress;
    private Collection`1<ErrorRecord> _lastErrors;
    private HelpCategory _lastHelpCategory;
    private bool _verboseHelpErrors;
    private Collection`1<string> _searchPaths;
    private ArrayList _helpProviders;
    private HelpErrorTracer _helpErrorTracer;
    private CultureInfo _culture;
    private Lazy`1<Dictionary`2<Ast, Token[]>> _scriptBlockTokenCache;
    internal ExecutionContext ExecutionContext { get; }
    internal Collection`1<ErrorRecord> LastErrors { get; }
    internal HelpCategory LastHelpCategory { get; }
    internal bool VerboseHelpErrors { get; }
    internal ArrayList HelpProviders { get; }
    internal HelpErrorTracer HelpErrorTracer { get; }
    internal Dictionary`2<Ast, Token[]> ScriptBlockTokenCache { get; }
    internal HelpSystem(ExecutionContext context);
    internal ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
internal void add_OnProgress(EventHandler`1<HelpProgressEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_OnProgress(EventHandler`1<HelpProgressEventArgs> value);
    internal void Initialize();
    internal IEnumerable`1<HelpInfo> GetHelp(HelpRequest helpRequest);
    internal Collection`1<ErrorRecord> get_LastErrors();
    internal HelpCategory get_LastHelpCategory();
    internal bool get_VerboseHelpErrors();
    internal Collection`1<string> GetSearchPaths();
    [IteratorStateMachineAttribute("System.Management.Automation.HelpSystem/<DoGetHelp>d__20")]
private IEnumerable`1<HelpInfo> DoGetHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpSystem/<ExactMatchHelp>d__21")]
internal IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.HelpSystem/<ForwardHelp>d__22")]
private IEnumerable`1<HelpInfo> ForwardHelp(HelpInfo helpInfo, HelpRequest helpRequest);
    private HelpInfo GetDefaultHelp();
    [IteratorStateMachineAttribute("System.Management.Automation.HelpSystem/<SearchHelp>d__24")]
private IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest);
    internal ArrayList get_HelpProviders();
    private void InitializeHelpProviders();
    internal HelpErrorTracer get_HelpErrorTracer();
    internal IDisposable Trace(string helpFile);
    internal void TraceError(ErrorRecord errorRecord);
    internal void TraceErrors(Collection`1<ErrorRecord> errorRecords);
    private void ValidateHelpCulture();
    internal void ResetHelpProviders();
    internal Dictionary`2<Ast, Token[]> get_ScriptBlockTokenCache();
    internal void ClearScriptBlockTokenCache();
}
internal static class System.Management.Automation.HelpUtils : object {
    private static string userHomeHelpPath;
    internal static string GetUserHomeHelpSearchPath();
    internal static string GetModuleBaseForUserHelp(string moduleBase, string moduleName);
}
[AttributeUsageAttribute("992")]
public class System.Management.Automation.HiddenAttribute : ParsingBaseAttribute {
}
public class System.Management.Automation.Host.BufferCell : ValueType {
    private char character;
    private ConsoleColor foregroundColor;
    private ConsoleColor backgroundColor;
    private BufferCellType bufferCellType;
    private static string StringsBaseName;
    public char Character { get; public set; }
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public BufferCellType BufferCellType { get; public set; }
    public BufferCell(char character, ConsoleColor foreground, ConsoleColor background, BufferCellType bufferCellType);
    public char get_Character();
    public void set_Character(char value);
    public ConsoleColor get_ForegroundColor();
    public void set_ForegroundColor(ConsoleColor value);
    public ConsoleColor get_BackgroundColor();
    public void set_BackgroundColor(ConsoleColor value);
    public BufferCellType get_BufferCellType();
    public void set_BufferCellType(BufferCellType value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(BufferCell first, BufferCell second);
    public static bool op_Inequality(BufferCell first, BufferCell second);
}
public enum System.Management.Automation.Host.BufferCellType : Enum {
    public int value__;
    public static BufferCellType Complete;
    public static BufferCellType Leading;
    public static BufferCellType Trailing;
}
public class System.Management.Automation.Host.ChoiceDescription : object {
    private string label;
    private string helpMessage;
    public string Label { get; }
    public string HelpMessage { get; public set; }
    public ChoiceDescription(string label);
    public ChoiceDescription(string label, string helpMessage);
    public string get_Label();
    public string get_HelpMessage();
    public void set_HelpMessage(string value);
}
[FlagsAttribute]
public enum System.Management.Automation.Host.ControlKeyStates : Enum {
    public int value__;
    public static ControlKeyStates RightAltPressed;
    public static ControlKeyStates LeftAltPressed;
    public static ControlKeyStates RightCtrlPressed;
    public static ControlKeyStates LeftCtrlPressed;
    public static ControlKeyStates ShiftPressed;
    public static ControlKeyStates NumLockOn;
    public static ControlKeyStates ScrollLockOn;
    public static ControlKeyStates CapsLockOn;
    public static ControlKeyStates EnhancedKey;
}
public class System.Management.Automation.Host.Coordinates : ValueType {
    private int x;
    private int y;
    public int X { get; public set; }
    public int Y { get; public set; }
    public Coordinates(int x, int y);
    public int get_X();
    public void set_X(int value);
    public int get_Y();
    public void set_Y(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Coordinates first, Coordinates second);
    public static bool op_Inequality(Coordinates first, Coordinates second);
}
public class System.Management.Automation.Host.FieldDescription : object {
    private string name;
    private string label;
    private string parameterTypeName;
    private string parameterTypeFullName;
    private string parameterAssemblyFullName;
    private string helpMessage;
    private bool isMandatory;
    private PSObject defaultValue;
    private Collection`1<Attribute> metadata;
    private bool modifiedByRemotingProtocol;
    private bool isFromRemoteHost;
    public string Name { get; }
    public string ParameterTypeName { get; }
    public string ParameterTypeFullName { get; }
    public string ParameterAssemblyFullName { get; }
    public string Label { get; public set; }
    public string HelpMessage { get; public set; }
    public bool IsMandatory { get; public set; }
    public PSObject DefaultValue { get; public set; }
    public Collection`1<Attribute> Attributes { get; }
    internal bool ModifiedByRemotingProtocol { get; internal set; }
    internal bool IsFromRemoteHost { get; internal set; }
    public FieldDescription(string name);
    public string get_Name();
    public void SetParameterType(Type parameterType);
    public string get_ParameterTypeName();
    public string get_ParameterTypeFullName();
    public string get_ParameterAssemblyFullName();
    public string get_Label();
    public void set_Label(string value);
    public string get_HelpMessage();
    public void set_HelpMessage(string value);
    public bool get_IsMandatory();
    public void set_IsMandatory(bool value);
    public PSObject get_DefaultValue();
    public void set_DefaultValue(PSObject value);
    public Collection`1<Attribute> get_Attributes();
    internal void SetParameterTypeName(string nameOfType);
    internal void SetParameterTypeFullName(string fullNameOfType);
    internal void SetParameterAssemblyFullName(string fullNameOfAssembly);
    internal bool get_ModifiedByRemotingProtocol();
    internal void set_ModifiedByRemotingProtocol(bool value);
    internal bool get_IsFromRemoteHost();
    internal void set_IsFromRemoteHost(bool value);
}
public class System.Management.Automation.Host.HostException : RuntimeException {
    public HostException(string message);
    public HostException(string message, Exception innerException);
    public HostException(string message, Exception innerException, string errorId, ErrorCategory errorCategory);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected HostException(SerializationInfo info, StreamingContext context);
    private void SetDefaultErrorRecord();
}
internal static class System.Management.Automation.Host.HostUIHelperMethods : object {
    internal static void BuildHotkeysAndPlainLabels(Collection`1<ChoiceDescription> choices, String[0...,0...]& hotkeysAndPlainLabels);
    internal static int DetermineChoicePicked(string response, Collection`1<ChoiceDescription> choices, String[0...,0...] hotkeysAndPlainLabels);
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.Host.IHostSupportsInteractiveSession {
    public bool IsRunspacePushed { get; }
    public Runspace Runspace { get; }
    [NullableContextAttribute("1")]
public abstract virtual void PushRunspace(Runspace runspace);
    public abstract virtual void PopRunspace();
    public abstract virtual bool get_IsRunspacePushed();
    public abstract virtual Runspace get_Runspace();
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.Host.IHostUISupportsMultipleChoiceSelection {
    public abstract virtual Collection`1<int> PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, IEnumerable`1<int> defaultChoices);
}
public class System.Management.Automation.Host.KeyInfo : ValueType {
    private int virtualKeyCode;
    private char character;
    private ControlKeyStates controlKeyState;
    private bool keyDown;
    public int VirtualKeyCode { get; public set; }
    public char Character { get; public set; }
    public ControlKeyStates ControlKeyState { get; public set; }
    public bool KeyDown { get; public set; }
    public KeyInfo(int virtualKeyCode, char ch, ControlKeyStates controlKeyState, bool keyDown);
    public int get_VirtualKeyCode();
    public void set_VirtualKeyCode(int value);
    public char get_Character();
    public void set_Character(char value);
    public ControlKeyStates get_ControlKeyState();
    public void set_ControlKeyState(ControlKeyStates value);
    public bool get_KeyDown();
    public void set_KeyDown(bool value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(KeyInfo first, KeyInfo second);
    public static bool op_Inequality(KeyInfo first, KeyInfo second);
}
public class System.Management.Automation.Host.PromptingException : HostException {
    public PromptingException(string message);
    public PromptingException(string message, Exception innerException);
    public PromptingException(string message, Exception innerException, string errorId, ErrorCategory errorCategory);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PromptingException(SerializationInfo info, StreamingContext context);
    private void SetDefaultErrorRecord();
}
public abstract class System.Management.Automation.Host.PSHost : object {
    internal static int MaximumNestedPromptLevel;
    internal static bool IsStdOutputRedirected;
    [CompilerGeneratedAttribute]
private bool <ShouldSetThreadUILanguageToZero>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public Guid InstanceId { get; }
    public PSHostUserInterface UI { get; }
    public CultureInfo CurrentCulture { get; }
    public CultureInfo CurrentUICulture { get; }
    public PSObject PrivateData { get; }
    internal bool ShouldSetThreadUILanguageToZero { get; internal set; }
    public bool DebuggerEnabled { get; public set; }
    public abstract virtual string get_Name();
    public abstract virtual Version get_Version();
    public abstract virtual Guid get_InstanceId();
    public abstract virtual PSHostUserInterface get_UI();
    public abstract virtual CultureInfo get_CurrentCulture();
    public abstract virtual CultureInfo get_CurrentUICulture();
    public abstract virtual void SetShouldExit(int exitCode);
    public abstract virtual void EnterNestedPrompt();
    public abstract virtual void ExitNestedPrompt();
    public virtual PSObject get_PrivateData();
    public abstract virtual void NotifyBeginApplication();
    public abstract virtual void NotifyEndApplication();
    [CompilerGeneratedAttribute]
internal bool get_ShouldSetThreadUILanguageToZero();
    [CompilerGeneratedAttribute]
internal void set_ShouldSetThreadUILanguageToZero(bool value);
    public virtual bool get_DebuggerEnabled();
    public virtual void set_DebuggerEnabled(bool value);
}
public abstract class System.Management.Automation.Host.PSHostRawUserInterface : object {
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public Coordinates CursorPosition { get; public set; }
    public Coordinates WindowPosition { get; public set; }
    public int CursorSize { get; public set; }
    public Size BufferSize { get; public set; }
    public Size WindowSize { get; public set; }
    public Size MaxWindowSize { get; }
    public Size MaxPhysicalWindowSize { get; }
    public bool KeyAvailable { get; }
    public string WindowTitle { get; public set; }
    public abstract virtual ConsoleColor get_ForegroundColor();
    public abstract virtual void set_ForegroundColor(ConsoleColor value);
    public abstract virtual ConsoleColor get_BackgroundColor();
    public abstract virtual void set_BackgroundColor(ConsoleColor value);
    public abstract virtual Coordinates get_CursorPosition();
    public abstract virtual void set_CursorPosition(Coordinates value);
    public abstract virtual Coordinates get_WindowPosition();
    public abstract virtual void set_WindowPosition(Coordinates value);
    public abstract virtual int get_CursorSize();
    public abstract virtual void set_CursorSize(int value);
    public abstract virtual Size get_BufferSize();
    public abstract virtual void set_BufferSize(Size value);
    public abstract virtual Size get_WindowSize();
    public abstract virtual void set_WindowSize(Size value);
    public abstract virtual Size get_MaxWindowSize();
    public abstract virtual Size get_MaxPhysicalWindowSize();
    public KeyInfo ReadKey();
    public abstract virtual KeyInfo ReadKey(ReadKeyOptions options);
    public abstract virtual void FlushInputBuffer();
    public abstract virtual bool get_KeyAvailable();
    public abstract virtual string get_WindowTitle();
    public abstract virtual void set_WindowTitle(string value);
    public abstract virtual void SetBufferContents(Coordinates origin, BufferCell[0...,0...] contents);
    public abstract virtual void SetBufferContents(Rectangle rectangle, BufferCell fill);
    public abstract virtual BufferCell[0...,0...] GetBufferContents(Rectangle rectangle);
    public abstract virtual void ScrollBufferContents(Rectangle source, Coordinates destination, Rectangle clip, BufferCell fill);
    public virtual int LengthInBufferCells(string source, int offset);
    public virtual int LengthInBufferCells(string source);
    public virtual int LengthInBufferCells(char source);
    public BufferCell[0...,0...] NewBufferCellArray(String[] contents, ConsoleColor foregroundColor, ConsoleColor backgroundColor);
    public BufferCell[0...,0...] NewBufferCellArray(int width, int height, BufferCell contents);
    public BufferCell[0...,0...] NewBufferCellArray(Size size, BufferCell contents);
}
public abstract class System.Management.Automation.Host.PSHostUserInterface : object {
    private TranscriptionData _volatileTranscriptionData;
    private int _transcribeOnlyCount;
    internal static TranscriptionOption systemTranscript;
    private static object s_systemTranscriptLock;
    private static Lazy`1<Transcription> s_transcriptionSettingCache;
    public PSHostRawUserInterface RawUI { get; }
    public bool SupportsVirtualTerminal { get; }
    private TranscriptionData TranscriptionData { get; }
    internal bool TranscribeOnly { get; }
    internal bool IsTranscribing { get; }
    private static PSHostUserInterface();
    public abstract virtual PSHostRawUserInterface get_RawUI();
    public virtual bool get_SupportsVirtualTerminal();
    public abstract virtual string ReadLine();
    public abstract virtual SecureString ReadLineAsSecureString();
    public abstract virtual void Write(string value);
    public abstract virtual void Write(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string value);
    public virtual void WriteLine();
    public abstract virtual void WriteLine(string value);
    public virtual void WriteLine(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string value);
    public abstract virtual void WriteErrorLine(string value);
    public abstract virtual void WriteDebugLine(string message);
    public abstract virtual void WriteProgress(long sourceId, ProgressRecord record);
    public abstract virtual void WriteVerboseLine(string message);
    public abstract virtual void WriteWarningLine(string message);
    public virtual void WriteInformation(InformationRecord record);
    private static bool ShouldOutputPlainText(bool isHost, Nullable`1<bool> supportsVirtualTerminal);
    public static string GetFormatStyleString(FormatStyle formatStyle);
    public static string GetOutputString(string text, bool supportsVirtualTerminal);
    internal static string GetOutputString(string text, bool isHost, Nullable`1<bool> supportsVirtualTerminal);
    private TranscriptionData get_TranscriptionData();
    internal void TranscribeCommand(string commandText, InvocationInfo invocation);
    private bool ShouldIgnoreCommand(string logElement, InvocationInfo invocation);
    internal void IgnoreCommand(string commandText, InvocationInfo invocation);
    internal bool get_TranscribeOnly();
    internal IDisposable SetTranscribeOnly();
    internal bool get_IsTranscribing();
    private void CheckSystemTranscript();
    internal void StartTranscribing(string path, PSSenderInfo senderInfo, bool includeInvocationHeader, bool useMinimalHeader);
    private void LogTranscriptHeader(PSSenderInfo senderInfo, TranscriptionOption transcript, bool useMinimalHeader);
    internal string StopTranscribing();
    private void LogTranscriptFooter(TranscriptionOption stoppedTranscript);
    internal void StopAllTranscribing();
    internal void TranscribeResult(Runspace sourceRunspace, string resultText);
    internal void TranscribeResult(string resultText);
    internal void TranscribeCommandComplete(InvocationInfo invocation);
    internal void TranscribePipelineComplete();
    private void FlushPendingOutput();
    public abstract virtual Dictionary`2<string, PSObject> Prompt(string caption, string message, Collection`1<FieldDescription> descriptions);
    public abstract virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName);
    public abstract virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName, PSCredentialTypes allowedCredentialTypes, PSCredentialUIOptions options);
    public abstract virtual int PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, int defaultChoice);
    internal void TranscribeError(ExecutionContext context, InvocationInfo invocation, PSObject errorWrap);
    internal static TranscriptionOption GetSystemTranscriptOption(TranscriptionOption currentTranscript);
    private static TranscriptionOption GetTranscriptOptionFromSettings(Transcription transcriptConfig, TranscriptionOption currentTranscript);
    internal static string GetTranscriptPath();
    internal static string GetTranscriptPath(string baseDirectory, bool includeDate);
}
[FlagsAttribute]
public enum System.Management.Automation.Host.ReadKeyOptions : Enum {
    public int value__;
    public static ReadKeyOptions AllowCtrlC;
    public static ReadKeyOptions NoEcho;
    public static ReadKeyOptions IncludeKeyDown;
    public static ReadKeyOptions IncludeKeyUp;
}
public class System.Management.Automation.Host.Rectangle : ValueType {
    private int left;
    private int top;
    private int right;
    private int bottom;
    public int Left { get; public set; }
    public int Top { get; public set; }
    public int Right { get; public set; }
    public int Bottom { get; public set; }
    public Rectangle(int left, int top, int right, int bottom);
    public Rectangle(Coordinates upperLeft, Coordinates lowerRight);
    public int get_Left();
    public void set_Left(int value);
    public int get_Top();
    public void set_Top(int value);
    public int get_Right();
    public void set_Right(int value);
    public int get_Bottom();
    public void set_Bottom(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Rectangle first, Rectangle second);
    public static bool op_Inequality(Rectangle first, Rectangle second);
}
public class System.Management.Automation.Host.Size : ValueType {
    private int width;
    private int height;
    public int Width { get; public set; }
    public int Height { get; public set; }
    public Size(int width, int height);
    public int get_Width();
    public void set_Width(int value);
    public int get_Height();
    public void set_Height(int value);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Size first, Size second);
    public static bool op_Inequality(Size first, Size second);
}
internal class System.Management.Automation.Host.TranscriptionData : object {
    [CompilerGeneratedAttribute]
private List`1<TranscriptionOption> <Transcripts>k__BackingField;
    [CompilerGeneratedAttribute]
private TranscriptionOption <SystemTranscript>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandBeingIgnored>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHelperCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PromptText>k__BackingField;
    internal List`1<TranscriptionOption> Transcripts { get; }
    internal TranscriptionOption SystemTranscript { get; internal set; }
    internal string CommandBeingIgnored { get; internal set; }
    internal bool IsHelperCommand { get; internal set; }
    internal string PromptText { get; internal set; }
    [CompilerGeneratedAttribute]
internal List`1<TranscriptionOption> get_Transcripts();
    [CompilerGeneratedAttribute]
internal TranscriptionOption get_SystemTranscript();
    [CompilerGeneratedAttribute]
internal void set_SystemTranscript(TranscriptionOption value);
    [CompilerGeneratedAttribute]
internal string get_CommandBeingIgnored();
    [CompilerGeneratedAttribute]
internal void set_CommandBeingIgnored(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsHelperCommand();
    [CompilerGeneratedAttribute]
internal void set_IsHelperCommand(bool value);
    [CompilerGeneratedAttribute]
internal string get_PromptText();
    [CompilerGeneratedAttribute]
internal void set_PromptText(string value);
}
internal class System.Management.Automation.Host.TranscriptionOption : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <OutputToLog>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <OutputBeingLogged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeInvocationHeader>k__BackingField;
    private StreamWriter _contentWriter;
    private bool _disposed;
    internal string Path { get; internal set; }
    internal List`1<string> OutputToLog { get; }
    internal List`1<string> OutputBeingLogged { get; }
    internal bool IncludeInvocationHeader { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_OutputToLog();
    [CompilerGeneratedAttribute]
internal List`1<string> get_OutputBeingLogged();
    [CompilerGeneratedAttribute]
internal bool get_IncludeInvocationHeader();
    [CompilerGeneratedAttribute]
internal void set_IncludeInvocationHeader(bool value);
    internal void FlushContentToDisk();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static Encoding <FlushContentToDisk>g__GetPathEncoding|15_0(string path);
}
public class System.Management.Automation.HostInformationMessage : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <NoNewLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColor> <ForegroundColor>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ConsoleColor> <BackgroundColor>k__BackingField;
    public string Message { get; public set; }
    public Nullable`1<bool> NoNewLine { get; public set; }
    public Nullable`1<ConsoleColor> ForegroundColor { get; public set; }
    public Nullable`1<ConsoleColor> BackgroundColor { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_NoNewLine();
    [CompilerGeneratedAttribute]
public void set_NoNewLine(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColor> get_ForegroundColor();
    [CompilerGeneratedAttribute]
public void set_ForegroundColor(Nullable`1<ConsoleColor> value);
    [CompilerGeneratedAttribute]
public Nullable`1<ConsoleColor> get_BackgroundColor();
    [CompilerGeneratedAttribute]
public void set_BackgroundColor(Nullable`1<ConsoleColor> value);
    public virtual string ToString();
}
public static class System.Management.Automation.HostUtilities : object {
    private static char s_actionIndicator;
    private static string s_checkForCommandInCurrentDirectoryScript;
    private static string s_createCommandExistsInCurrentDirectoryScript;
    private static string s_getFuzzyMatchedCommands;
    private static List`1<Hashtable> s_suggestions;
    public static string PSEditFunction;
    public static string CreatePSEditFunction;
    public static string RemovePSEditFunction;
    public static string RemoteSessionOpenFileEvent;
    private static HostUtilities();
    private static bool HostSupportUnicode();
    private static List`1<Hashtable> InitializeSuggestions();
    internal static PSObject GetDollarProfile(string allUsersAllHosts, string allUsersCurrentHost, string currentUserAllHosts, string currentUserCurrentHost);
    internal static void GetProfileObjectData(string shellId, bool useTestProfile, String& allUsersAllHosts, String& allUsersCurrentHost, String& currentUserAllHosts, String& currentUserCurrentHost, PSObject& dollarProfile);
    internal static PSCommand[] GetProfileCommands(string shellId, bool useTestProfile);
    internal static string GetFullProfileFileName(string shellId, bool forCurrentUser);
    internal static string GetFullProfileFileName(string shellId, bool forCurrentUser, bool useTestProfile);
    private static string GetAllUsersFolderPath(string shellId);
    internal static string GetMaxLines(string source, int maxLines);
    internal static List`1<string> GetSuggestion(Runspace runspace);
    internal static List`1<string> GetSuggestion(HistoryInfo lastHistory, object lastError, ArrayList errorList);
    private static Hashtable NewSuggestion(int id, string category, SuggestionMatchType matchType, string rule, ScriptBlock suggestion, Object[] suggestionArgs, bool enabled);
    private static Hashtable NewSuggestion(int id, string category, SuggestionMatchType matchType, ScriptBlock rule, ScriptBlock suggestion, bool enabled);
    private static Hashtable NewSuggestion(int id, string category, SuggestionMatchType matchType, ScriptBlock rule, ScriptBlock suggestion, Object[] suggestionArgs, bool enabled);
    private static string GetSuggestionText(object suggestion, Object[] suggestionArgs, PSModuleInfo invocationModule);
    internal static string GetRemotePrompt(RemoteRunspace runspace, string basePrompt, bool configuredSession);
    internal static RemoteRunspace CreateConfiguredRunspace(string configurationName, PSHost host);
    public static Collection`1<PSObject> InvokeOnRunspace(PSCommand command, Runspace runspace);
    public static void RenderFeedback(List`1<FeedbackResult> feedbacks, PSHostUserInterface ui);
    internal static void RenderText(StringBuilder output, string text, string style, string ansiReset, int indent, bool startOnNewLine);
    internal static void RenderActions(StringBuilder output, FeedbackItem item, string textStyle, string actionStyle, string ansiReset);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.IArgumentCompleter {
    public abstract virtual IEnumerable`1<CompletionResult> CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
public interface System.Management.Automation.IArgumentCompleterFactory {
    public abstract virtual IArgumentCompleter Create();
}
internal interface System.Management.Automation.IBlockingEnumerator`1 {
    public abstract virtual bool MoveNext(bool block);
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.ICommandRuntime {
    public PSHost Host { get; }
    public PSTransactionContext CurrentPSTransaction { get; }
    public abstract virtual PSHost get_Host();
    [NullableContextAttribute("1")]
public abstract virtual void WriteDebug(string text);
    [NullableContextAttribute("1")]
public abstract virtual void WriteError(ErrorRecord errorRecord);
    public abstract virtual void WriteObject(object sendToPipeline);
    public abstract virtual void WriteObject(object sendToPipeline, bool enumerateCollection);
    [NullableContextAttribute("1")]
public abstract virtual void WriteProgress(ProgressRecord progressRecord);
    [NullableContextAttribute("1")]
public abstract virtual void WriteProgress(long sourceId, ProgressRecord progressRecord);
    [NullableContextAttribute("1")]
public abstract virtual void WriteVerbose(string text);
    [NullableContextAttribute("1")]
public abstract virtual void WriteWarning(string text);
    [NullableContextAttribute("1")]
public abstract virtual void WriteCommandDetail(string text);
    public abstract virtual bool ShouldProcess(string target);
    public abstract virtual bool ShouldProcess(string target, string action);
    public abstract virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    public abstract virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    public abstract virtual bool ShouldContinue(string query, string caption);
    public abstract virtual bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    public abstract virtual bool TransactionAvailable();
    public abstract virtual PSTransactionContext get_CurrentPSTransaction();
    [NullableContextAttribute("1")]
[DoesNotReturnAttribute]
public abstract virtual void ThrowTerminatingError(ErrorRecord errorRecord);
}
public interface System.Management.Automation.ICommandRuntime2 {
    [NullableContextAttribute("1")]
public abstract virtual void WriteInformation(InformationRecord informationRecord);
    [NullableContextAttribute("2")]
public abstract virtual bool ShouldContinue(string query, string caption, bool hasSecurityImpact, Boolean& yesToAll, Boolean& noToAll);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.IContainsErrorRecord {
    public ErrorRecord ErrorRecord { get; }
    public abstract virtual ErrorRecord get_ErrorRecord();
}
[NullableContextAttribute("1")]
[GuidAttribute("00020400-0000-0000-c000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Management.Automation.IDispatch {
    public abstract virtual int GetTypeInfoCount(Int32& info);
    [NullableContextAttribute("2")]
public abstract virtual int GetTypeInfo(int iTInfo, int lcid, ITypeInfo& ppTInfo);
    public abstract virtual void GetIDsOfNames(Guid iid, String[] rgszNames, int cNames, int lcid, Int32[] rgDispId);
    public abstract virtual void Invoke(int dispIdMember, Guid iid, int lcid, INVOKEKIND wFlags, DISPPARAMS[] paramArray, Object& pVarResult, EXCEPINFO& pExcepInfo, UInt32& puArgErr);
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.IDynamicParameters {
    public abstract virtual object GetDynamicParameters();
}
internal interface System.Management.Automation.IHasSessionStateEntryVisibility {
    public SessionStateEntryVisibility Visibility { get; public set; }
    public abstract virtual SessionStateEntryVisibility get_Visibility();
    public abstract virtual void set_Visibility(SessionStateEntryVisibility value);
}
[GuidAttribute("AF86E2E0-B12D-4c6a-9C5A-D7AA65101E90")]
[InterfaceTypeAttribute("1")]
internal interface System.Management.Automation.IInspectable {
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.IJobDebugger {
    public Debugger Debugger { get; }
    public bool IsAsync { get; public set; }
    public abstract virtual Debugger get_Debugger();
    public abstract virtual bool get_IsAsync();
    public abstract virtual void set_IsAsync(bool value);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.IModuleAssemblyCleanup {
    public abstract virtual void OnRemove(PSModuleInfo psModuleInfo);
}
public interface System.Management.Automation.IModuleAssemblyInitializer {
    public abstract virtual void OnImport();
}
public enum System.Management.Automation.ImplementedAsType : Enum {
    public int value__;
    public static ImplementedAsType None;
    public static ImplementedAsType PowerShell;
    public static ImplementedAsType Binary;
    public static ImplementedAsType Composite;
}
public class System.Management.Automation.IncompleteParseException : ParseException {
    private static string errorIdString;
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected IncompleteParseException(SerializationInfo info, StreamingContext context);
    public IncompleteParseException(string message);
    internal IncompleteParseException(string message, string errorId);
    internal IncompleteParseException(string message, string errorId, Exception innerException);
    public IncompleteParseException(string message, Exception innerException);
}
[DataContractAttribute]
public abstract class System.Management.Automation.InformationalRecord : object {
    [DataMemberAttribute]
private string _message;
    private InvocationInfo _invocationInfo;
    private ReadOnlyCollection`1<int> _pipelineIterationInfo;
    private bool _serializeExtendedInfo;
    public string Message { get; public set; }
    public InvocationInfo InvocationInfo { get; }
    public ReadOnlyCollection`1<int> PipelineIterationInfo { get; }
    internal bool SerializeExtendedInfo { get; internal set; }
    internal InformationalRecord(string message);
    internal InformationalRecord(PSObject serializedObject);
    public string get_Message();
    public void set_Message(string value);
    public InvocationInfo get_InvocationInfo();
    public ReadOnlyCollection`1<int> get_PipelineIterationInfo();
    internal void SetInvocationInfo(InvocationInfo invocationInfo);
    internal bool get_SerializeExtendedInfo();
    internal void set_SerializeExtendedInfo(bool value);
    public virtual string ToString();
    internal virtual void ToPSObjectForRemoting(PSObject psObject);
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__14_0();
    [CompilerGeneratedAttribute]
private object <ToPSObjectForRemoting>b__14_3();
}
[DataContractAttribute]
public class System.Management.Automation.InformationRecord : object {
    [CompilerGeneratedAttribute]
private object <MessageData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeGenerated>k__BackingField;
    private List`1<string> _tags;
    private string _user;
    private string _computerName;
    private Nullable`1<UInt32> _processId;
    [CompilerGeneratedAttribute]
private UInt32 <NativeThreadId>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ManagedThreadId>k__BackingField;
    [DataMemberAttribute]
public object MessageData { get; internal set; }
    [DataMemberAttribute]
public string Source { get; public set; }
    [DataMemberAttribute]
public DateTime TimeGenerated { get; public set; }
    [DataMemberAttribute]
public List`1<string> Tags { get; internal set; }
    [DataMemberAttribute]
public string User { get; public set; }
    [DataMemberAttribute]
public string Computer { get; public set; }
    [DataMemberAttribute]
public UInt32 ProcessId { get; public set; }
    public UInt32 NativeThreadId { get; public set; }
    [DataMemberAttribute]
public UInt32 ManagedThreadId { get; public set; }
    public InformationRecord(object messageData, string source);
    internal InformationRecord(InformationRecord baseRecord);
    [CompilerGeneratedAttribute]
public object get_MessageData();
    [CompilerGeneratedAttribute]
internal void set_MessageData(object value);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public void set_Source(string value);
    [CompilerGeneratedAttribute]
public DateTime get_TimeGenerated();
    [CompilerGeneratedAttribute]
public void set_TimeGenerated(DateTime value);
    public List`1<string> get_Tags();
    internal void set_Tags(List`1<string> value);
    public string get_User();
    public void set_User(string value);
    public string get_Computer();
    public void set_Computer(string value);
    public UInt32 get_ProcessId();
    public void set_ProcessId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_NativeThreadId();
    [CompilerGeneratedAttribute]
public void set_NativeThreadId(UInt32 value);
    [CompilerGeneratedAttribute]
public UInt32 get_ManagedThreadId();
    [CompilerGeneratedAttribute]
public void set_ManagedThreadId(UInt32 value);
    public virtual string ToString();
    internal static InformationRecord FromPSObjectForRemoting(PSObject inputObject);
    internal PSObject ToPSObjectForRemoting();
}
public static class System.Management.Automation.Internal.AlternateDataStreamUtilities : object {
    internal static List`1<AlternateStreamData> GetStreams(string path);
    internal static FileStream CreateFileStream(string path, string streamName, FileMode mode, FileAccess access, FileShare share);
    internal static bool TryCreateFileStream(string path, string streamName, FileMode mode, FileAccess access, FileShare share, FileStream& stream);
    internal static void DeleteFileStream(string path, string streamName);
    internal static void SetZoneOfOrigin(string path, SecurityZone securityZone);
}
public class System.Management.Automation.Internal.AlternateStreamData : object {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Length>k__BackingField;
    public string FileName { get; public set; }
    public string Stream { get; public set; }
    public long Length { get; public set; }
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public void set_FileName(string value);
    [CompilerGeneratedAttribute]
public string get_Stream();
    [CompilerGeneratedAttribute]
public void set_Stream(string value);
    [CompilerGeneratedAttribute]
public long get_Length();
    [CompilerGeneratedAttribute]
public void set_Length(long value);
}
public static class System.Management.Automation.Internal.AutomationNull : object {
    [CompilerGeneratedAttribute]
private static PSObject <Value>k__BackingField;
    public static PSObject Value { get; }
    private static AutomationNull();
    [CompilerGeneratedAttribute]
public static PSObject get_Value();
}
internal class System.Management.Automation.Internal.BoundedStack`1 : LinkedList`1<T> {
    private int _capacity;
    internal BoundedStack`1(int capacity);
    internal void Push(T item);
    internal T Pop();
}
internal class System.Management.Automation.Internal.CabinetExtractor : ICabinetExtractor {
    private FdiAllocDelegate _allocDelegate;
    private GCHandle _fdiAllocHandle;
    private FdiFreeDelegate _freeDelegate;
    private GCHandle _fdiFreeHandle;
    private FdiOpenDelegate _openDelegate;
    private GCHandle _fdiOpenHandle;
    private FdiReadDelegate _readDelegate;
    private GCHandle _fdiReadHandle;
    private FdiWriteDelegate _writeDelegate;
    private GCHandle _fdiWriteHandle;
    private FdiCloseDelegate _closeDelegate;
    private GCHandle _fdiCloseHandle;
    private FdiSeekDelegate _seekDelegate;
    private GCHandle _fdiSeekHandle;
    private FdiNotifyDelegate _notifyDelegate;
    private GCHandle _fdiNotifyHandle;
    internal FdiContextHandle fdiContext;
    private bool _disposed;
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal virtual bool Extract(string cabinetName, string srcPath, string destPath);
    private void populateDelegates();
    private void CleanUpDelegates();
}
internal static class System.Management.Automation.Internal.CabinetExtractorFactory : object {
    private static ICabinetExtractorLoader s_cabinetLoader;
    internal static ICabinetExtractor EmptyExtractor;
    private static CabinetExtractorFactory();
    internal static ICabinetExtractor GetCabinetExtractor();
}
internal class System.Management.Automation.Internal.CabinetExtractorLoader : ICabinetExtractorLoader {
    private static CabinetExtractor s_extractorInstance;
    private static CabinetExtractorLoader s_instance;
    private static double s_created;
    internal static CabinetExtractorLoader GetInstance();
    internal virtual ICabinetExtractor GetCabinetExtractor();
}
internal static class System.Management.Automation.Internal.CabinetNativeApi : object {
    internal static IntPtr FdiAlloc(int size);
    internal static void FdiFree(IntPtr memblock);
    internal static IntPtr FdiOpen(string filename, int oflag, int pmode);
    internal static int FdiRead(IntPtr fp, Byte[] buffer, int count);
    internal static int FdiWrite(IntPtr fp, Byte[] buffer, int count);
    internal static int FdiClose(IntPtr fp);
    internal static int FdiSeek(IntPtr fp, int offset, int origin);
    internal static IntPtr FdiNotify(FdiNotificationType fdint, FdiNotification fdin);
    internal static SeekOrigin ConvertOriginToSeekOrigin(int origin);
    internal static FileMode ConvertOpflagToFileMode(int oflag);
    internal static FileAccess ConvertPermissionModeToFileAccess(int pmode);
    internal static FileShare ConvertPermissionModeToFileShare(int pmode);
    internal static FdiContextHandle FDICreate(IntPtr pfnalloc, IntPtr pfnfree, IntPtr pfnopen, IntPtr pfnread, IntPtr pfnwrite, IntPtr pfnclose, IntPtr pfnseek, FdiCreateCpuType cpuType, FdiERF erf);
    internal static bool FDICopy(FdiContextHandle hfdi, string pszCabinet, string pszCabPath, int flags, IntPtr pfnfdin, IntPtr pfnfdid, IntPtr pvUser);
    internal static bool FDIDestroy(IntPtr hfdi);
}
internal class System.Management.Automation.Internal.CertificateFilterInfo : object {
    [CompilerGeneratedAttribute]
private CertificatePurpose <Purpose>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SSLServerAuthentication>k__BackingField;
    [CompilerGeneratedAttribute]
private WildcardPattern <DnsName>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<WildcardPattern> <Eku>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <Expiring>k__BackingField;
    internal static string CodeSigningOid;
    internal static string OID_PKIX_KP_SERVER_AUTH;
    internal static string DocumentEncryptionOid;
    internal CertificatePurpose Purpose { get; internal set; }
    internal bool SSLServerAuthentication { get; internal set; }
    internal WildcardPattern DnsName { get; internal set; }
    internal List`1<WildcardPattern> Eku { get; internal set; }
    internal DateTime Expiring { get; internal set; }
    [CompilerGeneratedAttribute]
internal CertificatePurpose get_Purpose();
    [CompilerGeneratedAttribute]
internal void set_Purpose(CertificatePurpose value);
    [CompilerGeneratedAttribute]
internal bool get_SSLServerAuthentication();
    [CompilerGeneratedAttribute]
internal void set_SSLServerAuthentication(bool value);
    [CompilerGeneratedAttribute]
internal WildcardPattern get_DnsName();
    [CompilerGeneratedAttribute]
internal void set_DnsName(WildcardPattern value);
    [CompilerGeneratedAttribute]
internal List`1<WildcardPattern> get_Eku();
    [CompilerGeneratedAttribute]
internal void set_Eku(List`1<WildcardPattern> value);
    [CompilerGeneratedAttribute]
internal DateTime get_Expiring();
    [CompilerGeneratedAttribute]
internal void set_Expiring(DateTime value);
}
public static class System.Management.Automation.Internal.ClassOps : object {
    private static ConditionalWeakTable`2<MethodInfo, DynamicMethod> s_nonVirtualCallCache;
    private static ClassOps();
    public static void ValidateSetProperty(Type type, string propertyName, object value);
    public static void CallBaseCtor(object target, ConstructorInfo ci, Object[] args);
    public static object CallMethodNonVirtually(object target, MethodInfo mi, Object[] args);
    public static void CallVoidMethodNonVirtually(object target, MethodInfo mi, Object[] args);
    private static object CallMethodNonVirtuallyImpl(object target, MethodInfo mi, Object[] args);
    private static DynamicMethod CreateDynamicMethod(MethodInfo mi);
}
internal class System.Management.Automation.Internal.ClientPowerShellDataStructureHandler : object {
    [CompilerGeneratedAttribute]
private EventHandler RemoveAssociation;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSInvocationStateInfo>> InvocationStateInfoReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<object>> OutputReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<ErrorRecord>> ErrorReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<InformationalMessage>> InformationalMessageReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> HostCallReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> ClosedNotificationFromRunspacePool;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> CloseCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> BrokenNotificationFromRunspacePool;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> ReconnectCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> ConnectCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionStatusEventArgs> RobustConnectionNotification;
    protected Guid clientRunspacePoolId;
    protected Guid clientPowerShellId;
    [CompilerGeneratedAttribute]
private BaseClientCommandTransportManager <TransportManager>k__BackingField;
    private object _inputSyncObject;
    private int _connectionState;
    private Exception _sessionClosedReason;
    internal Guid PowerShellId { get; }
    internal BaseClientCommandTransportManager TransportManager { get; }
    internal ClientPowerShellDataStructureHandler(BaseClientCommandTransportManager transportManager, Guid clientRunspacePoolId, Guid clientPowerShellId);
    [CompilerGeneratedAttribute]
internal void add_RemoveAssociation(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_RemoveAssociation(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_InvocationStateInfoReceived(EventHandler`1<RemoteDataEventArgs`1<PSInvocationStateInfo>> value);
    [CompilerGeneratedAttribute]
internal void remove_InvocationStateInfoReceived(EventHandler`1<RemoteDataEventArgs`1<PSInvocationStateInfo>> value);
    [CompilerGeneratedAttribute]
internal void add_OutputReceived(EventHandler`1<RemoteDataEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
internal void remove_OutputReceived(EventHandler`1<RemoteDataEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
internal void add_ErrorReceived(EventHandler`1<RemoteDataEventArgs`1<ErrorRecord>> value);
    [CompilerGeneratedAttribute]
internal void remove_ErrorReceived(EventHandler`1<RemoteDataEventArgs`1<ErrorRecord>> value);
    [CompilerGeneratedAttribute]
internal void add_InformationalMessageReceived(EventHandler`1<RemoteDataEventArgs`1<InformationalMessage>> value);
    [CompilerGeneratedAttribute]
internal void remove_InformationalMessageReceived(EventHandler`1<RemoteDataEventArgs`1<InformationalMessage>> value);
    [CompilerGeneratedAttribute]
internal void add_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void remove_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void add_ClosedNotificationFromRunspacePool(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_ClosedNotificationFromRunspacePool(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_CloseCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_CloseCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_BrokenNotificationFromRunspacePool(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_BrokenNotificationFromRunspacePool(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_ReconnectCompleted(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_ReconnectCompleted(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_ConnectCompleted(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_ConnectCompleted(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_RobustConnectionNotification(EventHandler`1<ConnectionStatusEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RobustConnectionNotification(EventHandler`1<ConnectionStatusEventArgs> value);
    internal void Start(ClientRemoteSessionDSHandlerStateMachine stateMachine, bool inDisconnectMode);
    private void HandleDelayStreamRequestProcessed(object sender, EventArgs e);
    internal void HandleReconnectCompleted(object sender, EventArgs args);
    internal void HandleConnectCompleted(object sender, EventArgs args);
    internal void HandleTransportError(object sender, TransportErrorOccuredEventArgs e);
    internal void SendStopPowerShellMessage();
    private void OnSignalCompleted(object sender, EventArgs e);
    internal void SendHostResponseToServer(RemoteHostResponse hostResponse);
    internal void SendInput(ObjectStreamBase inputstream);
    internal void ProcessReceivedData(RemoteDataObject`1<PSObject> receivedData);
    internal void SetStateToFailed(Exception reason);
    internal void SetStateToStopped(Exception reason);
    internal void CloseConnectionAsync(Exception sessionCloseReason);
    internal void RaiseRemoveAssociationEvent();
    internal void ProcessDisconnect(RunspacePoolStateInfo rsStateInfo);
    internal void ReconnectAsync();
    internal void ConnectAsync();
    internal void ProcessRobustConnectionNotification(ConnectionStatusEventArgs e);
    internal Guid get_PowerShellId();
    [CompilerGeneratedAttribute]
internal BaseClientCommandTransportManager get_TransportManager();
    private void SendDataAsync(RemoteDataObject data);
    private void HandleInputDataReady(object sender, EventArgs e);
    private void WriteInput(ObjectStreamBase inputstream);
    private void SetupTransportManager(bool inDisconnectMode);
    [CompilerGeneratedAttribute]
private void <CloseConnectionAsync>b__48_0(object source, EventArgs args);
}
internal class System.Management.Automation.Internal.ClientRunspacePoolDataStructureHandler : object {
    private bool _reconnecting;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> RemoteHostCallReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RunspacePoolStateInfo>> StateInfoReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RunspacePoolInitInfo>> RSPoolInitInfoReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSPrimitiveDictionary>> ApplicationPrivateDataReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSEventArgs>> PSEventArgsReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> SessionClosed;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> SessionDisconnected;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> SessionReconnected;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> SessionClosing;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSObject>> SetMaxMinRunspacesResponseReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Uri>> URIRedirectionReported;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Exception>> SessionRCDisconnecting;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreateCompleteEventArgs> SessionCreateCompleted;
    private Guid _clientRunspacePoolId;
    private object _syncObject;
    private bool _createRunspaceCalled;
    private Exception _closingReason;
    private int _minRunspaces;
    private int _maxRunspaces;
    private PSHost _host;
    private PSPrimitiveDictionary _applicationArguments;
    private Dictionary`2<Guid, ClientPowerShellDataStructureHandler> _associatedPowerShellDSHandlers;
    private object _associationSyncObject;
    private BaseClientSessionTransportManager _transportManager;
    private List`1<BaseClientCommandTransportManager> _preparingForDisconnectList;
    [CompilerGeneratedAttribute]
private ClientRemoteSession <RemoteSession>k__BackingField;
    internal ClientRemoteSession RemoteSession { get; private set; }
    internal BaseClientSessionTransportManager TransportManager { get; }
    internal int MaxRetryConnectionTime { get; }
    internal bool EndpointSupportsDisconnect { get; }
    internal ClientRunspacePoolDataStructureHandler(RemoteRunspacePoolInternal clientRunspacePool, TypeTable typeTable);
    internal void CreateRunspacePoolAndOpenAsync();
    internal void CloseRunspacePoolAsync();
    internal void DisconnectPoolAsync();
    internal void ReconnectPoolAsync();
    internal void ConnectPoolAsync();
    internal void ProcessReceivedData(RemoteDataObject`1<PSObject> receivedData);
    internal ClientPowerShellDataStructureHandler CreatePowerShellDataStructureHandler(ClientRemotePowerShell shell);
    internal void CreatePowerShellOnServerAndInvoke(ClientRemotePowerShell shell);
    internal void AddRemotePowerShellDSHandler(Guid psShellInstanceId, ClientPowerShellDataStructureHandler psDSHandler);
    internal void DispatchMessageToPowerShell(RemoteDataObject`1<PSObject> rcvdData);
    internal void SendHostResponseToServer(RemoteHostResponse hostResponse);
    internal void SendResetRunspaceStateToServer(long callId);
    internal void SendSetMaxRunspacesToServer(int maxRunspaces, long callId);
    internal void SendSetMinRunspacesToServer(int minRunspaces, long callId);
    internal void SendGetAvailableRunspacesToServer(long callId);
    [CompilerGeneratedAttribute]
internal void add_RemoteHostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void remove_RemoteHostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void add_StateInfoReceived(EventHandler`1<RemoteDataEventArgs`1<RunspacePoolStateInfo>> value);
    [CompilerGeneratedAttribute]
internal void remove_StateInfoReceived(EventHandler`1<RemoteDataEventArgs`1<RunspacePoolStateInfo>> value);
    [CompilerGeneratedAttribute]
internal void add_RSPoolInitInfoReceived(EventHandler`1<RemoteDataEventArgs`1<RunspacePoolInitInfo>> value);
    [CompilerGeneratedAttribute]
internal void remove_RSPoolInitInfoReceived(EventHandler`1<RemoteDataEventArgs`1<RunspacePoolInitInfo>> value);
    [CompilerGeneratedAttribute]
internal void add_ApplicationPrivateDataReceived(EventHandler`1<RemoteDataEventArgs`1<PSPrimitiveDictionary>> value);
    [CompilerGeneratedAttribute]
internal void remove_ApplicationPrivateDataReceived(EventHandler`1<RemoteDataEventArgs`1<PSPrimitiveDictionary>> value);
    [CompilerGeneratedAttribute]
internal void add_PSEventArgsReceived(EventHandler`1<RemoteDataEventArgs`1<PSEventArgs>> value);
    [CompilerGeneratedAttribute]
internal void remove_PSEventArgsReceived(EventHandler`1<RemoteDataEventArgs`1<PSEventArgs>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionClosed(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionClosed(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionDisconnected(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionDisconnected(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionReconnected(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionReconnected(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionClosing(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionClosing(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_SetMaxMinRunspacesResponseReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void remove_SetMaxMinRunspacesResponseReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void add_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    [CompilerGeneratedAttribute]
internal void remove_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionRCDisconnecting(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionRCDisconnecting(EventHandler`1<RemoteDataEventArgs`1<Exception>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionCreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionCreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    private void SendDataAsync(RemoteDataObject data);
    internal void SendDataAsync(RemoteDataObject`1<T> data, DataPriorityType priority);
    internal void SendDataAsync(PSObject data, DataPriorityType priority);
    private ClientRemoteSessionImpl CreateClientRemoteSession(RemoteRunspacePoolInternal rsPoolInternal);
    private void HandleClientRemoteSessionStateChanged(object sender, RemoteSessionStateEventArgs e);
    private void HandleURIDirectionReported(Uri newURI);
    private void NotifyAssociatedPowerShells(RunspacePoolStateInfo stateInfo);
    private ClientPowerShellDataStructureHandler GetAssociatedPowerShellDataStructureHandler(Guid clientPowerShellId);
    private void HandleRemoveAssociation(object sender, EventArgs e);
    private void PrepareForAndStartDisconnect();
    private void PrepareForConnect();
    private void HandleReadyForDisconnect(object sender, EventArgs args);
    private void StartDisconnectAsync(object state);
    private void HandleRobustConnectionNotification(object sender, ConnectionStatusEventArgs e);
    private void HandleSessionCreateCompleted(object sender, CreateCompleteEventArgs eventArgs);
    [CompilerGeneratedAttribute]
internal ClientRemoteSession get_RemoteSession();
    [CompilerGeneratedAttribute]
private void set_RemoteSession(ClientRemoteSession value);
    internal BaseClientSessionTransportManager get_TransportManager();
    internal int get_MaxRetryConnectionTime();
    internal bool get_EndpointSupportsDisconnect();
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Management.Automation.Internal.CmdletMetadataAttribute : Attribute {
}
internal class System.Management.Automation.Internal.CommandScore : ValueType {
    public CommandInfo Command;
    public int Score;
    public CommandScore(CommandInfo command, int score);
}
public class System.Management.Automation.Internal.CommonParameters : object {
    private MshCommandRuntime _commandRuntime;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Verbose { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Debug { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ActionPreference ErrorAction { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ActionPreference WarningAction { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ActionPreference InformationAction { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ActionPreference ProgressAction { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateVariableName]
public string ErrorVariable { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateVariableName]
public string WarningVariable { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateVariableName]
public string InformationVariable { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateVariableName]
public string OutVariable { get; public set; }
    [ParameterAttribute]
[ValidateRangeAttribute("Mono.Cecil.CustomAttributeArgument", "Mono.Cecil.CustomAttributeArgument")]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public int OutBuffer { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[ValidateVariableName]
public string PipelineVariable { get; public set; }
    internal CommonParameters(MshCommandRuntime commandRuntime);
    public SwitchParameter get_Verbose();
    public void set_Verbose(SwitchParameter value);
    public SwitchParameter get_Debug();
    public void set_Debug(SwitchParameter value);
    public ActionPreference get_ErrorAction();
    public void set_ErrorAction(ActionPreference value);
    public ActionPreference get_WarningAction();
    public void set_WarningAction(ActionPreference value);
    public ActionPreference get_InformationAction();
    public void set_InformationAction(ActionPreference value);
    public ActionPreference get_ProgressAction();
    public void set_ProgressAction(ActionPreference value);
    public string get_ErrorVariable();
    public void set_ErrorVariable(string value);
    public string get_WarningVariable();
    public void set_WarningVariable(string value);
    public string get_InformationVariable();
    public void set_InformationVariable(string value);
    public string get_OutVariable();
    public void set_OutVariable(string value);
    public int get_OutBuffer();
    public void set_OutBuffer(int value);
    public string get_PipelineVariable();
    public void set_PipelineVariable(string value);
}
internal static class System.Management.Automation.Internal.CopyFileRemoteUtils : object {
    private static string functionToken;
    private static string nameToken;
    private static string definitionToken;
    internal static string PSCopyToSessionHelperName;
    private static string s_driveMaxSizeErrorFormatString;
    private static string s_PSCopyToSessionHelperDefinition;
    private static string s_PSCopyToSessionHelperDefinitionRestricted;
    private static string PSCopyToSessionHelperDefinitionFormat;
    private static string s_PSCopyToSessionHelper;
    private static Hashtable s_PSCopyToSessionHelperFunction;
    internal static string PSCopyFromSessionHelperName;
    private static string s_PSCopyFromSessionHelperDefinition;
    private static string s_PSCopyFromSessionHelperDefinitionRestricted;
    private static string PSCopyFromSessionHelperDefinitionFormat;
    internal static string PSCopyFromSessionHelper;
    private static Hashtable s_PSCopyFromSessionHelperFunction;
    internal static string PSCopyRemoteUtilsName;
    internal static string PSCopyRemoteUtilsDefinition;
    private static string s_PSCopyRemoteUtilsDefinitionRestricted;
    private static string PSCopyRemoteUtilsDefinitionFormat;
    private static string PSValidatePathFunction;
    internal static string PSValidatePathDefinition;
    internal static string PSCopyRemoteUtils;
    internal static Hashtable PSCopyRemoteUtilsFunction;
    internal static string AllCopyToRemoteScripts;
    internal static string AllCopyFromRemoteScripts;
    private static CopyFileRemoteUtils();
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.CopyFileRemoteUtils/<GetAllCopyToRemoteScriptFunctions>d__25")]
internal static IEnumerable`1<Hashtable> GetAllCopyToRemoteScriptFunctions();
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.CopyFileRemoteUtils/<GetAllCopyFromRemoteScriptFunctions>d__27")]
internal static IEnumerable`1<Hashtable> GetAllCopyFromRemoteScriptFunctions();
}
public static class System.Management.Automation.Internal.DebuggerUtils : object {
    private static SortedSet`1<string> s_noHistoryCommandNames;
    private static DebuggerUtils();
    public static bool ShouldAddCommandToHistory(string command);
    public static void StartMonitoringRunspace(Debugger debugger, PSMonitorRunspaceInfo runspaceInfo);
    public static void EndMonitoringRunspace(Debugger debugger, PSMonitorRunspaceInfo runspaceInfo);
}
internal class System.Management.Automation.Internal.EmptyCabinetExtractor : ICabinetExtractor {
    internal virtual bool Extract(string cabinetName, string srcPath, string destPath);
    protected virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Internal.GraphicalHostReflectionWrapper : object {
    private Assembly _graphicalHostAssembly;
    private Type _graphicalHostHelperType;
    private object _graphicalHostHelperObject;
    internal static GraphicalHostReflectionWrapper GetGraphicalHostReflectionWrapper(PSCmdlet parentCmdlet, string graphicalHostHelperTypeName);
    internal static GraphicalHostReflectionWrapper GetGraphicalHostReflectionWrapper(PSCmdlet parentCmdlet, string graphicalHostHelperTypeName, string featureName);
    internal static string EscapeBinding(string propertyName);
    internal object CallMethod(string methodName, Object[] arguments);
    internal object CallStaticMethod(string methodName, Object[] arguments);
    internal object GetPropertyValue(string propertyName);
    internal object GetStaticPropertyValue(string propertyName);
    private static bool IsInputFromRemoting(PSCmdlet parentCmdlet);
}
internal class System.Management.Automation.Internal.HistoryStack`1 : object {
    private BoundedStack`1<T> _boundedUndoStack;
    private BoundedStack`1<T> _boundedRedoStack;
    internal int UndoCount { get; }
    internal int RedoCount { get; }
    internal HistoryStack`1(int capacity);
    internal void Push(T item);
    internal T Undo(T currentItem);
    internal T Redo(T currentItem);
    internal int get_UndoCount();
    internal int get_RedoCount();
}
internal class System.Management.Automation.Internal.Host.InternalHost : PSHost {
    [CompilerGeneratedAttribute]
private bool <DebuggerEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NestedPromptCount>k__BackingField;
    private ObjectRef`1<PSHost> _externalHostRef;
    private ObjectRef`1<InternalHostUserInterface> _internalUIRef;
    private string _nameResult;
    private Version _versionResult;
    private Guid _idResult;
    private Stack`1<PromptContextData> _contextStack;
    private Guid _zeroGuid;
    public string Name { get; }
    public Version Version { get; }
    public Guid InstanceId { get; }
    public PSHostUserInterface UI { get; }
    internal InternalHostUserInterface InternalUI { get; }
    public CultureInfo CurrentCulture { get; }
    public CultureInfo CurrentUICulture { get; }
    public PSObject PrivateData { get; }
    public bool DebuggerEnabled { get; public set; }
    public bool IsRunspacePushed { get; }
    public Runspace Runspace { get; }
    internal bool IsHostRefSet { get; }
    internal ExecutionContext Context { get; }
    internal PSHost ExternalHost { get; }
    internal int NestedPromptCount { get; private set; }
    internal InternalHost(PSHost externalHost, ExecutionContext executionContext);
    public virtual string get_Name();
    public virtual Version get_Version();
    public virtual Guid get_InstanceId();
    public virtual PSHostUserInterface get_UI();
    internal InternalHostUserInterface get_InternalUI();
    public virtual CultureInfo get_CurrentCulture();
    public virtual CultureInfo get_CurrentUICulture();
    public virtual void SetShouldExit(int exitCode);
    public virtual void EnterNestedPrompt();
    internal void EnterNestedPrompt(InternalCommand callingCommand);
    private void ExitNestedPromptHelper();
    public virtual void ExitNestedPrompt();
    public virtual PSObject get_PrivateData();
    public virtual void NotifyBeginApplication();
    public virtual void NotifyEndApplication();
    [CompilerGeneratedAttribute]
public virtual bool get_DebuggerEnabled();
    [CompilerGeneratedAttribute]
public virtual void set_DebuggerEnabled(bool value);
    private IHostSupportsInteractiveSession GetIHostSupportsInteractiveSession();
    public sealed virtual void PushRunspace(Runspace runspace);
    public sealed virtual void PopRunspace();
    public sealed virtual bool get_IsRunspacePushed();
    public sealed virtual Runspace get_Runspace();
    internal bool HostInNestedPrompt();
    internal void SetHostRef(PSHost psHost);
    internal void RevertHostRef();
    internal bool get_IsHostRefSet();
    [CompilerGeneratedAttribute]
internal ExecutionContext get_Context();
    internal PSHost get_ExternalHost();
    [CompilerGeneratedAttribute]
internal int get_NestedPromptCount();
    [CompilerGeneratedAttribute]
private void set_NestedPromptCount(int value);
}
internal class System.Management.Automation.Internal.Host.InternalHostRawUserInterface : PSHostRawUserInterface {
    private PSHostRawUserInterface _externalRawUI;
    private InternalHost _parentHost;
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public Coordinates CursorPosition { get; public set; }
    public Coordinates WindowPosition { get; public set; }
    public int CursorSize { get; public set; }
    public Size BufferSize { get; public set; }
    public Size WindowSize { get; public set; }
    public Size MaxWindowSize { get; }
    public Size MaxPhysicalWindowSize { get; }
    public bool KeyAvailable { get; }
    public string WindowTitle { get; public set; }
    internal InternalHostRawUserInterface(PSHostRawUserInterface externalRawUI, InternalHost parentHost);
    internal void ThrowNotInteractive();
    public virtual ConsoleColor get_ForegroundColor();
    public virtual void set_ForegroundColor(ConsoleColor value);
    public virtual ConsoleColor get_BackgroundColor();
    public virtual void set_BackgroundColor(ConsoleColor value);
    public virtual Coordinates get_CursorPosition();
    public virtual void set_CursorPosition(Coordinates value);
    public virtual Coordinates get_WindowPosition();
    public virtual void set_WindowPosition(Coordinates value);
    public virtual int get_CursorSize();
    public virtual void set_CursorSize(int value);
    public virtual Size get_BufferSize();
    public virtual void set_BufferSize(Size value);
    public virtual Size get_WindowSize();
    public virtual void set_WindowSize(Size value);
    public virtual Size get_MaxWindowSize();
    public virtual Size get_MaxPhysicalWindowSize();
    public virtual KeyInfo ReadKey(ReadKeyOptions options);
    public virtual void FlushInputBuffer();
    public virtual bool get_KeyAvailable();
    public virtual string get_WindowTitle();
    public virtual void set_WindowTitle(string value);
    public virtual void SetBufferContents(Coordinates origin, BufferCell[0...,0...] contents);
    public virtual void SetBufferContents(Rectangle r, BufferCell fill);
    public virtual BufferCell[0...,0...] GetBufferContents(Rectangle r);
    public virtual void ScrollBufferContents(Rectangle source, Coordinates destination, Rectangle clip, BufferCell fill);
    public virtual int LengthInBufferCells(string str);
    public virtual int LengthInBufferCells(string str, int offset);
    public virtual int LengthInBufferCells(char character);
}
internal class System.Management.Automation.Internal.Host.InternalHostUserInterface : PSHostUserInterface {
    private PSHostUserInterface _externalUI;
    private InternalHostRawUserInterface _internalRawUI;
    private InternalHost _parent;
    private PSInformationalBuffers _informationalBuffers;
    public PSHostRawUserInterface RawUI { get; }
    public bool SupportsVirtualTerminal { get; }
    internal InternalHostUserInterface(PSHostUserInterface externalUI, InternalHost parentHost);
    private void ThrowNotInteractive();
    private static void ThrowPromptNotInteractive(string promptMessage);
    public virtual PSHostRawUserInterface get_RawUI();
    public virtual bool get_SupportsVirtualTerminal();
    public virtual string ReadLine();
    public virtual SecureString ReadLineAsSecureString();
    public virtual void Write(string value);
    public virtual void Write(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string value);
    public virtual void WriteLine();
    public virtual void WriteLine(string value);
    public virtual void WriteErrorLine(string value);
    public virtual void WriteLine(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string value);
    public virtual void WriteDebugLine(string message);
    internal void WriteDebugRecord(DebugRecord record);
    internal void WriteDebugInfoBuffers(DebugRecord record);
    internal void WriteDebugLine(string message, ActionPreference& preference);
    internal void SetInformationalMessageBuffers(PSInformationalBuffers informationalBuffers);
    internal PSInformationalBuffers GetInformationalMessageBuffers();
    private void WriteDebugLineHelper(string message);
    private bool DebugShouldContinue(string message, ActionPreference& actionPreference);
    public virtual void WriteProgress(long sourceId, ProgressRecord record);
    public virtual void WriteVerboseLine(string message);
    internal void WriteVerboseRecord(VerboseRecord record);
    internal void WriteVerboseInfoBuffers(VerboseRecord record);
    public virtual void WriteWarningLine(string message);
    internal void WriteWarningRecord(WarningRecord record);
    internal void WriteWarningInfoBuffers(WarningRecord record);
    internal void WriteInformationRecord(InformationRecord record);
    internal void WriteInformationInfoBuffers(InformationRecord record);
    internal static Type GetFieldType(FieldDescription field);
    internal static bool IsSecuritySensitiveType(string typeName);
    public virtual Dictionary`2<string, PSObject> Prompt(string caption, string message, Collection`1<FieldDescription> descriptions);
    public virtual int PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, int defaultChoice);
    public sealed virtual Collection`1<int> PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, IEnumerable`1<int> defaultChoices);
    private Collection`1<int> EmulatePromptForMultipleChoice(string caption, string message, Collection`1<ChoiceDescription> choices, IEnumerable`1<int> defaultChoices);
    public virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName);
    public virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName, PSCredentialTypes allowedCredentialTypes, PSCredentialUIOptions options);
}
internal abstract class System.Management.Automation.Internal.ICabinetExtractor : object {
    private bool _disposed;
    internal abstract virtual bool Extract(string cabinetName, string srcPath, string destPath);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
}
internal abstract class System.Management.Automation.Internal.ICabinetExtractorLoader : object {
    internal virtual ICabinetExtractor GetCabinetExtractor();
}
internal class System.Management.Automation.Internal.InformationalMessage : object {
    [CompilerGeneratedAttribute]
private object <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private RemotingDataType <DataType>k__BackingField;
    internal object Message { get; }
    internal RemotingDataType DataType { get; }
    internal InformationalMessage(object message, RemotingDataType dataType);
    [CompilerGeneratedAttribute]
internal object get_Message();
    [CompilerGeneratedAttribute]
internal RemotingDataType get_DataType();
}
[DebuggerDisplayAttribute("Command = {_commandInfo}")]
public abstract class System.Management.Automation.Internal.InternalCommand : object {
    internal ICommandRuntime commandRuntime;
    [CompilerGeneratedAttribute]
private IScriptExtent <InvocationExtent>k__BackingField;
    private InvocationInfo _myInvocation;
    internal PSObject currentObjectInPipeline;
    private PSHost _CBhost;
    private SessionState _state;
    private CommandInfo _commandInfo;
    private ExecutionContext _context;
    internal CommandOrigin CommandOriginInternal;
    internal IScriptExtent InvocationExtent { get; internal set; }
    internal InvocationInfo MyInvocation { get; }
    internal PSObject CurrentPipelineObject { get; internal set; }
    internal PSHost PSHostInternal { get; }
    internal SessionState InternalState { get; }
    internal bool IsStopping { get; }
    internal CommandInfo CommandInfo { get; internal set; }
    internal ExecutionContext Context { get; internal set; }
    public CommandOrigin CommandOrigin { get; }
    [CompilerGeneratedAttribute]
internal IScriptExtent get_InvocationExtent();
    [CompilerGeneratedAttribute]
internal void set_InvocationExtent(IScriptExtent value);
    internal InvocationInfo get_MyInvocation();
    internal PSObject get_CurrentPipelineObject();
    internal void set_CurrentPipelineObject(PSObject value);
    internal PSHost get_PSHostInternal();
    internal SessionState get_InternalState();
    internal bool get_IsStopping();
    internal CommandInfo get_CommandInfo();
    internal void set_CommandInfo(CommandInfo value);
    internal ExecutionContext get_Context();
    internal void set_Context(ExecutionContext value);
    public CommandOrigin get_CommandOrigin();
    internal virtual void DoBeginProcessing();
    internal virtual void DoProcessRecord();
    internal virtual void DoEndProcessing();
    internal virtual void DoStopProcessing();
    internal virtual void DoCleanResource();
    internal void ThrowIfStopping();
    internal void InternalDispose(bool isDisposing);
}
public static class System.Management.Automation.Internal.InternalTestHooks : object {
    internal static bool BypassGroupPolicyCaching;
    internal static bool ForceScriptBlockLogging;
    internal static bool UseDebugAmsiImplementation;
    internal static bool BypassAppLockerPolicyCaching;
    internal static bool BypassOnlineHelpRetrieval;
    internal static bool ForcePromptForChoiceDefaultOption;
    internal static bool NoPromptForPassword;
    internal static bool ForceFormatListFixedLabelWidth;
    internal static bool ThrowHelpCultureNotSupported;
    internal static CultureInfo CurrentUICulture;
    internal static bool TestStopComputer;
    internal static bool TestWaitStopComputer;
    internal static bool TestRenameComputer;
    internal static int TestStopComputerResults;
    internal static int TestRenameComputerResults;
    internal static bool IgnoreScriptBlockCache;
    internal static bool StopwatchIsNotHighResolution;
    internal static bool DisableGACLoading;
    internal static bool SetConsoleWidthToZero;
    internal static bool SetConsoleHeightToZero;
    internal static bool SetMyDocumentsSpecialFolderToBlank;
    internal static bool SetDate;
    internal static string TestWindowsPowerShellPSHomeLocation;
    internal static string TestWindowsPowerShellVersionString;
    internal static bool ShowMarkdownOutputBypass;
    internal static bool ThrowExdevErrorOnMoveDirectory;
    internal static bool OneDriveTestOn;
    internal static bool OneDriveTestRecurseOn;
    internal static string OneDriveTestSymlinkName;
    private static InternalTestHooks();
    public static void SetTestHook(string property, object value);
    public static PSSenderInfo GetCustomPSSenderInfo(string url, Version clientVersion);
}
internal static class System.Management.Automation.Internal.ModuleUtils : object {
    private static int FILE_ATTRIBUTE_RECALL_ON_DATA_ACCESS;
    private static int FILE_ATTRIBUTE_RECALL_ON_OPEN;
    private static EnumerationOptions s_defaultEnumerationOptions;
    private static FileAttributes FileAttributesToSkip;
    private static EnumerationOptions s_uncPathEnumerationOptions;
    private static string EnCulturePath;
    private static string EnUsCulturePath;
    private static ModuleUtils();
    internal static bool IsPossibleResourceDirectory(string dir);
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.ModuleUtils/<GetAllAvailableModuleFiles>d__9")]
internal static IEnumerable`1<string> GetAllAvailableModuleFiles(string topDirectoryToCheck);
    internal static bool IsPSEditionCompatible(string moduleManifestPath, IEnumerable`1<string> compatiblePSEditions);
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.ModuleUtils/<GetDefaultAvailableModuleFiles>d__11")]
internal static IEnumerable`1<string> GetDefaultAvailableModuleFiles(bool isForAutoDiscovery, ExecutionContext context);
    internal static List`1<string> GetModuleFilesFromAbsolutePath(string directory);
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.ModuleUtils/<GetDefaultAvailableModuleFiles>d__13")]
internal static IEnumerable`1<string> GetDefaultAvailableModuleFiles(string topDirectoryToCheck);
    internal static List`1<Version> GetModuleVersionSubfolders(string moduleBase);
    private static bool HasSkippedFileAttribute(string path);
    private static void ProcessPossibleVersionSubdirectories(IEnumerable`1<string> subdirectories, List`1<Version> versionFolders);
    internal static bool IsModuleInVersionSubdirectory(string modulePath, Version& version);
    internal static bool IsOnSystem32ModulePath(string path);
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.ModuleUtils/<GetFuzzyMatchingCommands>d__19")]
internal static IEnumerable`1<CommandScore> GetFuzzyMatchingCommands(string pattern, ExecutionContext context, CommandOrigin commandOrigin, FuzzyMatcher fuzzyMatcher, bool rediscoverImportedModules, bool moduleVersionRequired);
    [IteratorStateMachineAttribute("System.Management.Automation.Internal.ModuleUtils/<GetMatchingCommands>d__20")]
internal static IEnumerable`1<CommandInfo> GetMatchingCommands(string pattern, ExecutionContext context, CommandOrigin commandOrigin, bool rediscoverImportedModules, bool moduleVersionRequired, FuzzyMatcher fuzzyMatcher, bool useAbbreviationExpansion);
    internal static string AbbreviateName(string commandName);
}
internal class System.Management.Automation.Internal.ObjectReader : ObjectReaderBase`1<object> {
    public ObjectReader(ObjectStream stream);
    public virtual Collection`1<object> Read(int count);
    public virtual object Read();
    public virtual Collection`1<object> ReadToEnd();
    public virtual Collection`1<object> NonBlockingRead();
    public virtual Collection`1<object> NonBlockingRead(int maxRequested);
    public virtual object Peek();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Management.Automation.Internal.ObjectReaderBase`1 : PipelineReader`1<T> {
    [CompilerGeneratedAttribute]
private EventHandler InternalDataReady;
    protected ObjectStreamBase _stream;
    private object _monitorObject;
    public WaitHandle WaitHandle { get; }
    public bool EndOfPipeline { get; }
    public bool IsOpen { get; }
    public int Count { get; }
    public int MaxCapacity { get; }
    protected ObjectReaderBase`1(ObjectStreamBase stream);
    public virtual void add_DataReady(EventHandler value);
    public virtual void remove_DataReady(EventHandler value);
    [CompilerGeneratedAttribute]
public void add_InternalDataReady(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_InternalDataReady(EventHandler value);
    public virtual WaitHandle get_WaitHandle();
    public virtual bool get_EndOfPipeline();
    public virtual bool get_IsOpen();
    public virtual int get_Count();
    public virtual int get_MaxCapacity();
    public virtual void Close();
    private void OnDataReady(object sender, EventArgs args);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Internal.ObjectStream : ObjectStreamBase {
    private List`1<object> _objects;
    private bool _isOpen;
    private AutoResetEvent _readHandle;
    private ManualResetEvent _readWaitHandle;
    private ManualResetEvent _readClosedHandle;
    private AutoResetEvent _writeHandle;
    private ManualResetEvent _writeWaitHandle;
    private ManualResetEvent _writeClosedHandle;
    private PipelineReader`1<object> _reader;
    private PipelineReader`1<PSObject> _mshreader;
    private PipelineWriter _writer;
    private int _capacity;
    private object _monitorObject;
    private bool _disposed;
    internal int MaxCapacity { get; }
    internal WaitHandle ReadHandle { get; }
    internal WaitHandle WriteHandle { get; }
    internal PipelineReader`1<object> ObjectReader { get; }
    internal PipelineReader`1<PSObject> PSObjectReader { get; }
    internal PipelineWriter ObjectWriter { get; }
    internal bool EndOfPipeline { get; }
    internal bool IsOpen { get; }
    internal int Count { get; }
    internal ObjectStream(int capacity);
    internal virtual int get_MaxCapacity();
    internal virtual WaitHandle get_ReadHandle();
    internal virtual WaitHandle get_WriteHandle();
    internal virtual PipelineReader`1<object> get_ObjectReader();
    internal virtual PipelineReader`1<PSObject> get_PSObjectReader();
    internal virtual PipelineWriter get_ObjectWriter();
    internal virtual bool get_EndOfPipeline();
    internal virtual bool get_IsOpen();
    internal virtual int get_Count();
    private bool WaitRead();
    private bool WaitWrite();
    private void RaiseEvents();
    internal virtual void Flush();
    internal virtual void Close();
    internal virtual object Read();
    internal virtual Collection`1<object> Read(int count);
    internal virtual Collection`1<object> ReadToEnd();
    internal virtual Collection`1<object> NonBlockingRead(int maxRequested);
    internal virtual object Peek();
    internal virtual int Write(object obj, bool enumerateCollection);
    private void DFT_AddHandler_OnDataReady(EventHandler eventHandler);
    private void DFT_RemoveHandler_OnDataReady(EventHandler eventHandler);
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Management.Automation.Internal.ObjectStreamBase : object {
    [CompilerGeneratedAttribute]
private EventHandler DataReady;
    internal int MaxCapacity { get; }
    internal WaitHandle ReadHandle { get; }
    internal WaitHandle WriteHandle { get; }
    internal bool EndOfPipeline { get; }
    internal bool IsOpen { get; }
    internal int Count { get; }
    internal PipelineReader`1<object> ObjectReader { get; }
    internal PipelineReader`1<PSObject> PSObjectReader { get; }
    internal PipelineWriter ObjectWriter { get; }
    [CompilerGeneratedAttribute]
internal void add_DataReady(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DataReady(EventHandler value);
    internal void FireDataReadyEvent(object source, EventArgs args);
    internal abstract virtual int get_MaxCapacity();
    internal virtual WaitHandle get_ReadHandle();
    internal virtual WaitHandle get_WriteHandle();
    internal abstract virtual bool get_EndOfPipeline();
    internal abstract virtual bool get_IsOpen();
    internal abstract virtual int get_Count();
    internal abstract virtual PipelineReader`1<object> get_ObjectReader();
    internal abstract virtual PipelineReader`1<PSObject> get_PSObjectReader();
    internal abstract virtual PipelineWriter get_ObjectWriter();
    internal virtual object Read();
    internal virtual Collection`1<object> Read(int count);
    internal virtual Collection`1<object> ReadToEnd();
    internal virtual Collection`1<object> NonBlockingRead(int maxRequested);
    internal virtual object Peek();
    internal virtual int Write(object value);
    internal virtual int Write(object obj, bool enumerateCollection);
    internal virtual void Close();
    internal virtual void Flush();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Internal.ObjectWriter : PipelineWriter {
    private ObjectStreamBase _stream;
    public WaitHandle WaitHandle { get; }
    public bool IsOpen { get; }
    public int Count { get; }
    public int MaxCapacity { get; }
    public ObjectWriter(ObjectStreamBase stream);
    public virtual WaitHandle get_WaitHandle();
    public virtual bool get_IsOpen();
    public virtual int get_Count();
    public virtual int get_MaxCapacity();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Write(object obj);
    public virtual int Write(object obj, bool enumerateCollection);
}
[AttributeUsageAttribute("32767")]
public abstract class System.Management.Automation.Internal.ParsingBaseAttribute : CmdletMetadataAttribute {
}
internal class System.Management.Automation.Internal.Pipe : object {
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private PipelineProcessor <PipelineProcessor>k__BackingField;
    private CommandProcessorBase _downstreamCmdlet;
    [CompilerGeneratedAttribute]
private PipelineReader`1<object> <ExternalReader>k__BackingField;
    private PipelineWriter _externalWriter;
    [CompilerGeneratedAttribute]
private int <OutBufferCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreOutVariableList>k__BackingField;
    private bool _nullPipe;
    [CompilerGeneratedAttribute]
private Queue`1<object> <ObjectQueue>k__BackingField;
    private bool _isRedirected;
    private List`1<IList> _outVariableList;
    private List`1<IList> _errorVariableList;
    private List`1<IList> _warningVariableList;
    private List`1<IList> _informationVariableList;
    private PSVariable _pipelineVariableObject;
    private List`1<object> _resultList;
    private Collection`1<PSObject> _resultCollection;
    private IEnumerator _enumeratorToProcess;
    private bool _enumeratorToProcessIsEmpty;
    internal PipelineProcessor PipelineProcessor { get; }
    internal CommandProcessorBase DownstreamCmdlet { get; internal set; }
    internal PipelineReader`1<object> ExternalReader { get; internal set; }
    internal PipelineWriter ExternalWriter { get; internal set; }
    internal int OutBufferCount { get; internal set; }
    internal bool IgnoreOutVariableList { get; internal set; }
    internal bool NullPipe { get; internal set; }
    internal Queue`1<object> ObjectQueue { get; }
    internal bool Empty { get; }
    internal bool IsRedirected { get; }
    internal Pipe(List`1<object> resultList);
    internal Pipe(Collection`1<PSObject> resultCollection);
    internal Pipe(ExecutionContext context, PipelineProcessor outputPipeline);
    internal Pipe(IEnumerator enumeratorToProcess);
    [CompilerGeneratedAttribute]
internal PipelineProcessor get_PipelineProcessor();
    internal CommandProcessorBase get_DownstreamCmdlet();
    internal void set_DownstreamCmdlet(CommandProcessorBase value);
    [CompilerGeneratedAttribute]
internal PipelineReader`1<object> get_ExternalReader();
    [CompilerGeneratedAttribute]
internal void set_ExternalReader(PipelineReader`1<object> value);
    internal PipelineWriter get_ExternalWriter();
    internal void set_ExternalWriter(PipelineWriter value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal int get_OutBufferCount();
    [CompilerGeneratedAttribute]
internal void set_OutBufferCount(int value);
    [CompilerGeneratedAttribute]
internal bool get_IgnoreOutVariableList();
    [CompilerGeneratedAttribute]
internal void set_IgnoreOutVariableList(bool value);
    internal bool get_NullPipe();
    internal void set_NullPipe(bool value);
    [CompilerGeneratedAttribute]
internal Queue`1<object> get_ObjectQueue();
    internal bool get_Empty();
    internal bool get_IsRedirected();
    private static void AddToVarList(List`1<IList> varList, object obj);
    internal void AppendVariableList(VariableStreamKind kind, object obj);
    internal void AddVariableList(VariableStreamKind kind, IList list);
    internal void SetPipelineVariable(PSVariable pipelineVariable);
    internal void RemoveVariableList(VariableStreamKind kind, IList list);
    internal void RemovePipelineVariable();
    internal void SetVariableListForTemporaryPipe(Pipe tempPipe);
    private static void CopyVariableToTempPipe(VariableStreamKind streamKind, List`1<IList> variableList, Pipe tempPipe);
    internal void Add(object obj);
    internal void AddWithoutAppendingOutVarList(object obj);
    private void AddToPipe(object obj);
    internal void AddItems(object objects);
    internal object Retrieve();
    internal void Clear();
    internal Object[] ToArray();
}
internal class System.Management.Automation.Internal.PipelineProcessor : object {
    private List`1<CommandProcessorBase> _commands;
    private List`1<PipelineProcessor> _redirectionPipes;
    private PipelineReader`1<object> _externalInputPipe;
    private PipelineWriter _externalSuccessOutput;
    private PipelineWriter _externalErrorOutput;
    private bool _executionStarted;
    private bool _stopping;
    private SessionStateScope _executionScope;
    private ExceptionDispatchInfo _firstTerminatingError;
    private bool _linkedSuccessOutput;
    private bool _linkedErrorOutput;
    private NativeCommandProcessor _lastNativeCommand;
    private bool _haveReportedNativePipeUsage;
    private bool _disposed;
    private bool _executionFailed;
    private bool _terminatingErrorLogged;
    private bool _needToLog;
    private List`1<string> _eventLogBuffer;
    private object _stopReasonLock;
    internal InternalCommand _permittedToWrite;
    internal bool _permittedToWriteToPipeline;
    internal Thread _permittedToWriteThread;
    private LocalPipeline _localPipeline;
    [CompilerGeneratedAttribute]
private bool <TopLevel>k__BackingField;
    internal List`1<CommandProcessorBase> Commands { get; }
    internal bool ExecutionFailed { get; internal set; }
    internal PipelineReader`1<object> ExternalInput { get; internal set; }
    internal PipelineWriter ExternalSuccessOutput { get; internal set; }
    internal PipelineWriter ExternalErrorOutput { get; internal set; }
    internal bool ExecutionStarted { get; }
    internal bool Stopping { get; }
    internal LocalPipeline LocalPipeline { get; internal set; }
    internal bool TopLevel { get; internal set; }
    internal SessionStateScope ExecutionScope { get; internal set; }
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    internal List`1<CommandProcessorBase> get_Commands();
    internal bool get_ExecutionFailed();
    internal void set_ExecutionFailed(bool value);
    internal void LogExecutionInfo(InvocationInfo invocationInfo, string text);
    internal void LogExecutionComplete(InvocationInfo invocationInfo, string text);
    internal void LogPipelineComplete();
    internal void LogExecutionParameterBinding(InvocationInfo invocationInfo, string parameterName, string parameterValue);
    internal void LogExecutionError(InvocationInfo invocationInfo, ErrorRecord errorRecord);
    internal void LogExecutionException(Exception exception);
    private static string GetCommand(InvocationInfo invocationInfo);
    private static string GetCommand(Exception exception);
    private void Log(string logElement, InvocationInfo invocation, PipelineExecutionStatus pipelineExecutionStatus);
    private void LogToEventLog();
    internal int Add(CommandProcessorBase commandProcessor);
    internal void AddRedirectionPipe(PipelineProcessor pipelineProcessor);
    private int AddCommand(CommandProcessorBase commandProcessor, int readFromCommand, bool readErrorQueue);
    internal Array SynchronousExecuteEnumerate(object input);
    private ExceptionDispatchInfo GetFirstError(RuntimeException e);
    private void ThrowFirstErrorIfExisting(bool logException);
    private void DoCompleteCore(CommandProcessorBase commandRequestingUpstreamCommandsToStop);
    private void Clean();
    internal void DoCleanup();
    internal Array DoComplete();
    internal void StartStepping(bool expectInput);
    internal void Stop();
    internal Array Step(object input);
    private void Start(bool incomingStream);
    private void SetExternalErrorOutput();
    private void SetupParameterVariables();
    private static void ValidateCommandProcessorNotNull(CommandProcessorBase commandProcessor, string errorMessage);
    private void Inject(object input, bool enumerate);
    private Array RetrieveResults();
    internal void LinkPipelineSuccessOutput(Pipe pipeToUse);
    internal void LinkPipelineErrorOutput(Pipe pipeToUse);
    private void DisposeCommands();
    internal bool RecordFailure(Exception e, InternalCommand command);
    internal void ForgetFailure();
    internal PipelineReader`1<object> get_ExternalInput();
    internal void set_ExternalInput(PipelineReader`1<object> value);
    internal PipelineWriter get_ExternalSuccessOutput();
    internal void set_ExternalSuccessOutput(PipelineWriter value);
    internal PipelineWriter get_ExternalErrorOutput();
    internal void set_ExternalErrorOutput(PipelineWriter value);
    internal bool get_ExecutionStarted();
    internal bool get_Stopping();
    internal LocalPipeline get_LocalPipeline();
    internal void set_LocalPipeline(LocalPipeline value);
    [CompilerGeneratedAttribute]
internal bool get_TopLevel();
    [CompilerGeneratedAttribute]
internal void set_TopLevel(bool value);
    internal SessionStateScope get_ExecutionScope();
    internal void set_ExecutionScope(SessionStateScope value);
}
internal static class System.Management.Automation.Internal.PowerShellModuleAssemblyAnalyzer : object {
    internal static BinaryAnalysisResult AnalyzeModuleAssembly(string path, Version& assemblyVersion);
}
internal enum System.Management.Automation.Internal.PSChannel : Enum {
    public byte value__;
    public static PSChannel Operational;
    public static PSChannel Analytic;
}
internal class System.Management.Automation.Internal.PSCryptoException : Exception {
    private UInt32 _errorCode;
    internal UInt32 ErrorCode { get; }
    public PSCryptoException(UInt32 errorCode, StringBuilder message);
    public PSCryptoException(string message);
    public PSCryptoException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSCryptoException(SerializationInfo info, StreamingContext context);
    internal UInt32 get_ErrorCode();
}
internal static class System.Management.Automation.Internal.PSCryptoNativeConverter : object {
    public static UInt32 CUR_BLOB_VERSION;
    public static UInt32 CALG_RSA_KEYX;
    public static UInt32 CALG_AES_256;
    public static UInt32 PUBLICKEYBLOB;
    public static int PUBLICKEYBLOB_HEADER_LEN;
    public static UInt32 SIMPLEBLOB;
    public static int SIMPLEBLOB_HEADER_LEN;
    private static int ToInt32LE(Byte[] bytes, int offset);
    private static UInt32 ToUInt32LE(Byte[] bytes, int offset);
    private static Byte[] GetBytesLE(int val);
    private static Byte[] CreateReverseByteArray(Byte[] data);
    internal static RSA FromCapiPublicKeyBlob(Byte[] blob);
    private static RSA FromCapiPublicKeyBlob(Byte[] blob, int offset);
    private static RSAParameters GetParametersFromCapiPublicKeyBlob(Byte[] blob, int offset);
    internal static Byte[] ToCapiPublicKeyBlob(RSA rsa);
    internal static Byte[] FromCapiSimpleKeyBlob(Byte[] blob);
    internal static Byte[] ToCapiSimpleKeyBlob(Byte[] encryptedKey);
}
internal class System.Management.Automation.Internal.PSDataCollectionPipelineReader`2 : ObjectReaderBase`1<TReturn> {
    private PSDataCollection`1<T> _datastore;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RunspaceId>k__BackingField;
    internal string ComputerName { get; }
    internal Guid RunspaceId { get; }
    internal PSDataCollectionPipelineReader`2(PSDataCollectionStream`1<T> stream, string computerName, Guid runspaceId);
    [CompilerGeneratedAttribute]
internal string get_ComputerName();
    [CompilerGeneratedAttribute]
internal Guid get_RunspaceId();
    public virtual Collection`1<TReturn> Read(int count);
    public virtual TReturn Read();
    public virtual Collection`1<TReturn> ReadToEnd();
    public virtual Collection`1<TReturn> NonBlockingRead();
    public virtual Collection`1<TReturn> NonBlockingRead(int maxRequested);
    public virtual TReturn Peek();
    private static TReturn ConvertToReturnType(object inputObject);
    protected virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Internal.PSDataCollectionReader`2 : ObjectReaderBase`1<TResult> {
    private PSDataCollectionEnumerator`1<T> _enumerator;
    public PSDataCollectionReader`2(PSDataCollectionStream`1<T> stream);
    public virtual Collection`1<TResult> Read(int count);
    public virtual TResult Read();
    public virtual Collection`1<TResult> ReadToEnd();
    public virtual Collection`1<TResult> NonBlockingRead();
    public virtual Collection`1<TResult> NonBlockingRead(int maxRequested);
    public virtual TResult Peek();
    protected virtual void Dispose(bool disposing);
    private static TResult ConvertToReturnType(object inputObject);
}
internal class System.Management.Automation.Internal.PSDataCollectionStream`1 : ObjectStreamBase {
    private PSDataCollection`1<T> _objects;
    private Guid _psInstanceId;
    private bool _isOpen;
    private PipelineWriter _writer;
    private PipelineReader`1<object> _objectReader;
    private PipelineReader`1<PSObject> _psobjectReader;
    private PipelineReader`1<object> _objectReaderForPipeline;
    private PipelineReader`1<PSObject> _psobjectReaderForPipeline;
    private object _syncObject;
    private bool _disposed;
    internal PSDataCollection`1<T> ObjectStore { get; }
    internal int Count { get; }
    internal bool EndOfPipeline { get; }
    internal bool IsOpen { get; }
    internal int MaxCapacity { get; }
    internal PipelineReader`1<object> ObjectReader { get; }
    internal PipelineReader`1<PSObject> PSObjectReader { get; }
    internal PipelineWriter ObjectWriter { get; }
    internal WaitHandle ReadHandle { get; }
    internal PSDataCollectionStream`1(Guid psInstanceId, PSDataCollection`1<T> storeToUse);
    internal PSDataCollection`1<T> get_ObjectStore();
    internal virtual int get_Count();
    internal virtual bool get_EndOfPipeline();
    internal virtual bool get_IsOpen();
    internal virtual int get_MaxCapacity();
    internal virtual PipelineReader`1<object> get_ObjectReader();
    internal PipelineReader`1<object> GetObjectReaderForPipeline(string computerName, Guid runspaceId);
    internal virtual PipelineReader`1<PSObject> get_PSObjectReader();
    internal PipelineReader`1<PSObject> GetPSObjectReaderForPipeline(string computerName, Guid runspaceId);
    internal virtual PipelineWriter get_ObjectWriter();
    internal virtual WaitHandle get_ReadHandle();
    internal virtual int Write(object obj, bool enumerateCollection);
    internal virtual void Close();
    private void HandleClosed(object sender, EventArgs e);
    private void HandleDataAdded(object sender, DataAddedEventArgs e);
    protected virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Internal.PSDataCollectionWriter`1 : ObjectWriter {
    public PSDataCollectionWriter`1(PSDataCollectionStream`1<T> stream);
}
public class System.Management.Automation.Internal.PSEmbeddedMonitorRunspaceInfo : PSMonitorRunspaceInfo {
    [CompilerGeneratedAttribute]
private PowerShell <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentDebuggerId>k__BackingField;
    public PowerShell Command { get; }
    public Guid ParentDebuggerId { get; private set; }
    public PSEmbeddedMonitorRunspaceInfo(Runspace runspace, PSMonitorRunspaceType runspaceType, PowerShell command, Guid parentDebuggerId);
    [CompilerGeneratedAttribute]
public PowerShell get_Command();
    [CompilerGeneratedAttribute]
public Guid get_ParentDebuggerId();
    [CompilerGeneratedAttribute]
private void set_ParentDebuggerId(Guid value);
    internal virtual PSMonitorRunspaceInfo Copy();
    internal virtual NestedRunspaceDebugger CreateDebugger(Debugger rootDebugger);
}
internal class System.Management.Automation.Internal.PSETWBinaryBlob : object {
    public Byte[] blob;
    public int offset;
    public int length;
    public PSETWBinaryBlob(Byte[] blob, int offset, int length);
}
internal enum System.Management.Automation.Internal.PSEventId : Enum {
    public int value__;
    public static PSEventId HostNameResolve;
    public static PSEventId SchemeResolve;
    public static PSEventId ShellResolve;
    public static PSEventId RunspaceConstructor;
    public static PSEventId RunspacePoolConstructor;
    public static PSEventId RunspacePoolOpen;
    public static PSEventId OperationalTransferEventRunspacePool;
    public static PSEventId RunspaceStateChange;
    public static PSEventId RetrySessionCreation;
    public static PSEventId Port;
    public static PSEventId AppName;
    public static PSEventId ComputerName;
    public static PSEventId Scheme;
    public static PSEventId TestAnalytic;
    public static PSEventId WSManConnectionInfoDump;
    public static PSEventId AnalyticTransferEventRunspacePool;
    public static PSEventId TransportReceivedObject;
    public static PSEventId TransportSendingData;
    public static PSEventId TransportReceivedData;
    public static PSEventId AppDomainUnhandledException_Analytic;
    public static PSEventId TransportError_Analytic;
    public static PSEventId AppDomainUnhandledException;
    public static PSEventId TransportError;
    public static PSEventId WSManCreateShell;
    public static PSEventId WSManCreateShellCallbackReceived;
    public static PSEventId WSManCloseShell;
    public static PSEventId WSManCloseShellCallbackReceived;
    public static PSEventId WSManSendShellInputEx;
    public static PSEventId WSManSendShellInputExCallbackReceived;
    public static PSEventId WSManReceiveShellOutputEx;
    public static PSEventId WSManReceiveShellOutputExCallbackReceived;
    public static PSEventId WSManCreateCommand;
    public static PSEventId WSManCreateCommandCallbackReceived;
    public static PSEventId WSManCloseCommand;
    public static PSEventId WSManCloseCommandCallbackReceived;
    public static PSEventId WSManSignal;
    public static PSEventId WSManSignalCallbackReceived;
    public static PSEventId URIRedirection;
    public static PSEventId ServerSendData;
    public static PSEventId ServerCreateRemoteSession;
    public static PSEventId ReportContext;
    public static PSEventId ReportOperationComplete;
    public static PSEventId ServerCreateCommandSession;
    public static PSEventId ServerStopCommand;
    public static PSEventId ServerReceivedData;
    public static PSEventId ServerClientReceiveRequest;
    public static PSEventId ServerCloseOperation;
    public static PSEventId LoadingPSCustomShellAssembly;
    public static PSEventId LoadingPSCustomShellType;
    public static PSEventId ReceivedRemotingFragment;
    public static PSEventId SentRemotingFragment;
    public static PSEventId WSManPluginShutdown;
    public static PSEventId Serializer_RehydrationSuccess;
    public static PSEventId Serializer_RehydrationFailure;
    public static PSEventId Serializer_DepthOverride;
    public static PSEventId Serializer_ModeOverride;
    public static PSEventId Serializer_ScriptPropertyWithoutRunspace;
    public static PSEventId Serializer_PropertyGetterFailed;
    public static PSEventId Serializer_EnumerationFailed;
    public static PSEventId Serializer_ToStringFailed;
    public static PSEventId Serializer_MaxDepthWhenSerializing;
    public static PSEventId Serializer_XmlExceptionWhenDeserializing;
    public static PSEventId Serializer_SpecificPropertyMissing;
    public static PSEventId Perftrack_ConsoleStartupStart;
    public static PSEventId Perftrack_ConsoleStartupStop;
    public static PSEventId Command_Health;
    public static PSEventId Engine_Health;
    public static PSEventId Provider_Health;
    public static PSEventId Pipeline_Detail;
    public static PSEventId ScriptBlock_Compile_Detail;
    public static PSEventId ScriptBlock_Invoke_Start_Detail;
    public static PSEventId ScriptBlock_Invoke_Complete_Detail;
    public static PSEventId Command_Lifecycle;
    public static PSEventId Engine_Lifecycle;
    public static PSEventId Provider_Lifecycle;
    public static PSEventId Settings;
    public static PSEventId Engine_Trace;
    public static PSEventId Amsi_Init;
    public static PSEventId WDAC_Query;
    public static PSEventId WDAC_Audit;
    public static PSEventId ExperimentalFeature_InvalidName;
    public static PSEventId ExperimentalFeature_ReadConfig_Error;
    public static PSEventId ScheduledJob_Start;
    public static PSEventId ScheduledJob_Complete;
    public static PSEventId ScheduledJob_Error;
    public static PSEventId NamedPipeIPC_ServerListenerStarted;
    public static PSEventId NamedPipeIPC_ServerListenerEnded;
    public static PSEventId NamedPipeIPC_ServerListenerError;
    public static PSEventId NamedPipeIPC_ServerConnect;
    public static PSEventId NamedPipeIPC_ServerDisconnect;
    public static PSEventId ISEExecuteScript;
    public static PSEventId ISEExecuteSelection;
    public static PSEventId ISEStopCommand;
    public static PSEventId ISEResumeDebugger;
    public static PSEventId ISEStopDebugger;
    public static PSEventId ISEDebuggerStepInto;
    public static PSEventId ISEDebuggerStepOver;
    public static PSEventId ISEDebuggerStepOut;
    public static PSEventId ISEEnableAllBreakpoints;
    public static PSEventId ISEDisableAllBreakpoints;
    public static PSEventId ISERemoveAllBreakpoints;
    public static PSEventId ISESetBreakpoint;
    public static PSEventId ISERemoveBreakpoint;
    public static PSEventId ISEEnableBreakpoint;
    public static PSEventId ISEDisableBreakpoint;
    public static PSEventId ISEHitBreakpoint;
}
internal enum System.Management.Automation.Internal.PSEventVersion : Enum {
    public byte value__;
    public static PSEventVersion One;
}
[FlagsAttribute]
internal enum System.Management.Automation.Internal.PSKeyword : Enum {
    public ulong value__;
    public static PSKeyword Runspace;
    public static PSKeyword Pipeline;
    public static PSKeyword Protocol;
    public static PSKeyword Transport;
    public static PSKeyword Host;
    public static PSKeyword Cmdlets;
    public static PSKeyword Serializer;
    public static PSKeyword Session;
    public static PSKeyword ManagedPlugin;
    public static PSKeyword UseAlwaysOperational;
    public static PSKeyword UseAlwaysAnalytic;
}
internal enum System.Management.Automation.Internal.PSLevel : Enum {
    public byte value__;
    public static PSLevel LogAlways;
    public static PSLevel Critical;
    public static PSLevel Error;
    public static PSLevel Warning;
    public static PSLevel Informational;
    public static PSLevel Verbose;
    public static PSLevel Debug;
}
public abstract class System.Management.Automation.Internal.PSMonitorRunspaceInfo : object {
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    [CompilerGeneratedAttribute]
private PSMonitorRunspaceType <RunspaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private NestedRunspaceDebugger <NestedDebugger>k__BackingField;
    public Runspace Runspace { get; }
    public PSMonitorRunspaceType RunspaceType { get; }
    internal NestedRunspaceDebugger NestedDebugger { get; internal set; }
    protected PSMonitorRunspaceInfo(Runspace runspace, PSMonitorRunspaceType runspaceType);
    [CompilerGeneratedAttribute]
public Runspace get_Runspace();
    [CompilerGeneratedAttribute]
public PSMonitorRunspaceType get_RunspaceType();
    [CompilerGeneratedAttribute]
internal NestedRunspaceDebugger get_NestedDebugger();
    [CompilerGeneratedAttribute]
internal void set_NestedDebugger(NestedRunspaceDebugger value);
    internal abstract virtual PSMonitorRunspaceInfo Copy();
    internal abstract virtual NestedRunspaceDebugger CreateDebugger(Debugger rootDebugger);
}
public enum System.Management.Automation.Internal.PSMonitorRunspaceType : Enum {
    public int value__;
    public static PSMonitorRunspaceType Standalone;
    public static PSMonitorRunspaceType InvokeCommand;
}
internal class System.Management.Automation.Internal.PSObjectReader : ObjectReaderBase`1<PSObject> {
    public PSObjectReader(ObjectStream stream);
    public virtual Collection`1<PSObject> Read(int count);
    public virtual PSObject Read();
    public virtual Collection`1<PSObject> ReadToEnd();
    public virtual Collection`1<PSObject> NonBlockingRead();
    public virtual Collection`1<PSObject> NonBlockingRead(int maxRequested);
    public virtual PSObject Peek();
    protected virtual void Dispose(bool disposing);
    private static PSObject MakePSObject(object o);
    private static Collection`1<PSObject> MakePSObjectCollection(Collection`1<object> coll);
}
internal enum System.Management.Automation.Internal.PSOpcode : Enum {
    public byte value__;
    public static PSOpcode WinStart;
    public static PSOpcode WinStop;
    public static PSOpcode Open;
    public static PSOpcode Close;
    public static PSOpcode Connect;
    public static PSOpcode Disconnect;
    public static PSOpcode Negotiate;
    public static PSOpcode Create;
    public static PSOpcode Constructor;
    public static PSOpcode Dispose;
    public static PSOpcode EventHandler;
    public static PSOpcode Exception;
    public static PSOpcode Method;
    public static PSOpcode Send;
    public static PSOpcode Receive;
    public static PSOpcode Rehydration;
    public static PSOpcode SerializationSettings;
    public static PSOpcode ShuttingDown;
}
public abstract class System.Management.Automation.Internal.PSRemotingCryptoHelper : object {
    internal PSRSACryptoServiceProvider _rsaCryptoProvider;
    protected ManualResetEvent _keyExchangeCompleted;
    protected object syncObject;
    private bool _keyExchangeStarted;
    internal RemoteSession Session { get; internal set; }
    protected void RunKeyExchangeIfRequired();
    protected string EncryptSecureStringCore(SecureString secureString);
    protected SecureString DecryptSecureStringCore(string encryptedString);
    internal abstract virtual string EncryptSecureString(SecureString secureString);
    internal abstract virtual SecureString DecryptSecureString(string encryptedString);
    internal abstract virtual RemoteSession get_Session();
    internal abstract virtual void set_Session(RemoteSession value);
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    internal void CompleteKeyExchange();
}
internal class System.Management.Automation.Internal.PSRemotingCryptoHelperClient : PSRemotingCryptoHelper {
    [CompilerGeneratedAttribute]
private RemoteSession <Session>k__BackingField;
    internal RemoteSession Session { get; internal set; }
    internal virtual string EncryptSecureString(SecureString secureString);
    internal virtual SecureString DecryptSecureString(string encryptedString);
    internal bool ExportLocalPublicKey(String& publicKeyAsString);
    internal bool ImportEncryptedSessionKey(string encryptedSessionKey);
    [CompilerGeneratedAttribute]
internal virtual RemoteSession get_Session();
    [CompilerGeneratedAttribute]
internal virtual void set_Session(RemoteSession value);
    internal static PSRemotingCryptoHelperClient GetTestRemotingCryptHelperClient();
}
internal class System.Management.Automation.Internal.PSRemotingCryptoHelperServer : PSRemotingCryptoHelper {
    private RemoteSession _session;
    internal RemoteSession Session { get; internal set; }
    internal virtual string EncryptSecureString(SecureString secureString);
    internal virtual SecureString DecryptSecureString(string encryptedString);
    internal bool ImportRemotePublicKey(string publicKeyAsString);
    internal virtual RemoteSession get_Session();
    internal virtual void set_Session(RemoteSession value);
    internal bool ExportEncryptedSessionKey(String& encryptedSessionKey);
    internal static PSRemotingCryptoHelperServer GetTestRemotingCryptHelperServer();
}
internal class System.Management.Automation.Internal.PSRSACryptoServiceProvider : object {
    private RSA _rsa;
    private Aes _aes;
    private bool _canEncrypt;
    private bool _sessionKeyGenerated;
    private static object s_syncObject;
    internal bool CanEncrypt { get; internal set; }
    private PSRSACryptoServiceProvider(bool serverMode);
    private static PSRSACryptoServiceProvider();
    internal string GetPublicKeyAsBase64EncodedString();
    internal void GenerateSessionKey();
    internal string SafeExportSessionKey();
    internal void ImportPublicKeyFromBase64EncodedString(string publicKey);
    internal void ImportSessionKeyFromBase64EncodedString(string sessionKey);
    internal Byte[] EncryptWithSessionKey(Byte[] data);
    internal Byte[] DecryptWithSessionKey(Byte[] data);
    internal void GenerateKeyPair();
    internal bool get_CanEncrypt();
    internal void set_CanEncrypt(bool value);
    internal static PSRSACryptoServiceProvider GetRSACryptoServiceProviderForClient();
    internal static PSRSACryptoServiceProvider GetRSACryptoServiceProviderForServer();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class System.Management.Automation.Internal.PSStandaloneMonitorRunspaceInfo : PSMonitorRunspaceInfo {
    public PSStandaloneMonitorRunspaceInfo(Runspace runspace);
    internal virtual PSMonitorRunspaceInfo Copy();
    internal virtual NestedRunspaceDebugger CreateDebugger(Debugger rootDebugger);
}
internal enum System.Management.Automation.Internal.PSTask : Enum {
    public int value__;
    public static PSTask None;
    public static PSTask CreateRunspace;
    public static PSTask ExecuteCommand;
    public static PSTask Serialization;
    public static PSTask PowershellConsoleStartup;
    public static PSTask EngineStart;
    public static PSTask EngineStop;
    public static PSTask CommandStart;
    public static PSTask CommandStop;
    public static PSTask ProviderStart;
    public static PSTask ProviderStop;
    public static PSTask ExecutePipeline;
    public static PSTask ExperimentalFeature;
    public static PSTask ScheduledJob;
    public static PSTask NamedPipe;
    public static PSTask ISEOperation;
    public static PSTask Amsi;
    public static PSTask WDAC;
    public static PSTask WDACAudit;
}
internal class System.Management.Automation.Internal.PSTransactionManager : object {
    internal bool HasTransaction { get; }
    internal bool IsLastTransactionCommitted { get; }
    internal bool IsLastTransactionRolledBack { get; }
    internal RollbackSeverity RollbackPreference { get; }
    internal bool get_HasTransaction();
    internal bool get_IsLastTransactionCommitted();
    internal bool get_IsLastTransactionRolledBack();
    internal RollbackSeverity get_RollbackPreference();
    internal static IDisposable GetEngineProtectionScope();
    internal void Rollback(bool suppressErrors);
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.Internal.ReadOnlyBag`1 : object {
    private HashSet`1<T> _hashset;
    internal static ReadOnlyBag`1<T> Empty;
    public int Count { get; }
    public bool IsReadOnly { get; }
    internal ReadOnlyBag`1(HashSet`1<T> hashset);
    private static ReadOnlyBag`1();
    public int get_Count();
    public bool get_IsReadOnly();
    public bool Contains(T item);
    public sealed virtual IEnumerator GetEnumerator();
}
internal static class System.Management.Automation.Internal.Requires : object {
    internal static void NotNullOrEmpty(ICollection value, string paramName);
}
internal class System.Management.Automation.Internal.RobustConnectionProgress : object {
    private PSHost _psHost;
    private string _activity;
    private string _status;
    private int _secondsTotal;
    private int _secondsRemaining;
    private ProgressRecord _progressRecord;
    private long _sourceId;
    private bool _progressIsRunning;
    private object _syncObject;
    private Timer _updateTimer;
    public void StartProgress(long sourceId, string computerName, int secondsTotal, PSHost psHost);
    public void StopProgress(long sourceId);
    private void UpdateCallback(object state);
    private void RemoveProgressBar();
}
internal enum System.Management.Automation.Internal.SaferPolicy : Enum {
    public int value__;
    public static SaferPolicy ExplicitlyAllowed;
    public static SaferPolicy Allowed;
    public static SaferPolicy Disallowed;
}
public class System.Management.Automation.Internal.ScriptBlockMemberMethodWrapper : object {
    public static Object[] _emptyArgumentArray;
    private bool _isStatic;
    private SessionStateKeeper _sessionStateKeeper;
    private WeakReference`1<SessionStateInternal> _defaultSessionStateToUse;
    private IParameterMetadataProvider _ast;
    private Lazy`1<ScriptBlock> _scriptBlock;
    private ThreadLocal`1<ScriptBlock> _boundScriptBlock;
    internal ScriptBlockMemberMethodWrapper(IParameterMetadataProvider ast, SessionStateKeeper sessionStateKeeper);
    internal ScriptBlockMemberMethodWrapper(IParameterMetadataProvider ast);
    private static ScriptBlockMemberMethodWrapper();
    internal void InitAtRuntime();
    private void PrepareScriptBlockToInvoke(object instance, object sessionStateInternal);
    public void InvokeHelper(object instance, object sessionStateInternal, Object[] args);
    public T InvokeHelperT(object instance, object sessionStateInternal, Object[] args);
    [CompilerGeneratedAttribute]
private ScriptBlock <.ctor>b__8_0();
    [CompilerGeneratedAttribute]
private ScriptBlock <.ctor>b__8_1();
}
public static class System.Management.Automation.Internal.SecuritySupport : object {
    private static Nullable`1<bool> _hasGpScriptParent;
    private static bool _saferIdentifyLevelApiSupported;
    internal static ExecutionPolicyScope[] ExecutionPolicyScopePreferences { get; }
    private static bool HasGpScriptParent { get; }
    private static SecuritySupport();
    internal static ExecutionPolicyScope[] get_ExecutionPolicyScopePreferences();
    internal static void SetExecutionPolicy(ExecutionPolicyScope scope, ExecutionPolicy policy, string shellId);
    internal static ExecutionPolicy GetExecutionPolicy(string shellId);
    private static bool get_HasGpScriptParent();
    private static bool IsCurrentProcessLaunchedByGpScript();
    internal static ExecutionPolicy GetExecutionPolicy(string shellId, ExecutionPolicyScope scope);
    internal static ExecutionPolicy ParseExecutionPolicy(string policy);
    internal static string GetExecutionPolicy(ExecutionPolicy policy);
    public static bool IsProductBinary(string file);
    private static string GetGroupPolicyValue(string shellId, ExecutionPolicyScope scope);
    private static string GetLocalPreferenceValue(string shellId, ExecutionPolicyScope scope);
    internal static SaferPolicy GetSaferPolicy(string path, SafeHandle handle);
    internal static void CheckIfFileExists(string filePath);
    internal static bool CertIsGoodForSigning(X509Certificate2 c);
    internal static bool CertIsGoodForEncryption(X509Certificate2 c);
    internal static bool CertExpiresByTime(X509Certificate2 c, DateTime expiring);
    private static bool CertHasOid(X509Certificate2 c, string oid);
    private static bool CertHasKeyUsage(X509Certificate2 c, X509KeyUsageFlags keyUsage);
    internal static Collection`1<string> GetCertEKU(X509Certificate2 cert);
    internal static UInt32 GetDWORDFromInt(int n);
    internal static int GetIntFromDWORD(UInt32 n);
}
public class System.Management.Automation.Internal.SessionStateKeeper : object {
    private ConditionalWeakTable`2<Runspace, SessionStateInternal> _stateMap;
    internal void RegisterRunspace();
    public object GetSessionState();
}
public class System.Management.Automation.Internal.ShouldProcessParameters : object {
    private MshCommandRuntime _commandRuntime;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter WhatIf { get; public set; }
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter Confirm { get; public set; }
    internal ShouldProcessParameters(MshCommandRuntime commandRuntime);
    public SwitchParameter get_WhatIf();
    public void set_WhatIf(SwitchParameter value);
    public SwitchParameter get_Confirm();
    public void set_Confirm(SwitchParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Internal.StringDecorated : object {
    private bool _isDecorated;
    private string _text;
    [NullableAttribute("2")]
private string _plaintextcontent;
    private string PlainText { get; }
    public bool IsDecorated { get; }
    public int ContentLength { get; }
    public StringDecorated(string text);
    private string get_PlainText();
    public bool get_IsDecorated();
    public int get_ContentLength();
    public virtual string ToString();
    public string ToString(OutputRendering outputRendering);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Internal.StringUtil : object {
    private static int IndentCacheMax;
    private static String[] s_indentCache;
    private static int DashCacheMax;
    private static String[] s_dashCache;
    private static StringUtil();
    internal static string Format(string format, object arg0);
    internal static string Format(string format, object arg0, object arg1);
    internal static string Format(string format, object arg0, object arg1, object arg2);
    internal static string Format(string format, Object[] args);
    internal static string TruncateToBufferCellWidth(PSHostRawUserInterface rawUI, string toTruncate, int maxWidthInBufferCells);
    internal static string Padding(int countOfSpaces);
    internal static string DashPadding(int count);
    [ExtensionAttribute]
internal static string VtSubstring(string str, int startOffset);
    [ExtensionAttribute]
internal static string VtSubstring(string str, int startOffset, int length);
    [ExtensionAttribute]
internal static string VtSubstring(string str, int startOffset, string prependStr, string appendStr);
    [ExtensionAttribute]
internal static string VtSubstring(string str, int startOffset, int length, string prependStr, string appendStr);
    [ExtensionAttribute]
internal static bool EndsWith(StringBuilder sb, string value);
}
internal class System.Management.Automation.Internal.TestHelperSession : RemoteSession {
    internal RemotingDestination MySelf { get; }
    internal virtual void StartKeyExchange();
    internal virtual RemotingDestination get_MySelf();
    internal virtual void CompleteKeyExchange();
}
public class System.Management.Automation.Internal.TransactionParameters : object {
    private MshCommandRuntime _commandRuntime;
    [ParameterAttribute]
[AliasAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public SwitchParameter UseTransaction { get; public set; }
    internal TransactionParameters(MshCommandRuntime commandRuntime);
    public SwitchParameter get_UseTransaction();
    public void set_UseTransaction(SwitchParameter value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.Internal.ValueStringDecorated : ValueType {
    internal static char ESC;
    private bool _isDecorated;
    private string _text;
    [NullableAttribute("2")]
private string _plaintextcontent;
    [NullableAttribute("2")]
private Dictionary`2<int, int> _vtRanges;
    private static string GraphicsRegex;
    private static string CsiRegex;
    private static string HyperlinkRegex;
    internal static Regex AnsiRegex;
    private string PlainText { get; }
    [NullableAttribute("2")]
internal Dictionary`2<int, int> EscapeSequenceRanges { get; }
    public bool IsDecorated { get; }
    public int ContentLength { get; }
    public ValueStringDecorated(string text);
    private static ValueStringDecorated();
    private string get_PlainText();
    [NullableContextAttribute("2")]
internal Dictionary`2<int, int> get_EscapeSequenceRanges();
    public bool get_IsDecorated();
    public int get_ContentLength();
    public virtual string ToString();
    public string ToString(OutputRendering outputRendering);
}
internal enum System.Management.Automation.Internal.VariableStreamKind : Enum {
    public int value__;
    public static VariableStreamKind Output;
    public static VariableStreamKind Error;
    public static VariableStreamKind Warning;
    public static VariableStreamKind Information;
}
internal class System.Management.Automation.InternalDeserializer : object {
    private XmlReader _reader;
    private DeserializationContext _context;
    private TypeTable _typeTable;
    private int _depthBelowTopLevel;
    private Version _version;
    private static int MaxDepthBelowTopLevel;
    private ReferenceIdHandlerForDeserializer`1<object> _objectRefIdHandler;
    private ReferenceIdHandlerForDeserializer`1<ConsolidatedString> _typeRefIdHandler;
    private static Lazy`1<HashSet`1<Type>> s_knownCimArrayTypes;
    private bool _isStopping;
    internal static string CimInstanceMetadataProperty;
    internal static string CimModifiedProperties;
    internal static string CimClassMetadataProperty;
    internal static string CimClassNameProperty;
    internal static string CimNamespaceProperty;
    internal static string CimServerNameProperty;
    internal static string CimHashCodeProperty;
    internal static string CimMiXmlProperty;
    private static Lazy`1<CimDeserializer> s_cimDeserializer;
    [CompilerGeneratedAttribute]
private static XmlReaderSettings <XmlReaderSettingsForCliXml>k__BackingField;
    [CompilerGeneratedAttribute]
private static XmlReaderSettings <XmlReaderSettingsForUntrustedXmlDocument>k__BackingField;
    [TraceSourceAttribute("InternalDeserializer", "InternalDeserializer class")]
private static PSTraceSource s_trace;
    private bool UnknownTagsAllowed { get; }
    private bool DuplicateRefIdsAllowed { get; }
    internal TypeTable TypeTable { get; internal set; }
    internal static XmlReaderSettings XmlReaderSettingsForCliXml { get; }
    internal static XmlReaderSettings XmlReaderSettingsForUntrustedXmlDocument { get; }
    internal InternalDeserializer(XmlReader reader, DeserializationContext context);
    private static InternalDeserializer();
    private bool get_UnknownTagsAllowed();
    private bool get_DuplicateRefIdsAllowed();
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    internal void ValidateVersion(string version);
    private object ReadOneDeserializedObject(String& streamName, Boolean& isKnownPrimitiveType);
    internal void Stop();
    private void CheckIfStopping();
    private static bool RehydrateCimInstanceProperty(CimInstance cimInstance, PSPropertyInfo deserializedProperty, HashSet`1<string> namesOfModifiedProperties);
    private CimClass RehydrateCimClass(PSPropertyInfo classMetadataProperty);
    private PSObject RehydrateCimInstance(PSObject deserializedObject);
    internal object ReadOneObject(String& streamName);
    private object ReadOneObject();
    private PSObject ReadPSObject();
    private PSObject ReadAttributeAndCreatePSObject();
    private void ReadTypeNames(PSObject dso);
    private void ReadProperties(PSObject dso);
    private void ReadMemberSet(PSMemberInfoCollection`1<PSMemberInfo> collection);
    private PSNoteProperty ReadNoteProperty();
    private bool IsKnownContainerTag(ContainerType& ct);
    private object ReadKnownContainer(ContainerType ct, ConsolidatedString InternalTypeNames);
    private object ReadListContainer(ContainerType ct);
    private object ReadDictionary(ContainerType ct, ConsolidatedString InternalTypeNames);
    [CompilerGeneratedAttribute]
internal static XmlReaderSettings get_XmlReaderSettingsForCliXml();
    private static XmlReaderSettings GetXmlReaderSettingsForCliXml();
    [CompilerGeneratedAttribute]
internal static XmlReaderSettings get_XmlReaderSettingsForUntrustedXmlDocument();
    private static XmlReaderSettings GetXmlReaderSettingsForUntrustedXmlDocument();
    internal static object DeserializeBoolean(InternalDeserializer deserializer);
    internal static object DeserializeByte(InternalDeserializer deserializer);
    internal static object DeserializeChar(InternalDeserializer deserializer);
    internal static object DeserializeDateTime(InternalDeserializer deserializer);
    internal static object DeserializeDecimal(InternalDeserializer deserializer);
    internal static object DeserializeDouble(InternalDeserializer deserializer);
    internal static object DeserializeGuid(InternalDeserializer deserializer);
    internal static object DeserializeVersion(InternalDeserializer deserializer);
    internal static object DeserializeSemanticVersion(InternalDeserializer deserializer);
    internal static object DeserializeInt16(InternalDeserializer deserializer);
    internal static object DeserializeInt32(InternalDeserializer deserializer);
    internal static object DeserializeInt64(InternalDeserializer deserializer);
    internal static object DeserializeSByte(InternalDeserializer deserializer);
    internal static object DeserializeSingle(InternalDeserializer deserializer);
    internal static object DeserializeScriptBlock(InternalDeserializer deserializer);
    internal static object DeserializeString(InternalDeserializer deserializer);
    internal static object DeserializeTimeSpan(InternalDeserializer deserializer);
    internal static object DeserializeUInt16(InternalDeserializer deserializer);
    internal static object DeserializeUInt32(InternalDeserializer deserializer);
    internal static object DeserializeUInt64(InternalDeserializer deserializer);
    internal static object DeserializeUri(InternalDeserializer deserializer);
    internal static object DeserializeByteArray(InternalDeserializer deserializer);
    internal static XmlDocument LoadUnsafeXmlDocument(FileInfo xmlPath, bool preserveNonElements, Nullable`1<int> maxCharactersInDocument);
    internal static XmlDocument LoadUnsafeXmlDocument(string xmlContents, bool preserveNonElements, Nullable`1<int> maxCharactersInDocument);
    internal static XmlDocument LoadUnsafeXmlDocument(Stream stream, bool preserveNonElements, Nullable`1<int> maxCharactersInDocument);
    internal static XmlDocument LoadUnsafeXmlDocument(TextReader textReader, bool preserveNonElements, Nullable`1<int> maxCharactersInDocument);
    internal static object DeserializeXmlDocument(InternalDeserializer deserializer);
    internal static object DeserializeProgressRecord(InternalDeserializer deserializer);
    internal static object DeserializeSecureString(InternalDeserializer deserializer);
    private bool IsNextElement(string tag);
    internal bool ReadStartElementAndHandleEmpty(string element);
    private void ReadStartElement(string element);
    private void ReadEndElement();
    private string ReadDecodedElementString(string element);
    private void Skip();
    private object ReadPrimaryKnownType(TypeSerializationInfo pktInfo);
    private object ReadSecureString();
    private XmlException NewXmlException(string resourceString, Exception innerException, Object[] args);
    private string ReadNameAttribute();
    private static string DecodeString(string s);
}
internal class System.Management.Automation.InternalParameterMetadata : object {
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CompiledCommandParameter> <BindableParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CompiledCommandParameter> <AliasedParameters>k__BackingField;
    private Type _type;
    internal static BindingFlags metaDataBindingFlags;
    private static ConcurrentDictionary`2<string, InternalParameterMetadata> s_parameterMetadataCache;
    internal string TypeName { get; }
    internal Dictionary`2<string, CompiledCommandParameter> BindableParameters { get; }
    internal Dictionary`2<string, CompiledCommandParameter> AliasedParameters { get; }
    internal InternalParameterMetadata(RuntimeDefinedParameterDictionary runtimeDefinedParameters, bool processingDynamicParameters, bool checkNames);
    internal InternalParameterMetadata(Type type, bool processingDynamicParameters);
    private static InternalParameterMetadata();
    internal static InternalParameterMetadata Get(RuntimeDefinedParameterDictionary runtimeDefinedParameters, bool processingDynamicParameters, bool checkNames);
    internal static InternalParameterMetadata Get(Type type, ExecutionContext context, bool processingDynamicParameters);
    [CompilerGeneratedAttribute]
internal string get_TypeName();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, CompiledCommandParameter> get_BindableParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, CompiledCommandParameter> get_AliasedParameters();
    private void ConstructCompiledParametersUsingRuntimeDefinedParameters(RuntimeDefinedParameterDictionary runtimeDefinedParameters, bool processingDynamicParameters, bool checkNames);
    private void ConstructCompiledParametersUsingReflection(bool processingDynamicParameters);
    private static void CheckForReservedParameter(string name);
    private void AddParameter(MemberInfo member, bool processingDynamicParameters);
    private void AddParameter(CompiledCommandParameter parameter, bool checkNames);
    private void RemoveParameter(CompiledCommandParameter parameter);
    private static bool IsMemberAParameter(MemberInfo member);
}
internal class System.Management.Automation.InternalSerializer : object {
    internal static string DefaultVersion;
    private XmlWriter _writer;
    private SerializationContext _context;
    private TypeTable _typeTable;
    private int _depthBelowTopLevel;
    private static int MaxDepthBelowTopLevel;
    private ReferenceIdHandlerForSerializer`1<object> _objectRefIdHandler;
    private ReferenceIdHandlerForSerializer`1<ConsolidatedString> _typeRefIdHandler;
    private bool _isStopping;
    private static Lazy`1<CimSerializer> s_cimSerializer;
    private Nullable`1<bool> _canUseDefaultRunspaceInThreadSafeManner;
    private Collection`1<CollectionEntry`1<PSMemberInfo>> _extendedMembersCollection;
    private Collection`1<CollectionEntry`1<PSPropertyInfo>> _allPropertiesCollection;
    private static Char[] s_hexlookup;
    internal TypeTable TypeTable { get; internal set; }
    private bool CanUseDefaultRunspaceInThreadSafeManner { get; }
    private Collection`1<CollectionEntry`1<PSMemberInfo>> ExtendedMembersCollection { get; }
    private Collection`1<CollectionEntry`1<PSPropertyInfo>> AllPropertiesCollection { get; }
    internal InternalSerializer(XmlWriter writer, SerializationContext context);
    private static InternalSerializer();
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    internal void Start();
    internal void End();
    internal void Stop();
    private void CheckIfStopping();
    internal static bool IsPrimitiveKnownType(Type input);
    internal void WriteOneTopLevelObject(object source, string streamName);
    private void WriteOneObject(object source, string streamName, string property, int depth);
    private bool HandleMaxDepth(object source, string streamName, string property);
    private bool HandlePrimitiveKnownType(object source, string streamName, string property);
    private bool HandlePrimitiveKnownTypeByConvertingToPSObject(object source, string streamName, string property, int depth);
    private bool HandleSecureString(object source, string streamName, string property);
    private bool HandlePrimitiveKnownTypePSObject(object source, string streamName, string property, int depth);
    private bool HandleKnownContainerTypes(object source, string streamName, string property, int depth);
    private void WritePSObjectReference(string streamName, string property, string refId);
    private static bool PSObjectHasModifiedTypesCollection(PSObject pso);
    private void WritePrimitiveTypePSObject(PSObject source, object primitive, TypeSerializationInfo pktInfo, string streamName, string property, int depth);
    private void WritePrimitiveTypePSObjectWithNotes(PSObject source, object primitive, bool hasModifiedTypesCollection, string toStringValue, TypeSerializationInfo pktInfo, string streamName, string property, int depth);
    private void HandleComplexTypePSObject(object source, string streamName, string property, int depth);
    private void PrepareCimInstanceForSerialization(PSObject psObject, CimInstance cimInstance);
    private void WriteStartOfPSObject(PSObject mshObject, string streamName, string property, string refId, bool writeTypeNames, string toStringValue);
    private static bool PSObjectHasNotes(PSObject source);
    private bool get_CanUseDefaultRunspaceInThreadSafeManner();
    private void WriteMemberInfoCollection(IEnumerable`1<PSMemberInfo> me, int depth, bool writeEnclosingMemberSetElementTag);
    private void WriteMemberSet(PSMemberSet set, int depth);
    private void WritePSObjectProperties(PSObject source, int depth, IEnumerable`1<PSPropertyInfo> specificPropertiesToSerialize);
    private void SerializeInstanceProperties(PSObject source, int depth);
    private Collection`1<CollectionEntry`1<PSMemberInfo>> get_ExtendedMembersCollection();
    private Collection`1<CollectionEntry`1<PSPropertyInfo>> get_AllPropertiesCollection();
    private void SerializeExtendedProperties(PSObject source, int depth, IEnumerable`1<PSPropertyInfo> specificPropertiesToSerialize);
    private void SerializeProperties(IEnumerable`1<PSPropertyInfo> propertyCollection, string name, int depth);
    private void WriteEnumerable(IEnumerable enumerable, string tag, int depth);
    private void WriteDictionary(IDictionary dictionary, string tag, int depth);
    private void HandlePSObjectAsString(PSObject source, string streamName, string property, int depth);
    private string GetSerializationString(PSObject source);
    private bool SerializeAsString(PSObject source);
    private int GetDepthOfSerialization(object source, int depth);
    private void WriteNull(string streamName, string property);
    private static void WriteRawString(InternalSerializer serializer, string streamName, string property, string raw, TypeSerializationInfo entry);
    private static void WriteOnePrimitiveKnownType(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteDateTime(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteVersion(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteSemanticVersion(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteScriptBlock(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteUri(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteEncodedString(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteDouble(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteChar(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteBoolean(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteSingle(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteTimeSpan(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteByteArray(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteXmlDocument(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteProgressRecord(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    internal static void WriteSecureString(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    private void WriteStartElement(string elementTag);
    private void WriteAttribute(string name, string value);
    private void WriteNameAttribute(string value);
    internal static string EncodeString(string s);
    private static string EncodeString(string s, int indexOfFirstEncodableCharacter);
    private void WriteEncodedElementString(string name, string value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.InteropServices.ComEventsMethod : object {
    private List`1<DelegateWrapper> _delegateWrappers;
    private int _dispid;
    [NullableAttribute("2")]
private ComEventsMethod _next;
    public bool Empty { get; }
    public ComEventsMethod(int dispid);
    [NullableContextAttribute("2")]
public static ComEventsMethod Find(ComEventsMethod methods, int dispid);
    public static ComEventsMethod Add(ComEventsMethod methods, ComEventsMethod method);
    public static ComEventsMethod Remove(ComEventsMethod methods, ComEventsMethod method);
    public bool get_Empty();
    public void AddDelegate(Delegate d, bool wrapArgs);
    public void RemoveDelegate(Delegate d, bool wrapArgs);
    public void RemoveDelegates(Func`2<Delegate, bool> condition);
    public object Invoke(Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.InteropServices.ComEventsSink : object {
    private Guid _iidSourceItf;
    [NullableAttribute("2")]
private IConnectionPoint _connectionPoint;
    private int _cookie;
    [NullableAttribute("2")]
private ComEventsMethod _methods;
    [NullableAttribute("2")]
private ComEventsSink _next;
    private static VarEnum VT_BYREF_VARIANT;
    private static VarEnum VT_TYPEMASK;
    private static VarEnum VT_BYREF_TYPEMASK;
    public ComEventsSink(object rcw, Guid iid);
    [NullableContextAttribute("0")]
private void Initialize(object rcw, Guid iid);
    [NullableContextAttribute("0")]
public void AddHandler(int dispid, object func);
    [NullableContextAttribute("0")]
public void RemoveHandler(int dispid, object func);
    [NullableContextAttribute("0")]
public static ComEventsSink FromRuntimeCallableWrapper(object rcw, Guid sourceIid, bool createIfNotFound);
    [NullableContextAttribute("2")]
public static ComEventsSink Find(ComEventsSink sinks, Guid& iid);
    public static ComEventsSink Add(ComEventsSink sinks, ComEventsSink sink);
    [NullableContextAttribute("2")]
public static ComEventsSink RemoveAll(ComEventsSink sinks);
    public static ComEventsSink Remove(ComEventsSink sinks, ComEventsSink sink);
    public ComEventsMethod RemoveMethod(ComEventsMethod method);
    [NullableContextAttribute("2")]
public ComEventsMethod FindMethod(int dispid);
    public ComEventsMethod AddMethod(int dispid);
    private sealed virtual override int System.Management.Automation.InteropServices.IDispatch.GetTypeInfoCount();
    private sealed virtual override ITypeInfo System.Management.Automation.InteropServices.IDispatch.GetTypeInfo(int iTInfo, int lcid);
    private sealed virtual override void System.Management.Automation.InteropServices.IDispatch.GetIDsOfNames(Guid& iid, String[] names, int cNames, int lcid, Int32[] rgDispId);
    private static Variant& GetVariant(Variant& pSrc);
    private sealed virtual override void System.Management.Automation.InteropServices.IDispatch.Invoke(int dispid, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
    private sealed virtual override CustomQueryInterfaceResult System.Runtime.InteropServices.ICustomQueryInterface.GetInterface(Guid& iid, IntPtr& ppv);
    private void Advise(object rcw);
    private void Unadvise();
}
[GuidAttribute("00020400-0000-0000-C000-000000000046")]
[InterfaceTypeAttribute("1")]
internal interface System.Management.Automation.InteropServices.IDispatch {
    public abstract virtual int GetTypeInfoCount();
    public abstract virtual ITypeInfo GetTypeInfo(int iTInfo, int lcid);
    public abstract virtual void GetIDsOfNames(Guid& riid, String[] rgszNames, int cNames, int lcid, Int32[] rgDispId);
    public abstract virtual void Invoke(int dispIdMember, Guid& riid, int lcid, InvokeFlags wFlags, DISPPARAMS& pDispParams, IntPtr pVarResult, IntPtr pExcepInfo, IntPtr puArgErr);
}
[FlagsAttribute]
internal enum System.Management.Automation.InteropServices.InvokeFlags : Enum {
    public short value__;
    public static InvokeFlags DISPATCH_METHOD;
    public static InvokeFlags DISPATCH_PROPERTYGET;
    public static InvokeFlags DISPATCH_PROPERTYPUT;
    public static InvokeFlags DISPATCH_PROPERTYPUTREF;
}
internal class System.Management.Automation.InteropServices.Variant : ValueType {
    private TypeUnion _typeUnion;
    private decimal _decimal;
    public VarEnum VariantType { get; public set; }
    public bool IsEmpty { get; }
    public bool IsByRef { get; }
    public sbyte AsI1 { get; public set; }
    public short AsI2 { get; public set; }
    public int AsI4 { get; public set; }
    public long AsI8 { get; public set; }
    public byte AsUi1 { get; public set; }
    public ushort AsUi2 { get; public set; }
    public UInt32 AsUi4 { get; public set; }
    public ulong AsUi8 { get; public set; }
    public int AsInt { get; public set; }
    public UInt32 AsUint { get; public set; }
    public bool AsBool { get; public set; }
    public int AsError { get; public set; }
    public float AsR4 { get; public set; }
    public double AsR8 { get; public set; }
    public decimal AsDecimal { get; public set; }
    public decimal AsCy { get; public set; }
    public DateTime AsDate { get; public set; }
    [NullableAttribute("1")]
public string AsBstr { get; public set; }
    [NullableAttribute("2")]
public object AsUnknown { get; public set; }
    [NullableAttribute("2")]
public object AsDispatch { get; public set; }
    public IntPtr AsByRefVariant { get; }
    public object AsVariant { get; public set; }
    public static bool IsPrimitiveType(VarEnum varEnum);
    [NullableContextAttribute("1")]
public void CopyFromIndirect(object value);
    [NullableContextAttribute("2")]
public object ToObject();
    public void Clear();
    public VarEnum get_VariantType();
    public void set_VariantType(VarEnum value);
    public bool get_IsEmpty();
    public bool get_IsByRef();
    public void SetAsNULL();
    public sbyte get_AsI1();
    public void set_AsI1(sbyte value);
    public short get_AsI2();
    public void set_AsI2(short value);
    public int get_AsI4();
    public void set_AsI4(int value);
    public long get_AsI8();
    public void set_AsI8(long value);
    public byte get_AsUi1();
    public void set_AsUi1(byte value);
    public ushort get_AsUi2();
    public void set_AsUi2(ushort value);
    public UInt32 get_AsUi4();
    public void set_AsUi4(UInt32 value);
    public ulong get_AsUi8();
    public void set_AsUi8(ulong value);
    public int get_AsInt();
    public void set_AsInt(int value);
    public UInt32 get_AsUint();
    public void set_AsUint(UInt32 value);
    public bool get_AsBool();
    public void set_AsBool(bool value);
    public int get_AsError();
    public void set_AsError(int value);
    public float get_AsR4();
    public void set_AsR4(float value);
    public double get_AsR8();
    public void set_AsR8(double value);
    public decimal get_AsDecimal();
    public void set_AsDecimal(decimal value);
    public decimal get_AsCy();
    public void set_AsCy(decimal value);
    public DateTime get_AsDate();
    public void set_AsDate(DateTime value);
    [NullableContextAttribute("1")]
public string get_AsBstr();
    [NullableContextAttribute("1")]
public void set_AsBstr(string value);
    [NullableContextAttribute("2")]
public object get_AsUnknown();
    [NullableContextAttribute("2")]
public void set_AsUnknown(object value);
    [NullableContextAttribute("2")]
public object get_AsDispatch();
    [NullableContextAttribute("2")]
public void set_AsDispatch(object value);
    public IntPtr get_AsByRefVariant();
    public void SetAsByrefI1(SByte& value);
    public void SetAsByrefI2(Int16& value);
    public void SetAsByrefI4(Int32& value);
    public void SetAsByrefI8(Int64& value);
    public void SetAsByrefUi1(Byte& value);
    public void SetAsByrefUi2(UInt16& value);
    public void SetAsByrefUi4(UInt32& value);
    public void SetAsByrefUi8(UInt64& value);
    public void SetAsByrefInt(Int32& value);
    public void SetAsByrefUint(UInt32& value);
    public void SetAsByrefBool(Int16& value);
    public void SetAsByrefError(Int32& value);
    public void SetAsByrefR4(Single& value);
    public void SetAsByrefR8(Double& value);
    public void SetAsByrefDecimal(Decimal& value);
    public void SetAsByrefCy(Int64& value);
    public void SetAsByrefDate(Double& value);
    public void SetAsByrefBstr(IntPtr& value);
    public void SetAsByrefUnknown(IntPtr& value);
    public void SetAsByrefDispatch(IntPtr& value);
    public object get_AsVariant();
    public void set_AsVariant(object value);
    public void SetAsByrefVariant(Variant& value);
    public void SetAsByrefVariantIndirect(Variant& value);
    private void SetAsByref(T& value, VarEnum type);
    internal static PropertyInfo GetAccessor(VarEnum varType);
    internal static MethodInfo GetByrefSetter(VarEnum varType);
    public virtual string ToString();
    public void SetAsIConvertible(IConvertible value);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction : CallInstruction {
    private Action _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction(Action target);
    public ActionCallInstruction(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`1 : CallInstruction {
    private Action`1<T0> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`1(Action`1<T0> target);
    public ActionCallInstruction`1(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`2 : CallInstruction {
    private Action`2<T0, T1> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`2(Action`2<T0, T1> target);
    public ActionCallInstruction`2(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`3 : CallInstruction {
    private Action`3<T0, T1, T2> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`3(Action`3<T0, T1, T2> target);
    public ActionCallInstruction`3(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`4 : CallInstruction {
    private Action`4<T0, T1, T2, T3> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`4(Action`4<T0, T1, T2, T3> target);
    public ActionCallInstruction`4(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`5 : CallInstruction {
    private Action`5<T0, T1, T2, T3, T4> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`5(Action`5<T0, T1, T2, T3, T4> target);
    public ActionCallInstruction`5(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`6 : CallInstruction {
    private Action`6<T0, T1, T2, T3, T4, T5> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`6(Action`6<T0, T1, T2, T3, T4, T5> target);
    public ActionCallInstruction`6(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`7 : CallInstruction {
    private Action`7<T0, T1, T2, T3, T4, T5, T6> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`7(Action`7<T0, T1, T2, T3, T4, T5, T6> target);
    public ActionCallInstruction`7(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`8 : CallInstruction {
    private Action`8<T0, T1, T2, T3, T4, T5, T6, T7> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`8(Action`8<T0, T1, T2, T3, T4, T5, T6, T7> target);
    public ActionCallInstruction`8(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ActionCallInstruction`9 : CallInstruction {
    private Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public ActionCallInstruction`9(Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> target);
    public ActionCallInstruction`9(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.AddInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.AddOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.ArgumentArray : object {
    private Object[] _arguments;
    private int _first;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    private static MethodInfo s_getArgMethod;
    public int Count { get; }
    internal ArgumentArray(Object[] arguments, int first, int count);
    private static ArgumentArray();
    [CompilerGeneratedAttribute]
public int get_Count();
    public object GetArgument(int index);
    public DynamicMetaObject GetMetaObject(Expression parameter, int index);
    public static object GetArg(ArgumentArray array, int index);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Interpreter.ArrayUtils : object {
    [ExtensionAttribute]
internal static T[] AddLast(IList`1<T> list, T item);
}
internal static class System.Management.Automation.Interpreter.Assert : object {
    internal static Exception Unreachable { get; }
    internal static Exception get_Unreachable();
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2);
    [ConditionalAttribute("DEBUG")]
public static void NotNull(object var1, object var2, object var3);
    [ConditionalAttribute("DEBUG")]
public static void NotNullItems(IEnumerable`1<T> items);
    [ConditionalAttribute("DEBUG")]
public static void NotEmpty(string str);
}
internal class System.Management.Automation.Interpreter.AssignLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.AssignLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Management.Automation.Interpreter.AssignLocalToClosureInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal AssignLocalToClosureInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.BranchFalseInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.BranchInstruction : OffsetInstruction {
    private static Instruction[][][] s_caches;
    internal bool _hasResult;
    internal bool _hasValue;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public BranchInstruction(bool hasResult, bool hasValue);
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.BranchLabel : object {
    internal static int UnknownIndex;
    internal static int UnknownDepth;
    internal int _labelIndex;
    internal int _targetIndex;
    internal int _stackDepth;
    internal int _continuationStackDepth;
    private List`1<int> _forwardBranchFixups;
    internal int LabelIndex { get; internal set; }
    internal bool HasRuntimeLabel { get; }
    internal int TargetIndex { get; }
    internal int StackDepth { get; }
    internal int get_LabelIndex();
    internal void set_LabelIndex(int value);
    internal bool get_HasRuntimeLabel();
    internal int get_TargetIndex();
    internal int get_StackDepth();
    internal RuntimeLabel ToRuntimeLabel();
    internal void Mark(InstructionList instructions);
    internal void AddBranch(InstructionList instructions, int branchIndex);
    internal void FixupBranch(InstructionList instructions, int branchIndex);
}
internal class System.Management.Automation.Interpreter.BranchTrueInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.Interpreter.CacheDict`2 : object {
    private Dictionary`2<TKey, KeyInfo<TKey, TValue>> _dict;
    private LinkedList`1<TKey> _list;
    private int _maxSize;
    public TValue Item { get; public set; }
    public CacheDict`2(int maxSize);
    public bool TryGetValue(TKey key, TValue& value);
    public void Add(TKey key, TValue value);
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
internal abstract class System.Management.Automation.Interpreter.CallInstruction : Instruction {
    private static Dictionary`2<MethodInfo, CallInstruction> s_cache;
    private static int MaxHelpers;
    private static int MaxArgs;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public string InstructionName { get; }
    private static CallInstruction();
    public abstract virtual MethodInfo get_Info();
    public abstract virtual int get_ArgumentCount();
    public static CallInstruction Create(MethodInfo info);
    public static CallInstruction Create(MethodInfo info, ParameterInfo[] parameters);
    private static CallInstruction GetArrayAccessor(MethodInfo info, int argumentCount);
    public static void ArrayItemSetter1(Array array, int index0, object value);
    public static void ArrayItemSetter2(Array array, int index0, int index1, object value);
    public static void ArrayItemSetter3(Array array, int index0, int index1, int index2, object value);
    private static bool ShouldCache(MethodInfo info);
    private static Type TryGetParameterOrReturnType(MethodInfo target, ParameterInfo[] pi, int index);
    private static bool IndexIsNotReturnType(int index, MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction SlowCreate(MethodInfo info, ParameterInfo[] pis);
    public sealed virtual int get_ProducedStack();
    public sealed virtual int get_ConsumedStack();
    public sealed virtual string get_InstructionName();
    public virtual string ToString();
    public virtual object InvokeInstance(object instance, Object[] args);
    public virtual object Invoke(Object[] args);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static CallInstruction FastCreate(MethodInfo target, ParameterInfo[] pi);
    private static Type GetHelperType(MethodInfo info, Type[] arrTypes);
    public static MethodInfo CacheFunc(Func`1<TRet> method);
    public static MethodInfo CacheFunc(Func`2<T0, TRet> method);
    public static MethodInfo CacheFunc(Func`3<T0, T1, TRet> method);
    public static MethodInfo CacheFunc(Func`4<T0, T1, T2, TRet> method);
    public static MethodInfo CacheFunc(Func`5<T0, T1, T2, T3, TRet> method);
    public static MethodInfo CacheFunc(Func`6<T0, T1, T2, T3, T4, TRet> method);
    public static MethodInfo CacheFunc(Func`7<T0, T1, T2, T3, T4, T5, TRet> method);
    public static MethodInfo CacheFunc(Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> method);
    public static MethodInfo CacheFunc(Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> method);
    public static MethodInfo CacheFunc(Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> method);
    public static MethodInfo CacheAction(Action method);
    public static MethodInfo CacheAction(Action`1<T0> method);
    public static MethodInfo CacheAction(Action`2<T0, T1> method);
    public static MethodInfo CacheAction(Action`3<T0, T1, T2> method);
    public static MethodInfo CacheAction(Action`4<T0, T1, T2, T3> method);
    public static MethodInfo CacheAction(Action`5<T0, T1, T2, T3, T4> method);
    public static MethodInfo CacheAction(Action`6<T0, T1, T2, T3, T4, T5> method);
    public static MethodInfo CacheAction(Action`7<T0, T1, T2, T3, T4, T5, T6> method);
    public static MethodInfo CacheAction(Action`8<T0, T1, T2, T3, T4, T5, T6, T7> method);
    public static MethodInfo CacheAction(Action`9<T0, T1, T2, T3, T4, T5, T6, T7, T8> method);
}
internal class System.Management.Automation.Interpreter.CoalescingBranchInstruction : OffsetInstruction {
    private static Instruction[] s_cache;
    public Instruction[] Cache { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual Instruction[] get_Cache();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Interpreter.CollectionExtension : object {
    [ExtensionAttribute]
internal static bool TrueForAll(IEnumerable`1<T> collection, Predicate`1<T> predicate);
    [ExtensionAttribute]
internal static TResult[] Map(ICollection`1<TSource> source, Func`2<TSource, TResult> selector);
    [ExtensionAttribute]
internal static int ListHashCode(IEnumerable`1<T> list);
    [ExtensionAttribute]
internal static bool ListEquals(ICollection`1<T> first, ICollection`1<T> second);
}
internal class System.Management.Automation.Interpreter.CompiledLoopInstruction : Instruction {
    private Func`4<Object[], StrongBox`1[], InterpretedFrame, int> _compiledLoop;
    public CompiledLoopInstruction(Func`4<Object[], StrongBox`1[], InterpretedFrame, int> compiledLoop);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.CreateDelegateInstruction : Instruction {
    private LightDelegateCreator _creator;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal CreateDelegateInstruction(LightDelegateCreator delegateCreator);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.DebugInfo : object {
    public int StartLine;
    public int EndLine;
    public int Index;
    public string FileName;
    public bool IsClear;
    private static DebugInfoComparer s_debugComparer;
    private static DebugInfo();
    public static DebugInfo GetMatchingDebugInfo(DebugInfo[] debugInfos, int index);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DefaultValueInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal static class System.Management.Automation.Interpreter.DelegateHelpers : object {
    private static int MaximumArity;
    internal static Type MakeDelegate(Type[] types);
}
internal abstract class System.Management.Automation.Interpreter.DivInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DupInstruction : Instruction {
    internal static DupInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static DupInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`1 : Instruction {
    private CallSite`1<Func`2<CallSite, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`1(CallSite`1<Func`2<CallSite, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`10 : Instruction {
    private CallSite`1<Func`11<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`10(CallSite`1<Func`11<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`11 : Instruction {
    private CallSite`1<Func`12<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`11(CallSite`1<Func`12<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`12 : Instruction {
    private CallSite`1<Func`13<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`12(CallSite`1<Func`13<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`13 : Instruction {
    private CallSite`1<Func`14<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`13(CallSite`1<Func`14<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`14 : Instruction {
    private CallSite`1<Func`15<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`14(CallSite`1<Func`15<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`15 : Instruction {
    private CallSite`1<Func`16<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`15(CallSite`1<Func`16<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`16 : Instruction {
    private CallSite`1<Func`17<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`16(CallSite`1<Func`17<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`2 : Instruction {
    private CallSite`1<Func`3<CallSite, T0, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`2(CallSite`1<Func`3<CallSite, T0, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`3 : Instruction {
    private CallSite`1<Func`4<CallSite, T0, T1, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`3(CallSite`1<Func`4<CallSite, T0, T1, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`4 : Instruction {
    private CallSite`1<Func`5<CallSite, T0, T1, T2, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`4(CallSite`1<Func`5<CallSite, T0, T1, T2, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`5 : Instruction {
    private CallSite`1<Func`6<CallSite, T0, T1, T2, T3, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`5(CallSite`1<Func`6<CallSite, T0, T1, T2, T3, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`6 : Instruction {
    private CallSite`1<Func`7<CallSite, T0, T1, T2, T3, T4, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`6(CallSite`1<Func`7<CallSite, T0, T1, T2, T3, T4, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`7 : Instruction {
    private CallSite`1<Func`8<CallSite, T0, T1, T2, T3, T4, T5, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`7(CallSite`1<Func`8<CallSite, T0, T1, T2, T3, T4, T5, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`8 : Instruction {
    private CallSite`1<Func`9<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`8(CallSite`1<Func`9<CallSite, T0, T1, T2, T3, T4, T5, T6, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstruction`9 : Instruction {
    private CallSite`1<Func`10<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> _site;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private DynamicInstruction`9(CallSite`1<Func`10<CallSite, T0, T1, T2, T3, T4, T5, T6, T7, TRet>> site);
    public static Instruction Factory(CallSiteBinder binder);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.DynamicInstructionN : Instruction {
    private CallInstruction _target;
    private object _targetDelegate;
    private CallSite _site;
    private int _argumentCount;
    private bool _isVoid;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public DynamicInstructionN(Type delegateType, CallSite site);
    public DynamicInstructionN(Type delegateType, CallSite site, bool isVoid);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
    internal static Type GetDynamicInstructionType(Type delegateType);
    internal static Instruction CreateUntypedInstruction(CallSiteBinder binder, int argCount);
}
internal class System.Management.Automation.Interpreter.DynamicSplatInstruction : Instruction {
    private CallSite`1<Func`3<CallSite, ArgumentArray, object>> _site;
    private int _argumentCount;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    internal DynamicSplatInstruction(int argumentCount, CallSite`1<Func`3<CallSite, ArgumentArray, object>> site);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.EnterExceptionHandlerInstruction : Instruction {
    internal static EnterExceptionHandlerInstruction Void;
    internal static EnterExceptionHandlerInstruction NonVoid;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private EnterExceptionHandlerInstruction(bool hasValue);
    private static EnterExceptionHandlerInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.EnterFinallyInstruction : IndexedBranchInstruction {
    private static EnterFinallyInstruction[] s_cache;
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    private EnterFinallyInstruction(int labelIndex);
    private static EnterFinallyInstruction();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    internal static EnterFinallyInstruction Create(int labelIndex);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.EnterLoopInstruction : Instruction {
    private int _instructionIndex;
    private Dictionary`2<ParameterExpression, LocalVariable> _variables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private PowerShellLoopExpression _loop;
    private int _loopEnd;
    private int _compilationThreshold;
    private bool Compiled { get; }
    internal EnterLoopInstruction(PowerShellLoopExpression loop, LocalVariables locals, int compilationThreshold, int instructionIndex);
    internal void FinishLoop(int loopEnd);
    public virtual int Run(InterpretedFrame frame);
    private bool get_Compiled();
    private void Compile(object frameObj);
}
internal class System.Management.Automation.Interpreter.EnterTryCatchFinallyInstruction : IndexedBranchInstruction {
    private bool _hasFinally;
    private TryCatchFinallyHandler _tryHandler;
    public int ProducedContinuations { get; }
    public string InstructionName { get; }
    private EnterTryCatchFinallyInstruction(int targetIndex, bool hasFinally);
    internal void SetTryHandler(TryCatchFinallyHandler tryHandler);
    public virtual int get_ProducedContinuations();
    internal static EnterTryCatchFinallyInstruction CreateTryFinally(int labelIndex);
    internal static EnterTryCatchFinallyInstruction CreateTryCatch();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.EqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_boolean;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.ExceptionHandler : object {
    public Type ExceptionType;
    public int StartIndex;
    public int EndIndex;
    public int LabelIndex;
    public int HandlerStartIndex;
    public int HandlerEndIndex;
    internal TryCatchFinallyHandler Parent;
    public bool IsFault { get; }
    internal ExceptionHandler(int start, int end, int labelIndex, int handlerStartIndex, int handlerEndIndex, Type exceptionType);
    public bool get_IsFault();
    internal void SetParent(TryCatchFinallyHandler tryHandler);
    public bool Matches(Type exceptionType);
    public bool IsBetterThan(ExceptionHandler other);
    internal bool IsInsideTryBlock(int index);
    internal bool IsInsideCatchBlock(int index);
    internal bool IsInsideFinallyBlock(int index);
    public virtual string ToString();
}
internal static class System.Management.Automation.Interpreter.ExceptionHelpers : object {
    private static string prevStackTraces;
    public static Exception UpdateForRethrow(Exception rethrow);
    public static IList`1<StackTrace> GetExceptionStackTraces(Exception rethrow);
    private static void AssociateStackTraces(Exception e, List`1<StackTrace> traces);
    private static bool TryGetAssociatedStackTraces(Exception e, List`1& traces);
}
[FlagsAttribute]
internal enum System.Management.Automation.Interpreter.ExpressionAccess : Enum {
    public int value__;
    public static ExpressionAccess None;
    public static ExpressionAccess Read;
    public static ExpressionAccess Write;
    public static ExpressionAccess ReadWrite;
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`1 : CallInstruction {
    private Func`1<TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`1(Func`1<TRet> target);
    public FuncCallInstruction`1(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`10 : CallInstruction {
    private Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`10(Func`10<T0, T1, T2, T3, T4, T5, T6, T7, T8, TRet> target);
    public FuncCallInstruction`10(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7, object arg8);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`2 : CallInstruction {
    private Func`2<T0, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`2(Func`2<T0, TRet> target);
    public FuncCallInstruction`2(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`3 : CallInstruction {
    private Func`3<T0, T1, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`3(Func`3<T0, T1, TRet> target);
    public FuncCallInstruction`3(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`4 : CallInstruction {
    private Func`4<T0, T1, T2, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`4(Func`4<T0, T1, T2, TRet> target);
    public FuncCallInstruction`4(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`5 : CallInstruction {
    private Func`5<T0, T1, T2, T3, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`5(Func`5<T0, T1, T2, T3, TRet> target);
    public FuncCallInstruction`5(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`6 : CallInstruction {
    private Func`6<T0, T1, T2, T3, T4, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`6(Func`6<T0, T1, T2, T3, T4, TRet> target);
    public FuncCallInstruction`6(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`7 : CallInstruction {
    private Func`7<T0, T1, T2, T3, T4, T5, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`7(Func`7<T0, T1, T2, T3, T4, T5, TRet> target);
    public FuncCallInstruction`7(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`8 : CallInstruction {
    private Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`8(Func`8<T0, T1, T2, T3, T4, T5, T6, TRet> target);
    public FuncCallInstruction`8(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.FuncCallInstruction`9 : CallInstruction {
    private Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> _target;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    public FuncCallInstruction`9(Func`9<T0, T1, T2, T3, T4, T5, T6, T7, TRet> target);
    public FuncCallInstruction`9(MethodInfo target);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(object arg0, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6, object arg7);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.GetArrayItemInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class System.Management.Automation.Interpreter.GotoInstruction : IndexedBranchInstruction {
    private static int Variants;
    private static GotoInstruction[] s_cache;
    private bool _hasResult;
    private bool _hasValue;
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private GotoInstruction(int targetIndex, bool hasResult, bool hasValue);
    private static GotoInstruction();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static GotoInstruction Create(int labelIndex, bool hasResult, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.GreaterThanInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.Interpreter.HybridReferenceDictionary`2 : object {
    private KeyValuePair`2[] _keysAndValues;
    private Dictionary`2<TKey, TValue> _dict;
    private int _count;
    private static int _arraySize;
    public int Count { get; }
    public TValue Item { get; public set; }
    public HybridReferenceDictionary`2(int initialCapacity);
    public bool TryGetValue(TKey key, TValue& value);
    public bool Remove(TKey key);
    public bool ContainsKey(TKey key);
    public int get_Count();
    public IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    [IteratorStateMachineAttribute("System.Management.Automation.Interpreter.HybridReferenceDictionary`2/<GetEnumeratorWorker>d__12")]
private IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumeratorWorker();
    public TValue get_Item(TKey key);
    public void set_Item(TKey key, TValue value);
}
[NullableContextAttribute("2")]
internal interface System.Management.Automation.Interpreter.IBoxableInstruction {
    public abstract virtual Instruction BoxIfIndexMatches(int index);
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.Interpreter.IInstructionProvider {
    public abstract virtual void AddInstructions(LightCompiler compiler);
}
internal interface System.Management.Automation.Interpreter.ILightCallSiteBinder {
    public bool AcceptsArgumentArray { get; }
    public abstract virtual bool get_AcceptsArgumentArray();
}
internal abstract class System.Management.Automation.Interpreter.IndexedBranchInstruction : Instruction {
    protected static int CacheSize;
    internal int _labelIndex;
    protected IndexedBranchInstruction(int labelIndex);
    public RuntimeLabel GetLabel(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.InitializeLocalInstruction : LocalAccessInstruction {
    internal InitializeLocalInstruction(int index);
}
internal abstract class System.Management.Automation.Interpreter.Instruction : object {
    public static int UnknownInstrIndex;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public int ConsumedContinuations { get; }
    public int ProducedContinuations { get; }
    public int StackBalance { get; }
    public int ContinuationsBalance { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedContinuations();
    public virtual int get_ProducedContinuations();
    public int get_StackBalance();
    public int get_ContinuationsBalance();
    public abstract virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
    public virtual string ToString();
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual object GetDebugCookie(LightCompiler compiler);
}
[IsReadOnlyAttribute]
[DebuggerTypeProxyAttribute("System.Management.Automation.Interpreter.InstructionArray/DebugView")]
internal class System.Management.Automation.Interpreter.InstructionArray : ValueType {
    internal int MaxStackDepth;
    internal int MaxContinuationDepth;
    internal Instruction[] Instructions;
    internal Object[] Objects;
    internal RuntimeLabel[] Labels;
    internal List`1<KeyValuePair`2<int, object>> DebugCookies;
    internal int Length { get; }
    internal InstructionArray(int maxStackDepth, int maxContinuationDepth, Instruction[] instructions, Object[] objects, RuntimeLabel[] labels, List`1<KeyValuePair`2<int, object>> debugCookies);
    internal int get_Length();
}
internal abstract class System.Management.Automation.Interpreter.InstructionFactory : object {
    private static ConditionalWeakTable`2<Type, InstructionFactory> s_factories;
    internal static InstructionFactory GetFactory(Type type);
    protected internal abstract virtual Instruction GetArrayItem();
    protected internal abstract virtual Instruction SetArrayItem();
    protected internal abstract virtual Instruction TypeIs();
    protected internal abstract virtual Instruction TypeAs();
    protected internal abstract virtual Instruction DefaultValue();
    protected internal abstract virtual Instruction NewArray();
    protected internal abstract virtual Instruction NewArrayInit(int elementCount);
}
internal class System.Management.Automation.Interpreter.InstructionFactory`1 : InstructionFactory {
    public static InstructionFactory Factory;
    private Instruction _getArrayItem;
    private Instruction _setArrayItem;
    private Instruction _typeIs;
    private Instruction _defaultValue;
    private Instruction _newArray;
    private Instruction _typeAs;
    private Instruction[] _newArrayInit;
    private static int MaxArrayInitElementCountCache;
    private static InstructionFactory`1();
    protected internal virtual Instruction GetArrayItem();
    protected internal virtual Instruction SetArrayItem();
    protected internal virtual Instruction TypeIs();
    protected internal virtual Instruction TypeAs();
    protected internal virtual Instruction DefaultValue();
    protected internal virtual Instruction NewArray();
    protected internal virtual Instruction NewArrayInit(int elementCount);
}
[DebuggerTypeProxyAttribute("System.Management.Automation.Interpreter.InstructionList/DebugView")]
internal class System.Management.Automation.Interpreter.InstructionList : object {
    private List`1<Instruction> _instructions;
    private List`1<object> _objects;
    private int _currentStackDepth;
    private int _maxStackDepth;
    private int _currentContinuationsDepth;
    private int _maxContinuationDepth;
    private int _runtimeLabelCount;
    private List`1<BranchLabel> _labels;
    private List`1<KeyValuePair`2<int, object>> _debugCookies;
    private static int PushIntMinCachedValue;
    private static int PushIntMaxCachedValue;
    private static int CachedObjectCount;
    private static Instruction s_null;
    private static Instruction s_true;
    private static Instruction s_false;
    private static Instruction[] s_ints;
    private static Instruction[] s_loadObjectCached;
    private static int LocalInstrCacheSize;
    private static Instruction[] s_loadLocal;
    private static Instruction[] s_loadLocalBoxed;
    private static Instruction[] s_loadLocalFromClosure;
    private static Instruction[] s_loadLocalFromClosureBoxed;
    private static Instruction[] s_assignLocal;
    private static Instruction[] s_storeLocal;
    private static Instruction[] s_assignLocalBoxed;
    private static Instruction[] s_storeLocalBoxed;
    private static Instruction[] s_assignLocalToClosure;
    private static Instruction[] s_initReference;
    private static Instruction[] s_initImmutableRefBox;
    private static Instruction[] s_parameterBox;
    private static Instruction[] s_parameter;
    private static Dictionary`2<FieldInfo, Instruction> s_loadFields;
    private static Dictionary`2<Type, Func`2<CallSiteBinder, Instruction>> s_factories;
    private static RuntimeLabel[] s_emptyRuntimeLabels;
    public int Count { get; }
    public int CurrentStackDepth { get; }
    public int CurrentContinuationsDepth { get; }
    public int MaxStackDepth { get; }
    private static InstructionList();
    public void Emit(Instruction instruction);
    private void UpdateStackDepth(Instruction instruction);
    [ConditionalAttribute("DEBUG")]
public void SetDebugCookie(object cookie);
    public int get_Count();
    public int get_CurrentStackDepth();
    public int get_CurrentContinuationsDepth();
    public int get_MaxStackDepth();
    internal Instruction GetInstruction(int index);
    public InstructionArray ToArray();
    public void EmitLoad(object value);
    public void EmitLoad(bool value);
    public void EmitLoad(object value, Type type);
    public void EmitDup();
    public void EmitPop();
    internal void SwitchToBoxed(int index, int instructionIndex);
    public void EmitLoadLocal(int index);
    public void EmitLoadLocalBoxed(int index);
    internal static Instruction LoadLocalBoxed(int index);
    public void EmitLoadLocalFromClosure(int index);
    public void EmitLoadLocalFromClosureBoxed(int index);
    public void EmitAssignLocal(int index);
    public void EmitStoreLocal(int index);
    public void EmitAssignLocalBoxed(int index);
    internal static Instruction AssignLocalBoxed(int index);
    public void EmitStoreLocalBoxed(int index);
    internal static Instruction StoreLocalBoxed(int index);
    public void EmitAssignLocalToClosure(int index);
    public void EmitStoreLocalToClosure(int index);
    public void EmitInitializeLocal(int index, Type type);
    internal void EmitInitializeParameter(int index);
    internal static Instruction Parameter(int index);
    internal static Instruction ParameterBox(int index);
    internal static Instruction InitReference(int index);
    internal static Instruction InitImmutableRefBox(int index);
    public void EmitNewRuntimeVariables(int count);
    public void EmitGetArrayItem(Type arrayType);
    public void EmitSetArrayItem(Type arrayType);
    public void EmitNewArray(Type elementType);
    public void EmitNewArrayBounds(Type elementType, int rank);
    public void EmitNewArrayInit(Type elementType, int elementCount);
    public void EmitAdd(Type type, bool checked);
    public void EmitSub(Type type, bool checked);
    public void EmitMul(Type type, bool checked);
    public void EmitDiv(Type type);
    public void EmitEqual(Type type);
    public void EmitNotEqual(Type type);
    public void EmitLessThan(Type type);
    public void EmitLessThanOrEqual(Type type);
    public void EmitGreaterThan(Type type);
    public void EmitGreaterThanOrEqual(Type type);
    public void EmitNumericConvertChecked(TypeCode from, TypeCode to);
    public void EmitNumericConvertUnchecked(TypeCode from, TypeCode to);
    public void EmitNot();
    public void EmitDefaultValue(Type type);
    public void EmitNew(ConstructorInfo constructorInfo);
    internal void EmitCreateDelegate(LightDelegateCreator creator);
    public void EmitTypeEquals();
    public void EmitTypeIs(Type type);
    public void EmitTypeAs(Type type);
    public void EmitLoadField(FieldInfo field);
    private static Instruction GetLoadField(FieldInfo field);
    public void EmitStoreField(FieldInfo field);
    public void EmitCall(MethodInfo method);
    public void EmitCall(MethodInfo method, ParameterInfo[] parameters);
    public void EmitDynamic(Type type, CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    public void EmitDynamic(CallSiteBinder binder);
    internal static Instruction CreateDynamicInstruction(Type delegateType, CallSiteBinder binder);
    private RuntimeLabel[] BuildRuntimeLabels();
    public BranchLabel MakeLabel();
    internal void FixupBranch(int branchIndex, int offset);
    private int EnsureLabelIndex(BranchLabel label);
    public int MarkRuntimeLabel();
    public void MarkLabel(BranchLabel label);
    public void EmitGoto(BranchLabel label, bool hasResult, bool hasValue);
    private void EmitBranch(OffsetInstruction instruction, BranchLabel label);
    public void EmitBranch(BranchLabel label);
    public void EmitBranch(BranchLabel label, bool hasResult, bool hasValue);
    public void EmitCoalescingBranch(BranchLabel leftNotNull);
    public void EmitBranchTrue(BranchLabel elseLabel);
    public void EmitBranchFalse(BranchLabel elseLabel);
    public void EmitThrow();
    public void EmitThrowVoid();
    public void EmitRethrow();
    public void EmitRethrowVoid();
    public void EmitEnterTryFinally(BranchLabel finallyStartLabel);
    public void EmitEnterTryCatch();
    public void EmitEnterFinally(BranchLabel finallyStartLabel);
    public void EmitLeaveFinally();
    public void EmitLeaveFault(bool hasValue);
    public void EmitEnterExceptionHandlerNonVoid();
    public void EmitEnterExceptionHandlerVoid();
    public void EmitLeaveExceptionHandler(bool hasValue, BranchLabel tryExpressionEndLabel);
    public void EmitSwitch(Dictionary`2<int, int> cases);
}
internal class System.Management.Automation.Interpreter.InterpretedFrame : object {
    public static ThreadLocal`1<InterpretedFrame> CurrentFrame;
    internal Interpreter Interpreter;
    internal InterpretedFrame _parent;
    private Int32[] _continuations;
    private int _continuationIndex;
    private int _pendingContinuation;
    private object _pendingValue;
    public Object[] Data;
    public StrongBox`1[] Closure;
    public int StackIndex;
    public int InstructionIndex;
    private static MethodInfo s_goto;
    private static MethodInfo s_voidGoto;
    public string Name { get; }
    public ExecutionContext ExecutionContext { get; }
    public FunctionContext FunctionContext { get; }
    public InterpretedFrame Parent { get; }
    internal static MethodInfo GotoMethod { get; }
    internal static MethodInfo VoidGotoMethod { get; }
    internal InterpretedFrame(Interpreter interpreter, StrongBox`1[] closure);
    private static InterpretedFrame();
    public DebugInfo GetDebugInfo(int instructionIndex);
    public string get_Name();
    public void Push(object value);
    public void Push(bool value);
    public void Push(int value);
    public object Pop();
    internal void SetStackDepth(int depth);
    public object Peek();
    public void Dup();
    public ExecutionContext get_ExecutionContext();
    public FunctionContext get_FunctionContext();
    public InterpretedFrame get_Parent();
    public static bool IsInterpretedFrame(MethodBase method);
    [IteratorStateMachineAttribute("System.Management.Automation.Interpreter.InterpretedFrame/<GroupStackFrames>d__29")]
public static IEnumerable`1<StackFrame> GroupStackFrames(IEnumerable`1<StackFrame> stackTrace);
    [IteratorStateMachineAttribute("System.Management.Automation.Interpreter.InterpretedFrame/<GetStackTraceDebugInfo>d__30")]
public IEnumerable`1<InterpretedFrameInfo> GetStackTraceDebugInfo();
    internal void SaveTraceToException(Exception exception);
    public static InterpretedFrameInfo[] GetExceptionStackTrace(Exception exception);
    internal StorageInfo<InterpretedFrame> Enter();
    internal void Leave(StorageInfo<InterpretedFrame> currentFrame);
    internal bool IsJumpHappened();
    public void RemoveContinuation();
    public void PushContinuation(int continuation);
    public int YieldToCurrentContinuation();
    public int YieldToPendingContinuation();
    internal void PushPendingContinuation();
    internal void PopPendingContinuation();
    internal static MethodInfo get_GotoMethod();
    internal static MethodInfo get_VoidGotoMethod();
    public int VoidGoto(int labelIndex);
    public int Goto(int labelIndex, object value, bool gotoExceptionHandler);
}
[IsReadOnlyAttribute]
internal class System.Management.Automation.Interpreter.InterpretedFrameInfo : ValueType {
    public string MethodName;
    public DebugInfo DebugInfo;
    public InterpretedFrameInfo(string methodName, DebugInfo info);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.Interpreter : object {
    internal static object NoValue;
    internal static int RethrowOnReturn;
    internal int _compilationThreshold;
    internal Object[] _objects;
    internal RuntimeLabel[] _labels;
    internal string _name;
    internal DebugInfo[] _debugInfos;
    [CompilerGeneratedAttribute]
private int <LocalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private InstructionArray <Instructions>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<ParameterExpression, LocalVariable> <ClosureVariables>k__BackingField;
    [CompilerGeneratedAttribute]
private HybridReferenceDictionary`2<LabelTarget, BranchLabel> <LabelMapping>k__BackingField;
    internal int ClosureSize { get; }
    internal int LocalCount { get; }
    internal bool CompileSynchronously { get; }
    internal InstructionArray Instructions { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> LabelMapping { get; }
    internal Interpreter(string name, LocalVariables locals, HybridReferenceDictionary`2<LabelTarget, BranchLabel> labelMapping, InstructionArray instructions, DebugInfo[] debugInfos, int compilationThreshold);
    private static Interpreter();
    internal int get_ClosureSize();
    [CompilerGeneratedAttribute]
internal int get_LocalCount();
    internal bool get_CompileSynchronously();
    [CompilerGeneratedAttribute]
internal InstructionArray get_Instructions();
    [CompilerGeneratedAttribute]
internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    [CompilerGeneratedAttribute]
internal HybridReferenceDictionary`2<LabelTarget, BranchLabel> get_LabelMapping();
    public void Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LabelInfo : object {
    private LabelTarget _node;
    private BranchLabel _label;
    private object _definitions;
    private List`1<LabelScopeInfo> _references;
    private bool _acrossBlockJump;
    private bool HasDefinitions { get; }
    private bool HasMultipleDefinitions { get; }
    internal LabelInfo(LabelTarget node);
    internal BranchLabel GetLabel(LightCompiler compiler);
    internal void Reference(LabelScopeInfo block);
    internal void Define(LabelScopeInfo block);
    private void ValidateJump(LabelScopeInfo reference);
    internal void ValidateFinish();
    private void EnsureLabel(LightCompiler compiler);
    private bool DefinedIn(LabelScopeInfo scope);
    private bool get_HasDefinitions();
    private LabelScopeInfo FirstDefinition();
    private void AddDefinition(LabelScopeInfo scope);
    private bool get_HasMultipleDefinitions();
    internal static T CommonNode(T first, T second, Func`2<T, T> parent);
}
internal class System.Management.Automation.Interpreter.LabelScopeInfo : object {
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _labels;
    internal LabelScopeKind Kind;
    internal LabelScopeInfo Parent;
    internal bool CanJumpInto { get; }
    internal LabelScopeInfo(LabelScopeInfo parent, LabelScopeKind kind);
    internal bool get_CanJumpInto();
    internal bool ContainsTarget(LabelTarget target);
    internal bool TryGetLabelInfo(LabelTarget target, LabelInfo& info);
    internal void AddLabelInfo(LabelTarget target, LabelInfo info);
}
internal enum System.Management.Automation.Interpreter.LabelScopeKind : Enum {
    public int value__;
    public static LabelScopeKind Statement;
    public static LabelScopeKind Block;
    public static LabelScopeKind Switch;
    public static LabelScopeKind Lambda;
    public static LabelScopeKind Try;
    public static LabelScopeKind Catch;
    public static LabelScopeKind Finally;
    public static LabelScopeKind Filter;
    public static LabelScopeKind Expression;
}
internal class System.Management.Automation.Interpreter.LeaveExceptionHandlerInstruction : IndexedBranchInstruction {
    private static LeaveExceptionHandlerInstruction[] s_cache;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveExceptionHandlerInstruction(int labelIndex, bool hasValue);
    private static LeaveExceptionHandlerInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    internal static LeaveExceptionHandlerInstruction Create(int labelIndex, bool hasValue);
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LeaveFaultInstruction : Instruction {
    internal static Instruction NonVoid;
    internal static Instruction Void;
    private bool _hasValue;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private LeaveFaultInstruction(bool hasValue);
    private static LeaveFaultInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LeaveFinallyInstruction : Instruction {
    internal static Instruction Instance;
    public int ConsumedStack { get; }
    private static LeaveFinallyInstruction();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.LessThanInstruction : Instruction {
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.LightCompiler : object {
    internal static int DefaultCompilationThreshold;
    private int _compilationThreshold;
    private InstructionList _instructions;
    private LocalVariables _locals;
    private List`1<DebugInfo> _debugInfos;
    private HybridReferenceDictionary`2<LabelTarget, LabelInfo> _treeLabels;
    private LabelScopeInfo _labelBlock;
    private Stack`1<ParameterExpression> _exceptionForRethrowStack;
    private bool _forceCompile;
    private LightCompiler _parent;
    private static LocalDefinition[] s_emptyLocals;
    public InstructionList Instructions { get; }
    public LocalVariables Locals { get; }
    public LightCompiler(int compilationThreshold);
    private LightCompiler(LightCompiler parent);
    private static LightCompiler();
    public InstructionList get_Instructions();
    public LocalVariables get_Locals();
    internal static Expression Unbox(Expression strongBoxExpression);
    public LightDelegateCreator CompileTop(LambdaExpression node);
    private Interpreter MakeInterpreter(string lambdaName);
    private void CompileConstantExpression(Expression expr);
    private void CompileDefaultExpression(Expression expr);
    private void CompileDefaultExpression(Type type);
    private LocalVariable EnsureAvailableForClosure(ParameterExpression expr);
    private LocalVariable ResolveLocal(ParameterExpression variable);
    public void CompileGetVariable(ParameterExpression variable);
    public void CompileGetBoxedVariable(ParameterExpression variable);
    public void CompileSetVariable(ParameterExpression variable, bool isVoid);
    public void CompileParameterExpression(Expression expr);
    private void CompileBlockExpression(Expression expr, bool asVoid);
    private LocalDefinition[] CompileBlockStart(BlockExpression node);
    private void CompileBlockEnd(LocalDefinition[] locals);
    private void CompileIndexExpression(Expression expr);
    private void CompileIndexAssignment(BinaryExpression node, bool asVoid);
    private void CompileMemberAssignment(BinaryExpression node, bool asVoid);
    private void CompileVariableAssignment(BinaryExpression node, bool asVoid);
    private void CompileAssignBinaryExpression(Expression expr, bool asVoid);
    private void CompileBinaryExpression(Expression expr);
    private void CompileEqual(Expression left, Expression right);
    private void CompileNotEqual(Expression left, Expression right);
    private void CompileComparison(ExpressionType nodeType, Expression left, Expression right);
    private void CompileArithmetic(ExpressionType nodeType, Expression left, Expression right);
    private void CompileConvertUnaryExpression(Expression expr);
    private void CompileConvertToType(Type typeFrom, Type typeTo, bool isChecked);
    private void CompileNotExpression(UnaryExpression node);
    private void CompileUnaryExpression(Expression expr);
    private void CompileAndAlsoBinaryExpression(Expression expr);
    private void CompileOrElseBinaryExpression(Expression expr);
    private void CompileLogicalBinaryExpression(Expression expr, bool andAlso);
    private void CompileConditionalExpression(Expression expr, bool asVoid);
    private static void CompileLoopExpression(Expression expr);
    private void CompileSwitchExpression(Expression expr);
    private void CompileLabelExpression(Expression expr);
    private void CompileGotoExpression(Expression expr);
    public BranchLabel GetBranchLabel(LabelTarget target);
    public void PushLabelBlock(LabelScopeKind type);
    public void PopLabelBlock(LabelScopeKind kind);
    private LabelInfo EnsureLabel(LabelTarget node);
    private LabelInfo ReferenceLabel(LabelTarget node);
    internal LabelInfo DefineLabel(LabelTarget node);
    private bool TryPushLabelBlock(Expression node);
    private void DefineBlockLabels(Expression node);
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> GetBranchMapping();
    private void CompileThrowUnaryExpression(Expression expr, bool asVoid);
    private static bool EndsWithRethrow(Expression expr);
    private void CompileAsVoidRemoveRethrow(Expression expr);
    private void CompileTryExpression(Expression expr);
    private void CompileDynamicExpression(Expression expr);
    private void CompileMethodCallExpression(Expression expr);
    private void CompileNewExpression(Expression expr);
    private void CompileMemberExpression(Expression expr);
    private void CompileNewArrayExpression(Expression expr);
    private void CompileExtensionExpression(Expression expr);
    private void CompileDebugInfoExpression(Expression expr);
    private void CompileRuntimeVariablesExpression(Expression expr);
    private void CompileLambdaExpression(Expression expr);
    private void CompileCoalesceBinaryExpression(Expression expr);
    private void CompileInvocationExpression(Expression expr);
    private void CompileListInitExpression(Expression expr);
    private void CompileMemberInitExpression(Expression expr);
    private void CompileQuoteUnaryExpression(Expression expr);
    private void CompileUnboxUnaryExpression(Expression expr);
    private void CompileTypeEqualExpression(Expression expr);
    private void CompileTypeAsExpression(UnaryExpression node);
    private void CompileTypeIsExpression(Expression expr);
    private void CompileReducibleExpression(Expression expr);
    internal void Compile(Expression expr, bool asVoid);
    internal void CompileAsVoid(Expression expr);
    private void CompileNoLabelPush(Expression expr);
    public void Compile(Expression expr);
}
internal class System.Management.Automation.Interpreter.LightDelegateCreator : object {
    private Interpreter _interpreter;
    private Expression _lambda;
    private Type _compiledDelegateType;
    private Delegate _compiled;
    private object _compileLock;
    internal Interpreter Interpreter { get; }
    private bool HasClosure { get; }
    internal bool HasCompiled { get; }
    internal bool SameDelegateType { get; }
    private Type DelegateType { get; }
    internal LightDelegateCreator(Interpreter interpreter, LambdaExpression lambda);
    internal Interpreter get_Interpreter();
    private bool get_HasClosure();
    internal bool get_HasCompiled();
    internal bool get_SameDelegateType();
    public Delegate CreateDelegate();
    internal Delegate CreateDelegate(StrongBox`1[] closure);
    private Type get_DelegateType();
    internal Delegate CreateCompiledDelegate(StrongBox`1[] closure);
    internal void Compile(object state);
    private static Type GetFuncOrAction(LambdaExpression lambda);
}
internal class System.Management.Automation.Interpreter.LightLambda : object {
    private StrongBox`1[] _closure;
    private Interpreter _interpreter;
    private static CacheDict`2<Type, Func`2<LightLambda, Delegate>> s_runCache;
    private LightDelegateCreator _delegateCreator;
    private Delegate _compiled;
    private int _compilationThreshold;
    [CompilerGeneratedAttribute]
private EventHandler`1<LightLambdaCompileEventArgs> Compile;
    internal static int MaxParameters;
    internal LightLambda(LightDelegateCreator delegateCreator, StrongBox`1[] closure, int compilationThreshold);
    private static LightLambda();
    [CompilerGeneratedAttribute]
public void add_Compile(EventHandler`1<LightLambdaCompileEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Compile(EventHandler`1<LightLambdaCompileEventArgs> value);
    private static Func`2<LightLambda, Delegate> GetRunDelegateCtor(Type delegateType);
    private static Func`2<LightLambda, Delegate> MakeRunDelegateCtor(Type delegateType);
    private Delegate CreateCustomDelegate(Type delegateType);
    internal Delegate MakeDelegate(Type delegateType);
    private bool TryGetCompiled();
    private InterpretedFrame MakeFrame();
    internal void RunVoidRef2(T0& arg0, T1& arg1);
    public object Run(Object[] arguments);
    internal TRet Run0();
    internal void RunVoid0();
    internal static Delegate MakeRun0(LightLambda lambda);
    internal static Delegate MakeRunVoid0(LightLambda lambda);
    internal TRet Run1(T0 arg0);
    internal void RunVoid1(T0 arg0);
    internal static Delegate MakeRun1(LightLambda lambda);
    internal static Delegate MakeRunVoid1(LightLambda lambda);
    internal TRet Run2(T0 arg0, T1 arg1);
    internal void RunVoid2(T0 arg0, T1 arg1);
    internal static Delegate MakeRun2(LightLambda lambda);
    internal static Delegate MakeRunVoid2(LightLambda lambda);
    internal TRet Run3(T0 arg0, T1 arg1, T2 arg2);
    internal void RunVoid3(T0 arg0, T1 arg1, T2 arg2);
    internal static Delegate MakeRun3(LightLambda lambda);
    internal static Delegate MakeRunVoid3(LightLambda lambda);
    internal TRet Run4(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    internal void RunVoid4(T0 arg0, T1 arg1, T2 arg2, T3 arg3);
    internal static Delegate MakeRun4(LightLambda lambda);
    internal static Delegate MakeRunVoid4(LightLambda lambda);
    internal TRet Run5(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    internal void RunVoid5(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4);
    internal static Delegate MakeRun5(LightLambda lambda);
    internal static Delegate MakeRunVoid5(LightLambda lambda);
    internal TRet Run6(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    internal void RunVoid6(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5);
    internal static Delegate MakeRun6(LightLambda lambda);
    internal static Delegate MakeRunVoid6(LightLambda lambda);
    internal TRet Run7(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    internal void RunVoid7(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6);
    internal static Delegate MakeRun7(LightLambda lambda);
    internal static Delegate MakeRunVoid7(LightLambda lambda);
    internal TRet Run8(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    internal void RunVoid8(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7);
    internal static Delegate MakeRun8(LightLambda lambda);
    internal static Delegate MakeRunVoid8(LightLambda lambda);
    internal TRet Run9(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    internal void RunVoid9(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8);
    internal static Delegate MakeRun9(LightLambda lambda);
    internal static Delegate MakeRunVoid9(LightLambda lambda);
    internal TRet Run10(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    internal void RunVoid10(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9);
    internal static Delegate MakeRun10(LightLambda lambda);
    internal static Delegate MakeRunVoid10(LightLambda lambda);
    internal TRet Run11(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    internal void RunVoid11(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10);
    internal static Delegate MakeRun11(LightLambda lambda);
    internal static Delegate MakeRunVoid11(LightLambda lambda);
    internal TRet Run12(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    internal void RunVoid12(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11);
    internal static Delegate MakeRun12(LightLambda lambda);
    internal static Delegate MakeRunVoid12(LightLambda lambda);
    internal TRet Run13(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    internal void RunVoid13(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12);
    internal static Delegate MakeRun13(LightLambda lambda);
    internal static Delegate MakeRunVoid13(LightLambda lambda);
    internal TRet Run14(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    internal void RunVoid14(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13);
    internal static Delegate MakeRun14(LightLambda lambda);
    internal static Delegate MakeRunVoid14(LightLambda lambda);
    internal TRet Run15(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    internal void RunVoid15(T0 arg0, T1 arg1, T2 arg2, T3 arg3, T4 arg4, T5 arg5, T6 arg6, T7 arg7, T8 arg8, T9 arg9, T10 arg10, T11 arg11, T12 arg12, T13 arg13, T14 arg14);
    internal static Delegate MakeRun15(LightLambda lambda);
    internal static Delegate MakeRunVoid15(LightLambda lambda);
}
internal class System.Management.Automation.Interpreter.LightLambdaClosureVisitor : ExpressionVisitor {
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVars;
    private ParameterExpression _closureArray;
    private Stack`1<HashSet`1<ParameterExpression>> _shadowedVars;
    private LightLambdaClosureVisitor(Dictionary`2<ParameterExpression, LocalVariable> closureVariables, ParameterExpression closureArray);
    internal static Func`2<StrongBox`1[], Delegate> BindLambda(LambdaExpression lambda, Dictionary`2<ParameterExpression, LocalVariable> closureVariables);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    protected virtual Expression VisitBlock(BlockExpression node);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitRuntimeVariables(RuntimeVariablesExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    protected virtual Expression VisitBinary(BinaryExpression node);
    private Expression GetClosureItem(ParameterExpression variable, bool unbox);
    protected virtual Expression VisitExtension(Expression node);
}
internal class System.Management.Automation.Interpreter.LightLambdaCompileEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Delegate <Compiled>k__BackingField;
    public Delegate Compiled { get; }
    internal LightLambdaCompileEventArgs(Delegate compiled);
    [CompilerGeneratedAttribute]
public Delegate get_Compiled();
}
internal class System.Management.Automation.Interpreter.ListEqualityComparer`1 : EqualityComparer`1<ICollection`1<T>> {
    internal static ListEqualityComparer`1<T> Instance;
    private static ListEqualityComparer`1();
    public virtual bool Equals(ICollection`1<T> x, ICollection`1<T> y);
    public virtual int GetHashCode(ICollection`1<T> obj);
}
internal class System.Management.Automation.Interpreter.LoadCachedObjectInstruction : Instruction {
    private UInt32 _index;
    public int ProducedStack { get; }
    internal LoadCachedObjectInstruction(UInt32 index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.LoadFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public LoadFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LoadLocalBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LoadLocalFromClosureBoxedInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalFromClosureBoxedInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LoadLocalFromClosureInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalFromClosureInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.LoadLocalInstruction : LocalAccessInstruction {
    public int ProducedStack { get; }
    internal LoadLocalInstruction(int index);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Management.Automation.Interpreter.LoadObjectInstruction : Instruction {
    private object _value;
    public int ProducedStack { get; }
    internal LoadObjectInstruction(object value);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.LoadStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ProducedStack { get; }
    public LoadStaticFieldInstruction(FieldInfo field);
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.LocalAccessInstruction : Instruction {
    internal int _index;
    protected LocalAccessInstruction(int index);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
}
[IsReadOnlyAttribute]
internal class System.Management.Automation.Interpreter.LocalDefinition : ValueType {
    private int _index;
    private ParameterExpression _parameter;
    public int Index { get; }
    public ParameterExpression Parameter { get; }
    internal LocalDefinition(int localIndex, ParameterExpression parameter);
    public int get_Index();
    public ParameterExpression get_Parameter();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LocalDefinition self, LocalDefinition other);
    public static bool op_Inequality(LocalDefinition self, LocalDefinition other);
}
internal class System.Management.Automation.Interpreter.LocalVariable : object {
    private static int IsBoxedFlag;
    private static int InClosureFlag;
    public int Index;
    private int _flags;
    public bool IsBoxed { get; public set; }
    public bool InClosure { get; }
    public bool InClosureOrBoxed { get; }
    internal LocalVariable(int index, bool closure, bool boxed);
    public bool get_IsBoxed();
    public void set_IsBoxed(bool value);
    public bool get_InClosure();
    public bool get_InClosureOrBoxed();
    internal Expression LoadFromArray(Expression frameData, Expression closure);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.LocalVariables : object {
    private HybridReferenceDictionary`2<ParameterExpression, VariableScope> _variables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private int _localCount;
    private int _maxLocalCount;
    public int LocalCount { get; }
    internal Dictionary`2<ParameterExpression, LocalVariable> ClosureVariables { get; }
    public LocalDefinition DefineLocal(ParameterExpression variable, int start);
    public void UndefineLocal(LocalDefinition definition, int end);
    internal void Box(ParameterExpression variable, InstructionList instructions);
    public int get_LocalCount();
    public int GetOrDefineLocal(ParameterExpression var);
    public int GetLocalIndex(ParameterExpression var);
    public bool TryGetLocalOrClosure(ParameterExpression var, LocalVariable& local);
    internal Dictionary`2<ParameterExpression, LocalVariable> CopyLocals();
    internal bool ContainsVariable(ParameterExpression variable);
    internal Dictionary`2<ParameterExpression, LocalVariable> get_ClosureVariables();
    internal LocalVariable AddClosureVariable(ParameterExpression variable);
}
internal class System.Management.Automation.Interpreter.LoopCompiler : ExpressionVisitor {
    private ParameterExpression _frameDataVar;
    private ParameterExpression _frameClosureVar;
    private ParameterExpression _frameVar;
    private LabelTarget _returnLabel;
    private Dictionary`2<ParameterExpression, LocalVariable> _outerVariables;
    private Dictionary`2<ParameterExpression, LocalVariable> _closureVariables;
    private PowerShellLoopExpression _loop;
    private List`1<ParameterExpression> _temps;
    private Dictionary`2<ParameterExpression, LoopVariable> _loopVariables;
    private HashSet`1<ParameterExpression> _loopLocals;
    private HybridReferenceDictionary`2<LabelTarget, BranchLabel> _labelMapping;
    private int _loopStartInstructionIndex;
    private int _loopEndInstructionIndex;
    internal LoopCompiler(PowerShellLoopExpression loop, HybridReferenceDictionary`2<LabelTarget, BranchLabel> labelMapping, Dictionary`2<ParameterExpression, LocalVariable> locals, Dictionary`2<ParameterExpression, LocalVariable> closureVariables, int loopStartInstructionIndex, int loopEndInstructionIndex);
    internal Func`4<Object[], StrongBox`1[], InterpretedFrame, int> CreateDelegate();
    protected virtual Expression VisitExtension(Expression node);
    protected virtual Expression VisitGoto(GotoExpression node);
    protected virtual Expression VisitBlock(BlockExpression node);
    private HashSet`1<ParameterExpression> EnterVariableScope(ICollection`1<ParameterExpression> variables);
    protected virtual CatchBlock VisitCatchBlock(CatchBlock node);
    protected virtual Expression VisitLambda(Expression`1<T> node);
    private void ExitVariableScope(HashSet`1<ParameterExpression> prevLocals);
    protected virtual Expression VisitBinary(BinaryExpression node);
    protected virtual Expression VisitUnary(UnaryExpression node);
    protected virtual Expression VisitParameter(ParameterExpression node);
    private Expression VisitVariable(ParameterExpression node, ExpressionAccess access);
    private ParameterExpression AddTemp(ParameterExpression variable);
}
internal class System.Management.Automation.Interpreter.MethodInfoCallInstruction : CallInstruction {
    private MethodInfo _target;
    private int _argumentCount;
    public MethodInfo Info { get; }
    public int ArgumentCount { get; }
    internal MethodInfoCallInstruction(MethodInfo target, int argumentCount);
    public virtual MethodInfo get_Info();
    public virtual int get_ArgumentCount();
    public virtual object Invoke(Object[] args);
    public virtual object InvokeInstance(object instance, Object[] args);
    private object InvokeWorker(Object[] args);
    private static Object[] GetNonStaticArgs(Object[] args);
    public sealed virtual int Run(InterpretedFrame frame);
    public virtual object Invoke();
    public virtual object Invoke(object arg0);
    public virtual object Invoke(object arg0, object arg1);
}
internal abstract class System.Management.Automation.Interpreter.MulInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.MulOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.NewArrayBoundsInstruction : Instruction {
    private Type _elementType;
    private int _rank;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal NewArrayBoundsInstruction(Type elementType, int rank);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.NewArrayInitInstruction`1 : Instruction {
    private int _elementCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal NewArrayInitInstruction`1(int elementCount);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.NewArrayInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.NewInstruction : Instruction {
    private ConstructorInfo _constructor;
    private int _argCount;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public NewInstruction(ConstructorInfo constructor);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.NotEqualInstruction : Instruction {
    private static Instruction s_reference;
    private static Instruction s_boolean;
    private static Instruction s_SByte;
    private static Instruction s_int16;
    private static Instruction s_char;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_byte;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.NotInstruction : Instruction {
    public static Instruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    private static NotInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.NumericConvertInstruction : Instruction {
    internal TypeCode _from;
    internal TypeCode _to;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    protected NumericConvertInstruction(TypeCode from, TypeCode to);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.OffsetInstruction : Instruction {
    internal static int Unknown;
    internal static int CacheSize;
    protected int _offset;
    public int Offset { get; }
    public Instruction[] Cache { get; }
    public int get_Offset();
    public abstract virtual Instruction[] get_Cache();
    public Instruction Fixup(int offset);
    public virtual string ToDebugString(int instructionIndex, object cookie, Func`2<int, int> labelIndexer, IList`1<object> objects);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.PopInstruction : Instruction {
    internal static PopInstruction Instance;
    public int ConsumedStack { get; }
    private static PopInstruction();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.RethrowException : SystemException {
}
[IsReadOnlyAttribute]
internal class System.Management.Automation.Interpreter.RuntimeLabel : ValueType {
    public int Index;
    public int StackDepth;
    public int ContinuationStackDepth;
    public RuntimeLabel(int index, int continuationStackDepth, int stackDepth);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.RuntimeVariables : object {
    private IStrongBox[] _boxes;
    private int System.Runtime.CompilerServices.IRuntimeVariables.Count { get; }
    private object System.Runtime.CompilerServices.IRuntimeVariables.Item { get; private set; }
    private RuntimeVariables(IStrongBox[] boxes);
    private sealed virtual override int System.Runtime.CompilerServices.IRuntimeVariables.get_Count();
    private sealed virtual override object System.Runtime.CompilerServices.IRuntimeVariables.get_Item(int index);
    private sealed virtual override void System.Runtime.CompilerServices.IRuntimeVariables.set_Item(int index, object value);
    internal static IRuntimeVariables Create(IStrongBox[] boxes);
}
internal class System.Management.Automation.Interpreter.RuntimeVariablesInstruction : Instruction {
    private int _count;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    public RuntimeVariablesInstruction(int count);
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal static class System.Management.Automation.Interpreter.ScriptingRuntimeHelpers : object {
    internal static MethodInfo BooleanToObjectMethod;
    internal static MethodInfo Int32ToObjectMethod;
    internal static object True;
    internal static object False;
    private static ScriptingRuntimeHelpers();
    internal static object Int32ToObject(int i);
    internal static object BooleanToObject(bool b);
    internal static object GetPrimitiveDefaultValue(Type type);
}
internal class System.Management.Automation.Interpreter.SetArrayItemInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class System.Management.Automation.Interpreter.StoreFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.StoreLocalBoxedInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal StoreLocalBoxedInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.StoreLocalInstruction : LocalAccessInstruction {
    public int ConsumedStack { get; }
    internal StoreLocalInstruction(int index);
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
    public sealed virtual Instruction BoxIfIndexMatches(int index);
}
internal class System.Management.Automation.Interpreter.StoreStaticFieldInstruction : Instruction {
    private FieldInfo _field;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public StoreStaticFieldInstruction(FieldInfo field);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal abstract class System.Management.Automation.Interpreter.SubInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal abstract class System.Management.Automation.Interpreter.SubOvfInstruction : Instruction {
    private static Instruction s_int16;
    private static Instruction s_int32;
    private static Instruction s_int64;
    private static Instruction s_UInt16;
    private static Instruction s_UInt32;
    private static Instruction s_UInt64;
    private static Instruction s_single;
    private static Instruction s_double;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public static Instruction Create(Type type);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.SwitchInstruction : Instruction {
    private Dictionary`2<int, int> _cases;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    internal SwitchInstruction(Dictionary`2<int, int> cases);
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.ThreadLocal`1 : object {
    private StorageInfo[] _stores;
    private static StorageInfo[] s_updating;
    private bool _refCounted;
    public T Value { get; public set; }
    public ThreadLocal`1(bool refCounted);
    private static ThreadLocal`1();
    public T get_Value();
    public void set_Value(T value);
    public T GetOrCreate(Func`1<T> func);
    public T Update(Func`2<T, T> updater);
    public T Update(T newValue);
    public StorageInfo<T> GetStorageInfo();
    private StorageInfo<T> GetStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> RetryOrCreateStorageInfo(StorageInfo[] curStorage);
    private StorageInfo<T> CreateStorageInfo();
}
internal class System.Management.Automation.Interpreter.ThrowInstruction : Instruction {
    internal static ThrowInstruction Throw;
    internal static ThrowInstruction VoidThrow;
    internal static ThrowInstruction Rethrow;
    internal static ThrowInstruction VoidRethrow;
    private bool _hasResult;
    private bool _rethrow;
    public int ProducedStack { get; }
    public int ConsumedStack { get; }
    private ThrowInstruction(bool hasResult, bool isRethrow);
    private static ThrowInstruction();
    public virtual int get_ProducedStack();
    public virtual int get_ConsumedStack();
    public virtual int Run(InterpretedFrame frame);
}
internal class System.Management.Automation.Interpreter.TryCatchFinallyHandler : object {
    internal int TryStartIndex;
    internal int TryEndIndex;
    internal int FinallyStartIndex;
    internal int FinallyEndIndex;
    internal int GotoEndTargetIndex;
    private ExceptionHandler[] _handlers;
    internal bool IsFinallyBlockExist { get; }
    internal bool IsCatchBlockExist { get; }
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndTargetIndex, ExceptionHandler[] handlers);
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndTargetIndex, int finallyStart, int finallyEnd);
    internal TryCatchFinallyHandler(int tryStart, int tryEnd, int gotoEndLabelIndex, int finallyStart, int finallyEnd, ExceptionHandler[] handlers);
    internal bool get_IsFinallyBlockExist();
    internal bool get_IsCatchBlockExist();
    internal int GotoHandler(InterpretedFrame frame, object exception, ExceptionHandler& handler);
}
internal class System.Management.Automation.Interpreter.TypeAsInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
internal class System.Management.Automation.Interpreter.TypeEqualsInstruction : Instruction {
    public static TypeEqualsInstruction Instance;
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public string InstructionName { get; }
    private static TypeEqualsInstruction();
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string get_InstructionName();
}
internal class System.Management.Automation.Interpreter.TypeIsInstruction`1 : Instruction {
    public int ConsumedStack { get; }
    public int ProducedStack { get; }
    public virtual int get_ConsumedStack();
    public virtual int get_ProducedStack();
    public virtual int Run(InterpretedFrame frame);
    public virtual string ToString();
}
[ExtensionAttribute]
internal static class System.Management.Automation.Interpreter.TypeUtils : object {
    [ExtensionAttribute]
internal static Type GetNonNullableType(Type type);
    internal static Type GetNullableType(Type type);
    internal static bool IsNullableType(Type type);
    internal static bool IsBool(Type type);
    internal static bool IsNumeric(Type type);
    internal static bool IsNumeric(TypeCode typeCode);
    internal static bool IsArithmetic(Type type);
}
internal class System.Management.Automation.Interpreter.UpdatePositionInstruction : Instruction {
    private int _sequencePoint;
    private bool _checkBreakpoints;
    private UpdatePositionInstruction(bool checkBreakpoints, int sequencePoint);
    public virtual int Run(InterpretedFrame frame);
    public static Instruction Create(int sequencePoint, bool checkBreakpoints);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Interpreter.Utils : object {
    private static DefaultExpression s_voidInstance;
    private static Utils();
    internal static Expression Constant(object value);
    public static DefaultExpression Empty();
    public static Expression Void(Expression expression);
    public static DefaultExpression Default(Type type);
    public static Expression Convert(Expression expression, Type type);
    public static Expression Box(Expression expression);
    [ExtensionAttribute]
public static bool IsReadWriteAssignment(ExpressionType type);
}
internal static class System.Management.Automation.InterpreterError : object {
    internal static RuntimeException NewInterpreterException(object targetObject, Type exceptionType, IScriptExtent errorPosition, string resourceIdAndErrorId, string resourceString, Object[] args);
    internal static RuntimeException NewInterpreterExceptionWithInnerException(object targetObject, Type exceptionType, IScriptExtent errorPosition, string resourceIdAndErrorId, string resourceString, Exception innerException, Object[] args);
    internal static RuntimeException NewInterpreterExceptionByMessage(Type exceptionType, IScriptExtent errorPosition, string message, string errorId, Exception innerException);
    private static RuntimeException NewBackupInterpreterException(Type exceptionType, IScriptExtent errorPosition, string errorId, Exception innerException);
    internal static void UpdateExceptionErrorRecordPosition(Exception exception, IScriptExtent extent);
    internal static void UpdateExceptionErrorRecordHistoryId(RuntimeException exception, ExecutionContext context);
}
internal static class System.Management.Automation.IntOps : object {
    internal static object Add(int lhs, int rhs);
    internal static object Sub(int lhs, int rhs);
    internal static object Multiply(int lhs, int rhs);
    internal static object Divide(int lhs, int rhs);
    internal static object Remainder(int lhs, int rhs);
    internal static object CompareEq(int lhs, int rhs);
    internal static object CompareNe(int lhs, int rhs);
    internal static object CompareLt(int lhs, int rhs);
    internal static object CompareLe(int lhs, int rhs);
    internal static object CompareGt(int lhs, int rhs);
    internal static object CompareGe(int lhs, int rhs);
    internal static Object[] Range(int lower, int upper);
}
public class System.Management.Automation.InvalidJobStateException : SystemException {
    private JobState _currState;
    public JobState CurrentState { get; }
    public InvalidJobStateException(string message);
    public InvalidJobStateException(string message, Exception innerException);
    public InvalidJobStateException(JobState currentState, string actionMessage);
    internal InvalidJobStateException(JobState currentState);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected InvalidJobStateException(SerializationInfo info, StreamingContext context);
    public JobState get_CurrentState();
}
public class System.Management.Automation.InvalidPowerShellStateException : SystemException {
    private PSInvocationState _currState;
    public PSInvocationState CurrentState { get; }
    public InvalidPowerShellStateException(string message);
    public InvalidPowerShellStateException(string message, Exception innerException);
    internal InvalidPowerShellStateException(PSInvocationState currentState);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected InvalidPowerShellStateException(SerializationInfo info, StreamingContext context);
    public PSInvocationState get_CurrentState();
}
[DebuggerDisplayAttribute("Command = {MyCommand}")]
public class System.Management.Automation.InvocationInfo : object {
    private IScriptExtent _scriptPosition;
    private string _invocationName;
    private Dictionary`2<string, object> _boundParameters;
    private List`1<object> _unboundArguments;
    [CompilerGeneratedAttribute]
private CommandInfo <MyCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private long <HistoryId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PipelineLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PipelinePosition>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpectingInput>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandOrigin <CommandOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <DisplayScriptPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <PipelineIterationInfo>k__BackingField;
    public CommandInfo MyCommand { get; }
    public Dictionary`2<string, object> BoundParameters { get; internal set; }
    public List`1<object> UnboundArguments { get; internal set; }
    public int ScriptLineNumber { get; }
    public int OffsetInLine { get; }
    public long HistoryId { get; internal set; }
    public string ScriptName { get; }
    public string Line { get; }
    public string Statement { get; }
    public string PositionMessage { get; }
    public string PSScriptRoot { get; }
    public string PSCommandPath { get; }
    public string InvocationName { get; internal set; }
    public int PipelineLength { get; internal set; }
    public int PipelinePosition { get; internal set; }
    public bool ExpectingInput { get; internal set; }
    public CommandOrigin CommandOrigin { get; internal set; }
    public IScriptExtent DisplayScriptPosition { get; public set; }
    internal IScriptExtent ScriptPosition { get; internal set; }
    internal Int32[] PipelineIterationInfo { get; internal set; }
    internal InvocationInfo(InternalCommand command);
    internal InvocationInfo(CommandInfo commandInfo, IScriptExtent scriptPosition);
    internal InvocationInfo(CommandInfo commandInfo, IScriptExtent scriptPosition, ExecutionContext context);
    internal InvocationInfo(PSObject psObject);
    [CompilerGeneratedAttribute]
public CommandInfo get_MyCommand();
    public Dictionary`2<string, object> get_BoundParameters();
    internal void set_BoundParameters(Dictionary`2<string, object> value);
    public List`1<object> get_UnboundArguments();
    internal void set_UnboundArguments(List`1<object> value);
    public int get_ScriptLineNumber();
    public int get_OffsetInLine();
    [CompilerGeneratedAttribute]
public long get_HistoryId();
    [CompilerGeneratedAttribute]
internal void set_HistoryId(long value);
    public string get_ScriptName();
    public string get_Line();
    public string get_Statement();
    public string get_PositionMessage();
    public string get_PSScriptRoot();
    public string get_PSCommandPath();
    public string get_InvocationName();
    internal void set_InvocationName(string value);
    [CompilerGeneratedAttribute]
public int get_PipelineLength();
    [CompilerGeneratedAttribute]
internal void set_PipelineLength(int value);
    [CompilerGeneratedAttribute]
public int get_PipelinePosition();
    [CompilerGeneratedAttribute]
internal void set_PipelinePosition(int value);
    [CompilerGeneratedAttribute]
public bool get_ExpectingInput();
    [CompilerGeneratedAttribute]
internal void set_ExpectingInput(bool value);
    [CompilerGeneratedAttribute]
public CommandOrigin get_CommandOrigin();
    [CompilerGeneratedAttribute]
internal void set_CommandOrigin(CommandOrigin value);
    [CompilerGeneratedAttribute]
public IScriptExtent get_DisplayScriptPosition();
    [CompilerGeneratedAttribute]
public void set_DisplayScriptPosition(IScriptExtent value);
    public static InvocationInfo Create(CommandInfo commandInfo, IScriptExtent scriptPosition);
    internal IScriptExtent get_ScriptPosition();
    internal void set_ScriptPosition(IScriptExtent value);
    internal string GetFullScript();
    [CompilerGeneratedAttribute]
internal Int32[] get_PipelineIterationInfo();
    [CompilerGeneratedAttribute]
internal void set_PipelineIterationInfo(Int32[] value);
    internal void ToPSObjectForRemoting(PSObject psObject);
    [CompilerGeneratedAttribute]
private object <ToPSObjectForRemoting>b__69_0();
    [CompilerGeneratedAttribute]
private CommandOrigin <ToPSObjectForRemoting>b__69_1();
    [CompilerGeneratedAttribute]
private bool <ToPSObjectForRemoting>b__69_2();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_3();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_4();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__69_5();
    [CompilerGeneratedAttribute]
private long <ToPSObjectForRemoting>b__69_6();
    [CompilerGeneratedAttribute]
private Int32[] <ToPSObjectForRemoting>b__69_7();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__69_8();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__69_9();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_10();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_11();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_12();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__69_13();
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__69_14();
    [CompilerGeneratedAttribute]
private object <ToPSObjectForRemoting>b__69_15();
}
internal interface System.Management.Automation.IOutputProcessingState {
    [CompilerGeneratedAttribute]
public abstract virtual void add_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.IResourceSupplier {
    public abstract virtual string GetResourceString(string baseName, string resourceId);
}
internal interface System.Management.Automation.IRSPDriverInvoke {
    public abstract virtual void EnterNestedPipeline();
    public abstract virtual void ExitNestedPipeline();
    public abstract virtual bool HandleStopSignal();
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.IScriptCommandInfo {
    public ScriptBlock ScriptBlock { get; }
    public abstract virtual ScriptBlock get_ScriptBlock();
}
public class System.Management.Automation.ItemCmdletProviderIntrinsics : object {
    private Cmdlet _cmdlet;
    private SessionStateInternal _sessionState;
    internal ItemCmdletProviderIntrinsics(Cmdlet cmdlet);
    internal ItemCmdletProviderIntrinsics(SessionStateInternal sessionState);
    public Collection`1<PSObject> Get(string path);
    public Collection`1<PSObject> Get(String[] path, bool force, bool literalPath);
    internal void Get(string path, CmdletProviderContext context);
    internal object GetItemDynamicParameters(string path, CmdletProviderContext context);
    public Collection`1<PSObject> Set(string path, object value);
    public Collection`1<PSObject> Set(String[] path, object value, bool force, bool literalPath);
    internal void Set(string path, object value, CmdletProviderContext context);
    internal object SetItemDynamicParameters(string path, object value, CmdletProviderContext context);
    public Collection`1<PSObject> Clear(string path);
    public Collection`1<PSObject> Clear(String[] path, bool force, bool literalPath);
    internal void Clear(string path, CmdletProviderContext context);
    internal object ClearItemDynamicParameters(string path, CmdletProviderContext context);
    public void Invoke(string path);
    public void Invoke(String[] path, bool literalPath);
    internal void Invoke(string path, CmdletProviderContext context);
    internal object InvokeItemDynamicParameters(string path, CmdletProviderContext context);
    public Collection`1<PSObject> Rename(string path, string newName);
    public Collection`1<PSObject> Rename(string path, string newName, bool force);
    internal void Rename(string path, string newName, CmdletProviderContext context);
    internal object RenameItemDynamicParameters(string path, string newName, CmdletProviderContext context);
    public Collection`1<PSObject> New(string path, string name, string itemTypeName, object content);
    public Collection`1<PSObject> New(String[] path, string name, string itemTypeName, object content, bool force);
    internal void New(string path, string name, string type, object content, CmdletProviderContext context);
    internal object NewItemDynamicParameters(string path, string type, object content, CmdletProviderContext context);
    public void Remove(string path, bool recurse);
    public void Remove(String[] path, bool recurse, bool force, bool literalPath);
    internal void Remove(string path, bool recurse, CmdletProviderContext context);
    internal object RemoveItemDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    public Collection`1<PSObject> Copy(string path, string destinationPath, bool recurse, CopyContainers copyContainers);
    public Collection`1<PSObject> Copy(String[] path, string destinationPath, bool recurse, CopyContainers copyContainers, bool force, bool literalPath);
    internal void Copy(string path, string destinationPath, bool recurse, CopyContainers copyContainers, CmdletProviderContext context);
    internal object CopyItemDynamicParameters(string path, string destination, bool recurse, CmdletProviderContext context);
    public Collection`1<PSObject> Move(string path, string destination);
    public Collection`1<PSObject> Move(String[] path, string destination, bool force, bool literalPath);
    internal void Move(string path, string destination, CmdletProviderContext context);
    internal object MoveItemDynamicParameters(string path, string destination, CmdletProviderContext context);
    public bool Exists(string path);
    public bool Exists(string path, bool force, bool literalPath);
    internal bool Exists(string path, CmdletProviderContext context);
    internal object ItemExistsDynamicParameters(string path, CmdletProviderContext context);
    public bool IsContainer(string path);
    internal bool IsContainer(string path, CmdletProviderContext context);
}
public class System.Management.Automation.ItemNotFoundException : SessionStateException {
    internal ItemNotFoundException(string path, string errorIdAndResourceId, string resourceStr);
    public ItemNotFoundException(string message);
    public ItemNotFoundException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ItemNotFoundException(SerializationInfo info, StreamingContext context);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.IValidateSetValuesGenerator {
    public abstract virtual String[] GetValidValues();
}
public abstract class System.Management.Automation.Job : object {
    private ManualResetEvent _finished;
    private string _name;
    private IList`1<Job> _childJobs;
    internal object syncObject;
    private PSDataCollection`1<PSStreamObject> _results;
    private bool _resultsOwner;
    private PSDataCollection`1<ErrorRecord> _error;
    private bool _errorOwner;
    private PSDataCollection`1<ProgressRecord> _progress;
    private bool _progressOwner;
    private PSDataCollection`1<VerboseRecord> _verbose;
    private bool _verboseOwner;
    private PSDataCollection`1<WarningRecord> _warning;
    private bool _warningOwner;
    private PSDataCollection`1<DebugRecord> _debug;
    private bool _debugOwner;
    private PSDataCollection`1<InformationRecord> _information;
    private bool _informationOwner;
    private PSDataCollection`1<PSObject> _output;
    private bool _outputOwner;
    private static int s_jobIdSeed;
    private string _jobTypeName;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStateInfo <JobStateInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <PSBeginTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <PSEndTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesResultsCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SuppressOutputForwarding>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PropagateThrows>k__BackingField;
    private Lazy`1<int> _parentActivityId;
    private bool _jobStreamsLoaded;
    [CompilerGeneratedAttribute]
private EventHandler`1<JobStateEventArgs> StateChanged;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private EventHandler`1<OutputProcessingStateEventArgs> OutputProcessingStateChanged;
    private bool _processingOutput;
    [CompilerGeneratedAttribute]
private bool <MonitorOutputProcessing>k__BackingField;
    public string Command { get; }
    public JobStateInfo JobStateInfo { get; private set; }
    public WaitHandle Finished { get; }
    public Guid InstanceId { get; }
    public int Id { get; }
    public string Name { get; public set; }
    public IList`1<Job> ChildJobs { get; }
    public string StatusMessage { get; }
    public bool HasMoreData { get; }
    public Nullable`1<DateTime> PSBeginTime { get; protected set; }
    public Nullable`1<DateTime> PSEndTime { get; protected set; }
    public string PSJobTypeName { get; protected internal set; }
    internal PSDataCollection`1<PSStreamObject> Results { get; internal set; }
    internal bool UsesResultsCollection { get; internal set; }
    internal bool SuppressOutputForwarding { get; internal set; }
    internal bool PropagateThrows { get; internal set; }
    public PSDataCollection`1<PSObject> Output { get; public set; }
    public PSDataCollection`1<ErrorRecord> Error { get; public set; }
    public PSDataCollection`1<ProgressRecord> Progress { get; public set; }
    public PSDataCollection`1<VerboseRecord> Verbose { get; public set; }
    public PSDataCollection`1<DebugRecord> Debug { get; public set; }
    public PSDataCollection`1<WarningRecord> Warning { get; public set; }
    public PSDataCollection`1<InformationRecord> Information { get; public set; }
    public string Location { get; }
    internal bool CanDisconnect { get; }
    internal bool MonitorOutputProcessing { get; internal set; }
    protected Job(string command);
    protected Job(string command, string name);
    protected Job(string command, string name, IList`1<Job> childJobs);
    protected Job(string command, string name, JobIdentifier token);
    protected Job(string command, string name, Guid instanceId);
    internal static string GetCommandTextFromInvocationInfo(InvocationInfo invocationInfo);
    [CompilerGeneratedAttribute]
public string get_Command();
    [CompilerGeneratedAttribute]
public JobStateInfo get_JobStateInfo();
    [CompilerGeneratedAttribute]
private void set_JobStateInfo(JobStateInfo value);
    public WaitHandle get_Finished();
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
public int get_Id();
    public string get_Name();
    public void set_Name(string value);
    public IList`1<Job> get_ChildJobs();
    public abstract virtual string get_StatusMessage();
    public abstract virtual bool get_HasMoreData();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_PSBeginTime();
    [CompilerGeneratedAttribute]
protected void set_PSBeginTime(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_PSEndTime();
    [CompilerGeneratedAttribute]
protected void set_PSEndTime(Nullable`1<DateTime> value);
    public string get_PSJobTypeName();
    protected internal void set_PSJobTypeName(string value);
    internal PSDataCollection`1<PSStreamObject> get_Results();
    internal void set_Results(PSDataCollection`1<PSStreamObject> value);
    [CompilerGeneratedAttribute]
internal bool get_UsesResultsCollection();
    [CompilerGeneratedAttribute]
internal void set_UsesResultsCollection(bool value);
    [CompilerGeneratedAttribute]
internal bool get_SuppressOutputForwarding();
    [CompilerGeneratedAttribute]
internal void set_SuppressOutputForwarding(bool value);
    internal virtual void WriteObject(object outputObject);
    [CompilerGeneratedAttribute]
internal bool get_PropagateThrows();
    [CompilerGeneratedAttribute]
internal void set_PropagateThrows(bool value);
    private void WriteError(Cmdlet cmdlet, ErrorRecord errorRecord);
    private static Exception GetExceptionFromErrorRecord(ErrorRecord errorRecord);
    internal virtual void WriteError(ErrorRecord errorRecord);
    internal void WriteError(ErrorRecord errorRecord, Exception& exceptionThrownOnCmdletThread);
    internal virtual void WriteWarning(string message);
    internal virtual void WriteVerbose(string message);
    internal virtual void WriteDebug(string message);
    internal virtual void WriteProgress(ProgressRecord progressRecord);
    internal virtual void WriteInformation(InformationRecord informationRecord);
    internal void SetParentActivityIdGetter(Func`1<int> parentActivityIdGetter);
    internal bool ShouldContinue(string query, string caption);
    internal bool ShouldContinue(string query, string caption, Exception& exceptionThrownOnCmdletThread);
    internal virtual void NonblockingShouldProcess(string verboseDescription, string verboseWarning, string caption);
    internal virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason, Exception& exceptionThrownOnCmdletThread);
    private void InvokeCmdletMethodAndIgnoreResults(Action`1<Cmdlet> invokeCmdletMethod);
    private T InvokeCmdletMethodAndWaitForResults(Func`2<Cmdlet, T> invokeCmdletMethodAndReturnResult, Exception& exceptionThrownOnCmdletThread);
    internal virtual void ForwardAvailableResultsToCmdlet(Cmdlet cmdlet);
    internal virtual void ForwardAllResultsToCmdlet(Cmdlet cmdlet);
    protected virtual void DoLoadJobStreams();
    protected virtual void DoUnloadJobStreams();
    public void LoadJobStreams();
    public void UnloadJobStreams();
    public PSDataCollection`1<PSObject> get_Output();
    public void set_Output(PSDataCollection`1<PSObject> value);
    public PSDataCollection`1<ErrorRecord> get_Error();
    public void set_Error(PSDataCollection`1<ErrorRecord> value);
    public PSDataCollection`1<ProgressRecord> get_Progress();
    public void set_Progress(PSDataCollection`1<ProgressRecord> value);
    public PSDataCollection`1<VerboseRecord> get_Verbose();
    public void set_Verbose(PSDataCollection`1<VerboseRecord> value);
    public PSDataCollection`1<DebugRecord> get_Debug();
    public void set_Debug(PSDataCollection`1<DebugRecord> value);
    public PSDataCollection`1<WarningRecord> get_Warning();
    public void set_Warning(PSDataCollection`1<WarningRecord> value);
    public PSDataCollection`1<InformationRecord> get_Information();
    public void set_Information(PSDataCollection`1<InformationRecord> value);
    public abstract virtual string get_Location();
    internal virtual bool get_CanDisconnect();
    internal virtual IEnumerable`1<RemoteRunspace> GetRunspaces();
    [CompilerGeneratedAttribute]
public void add_StateChanged(EventHandler`1<JobStateEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(EventHandler`1<JobStateEventArgs> value);
    protected void SetJobState(JobState state);
    internal void SetJobState(JobState state, Exception reason);
    public abstract virtual void StopJob();
    internal Collection`1<PSStreamObject> ReadAll();
    internal bool IsFinishedState(JobState state);
    internal bool IsPersistentState(JobState state);
    private void AssertChangesAreAccepted();
    protected string AutoGenerateJobName();
    internal void AssertNotDisposed();
    internal void CloseAllStreams();
    private static void TraceException(Exception e);
    internal List`1<Job> GetJobsForLocation(string location);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
internal void add_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_OutputProcessingStateChanged(EventHandler`1<OutputProcessingStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal bool get_MonitorOutputProcessing();
    [CompilerGeneratedAttribute]
internal void set_MonitorOutputProcessing(bool value);
    internal void SetMonitorOutputProcessing(IOutputProcessingState outputProcessingState);
    internal void RemoveMonitorOutputProcessing(IOutputProcessingState outputProcessingState);
    private void HandleOutputProcessingStateChanged(object sender, OutputProcessingStateEventArgs e);
}
public abstract class System.Management.Automation.Job2 : Job {
    private List`1<CommandParameterCollection> _parameters;
    private object _syncobject;
    private static int StartJobOperation;
    private static int StopJobOperation;
    private static int SuspendJobOperation;
    private static int ResumeJobOperation;
    private static int UnblockJobOperation;
    private PowerShellTraceSource _tracer;
    [CompilerGeneratedAttribute]
private EventHandler`1<AsyncCompletedEventArgs> StartJobCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<AsyncCompletedEventArgs> StopJobCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<AsyncCompletedEventArgs> SuspendJobCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<AsyncCompletedEventArgs> ResumeJobCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<AsyncCompletedEventArgs> UnblockJobCompleted;
    public List`1<CommandParameterCollection> StartParameters { get; public set; }
    protected object SyncRoot { get; }
    protected Job2(string command);
    protected Job2(string command, string name);
    protected Job2(string command, string name, IList`1<Job> childJobs);
    protected Job2(string command, string name, JobIdentifier token);
    protected Job2(string command, string name, Guid instanceId);
    public List`1<CommandParameterCollection> get_StartParameters();
    public void set_StartParameters(List`1<CommandParameterCollection> value);
    protected object get_SyncRoot();
    protected void SetJobState(JobState state, Exception reason);
    public abstract virtual void StartJob();
    public abstract virtual void StartJobAsync();
    [CompilerGeneratedAttribute]
public void add_StartJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StartJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    protected virtual void OnStartJobCompleted(AsyncCompletedEventArgs eventArgs);
    protected virtual void OnStopJobCompleted(AsyncCompletedEventArgs eventArgs);
    protected virtual void OnSuspendJobCompleted(AsyncCompletedEventArgs eventArgs);
    protected virtual void OnResumeJobCompleted(AsyncCompletedEventArgs eventArgs);
    protected virtual void OnUnblockJobCompleted(AsyncCompletedEventArgs eventArgs);
    private void RaiseCompletedHandler(int operation, AsyncCompletedEventArgs eventArgs);
    public abstract virtual void StopJobAsync();
    [CompilerGeneratedAttribute]
public void add_StopJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StopJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public abstract virtual void SuspendJob();
    public abstract virtual void SuspendJobAsync();
    [CompilerGeneratedAttribute]
public void add_SuspendJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SuspendJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public abstract virtual void ResumeJob();
    public abstract virtual void ResumeJobAsync();
    [CompilerGeneratedAttribute]
public void add_ResumeJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ResumeJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    public abstract virtual void UnblockJob();
    public abstract virtual void UnblockJobAsync();
    public abstract virtual void StopJob(bool force, string reason);
    public abstract virtual void StopJobAsync(bool force, string reason);
    public abstract virtual void SuspendJob(bool force, string reason);
    public abstract virtual void SuspendJobAsync(bool force, string reason);
    [CompilerGeneratedAttribute]
public void add_UnblockJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_UnblockJobCompleted(EventHandler`1<AsyncCompletedEventArgs> value);
}
public class System.Management.Automation.JobDefinition : object {
    private string _name;
    [CompilerGeneratedAttribute]
private Type <JobSourceAdapterType>k__BackingField;
    private string _moduleName;
    private string _jobSourceAdapterTypeName;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    private Guid _instanceId;
    public string Name { get; public set; }
    public Type JobSourceAdapterType { get; }
    public string ModuleName { get; public set; }
    public string JobSourceAdapterTypeName { get; public set; }
    public string Command { get; }
    public Guid InstanceId { get; public set; }
    public CommandInfo CommandInfo { get; }
    public JobDefinition(Type jobSourceAdapterType, string command, string name);
    protected JobDefinition(SerializationInfo info, StreamingContext context);
    public string get_Name();
    public void set_Name(string value);
    [CompilerGeneratedAttribute]
public Type get_JobSourceAdapterType();
    public string get_ModuleName();
    public void set_ModuleName(string value);
    public string get_JobSourceAdapterTypeName();
    public void set_JobSourceAdapterTypeName(string value);
    [CompilerGeneratedAttribute]
public string get_Command();
    public Guid get_InstanceId();
    public void set_InstanceId(Guid value);
    public virtual void Save(Stream stream);
    public virtual void Load(Stream stream);
    public CommandInfo get_CommandInfo();
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.JobFailedException : SystemException {
    private Exception _reason;
    private ScriptExtent _displayScriptPosition;
    public Exception Reason { get; }
    public ScriptExtent DisplayScriptPosition { get; }
    public string Message { get; }
    public JobFailedException(string message);
    public JobFailedException(string message, Exception innerException);
    public JobFailedException(Exception innerException, ScriptExtent displayScriptPosition);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected JobFailedException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public Exception get_Reason();
    public ScriptExtent get_DisplayScriptPosition();
    public virtual string get_Message();
}
public class System.Management.Automation.JobIdentifier : object {
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    internal int Id { get; }
    internal Guid InstanceId { get; private set; }
    internal JobIdentifier(int id, Guid instanceId);
    [CompilerGeneratedAttribute]
internal int get_Id();
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
private void set_InstanceId(Guid value);
}
public class System.Management.Automation.JobInvocationInfo : object {
    private string _name;
    private string _command;
    private JobDefinition _definition;
    private List`1<CommandParameterCollection> _parameters;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    public string Name { get; public set; }
    public string Command { get; public set; }
    public JobDefinition Definition { get; public set; }
    public List`1<CommandParameterCollection> Parameters { get; }
    public Guid InstanceId { get; }
    public JobInvocationInfo(JobDefinition definition, Dictionary`2<string, object> parameters);
    public JobInvocationInfo(JobDefinition definition, IEnumerable`1<Dictionary`2<string, object>> parameterCollectionList);
    public JobInvocationInfo(JobDefinition definition, CommandParameterCollection parameters);
    public JobInvocationInfo(JobDefinition definition, IEnumerable`1<CommandParameterCollection> parameters);
    protected JobInvocationInfo(SerializationInfo info, StreamingContext context);
    public string get_Name();
    public void set_Name(string value);
    public string get_Command();
    public void set_Command(string value);
    public JobDefinition get_Definition();
    public void set_Definition(JobDefinition value);
    public List`1<CommandParameterCollection> get_Parameters();
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    public virtual void Save(Stream stream);
    public virtual void Load(Stream stream);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    private static CommandParameterCollection ConvertDictionaryToParameterCollection(IEnumerable`1<KeyValuePair`2<string, object>> parameters);
}
public class System.Management.Automation.JobManager : object {
    private PowerShellTraceSource _tracer;
    private Dictionary`2<string, JobSourceAdapter> _sourceAdapters;
    private object _syncObject;
    private static Dictionary`2<Guid, KeyValuePair`2<int, string>> s_jobIdsForReuse;
    private static object s_syncObject;
    private static JobManager();
    public bool IsRegistered(string typeName);
    internal void RegisterJobSourceAdapter(Type jobSourceAdapterType);
    internal static JobIdentifier GetJobIdentifier(Guid instanceId, string typeName);
    internal static void SaveJobId(Guid instanceId, int id, string typeName);
    public Job2 NewJob(JobDefinition definition);
    public Job2 NewJob(JobInvocationInfo specification);
    public void PersistJob(Job2 job, JobDefinition definition);
    private JobSourceAdapter AssertAndReturnJobSourceAdapter(string adapterTypeName);
    private JobSourceAdapter GetJobSourceAdapter(JobDefinition definition);
    internal List`1<Job2> GetJobs(Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, String[] jobSourceAdapterTypes);
    internal List`1<Job2> GetJobsByName(string name, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse, String[] jobSourceAdapterTypes);
    internal List`1<Job2> GetJobsByCommand(string command, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse, String[] jobSourceAdapterTypes);
    internal List`1<Job2> GetJobsByState(JobState state, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse, String[] jobSourceAdapterTypes);
    internal List`1<Job2> GetJobsByFilter(Dictionary`2<string, object> filter, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse);
    internal bool IsJobFromAdapter(Guid id, string name);
    private List`1<Job2> GetFilteredJobs(object filter, FilterType filterType, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse, String[] jobSourceAdapterTypes);
    private static bool CheckTypeNames(JobSourceAdapter sourceAdapter, String[] jobSourceAdapterTypes);
    private static string GetAdapterName(JobSourceAdapter sourceAdapter);
    private static List`1<Job2> CallJobFilter(JobSourceAdapter sourceAdapter, object filter, FilterType filterType, bool recurse);
    internal Job2 GetJobById(int id, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse);
    internal Job2 GetJobByInstanceId(Guid instanceId, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse);
    private Job2 GetJobThroughId(Guid guid, int id, Cmdlet cmdlet, bool writeErrorOnException, bool writeObject, bool recurse);
    internal List`1<Job2> GetJobToStart(string definitionName, string definitionPath, string definitionType, Cmdlet cmdlet, bool writeErrorOnException);
    private static void WriteErrorOrWarning(bool writeErrorOnException, Cmdlet cmdlet, Exception exception, string identifier, JobSourceAdapter sourceAdapter);
    internal List`1<string> GetLoadedAdapterNames(String[] adapterTypeNames);
    internal void RemoveJob(int sessionJobId, Cmdlet cmdlet, bool writeErrorOnException);
    internal bool RemoveJob(Job2 job, Cmdlet cmdlet, bool writeErrorOnException, bool throwExceptions);
    private void RemoveJobIdForReuse(Job job);
    private void RemoveJobIdForReuseHelper(Hashtable duplicateDetector, Job job);
}
public class System.Management.Automation.JobRepository : Repository`1<Job> {
    public List`1<Job> Jobs { get; }
    public List`1<Job> get_Jobs();
    public Job GetJob(Guid instanceId);
    protected virtual Guid GetKey(Job item);
}
public abstract class System.Management.Automation.JobSourceAdapter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    protected JobIdentifier RetrieveJobIdForReuse(Guid instanceId);
    public void StoreJobIdForReuse(Job2 job, bool recurse);
    private void StoreJobIdForReuseHelper(Hashtable duplicateDetector, Job2 job, bool recurse);
    public Job2 NewJob(JobDefinition definition);
    public virtual Job2 NewJob(string definitionName, string definitionPath);
    public abstract virtual Job2 NewJob(JobInvocationInfo specification);
    public abstract virtual IList`1<Job2> GetJobs();
    public abstract virtual IList`1<Job2> GetJobsByName(string name, bool recurse);
    public abstract virtual IList`1<Job2> GetJobsByCommand(string command, bool recurse);
    public abstract virtual Job2 GetJobByInstanceId(Guid instanceId, bool recurse);
    public abstract virtual Job2 GetJobBySessionId(int id, bool recurse);
    public abstract virtual IList`1<Job2> GetJobsByState(JobState state, bool recurse);
    public abstract virtual IList`1<Job2> GetJobsByFilter(Dictionary`2<string, object> filter, bool recurse);
    public abstract virtual void RemoveJob(Job2 job);
    public virtual void PersistJob(Job2 job);
}
public enum System.Management.Automation.JobState : Enum {
    public int value__;
    public static JobState NotStarted;
    public static JobState Running;
    public static JobState Completed;
    public static JobState Failed;
    public static JobState Stopped;
    public static JobState Blocked;
    public static JobState Suspended;
    public static JobState Disconnected;
    public static JobState Suspending;
    public static JobState Stopping;
    public static JobState AtBreakpoint;
}
public class System.Management.Automation.JobStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private JobStateInfo <JobStateInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private JobStateInfo <PreviousJobStateInfo>k__BackingField;
    public JobStateInfo JobStateInfo { get; }
    public JobStateInfo PreviousJobStateInfo { get; }
    public JobStateEventArgs(JobStateInfo jobStateInfo);
    public JobStateEventArgs(JobStateInfo jobStateInfo, JobStateInfo previousJobStateInfo);
    [CompilerGeneratedAttribute]
public JobStateInfo get_JobStateInfo();
    [CompilerGeneratedAttribute]
public JobStateInfo get_PreviousJobStateInfo();
}
public class System.Management.Automation.JobStateInfo : object {
    [CompilerGeneratedAttribute]
private JobState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public JobState State { get; }
    public Exception Reason { get; }
    public JobStateInfo(JobState state);
    public JobStateInfo(JobState state, Exception reason);
    internal JobStateInfo(JobStateInfo jobStateInfo);
    [CompilerGeneratedAttribute]
public JobState get_State();
    [CompilerGeneratedAttribute]
public Exception get_Reason();
    public virtual string ToString();
    internal JobStateInfo Clone();
}
public enum System.Management.Automation.JobThreadOptions : Enum {
    public int value__;
    public static JobThreadOptions Default;
    public static JobThreadOptions UseThreadPoolThread;
    public static JobThreadOptions UseNewThread;
}
internal static class System.Management.Automation.KnownTypes : object {
    private static TypeSerializationInfo s_xdInfo;
    private static TypeSerializationInfo[] s_typeSerializationInfo;
    private static Dictionary`2<string, TypeSerializationInfo> s_knownTableKeyType;
    private static Dictionary`2<string, TypeSerializationInfo> s_knownTableKeyItemTag;
    private static KnownTypes();
    internal static TypeSerializationInfo GetTypeSerializationInfo(Type type);
    internal static TypeSerializationInfo GetTypeSerializationInfoFromItemTag(string itemTag);
}
internal class System.Management.Automation.Language.ArrayAssignableValue : object {
    [CompilerGeneratedAttribute]
private ArrayLiteralAst <ArrayLiteral>k__BackingField;
    internal ArrayLiteralAst ArrayLiteral { get; internal set; }
    [CompilerGeneratedAttribute]
internal ArrayLiteralAst get_ArrayLiteral();
    [CompilerGeneratedAttribute]
internal void set_ArrayLiteral(ArrayLiteralAst value);
    public sealed virtual Expression GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    public sealed virtual Expression SetValue(Compiler compiler, Expression rhs);
}
public class System.Management.Automation.Language.ArrayExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private StatementBlockAst <SubExpression>k__BackingField;
    public StatementBlockAst SubExpression { get; }
    public Type StaticType { get; }
    public ArrayExpressionAst(IScriptExtent extent, StatementBlockAst statementBlock);
    [CompilerGeneratedAttribute]
public StatementBlockAst get_SubExpression();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ArrayLiteralAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ExpressionAst> <Elements>k__BackingField;
    public ReadOnlyCollection`1<ExpressionAst> Elements { get; }
    public Type StaticType { get; }
    public ArrayLiteralAst(IScriptExtent extent, IList`1<ExpressionAst> elements);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ExpressionAst> get_Elements();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
}
public class System.Management.Automation.Language.ArrayTypeName : object {
    private string _cachedFullName;
    private Type _cachedType;
    [CompilerGeneratedAttribute]
private ITypeName <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <Extent>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public string AssemblyName { get; }
    public bool IsArray { get; }
    public bool IsGeneric { get; }
    public ITypeName ElementType { get; }
    public int Rank { get; }
    public IScriptExtent Extent { get; }
    private Type System.Management.Automation.Language.ISupportsTypeCaching.CachedType { get; private set; }
    public ArrayTypeName(IScriptExtent extent, ITypeName elementType, int rank);
    private string GetName(bool includeAssemblyName);
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual string get_AssemblyName();
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsGeneric();
    [CompilerGeneratedAttribute]
public ITypeName get_ElementType();
    [CompilerGeneratedAttribute]
public int get_Rank();
    [CompilerGeneratedAttribute]
public sealed virtual IScriptExtent get_Extent();
    public sealed virtual Type GetReflectionType();
    public sealed virtual Type GetReflectionAttributeType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override Type System.Management.Automation.Language.ISupportsTypeCaching.get_CachedType();
    private sealed virtual override void System.Management.Automation.Language.ISupportsTypeCaching.set_CachedType(Type value);
}
public class System.Management.Automation.Language.AssignmentStatementAst : PipelineBaseAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenKind <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementAst <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <ErrorPosition>k__BackingField;
    public ExpressionAst Left { get; }
    public TokenKind Operator { get; }
    public StatementAst Right { get; }
    public IScriptExtent ErrorPosition { get; }
    public AssignmentStatementAst(IScriptExtent extent, ExpressionAst left, TokenKind operator, StatementAst right, IScriptExtent errorPosition);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Left();
    [CompilerGeneratedAttribute]
public TokenKind get_Operator();
    [CompilerGeneratedAttribute]
public StatementAst get_Right();
    [CompilerGeneratedAttribute]
public IScriptExtent get_ErrorPosition();
    public virtual Ast Copy();
    [IteratorStateMachineAttribute("System.Management.Automation.Language.AssignmentStatementAst/<GetAssignmentTargets>d__14")]
public IEnumerable`1<ExpressionAst> GetAssignmentTargets();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public abstract class System.Management.Automation.Language.Ast : object {
    [CompilerGeneratedAttribute]
private IScriptExtent <Extent>k__BackingField;
    [CompilerGeneratedAttribute]
private Ast <Parent>k__BackingField;
    internal static PSTypeName[] EmptyPSTypeNameArray;
    [CompilerGeneratedAttribute]
private bool <HasSuspiciousContent>k__BackingField;
    public IScriptExtent Extent { get; }
    public Ast Parent { get; private set; }
    internal bool HasSuspiciousContent { get; internal set; }
    protected Ast(IScriptExtent extent);
    private static Ast();
    [CompilerGeneratedAttribute]
public IScriptExtent get_Extent();
    [CompilerGeneratedAttribute]
public Ast get_Parent();
    [CompilerGeneratedAttribute]
private void set_Parent(Ast value);
    public object Visit(ICustomAstVisitor astVisitor);
    public void Visit(AstVisitor astVisitor);
    public IEnumerable`1<Ast> FindAll(Func`2<Ast, bool> predicate, bool searchNestedScriptBlocks);
    public Ast Find(Func`2<Ast, bool> predicate, bool searchNestedScriptBlocks);
    public virtual string ToString();
    public abstract virtual Ast Copy();
    public object SafeGetValue();
    public object SafeGetValue(bool skipHashtableSizeCheck);
    internal static T[] CopyElements(ReadOnlyCollection`1<T> elements);
    internal static T CopyElement(T element);
    internal void SetParents(ReadOnlyCollection`1<T> children);
    internal void SetParents(ReadOnlyCollection`1<Tuple`2<T1, T2>> children);
    internal void SetParent(Ast child);
    internal void ClearParent();
    internal abstract virtual object Accept(ICustomAstVisitor visitor);
    internal abstract virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal bool IsInWorkflow();
    [CompilerGeneratedAttribute]
internal bool get_HasSuspiciousContent();
    [CompilerGeneratedAttribute]
internal void set_HasSuspiciousContent(bool value);
    internal static ConfigurationDefinitionAst GetAncestorConfigurationDefinitionAstAndDynamicKeywordStatementAst(Ast ast, DynamicKeywordStatementAst& keywordAst);
    internal static HashtableAst GetAncestorHashtableAst(Ast ast, Ast& lastChildOfHashtable);
    internal static TypeDefinitionAst GetAncestorTypeDefinitionAst(Ast ast);
    internal static T GetAncestorAst(Ast ast);
}
internal class System.Management.Automation.Language.AstArrayPair : AstParameterArgumentPair {
    [CompilerGeneratedAttribute]
private ExpressionAst[] <Argument>k__BackingField;
    public ExpressionAst[] Argument { get; }
    internal AstArrayPair(string parameterName, ICollection`1<ExpressionAst> arguments);
    [CompilerGeneratedAttribute]
public ExpressionAst[] get_Argument();
}
internal class System.Management.Automation.Language.AstPair : AstParameterArgumentPair {
    [CompilerGeneratedAttribute]
private bool <ParameterContainsArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ArgumentIsCommandParameterAst>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandElementAst <Argument>k__BackingField;
    public bool ParameterContainsArgument { get; }
    public bool ArgumentIsCommandParameterAst { get; }
    public CommandElementAst Argument { get; }
    internal AstPair(CommandParameterAst parameterAst);
    internal AstPair(CommandParameterAst parameterAst, ExpressionAst argumentAst);
    internal AstPair(CommandParameterAst parameterAst, CommandElementAst argumentAst);
    [CompilerGeneratedAttribute]
public bool get_ParameterContainsArgument();
    [CompilerGeneratedAttribute]
public bool get_ArgumentIsCommandParameterAst();
    [CompilerGeneratedAttribute]
public CommandElementAst get_Argument();
}
internal abstract class System.Management.Automation.Language.AstParameterArgumentPair : object {
    [CompilerGeneratedAttribute]
private CommandParameterAst <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private AstParameterArgumentType <ParameterArgumentType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ParameterSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ArgumentSpecified>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterText>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ArgumentType>k__BackingField;
    public CommandParameterAst Parameter { get; protected set; }
    public AstParameterArgumentType ParameterArgumentType { get; protected set; }
    public bool ParameterSpecified { get; protected set; }
    public bool ArgumentSpecified { get; protected set; }
    public string ParameterName { get; protected set; }
    public string ParameterText { get; protected set; }
    public Type ArgumentType { get; protected set; }
    [CompilerGeneratedAttribute]
public CommandParameterAst get_Parameter();
    [CompilerGeneratedAttribute]
protected void set_Parameter(CommandParameterAst value);
    [CompilerGeneratedAttribute]
public AstParameterArgumentType get_ParameterArgumentType();
    [CompilerGeneratedAttribute]
protected void set_ParameterArgumentType(AstParameterArgumentType value);
    [CompilerGeneratedAttribute]
public bool get_ParameterSpecified();
    [CompilerGeneratedAttribute]
protected void set_ParameterSpecified(bool value);
    [CompilerGeneratedAttribute]
public bool get_ArgumentSpecified();
    [CompilerGeneratedAttribute]
protected void set_ArgumentSpecified(bool value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
protected void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public string get_ParameterText();
    [CompilerGeneratedAttribute]
protected void set_ParameterText(string value);
    [CompilerGeneratedAttribute]
public Type get_ArgumentType();
    [CompilerGeneratedAttribute]
protected void set_ArgumentType(Type value);
}
internal enum System.Management.Automation.Language.AstParameterArgumentType : Enum {
    public int value__;
    public static AstParameterArgumentType AstPair;
    public static AstParameterArgumentType Switch;
    public static AstParameterArgumentType Fake;
    public static AstParameterArgumentType AstArray;
    public static AstParameterArgumentType PipeObject;
}
internal class System.Management.Automation.Language.AstSearcher : AstVisitor2 {
    private Func`2<Ast, bool> _callback;
    private bool _stopOnFirst;
    private bool _searchNestedScriptBlocks;
    protected List`1<Ast> Results;
    protected AstSearcher(Func`2<Ast, bool> callback, bool stopOnFirst, bool searchNestedScriptBlocks);
    internal static IEnumerable`1<Ast> FindAll(Ast ast, Func`2<Ast, bool> predicate, bool searchNestedScriptBlocks);
    internal static Ast FindFirst(Ast ast, Func`2<Ast, bool> predicate, bool searchNestedScriptBlocks);
    internal static bool Contains(Ast ast, Func`2<Ast, bool> predicate, bool searchNestedScriptBlocks);
    internal static bool IsUsingDollarInput(Ast ast);
    protected AstVisitAction Check(Ast ast);
    protected AstVisitAction CheckScriptBlock(Ast ast);
    public virtual AstVisitAction VisitErrorStatement(ErrorStatementAst ast);
    public virtual AstVisitAction VisitErrorExpression(ErrorExpressionAst ast);
    public virtual AstVisitAction VisitScriptBlock(ScriptBlockAst ast);
    public virtual AstVisitAction VisitParamBlock(ParamBlockAst ast);
    public virtual AstVisitAction VisitNamedBlock(NamedBlockAst ast);
    public virtual AstVisitAction VisitTypeConstraint(TypeConstraintAst ast);
    public virtual AstVisitAction VisitAttribute(AttributeAst ast);
    public virtual AstVisitAction VisitParameter(ParameterAst ast);
    public virtual AstVisitAction VisitTypeExpression(TypeExpressionAst ast);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst ast);
    public virtual AstVisitAction VisitStatementBlock(StatementBlockAst ast);
    public virtual AstVisitAction VisitIfStatement(IfStatementAst ast);
    public virtual AstVisitAction VisitTrap(TrapStatementAst ast);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst ast);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst ast);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst ast);
    public virtual AstVisitAction VisitDoWhileStatement(DoWhileStatementAst ast);
    public virtual AstVisitAction VisitForStatement(ForStatementAst ast);
    public virtual AstVisitAction VisitWhileStatement(WhileStatementAst ast);
    public virtual AstVisitAction VisitCatchClause(CatchClauseAst ast);
    public virtual AstVisitAction VisitTryStatement(TryStatementAst ast);
    public virtual AstVisitAction VisitBreakStatement(BreakStatementAst ast);
    public virtual AstVisitAction VisitContinueStatement(ContinueStatementAst ast);
    public virtual AstVisitAction VisitReturnStatement(ReturnStatementAst ast);
    public virtual AstVisitAction VisitExitStatement(ExitStatementAst ast);
    public virtual AstVisitAction VisitThrowStatement(ThrowStatementAst ast);
    public virtual AstVisitAction VisitDoUntilStatement(DoUntilStatementAst ast);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst ast);
    public virtual AstVisitAction VisitPipeline(PipelineAst ast);
    public virtual AstVisitAction VisitCommand(CommandAst ast);
    public virtual AstVisitAction VisitCommandExpression(CommandExpressionAst ast);
    public virtual AstVisitAction VisitCommandParameter(CommandParameterAst ast);
    public virtual AstVisitAction VisitMergingRedirection(MergingRedirectionAst ast);
    public virtual AstVisitAction VisitFileRedirection(FileRedirectionAst ast);
    public virtual AstVisitAction VisitBinaryExpression(BinaryExpressionAst ast);
    public virtual AstVisitAction VisitUnaryExpression(UnaryExpressionAst ast);
    public virtual AstVisitAction VisitConvertExpression(ConvertExpressionAst ast);
    public virtual AstVisitAction VisitConstantExpression(ConstantExpressionAst ast);
    public virtual AstVisitAction VisitStringConstantExpression(StringConstantExpressionAst ast);
    public virtual AstVisitAction VisitSubExpression(SubExpressionAst ast);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst ast);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst ast);
    public virtual AstVisitAction VisitMemberExpression(MemberExpressionAst ast);
    public virtual AstVisitAction VisitInvokeMemberExpression(InvokeMemberExpressionAst ast);
    public virtual AstVisitAction VisitArrayExpression(ArrayExpressionAst ast);
    public virtual AstVisitAction VisitArrayLiteral(ArrayLiteralAst ast);
    public virtual AstVisitAction VisitHashtable(HashtableAst ast);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst ast);
    public virtual AstVisitAction VisitParenExpression(ParenExpressionAst ast);
    public virtual AstVisitAction VisitExpandableStringExpression(ExpandableStringExpressionAst ast);
    public virtual AstVisitAction VisitIndexExpression(IndexExpressionAst ast);
    public virtual AstVisitAction VisitAttributedExpression(AttributedExpressionAst ast);
    public virtual AstVisitAction VisitNamedAttributeArgument(NamedAttributeArgumentAst ast);
    public virtual AstVisitAction VisitTypeDefinition(TypeDefinitionAst ast);
    public virtual AstVisitAction VisitPropertyMember(PropertyMemberAst ast);
    public virtual AstVisitAction VisitFunctionMember(FunctionMemberAst ast);
    public virtual AstVisitAction VisitUsingStatement(UsingStatementAst ast);
    public virtual AstVisitAction VisitBlockStatement(BlockStatementAst ast);
    public virtual AstVisitAction VisitConfigurationDefinition(ConfigurationDefinitionAst ast);
    public virtual AstVisitAction VisitDynamicKeywordStatement(DynamicKeywordStatementAst ast);
    public virtual AstVisitAction VisitTernaryExpression(TernaryExpressionAst ast);
    public virtual AstVisitAction VisitPipelineChain(PipelineChainAst ast);
}
public enum System.Management.Automation.Language.AstVisitAction : Enum {
    public int value__;
    public static AstVisitAction Continue;
    public static AstVisitAction SkipChildren;
    public static AstVisitAction StopVisit;
}
public abstract class System.Management.Automation.Language.AstVisitor : object {
    internal AstVisitAction CheckForPostAction(Ast ast, AstVisitAction action);
    public virtual AstVisitAction DefaultVisit(Ast ast);
    public virtual AstVisitAction VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public virtual AstVisitAction VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public virtual AstVisitAction VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public virtual AstVisitAction VisitParamBlock(ParamBlockAst paramBlockAst);
    public virtual AstVisitAction VisitNamedBlock(NamedBlockAst namedBlockAst);
    public virtual AstVisitAction VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public virtual AstVisitAction VisitAttribute(AttributeAst attributeAst);
    public virtual AstVisitAction VisitParameter(ParameterAst parameterAst);
    public virtual AstVisitAction VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitStatementBlock(StatementBlockAst statementBlockAst);
    public virtual AstVisitAction VisitIfStatement(IfStatementAst ifStmtAst);
    public virtual AstVisitAction VisitTrap(TrapStatementAst trapStatementAst);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual AstVisitAction VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public virtual AstVisitAction VisitForStatement(ForStatementAst forStatementAst);
    public virtual AstVisitAction VisitWhileStatement(WhileStatementAst whileStatementAst);
    public virtual AstVisitAction VisitCatchClause(CatchClauseAst catchClauseAst);
    public virtual AstVisitAction VisitTryStatement(TryStatementAst tryStatementAst);
    public virtual AstVisitAction VisitBreakStatement(BreakStatementAst breakStatementAst);
    public virtual AstVisitAction VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public virtual AstVisitAction VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public virtual AstVisitAction VisitExitStatement(ExitStatementAst exitStatementAst);
    public virtual AstVisitAction VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public virtual AstVisitAction VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual AstVisitAction VisitPipeline(PipelineAst pipelineAst);
    public virtual AstVisitAction VisitCommand(CommandAst commandAst);
    public virtual AstVisitAction VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public virtual AstVisitAction VisitCommandParameter(CommandParameterAst commandParameterAst);
    public virtual AstVisitAction VisitMergingRedirection(MergingRedirectionAst redirectionAst);
    public virtual AstVisitAction VisitFileRedirection(FileRedirectionAst redirectionAst);
    public virtual AstVisitAction VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public virtual AstVisitAction VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public virtual AstVisitAction VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public virtual AstVisitAction VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public virtual AstVisitAction VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public virtual AstVisitAction VisitSubExpression(SubExpressionAst subExpressionAst);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual AstVisitAction VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public virtual AstVisitAction VisitInvokeMemberExpression(InvokeMemberExpressionAst methodCallAst);
    public virtual AstVisitAction VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public virtual AstVisitAction VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public virtual AstVisitAction VisitHashtable(HashtableAst hashtableAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public virtual AstVisitAction VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public virtual AstVisitAction VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public virtual AstVisitAction VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public virtual AstVisitAction VisitBlockStatement(BlockStatementAst blockStatementAst);
    public virtual AstVisitAction VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
}
public abstract class System.Management.Automation.Language.AstVisitor2 : AstVisitor {
    public virtual AstVisitAction VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual AstVisitAction VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public virtual AstVisitAction VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public virtual AstVisitAction VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public virtual AstVisitAction VisitUsingStatement(UsingStatementAst usingStatementAst);
    public virtual AstVisitAction VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public virtual AstVisitAction VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordStatementAst);
    public virtual AstVisitAction VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public virtual AstVisitAction VisitPipelineChain(PipelineChainAst statementChain);
}
public class System.Management.Automation.Language.AttributeAst : AttributeBaseAst {
    private static ReadOnlyCollection`1<ExpressionAst> s_emptyPositionalArguments;
    private static ReadOnlyCollection`1<NamedAttributeArgumentAst> s_emptyNamedAttributeArguments;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ExpressionAst> <PositionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<NamedAttributeArgumentAst> <NamedArguments>k__BackingField;
    public ReadOnlyCollection`1<ExpressionAst> PositionalArguments { get; }
    public ReadOnlyCollection`1<NamedAttributeArgumentAst> NamedArguments { get; }
    public AttributeAst(IScriptExtent extent, ITypeName typeName, IEnumerable`1<ExpressionAst> positionalArguments, IEnumerable`1<NamedAttributeArgumentAst> namedArguments);
    private static AttributeAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ExpressionAst> get_PositionalArguments();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<NamedAttributeArgumentAst> get_NamedArguments();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal virtual Attribute GetAttribute();
}
public abstract class System.Management.Automation.Language.AttributeBaseAst : Ast {
    [CompilerGeneratedAttribute]
private ITypeName <TypeName>k__BackingField;
    public ITypeName TypeName { get; }
    protected AttributeBaseAst(IScriptExtent extent, ITypeName typeName);
    [CompilerGeneratedAttribute]
public ITypeName get_TypeName();
    internal abstract virtual Attribute GetAttribute();
}
public class System.Management.Automation.Language.AttributedExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Child>k__BackingField;
    [CompilerGeneratedAttribute]
private AttributeBaseAst <Attribute>k__BackingField;
    public ExpressionAst Child { get; }
    public AttributeBaseAst Attribute { get; }
    public AttributedExpressionAst(IScriptExtent extent, AttributeBaseAst attribute, ExpressionAst child);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Child();
    [CompilerGeneratedAttribute]
public AttributeBaseAst get_Attribute();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private ISupportsAssignment GetActualAssignableAst();
    private List`1<AttributeBaseAst> GetAttributes();
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
    private sealed virtual override Expression System.Management.Automation.Language.IAssignableValue.GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    private sealed virtual override Expression System.Management.Automation.Language.IAssignableValue.SetValue(Compiler compiler, Expression rhs);
}
public class System.Management.Automation.Language.BaseCtorInvokeMemberExpressionAst : InvokeMemberExpressionAst {
    public BaseCtorInvokeMemberExpressionAst(IScriptExtent baseKeywordExtent, IScriptExtent baseCallExtent, IEnumerable`1<ExpressionAst> arguments);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal virtual object Accept(ICustomAstVisitor visitor);
}
public class System.Management.Automation.Language.BinaryExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private TokenKind <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Left>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Right>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <ErrorPosition>k__BackingField;
    internal static PSTypeName[] BoolTypeNameArray;
    public TokenKind Operator { get; }
    public ExpressionAst Left { get; }
    public ExpressionAst Right { get; }
    public IScriptExtent ErrorPosition { get; }
    public Type StaticType { get; }
    public BinaryExpressionAst(IScriptExtent extent, ExpressionAst left, TokenKind operator, ExpressionAst right, IScriptExtent errorPosition);
    private static BinaryExpressionAst();
    [CompilerGeneratedAttribute]
public TokenKind get_Operator();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Left();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Right();
    [CompilerGeneratedAttribute]
public IScriptExtent get_ErrorPosition();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal static class System.Management.Automation.Language.BinderUtils : object {
    internal static BindingRestrictions GetVersionCheck(DynamicMetaObjectBinder binder, int expectedVersionNumber);
    internal static BindingRestrictions GetLanguageModeCheckIfHasEverUsedConstrainedLanguage();
    internal static BindingRestrictions GetOptionalVersionAndLanguageCheckForType(DynamicMetaObjectBinder binder, Type targetType, int expectedVersionNumber);
}
public class System.Management.Automation.Language.BlockStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <Kind>k__BackingField;
    public StatementBlockAst Body { get; }
    public Token Kind { get; }
    public BlockStatementAst(IScriptExtent extent, Token kind, StatementBlockAst body);
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
    [CompilerGeneratedAttribute]
public Token get_Kind();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.BreakStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Label>k__BackingField;
    public ExpressionAst Label { get; }
    public BreakStatementAst(IScriptExtent extent, ExpressionAst label);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Label();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal static class System.Management.Automation.Language.CachedReflectionInfo : object {
    internal static BindingFlags InstanceFlags;
    internal static BindingFlags StaticFlags;
    internal static BindingFlags StaticPublicFlags;
    internal static BindingFlags InstancePublicFlags;
    internal static ConstructorInfo ObjectList_ctor;
    internal static MethodInfo ObjectList_ToArray;
    internal static MethodInfo ArrayOps_GetMDArrayValue;
    internal static MethodInfo ArrayOps_GetMDArrayValueOrSlice;
    internal static MethodInfo ArrayOps_GetNonIndexable;
    internal static MethodInfo ArrayOps_IndexStringMessage;
    internal static MethodInfo ArrayOps_Multiply;
    internal static MethodInfo ArrayOps_SetMDArrayValue;
    internal static MethodInfo ArrayOps_SlicingIndex;
    internal static ConstructorInfo BreakException_ctor;
    internal static MethodInfo CharOps_CompareIeq;
    internal static MethodInfo CharOps_CompareIne;
    internal static MethodInfo CharOps_CompareStringIeq;
    internal static MethodInfo CharOps_CompareStringIne;
    internal static MethodInfo CommandParameterInternal_CreateArgument;
    internal static MethodInfo CommandParameterInternal_CreateParameter;
    internal static MethodInfo CommandParameterInternal_CreateParameterWithArgument;
    internal static MethodInfo CommandRedirection_UnbindForExpression;
    internal static ConstructorInfo ContinueException_ctor;
    internal static MethodInfo Convert_ChangeType;
    internal static MethodInfo Debugger_EnterScriptFunction;
    internal static MethodInfo Debugger_ExitScriptFunction;
    internal static MethodInfo Debugger_OnSequencePointHit;
    internal static MethodInfo EnumerableOps_AddEnumerable;
    internal static MethodInfo EnumerableOps_AddObject;
    internal static MethodInfo EnumerableOps_Compare;
    internal static MethodInfo EnumerableOps_GetEnumerator;
    internal static MethodInfo EnumerableOps_GetCOMEnumerator;
    internal static MethodInfo EnumerableOps_GetGenericEnumerator;
    internal static MethodInfo EnumerableOps_GetSlice;
    internal static MethodInfo EnumerableOps_MethodInvoker;
    internal static MethodInfo EnumerableOps_Where;
    internal static MethodInfo EnumerableOps_ForEach;
    internal static MethodInfo EnumerableOps_Multiply;
    internal static MethodInfo EnumerableOps_PropertyGetter;
    internal static MethodInfo EnumerableOps_SlicingIndex;
    internal static MethodInfo EnumerableOps_ToArray;
    internal static MethodInfo EnumerableOps_WriteEnumerableToPipe;
    internal static ConstructorInfo ErrorRecord__ctor;
    internal static PropertyInfo Exception_Message;
    internal static MethodInfo ExceptionHandlingOps_CheckActionPreference;
    internal static MethodInfo ExceptionHandlingOps_ConvertToArgumentConversionException;
    internal static MethodInfo ExceptionHandlingOps_ConvertToException;
    internal static MethodInfo ExceptionHandlingOps_ConvertToMethodInvocationException;
    internal static MethodInfo ExceptionHandlingOps_FindMatchingHandler;
    internal static MethodInfo ExceptionHandlingOps_RestoreStoppingPipeline;
    internal static MethodInfo ExceptionHandlingOps_SuspendStoppingPipeline;
    internal static PropertyInfo ExecutionContext_CurrentExceptionBeingHandled;
    internal static FieldInfo ExecutionContext_Debugger;
    internal static FieldInfo ExecutionContext_DebuggingMode;
    internal static PropertyInfo ExecutionContext_ExceptionHandlerInEnclosingStatementBlock;
    internal static MethodInfo ExecutionContext_IsStrictVersion;
    internal static PropertyInfo ExecutionContext_QuestionMarkVariableValue;
    internal static PropertyInfo ExecutionContext_LanguageMode;
    internal static PropertyInfo ExecutionContext_EngineIntrinsics;
    internal static MethodInfo FileRedirection_BindForExpression;
    internal static MethodInfo FileRedirection_CallDoCompleteForExpression;
    internal static ConstructorInfo FileRedirection_ctor;
    internal static MethodInfo FileRedirection_Dispose;
    internal static FieldInfo FunctionContext__currentSequencePointIndex;
    internal static FieldInfo FunctionContext__executionContext;
    internal static FieldInfo FunctionContext__functionName;
    internal static FieldInfo FunctionContext__localsTuple;
    internal static FieldInfo FunctionContext__outputPipe;
    internal static MethodInfo FunctionContext_PopTrapHandlers;
    internal static MethodInfo FunctionContext_PushTrapHandlers;
    internal static MethodInfo FunctionOps_DefineFunction;
    internal static ConstructorInfo Hashtable_ctor;
    internal static MethodInfo ByRefOps_GetByRefPropertyValue;
    internal static MethodInfo HashtableOps_Add;
    internal static MethodInfo HashtableOps_AddKeyValuePair;
    internal static PropertyInfo ICollection_Count;
    internal static MethodInfo IComparable_CompareTo;
    internal static MethodInfo IDisposable_Dispose;
    internal static MethodInfo IEnumerable_GetEnumerator;
    internal static PropertyInfo IEnumerator_Current;
    internal static MethodInfo IEnumerator_MoveNext;
    internal static MethodInfo IList_get_Item;
    internal static MethodInfo InterpreterError_NewInterpreterException;
    internal static MethodInfo InterpreterError_NewInterpreterExceptionWithInnerException;
    internal static MethodInfo LanguagePrimitives_GetInvalidCastMessages;
    internal static MethodInfo LanguagePrimitives_IsNull;
    internal static MethodInfo LanguagePrimitives_ThrowInvalidCastException;
    internal static MethodInfo LocalPipeline_GetExecutionContextFromTLS;
    internal static MethodInfo LoopFlowException_MatchLabel;
    internal static MethodInfo MergingRedirection_BindForExpression;
    internal static ConstructorInfo MethodException_ctor;
    internal static MethodInfo MutableTuple_IsValueSet;
    internal static MethodInfo Object_Equals;
    internal static ConstructorInfo OrderedDictionary_ctor;
    internal static MethodInfo Parser_ScanNumber;
    internal static MethodInfo ParserOps_ContainsOperatorCompiled;
    internal static MethodInfo ParserOps_ImplicitOp;
    internal static MethodInfo ParserOps_JoinOperator;
    internal static MethodInfo ParserOps_LikeOperator;
    internal static MethodInfo ParserOps_MatchOperator;
    internal static MethodInfo ParserOps_RangeOperator;
    internal static MethodInfo ParserOps_GetRangeEnumerator;
    internal static MethodInfo ParserOps_ReplaceOperator;
    internal static MethodInfo ParserOps_SplitOperator;
    internal static MethodInfo ParserOps_UnaryJoinOperator;
    internal static MethodInfo ParserOps_UnarySplitOperator;
    internal static ConstructorInfo Pipe_ctor;
    internal static MethodInfo Pipe_Add;
    internal static MethodInfo Pipe_SetVariableListForTemporaryPipe;
    internal static MethodInfo PipelineOps_CheckAutomationNullInCommandArgument;
    internal static MethodInfo PipelineOps_CheckAutomationNullInCommandArgumentArray;
    internal static MethodInfo PipelineOps_CheckForInterrupts;
    internal static MethodInfo PipelineOps_GetExitException;
    internal static MethodInfo PipelineOps_FlushPipe;
    internal static MethodInfo PipelineOps_InvokePipeline;
    internal static MethodInfo PipelineOps_InvokePipelineInBackground;
    internal static MethodInfo PipelineOps_Nop;
    internal static MethodInfo PipelineOps_PipelineResult;
    internal static MethodInfo PipelineOps_ClearPipe;
    internal static MethodInfo PSGetDynamicMemberBinder_GetIDictionaryMember;
    internal static MethodInfo PSGetMemberBinder_CloneMemberInfo;
    internal static MethodInfo PSGetMemberBinder_GetAdaptedValue;
    internal static MethodInfo PSGetMemberBinder_GetTypeTableFromTLS;
    internal static MethodInfo PSGetMemberBinder_IsTypeNameSame;
    internal static MethodInfo PSGetMemberBinder_TryGetGenericDictionaryValue;
    internal static MethodInfo PSGetMemberBinder_TryGetInstanceMember;
    internal static MethodInfo PSGetMemberBinder_TryGetIDictionaryValue;
    internal static MethodInfo PSInvokeMemberBinder_InvokeAdaptedMember;
    internal static MethodInfo PSInvokeMemberBinder_InvokeAdaptedSetMember;
    internal static MethodInfo PSInvokeMemberBinder_IsHeterogeneousArray;
    internal static MethodInfo PSInvokeMemberBinder_IsHomogeneousArray;
    internal static MethodInfo PSInvokeMemberBinder_TryGetInstanceMethod;
    internal static MethodInfo PSMethodInfo_Invoke;
    internal static PropertyInfo PSNoteProperty_Value;
    internal static MethodInfo PSObject_Base;
    internal static PropertyInfo PSObject_BaseObject;
    internal static PropertyInfo PSObject_IsDeserialized;
    internal static MethodInfo PSObject_ToStringParser;
    internal static PropertyInfo PSReference_Value;
    internal static MethodInfo PSScriptMethod_InvokeScript;
    internal static MethodInfo PSScriptProperty_InvokeGetter;
    internal static MethodInfo PSScriptProperty_InvokeSetter;
    internal static MethodInfo PSSetMemberBinder_SetAdaptedValue;
    internal static MethodInfo PSVariableAssignmentBinder_CopyInstanceMembersOfValueType;
    internal static FieldInfo PSVariableAssignmentBinder__mutableValueWithInstanceMemberVersion;
    internal static MethodInfo PSCreateInstanceBinder_IsTargetTypeNonPublic;
    internal static MethodInfo PSCreateInstanceBinder_IsTargetTypeByRefLike;
    internal static MethodInfo PSCreateInstanceBinder_GetTargetTypeName;
    internal static MethodInfo ReservedNameMembers_GeneratePSAdaptedMemberSet;
    internal static MethodInfo ReservedNameMembers_GeneratePSBaseMemberSet;
    internal static MethodInfo ReservedNameMembers_GeneratePSExtendedMemberSet;
    internal static MethodInfo ReservedNameMembers_GeneratePSObjectMemberSet;
    internal static MethodInfo ReservedNameMembers_PSTypeNames;
    internal static MethodInfo RestrictedLanguageChecker_CheckDataStatementLanguageModeAtRuntime;
    internal static MethodInfo RestrictedLanguageChecker_CheckDataStatementAstAtRuntime;
    internal static MethodInfo RestrictedLanguageChecker_EnsureUtilityModuleLoaded;
    internal static ConstructorInfo ReturnException_ctor;
    internal static PropertyInfo RuntimeException_ErrorRecord;
    internal static MethodInfo ScriptBlock_DoInvokeReturnAsIs;
    internal static MethodInfo ScriptBlock_InvokeAsDelegateHelper;
    internal static MethodInfo ScriptBlockExpressionWrapper_GetScriptBlock;
    internal static ConstructorInfo SetValueException_ctor;
    internal static ConstructorInfo GetValueException_ctor;
    internal static ConstructorInfo StreamReader_ctor;
    internal static MethodInfo StreamReader_ReadLine;
    internal static ConstructorInfo String_ctor_char_int;
    internal static MethodInfo String_Concat_String;
    internal static MethodInfo String_Equals;
    internal static MethodInfo StringOps_Compare;
    internal static MethodInfo StringOps_Equals;
    internal static MethodInfo StringOps_FormatOperator;
    internal static MethodInfo StringOps_Multiply;
    internal static MethodInfo SwitchOps_ConditionSatisfiedRegex;
    internal static MethodInfo SwitchOps_ConditionSatisfiedWildcard;
    internal static MethodInfo SwitchOps_ResolveFilePath;
    internal static MethodInfo TypeOps_AsOperator;
    internal static MethodInfo TypeOps_AddPowerShellTypesToTheScope;
    internal static MethodInfo TypeOps_InitPowerShellTypesAtRuntime;
    internal static MethodInfo TypeOps_SetCurrentTypeResolutionState;
    internal static MethodInfo TypeOps_SetAssemblyDefiningPSTypes;
    internal static MethodInfo TypeOps_IsInstance;
    internal static MethodInfo TypeOps_ResolveTypeName;
    internal static MethodInfo VariableOps_GetUsingValue;
    internal static MethodInfo VariableOps_GetVariableAsRef;
    internal static MethodInfo VariableOps_GetVariableValue;
    internal static MethodInfo VariableOps_GetAutomaticVariableValue;
    internal static MethodInfo VariableOps_SetVariableValue;
    internal static MethodInfo Utils_IsComObject;
    internal static MethodInfo ClassOps_ValidateSetProperty;
    internal static MethodInfo ClassOps_CallBaseCtor;
    internal static MethodInfo ClassOps_CallMethodNonVirtually;
    internal static MethodInfo ClassOps_CallVoidMethodNonVirtually;
    internal static MethodInfo ArgumentTransformationAttribute_Transform;
    internal static MethodInfo MemberInvocationLoggingOps_LogMemberInvocation;
    private static CachedReflectionInfo();
}
public class System.Management.Automation.Language.CatchClauseAst : Ast {
    private static ReadOnlyCollection`1<TypeConstraintAst> s_emptyCatchTypes;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TypeConstraintAst> <CatchTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    public ReadOnlyCollection`1<TypeConstraintAst> CatchTypes { get; }
    public bool IsCatchAll { get; }
    public StatementBlockAst Body { get; }
    public CatchClauseAst(IScriptExtent extent, IEnumerable`1<TypeConstraintAst> catchTypes, StatementBlockAst body);
    private static CatchClauseAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TypeConstraintAst> get_CatchTypes();
    public bool get_IsCatchAll();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public abstract class System.Management.Automation.Language.ChainableAst : PipelineBaseAst {
    protected ChainableAst(IScriptExtent extent);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.CharExtensions : object {
    private static CharTraits[] s_traits;
    private static CharExtensions();
    public static bool IsCurlyBracket(char c);
    [ExtensionAttribute]
internal static bool IsWhitespace(char c);
    [ExtensionAttribute]
internal static bool IsDash(char c);
    [ExtensionAttribute]
internal static bool IsSingleQuote(char c);
    [ExtensionAttribute]
internal static bool IsDoubleQuote(char c);
    [ExtensionAttribute]
internal static bool IsVariableStart(char c);
    [ExtensionAttribute]
internal static bool IsIdentifierStart(char c);
    [ExtensionAttribute]
internal static bool IsIdentifierFollow(char c);
    [ExtensionAttribute]
internal static bool IsHexDigit(char c);
    [ExtensionAttribute]
internal static bool IsDecimalDigit(char c);
    [ExtensionAttribute]
internal static bool IsBinaryDigit(char c);
    [ExtensionAttribute]
internal static bool IsTypeSuffix(char c);
    [ExtensionAttribute]
internal static bool IsMultiplierStart(char c);
    [ExtensionAttribute]
internal static bool ForceStartNewToken(char c);
    [ExtensionAttribute]
internal static bool ForceStartNewTokenAfterNumber(char c, bool forceEndNumberOnTernaryOperatorChars);
    [ExtensionAttribute]
internal static bool ForceStartNewTokenInAssemblyNameSpec(char c);
}
[FlagsAttribute]
internal enum System.Management.Automation.Language.CharTraits : Enum {
    public int value__;
    public static CharTraits None;
    public static CharTraits IdentifierStart;
    public static CharTraits MultiplierStart;
    public static CharTraits TypeSuffix;
    public static CharTraits Whitespace;
    public static CharTraits Newline;
    public static CharTraits HexDigit;
    public static CharTraits Digit;
    public static CharTraits VarNameFirst;
    public static CharTraits ForceStartNewToken;
    public static CharTraits ForceStartNewAssemblyNameSpecToken;
    public static CharTraits ForceStartNewTokenAfterNumber;
}
public static class System.Management.Automation.Language.CodeGeneration : object {
    public static string EscapeSingleQuotedStringContent(string value);
    public static string EscapeBlockCommentContent(string value);
    public static string EscapeFormatStringContent(string value);
    public static string EscapeVariableName(string value);
}
public class System.Management.Automation.Language.CommandAst : CommandBaseAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CommandElementAst> <CommandElements>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenKind <InvocationOperator>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicKeyword <DefiningKeyword>k__BackingField;
    public ReadOnlyCollection`1<CommandElementAst> CommandElements { get; }
    public TokenKind InvocationOperator { get; }
    public DynamicKeyword DefiningKeyword { get; public set; }
    public CommandAst(IScriptExtent extent, IEnumerable`1<CommandElementAst> commandElements, TokenKind invocationOperator, IEnumerable`1<RedirectionAst> redirections);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CommandElementAst> get_CommandElements();
    [CompilerGeneratedAttribute]
public TokenKind get_InvocationOperator();
    public string GetCommandName();
    [CompilerGeneratedAttribute]
public DynamicKeyword get_DefiningKeyword();
    [CompilerGeneratedAttribute]
public void set_DefiningKeyword(DynamicKeyword value);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public abstract class System.Management.Automation.Language.CommandBaseAst : StatementAst {
    private static ReadOnlyCollection`1<RedirectionAst> s_emptyRedirections;
    internal static int MaxRedirections;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<RedirectionAst> <Redirections>k__BackingField;
    public ReadOnlyCollection`1<RedirectionAst> Redirections { get; }
    protected CommandBaseAst(IScriptExtent extent, IEnumerable`1<RedirectionAst> redirections);
    private static CommandBaseAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<RedirectionAst> get_Redirections();
}
public abstract class System.Management.Automation.Language.CommandElementAst : Ast {
    protected CommandElementAst(IScriptExtent extent);
}
public class System.Management.Automation.Language.CommandExpressionAst : CommandBaseAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Expression>k__BackingField;
    public ExpressionAst Expression { get; }
    public CommandExpressionAst(IScriptExtent extent, ExpressionAst expression, IEnumerable`1<RedirectionAst> redirections);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Expression();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.CommandParameterAst : CommandElementAst {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <ErrorPosition>k__BackingField;
    public string ParameterName { get; }
    public ExpressionAst Argument { get; }
    public IScriptExtent ErrorPosition { get; }
    public CommandParameterAst(IScriptExtent extent, string parameterName, ExpressionAst argument, IScriptExtent errorPosition);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Argument();
    [CompilerGeneratedAttribute]
public IScriptExtent get_ErrorPosition();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.CommentHelpInfo : object {
    [CompilerGeneratedAttribute]
private string <Synopsis>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Notes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Links>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Examples>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Inputs>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <Outputs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Role>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Functionality>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForwardHelpTargetName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ForwardHelpCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RemoteHelpRunspace>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MamlHelpFile>k__BackingField;
    public string Synopsis { get; internal set; }
    public string Description { get; internal set; }
    public string Notes { get; internal set; }
    public IDictionary`2<string, string> Parameters { get; internal set; }
    public ReadOnlyCollection`1<string> Links { get; internal set; }
    public ReadOnlyCollection`1<string> Examples { get; internal set; }
    public ReadOnlyCollection`1<string> Inputs { get; internal set; }
    public ReadOnlyCollection`1<string> Outputs { get; internal set; }
    public string Component { get; internal set; }
    public string Role { get; internal set; }
    public string Functionality { get; internal set; }
    public string ForwardHelpTargetName { get; internal set; }
    public string ForwardHelpCategory { get; internal set; }
    public string RemoteHelpRunspace { get; internal set; }
    public string MamlHelpFile { get; internal set; }
    [CompilerGeneratedAttribute]
public string get_Synopsis();
    [CompilerGeneratedAttribute]
internal void set_Synopsis(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
internal void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Notes();
    [CompilerGeneratedAttribute]
internal void set_Notes(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Parameters();
    [CompilerGeneratedAttribute]
internal void set_Parameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Links();
    [CompilerGeneratedAttribute]
internal void set_Links(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Examples();
    [CompilerGeneratedAttribute]
internal void set_Examples(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Inputs();
    [CompilerGeneratedAttribute]
internal void set_Inputs(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_Outputs();
    [CompilerGeneratedAttribute]
internal void set_Outputs(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
internal void set_Component(string value);
    [CompilerGeneratedAttribute]
public string get_Role();
    [CompilerGeneratedAttribute]
internal void set_Role(string value);
    [CompilerGeneratedAttribute]
public string get_Functionality();
    [CompilerGeneratedAttribute]
internal void set_Functionality(string value);
    [CompilerGeneratedAttribute]
public string get_ForwardHelpTargetName();
    [CompilerGeneratedAttribute]
internal void set_ForwardHelpTargetName(string value);
    [CompilerGeneratedAttribute]
public string get_ForwardHelpCategory();
    [CompilerGeneratedAttribute]
internal void set_ForwardHelpCategory(string value);
    [CompilerGeneratedAttribute]
public string get_RemoteHelpRunspace();
    [CompilerGeneratedAttribute]
internal void set_RemoteHelpRunspace(string value);
    [CompilerGeneratedAttribute]
public string get_MamlHelpFile();
    [CompilerGeneratedAttribute]
internal void set_MamlHelpFile(string value);
    public string GetCommentBlock();
}
internal class System.Management.Automation.Language.Compiler : object {
    internal static ParameterExpression s_executionContextParameter;
    internal static ParameterExpression s_functionContext;
    private static ParameterExpression s_returnPipe;
    private static Expression s_notDollarQuestion;
    private static Expression s_getDollarQuestion;
    private static Expression s_setDollarQuestionToTrue;
    private static Expression s_callCheckForInterrupts;
    private static Expression s_getCurrentPipe;
    private static Expression s_currentExceptionBeingHandled;
    private static CatchBlock s_catchFlowControl;
    private static CatchBlock[] s_stmtCatchHandlers;
    internal static Type DottedLocalsTupleType;
    internal static Dictionary`2<string, int> DottedLocalsNameIndexMap;
    internal static Dictionary`2<string, int> DottedScriptCmdletLocalsNameIndexMap;
    [CompilerGeneratedAttribute]
private bool <CompilingConstantExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <LocalVariablesTupleType>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterExpression <LocalVariablesParameter>k__BackingField;
    private SymbolDocumentInfo _debugSymbolDocument;
    internal TypeDefinitionAst _memberFunctionType;
    private bool _compilingTrap;
    private bool _compilingSingleExpression;
    private bool _compilingScriptCmdlet;
    private string _currentFunctionName;
    private int _switchTupleIndex;
    private int _foreachTupleIndex;
    private List`1<IScriptExtent> _sequencePoints;
    private Dictionary`2<IScriptExtent, int> _sequencePointIndexMap;
    private int _stmtCount;
    [CompilerGeneratedAttribute]
private bool <CompilingMemberFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecialMemberFunctionType <SpecialMemberFunctionType>k__BackingField;
    private Type _memberFunctionReturnType;
    private int _tempCounter;
    private static Dictionary`2<CallInfo, Delegate> s_attributeGeneratorCache;
    private static Dictionary`2<Type, Func`2<AttributeAst, Attribute>> s_builtinAttributeGenerator;
    private static CallSite`1<Func`3<CallSite, object, int>> s_attrArgToIntConverter;
    internal static CallSite`1<Func`3<CallSite, object, string>> s_attrArgToStringConverter;
    private static CallSite`1<Func`3<CallSite, object, String[]>> s_attrArgToStringArrayConverter;
    private static CallSite`1<Func`3<CallSite, object, bool>> s_attrArgToBoolConverter;
    private static CallSite`1<Func`3<CallSite, object, ConfirmImpact>> s_attrArgToConfirmImpactConverter;
    private static CallSite`1<Func`3<CallSite, object, RemotingCapability>> s_attrArgToRemotingCapabilityConverter;
    private static CallSite`1<Func`3<CallSite, object, ExperimentAction>> s_attrArgToExperimentActionConverter;
    private static ConstantValueVisitor s_cvv;
    private LabelTarget _returnTarget;
    private Expression`1<Action`1<FunctionContext>> _dynamicParamBlockLambda;
    private Expression`1<Action`1<FunctionContext>> _beginBlockLambda;
    private Expression`1<Action`1<FunctionContext>> _processBlockLambda;
    private Expression`1<Action`1<FunctionContext>> _endBlockLambda;
    private Expression`1<Action`1<FunctionContext>> _cleanBlockLambda;
    private List`1<LoopGotoTargets> _loopTargets;
    private bool _generatingWhileOrDoLoop;
    private int _trapNestingCount;
    internal bool CompilingConstantExpression { get; internal set; }
    internal bool Optimize { get; private set; }
    internal Type LocalVariablesTupleType { get; private set; }
    internal ParameterExpression LocalVariablesParameter { get; private set; }
    internal bool CompilingMemberFunction { get; internal set; }
    internal SpecialMemberFunctionType SpecialMemberFunctionType { get; internal set; }
    internal Type MemberFunctionReturnType { get; internal set; }
    private static Compiler();
    private Compiler(List`1<IScriptExtent> sequencePoints, Dictionary`2<IScriptExtent, int> sequencePointIndexMap);
    [CompilerGeneratedAttribute]
internal bool get_CompilingConstantExpression();
    [CompilerGeneratedAttribute]
internal void set_CompilingConstantExpression(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Optimize();
    [CompilerGeneratedAttribute]
private void set_Optimize(bool value);
    [CompilerGeneratedAttribute]
internal Type get_LocalVariablesTupleType();
    [CompilerGeneratedAttribute]
private void set_LocalVariablesTupleType(Type value);
    [CompilerGeneratedAttribute]
internal ParameterExpression get_LocalVariablesParameter();
    [CompilerGeneratedAttribute]
private void set_LocalVariablesParameter(ParameterExpression value);
    [CompilerGeneratedAttribute]
internal bool get_CompilingMemberFunction();
    [CompilerGeneratedAttribute]
internal void set_CompilingMemberFunction(bool value);
    [CompilerGeneratedAttribute]
internal SpecialMemberFunctionType get_SpecialMemberFunctionType();
    [CompilerGeneratedAttribute]
internal void set_SpecialMemberFunctionType(SpecialMemberFunctionType value);
    internal Type get_MemberFunctionReturnType();
    internal void set_MemberFunctionReturnType(Type value);
    internal Expression Compile(Ast ast);
    internal Expression CompileExpressionOperand(ExpressionAst exprAst);
    private IEnumerable`1<Expression> CompileInvocationArguments(IReadOnlyList`1<ExpressionAst> arguments);
    internal Expression ReduceAssignment(ISupportsAssignment left, TokenKind tokenKind, Expression right);
    private static Expression Coalesce(Expression left, Expression right);
    internal Expression GetLocal(int tupleIndex);
    internal static Expression CallGetVariable(Expression variablePath, VariableExpressionAst varAst);
    internal static Expression CallSetVariable(Expression variablePath, Expression rhs, Expression attributes);
    internal Expression GetAutomaticVariable(VariableExpressionAst varAst);
    internal static Expression CallStringEquals(Expression left, Expression right, bool ignoreCase);
    internal static Expression IsStrictMode(int version, Expression executionContext);
    private int AddSequencePoint(IScriptExtent extent);
    private Expression UpdatePosition(Ast ast);
    internal ParameterExpression NewTemp(Type type, string name);
    internal static Type GetTypeConstraintForMethodResolution(ExpressionAst expr);
    internal static PSMethodInvocationConstraints CombineTypeConstraintForMethodResolution(Type targetType, Type argType);
    internal static PSMethodInvocationConstraints CombineTypeConstraintForMethodResolution(Type targetType, Type[] argTypes, Object[] genericArguments);
    internal static Expression ConvertValue(TypeConstraintAst typeConstraint, Expression expr);
    internal static Expression ConvertValue(Expression expr, List`1<AttributeBaseAst> conversions);
    internal static RuntimeDefinedParameterDictionary GetParameterMetaData(ReadOnlyCollection`1<ParameterAst> parameters, bool automaticPositions, Boolean& usesCmdletBinding);
    private static Delegate GetAttributeGenerator(CallInfo callInfo);
    private static void CheckNoPositionalArgs(AttributeAst ast);
    private static void CheckNoNamedArgs(AttributeAst ast);
    private static ValueTuple`2<string, ExperimentAction> GetFeatureNameAndAction(AttributeAst ast);
    private static Attribute NewCmdletBindingAttribute(AttributeAst ast);
    private static Attribute NewExperimentalAttribute(AttributeAst ast);
    private static Attribute NewParameterAttribute(AttributeAst ast);
    private static Attribute NewOutputTypeAttribute(AttributeAst ast);
    private static Attribute NewAliasAttribute(AttributeAst ast);
    private static Attribute NewValidateSetAttribute(AttributeAst ast);
    private static Attribute NewDebuggerHiddenAttribute(AttributeAst ast);
    private static Attribute NewValidateNotNullOrEmptyAttribute(AttributeAst ast);
    private static Attribute NewValidateNotNullAttribute(AttributeAst ast);
    internal static Attribute GetAttribute(AttributeAst attributeAst);
    internal static Attribute GetAttribute(TypeConstraintAst typeConstraintAst);
    private static RuntimeDefinedParameter GetRuntimeDefinedParameter(ParameterAst parameterAst, Boolean& customParameterSet, Boolean& usesCmdletBinding);
    internal static bool TryGetDefaultParameterValue(Type type, Object& value);
    internal void Compile(CompiledScriptBlockData scriptBlock, bool optimize);
    private static Action`1<FunctionContext> CompileTree(Expression`1<Action`1<FunctionContext>> lambda, CompileInterpretChoice compileInterpretChoice);
    internal static object GetExpressionValue(ExpressionAst expressionAst, bool isTrustedInput, ExecutionContext context, IDictionary usingValues);
    internal static object GetExpressionValue(ExpressionAst expressionAst, bool isTrustedInput, ExecutionContext context, SessionStateInternal sessionStateInternal, IDictionary usingValues);
    private static object GetExpressionValue(ExpressionAst expressionAst, bool isTrustedInput, ExecutionContext context, SessionStateInternal sessionStateInternal, IDictionary usingValues, Func`2& lambda, IScriptExtent[]& sequencePoints, Type& localsTupleType);
    private Func`2<FunctionContext, object> CompileSingleExpression(ExpressionAst expressionAst, IScriptExtent[]& sequencePoints, Type& localsTupleType);
    private Expression CaptureAstResults(Ast ast, CaptureAstContext context, MergeRedirectExprs generateRedirectExprs);
    private Expression CaptureStatementResultsHelper(StatementAst stmt, CaptureAstContext context, MergeRedirectExprs generateRedirectExprs);
    private Expression CaptureStatementResults(StatementAst stmt, CaptureAstContext context, MergeRedirectExprs generateRedirectExprs);
    internal Expression CallAddPipe(Expression expr, Expression pipe);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    private Expression`1<Action`1<FunctionContext>> CompileNamedBlock(NamedBlockAst namedBlockAst, string funcName, ScriptBlockAst rootForDefiningTypes);
    private Tuple`2<Action`1<FunctionContext>, Type> CompileTrap(TrapStatementAst trap);
    private Expression`1<Action`1<FunctionContext>> CompileSingleLambda(ReadOnlyCollection`1<StatementAst> statements, ReadOnlyCollection`1<TrapStatementAst> traps, string funcName, IScriptExtent entryExtent, IScriptExtent exitExtent, ScriptBlockAst rootForDefiningTypesAndUsings);
    private static void GenerateTypesAndUsings(ScriptBlockAst rootForDefiningTypesAndUsings, List`1<Expression> exprs);
    internal static void GenerateLoadUsings(IEnumerable`1<UsingStatementAst> usingStatements, bool allUsingsAreNamespaces, List`1<Expression> exprs);
    internal static Assembly DefinePowerShellTypes(Ast rootForDefiningTypes, TypeDefinitionAst[] typeAsts);
    private static Dictionary`2<string, TypeDefinitionAst> LoadUsingsImpl(IEnumerable`1<UsingStatementAst> usingAsts, Assembly[]& assemblies);
    private static void PopulateRuntimeTypes(ReadOnlyDictionary`2<string, TypeDefinitionAst> parseTimeTypes, ReadOnlyDictionary`2<string, TypeDefinitionAst> runtimeTypes);
    private static Assembly LoadAssembly(string assemblyName, string scriptFileName);
    private static PSModuleInfo LoadModule(PSModuleInfo originalModuleInfo);
    private void GenerateFunctionProlog(List`1<Expression> exprs, List`1<ParameterExpression> temps, IScriptExtent entryExtent);
    private Expression InitializeMemberProperties(Expression ourThis);
    private void GenerateFunctionEpilog(List`1<Expression> exprs, IScriptExtent exitExtent);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    private void CompileStatementListWithTraps(ReadOnlyCollection`1<StatementAst> statements, ReadOnlyCollection`1<TrapStatementAst> traps, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    private void CompileTrappableExpression(List`1<Expression> exprList, StatementAst stmt);
    private bool ShouldSetExecutionStatusToSuccess(StatementAst statementAst);
    private bool ShouldSetExecutionStatusToSuccess(PipelineAst pipelineAst);
    private static ExpressionAst GetSingleExpressionFromPipeline(PipelineAst pipelineAst);
    private bool ShouldSetExecutionStatusToSuccess(AssignmentStatementAst assignmentStatementAst);
    private bool ShouldSetExecutionStatusToSuccess(ExpressionAst expressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatementAst);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    private Expression CompileAssignment(AssignmentStatementAst assignmentStatementAst, MergeRedirectExprs generateRedirectExprs);
    public sealed virtual object VisitPipelineChain(PipelineChainAst pipelineChainAst);
    private Expression CompilePipelineChainElement(PipelineAst pipelineAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    private object GetCommandRedirections(CommandBaseAst command);
    private Expression GetRedirectedExpression(CommandExpressionAst commandExpr, bool captureForInput);
    private void AddMergeRedirectionExpressions(ReadOnlyCollection`1<RedirectionAst> redirections, List`1<ParameterExpression> temps, List`1<Expression> exprs, List`1<Expression> finallyExprs);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    private Expression GetCommandArgumentExpression(CommandElementAst element);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    internal static Expression ThrowRuntimeError(string errorID, string resourceString, Expression[] exceptionArgs);
    internal static Expression ThrowRuntimeError(string errorID, string resourceString, Type throwResultType, Expression[] exceptionArgs);
    internal static Expression ThrowRuntimeError(Type exceptionType, string errorID, string resourceString, Type throwResultType, Expression[] exceptionArgs);
    internal static Expression ThrowRuntimeErrorWithInnerException(string errorID, string resourceString, Expression innerException, Expression[] exceptionArgs);
    internal static Expression ThrowRuntimeErrorWithInnerException(string errorID, Expression resourceString, Expression innerException, Type throwResultType, Expression[] exceptionArgs);
    internal static Expression CreateThrow(Type resultType, Type exception, Type[] exceptionArgTypes, Object[] exceptionArgs);
    internal static Expression CreateThrow(Type resultType, Type exception, Object[] exceptionArgs);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    private Action`2<List`1<Expression>, Expression> GetSwitchBodyGenerator(SwitchStatementAst switchStatementAst, AutomaticVarSaver avs, ParameterExpression skipDefault);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    private static CatchBlock[] GenerateLoopBreakContinueCatchBlocks(string label, LabelTarget breakLabel, LabelTarget continueLabel);
    private Expression GenerateWhileLoop(string loopLabel, Func`1<Expression> generateCondition, Action`3<List`1<Expression>, LabelTarget, LabelTarget> generateLoopBody, PipelineBaseAst continueAst);
    private Expression GenerateDoLoop(LoopStatementAst loopStatement);
    private Expression GenerateIteratorStatement(VariablePath iteratorVariablePath, Func`1<Expression> generateMoveNextUpdatePosition, int iteratorTupleIndex, LabeledStatementAst stmt, Action`2<List`1<Expression>, Expression> generateBody);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    private Expression GetRangeEnumerator(ExpressionAst condExpr);
    private Expression UpdatePositionForInitializerOrCondition(PipelineBaseAst pipelineBaseAst, Expression initializerOrCondition);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    private Expression GenerateBreakOrContinue(Ast ast, ExpressionAst label, Func`2<LoopGotoTargets, LabelTarget> fieldSelector, Func`2<LabelTarget, Expression> exprGenerator, ConstructorInfo nonLocalExceptionCtor);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public Expression GenerateCallContains(Expression lhs, Expression rhs, bool ignoreCase);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    private static Expression GetLikeRHSOperand(WildcardOptions options, Expression expr);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    private Expression CompileIncrementOrDecrement(ExpressionAst exprAst, int valueToAdd, bool prefix);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpression);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    internal Expression CompileTypeName(ITypeName typeName, IScriptExtent errorPos);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    internal static PSMethodInvocationConstraints GetInvokeMemberConstraints(InvokeMemberExpressionAst invokeMemberExpressionAst);
    internal static PSMethodInvocationConstraints GetInvokeMemberConstraints(BaseCtorInvokeMemberExpressionAst invokeMemberExpressionAst);
    internal Expression InvokeMember(string name, PSMethodInvocationConstraints constraints, Expression target, IEnumerable`1<Expression> args, bool static, bool propertySet, bool nullConditional);
    private static Expression InvokeBaseCtorMethod(PSMethodInvocationConstraints constraints, Expression target, IEnumerable`1<Expression> args);
    internal Expression InvokeDynamicMember(Expression memberNameExpr, PSMethodInvocationConstraints constraints, Expression target, IEnumerable`1<Expression> args, bool static, bool propertySet, bool nullConditional);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.Compiler/<BuildHashtable>d__234")]
private IEnumerable`1<Expression> BuildHashtable(ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementAst>> keyValuePairs, ParameterExpression temp, bool ordered);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    private static Expression GetNullConditionalWrappedExpression(Expression targetExpr, Expression memberAccessExpression);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    [CompilerGeneratedAttribute]
private Expression <VisitDataStatement>b__190_0(ExpressionAst elem);
}
internal class System.Management.Automation.Language.CompilerGeneratedMemberFunctionAst : MemberAst {
    [CompilerGeneratedAttribute]
private TypeDefinitionAst <DefiningType>k__BackingField;
    [CompilerGeneratedAttribute]
private SpecialMemberFunctionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlockAst <Body>k__BackingField;
    public string Name { get; }
    internal TypeDefinitionAst DefiningType { get; }
    internal SpecialMemberFunctionType Type { get; }
    public ReadOnlyCollection`1<ParameterAst> Parameters { get; }
    public ScriptBlockAst Body { get; }
    internal CompilerGeneratedMemberFunctionAst(IScriptExtent extent, TypeDefinitionAst definingType, SpecialMemberFunctionType type);
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
internal TypeDefinitionAst get_DefiningType();
    [CompilerGeneratedAttribute]
internal SpecialMemberFunctionType get_Type();
    internal virtual string GetTooltip();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    public sealed virtual bool HasAnyScriptBlockAttributes();
    public sealed virtual RuntimeDefinedParameterDictionary GetParameterMetadata(bool automaticPositions, Boolean& usesCmdletBinding);
    public sealed virtual IEnumerable`1<Attribute> GetScriptBlockAttributes();
    public sealed virtual IEnumerable`1<ExperimentalAttribute> GetExperimentalAttributes();
    public sealed virtual bool UsesCmdletBinding();
    public sealed virtual ReadOnlyCollection`1<ParameterAst> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ScriptBlockAst get_Body();
    public sealed virtual PowerShell GetPowerShell(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    public sealed virtual string GetWithInputHandlingForInvokeCommand();
    public sealed virtual Tuple`2<string, string> GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
}
public class System.Management.Automation.Language.ConfigurationDefinitionAst : StatementAst {
    [CompilerGeneratedAttribute]
private ScriptBlockExpressionAst <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfigurationType <ConfigurationType>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <LCurlyToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <ConfigurationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<AttributeAst> <CustomAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DynamicKeyword> <DefinedKeywords>k__BackingField;
    private static string ConfigurationBuildInParametersStr;
    private static List`1<ParameterAst> s_configurationBuildInParameters;
    private static List`1<AttributeAst> s_configurationBuildInParameterAttrAsts;
    private static List`1<StatementAst> s_configurationExtraParameterStatements;
    public ScriptBlockExpressionAst Body { get; }
    public ConfigurationType ConfigurationType { get; }
    public ExpressionAst InstanceName { get; }
    internal Token LCurlyToken { get; internal set; }
    internal Token ConfigurationToken { get; internal set; }
    internal IEnumerable`1<AttributeAst> CustomAttributes { get; internal set; }
    internal List`1<DynamicKeyword> DefinedKeywords { get; internal set; }
    private static IEnumerable`1<ParameterAst> ConfigurationBuildInParameters { get; }
    private static IEnumerable`1<AttributeAst> ConfigurationBuildInParameterAttribAsts { get; }
    private static IEnumerable`1<StatementAst> ConfigurationExtraParameterStatements { get; }
    public ConfigurationDefinitionAst(IScriptExtent extent, ScriptBlockExpressionAst body, ConfigurationType type, ExpressionAst instanceName);
    [CompilerGeneratedAttribute]
public ScriptBlockExpressionAst get_Body();
    [CompilerGeneratedAttribute]
public ConfigurationType get_ConfigurationType();
    [CompilerGeneratedAttribute]
public ExpressionAst get_InstanceName();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    [CompilerGeneratedAttribute]
internal Token get_LCurlyToken();
    [CompilerGeneratedAttribute]
internal void set_LCurlyToken(Token value);
    [CompilerGeneratedAttribute]
internal Token get_ConfigurationToken();
    [CompilerGeneratedAttribute]
internal void set_ConfigurationToken(Token value);
    [CompilerGeneratedAttribute]
internal IEnumerable`1<AttributeAst> get_CustomAttributes();
    [CompilerGeneratedAttribute]
internal void set_CustomAttributes(IEnumerable`1<AttributeAst> value);
    [CompilerGeneratedAttribute]
internal List`1<DynamicKeyword> get_DefinedKeywords();
    [CompilerGeneratedAttribute]
internal void set_DefinedKeywords(List`1<DynamicKeyword> value);
    internal PipelineAst GenerateSetItemPipelineAst();
    private static bool IsImportCommand(StatementAst stmt, List`1<Tuple`3<String[], ModuleSpecification[], Version>> resourceModulePairsToImport);
    private static IEnumerable`1<ParameterAst> get_ConfigurationBuildInParameters();
    private static IEnumerable`1<AttributeAst> get_ConfigurationBuildInParameterAttribAsts();
    private static IEnumerable`1<StatementAst> get_ConfigurationExtraParameterStatements();
}
public enum System.Management.Automation.Language.ConfigurationType : Enum {
    public int value__;
    public static ConfigurationType Resource;
    public static ConfigurationType Meta;
}
public class System.Management.Automation.Language.ConstantExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    public object Value { get; }
    public Type StaticType { get; }
    public ConstantExpressionAst(IScriptExtent extent, object value);
    internal ConstantExpressionAst(NumberToken token);
    [CompilerGeneratedAttribute]
public object get_Value();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.ConstantValueVisitor : object {
    [CompilerGeneratedAttribute]
private bool <AttributeArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequiresArgument>k__BackingField;
    internal bool AttributeArgument { get; internal set; }
    internal bool RequiresArgument { get; internal set; }
    [CompilerGeneratedAttribute]
internal bool get_AttributeArgument();
    [CompilerGeneratedAttribute]
internal void set_AttributeArgument(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RequiresArgument();
    [CompilerGeneratedAttribute]
internal void set_RequiresArgument(bool value);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("ASSERTIONS_TRACE")]
private void CheckIsConstant(Ast ast, string msg);
    private static object CompileAndInvoke(Ast ast);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    [CompilerGeneratedAttribute]
private object <VisitArrayLiteral>b__68_0(ExpressionAst e);
}
public class System.Management.Automation.Language.ContinueStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Label>k__BackingField;
    public ExpressionAst Label { get; }
    public ContinueStatementAst(IScriptExtent extent, ExpressionAst label);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Label();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ConvertExpressionAst : AttributedExpressionAst {
    public TypeConstraintAst Type { get; }
    public Type StaticType { get; }
    public ConvertExpressionAst(IScriptExtent extent, TypeConstraintAst typeConstraint, ExpressionAst child);
    public TypeConstraintAst get_Type();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
    internal bool IsRef();
}
public class System.Management.Automation.Language.DataStatementAst : StatementAst {
    private static ExpressionAst[] s_emptyCommandsAllowed;
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ExpressionAst> <CommandsAllowed>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasNonConstantAllowedCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TupleIndex>k__BackingField;
    public string Variable { get; }
    public ReadOnlyCollection`1<ExpressionAst> CommandsAllowed { get; }
    public StatementBlockAst Body { get; }
    internal bool HasNonConstantAllowedCommand { get; }
    internal int TupleIndex { get; internal set; }
    public DataStatementAst(IScriptExtent extent, string variableName, IEnumerable`1<ExpressionAst> commandsAllowed, StatementBlockAst body);
    private static DataStatementAst();
    [CompilerGeneratedAttribute]
public string get_Variable();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ExpressionAst> get_CommandsAllowed();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
    public virtual Ast Copy();
    [CompilerGeneratedAttribute]
internal bool get_HasNonConstantAllowedCommand();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    [CompilerGeneratedAttribute]
internal int get_TupleIndex();
    [CompilerGeneratedAttribute]
internal void set_TupleIndex(int value);
}
public abstract class System.Management.Automation.Language.DefaultCustomAstVisitor : object {
    public virtual object DefaultVisit(Ast ast);
    public virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public virtual object VisitAttribute(AttributeAst attributeAst);
    public virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public virtual object VisitParameter(ParameterAst parameterAst);
    public virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public virtual object VisitForStatement(ForStatementAst forStatementAst);
    public virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual object VisitPipeline(PipelineAst pipelineAst);
    public virtual object VisitCommand(CommandAst commandAst);
    public virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public virtual object VisitHashtable(HashtableAst hashtableAst);
    public virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
}
public abstract class System.Management.Automation.Language.DefaultCustomAstVisitor2 : DefaultCustomAstVisitor {
    public virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationAst);
    public virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public virtual object VisitPipelineChain(PipelineChainAst statementChainAst);
}
public class System.Management.Automation.Language.DoUntilStatementAst : LoopStatementAst {
    public DoUntilStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition, StatementBlockAst body);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.DoWhileStatementAst : LoopStatementAst {
    public DoWhileStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition, StatementBlockAst body);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal static class System.Management.Automation.Language.DscResourceChecker : object {
    internal static void CheckType(Parser parser, TypeDefinitionAst typeDefinitionAst, AttributeAst dscResourceAttributeAst);
    private static void LookupRequiredMembers(Parser parser, TypeDefinitionAst typeDefinitionAst, Boolean& hasSet, Boolean& hasGet, Boolean& hasTest, Boolean& hasKey);
    private static void CheckGet(Parser parser, FunctionMemberAst functionMemberAst, Boolean& hasGet);
    private static void CheckTest(FunctionMemberAst functionMemberAst, Boolean& hasTest);
    private static void CheckSet(FunctionMemberAst functionMemberAst, Boolean& hasSet);
    private static void CheckKey(Parser parser, PropertyMemberAst propertyMemberAst, Boolean& hasKey);
}
public class System.Management.Automation.Language.DynamicKeyword : object {
    [ThreadStaticAttribute]
private static Dictionary`2<string, DynamicKeyword> t_dynamicKeywords;
    [ThreadStaticAttribute]
private static Stack`1<Dictionary`2<string, DynamicKeyword>> t_dynamicKeywordsStack;
    private static HashSet`1<string> s_hiddenDynamicKeywords;
    [CompilerGeneratedAttribute]
private string <ImplementingModule>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ImplementingModuleVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Keyword>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceName>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicKeywordBodyMode <BodyMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DirectCall>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicKeywordNameMode <NameMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MetaStatement>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReservedKeyword>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasReservedProperties>k__BackingField;
    private Dictionary`2<string, DynamicKeywordProperty> _properties;
    private Dictionary`2<string, DynamicKeywordParameter> _parameters;
    [CompilerGeneratedAttribute]
private Func`2<DynamicKeyword, ParseError[]> <PreParse>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DynamicKeywordStatementAst, ParseError[]> <PostParse>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<DynamicKeywordStatementAst, ParseError[]> <SemanticCheck>k__BackingField;
    private static Dictionary`2<string, DynamicKeyword> DynamicKeywords { get; }
    private static Stack`1<Dictionary`2<string, DynamicKeyword>> DynamicKeywordsStack { get; }
    public string ImplementingModule { get; public set; }
    public Version ImplementingModuleVersion { get; public set; }
    public string Keyword { get; public set; }
    public string ResourceName { get; public set; }
    public DynamicKeywordBodyMode BodyMode { get; public set; }
    public bool DirectCall { get; public set; }
    public DynamicKeywordNameMode NameMode { get; public set; }
    public bool MetaStatement { get; public set; }
    public bool IsReservedKeyword { get; public set; }
    public bool HasReservedProperties { get; public set; }
    public Dictionary`2<string, DynamicKeywordProperty> Properties { get; }
    public Dictionary`2<string, DynamicKeywordParameter> Parameters { get; }
    public Func`2<DynamicKeyword, ParseError[]> PreParse { get; public set; }
    public Func`2<DynamicKeywordStatementAst, ParseError[]> PostParse { get; public set; }
    public Func`2<DynamicKeywordStatementAst, ParseError[]> SemanticCheck { get; public set; }
    private static DynamicKeyword();
    private static Dictionary`2<string, DynamicKeyword> get_DynamicKeywords();
    private static Stack`1<Dictionary`2<string, DynamicKeyword>> get_DynamicKeywordsStack();
    public static void Reset();
    public static void Push();
    public static void Pop();
    public static DynamicKeyword GetKeyword(string name);
    public static List`1<DynamicKeyword> GetKeyword();
    public static bool ContainsKeyword(string name);
    public static void AddKeyword(DynamicKeyword keywordToAdd);
    public static void RemoveKeyword(string name);
    internal static bool IsHiddenKeyword(string name);
    public DynamicKeyword Copy();
    [CompilerGeneratedAttribute]
public string get_ImplementingModule();
    [CompilerGeneratedAttribute]
public void set_ImplementingModule(string value);
    [CompilerGeneratedAttribute]
public Version get_ImplementingModuleVersion();
    [CompilerGeneratedAttribute]
public void set_ImplementingModuleVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_Keyword();
    [CompilerGeneratedAttribute]
public void set_Keyword(string value);
    [CompilerGeneratedAttribute]
public string get_ResourceName();
    [CompilerGeneratedAttribute]
public void set_ResourceName(string value);
    [CompilerGeneratedAttribute]
public DynamicKeywordBodyMode get_BodyMode();
    [CompilerGeneratedAttribute]
public void set_BodyMode(DynamicKeywordBodyMode value);
    [CompilerGeneratedAttribute]
public bool get_DirectCall();
    [CompilerGeneratedAttribute]
public void set_DirectCall(bool value);
    [CompilerGeneratedAttribute]
public DynamicKeywordNameMode get_NameMode();
    [CompilerGeneratedAttribute]
public void set_NameMode(DynamicKeywordNameMode value);
    [CompilerGeneratedAttribute]
public bool get_MetaStatement();
    [CompilerGeneratedAttribute]
public void set_MetaStatement(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsReservedKeyword();
    [CompilerGeneratedAttribute]
public void set_IsReservedKeyword(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasReservedProperties();
    [CompilerGeneratedAttribute]
public void set_HasReservedProperties(bool value);
    public Dictionary`2<string, DynamicKeywordProperty> get_Properties();
    public Dictionary`2<string, DynamicKeywordParameter> get_Parameters();
    [CompilerGeneratedAttribute]
public Func`2<DynamicKeyword, ParseError[]> get_PreParse();
    [CompilerGeneratedAttribute]
public void set_PreParse(Func`2<DynamicKeyword, ParseError[]> value);
    [CompilerGeneratedAttribute]
public Func`2<DynamicKeywordStatementAst, ParseError[]> get_PostParse();
    [CompilerGeneratedAttribute]
public void set_PostParse(Func`2<DynamicKeywordStatementAst, ParseError[]> value);
    [CompilerGeneratedAttribute]
public Func`2<DynamicKeywordStatementAst, ParseError[]> get_SemanticCheck();
    [CompilerGeneratedAttribute]
public void set_SemanticCheck(Func`2<DynamicKeywordStatementAst, ParseError[]> value);
}
public enum System.Management.Automation.Language.DynamicKeywordBodyMode : Enum {
    public int value__;
    public static DynamicKeywordBodyMode Command;
    public static DynamicKeywordBodyMode ScriptBlock;
    public static DynamicKeywordBodyMode Hashtable;
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.DynamicKeywordExtension : object {
    private static Dictionary`2<string, List`1<string>> s_excludeKeywords;
    private static DynamicKeywordExtension();
    [ExtensionAttribute]
internal static bool IsMetaDSCResource(DynamicKeyword keyword);
    [ExtensionAttribute]
internal static bool IsCompatibleWithConfigurationType(DynamicKeyword keyword, ConfigurationType ConfigurationType);
    [ExtensionAttribute]
internal static IEnumerable`1<DynamicKeyword> GetAllowedKeywords(DynamicKeyword keyword, IEnumerable`1<DynamicKeyword> allowedKeywords);
}
public enum System.Management.Automation.Language.DynamicKeywordNameMode : Enum {
    public int value__;
    public static DynamicKeywordNameMode NoName;
    public static DynamicKeywordNameMode SimpleNameRequired;
    public static DynamicKeywordNameMode NameRequired;
    public static DynamicKeywordNameMode SimpleOptionalName;
    public static DynamicKeywordNameMode OptionalName;
}
public class System.Management.Automation.Language.DynamicKeywordParameter : DynamicKeywordProperty {
    [CompilerGeneratedAttribute]
private bool <Switch>k__BackingField;
    public bool Switch { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_Switch();
    [CompilerGeneratedAttribute]
public void set_Switch(bool value);
}
public class System.Management.Automation.Language.DynamicKeywordProperty : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeConstraint>k__BackingField;
    private List`1<string> _attributes;
    private List`1<string> _values;
    private Dictionary`2<string, string> _valueMap;
    [CompilerGeneratedAttribute]
private bool <Mandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Tuple`2<int, int> <Range>k__BackingField;
    public string Name { get; public set; }
    public string TypeConstraint { get; public set; }
    public List`1<string> Attributes { get; }
    public List`1<string> Values { get; }
    public Dictionary`2<string, string> ValueMap { get; }
    public bool Mandatory { get; public set; }
    public bool IsKey { get; public set; }
    public Tuple`2<int, int> Range { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_TypeConstraint();
    [CompilerGeneratedAttribute]
public void set_TypeConstraint(string value);
    public List`1<string> get_Attributes();
    public List`1<string> get_Values();
    public Dictionary`2<string, string> get_ValueMap();
    [CompilerGeneratedAttribute]
public bool get_Mandatory();
    [CompilerGeneratedAttribute]
public void set_Mandatory(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsKey();
    [CompilerGeneratedAttribute]
public void set_IsKey(bool value);
    [CompilerGeneratedAttribute]
public Tuple`2<int, int> get_Range();
    [CompilerGeneratedAttribute]
public void set_Range(Tuple`2<int, int> value);
}
public class System.Management.Automation.Language.DynamicKeywordStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CommandElementAst> <CommandElements>k__BackingField;
    private DynamicKeyword _keyword;
    [CompilerGeneratedAttribute]
private Token <LCurly>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <FunctionName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <InstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <OriginalInstanceName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <BodyExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ElementName>k__BackingField;
    private PipelineAst _commandCallPipelineAst;
    public ReadOnlyCollection`1<CommandElementAst> CommandElements { get; }
    internal DynamicKeyword Keyword { get; internal set; }
    internal Token LCurly { get; internal set; }
    internal Token FunctionName { get; internal set; }
    internal ExpressionAst InstanceName { get; internal set; }
    internal ExpressionAst OriginalInstanceName { get; internal set; }
    internal ExpressionAst BodyExpression { get; internal set; }
    internal string ElementName { get; internal set; }
    public DynamicKeywordStatementAst(IScriptExtent extent, IEnumerable`1<CommandElementAst> commandElements);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CommandElementAst> get_CommandElements();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal DynamicKeyword get_Keyword();
    internal void set_Keyword(DynamicKeyword value);
    [CompilerGeneratedAttribute]
internal Token get_LCurly();
    [CompilerGeneratedAttribute]
internal void set_LCurly(Token value);
    [CompilerGeneratedAttribute]
internal Token get_FunctionName();
    [CompilerGeneratedAttribute]
internal void set_FunctionName(Token value);
    [CompilerGeneratedAttribute]
internal ExpressionAst get_InstanceName();
    [CompilerGeneratedAttribute]
internal void set_InstanceName(ExpressionAst value);
    [CompilerGeneratedAttribute]
internal ExpressionAst get_OriginalInstanceName();
    [CompilerGeneratedAttribute]
internal void set_OriginalInstanceName(ExpressionAst value);
    [CompilerGeneratedAttribute]
internal ExpressionAst get_BodyExpression();
    [CompilerGeneratedAttribute]
internal void set_BodyExpression(ExpressionAst value);
    [CompilerGeneratedAttribute]
internal string get_ElementName();
    [CompilerGeneratedAttribute]
internal void set_ElementName(string value);
    internal PipelineAst GenerateCommandCallPipelineAst();
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.DynamicMetaObjectBinderExtensions : object {
    [ExtensionAttribute]
internal static DynamicMetaObject DeferForPSObject(DynamicMetaObjectBinder binder, DynamicMetaObject target, bool targetIsComObject);
    [ExtensionAttribute]
internal static DynamicMetaObject DeferForPSObject(DynamicMetaObjectBinder binder, DynamicMetaObject target, DynamicMetaObject arg, bool targetIsComObject);
    [ExtensionAttribute]
internal static DynamicMetaObject DeferForPSObject(DynamicMetaObjectBinder binder, DynamicMetaObject[] args, bool targetIsComObject);
    private static Expression ProcessOnePSObject(DynamicMetaObject arg, BindingRestrictions& restrictions, bool argIsComObject);
    [ExtensionAttribute]
internal static DynamicMetaObject UpdateComRestrictionsForPsObject(DynamicMetaObject binder, DynamicMetaObject[] args);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.DynamicMetaObjectExtensions : object {
    internal static DynamicMetaObject FakeError;
    private static DynamicMetaObjectExtensions();
    [ExtensionAttribute]
internal static DynamicMetaObject WriteToDebugLog(DynamicMetaObject obj, DynamicMetaObjectBinder binder);
    [ExtensionAttribute]
internal static BindingRestrictions GetSimpleTypeRestriction(DynamicMetaObject obj);
    [ExtensionAttribute]
internal static BindingRestrictions PSGetMethodArgumentRestriction(DynamicMetaObject obj);
    [ExtensionAttribute]
internal static BindingRestrictions PSGetStaticMemberRestriction(DynamicMetaObject obj);
    [ExtensionAttribute]
internal static BindingRestrictions PSGetTypeRestriction(DynamicMetaObject obj);
    [ExtensionAttribute]
internal static BindingRestrictions CombineRestrictions(DynamicMetaObject target, DynamicMetaObject[] args);
    [ExtensionAttribute]
internal static Expression CastOrConvertMethodArgument(DynamicMetaObject target, Type parameterType, string parameterName, string methodName, bool allowCastingToByRefLikeType, List`1<ParameterExpression> temps, List`1<Expression> initTemps);
    [ExtensionAttribute]
internal static Expression CastOrConvert(DynamicMetaObject target, Type type);
    [ExtensionAttribute]
internal static DynamicMetaObject ThrowRuntimeError(DynamicMetaObject target, DynamicMetaObject[] args, BindingRestrictions moreTests, string errorID, string resourceString, Expression[] exceptionArgs);
    [ExtensionAttribute]
internal static DynamicMetaObject ThrowRuntimeError(DynamicMetaObject target, BindingRestrictions bindingRestrictions, string errorID, string resourceString, Expression[] exceptionArgs);
}
internal class System.Management.Automation.Language.EmptyScriptExtent : object {
    public string File { get; }
    public IScriptPosition StartScriptPosition { get; }
    public IScriptPosition EndScriptPosition { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public string Text { get; }
    public sealed virtual string get_File();
    public sealed virtual IScriptPosition get_StartScriptPosition();
    public sealed virtual IScriptPosition get_EndScriptPosition();
    public sealed virtual int get_StartLineNumber();
    public sealed virtual int get_StartColumnNumber();
    public sealed virtual int get_EndLineNumber();
    public sealed virtual int get_EndColumnNumber();
    public sealed virtual int get_StartOffset();
    public sealed virtual int get_EndOffset();
    public sealed virtual string get_Text();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class System.Management.Automation.Language.EmptyScriptPosition : object {
    public string File { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int Offset { get; }
    public string Line { get; }
    public sealed virtual string get_File();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_ColumnNumber();
    public sealed virtual int get_Offset();
    public sealed virtual string get_Line();
    public sealed virtual string GetFullScript();
}
internal class System.Management.Automation.Language.EnterLoopExpression : Expression {
    [CompilerGeneratedAttribute]
private PowerShellLoopExpression <Loop>k__BackingField;
    [CompilerGeneratedAttribute]
private EnterLoopInstruction <EnterLoopInstruction>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LoopStatementCount>k__BackingField;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal PowerShellLoopExpression Loop { get; internal set; }
    internal EnterLoopInstruction EnterLoopInstruction { get; private set; }
    internal int LoopStatementCount { get; internal set; }
    public virtual bool get_CanReduce();
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
    public virtual Expression Reduce();
    [CompilerGeneratedAttribute]
internal PowerShellLoopExpression get_Loop();
    [CompilerGeneratedAttribute]
internal void set_Loop(PowerShellLoopExpression value);
    [CompilerGeneratedAttribute]
internal EnterLoopInstruction get_EnterLoopInstruction();
    [CompilerGeneratedAttribute]
private void set_EnterLoopInstruction(EnterLoopInstruction value);
    [CompilerGeneratedAttribute]
internal int get_LoopStatementCount();
    [CompilerGeneratedAttribute]
internal void set_LoopStatementCount(int value);
    public sealed virtual void AddInstructions(LightCompiler compiler);
}
public class System.Management.Automation.Language.ErrorExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Ast> <NestedAst>k__BackingField;
    public ReadOnlyCollection`1<Ast> NestedAst { get; }
    internal ErrorExpressionAst(IScriptExtent extent, IEnumerable`1<Ast> nestedAsts);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Ast> get_NestedAst();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ErrorStatementAst : PipelineBaseAst {
    [CompilerGeneratedAttribute]
private Token <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, Tuple`2<Token, Ast>> <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Ast> <Conditions>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Ast> <Bodies>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Ast> <NestedAst>k__BackingField;
    public Token Kind { get; }
    public Dictionary`2<string, Tuple`2<Token, Ast>> Flags { get; }
    public ReadOnlyCollection`1<Ast> Conditions { get; }
    public ReadOnlyCollection`1<Ast> Bodies { get; }
    public ReadOnlyCollection`1<Ast> NestedAst { get; }
    internal ErrorStatementAst(IScriptExtent extent, IEnumerable`1<Ast> nestedAsts);
    internal ErrorStatementAst(IScriptExtent extent, Token kind, IEnumerable`1<Ast> nestedAsts);
    internal ErrorStatementAst(IScriptExtent extent, Token kind, IEnumerable`1<KeyValuePair`2<string, Tuple`2<Token, Ast>>> flags, IEnumerable`1<Ast> conditions, IEnumerable`1<Ast> bodies);
    [CompilerGeneratedAttribute]
public Token get_Kind();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, Tuple`2<Token, Ast>> get_Flags();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Ast> get_Conditions();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Ast> get_Bodies();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Ast> get_NestedAst();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ExitStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Pipeline>k__BackingField;
    public PipelineBaseAst Pipeline { get; }
    public ExitStatementAst(IScriptExtent extent, PipelineBaseAst pipeline);
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Pipeline();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ExpandableStringExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private StringConstantType <StringConstantType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ExpressionAst> <NestedExpressions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatExpression>k__BackingField;
    public string Value { get; }
    public StringConstantType StringConstantType { get; }
    public ReadOnlyCollection`1<ExpressionAst> NestedExpressions { get; }
    public Type StaticType { get; }
    internal string FormatExpression { get; }
    public ExpandableStringExpressionAst(IScriptExtent extent, string value, StringConstantType type);
    internal ExpandableStringExpressionAst(Token token, string value, string formatString, IEnumerable`1<ExpressionAst> nestedExpressions);
    private ExpandableStringExpressionAst(IScriptExtent extent, string value, string formatString, StringConstantType type, IEnumerable`1<ExpressionAst> nestedExpressions);
    [CompilerGeneratedAttribute]
public string get_Value();
    [CompilerGeneratedAttribute]
public StringConstantType get_StringConstantType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ExpressionAst> get_NestedExpressions();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    [CompilerGeneratedAttribute]
internal string get_FormatExpression();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public abstract class System.Management.Automation.Language.ExpressionAst : CommandElementAst {
    public Type StaticType { get; }
    protected ExpressionAst(IScriptExtent extent);
    public virtual Type get_StaticType();
    internal virtual bool ShouldPreserveOutputInCaseOfException();
}
internal static class System.Management.Automation.Language.ExpressionCache : object {
    internal static Expression NullConstant;
    internal static Expression NullExecutionContext;
    internal static Expression NullPSObject;
    internal static Expression NullEnumerator;
    internal static Expression NullExtent;
    internal static Expression NullTypeTable;
    internal static Expression NullFormatProvider;
    internal static Expression NullObjectArray;
    internal static Expression AutomationNullConstant;
    internal static Expression NullCommandRedirections;
    internal static Expression NullTypeArray;
    internal static Expression NullType;
    internal static Expression NullDelegateArray;
    internal static Expression NullPipe;
    internal static Expression ConstEmptyString;
    internal static Expression CompareOptionsIgnoreCase;
    internal static Expression CompareOptionsNone;
    internal static Expression Ordinal;
    internal static Expression InvariantCulture;
    internal static Expression OrdinalIgnoreCaseComparer;
    internal static Expression CatchAllType;
    internal static Expression Empty;
    internal static Expression GetExecutionContextFromTLS;
    internal static Expression BoxedTrue;
    internal static Expression BoxedFalse;
    private static Expression[] s_intConstants;
    internal static Expression TrueConstant;
    internal static Expression FalseConstant;
    private static ExpressionCache();
    internal static Expression Constant(int i);
    internal static Expression Constant(bool b);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.ExpressionExtensions : object {
    [ExtensionAttribute]
internal static Expression Convert(Expression expr, Type type);
    [ExtensionAttribute]
internal static Expression Cast(Expression expr, Type type);
}
internal class System.Management.Automation.Language.FakePair : AstParameterArgumentPair {
    internal FakePair(CommandParameterAst parameterAst);
}
public class System.Management.Automation.Language.FileRedirectionAst : RedirectionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Location>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Append>k__BackingField;
    public ExpressionAst Location { get; }
    public bool Append { get; }
    public FileRedirectionAst(IScriptExtent extent, RedirectionStream stream, ExpressionAst file, bool append);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Location();
    [CompilerGeneratedAttribute]
public bool get_Append();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.FileRedirectionToken : RedirectionToken {
    [CompilerGeneratedAttribute]
private RedirectionStream <FromStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Append>k__BackingField;
    public RedirectionStream FromStream { get; }
    public bool Append { get; }
    internal FileRedirectionToken(InternalScriptExtent scriptExtent, RedirectionStream from, bool append);
    [CompilerGeneratedAttribute]
public RedirectionStream get_FromStream();
    [CompilerGeneratedAttribute]
public bool get_Append();
}
internal class System.Management.Automation.Language.FindAllVariablesVisitor : AstVisitor {
    private static HashSet`1<string> s_hashOfPessimizingCmdlets;
    private static String[] s_pessimizingCmdlets;
    private bool _disableOptimizations;
    private Dictionary`2<string, VariableAnalysisDetails> _variables;
    private int _runtimeUsingIndex;
    private static FindAllVariablesVisitor();
    private FindAllVariablesVisitor(bool disableOptimizations, bool scriptCmdlet);
    internal static Dictionary`2<string, VariableAnalysisDetails> Visit(TrapStatementAst trap);
    internal static Dictionary`2<string, VariableAnalysisDetails> Visit(ExpressionAst exprAst);
    internal static Dictionary`2<string, VariableAnalysisDetails> Visit(IParameterMetadataProvider ast, bool disableOptimizations, bool scriptCmdlet, Int32& localsAllocated, Boolean& forceNoOptimizing);
    private void VisitParameters(ReadOnlyCollection`1<ParameterAst> parameters);
    private void NoteVariable(string variableName, int index, Type type, bool automatic, bool preferenceVariable);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public virtual AstVisitAction VisitCommand(CommandAst commandAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitTrap(TrapStatementAst trapStatementAst);
}
[FlagsAttribute]
public enum System.Management.Automation.Language.ForEachFlags : Enum {
    public int value__;
    public static ForEachFlags None;
    public static ForEachFlags Parallel;
}
public class System.Management.Automation.Language.ForEachStatementAst : LoopStatementAst {
    [CompilerGeneratedAttribute]
private VariableExpressionAst <Variable>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <ThrottleLimit>k__BackingField;
    [CompilerGeneratedAttribute]
private ForEachFlags <Flags>k__BackingField;
    public VariableExpressionAst Variable { get; }
    public ExpressionAst ThrottleLimit { get; }
    public ForEachFlags Flags { get; }
    public ForEachStatementAst(IScriptExtent extent, string label, ForEachFlags flags, VariableExpressionAst variable, PipelineBaseAst expression, StatementBlockAst body);
    public ForEachStatementAst(IScriptExtent extent, string label, ForEachFlags flags, ExpressionAst throttleLimit, VariableExpressionAst variable, PipelineBaseAst expression, StatementBlockAst body);
    [CompilerGeneratedAttribute]
public VariableExpressionAst get_Variable();
    [CompilerGeneratedAttribute]
public ExpressionAst get_ThrottleLimit();
    [CompilerGeneratedAttribute]
public ForEachFlags get_Flags();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ForStatementAst : LoopStatementAst {
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Initializer>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Iterator>k__BackingField;
    public PipelineBaseAst Initializer { get; }
    public PipelineBaseAst Iterator { get; }
    public ForStatementAst(IScriptExtent extent, string label, PipelineBaseAst initializer, PipelineBaseAst condition, PipelineBaseAst iterator, StatementBlockAst body);
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Initializer();
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Iterator();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.FunctionContext : object {
    internal ScriptBlock _scriptBlock;
    internal string _file;
    internal bool _debuggerHidden;
    internal bool _debuggerStepThrough;
    internal IScriptExtent[] _sequencePoints;
    internal ExecutionContext _executionContext;
    internal Pipe _outputPipe;
    internal BitArray _breakPoints;
    internal Dictionary`2<int, List`1<LineBreakpoint>> _boundBreakpoints;
    internal int _currentSequencePointIndex;
    internal MutableTuple _localsTuple;
    internal List`1<Tuple`3<Type[], Action`1[], Type[]>> _traps;
    internal string _functionName;
    internal IScriptExtent CurrentPosition { get; }
    internal IScriptExtent get_CurrentPosition();
    internal void PushTrapHandlers(Type[] type, Action`1[] handler, Type[] tupleType);
    internal void PopTrapHandlers();
}
public class System.Management.Automation.Language.FunctionDefinitionAst : StatementAst {
    [CompilerGeneratedAttribute]
private bool <IsFilter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWorkflow>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ParameterAst> <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlockAst <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <NameExtent>k__BackingField;
    public bool IsFilter { get; }
    public bool IsWorkflow { get; }
    public string Name { get; }
    public ReadOnlyCollection`1<ParameterAst> Parameters { get; }
    public ScriptBlockAst Body { get; }
    internal IScriptExtent NameExtent { get; private set; }
    private ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.Parameters { get; }
    public FunctionDefinitionAst(IScriptExtent extent, bool isFilter, bool isWorkflow, string name, IEnumerable`1<ParameterAst> parameters, ScriptBlockAst body);
    internal FunctionDefinitionAst(IScriptExtent extent, bool isFilter, bool isWorkflow, Token functionNameToken, IEnumerable`1<ParameterAst> parameters, ScriptBlockAst body);
    [CompilerGeneratedAttribute]
public bool get_IsFilter();
    [CompilerGeneratedAttribute]
public bool get_IsWorkflow();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ParameterAst> get_Parameters();
    [CompilerGeneratedAttribute]
public sealed virtual ScriptBlockAst get_Body();
    [CompilerGeneratedAttribute]
internal IScriptExtent get_NameExtent();
    [CompilerGeneratedAttribute]
private void set_NameExtent(IScriptExtent value);
    public CommentHelpInfo GetHelpContent();
    public CommentHelpInfo GetHelpContent(Dictionary`2<Ast, Token[]> scriptBlockTokenCache);
    public virtual Ast Copy();
    internal string GetParamTextFromParameterList(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.HasAnyScriptBlockAttributes();
    private sealed virtual override RuntimeDefinedParameterDictionary System.Management.Automation.Language.IParameterMetadataProvider.GetParameterMetadata(bool automaticPositions, Boolean& usesCmdletBinding);
    private sealed virtual override IEnumerable`1<Attribute> System.Management.Automation.Language.IParameterMetadataProvider.GetScriptBlockAttributes();
    private sealed virtual override IEnumerable`1<ExperimentalAttribute> System.Management.Automation.Language.IParameterMetadataProvider.GetExperimentalAttributes();
    private sealed virtual override ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.get_Parameters();
    private sealed virtual override PowerShell System.Management.Automation.Language.IParameterMetadataProvider.GetPowerShell(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    private sealed virtual override string System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommand();
    private sealed virtual override Tuple`2<string, string> System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.UsesCmdletBinding();
}
public class System.Management.Automation.Language.FunctionMemberAst : MemberAst {
    private static ReadOnlyCollection`1<AttributeAst> s_emptyAttributeList;
    private static ReadOnlyCollection`1<ParameterAst> s_emptyParameterList;
    private FunctionDefinitionAst _functionDefinitionAst;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConstraintAst <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodAttributes <MethodAttributes>k__BackingField;
    private string _toolTip;
    public string Name { get; }
    public ReadOnlyCollection`1<AttributeAst> Attributes { get; }
    public TypeConstraintAst ReturnType { get; }
    public ReadOnlyCollection`1<ParameterAst> Parameters { get; }
    public ScriptBlockAst Body { get; }
    public MethodAttributes MethodAttributes { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsHidden { get; }
    public bool IsStatic { get; }
    public bool IsConstructor { get; }
    internal IScriptExtent NameExtent { get; }
    private ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.Parameters { get; }
    public FunctionMemberAst(IScriptExtent extent, FunctionDefinitionAst functionDefinitionAst, TypeConstraintAst returnType, IEnumerable`1<AttributeAst> attributes, MethodAttributes methodAttributes);
    private static FunctionMemberAst();
    public virtual string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeAst> get_Attributes();
    [CompilerGeneratedAttribute]
public TypeConstraintAst get_ReturnType();
    public ReadOnlyCollection`1<ParameterAst> get_Parameters();
    public sealed virtual ScriptBlockAst get_Body();
    [CompilerGeneratedAttribute]
public MethodAttributes get_MethodAttributes();
    public bool get_IsPublic();
    public bool get_IsPrivate();
    public bool get_IsHidden();
    public bool get_IsStatic();
    public bool get_IsConstructor();
    internal IScriptExtent get_NameExtent();
    public virtual Ast Copy();
    internal virtual string GetTooltip();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.HasAnyScriptBlockAttributes();
    private sealed virtual override ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.get_Parameters();
    private sealed virtual override RuntimeDefinedParameterDictionary System.Management.Automation.Language.IParameterMetadataProvider.GetParameterMetadata(bool automaticPositions, Boolean& usesCmdletBinding);
    private sealed virtual override IEnumerable`1<Attribute> System.Management.Automation.Language.IParameterMetadataProvider.GetScriptBlockAttributes();
    private sealed virtual override IEnumerable`1<ExperimentalAttribute> System.Management.Automation.Language.IParameterMetadataProvider.GetExperimentalAttributes();
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.UsesCmdletBinding();
    private sealed virtual override PowerShell System.Management.Automation.Language.IParameterMetadataProvider.GetPowerShell(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    private sealed virtual override string System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommand();
    private sealed virtual override Tuple`2<string, string> System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    internal bool IsReturnTypeVoid();
    internal Type GetReturnType();
}
public class System.Management.Automation.Language.GenericTypeName : object {
    private string _cachedFullName;
    private Type _cachedType;
    [CompilerGeneratedAttribute]
private ITypeName <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ITypeName> <GenericArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <Extent>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public string AssemblyName { get; }
    public bool IsArray { get; }
    public bool IsGeneric { get; }
    public ITypeName TypeName { get; }
    public ReadOnlyCollection`1<ITypeName> GenericArguments { get; }
    public IScriptExtent Extent { get; }
    private Type System.Management.Automation.Language.ISupportsTypeCaching.CachedType { get; private set; }
    public GenericTypeName(IScriptExtent extent, ITypeName genericTypeName, IEnumerable`1<ITypeName> genericArguments);
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual string get_AssemblyName();
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsGeneric();
    [CompilerGeneratedAttribute]
public ITypeName get_TypeName();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ITypeName> get_GenericArguments();
    [CompilerGeneratedAttribute]
public sealed virtual IScriptExtent get_Extent();
    public sealed virtual Type GetReflectionType();
    internal Type GetGenericType(Type generic);
    public sealed virtual Type GetReflectionAttributeType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override Type System.Management.Automation.Language.ISupportsTypeCaching.get_CachedType();
    private sealed virtual override void System.Management.Automation.Language.ISupportsTypeCaching.set_CachedType(Type value);
}
internal class System.Management.Automation.Language.GetSafeValueVisitor : object {
    [ThreadStaticAttribute]
private static ExecutionContext t_context;
    public static object GetSafeValue(Ast ast, ExecutionContext context, SafeValueContext safeValueContext);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    private static object GetSingleValueFromTarget(object target, object index);
    private static object GetIndexedValueFromTarget(object target, object index);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
}
public class System.Management.Automation.Language.HashtableAst : ExpressionAst {
    private static ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementAst>> s_emptyKeyValuePairs;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementAst>> <KeyValuePairs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSchemaElement>k__BackingField;
    public ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementAst>> KeyValuePairs { get; }
    public Type StaticType { get; }
    internal bool IsSchemaElement { get; internal set; }
    public HashtableAst(IScriptExtent extent, IEnumerable`1<Tuple`2<ExpressionAst, StatementAst>> keyValuePairs);
    private static HashtableAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementAst>> get_KeyValuePairs();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    [CompilerGeneratedAttribute]
internal bool get_IsSchemaElement();
    [CompilerGeneratedAttribute]
internal void set_IsSchemaElement(bool value);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.Language.IAssignableValue {
    public abstract virtual Expression GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    public abstract virtual Expression SetValue(Compiler compiler, Expression rhs);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Language.IAstPostVisitHandler {
    public abstract virtual void PostVisit(Ast ast);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Language.ICustomAstVisitor {
    public virtual object DefaultVisit(Ast ast);
    public virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public virtual object VisitAttribute(AttributeAst attributeAst);
    public virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public virtual object VisitParameter(ParameterAst parameterAst);
    public virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public virtual object VisitForStatement(ForStatementAst forStatementAst);
    public virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual object VisitPipeline(PipelineAst pipelineAst);
    public virtual object VisitCommand(CommandAst commandAst);
    public virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public virtual object VisitHashtable(HashtableAst hashtableAst);
    public virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Language.ICustomAstVisitor2 {
    public virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public virtual object VisitPipelineChain(PipelineChainAst statementChainAst);
}
public class System.Management.Automation.Language.IfStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Tuple`2<PipelineBaseAst, StatementBlockAst>> <Clauses>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <ElseClause>k__BackingField;
    public ReadOnlyCollection`1<Tuple`2<PipelineBaseAst, StatementBlockAst>> Clauses { get; }
    public StatementBlockAst ElseClause { get; }
    public IfStatementAst(IScriptExtent extent, IEnumerable`1<Tuple`2<PipelineBaseAst, StatementBlockAst>> clauses, StatementBlockAst elseClause);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Tuple`2<PipelineBaseAst, StatementBlockAst>> get_Clauses();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_ElseClause();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.IndexAssignableValue : object {
    [CompilerGeneratedAttribute]
private IndexExpressionAst <IndexExpressionAst>k__BackingField;
    private ParameterExpression _targetExprTemp;
    private ParameterExpression _indexExprTemp;
    internal IndexExpressionAst IndexExpressionAst { get; internal set; }
    [CompilerGeneratedAttribute]
internal IndexExpressionAst get_IndexExpressionAst();
    [CompilerGeneratedAttribute]
internal void set_IndexExpressionAst(IndexExpressionAst value);
    private PSMethodInvocationConstraints GetInvocationConstraints();
    private Expression GetTargetExpr(Compiler compiler);
    private Expression GetIndexExpr(Compiler compiler);
    public sealed virtual Expression GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    public sealed virtual Expression SetValue(Compiler compiler, Expression rhs);
}
public class System.Management.Automation.Language.IndexExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Index>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NullConditional>k__BackingField;
    public ExpressionAst Target { get; }
    public ExpressionAst Index { get; }
    public bool NullConditional { get; }
    public IndexExpressionAst(IScriptExtent extent, ExpressionAst target, ExpressionAst index);
    public IndexExpressionAst(IScriptExtent extent, ExpressionAst target, ExpressionAst index, bool nullConditional);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Target();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Index();
    [CompilerGeneratedAttribute]
public bool get_NullConditional();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
}
public class System.Management.Automation.Language.InputRedirectionToken : RedirectionToken {
    internal InputRedirectionToken(InternalScriptExtent scriptExtent);
}
internal class System.Management.Automation.Language.InternalScriptExtent : object {
    [CompilerGeneratedAttribute]
private PositionHelper <PositionHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartOffset>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndOffset>k__BackingField;
    public string File { get; }
    public IScriptPosition StartScriptPosition { get; }
    public IScriptPosition EndScriptPosition { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string Text { get; }
    internal PositionHelper PositionHelper { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    internal InternalScriptExtent(PositionHelper _positionHelper, int startOffset, int endOffset);
    public sealed virtual string get_File();
    public sealed virtual IScriptPosition get_StartScriptPosition();
    public sealed virtual IScriptPosition get_EndScriptPosition();
    public sealed virtual int get_StartLineNumber();
    public sealed virtual int get_StartColumnNumber();
    public sealed virtual int get_EndLineNumber();
    public sealed virtual int get_EndColumnNumber();
    public sealed virtual string get_Text();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal PositionHelper get_PositionHelper();
    [CompilerGeneratedAttribute]
public sealed virtual int get_StartOffset();
    [CompilerGeneratedAttribute]
public sealed virtual int get_EndOffset();
}
internal class System.Management.Automation.Language.InternalScriptPosition : object {
    private PositionHelper _positionHelper;
    [CompilerGeneratedAttribute]
private int <Offset>k__BackingField;
    public string File { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public string Line { get; }
    public int Offset { get; }
    internal InternalScriptPosition(PositionHelper _positionHelper, int offset);
    public sealed virtual string get_File();
    public sealed virtual int get_LineNumber();
    public sealed virtual int get_ColumnNumber();
    public sealed virtual string get_Line();
    [CompilerGeneratedAttribute]
public sealed virtual int get_Offset();
    internal InternalScriptPosition CloneWithNewOffset(int offset);
    public sealed virtual string GetFullScript();
}
internal class System.Management.Automation.Language.InvokeMemberAssignableValue : object {
    [CompilerGeneratedAttribute]
private InvokeMemberExpressionAst <InvokeMemberExpressionAst>k__BackingField;
    private ParameterExpression _targetExprTemp;
    private ParameterExpression _memberNameExprTemp;
    private IEnumerable`1<ParameterExpression> _argExprTemps;
    internal InvokeMemberExpressionAst InvokeMemberExpressionAst { get; internal set; }
    [CompilerGeneratedAttribute]
internal InvokeMemberExpressionAst get_InvokeMemberExpressionAst();
    [CompilerGeneratedAttribute]
internal void set_InvokeMemberExpressionAst(InvokeMemberExpressionAst value);
    private Expression GetTargetExpr(Compiler compiler);
    private Expression GetMemberNameExpr(Compiler compiler);
    private IEnumerable`1<Expression> GetArgumentExprs(Compiler compiler);
    public sealed virtual Expression GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    public sealed virtual Expression SetValue(Compiler compiler, Expression rhs);
}
public class System.Management.Automation.Language.InvokeMemberExpressionAst : MemberExpressionAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ITypeName> <GenericTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ExpressionAst> <Arguments>k__BackingField;
    public ReadOnlyCollection`1<ITypeName> GenericTypeArguments { get; }
    public ReadOnlyCollection`1<ExpressionAst> Arguments { get; }
    public InvokeMemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst method, IEnumerable`1<ExpressionAst> arguments, bool static, IList`1<ITypeName> genericTypes);
    public InvokeMemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst method, IEnumerable`1<ExpressionAst> arguments, bool static);
    public InvokeMemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst method, IEnumerable`1<ExpressionAst> arguments, bool static, bool nullConditional, IList`1<ITypeName> genericTypes);
    public InvokeMemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst method, IEnumerable`1<ExpressionAst> arguments, bool static, bool nullConditional);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ITypeName> get_GenericTypeArguments();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ExpressionAst> get_Arguments();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal AstVisitAction InternalVisitChildren(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
}
internal interface System.Management.Automation.Language.IParameterMetadataProvider {
    public ReadOnlyCollection`1<ParameterAst> Parameters { get; }
    public ScriptBlockAst Body { get; }
    public abstract virtual bool HasAnyScriptBlockAttributes();
    public abstract virtual RuntimeDefinedParameterDictionary GetParameterMetadata(bool automaticPositions, Boolean& usesCmdletBinding);
    public abstract virtual IEnumerable`1<Attribute> GetScriptBlockAttributes();
    public abstract virtual IEnumerable`1<ExperimentalAttribute> GetExperimentalAttributes();
    public abstract virtual bool UsesCmdletBinding();
    public abstract virtual ReadOnlyCollection`1<ParameterAst> get_Parameters();
    public abstract virtual ScriptBlockAst get_Body();
    public abstract virtual PowerShell GetPowerShell(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    public abstract virtual string GetWithInputHandlingForInvokeCommand();
    public abstract virtual Tuple`2<string, string> GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
}
internal class System.Management.Automation.Language.IsConstantValueVisitor : object {
    [CompilerGeneratedAttribute]
private bool <CheckingAttributeArgument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckingClassAttributeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CheckingRequiresArgument>k__BackingField;
    internal bool CheckingAttributeArgument { get; internal set; }
    internal bool CheckingClassAttributeArguments { get; internal set; }
    internal bool CheckingRequiresArgument { get; internal set; }
    public static bool IsConstant(Ast ast, Object& constantValue, bool forAttribute, bool forRequires);
    [CompilerGeneratedAttribute]
internal bool get_CheckingAttributeArgument();
    [CompilerGeneratedAttribute]
internal void set_CheckingAttributeArgument(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckingClassAttributeArguments();
    [CompilerGeneratedAttribute]
internal void set_CheckingClassAttributeArguments(bool value);
    [CompilerGeneratedAttribute]
internal bool get_CheckingRequiresArgument();
    [CompilerGeneratedAttribute]
internal void set_CheckingRequiresArgument(bool value);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    private static bool IsNullDivisor(ExpressionAst operand);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    [CompilerGeneratedAttribute]
private bool <VisitArrayLiteral>b__72_0(ExpressionAst e);
    [CompilerGeneratedAttribute]
private bool <VisitHashtable>b__73_0(Tuple`2<ExpressionAst, StatementAst> pair);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Language.IScriptExtent {
    [NullableAttribute("2")]
public string File { get; }
    public IScriptPosition StartScriptPosition { get; }
    public IScriptPosition EndScriptPosition { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public string Text { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    [NullableContextAttribute("2")]
public abstract virtual string get_File();
    public abstract virtual IScriptPosition get_StartScriptPosition();
    public abstract virtual IScriptPosition get_EndScriptPosition();
    public abstract virtual int get_StartLineNumber();
    public abstract virtual int get_StartColumnNumber();
    public abstract virtual int get_EndLineNumber();
    public abstract virtual int get_EndColumnNumber();
    public abstract virtual string get_Text();
    public abstract virtual int get_StartOffset();
    public abstract virtual int get_EndOffset();
}
[NullableContextAttribute("2")]
public interface System.Management.Automation.Language.IScriptPosition {
    public string File { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int Offset { get; }
    [NullableAttribute("1")]
public string Line { get; }
    public abstract virtual string get_File();
    public abstract virtual int get_LineNumber();
    public abstract virtual int get_ColumnNumber();
    public abstract virtual int get_Offset();
    [NullableContextAttribute("1")]
public abstract virtual string get_Line();
    public abstract virtual string GetFullScript();
}
internal class System.Management.Automation.Language.IsSafeValueVisitor : object {
    internal static IsSafeValueVisitor Default;
    private UInt32 _visitCount;
    private static UInt32 MaxVisitCount;
    private static int MaxHashtableKeyCount;
    private SafeValueContext _safeValueContext;
    internal IsSafeValueVisitor(SafeValueContext safeValueContext);
    private static IsSafeValueVisitor();
    public static bool IsAstSafe(Ast ast, SafeValueContext safeValueContext);
    internal bool IsAstSafe(Ast ast);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    [CompilerGeneratedAttribute]
private bool <VisitArrayLiteral>b__66_0(ExpressionAst e);
    [CompilerGeneratedAttribute]
private bool <VisitHashtable>b__67_0(Tuple`2<ExpressionAst, StatementAst> pair);
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.Language.ISupportsAssignment {
    public abstract virtual IAssignableValue GetAssignableValue();
}
[NullableContextAttribute("2")]
internal interface System.Management.Automation.Language.ISupportsTypeCaching {
    public Type CachedType { get; public set; }
    public abstract virtual Type get_CachedType();
    public abstract virtual void set_CachedType(Type value);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Language.ITypeName {
    public string FullName { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string AssemblyName { get; }
    public bool IsArray { get; }
    public bool IsGeneric { get; }
    public IScriptExtent Extent { get; }
    public abstract virtual string get_FullName();
    public abstract virtual string get_Name();
    [NullableContextAttribute("2")]
public abstract virtual string get_AssemblyName();
    public abstract virtual bool get_IsArray();
    public abstract virtual bool get_IsGeneric();
    [NullableContextAttribute("2")]
public abstract virtual Type GetReflectionType();
    [NullableContextAttribute("2")]
public abstract virtual Type GetReflectionAttributeType();
    public abstract virtual IScriptExtent get_Extent();
}
public abstract class System.Management.Automation.Language.LabeledStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Condition>k__BackingField;
    public string Label { get; }
    public PipelineBaseAst Condition { get; }
    protected LabeledStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Condition();
}
public class System.Management.Automation.Language.LabelToken : Token {
    [CompilerGeneratedAttribute]
private string <LabelText>k__BackingField;
    public string LabelText { get; }
    internal LabelToken(InternalScriptExtent scriptExtent, TokenFlags tokenFlags, string labelText);
    [CompilerGeneratedAttribute]
public string get_LabelText();
}
public abstract class System.Management.Automation.Language.LoopStatementAst : LabeledStatementAst {
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    public StatementBlockAst Body { get; }
    protected LoopStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition, StatementBlockAst body);
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
}
internal class System.Management.Automation.Language.MemberAssignableValue : object {
    [CompilerGeneratedAttribute]
private MemberExpressionAst <MemberExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <CachedTarget>k__BackingField;
    [CompilerGeneratedAttribute]
private Expression <CachedPropertyExpr>k__BackingField;
    internal MemberExpressionAst MemberExpression { get; internal set; }
    private Expression CachedTarget { get; private set; }
    private Expression CachedPropertyExpr { get; private set; }
    [CompilerGeneratedAttribute]
internal MemberExpressionAst get_MemberExpression();
    [CompilerGeneratedAttribute]
internal void set_MemberExpression(MemberExpressionAst value);
    [CompilerGeneratedAttribute]
private Expression get_CachedTarget();
    [CompilerGeneratedAttribute]
private void set_CachedTarget(Expression value);
    [CompilerGeneratedAttribute]
private Expression get_CachedPropertyExpr();
    [CompilerGeneratedAttribute]
private void set_CachedPropertyExpr(Expression value);
    private Expression GetTargetExpr(Compiler compiler);
    private Expression GetPropertyExpr(Compiler compiler);
    public sealed virtual Expression GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    public sealed virtual Expression SetValue(Compiler compiler, Expression rhs);
}
public abstract class System.Management.Automation.Language.MemberAst : Ast {
    public string Name { get; }
    protected MemberAst(IScriptExtent extent);
    public abstract virtual string get_Name();
    internal abstract virtual string GetTooltip();
}
public class System.Management.Automation.Language.MemberExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandElementAst <Member>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Static>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NullConditional>k__BackingField;
    public ExpressionAst Expression { get; }
    public CommandElementAst Member { get; }
    public bool Static { get; }
    public bool NullConditional { get; protected set; }
    public MemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst member, bool static);
    public MemberExpressionAst(IScriptExtent extent, ExpressionAst expression, CommandElementAst member, bool static, bool nullConditional);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Expression();
    [CompilerGeneratedAttribute]
public CommandElementAst get_Member();
    [CompilerGeneratedAttribute]
public bool get_Static();
    [CompilerGeneratedAttribute]
public bool get_NullConditional();
    [CompilerGeneratedAttribute]
protected void set_NullConditional(bool value);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
}
public class System.Management.Automation.Language.MergingRedirectionAst : RedirectionAst {
    [CompilerGeneratedAttribute]
private RedirectionStream <ToStream>k__BackingField;
    public RedirectionStream ToStream { get; }
    public MergingRedirectionAst(IScriptExtent extent, RedirectionStream from, RedirectionStream to);
    [CompilerGeneratedAttribute]
public RedirectionStream get_ToStream();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.MergingRedirectionToken : RedirectionToken {
    [CompilerGeneratedAttribute]
private RedirectionStream <FromStream>k__BackingField;
    [CompilerGeneratedAttribute]
private RedirectionStream <ToStream>k__BackingField;
    public RedirectionStream FromStream { get; }
    public RedirectionStream ToStream { get; }
    internal MergingRedirectionToken(InternalScriptExtent scriptExtent, RedirectionStream from, RedirectionStream to);
    [CompilerGeneratedAttribute]
public RedirectionStream get_FromStream();
    [CompilerGeneratedAttribute]
public RedirectionStream get_ToStream();
}
[FlagsAttribute]
public enum System.Management.Automation.Language.MethodAttributes : Enum {
    public int value__;
    public static MethodAttributes None;
    public static MethodAttributes Public;
    public static MethodAttributes Private;
    public static MethodAttributes Static;
    public static MethodAttributes Hidden;
}
public class System.Management.Automation.Language.NamedAttributeArgumentAst : Ast {
    [CompilerGeneratedAttribute]
private string <ArgumentName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Argument>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExpressionOmitted>k__BackingField;
    public string ArgumentName { get; }
    public ExpressionAst Argument { get; }
    public bool ExpressionOmitted { get; }
    public NamedAttributeArgumentAst(IScriptExtent extent, string argumentName, ExpressionAst argument, bool expressionOmitted);
    [CompilerGeneratedAttribute]
public string get_ArgumentName();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Argument();
    [CompilerGeneratedAttribute]
public bool get_ExpressionOmitted();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.NamedBlockAst : Ast {
    [CompilerGeneratedAttribute]
private bool <Unnamed>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenKind <BlockKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<StatementAst> <Statements>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TrapStatementAst> <Traps>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <OpenCurlyExtent>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent <CloseCurlyExtent>k__BackingField;
    public bool Unnamed { get; }
    public TokenKind BlockKind { get; }
    public ReadOnlyCollection`1<StatementAst> Statements { get; }
    public ReadOnlyCollection`1<TrapStatementAst> Traps { get; }
    internal IScriptExtent OpenCurlyExtent { get; }
    internal IScriptExtent CloseCurlyExtent { get; }
    public NamedBlockAst(IScriptExtent extent, TokenKind blockName, StatementBlockAst statementBlock, bool unnamed);
    [CompilerGeneratedAttribute]
public bool get_Unnamed();
    [CompilerGeneratedAttribute]
public TokenKind get_BlockKind();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<StatementAst> get_Statements();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TrapStatementAst> get_Traps();
    public virtual Ast Copy();
    private static bool HasInvalidBlockName(TokenKind blockName, bool unnamed);
    [CompilerGeneratedAttribute]
internal IScriptExtent get_OpenCurlyExtent();
    [CompilerGeneratedAttribute]
internal IScriptExtent get_CloseCurlyExtent();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.Language.NoRunspaceAffinityAttribute : ParsingBaseAttribute {
}
public class System.Management.Automation.Language.NullString : object {
    [CompilerGeneratedAttribute]
private static NullString <Value>k__BackingField;
    public static NullString Value { get; }
    private static NullString();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public static NullString get_Value();
}
internal enum System.Management.Automation.Language.NumberFormat : Enum {
    public int value__;
    public static NumberFormat Decimal;
    public static NumberFormat Hex;
    public static NumberFormat Binary;
}
[FlagsAttribute]
internal enum System.Management.Automation.Language.NumberSuffixFlags : Enum {
    public int value__;
    public static NumberSuffixFlags None;
    public static NumberSuffixFlags Unsigned;
    public static NumberSuffixFlags SignedByte;
    public static NumberSuffixFlags UnsignedByte;
    public static NumberSuffixFlags Short;
    public static NumberSuffixFlags UnsignedShort;
    public static NumberSuffixFlags Long;
    public static NumberSuffixFlags UnsignedLong;
    public static NumberSuffixFlags Decimal;
    public static NumberSuffixFlags BigInteger;
}
public class System.Management.Automation.Language.NumberToken : Token {
    private object _value;
    public object Value { get; }
    internal NumberToken(InternalScriptExtent scriptExtent, object value, TokenFlags tokenFlags);
    internal virtual string ToDebugString(int indent);
    public object get_Value();
}
public class System.Management.Automation.Language.ParamBlockAst : Ast {
    private static ReadOnlyCollection`1<AttributeAst> s_emptyAttributeList;
    private static ReadOnlyCollection`1<ParameterAst> s_emptyParameterList;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ParameterAst> <Parameters>k__BackingField;
    public ReadOnlyCollection`1<AttributeAst> Attributes { get; }
    public ReadOnlyCollection`1<ParameterAst> Parameters { get; }
    public ParamBlockAst(IScriptExtent extent, IEnumerable`1<AttributeAst> attributes, IEnumerable`1<ParameterAst> parameters);
    private static ParamBlockAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeAst> get_Attributes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ParameterAst> get_Parameters();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal static bool UsesCmdletBinding(IEnumerable`1<ParameterAst> parameters);
}
public class System.Management.Automation.Language.ParameterAst : Ast {
    private static ReadOnlyCollection`1<AttributeBaseAst> s_emptyAttributeList;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeBaseAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private VariableExpressionAst <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <DefaultValue>k__BackingField;
    public ReadOnlyCollection`1<AttributeBaseAst> Attributes { get; }
    public VariableExpressionAst Name { get; }
    public ExpressionAst DefaultValue { get; }
    public Type StaticType { get; }
    public ParameterAst(IScriptExtent extent, VariableExpressionAst name, IEnumerable`1<AttributeBaseAst> attributes, ExpressionAst defaultValue);
    private static ParameterAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeBaseAst> get_Attributes();
    [CompilerGeneratedAttribute]
public VariableExpressionAst get_Name();
    [CompilerGeneratedAttribute]
public ExpressionAst get_DefaultValue();
    public Type get_StaticType();
    public virtual Ast Copy();
    internal string GetTooltip();
    internal string GetParamTextWithDollarUsingHandling(IEnumerator`1<VariableExpressionAst> orderedUsingVar);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ParameterBindingResult : object {
    [CompilerGeneratedAttribute]
private ParameterMetadata <Parameter>k__BackingField;
    private object _constantValue;
    private CommandElementAst _value;
    public ParameterMetadata Parameter { get; internal set; }
    public object ConstantValue { get; internal set; }
    public CommandElementAst Value { get; internal set; }
    internal ParameterBindingResult(CompiledCommandParameter parameter, CommandElementAst value, object constantValue);
    [CompilerGeneratedAttribute]
public ParameterMetadata get_Parameter();
    [CompilerGeneratedAttribute]
internal void set_Parameter(ParameterMetadata value);
    public object get_ConstantValue();
    internal void set_ConstantValue(object value);
    public CommandElementAst get_Value();
    internal void set_Value(CommandElementAst value);
}
public class System.Management.Automation.Language.ParameterToken : Token {
    private string _parameterName;
    private bool _usedColon;
    public string ParameterName { get; }
    public bool UsedColon { get; }
    internal ParameterToken(InternalScriptExtent scriptExtent, string parameterName, bool usedColon);
    public string get_ParameterName();
    public bool get_UsedColon();
    internal virtual string ToDebugString(int indent);
}
public class System.Management.Automation.Language.ParenExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Pipeline>k__BackingField;
    public PipelineBaseAst Pipeline { get; }
    public ParenExpressionAst(IScriptExtent extent, PipelineBaseAst pipeline);
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Pipeline();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
}
public class System.Management.Automation.Language.ParseError : object {
    [CompilerGeneratedAttribute]
private IScriptExtent <Extent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncompleteInput>k__BackingField;
    public IScriptExtent Extent { get; }
    public string ErrorId { get; }
    public string Message { get; }
    public bool IncompleteInput { get; }
    public ParseError(IScriptExtent extent, string errorId, string message);
    internal ParseError(IScriptExtent extent, string errorId, string message, bool incompleteInput);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public IScriptExtent get_Extent();
    [CompilerGeneratedAttribute]
public string get_ErrorId();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public bool get_IncompleteInput();
}
internal enum System.Management.Automation.Language.ParseMode : Enum {
    public int value__;
    public static ParseMode Default;
    public static ParseMode ModuleAnalysis;
}
public class System.Management.Automation.Language.Parser : object {
    private Tokenizer _tokenizer;
    internal Token _ungotToken;
    private bool _disableCommaOperator;
    private bool _savingTokens;
    private bool _inConfiguration;
    private ParseMode _parseMode;
    internal string _fileName;
    [CompilerGeneratedAttribute]
private bool <ProduceV2Tokens>k__BackingField;
    internal static string VERBATIM_ARGUMENT;
    internal static string VERBATIM_PARAMETERNAME;
    private string _keywordModuleName;
    private string _previousFirstTokenText;
    private string _previousLastTokenText;
    [CompilerGeneratedAttribute]
private List`1<ParseError> <ErrorList>k__BackingField;
    private Dictionary`2<string, DynamicKeyword> _configurationKeywordsDefinedInThisFile;
    [ThreadStaticAttribute]
private static Object[] t_arrayOfOneArg;
    [ThreadStaticAttribute]
private static Object[] t_arrayOfTwoArgs;
    internal bool ProduceV2Tokens { get; internal set; }
    internal List`1<ParseError> ErrorList { get; }
    private static Object[] arrayOfOneArg { get; }
    private static Object[] arrayOfTwoArgs { get; }
    [CompilerGeneratedAttribute]
internal bool get_ProduceV2Tokens();
    [CompilerGeneratedAttribute]
internal void set_ProduceV2Tokens(bool value);
    public static ScriptBlockAst ParseFile(string fileName, Token[]& tokens, ParseError[]& errors);
    public static ScriptBlockAst ParseInput(string input, Token[]& tokens, ParseError[]& errors);
    public static ScriptBlockAst ParseInput(string input, string fileName, Token[]& tokens, ParseError[]& errors);
    internal ScriptBlockAst Parse(string fileName, string input, List`1<Token> tokenList, ParseError[]& errors, ParseMode parseMode);
    private ScriptBlockAst ParseTask(string fileName, string input, List`1<Token> tokenList, bool recursed, ParseMode parseMode);
    internal static object ScanNumber(string str, Type toType, bool shouldTryCoercion);
    internal static ITypeName ScanType(string typename, bool ignoreErrors);
    internal static ExpressionAst ScanString(string str);
    private static bool IgnoreTokenWhenUpdatingPreviousFirstLast(Token token);
    internal void SetPreviousFirstLastToken(ExecutionContext context);
    [CompilerGeneratedAttribute]
internal List`1<ParseError> get_ErrorList();
    private void SkipNewlines();
    private void SkipNewlinesAndSemicolons();
    private void SyncOnError(bool consumeClosingToken, TokenKind[] syncTokens);
    private Token NextToken();
    private Token PeekToken();
    private Token NextMemberAccessToken(bool allowLBracket);
    private Token NextInvokeMemberToken();
    private Token NextLBracket();
    private StringToken GetVerbatimCommandArgumentToken();
    private void SkipToken();
    private void UngetToken(Token token);
    private void SetTokenizerMode(TokenizerMode mode);
    private void Resync(Token token);
    private void Resync(int restorePoint);
    private static bool IsSpecificParameter(Token token, string parameter);
    internal void RequireStatementTerminator();
    internal static IScriptExtent ExtentOf(IScriptExtent first, IScriptExtent last);
    internal static IScriptExtent Before(IScriptExtent extent);
    internal static IScriptExtent After(IScriptExtent extent);
    internal static IScriptExtent LastCharacterOf(IScriptExtent extent);
    internal static IScriptExtent ExtentFromFirstOf(Object[] objs);
    internal static IScriptExtent ExtentOf(Token first, Token last);
    internal static IScriptExtent ExtentOf(Ast first, Ast last);
    internal static IScriptExtent ExtentOf(Ast first, Token last);
    internal static IScriptExtent ExtentOf(Token first, Ast last);
    internal static IScriptExtent ExtentOf(IScriptExtent first, Ast last);
    internal static IScriptExtent ExtentOf(IScriptExtent first, Token last);
    internal static IScriptExtent ExtentOf(Ast first, IScriptExtent last);
    internal static IScriptExtent ExtentOf(Token first, IScriptExtent last);
    internal static IScriptExtent Before(Token token);
    internal static IScriptExtent After(Ast ast);
    internal static IScriptExtent After(Token token);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.Parser/<GetNestedErrorAsts>d__62")]
private static IEnumerable`1<Ast> GetNestedErrorAsts(Object[] asts);
    internal static bool TryParseAsConstantHashtable(string input, Hashtable& result);
    private ScriptBlockAst ScriptBlockRule(Token lCurly, bool isFilter);
    private ScriptBlockAst ScriptBlockRule(Token lCurly, bool isFilter, StatementAst predefinedStatementAst);
    private List`1<UsingStatementAst> UsingStatementsRule();
    private ParamBlockAst ParamBlockRule();
    private List`1<ParameterAst> ParameterListRule();
    private ParameterAst ParameterRule();
    private List`1<AttributeBaseAst> AttributeListRule(bool inExpressionMode);
    private AttributeBaseAst AttributeRule();
    private void AttributeArgumentsRule(ICollection`1<ExpressionAst> positionalArguments, ICollection`1<NamedAttributeArgumentAst> namedArguments, IScriptExtent& lastItemExtent);
    private ITypeName TypeNameRule(bool allowAssemblyQualifiedNames, Token& firstTypeNameToken);
    private ITypeName FinishTypeNameRule(Token typeName, bool unBracketedGenericArg, bool allowAssemblyQualifiedNames);
    private ITypeName GetSingleGenericArgument(Token firstToken);
    private List`1<ITypeName> GenericTypeArgumentsRule(Token firstToken, Token& lastToken);
    private ITypeName GenericTypeNameRule(Token genericTypeName, Token firstToken, bool unbracketedGenericArg);
    private ITypeName CompleteArrayTypeName(ITypeName elementType, TypeName typeForAssemblyQualification, Token firstTokenAfterLBracket, bool unBracketedGenericArg);
    private bool CompleteScriptBlockBody(Token lCurly, IScriptExtent& bodyExtent, IScriptExtent& fullBodyExtent);
    private ScriptBlockAst ScriptBlockBodyRule(Token lCurly, List`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlockAst, bool isFilter, StatementAst predefinedStatementAst);
    private ScriptBlockAst NamedBlockListRule(Token lCurly, List`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlockAst);
    private StatementBlockAst StatementBlockRule();
    private IScriptExtent StatementListRule(List`1<StatementAst> statements, List`1<TrapStatementAst> traps);
    private StatementAst StatementRule();
    private StringConstantExpressionAst SimpleNameRule();
    private StringConstantExpressionAst SimpleNameRule(Token& token);
    private ExpressionAst LabelOrKeyRule();
    private BreakStatementAst BreakStatementRule(Token breakToken);
    private ContinueStatementAst ContinueStatementRule(Token continueToken);
    private ReturnStatementAst ReturnStatementRule(Token token);
    private ExitStatementAst ExitStatementRule(Token token);
    private ThrowStatementAst ThrowStatementRule(Token token);
    private StatementAst LabeledStatementRule(LabelToken label);
    private StatementAst BlockStatementRule(Token kindToken);
    private bool InlineScriptRule(Token inlineScriptToken, List`1<CommandElementAst> elements);
    private StatementAst IfStatementRule(Token ifToken);
    private StatementAst SwitchStatementRule(LabelToken labelToken, Token switchToken);
    private StatementAst ConfigurationStatementRule(IEnumerable`1<AttributeAst> customAttributes, Token configurationToken);
    private ExpressionAst GetWordOrExpression(Token keywordToken);
    private StatementAst ForeachStatementRule(LabelToken labelToken, Token forEachToken);
    private StatementAst ForStatementRule(LabelToken labelToken, Token forToken);
    private StatementAst WhileStatementRule(LabelToken labelToken, Token whileToken);
    private StatementAst DynamicKeywordStatementRule(Token functionName, DynamicKeyword keywordData);
    internal StatementAst CreateErrorStatementAst(Token functionName, ExpressionAst instanceName, ExpressionAst bodyExpression);
    private StatementAst DoWhileStatementRule(LabelToken labelToken, Token doToken);
    private StatementAst ClassDefinitionRule(List`1<AttributeBaseAst> customAttributes, Token classToken);
    private MemberAst ClassMemberRule(string className, List`1& astsOnError);
    private static bool TryUseTokenAsSimpleName(Token token);
    private static void RecordErrorAsts(Ast errAst, List`1& astsOnError);
    private static void RecordErrorAsts(IEnumerable`1<Ast> errAsts, List`1& astsOnError);
    private Token NextTypeIdentifierToken();
    private StatementAst EnumDefinitionRule(List`1<AttributeBaseAst> customAttributes, Token enumToken);
    private MemberAst EnumMemberRule();
    private StatementAst UsingStatementRule(Token usingToken);
    private StringConstantExpressionAst ResolveUsingAssembly(StringConstantExpressionAst name);
    private StatementAst MethodDeclarationRule(Token functionNameToken, string className, bool isStaticMethod);
    private StatementAst FunctionDeclarationRule(Token functionToken);
    private List`1<ParameterAst> FunctionParameterDeclarationRule(IScriptExtent& endErrorStatement, Token& rParen);
    private StatementAst TrapStatementRule(Token trapToken);
    private CatchClauseAst CatchBlockRule(IScriptExtent& endErrorStatement, List`1& errorAsts);
    private StatementAst TryStatementRule(Token tryToken);
    private StatementAst DataStatementRule(Token dataToken);
    private PipelineBaseAst PipelineChainRule();
    private PipelineBaseAst PipelineRule(ExpressionAst startExpression, bool allowBackground);
    private RedirectionAst RedirectionRule(RedirectionToken redirectionToken, RedirectionAst[] redirections, IScriptExtent& extent);
    private ExpressionAst GetSingleCommandArgument(CommandArgumentContext context);
    private ExpressionAst GetCommandArgument(CommandArgumentContext context, Token token);
    internal Ast CommandRule(bool forDynamicKeyword);
    private ExpressionAst ExpressionRule(bool endNumberOnTernaryOpChars);
    private ExpressionAst BinaryExpressionRule(bool endNumberOnTernaryOpChars);
    private ExpressionAst ErrorRecoveryParameterInExpression(ParameterToken paramToken, ExpressionAst expr);
    private ExpressionAst ArrayLiteralRule(bool endNumberOnTernaryOpChars);
    private ExpressionAst UnaryExpressionRule(bool endNumberOnTernaryOpChars);
    private ExpressionAst PrimaryExpressionRule(bool withMemberAccess);
    private ExpressionAst CheckUsingVariable(VariableToken variableToken, bool withMemberAccess);
    private ExpressionAst CheckPostPrimaryExpressionOperators(Token token, ExpressionAst expr);
    private ExpressionAst HashExpressionRule(Token atCurlyToken, bool parsingSchemaElement);
    private Tuple`2<ExpressionAst, StatementAst> GetKeyValuePair(bool parsingSchemaElement);
    private ExpressionAst ScriptBlockExpressionRule(Token lCurly);
    private ExpressionAst SubExpressionRule(Token firstToken);
    private ExpressionAst ParenthesizedExpressionRule(Token lParen);
    private List`1<ExpressionAst> ParseNestedExpressions(StringExpandableToken expandableStringToken);
    private ExpressionAst ExpandableStringRule(StringExpandableToken strToken);
    private ExpressionAst MemberNameRule();
    private ExpressionAst MemberAccessRule(ExpressionAst targetExpr, Token operatorToken);
    private List`1<ITypeName> GenericMethodArgumentsRule(int resyncIndex, Token& rBracketToken);
    private ExpressionAst MemberInvokeRule(ExpressionAst targetExpr, Token lBracket, Token operatorToken, CommandElementAst member, IList`1<ITypeName> genericTypes);
    private List`1<ExpressionAst> InvokeParamParenListRule(Token lParen, IScriptExtent& lastExtent);
    private ExpressionAst ElementAccessRule(ExpressionAst primaryExpression, Token lBracket);
    private void SaveError(ParseError error);
    private void SaveError(IScriptExtent extent, string errorId, string errorMsg, bool incompleteInput, Object[] args);
    [ConditionalAttribute("DEBUG")]
[ConditionalAttribute("ASSERTIONS_TRACE")]
private static void AssertErrorIdCorrespondsToMsgString(string errorId, string errorMsg);
    private static Object[] get_arrayOfOneArg();
    private static Object[] get_arrayOfTwoArgs();
    internal bool ReportIncompleteInput(IScriptExtent extent, string errorId, string errorMsg);
    internal bool ReportIncompleteInput(IScriptExtent extent, string errorId, string errorMsg, object arg);
    internal bool ReportIncompleteInput(IScriptExtent errorPosition, IScriptExtent errorDetectedPosition, string errorId, string errorMsg, Object[] args);
    internal void ReportError(IScriptExtent extent, string errorId, string errorMsg);
    internal void ReportError(IScriptExtent extent, string errorId, string errorMsg, object arg);
    internal void ReportError(IScriptExtent extent, string errorId, string errorMsg, object arg1, object arg2);
    internal void ReportError(IScriptExtent extent, string errorId, string errorMsg, Object[] args);
    internal void ReportError(ParseError error);
    private static void ReportErrorsAsWarnings(Collection`1<Exception> errors);
}
[EventSourceAttribute]
internal class System.Management.Automation.Language.ParserEventSource : EventSource {
    internal static ParserEventSource Log;
    internal static int MaxScriptLengthToLog;
    private static ParserEventSource();
    public void ParseStart(string FileName, int Length);
    public void ParseStop();
    public void ResolveSymbolsStart();
    public void ResolveSymbolsStop();
    public void SemanticChecksStart();
    public void SemanticChecksStop();
    public void CheckSecurityStart(string FileName);
    public void CheckSecurityStop(string FileName);
    public void CompileStart(string FileName, int Length, bool Optimized);
    public void CompileStop();
    internal static string GetFileOrScript(string fileName, string input);
}
public class System.Management.Automation.Language.PipelineAst : ChainableAst {
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CommandBaseAst> <PipelineElements>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Background>k__BackingField;
    public ReadOnlyCollection`1<CommandBaseAst> PipelineElements { get; }
    public bool Background { get; internal set; }
    public PipelineAst(IScriptExtent extent, IEnumerable`1<CommandBaseAst> pipelineElements, bool background);
    public PipelineAst(IScriptExtent extent, IEnumerable`1<CommandBaseAst> pipelineElements);
    public PipelineAst(IScriptExtent extent, CommandBaseAst commandAst, bool background);
    public PipelineAst(IScriptExtent extent, CommandBaseAst commandAst);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CommandBaseAst> get_PipelineElements();
    [CompilerGeneratedAttribute]
public bool get_Background();
    [CompilerGeneratedAttribute]
internal void set_Background(bool value);
    public virtual ExpressionAst GetPureExpression();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public abstract class System.Management.Automation.Language.PipelineBaseAst : StatementAst {
    protected PipelineBaseAst(IScriptExtent extent);
    public virtual ExpressionAst GetPureExpression();
}
public class System.Management.Automation.Language.PipelineChainAst : ChainableAst {
    [CompilerGeneratedAttribute]
private ChainableAst <LhsPipelineChain>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineAst <RhsPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenKind <Operator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Background>k__BackingField;
    public ChainableAst LhsPipelineChain { get; }
    public PipelineAst RhsPipeline { get; }
    public TokenKind Operator { get; }
    public bool Background { get; }
    public PipelineChainAst(IScriptExtent extent, ChainableAst lhsChain, PipelineAst rhsPipeline, TokenKind chainOperator, bool background);
    [CompilerGeneratedAttribute]
public ChainableAst get_LhsPipelineChain();
    [CompilerGeneratedAttribute]
public PipelineAst get_RhsPipeline();
    [CompilerGeneratedAttribute]
public TokenKind get_Operator();
    [CompilerGeneratedAttribute]
public bool get_Background();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.PipeObjectPair : AstParameterArgumentPair {
    internal PipeObjectPair(string parameterName, Type pipeObjType);
}
internal class System.Management.Automation.Language.PositionHelper : object {
    private Int32[] _lineStartMap;
    [CompilerGeneratedAttribute]
private string <ScriptText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    internal string ScriptText { get; }
    unknown Int32[] LineStartMap {internal set; }
    public string File { get; }
    internal PositionHelper(string filename, string scriptText);
    [CompilerGeneratedAttribute]
internal string get_ScriptText();
    internal void set_LineStartMap(Int32[] value);
    [CompilerGeneratedAttribute]
public string get_File();
    internal int LineFromOffset(int offset);
    internal int ColumnFromOffset(int offset);
    internal string Text(int line);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.PositionUtilities : object {
    [CompilerGeneratedAttribute]
private static IScriptPosition <EmptyPosition>k__BackingField;
    [CompilerGeneratedAttribute]
private static IScriptExtent <EmptyExtent>k__BackingField;
    public static IScriptPosition EmptyPosition { get; }
    public static IScriptExtent EmptyExtent { get; }
    private static PositionUtilities();
    [CompilerGeneratedAttribute]
public static IScriptPosition get_EmptyPosition();
    [CompilerGeneratedAttribute]
public static IScriptExtent get_EmptyExtent();
    internal static string VerboseMessage(IScriptExtent position);
    internal static string BriefMessage(IScriptPosition position);
    internal static IScriptExtent NewScriptExtent(IScriptExtent start, IScriptExtent end);
    [ExtensionAttribute]
internal static bool IsBefore(IScriptExtent extentToTest, IScriptExtent startExtent);
    [ExtensionAttribute]
internal static bool IsAfter(IScriptExtent extentToTest, IScriptExtent endExtent);
    [ExtensionAttribute]
internal static bool IsWithin(IScriptExtent extentToTest, IScriptExtent extent);
    [ExtensionAttribute]
internal static bool IsAfter(IScriptExtent extent, int line, int column);
    [ExtensionAttribute]
internal static bool ContainsLineAndColumn(IScriptExtent extent, int line, int column);
}
internal class System.Management.Automation.Language.PowerShellLoopExpression : Expression {
    private IEnumerable`1<Expression> _exprs;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    internal PowerShellLoopExpression(IEnumerable`1<Expression> exprs);
    public virtual bool get_CanReduce();
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
    public virtual Expression Reduce();
    public sealed virtual void AddInstructions(LightCompiler compiler);
}
[FlagsAttribute]
public enum System.Management.Automation.Language.PropertyAttributes : Enum {
    public int value__;
    public static PropertyAttributes None;
    public static PropertyAttributes Public;
    public static PropertyAttributes Private;
    public static PropertyAttributes Static;
    public static PropertyAttributes Literal;
    public static PropertyAttributes Hidden;
}
public class System.Management.Automation.Language.PropertyMemberAst : MemberAst {
    private static ReadOnlyCollection`1<AttributeAst> s_emptyAttributeList;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeConstraintAst <PropertyType>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyAttributes <PropertyAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <InitialValue>k__BackingField;
    public string Name { get; }
    public TypeConstraintAst PropertyType { get; }
    public ReadOnlyCollection`1<AttributeAst> Attributes { get; }
    public PropertyAttributes PropertyAttributes { get; }
    public ExpressionAst InitialValue { get; }
    public bool IsPublic { get; }
    public bool IsPrivate { get; }
    public bool IsHidden { get; }
    public bool IsStatic { get; }
    public PropertyMemberAst(IScriptExtent extent, string name, TypeConstraintAst propertyType, IEnumerable`1<AttributeAst> attributes, PropertyAttributes propertyAttributes, ExpressionAst initialValue);
    private static PropertyMemberAst();
    [CompilerGeneratedAttribute]
public virtual string get_Name();
    [CompilerGeneratedAttribute]
public TypeConstraintAst get_PropertyType();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeAst> get_Attributes();
    [CompilerGeneratedAttribute]
public PropertyAttributes get_PropertyAttributes();
    [CompilerGeneratedAttribute]
public ExpressionAst get_InitialValue();
    public bool get_IsPublic();
    public bool get_IsPrivate();
    public bool get_IsHidden();
    public bool get_IsStatic();
    public virtual Ast Copy();
    internal virtual string GetTooltip();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.PSArrayAssignmentRHSBinder : DynamicMetaObjectBinder {
    private static List`1<PSArrayAssignmentRHSBinder> s_binders;
    private int _elements;
    public Type ReturnType { get; }
    private PSArrayAssignmentRHSBinder(int elements);
    private static PSArrayAssignmentRHSBinder();
    internal static PSArrayAssignmentRHSBinder Get(int i);
    public virtual string ToString();
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSAttributeGenerator : CreateInstanceBinder {
    private static Dictionary`2<CallInfo, PSAttributeGenerator> s_binderCache;
    private PSAttributeGenerator(CallInfo callInfo);
    private static PSAttributeGenerator();
    internal static PSAttributeGenerator Get(CallInfo callInfo);
    public virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.Language.PSBinaryOperationBinder : BinaryOperationBinder {
    private static Dictionary`2<Tuple`3<ExpressionType, bool, bool>, PSBinaryOperationBinder> s_binderCache;
    private bool _ignoreCase;
    private bool _scalarCompare;
    internal int _version;
    private Func`3<object, object, bool> _compareDelegate;
    private PSBinaryOperationBinder(ExpressionType operation, bool ignoreCase, bool scalarCompare);
    private static PSBinaryOperationBinder();
    internal static PSBinaryOperationBinder Get(ExpressionType operation, bool ignoreCase, bool scalarCompare);
    private Func`3<object, object, bool> GetScalarCompareDelegate();
    public virtual DynamicMetaObject FallbackBinaryOperation(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    public virtual string ToString();
    internal static void InvalidateCache();
    private string GetOperatorText();
    private static DynamicMetaObject CallImplicitOp(string methodName, DynamicMetaObject target, DynamicMetaObject arg, string errorOperator, DynamicMetaObject errorSuggestion);
    private static bool IsValueNegative(object value, TypeCode typeCode);
    private static Expression TypedZero(TypeCode typeCode);
    private static DynamicMetaObject FigureSignedUnsignedInt(DynamicMetaObject obj, TypeCode typeCode, TypeCode currentOpType, Type& opImplType, Type& argType, Boolean& shouldFallbackToDoubleInCaseOfOverflow);
    private DynamicMetaObject BinaryNumericOp(string methodName, DynamicMetaObject target, DynamicMetaObject arg);
    private DynamicMetaObject BinaryNumericStringOp(DynamicMetaObject target, DynamicMetaObject arg);
    internal static Expression ConvertStringToNumber(Expression expr, Type toType);
    private static DynamicMetaObject GetArgAsNumericOrPrimitive(DynamicMetaObject arg, Type targetType);
    private static Type GetBitwiseOpType(TypeCode opTypeCode);
    private DynamicMetaObject BinaryAdd(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinarySub(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryMultiply(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryDivide(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryRemainder(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinarySubDivOrRem(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion, string numericOpMethodName, string implicitOpMethodName, string errorOperatorText);
    private DynamicMetaObject Shift(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion, string userOp, Func`3<Expression, Expression, Expression> exprGenerator);
    private DynamicMetaObject LeftShift(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject RightShift(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryBitwiseXor(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryBitwiseOr(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryBitwiseAnd(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryBitwiseOp(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion, Func`3<Expression, Expression, Expression> exprGenerator, string implicitMethodName, string errorOperatorName, string methodName);
    private DynamicMetaObject CompareEQ(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CompareNE(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryEqualityComparison(DynamicMetaObject target, DynamicMetaObject arg);
    private static Expression CompareWithZero(DynamicMetaObject target, Func`3<Expression, Expression, Expression> comparer);
    private DynamicMetaObject CompareLT(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CompareLE(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CompareGT(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CompareGE(DynamicMetaObject target, DynamicMetaObject arg, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject BinaryComparison(DynamicMetaObject target, DynamicMetaObject arg, Func`2<Expression, Expression> toResult);
    private DynamicMetaObject BinaryComparisonCommon(DynamicMetaObject targetAsEnumerator, DynamicMetaObject target, DynamicMetaObject arg);
}
internal class System.Management.Automation.Language.PSConvertBinder : ConvertBinder {
    private static Dictionary`2<Type, PSConvertBinder> s_binderCache;
    internal int _version;
    private PSConvertBinder(Type type);
    private static PSConvertBinder();
    public static PSConvertBinder Get(Type type);
    public virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public virtual string ToString();
    internal static void InvalidateCache();
    internal static DynamicMetaObject ThrowNoConversion(DynamicMetaObject target, Type toType, DynamicMetaObjectBinder binder, int currentVersion, DynamicMetaObject[] args);
    internal static Expression ConvertToByRefLikeTypeViaCasting(DynamicMetaObject argument, Type resultType);
    internal static Expression InvokeConverter(IConversionData conversion, Expression value, Type resultType, bool debase, Expression formatProvider);
    private static string StringToStringRule(CallSite site, object obj);
}
internal class System.Management.Automation.Language.PSCreateInstanceBinder : CreateInstanceBinder {
    private CallInfo _callInfo;
    private PSMethodInvocationConstraints _constraints;
    private bool _publicTypeOnly;
    private int _version;
    private static Dictionary`2<Tuple`3<CallInfo, PSMethodInvocationConstraints, bool>, PSCreateInstanceBinder> s_binderCache;
    internal PSCreateInstanceBinder(CallInfo callInfo, PSMethodInvocationConstraints constraints, bool publicTypeOnly);
    private static PSCreateInstanceBinder();
    public static PSCreateInstanceBinder Get(CallInfo callInfo, PSMethodInvocationConstraints constraints, bool publicTypeOnly);
    internal static void InvalidateCache();
    public virtual string ToString();
    public virtual DynamicMetaObject FallbackCreateInstance(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    internal static bool IsTargetTypeByRefLike(object target);
    internal static bool IsTargetTypeNonPublic(object target);
    internal static string GetTargetTypeName(object target);
}
internal class System.Management.Automation.Language.PSCustomObjectConverter : DynamicMetaObjectBinder {
    private static PSCustomObjectConverter s_binder;
    private static PSCustomObjectConverter();
    internal static PSCustomObjectConverter Get();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSDynamicConvertBinder : DynamicMetaObjectBinder {
    private static PSDynamicConvertBinder s_binder;
    private static PSDynamicConvertBinder();
    internal static PSDynamicConvertBinder Get();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSDynamicGetOrSetBinderKeyComparer : object {
    public sealed virtual bool Equals(Tuple`2<Type, bool> x, Tuple`2<Type, bool> y);
    public sealed virtual int GetHashCode(Tuple`2<Type, bool> obj);
}
internal class System.Management.Automation.Language.PSEnumerableBinder : ConvertBinder {
    private static PSEnumerableBinder s_binder;
    private static PSEnumerableBinder();
    internal static PSEnumerableBinder Get();
    public virtual string ToString();
    internal static BindingRestrictions GetRestrictions(DynamicMetaObject target);
    private DynamicMetaObject NullResult(DynamicMetaObject target);
    internal static Expression MaybeDebase(DynamicMetaObjectBinder binder, Func`2<Expression, Expression> generator, DynamicMetaObject target);
    public virtual DynamicMetaObject FallbackConvert(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    internal static bool IsStaticTypePossiblyEnumerable(Type type);
    internal static DynamicMetaObject IsEnumerable(DynamicMetaObject target);
    private static IEnumerator AutomationNullRule(CallSite site, object obj);
    private static IEnumerator NotEnumerableRule(CallSite site, object obj);
    private static IEnumerator PSObjectNotEnumerableRule(CallSite site, object obj);
    private static IEnumerator ArrayRule(CallSite site, object obj);
    private static IEnumerator StringRule(CallSite site, object obj);
    private static IEnumerator PSObjectStringRule(CallSite site, object obj);
}
internal class System.Management.Automation.Language.PseudoBindingInfo : object {
    [CompilerGeneratedAttribute]
private CommandInfo <CommandInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private PseudoBindingInfoType <InfoType>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ValidParameterSetsFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <DefaultParameterSetFlag>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MergedCompiledCommandParameter> <BoundParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<MergedCompiledCommandParameter> <UnboundParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, AstParameterArgumentPair> <BoundArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AstParameterArgumentPair> <UnboundArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <BoundPositionalParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AstParameterArgumentPair> <AllParsedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CommandParameterAst> <ParametersNotFound>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CommandParameterAst> <AmbiguousParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<CommandParameterAst, ParameterBindingException> <BindingExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<AstParameterArgumentPair> <DuplicateParameters>k__BackingField;
    internal string CommandName { get; }
    internal CommandInfo CommandInfo { get; }
    internal PseudoBindingInfoType InfoType { get; }
    internal UInt32 ValidParameterSetsFlags { get; }
    internal UInt32 DefaultParameterSetFlag { get; }
    internal Dictionary`2<string, MergedCompiledCommandParameter> BoundParameters { get; }
    internal List`1<MergedCompiledCommandParameter> UnboundParameters { get; }
    internal Dictionary`2<string, AstParameterArgumentPair> BoundArguments { get; }
    internal Collection`1<AstParameterArgumentPair> UnboundArguments { get; }
    internal Collection`1<string> BoundPositionalParameter { get; }
    internal Collection`1<AstParameterArgumentPair> AllParsedArguments { get; }
    internal Collection`1<CommandParameterAst> ParametersNotFound { get; }
    internal Collection`1<CommandParameterAst> AmbiguousParameters { get; }
    internal Dictionary`2<CommandParameterAst, ParameterBindingException> BindingExceptions { get; }
    internal Collection`1<AstParameterArgumentPair> DuplicateParameters { get; }
    internal PseudoBindingInfo(CommandInfo commandInfo, UInt32 validParameterSetsFlags, UInt32 defaultParameterSetFlag, Dictionary`2<string, MergedCompiledCommandParameter> boundParameters, List`1<MergedCompiledCommandParameter> unboundParameters, Dictionary`2<string, AstParameterArgumentPair> boundArguments, Collection`1<string> boundPositionalParameter, Collection`1<AstParameterArgumentPair> allParsedArguments, Collection`1<CommandParameterAst> parametersNotFound, Collection`1<CommandParameterAst> ambiguousParameters, Dictionary`2<CommandParameterAst, ParameterBindingException> bindingExceptions, Collection`1<AstParameterArgumentPair> duplicateParameters, Collection`1<AstParameterArgumentPair> unboundArguments);
    internal PseudoBindingInfo(CommandInfo commandInfo, UInt32 defaultParameterSetFlag, Collection`1<AstParameterArgumentPair> allParsedArguments, List`1<MergedCompiledCommandParameter> unboundParameters);
    internal string get_CommandName();
    [CompilerGeneratedAttribute]
internal CommandInfo get_CommandInfo();
    [CompilerGeneratedAttribute]
internal PseudoBindingInfoType get_InfoType();
    [CompilerGeneratedAttribute]
internal UInt32 get_ValidParameterSetsFlags();
    [CompilerGeneratedAttribute]
internal UInt32 get_DefaultParameterSetFlag();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, MergedCompiledCommandParameter> get_BoundParameters();
    [CompilerGeneratedAttribute]
internal List`1<MergedCompiledCommandParameter> get_UnboundParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, AstParameterArgumentPair> get_BoundArguments();
    [CompilerGeneratedAttribute]
internal Collection`1<AstParameterArgumentPair> get_UnboundArguments();
    [CompilerGeneratedAttribute]
internal Collection`1<string> get_BoundPositionalParameter();
    [CompilerGeneratedAttribute]
internal Collection`1<AstParameterArgumentPair> get_AllParsedArguments();
    [CompilerGeneratedAttribute]
internal Collection`1<CommandParameterAst> get_ParametersNotFound();
    [CompilerGeneratedAttribute]
internal Collection`1<CommandParameterAst> get_AmbiguousParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<CommandParameterAst, ParameterBindingException> get_BindingExceptions();
    [CompilerGeneratedAttribute]
internal Collection`1<AstParameterArgumentPair> get_DuplicateParameters();
}
internal enum System.Management.Automation.Language.PseudoBindingInfoType : Enum {
    public int value__;
    public static PseudoBindingInfoType PseudoBindingFail;
    public static PseudoBindingInfoType PseudoBindingSucceed;
}
internal class System.Management.Automation.Language.PseudoParameterBinder : object {
    private PSHost _restoreHost;
    private CommandAst _commandAst;
    private ReadOnlyCollection`1<CommandElementAst> _commandElements;
    private bool _function;
    private string _commandName;
    private CommandInfo _commandInfo;
    private UInt32 _currentParameterSetFlag;
    private UInt32 _defaultParameterSetFlag;
    private MergedCommandParameterMetadata _bindableParameters;
    private Dictionary`2<string, MergedCompiledCommandParameter> _boundParameters;
    private Dictionary`2<string, AstParameterArgumentPair> _boundArguments;
    private Collection`1<AstParameterArgumentPair> _arguments;
    private Collection`1<string> _boundPositionalParameter;
    private List`1<MergedCompiledCommandParameter> _unboundParameters;
    private Type _pipelineInputType;
    private bool _bindingEffective;
    private bool _isPipelineInputExpected;
    private Collection`1<CommandParameterAst> _parametersNotFound;
    private Collection`1<CommandParameterAst> _ambiguousParameters;
    private Collection`1<AstParameterArgumentPair> _duplicateParameters;
    private Dictionary`2<CommandParameterAst, ParameterBindingException> _bindingExceptions;
    internal PseudoBindingInfo DoPseudoParameterBinding(CommandAst command, Type pipeArgumentType, CommandParameterAst paramAstAtCursor, BindingType bindingType, bool bindPositional);
    private void SetTemporaryDefaultHost(ExecutionContext executionContext);
    private void RestoreHost(ExecutionContext executionContext);
    private void InitializeMembers();
    private bool PrepareCommandElements(ExecutionContext context, CommandParameterAst paramAtCursor);
    private CommandProcessorBase PrepareFromAst(ExecutionContext context, String& resolvedCommandName);
    private bool ParseParameterArguments(CommandParameterAst paramAstAtCursor);
    private Collection`1<AstParameterArgumentPair> BindNamedParameters();
    private Collection`1<AstParameterArgumentPair> BindPositionalParameter(Collection`1<AstParameterArgumentPair> unboundArguments, UInt32 validParameterSetFlags, UInt32 defaultParameterSetFlag, BindingType bindingType);
    private bool BindPseudoPositionalParameterInSet(UInt32 validParameterSetFlag, Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter> nextPositionalParameters, AstParameterArgumentPair argument, bool typeConversion);
    private static bool IsTypeEquivalent(Type argType, Type paramType);
    private static AstParameterArgumentPair GetNextPositionalArgument(List`1<AstParameterArgumentPair> unboundArgumentsCollection, Collection`1<AstParameterArgumentPair> nonPositionalArguments, Int32& unboundArgumentsIndex);
    private Collection`1<AstParameterArgumentPair> BindRemainingParameters(Collection`1<AstParameterArgumentPair> unboundArguments);
    private void BindPipelineParameters();
}
internal class System.Management.Automation.Language.PSGetDynamicMemberBinder : DynamicMetaObjectBinder {
    private static Dictionary`2<Tuple`2<Type, bool>, PSGetDynamicMemberBinder> s_binderCache;
    private bool _static;
    private Type _classScope;
    private PSGetDynamicMemberBinder(Type classScope, bool static);
    private static PSGetDynamicMemberBinder();
    internal static PSGetDynamicMemberBinder Get(TypeDefinitionAst classScope, bool static);
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal static object GetIDictionaryMember(IDictionary hash, object key);
}
internal class System.Management.Automation.Language.PSGetIndexBinder : GetIndexBinder {
    private static Dictionary`2<Tuple`3<CallInfo, PSMethodInvocationConstraints, bool>, PSGetIndexBinder> s_binderCache;
    private PSMethodInvocationConstraints _constraints;
    private bool _allowSlicing;
    internal int _version;
    private PSGetIndexBinder(Tuple`3<CallInfo, PSMethodInvocationConstraints, bool> tuple);
    private static PSGetIndexBinder();
    public static PSGetIndexBinder Get(int argCount, PSMethodInvocationConstraints constraints, bool allowSlicing);
    public virtual string ToString();
    internal static void InvalidateCache();
    public virtual DynamicMetaObject FallbackGetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CannotIndexTarget(DynamicMetaObject target, DynamicMetaObject[] indexes);
    private DynamicMetaObject GetIndexDictionary(DynamicMetaObject target, DynamicMetaObject[] indexes, Type idictionary);
    internal static bool CanIndexFromEndWithNegativeIndex(DynamicMetaObject target, MethodInfo indexer, ParameterInfo[] getterParams);
    private DynamicMetaObject IndexWithNegativeChecks(DynamicMetaObject target, DynamicMetaObject index, PropertyInfo lengthProperty, Func`3<Expression, Expression, Expression> generateIndexOperation);
    private DynamicMetaObject GetIndexArray(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject GetIndexMultiDimensionArray(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject InvokeIndexer(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject errorSuggestion, string methodName, PropertyInfo lengthProperty);
    internal static Expression ConvertIndex(DynamicMetaObject index, Type resultType);
    private DynamicMetaObject CheckForSlicing(DynamicMetaObject target, DynamicMetaObject[] indexes);
    private DynamicMetaObject InvokeSlicingIndexer(DynamicMetaObject target, DynamicMetaObject[] indexes);
    private Expression SafeIndexResult(Expression expr);
    private Expression GetNullResult();
    private Func`3<object, object, object> GetNonSlicingIndexer();
}
internal class System.Management.Automation.Language.PSGetMemberBinder : GetMemberBinder {
    private static Dictionary`2<Tuple`4<string, Type, bool, bool>, PSGetMemberBinder> s_binderCache;
    private static ConcurrentDictionary`2<string, List`1<PSGetMemberBinder>> s_binderCacheIgnoringCase;
    private bool _static;
    private bool _nonEnumerating;
    private Type _classScope;
    internal int _version;
    private bool _hasInstanceMember;
    private bool _hasTypeTableMember;
    internal bool HasInstanceMember { get; }
    private static PSGetMemberBinder();
    private PSGetMemberBinder(string name, Type classScope, bool ignoreCase, bool static, bool nonEnumerating);
    internal bool get_HasInstanceMember();
    internal static void SetHasInstanceMember(string memberName);
    internal static void TypeTableMemberAdded(string memberName);
    internal static void TypeTableMemberPossiblyUpdated(string memberName);
    public static PSGetMemberBinder Get(string memberName, TypeDefinitionAst classScope, bool static);
    public static PSGetMemberBinder Get(string memberName, Type classScope, bool static);
    private PSGetMemberBinder GetNonEnumeratingBinder();
    private static PSGetMemberBinder Get(string memberName, Type classScope, bool static, bool nonEnumerating);
    public virtual string ToString();
    public virtual DynamicMetaObject FallbackGetMember(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject GenerateGetPropertyException(BindingRestrictions restrictions);
    internal static bool IsGenericDictionary(object value, Type& genericTypeArg);
    internal static Expression GetTargetExpr(DynamicMetaObject target, Type castToType);
    private DynamicMetaObject PropertyDoesntExist(DynamicMetaObject target, BindingRestrictions restrictions);
    private Expression ThrowPropertyNotFoundStrict();
    internal static DynamicMetaObject EnsureAllowedInLanguageMode(DynamicMetaObject target, object targetValue, string name, bool isStatic, DynamicMetaObject[] args, BindingRestrictions moreTests, string errorID, string resourceString);
    internal static bool IsAllowedInConstrainedLanguage(object targetValue, string name, bool isStatic);
    internal BindingRestrictions NotInstanceMember(DynamicMetaObject target);
    private static Expression WrapGetMemberInTry(Expression expr);
    private PSMemberInfo ResolveAlias(PSAliasProperty alias, DynamicMetaObject target, HashSet`1<string> aliases, List`1<BindingRestrictions> aliasRestrictions);
    internal PSMemberInfo GetPSMemberInfo(DynamicMetaObject target, BindingRestrictions& restrictions, Boolean& canOptimize, Type& aliasConversionType, MemberTypes memberTypeToOperateOn, HashSet`1<string> aliases, List`1<BindingRestrictions> aliasRestrictions);
    internal static PSMemberInfo CloneMemberInfo(PSMemberInfo memberInfo, object obj);
    internal static object GetAdaptedValue(object obj, string member);
    internal static bool IsTypeNameSame(object value, string typeName);
    internal static TypeTable GetTypeTableFromTLS();
    internal static bool TryGetInstanceMember(object value, string memberName, PSMemberInfo& memberInfo);
    internal static bool TryGetIDictionaryValue(IDictionary hash, string memberName, Object& value);
    internal static bool TryGetGenericDictionaryValue(IDictionary`2<string, T> hash, string memberName, Object& value);
}
internal class System.Management.Automation.Language.PSInvokeBaseCtorBinder : InvokeMemberBinder {
    private CallInfo _callInfo;
    private PSMethodInvocationConstraints _constraints;
    private static Dictionary`2<Tuple`2<CallInfo, PSMethodInvocationConstraints>, PSInvokeBaseCtorBinder> s_binderCache;
    internal PSInvokeBaseCtorBinder(CallInfo callInfo, PSMethodInvocationConstraints constraints);
    private static PSInvokeBaseCtorBinder();
    public static PSInvokeBaseCtorBinder Get(CallInfo callInfo, PSMethodInvocationConstraints constraints);
    public virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.Language.PSInvokeBinder : InvokeBinder {
    internal PSInvokeBinder(CallInfo callInfo);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.Language.PSInvokeDynamicMemberBinder : DynamicMetaObjectBinder {
    private static Dictionary`2<Tuple`5<CallInfo, PSMethodInvocationConstraints, bool, bool, Type>, PSInvokeDynamicMemberBinder> s_binderCache;
    private CallInfo _callInfo;
    private bool _static;
    private bool _propertySetter;
    private PSMethodInvocationConstraints _constraints;
    private Type _classScope;
    private PSInvokeDynamicMemberBinder(CallInfo callInfo, bool static, bool propertySetter, PSMethodInvocationConstraints constraints, Type classScope);
    private static PSInvokeDynamicMemberBinder();
    internal static PSInvokeDynamicMemberBinder Get(CallInfo callInfo, TypeDefinitionAst classScopeAst, bool static, bool propertySetter, PSMethodInvocationConstraints constraints);
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSInvokeMemberBinder : InvokeMemberBinder {
    private static Dictionary`2<Tuple`7<string, CallInfo, bool, bool, PSMethodInvocationConstraints, bool, Type>, PSInvokeMemberBinder> s_binderCache;
    internal PSMethodInvocationConstraints _invocationConstraints;
    internal PSGetMemberBinder _getMemberBinder;
    private bool _static;
    private bool _propertySetter;
    private bool _nonEnumerating;
    private Type _classScope;
    private PSInvokeMemberBinder(string name, bool ignoreCase, bool static, bool propertySetter, bool nonEnumerating, CallInfo callInfo, PSMethodInvocationConstraints invocationConstraints, Type classScope);
    private static PSInvokeMemberBinder();
    private PSInvokeMemberBinder GetNonEnumeratingBinder();
    public static PSInvokeMemberBinder Get(string memberName, CallInfo callInfo, bool static, bool propertySetter, PSMethodInvocationConstraints constraints, Type classScope);
    private static PSInvokeMemberBinder Get(string memberName, Type classScope, CallInfo callInfo, bool static, bool propertySetter, bool nonEnumerating, PSMethodInvocationConstraints constraints);
    public virtual string ToString();
    public virtual DynamicMetaObject FallbackInvokeMember(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    internal static DynamicMetaObject InvokeDotNetMethod(CallInfo callInfo, string name, PSMethodInvocationConstraints psMethodInvocationConstraints, MethodInvocationType methodInvocationType, DynamicMetaObject target, DynamicMetaObject[] args, BindingRestrictions restrictions, MethodInformation[] mi, Type errorExceptionType);
    public virtual DynamicMetaObject FallbackInvoke(DynamicMetaObject target, DynamicMetaObject[] args, DynamicMetaObject errorSuggestion);
    internal static MethodInfo FindBestMethod(DynamicMetaObject target, IEnumerable`1<DynamicMetaObject> args, string methodName, bool static, PSMethodInvocationConstraints invocationConstraints);
    internal static Expression InvokeMethod(MethodBase mi, DynamicMetaObject target, DynamicMetaObject[] args, bool expandParameters, MethodInvocationType invocationType);
    private DynamicMetaObject InvokeMemberOnCollection(DynamicMetaObject targetEnumerator, DynamicMetaObject[] args, Type typeForMessage, BindingRestrictions restrictions);
    private static DynamicMetaObject GetTargetAsEnumerable(DynamicMetaObject target);
    private DynamicMetaObject InvokeWhereOnCollection(DynamicMetaObject target, DynamicMetaObject[] args, BindingRestrictions argRestrictions);
    private DynamicMetaObject InvokeForEachOnCollection(DynamicMetaObject targetEnumerator, DynamicMetaObject[] args, BindingRestrictions restrictions);
    internal static bool IsHomogeneousArray(Object[] args);
    internal static bool IsHeterogeneousArray(Object[] args);
    internal static object InvokeAdaptedMember(object obj, string methodName, Object[] args);
    internal static object InvokeAdaptedSetMember(object obj, string methodName, Object[] args, object valueToSet);
    internal static bool TryGetInstanceMethod(object value, string memberName, PSMethodInfo& methodInfo);
    internal static void InvalidateCache();
}
internal class System.Management.Automation.Language.PSPipelineResultToBoolBinder : DynamicMetaObjectBinder {
    private static PSPipelineResultToBoolBinder s_binder;
    public Type ReturnType { get; }
    private static PSPipelineResultToBoolBinder();
    internal static PSPipelineResultToBoolBinder Get();
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSPipeWriterBinder : DynamicMetaObjectBinder {
    private static PSPipeWriterBinder s_binder;
    private static PSPipeWriterBinder();
    internal static PSPipeWriterBinder Get();
    public virtual string ToString();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    private static void BoolRule(CallSite site, object obj, Pipe pipe, ExecutionContext context);
    private static void IntRule(CallSite site, object obj, Pipe pipe, ExecutionContext context);
    private static void StringRule(CallSite site, object obj, Pipe pipe, ExecutionContext context);
    private static void AutomationNullRule(CallSite site, object obj, Pipe pipe, ExecutionContext context);
}
internal class System.Management.Automation.Language.PSSetDynamicMemberBinder : DynamicMetaObjectBinder {
    private static Dictionary`2<Tuple`2<Type, bool>, PSSetDynamicMemberBinder> s_binderCache;
    private bool _static;
    private Type _classScope;
    private PSSetDynamicMemberBinder(Type classScope, bool static);
    private static PSSetDynamicMemberBinder();
    internal static PSSetDynamicMemberBinder Get(TypeDefinitionAst classScope, bool static);
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSSetIndexBinder : SetIndexBinder {
    private static Dictionary`2<Tuple`2<CallInfo, PSMethodInvocationConstraints>, PSSetIndexBinder> s_binderCache;
    private PSMethodInvocationConstraints _constraints;
    internal int _version;
    private PSSetIndexBinder(Tuple`2<CallInfo, PSMethodInvocationConstraints> tuple);
    private static PSSetIndexBinder();
    public static PSSetIndexBinder Get(int argCount, PSMethodInvocationConstraints constraints);
    public virtual string ToString();
    internal static void InvalidateCache();
    public virtual DynamicMetaObject FallbackSetIndex(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject CannotIndexTarget(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value);
    private DynamicMetaObject InvokeIndexer(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion, string methodName);
    private DynamicMetaObject IndexWithNegativeChecks(DynamicMetaObject target, DynamicMetaObject index, DynamicMetaObject value, PropertyInfo lengthProperty, Func`4<Expression, Expression, Expression, Expression> generateIndexOperation);
    private DynamicMetaObject SetIndexArray(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject SetIndexMultiDimensionArray(DynamicMetaObject target, DynamicMetaObject[] indexes, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.Language.PSSetMemberBinder : SetMemberBinder {
    private static Dictionary`2<Tuple`3<string, Type, bool>, PSSetMemberBinder> s_binderCache;
    private bool _static;
    private Type _classScope;
    private PSGetMemberBinder _getMemberBinder;
    public PSSetMemberBinder(string name, bool ignoreCase, bool static, Type classScope);
    private static PSSetMemberBinder();
    public static PSSetMemberBinder Get(string memberName, TypeDefinitionAst classScopeAst, bool static);
    public static PSSetMemberBinder Get(string memberName, Type classScope, bool static);
    public virtual string ToString();
    private static Expression GetTransformedExpression(IEnumerable`1<ArgumentTransformationAttribute> transformationAttributes, Expression originalExpression);
    public virtual DynamicMetaObject FallbackSetMember(DynamicMetaObject target, DynamicMetaObject value, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject GeneratePropertyAssignmentException(BindingRestrictions restrictions);
    internal static object SetAdaptedValue(object obj, string member, object value);
    internal static void InvalidateCache();
}
internal class System.Management.Automation.Language.PSSwitchClauseEvalBinder : DynamicMetaObjectBinder {
    private static PSSwitchClauseEvalBinder[] s_binderCache;
    private SwitchFlags _flags;
    public Type ReturnType { get; }
    private PSSwitchClauseEvalBinder(SwitchFlags flags);
    private static PSSwitchClauseEvalBinder();
    internal static PSSwitchClauseEvalBinder Get(SwitchFlags flags);
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSToObjectArrayBinder : DynamicMetaObjectBinder {
    private static PSToObjectArrayBinder s_binder;
    public Type ReturnType { get; }
    private static PSToObjectArrayBinder();
    internal static PSToObjectArrayBinder Get();
    public virtual string ToString();
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
}
internal class System.Management.Automation.Language.PSToStringBinder : DynamicMetaObjectBinder {
    private static PSToStringBinder s_binder;
    public Type ReturnType { get; }
    private static PSToStringBinder();
    internal static PSToStringBinder Get();
    public virtual Type get_ReturnType();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    internal static Expression InvokeToString(Expression context, Expression target);
}
internal class System.Management.Automation.Language.PSUnaryOperationBinder : UnaryOperationBinder {
    private static PSUnaryOperationBinder s_notBinder;
    private static PSUnaryOperationBinder s_bnotBinder;
    private static PSUnaryOperationBinder s_unaryMinus;
    private static PSUnaryOperationBinder s_unaryPlusBinder;
    private static PSUnaryOperationBinder s_incrementBinder;
    private static PSUnaryOperationBinder s_decrementBinder;
    private PSUnaryOperationBinder(ExpressionType operation);
    internal static PSUnaryOperationBinder Get(ExpressionType operation);
    public virtual DynamicMetaObject FallbackUnaryOperation(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    public virtual string ToString();
    internal DynamicMetaObject Not(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    internal DynamicMetaObject BNot(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject UnaryPlus(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject UnaryMinus(DynamicMetaObject target, DynamicMetaObject errorSuggestion);
    private DynamicMetaObject IncrDecr(DynamicMetaObject target, int valueToAdd, DynamicMetaObject errorSuggestion);
}
internal class System.Management.Automation.Language.PSVariableAssignmentBinder : DynamicMetaObjectBinder {
    private static PSVariableAssignmentBinder s_binder;
    internal static int s_mutableValueWithInstanceMemberVersion;
    private static ConcurrentDictionary`2<Type, bool> s_mutableValueTypesWithInstanceMembers;
    private static PSVariableAssignmentBinder();
    internal static PSVariableAssignmentBinder Get();
    public virtual DynamicMetaObject Bind(DynamicMetaObject target, DynamicMetaObject[] args);
    private static Expression GetExprForValueType(Type type, Expression convertedExpr, Expression originalExpr, BindingRestrictions& restrictions);
    private static object EnumRule(CallSite site, object obj);
    private static object BoolRule(CallSite site, object obj);
    private static object IntRule(CallSite site, object obj);
    private static object ObjectRule(CallSite site, object obj);
    private static object PSObjectStringRule(CallSite site, object obj);
    private static object NullRule(CallSite site, object obj);
    internal static bool IsValueTypeMutable(Type type);
    internal static void NoteTypeHasInstanceMemberOrTypeName(Type type);
    internal static object CopyInstanceMembersOfValueType(T t, object boxedT);
    internal static BindingRestrictions GetVersionCheck(int expectedVersionNumber);
}
public abstract class System.Management.Automation.Language.RedirectionAst : Ast {
    [CompilerGeneratedAttribute]
private RedirectionStream <FromStream>k__BackingField;
    public RedirectionStream FromStream { get; }
    protected RedirectionAst(IScriptExtent extent, RedirectionStream from);
    [CompilerGeneratedAttribute]
public RedirectionStream get_FromStream();
}
public enum System.Management.Automation.Language.RedirectionStream : Enum {
    public int value__;
    public static RedirectionStream All;
    public static RedirectionStream Output;
    public static RedirectionStream Error;
    public static RedirectionStream Warning;
    public static RedirectionStream Verbose;
    public static RedirectionStream Debug;
    public static RedirectionStream Information;
}
public abstract class System.Management.Automation.Language.RedirectionToken : Token {
    internal RedirectionToken(InternalScriptExtent scriptExtent, TokenKind kind);
}
public class System.Management.Automation.Language.ReflectionTypeName : object {
    private Type _type;
    public string FullName { get; }
    public string Name { get; }
    public string AssemblyName { get; }
    public bool IsArray { get; }
    public bool IsGeneric { get; }
    public IScriptExtent Extent { get; }
    private Type System.Management.Automation.Language.ISupportsTypeCaching.CachedType { get; private set; }
    public ReflectionTypeName(Type type);
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    public sealed virtual string get_AssemblyName();
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual IScriptExtent get_Extent();
    public sealed virtual Type GetReflectionType();
    public sealed virtual Type GetReflectionAttributeType();
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private sealed virtual override Type System.Management.Automation.Language.ISupportsTypeCaching.get_CachedType();
    private sealed virtual override void System.Management.Automation.Language.ISupportsTypeCaching.set_CachedType(Type value);
}
internal class System.Management.Automation.Language.RestrictedLanguageChecker : AstVisitor {
    private Parser _parser;
    private IEnumerable`1<string> _allowedCommands;
    private IEnumerable`1<string> _allowedVariables;
    private bool _allVariablesAreAllowed;
    private bool _allowEnvironmentVariables;
    [CompilerGeneratedAttribute]
private bool <FoundError>k__BackingField;
    private static HashSet`1<string> s_defaultAllowedVariables;
    private bool FoundError { get; private set; }
    internal RestrictedLanguageChecker(Parser parser, IEnumerable`1<string> allowedCommands, IEnumerable`1<string> allowedVariables, bool allowEnvironmentVariables);
    private static RestrictedLanguageChecker();
    [CompilerGeneratedAttribute]
private bool get_FoundError();
    [CompilerGeneratedAttribute]
private void set_FoundError(bool value);
    internal static void CheckDataStatementLanguageModeAtRuntime(DataStatementAst dataStatementAst, ExecutionContext executionContext);
    internal static void CheckDataStatementAstAtRuntime(DataStatementAst dataStatementAst, String[] allowedCommands);
    internal static void EnsureUtilityModuleLoaded(ExecutionContext context);
    private void ReportError(Ast ast, string errorId, string errorMsg, Object[] args);
    private void ReportError(IScriptExtent extent, string errorId, string errorMsg, Object[] args);
    public virtual AstVisitAction VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public virtual AstVisitAction VisitParamBlock(ParamBlockAst paramBlockAst);
    public virtual AstVisitAction VisitNamedBlock(NamedBlockAst namedBlockAst);
    private void CheckTypeName(Ast ast, ITypeName typename);
    public virtual AstVisitAction VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public virtual AstVisitAction VisitAttribute(AttributeAst attributeAst);
    public virtual AstVisitAction VisitParameter(ParameterAst parameterAst);
    public virtual AstVisitAction VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitStatementBlock(StatementBlockAst statementBlockAst);
    public virtual AstVisitAction VisitIfStatement(IfStatementAst ifStmtAst);
    public virtual AstVisitAction VisitTrap(TrapStatementAst trapStatementAst);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual AstVisitAction VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public virtual AstVisitAction VisitForStatement(ForStatementAst forStatementAst);
    public virtual AstVisitAction VisitWhileStatement(WhileStatementAst whileStatementAst);
    public virtual AstVisitAction VisitCatchClause(CatchClauseAst catchClauseAst);
    public virtual AstVisitAction VisitTryStatement(TryStatementAst tryStatementAst);
    public virtual AstVisitAction VisitBreakStatement(BreakStatementAst breakStatementAst);
    public virtual AstVisitAction VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public virtual AstVisitAction VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public virtual AstVisitAction VisitExitStatement(ExitStatementAst exitStatementAst);
    public virtual AstVisitAction VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public virtual AstVisitAction VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual AstVisitAction VisitPipeline(PipelineAst pipelineAst);
    public virtual AstVisitAction VisitCommand(CommandAst commandAst);
    public virtual AstVisitAction VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public virtual AstVisitAction VisitCommandParameter(CommandParameterAst commandParameterAst);
    public virtual AstVisitAction VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public virtual AstVisitAction VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public virtual AstVisitAction VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public virtual AstVisitAction VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public virtual AstVisitAction VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public virtual AstVisitAction VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public virtual AstVisitAction VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public virtual AstVisitAction VisitSubExpression(SubExpressionAst subExpressionAst);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual AstVisitAction VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public virtual AstVisitAction VisitInvokeMemberExpression(InvokeMemberExpressionAst methodCallAst);
    public virtual AstVisitAction VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public virtual AstVisitAction VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public virtual AstVisitAction VisitHashtable(HashtableAst hashtableAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public virtual AstVisitAction VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public virtual AstVisitAction VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public virtual AstVisitAction VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public virtual AstVisitAction VisitBlockStatement(BlockStatementAst blockStatementAst);
    public virtual AstVisitAction VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
}
public class System.Management.Automation.Language.ReturnStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Pipeline>k__BackingField;
    public PipelineBaseAst Pipeline { get; }
    public ReturnStatementAst(IScriptExtent extent, PipelineBaseAst pipeline);
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Pipeline();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.Scope : object {
    internal Ast _ast;
    internal ScopeType _scopeType;
    private Dictionary`2<string, TypeLookupResult> _typeTable;
    private Dictionary`2<string, Ast> _variableTable;
    internal Scope(IParameterMetadataProvider ast, ScopeType scopeType);
    internal Scope(TypeDefinitionAst typeDefinition);
    internal void AddType(Parser parser, TypeDefinitionAst typeDefinitionAst);
    internal void AddTypeFromUsingModule(Parser parser, TypeDefinitionAst typeDefinitionAst, PSModuleInfo moduleInfo);
    internal TypeLookupResult LookupType(TypeName typeName);
    public Ast LookupVariable(VariablePath variablePath);
}
internal enum System.Management.Automation.Language.ScopeType : Enum {
    public int value__;
    public static ScopeType Type;
    public static ScopeType Method;
    public static ScopeType Function;
    public static ScopeType ScriptBlock;
}
public class System.Management.Automation.Language.ScriptBlockAst : Ast {
    private static ReadOnlyCollection`1<AttributeAst> s_emptyAttributeList;
    private static ReadOnlyCollection`1<UsingStatementAst> s_emptyUsingStatementList;
    [CompilerGeneratedAttribute]
private bool <HadErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PostParseChecksPerformed>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<UsingStatementAst> <UsingStatements>k__BackingField;
    [CompilerGeneratedAttribute]
private ParamBlockAst <ParamBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedBlockAst <BeginBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedBlockAst <ProcessBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedBlockAst <EndBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedBlockAst <CleanBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedBlockAst <DynamicParamBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptRequirements <ScriptRequirements>k__BackingField;
    internal bool HadErrors { get; internal set; }
    internal bool IsConfiguration { get; private set; }
    internal bool PostParseChecksPerformed { get; internal set; }
    public ReadOnlyCollection`1<AttributeAst> Attributes { get; }
    public ReadOnlyCollection`1<UsingStatementAst> UsingStatements { get; private set; }
    public ParamBlockAst ParamBlock { get; }
    public NamedBlockAst BeginBlock { get; }
    public NamedBlockAst ProcessBlock { get; }
    public NamedBlockAst EndBlock { get; }
    public NamedBlockAst CleanBlock { get; }
    public NamedBlockAst DynamicParamBlock { get; }
    public ScriptRequirements ScriptRequirements { get; internal set; }
    private ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.Parameters { get; }
    private ScriptBlockAst System.Management.Automation.Language.IParameterMetadataProvider.Body { get; }
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, IEnumerable`1<AttributeAst> attributes, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, IEnumerable`1<AttributeAst> attributes, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst cleanBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst cleanBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, ParamBlockAst paramBlock, NamedBlockAst beginBlock, NamedBlockAst processBlock, NamedBlockAst endBlock, NamedBlockAst cleanBlock, NamedBlockAst dynamicParamBlock);
    public ScriptBlockAst(IScriptExtent extent, List`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter);
    public ScriptBlockAst(IScriptExtent extent, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter);
    public ScriptBlockAst(IScriptExtent extent, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter, bool isConfiguration);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter, bool isConfiguration);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<AttributeAst> attributes, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter, bool isConfiguration);
    public ScriptBlockAst(IScriptExtent extent, IEnumerable`1<UsingStatementAst> usingStatements, IEnumerable`1<AttributeAst> attributes, ParamBlockAst paramBlock, StatementBlockAst statements, bool isFilter, bool isConfiguration);
    private static ScriptBlockAst();
    [CompilerGeneratedAttribute]
internal bool get_HadErrors();
    [CompilerGeneratedAttribute]
internal void set_HadErrors(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsConfiguration();
    [CompilerGeneratedAttribute]
private void set_IsConfiguration(bool value);
    [CompilerGeneratedAttribute]
internal bool get_PostParseChecksPerformed();
    [CompilerGeneratedAttribute]
internal void set_PostParseChecksPerformed(bool value);
    private void SetUsingStatements(IEnumerable`1<UsingStatementAst> usingStatements);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeAst> get_Attributes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<UsingStatementAst> get_UsingStatements();
    [CompilerGeneratedAttribute]
private void set_UsingStatements(ReadOnlyCollection`1<UsingStatementAst> value);
    [CompilerGeneratedAttribute]
public ParamBlockAst get_ParamBlock();
    [CompilerGeneratedAttribute]
public NamedBlockAst get_BeginBlock();
    [CompilerGeneratedAttribute]
public NamedBlockAst get_ProcessBlock();
    [CompilerGeneratedAttribute]
public NamedBlockAst get_EndBlock();
    [CompilerGeneratedAttribute]
public NamedBlockAst get_CleanBlock();
    [CompilerGeneratedAttribute]
public NamedBlockAst get_DynamicParamBlock();
    [CompilerGeneratedAttribute]
public ScriptRequirements get_ScriptRequirements();
    [CompilerGeneratedAttribute]
internal void set_ScriptRequirements(ScriptRequirements value);
    public CommentHelpInfo GetHelpContent();
    public ScriptBlock GetScriptBlock();
    private ScriptBlockAst GetRootScriptBlockAst();
    public virtual Ast Copy();
    internal string ToStringForSerialization();
    internal string ToStringForSerialization(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple, int initialStartOffset, int initialEndOffset);
    internal void PerformPostParseChecks(Parser parser);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.HasAnyScriptBlockAttributes();
    private sealed virtual override RuntimeDefinedParameterDictionary System.Management.Automation.Language.IParameterMetadataProvider.GetParameterMetadata(bool automaticPositions, Boolean& usesCmdletBinding);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.ScriptBlockAst/<System-Management-Automation-Language-IParameterMetadataProvider-GetScriptBlockAttributes>d__67")]
private sealed virtual override IEnumerable`1<Attribute> System.Management.Automation.Language.IParameterMetadataProvider.GetScriptBlockAttributes();
    [IteratorStateMachineAttribute("System.Management.Automation.Language.ScriptBlockAst/<System-Management-Automation-Language-IParameterMetadataProvider-GetExperimentalAttributes>d__68")]
private sealed virtual override IEnumerable`1<ExperimentalAttribute> System.Management.Automation.Language.IParameterMetadataProvider.GetExperimentalAttributes();
    private sealed virtual override ReadOnlyCollection`1<ParameterAst> System.Management.Automation.Language.IParameterMetadataProvider.get_Parameters();
    private sealed virtual override ScriptBlockAst System.Management.Automation.Language.IParameterMetadataProvider.get_Body();
    private sealed virtual override PowerShell System.Management.Automation.Language.IParameterMetadataProvider.GetPowerShell(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    private sealed virtual override string System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommand();
    private sealed virtual override Tuple`2<string, string> System.Management.Automation.Language.IParameterMetadataProvider.GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    private string GetWithInputHandlingForInvokeCommandImpl(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    private sealed virtual override bool System.Management.Automation.Language.IParameterMetadataProvider.UsesCmdletBinding();
    internal PipelineAst GetSimplePipeline(bool allowMultiplePipelines, String& errorId, String& errorMsg);
    [CompilerGeneratedAttribute]
internal static bool <InternalVisit>g__VisitAndShallContinue|64_0(Ast ast, <>c__DisplayClass64_0& );
    [CompilerGeneratedAttribute]
internal static ExperimentalAttribute <System.Management.Automation.Language.IParameterMetadataProvider.GetExperimentalAttributes>g__GetExpAttributeHelper|68_0(AttributeAst attributeAst);
}
public class System.Management.Automation.Language.ScriptBlockExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ScriptBlockAst <ScriptBlock>k__BackingField;
    public ScriptBlockAst ScriptBlock { get; }
    public Type StaticType { get; }
    public ScriptBlockExpressionAst(IScriptExtent extent, ScriptBlockAst scriptBlock);
    [CompilerGeneratedAttribute]
public ScriptBlockAst get_ScriptBlock();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ScriptExtent : object {
    private ScriptPosition _startPosition;
    private ScriptPosition _endPosition;
    public string File { get; }
    public IScriptPosition StartScriptPosition { get; }
    public IScriptPosition EndScriptPosition { get; }
    public int StartLineNumber { get; }
    public int StartColumnNumber { get; }
    public int EndLineNumber { get; }
    public int EndColumnNumber { get; }
    public int StartOffset { get; }
    public int EndOffset { get; }
    public string Text { get; }
    public ScriptExtent(ScriptPosition startPosition, ScriptPosition endPosition);
    public sealed virtual string get_File();
    public sealed virtual IScriptPosition get_StartScriptPosition();
    public sealed virtual IScriptPosition get_EndScriptPosition();
    public sealed virtual int get_StartLineNumber();
    public sealed virtual int get_StartColumnNumber();
    public sealed virtual int get_EndLineNumber();
    public sealed virtual int get_EndColumnNumber();
    public sealed virtual int get_StartOffset();
    public sealed virtual int get_EndOffset();
    public sealed virtual string get_Text();
    internal void ToPSObjectForRemoting(PSObject dest);
    private void PopulateFromSerializedInfo(PSObject serializedScriptExtent);
    internal static ScriptExtent FromPSObjectForRemoting(PSObject serializedScriptExtent);
    [CompilerGeneratedAttribute]
private string <ToPSObjectForRemoting>b__24_0();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__24_1();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__24_2();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__24_3();
    [CompilerGeneratedAttribute]
private int <ToPSObjectForRemoting>b__24_4();
}
public class System.Management.Automation.Language.ScriptPosition : object {
    private string _fullScript;
    [CompilerGeneratedAttribute]
private string <File>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LineNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ColumnNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Line>k__BackingField;
    public string File { get; }
    public int LineNumber { get; }
    public int ColumnNumber { get; }
    public int Offset { get; }
    public string Line { get; }
    public ScriptPosition(string scriptName, int scriptLineNumber, int offsetInLine, string line);
    public ScriptPosition(string scriptName, int scriptLineNumber, int offsetInLine, string line, string fullScript);
    [CompilerGeneratedAttribute]
public sealed virtual string get_File();
    [CompilerGeneratedAttribute]
public sealed virtual int get_LineNumber();
    [CompilerGeneratedAttribute]
public sealed virtual int get_ColumnNumber();
    public sealed virtual int get_Offset();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Line();
    public sealed virtual string GetFullScript();
}
public class System.Management.Automation.Language.ScriptRequirements : object {
    internal static ReadOnlyCollection`1<PSSnapInSpecification> EmptySnapinCollection;
    internal static ReadOnlyCollection`1<string> EmptyAssemblyCollection;
    internal static ReadOnlyCollection`1<ModuleSpecification> EmptyModuleCollection;
    internal static ReadOnlyCollection`1<string> EmptyEditionCollection;
    [CompilerGeneratedAttribute]
private string <RequiredApplicationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <RequiredPSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <RequiredPSEditions>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<ModuleSpecification> <RequiredModules>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <RequiredAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsElevationRequired>k__BackingField;
    public string RequiredApplicationId { get; internal set; }
    public Version RequiredPSVersion { get; internal set; }
    public ReadOnlyCollection`1<string> RequiredPSEditions { get; internal set; }
    public ReadOnlyCollection`1<ModuleSpecification> RequiredModules { get; internal set; }
    public ReadOnlyCollection`1<string> RequiredAssemblies { get; internal set; }
    public bool IsElevationRequired { get; internal set; }
    private static ScriptRequirements();
    [CompilerGeneratedAttribute]
public string get_RequiredApplicationId();
    [CompilerGeneratedAttribute]
internal void set_RequiredApplicationId(string value);
    [CompilerGeneratedAttribute]
public Version get_RequiredPSVersion();
    [CompilerGeneratedAttribute]
internal void set_RequiredPSVersion(Version value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_RequiredPSEditions();
    [CompilerGeneratedAttribute]
internal void set_RequiredPSEditions(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<ModuleSpecification> get_RequiredModules();
    [CompilerGeneratedAttribute]
internal void set_RequiredModules(ReadOnlyCollection`1<ModuleSpecification> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_RequiredAssemblies();
    [CompilerGeneratedAttribute]
internal void set_RequiredAssemblies(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_IsElevationRequired();
    [CompilerGeneratedAttribute]
internal void set_IsElevationRequired(bool value);
}
internal class System.Management.Automation.Language.SemanticChecks : AstVisitor2 {
    private Parser _parser;
    private static IsConstantValueVisitor s_isConstantAttributeArgVisitor;
    private static IsConstantValueVisitor s_isConstantAttributeArgForClassVisitor;
    private Stack`1<MemberAst> _memberScopeStack;
    private Stack`1<ScriptBlockAst> _scopeStack;
    private SemanticChecks(Parser parser);
    private static SemanticChecks();
    internal static void CheckAst(Parser parser, ScriptBlockAst ast);
    private bool AnalyzingStaticMember();
    private static bool IsValidAttributeArgument(Ast ast, IsConstantValueVisitor visitor);
    private static ValueTuple`2<string, string> GetNonConstantAttributeArgErrorExpr(IsConstantValueVisitor visitor);
    private void CheckForDuplicateParameters(ReadOnlyCollection`1<ParameterAst> parameters);
    public virtual AstVisitAction VisitParamBlock(ParamBlockAst paramBlockAst);
    public virtual AstVisitAction VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public virtual AstVisitAction VisitAttribute(AttributeAst attributeAst);
    private static string GetValidNamedAttributeProperties(Type attributeType);
    public virtual AstVisitAction VisitParameter(ParameterAst parameterAst);
    public virtual AstVisitAction VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    internal static void CheckArrayTypeNameDepth(ITypeName typeName, IScriptExtent extent, Parser parser);
    public virtual AstVisitAction VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual AstVisitAction VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.SemanticChecks/<GetConstantDataStatementAllowedCommands>d__22")]
private static IEnumerable`1<string> GetConstantDataStatementAllowedCommands(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitDataStatement(DataStatementAst dataStatementAst);
    public virtual AstVisitAction VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public virtual AstVisitAction VisitTryStatement(TryStatementAst tryStatementAst);
    private void CheckLabelExists(StatementAst ast, string label);
    private void CheckForFlowOutOfFinally(Ast ast, string label);
    private static string GetLabel(ExpressionAst expr);
    public virtual AstVisitAction VisitBreakStatement(BreakStatementAst breakStatementAst);
    public virtual AstVisitAction VisitContinueStatement(ContinueStatementAst continueStatementAst);
    private void CheckForReturnStatement(ReturnStatementAst ast);
    public virtual AstVisitAction VisitReturnStatement(ReturnStatementAst returnStatementAst);
    private void CheckAssignmentTarget(ExpressionAst ast, bool simpleAssignment, Action`1<Ast> reportError);
    private void CheckArrayLiteralAssignment(ArrayLiteralAst ast, Action`1<Ast> reportError);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual AstVisitAction VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public virtual AstVisitAction VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public virtual AstVisitAction VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    private static ExpressionAst CheckUsingExpression(ExpressionAst exprAst);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual AstVisitAction VisitHashtable(HashtableAst hashtableAst);
    public virtual AstVisitAction VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public virtual AstVisitAction VisitBlockStatement(BlockStatementAst blockStatementAst);
    public virtual AstVisitAction VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public virtual AstVisitAction VisitInvokeMemberExpression(InvokeMemberExpressionAst memberExpressionAst);
    private static void CheckMemberAccess(MemberExpressionAst ast);
    private static void MarkAstParentsAsSuspicious(Ast ast);
    public virtual AstVisitAction VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitUsingStatement(UsingStatementAst usingStatementAst);
    public virtual AstVisitAction VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public virtual AstVisitAction VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordStatementAst);
    public virtual AstVisitAction VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual void PostVisit(Ast ast);
    [CompilerGeneratedAttribute]
private void <VisitAssignmentStatement>b__35_0(Ast ast);
    [CompilerGeneratedAttribute]
private void <VisitDynamicKeywordStatement>b__53_0(ParseError e);
}
internal class System.Management.Automation.Language.SequencePointAst : Ast {
    public SequencePointAst(IScriptExtent extent);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal static class System.Management.Automation.Language.SpecialChars : object {
    internal static char NoBreakSpace;
    internal static char NextLine;
    internal static char EnDash;
    internal static char EmDash;
    internal static char HorizontalBar;
    internal static char QuoteSingleLeft;
    internal static char QuoteSingleRight;
    internal static char QuoteSingleBase;
    internal static char QuoteReversed;
    internal static char QuoteDoubleLeft;
    internal static char QuoteDoubleRight;
    internal static char QuoteLowDoubleLeft;
}
internal enum System.Management.Automation.Language.SpecialMemberFunctionType : Enum {
    public int value__;
    public static SpecialMemberFunctionType None;
    public static SpecialMemberFunctionType DefaultConstructor;
    public static SpecialMemberFunctionType StaticConstructor;
}
public abstract class System.Management.Automation.Language.StatementAst : Ast {
    protected StatementAst(IScriptExtent extent);
}
public class System.Management.Automation.Language.StatementBlockAst : Ast {
    private static ReadOnlyCollection`1<StatementAst> s_emptyStatementCollection;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<StatementAst> <Statements>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TrapStatementAst> <Traps>k__BackingField;
    public ReadOnlyCollection`1<StatementAst> Statements { get; }
    public ReadOnlyCollection`1<TrapStatementAst> Traps { get; }
    public StatementBlockAst(IScriptExtent extent, IEnumerable`1<StatementAst> statements, IEnumerable`1<TrapStatementAst> traps);
    private static StatementBlockAst();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<StatementAst> get_Statements();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TrapStatementAst> get_Traps();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal static AstVisitAction InternalVisit(AstVisitor visitor, ReadOnlyCollection`1<TrapStatementAst> traps, ReadOnlyCollection`1<StatementAst> statements, AstVisitAction action);
}
public class System.Management.Automation.Language.StaticBindingError : object {
    [CompilerGeneratedAttribute]
private CommandElementAst <CommandElement>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterBindingException <BindingException>k__BackingField;
    public CommandElementAst CommandElement { get; }
    public ParameterBindingException BindingException { get; }
    internal StaticBindingError(CommandElementAst commandElement, ParameterBindingException exception);
    [CompilerGeneratedAttribute]
public CommandElementAst get_CommandElement();
    [CompilerGeneratedAttribute]
public ParameterBindingException get_BindingException();
}
public class System.Management.Automation.Language.StaticBindingResult : object {
    private PseudoBindingInfo _bindingInfo;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, ParameterBindingResult> <BoundParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, StaticBindingError> <BindingExceptions>k__BackingField;
    public Dictionary`2<string, ParameterBindingResult> BoundParameters { get; }
    public Dictionary`2<string, StaticBindingError> BindingExceptions { get; }
    internal StaticBindingResult(CommandAst commandAst, PseudoBindingInfo bindingInfo);
    private void CreateBindingResultForSuccessfulBind(CommandAst commandAst, PseudoBindingInfo bindingInfo);
    private void AddDuplicateParameterBindingException(CommandParameterAst duplicateParameter);
    private void CreateBindingResultForSyntacticBind(CommandAst commandAst);
    private void AddBoundParameter(CommandParameterAst parameter, string parameterName, ParameterBindingResult bindingResult);
    private static void ResetCurrentParameter(CommandParameterAst& currentParameter, ParameterBindingResult& bindingResult);
    private void AddSwitch(string currentParameter, ParameterBindingResult bindingResult);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, ParameterBindingResult> get_BoundParameters();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, StaticBindingError> get_BindingExceptions();
}
public static class System.Management.Automation.Language.StaticParameterBinder : object {
    [ThreadStaticAttribute]
private static Runspace t_bindCommandRunspace;
    public static StaticBindingResult BindCommand(CommandAst commandAst);
    public static StaticBindingResult BindCommand(CommandAst commandAst, bool resolve);
    public static StaticBindingResult BindCommand(CommandAst commandAst, bool resolve, String[] desiredParameters);
}
public class System.Management.Automation.Language.StringConstantExpressionAst : ConstantExpressionAst {
    [CompilerGeneratedAttribute]
private StringConstantType <StringConstantType>k__BackingField;
    public StringConstantType StringConstantType { get; }
    public string Value { get; }
    public Type StaticType { get; }
    public StringConstantExpressionAst(IScriptExtent extent, string value, StringConstantType stringConstantType);
    internal StringConstantExpressionAst(StringToken token);
    [CompilerGeneratedAttribute]
public StringConstantType get_StringConstantType();
    public string get_Value();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal static StringConstantType MapTokenKindToStringConstantKind(Token token);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public enum System.Management.Automation.Language.StringConstantType : Enum {
    public int value__;
    public static StringConstantType SingleQuoted;
    public static StringConstantType SingleQuotedHereString;
    public static StringConstantType DoubleQuoted;
    public static StringConstantType DoubleQuotedHereString;
    public static StringConstantType BareWord;
}
public class System.Management.Automation.Language.StringExpandableToken : StringToken {
    private ReadOnlyCollection`1<Token> _nestedTokens;
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    public ReadOnlyCollection`1<Token> NestedTokens { get; internal set; }
    internal string FormatString { get; }
    internal StringExpandableToken(InternalScriptExtent scriptExtent, TokenKind tokenKind, string value, string formatString, List`1<Token> nestedTokens, TokenFlags flags);
    internal static void ToDebugString(ReadOnlyCollection`1<Token> nestedTokens, StringBuilder sb, int indent);
    public ReadOnlyCollection`1<Token> get_NestedTokens();
    internal void set_NestedTokens(ReadOnlyCollection`1<Token> value);
    [CompilerGeneratedAttribute]
internal string get_FormatString();
    internal virtual string ToDebugString(int indent);
}
public class System.Management.Automation.Language.StringLiteralToken : StringToken {
    internal StringLiteralToken(InternalScriptExtent scriptExtent, TokenFlags flags, TokenKind tokenKind, string value);
}
public abstract class System.Management.Automation.Language.StringToken : Token {
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    internal StringToken(InternalScriptExtent scriptExtent, TokenKind kind, TokenFlags tokenFlags, string value);
    [CompilerGeneratedAttribute]
public string get_Value();
    internal virtual string ToDebugString(int indent);
}
public class System.Management.Automation.Language.SubExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private StatementBlockAst <SubExpression>k__BackingField;
    public StatementBlockAst SubExpression { get; }
    public SubExpressionAst(IScriptExtent extent, StatementBlockAst statementBlock);
    [CompilerGeneratedAttribute]
public StatementBlockAst get_SubExpression();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
[FlagsAttribute]
public enum System.Management.Automation.Language.SwitchFlags : Enum {
    public int value__;
    public static SwitchFlags None;
    public static SwitchFlags File;
    public static SwitchFlags Regex;
    public static SwitchFlags Wildcard;
    public static SwitchFlags Exact;
    public static SwitchFlags CaseSensitive;
    public static SwitchFlags Parallel;
}
internal class System.Management.Automation.Language.SwitchPair : AstParameterArgumentPair {
    public bool Argument { get; }
    internal SwitchPair(CommandParameterAst parameterAst);
    public bool get_Argument();
}
public class System.Management.Automation.Language.SwitchStatementAst : LabeledStatementAst {
    private static Tuple`2[] s_emptyClauseArray;
    [CompilerGeneratedAttribute]
private SwitchFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementBlockAst>> <Clauses>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Default>k__BackingField;
    public SwitchFlags Flags { get; }
    public ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementBlockAst>> Clauses { get; }
    public StatementBlockAst Default { get; }
    public SwitchStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition, SwitchFlags flags, IEnumerable`1<Tuple`2<ExpressionAst, StatementBlockAst>> clauses, StatementBlockAst default);
    private static SwitchStatementAst();
    [CompilerGeneratedAttribute]
public SwitchFlags get_Flags();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<Tuple`2<ExpressionAst, StatementBlockAst>> get_Clauses();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Default();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.SymbolResolvePostActionVisitor : DefaultCustomAstVisitor2 {
    internal SymbolResolver _symbolResolver;
    public virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
}
internal class System.Management.Automation.Language.SymbolResolver : AstVisitor2 {
    private SymbolResolvePostActionVisitor _symbolResolvePostActionVisitor;
    internal SymbolTable _symbolTable;
    internal Parser _parser;
    internal TypeResolutionState _typeResolutionState;
    [ThreadStaticAttribute]
private static PowerShell t_usingStatementResolvePowerShell;
    private static PowerShell UsingStatementResolvePowerShell { get; }
    private SymbolResolver(Parser parser, TypeResolutionState typeResolutionState);
    private static PowerShell get_UsingStatementResolvePowerShell();
    internal static void ResolveSymbols(Parser parser, ScriptBlockAst scriptBlockAst);
    public virtual AstVisitAction VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public virtual AstVisitAction VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public virtual AstVisitAction VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public virtual AstVisitAction VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public virtual AstVisitAction VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public virtual AstVisitAction VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    private Collection`1<PSModuleInfo> GetModulesFromUsingModule(UsingStatementAst usingStatementAst, Exception& exception, Boolean& wildcardCharactersUsed, Boolean& isConstant);
    public virtual AstVisitAction VisitUsingStatement(UsingStatementAst usingStatementAst);
    public virtual AstVisitAction VisitAttribute(AttributeAst attributeAst);
    private bool DispatchTypeName(ITypeName type, int genericArgumentCount, bool isAttribute);
    private bool VisitArrayTypeName(ArrayTypeName arrayTypeName);
    private bool VisitTypeName(TypeName typeName, int genericArgumentCount, bool isAttribute);
    private bool VisitGenericTypeName(GenericTypeName genericTypeName);
    public sealed virtual void PostVisit(Ast ast);
    internal static string GetModuleQualifiedName(string namespaceName, string typeName);
}
internal class System.Management.Automation.Language.SymbolTable : object {
    internal List`1<Scope> _scopes;
    internal Parser _parser;
    internal SymbolTable(Parser parser);
    internal void AddTypesInScope(Ast ast);
    internal void EnterScope(IParameterMetadataProvider ast, ScopeType scopeType);
    internal void EnterScope(TypeDefinitionAst typeDefinition);
    internal void LeaveScope();
    public void AddType(TypeDefinitionAst typeDefinitionAst);
    public void AddTypeFromUsingModule(TypeDefinitionAst typeDefinitionAst, PSModuleInfo moduleInfo);
    public TypeLookupResult LookupType(TypeName typeName);
    public Ast LookupVariable(VariablePath variablePath);
    public TypeDefinitionAst GetCurrentTypeDefinitionAst();
    public bool IsInMethodScope();
}
public class System.Management.Automation.Language.TernaryExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <Condition>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <IfTrue>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <IfFalse>k__BackingField;
    public ExpressionAst Condition { get; }
    public ExpressionAst IfTrue { get; }
    public ExpressionAst IfFalse { get; }
    public TernaryExpressionAst(IScriptExtent extent, ExpressionAst condition, ExpressionAst ifTrue, ExpressionAst ifFalse);
    [CompilerGeneratedAttribute]
public ExpressionAst get_Condition();
    [CompilerGeneratedAttribute]
public ExpressionAst get_IfTrue();
    [CompilerGeneratedAttribute]
public ExpressionAst get_IfFalse();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.ThrowStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private PipelineBaseAst <Pipeline>k__BackingField;
    public PipelineBaseAst Pipeline { get; }
    public bool IsRethrow { get; }
    public ThrowStatementAst(IScriptExtent extent, PipelineBaseAst pipeline);
    [CompilerGeneratedAttribute]
public PipelineBaseAst get_Pipeline();
    public bool get_IsRethrow();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.Token : object {
    private TokenKind _kind;
    private TokenFlags _tokenFlags;
    private InternalScriptExtent _scriptExtent;
    public string Text { get; }
    public TokenFlags TokenFlags { get; internal set; }
    public TokenKind Kind { get; }
    public bool HasError { get; }
    public IScriptExtent Extent { get; }
    internal Token(InternalScriptExtent scriptExtent, TokenKind kind, TokenFlags tokenFlags);
    internal void SetIsCommandArgument();
    public string get_Text();
    public TokenFlags get_TokenFlags();
    internal void set_TokenFlags(TokenFlags value);
    public TokenKind get_Kind();
    public bool get_HasError();
    public IScriptExtent get_Extent();
    public virtual string ToString();
    internal virtual string ToDebugString(int indent);
}
[FlagsAttribute]
public enum System.Management.Automation.Language.TokenFlags : Enum {
    public int value__;
    public static TokenFlags None;
    public static TokenFlags BinaryPrecedenceLogical;
    public static TokenFlags BinaryPrecedenceBitwise;
    public static TokenFlags BinaryPrecedenceComparison;
    public static TokenFlags BinaryPrecedenceCoalesce;
    public static TokenFlags BinaryPrecedenceAdd;
    public static TokenFlags BinaryPrecedenceMultiply;
    public static TokenFlags BinaryPrecedenceFormat;
    public static TokenFlags BinaryPrecedenceRange;
    public static TokenFlags BinaryPrecedenceMask;
    public static TokenFlags Keyword;
    public static TokenFlags ScriptBlockBlockName;
    public static TokenFlags BinaryOperator;
    public static TokenFlags UnaryOperator;
    public static TokenFlags CaseSensitiveOperator;
    public static TokenFlags TernaryOperator;
    public static TokenFlags SpecialOperator;
    public static TokenFlags AssignmentOperator;
    public static TokenFlags ParseModeInvariant;
    public static TokenFlags TokenInError;
    public static TokenFlags DisallowedInRestrictedMode;
    public static TokenFlags PrefixOrPostfixOperator;
    public static TokenFlags CommandName;
    public static TokenFlags MemberName;
    public static TokenFlags TypeName;
    public static TokenFlags AttributeName;
    public static TokenFlags CanConstantFold;
    public static TokenFlags StatementDoesntSupportAttributes;
}
[DebuggerDisplayAttribute("Mode = {Mode}; Script = {_script}")]
internal class System.Management.Automation.Language.Tokenizer : object {
    private static Dictionary`2<string, TokenKind> s_keywordTable;
    private static Dictionary`2<string, TokenKind> s_operatorTable;
    private static char s_invalidChar;
    private static int s_maxNumberOfUnicodeHexDigits;
    private Parser _parser;
    private PositionHelper _positionHelper;
    private int _nestedTokensAdjustment;
    private BitArray _skippedCharOffsets;
    private string _script;
    private int _tokenStart;
    private int _currentIndex;
    private InternalScriptExtent _beginSignatureExtent;
    private static String[] s_keywordText;
    private static TokenKind[] s_keywordTokenKind;
    internal static String[] _operatorText;
    private static TokenKind[] s_operatorTokenKind;
    [CompilerGeneratedAttribute]
private TokenizerMode <Mode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowSignedNumbers>k__BackingField;
    private bool _forceEndNumberOnTernaryOpChars;
    [CompilerGeneratedAttribute]
private bool <WantSimpleName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InWorkflowContext>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Token> <TokenList>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <FirstToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Token <LastToken>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Token> <RequiresTokens>k__BackingField;
    private Int32[0...,0...] _beginTokenSimilarity2dArray;
    private Queue`1<StringBuilder> _stringBuilders;
    private static string shellIDToken;
    private static string PSSnapinToken;
    private static string versionToken;
    private static string editionToken;
    private static string assemblyToken;
    private static string modulesToken;
    private static string elevationToken;
    internal TokenizerMode Mode { get; internal set; }
    internal bool AllowSignedNumbers { get; internal set; }
    internal bool ForceEndNumberOnTernaryOpChars { get; internal set; }
    internal bool WantSimpleName { get; internal set; }
    internal bool InWorkflowContext { get; internal set; }
    internal List`1<Token> TokenList { get; internal set; }
    internal Token FirstToken { get; private set; }
    internal Token LastToken { get; private set; }
    private List`1<Token> RequiresTokens { get; private set; }
    private static Tokenizer();
    internal Tokenizer(Parser parser);
    [CompilerGeneratedAttribute]
internal TokenizerMode get_Mode();
    [CompilerGeneratedAttribute]
internal void set_Mode(TokenizerMode value);
    [CompilerGeneratedAttribute]
internal bool get_AllowSignedNumbers();
    [CompilerGeneratedAttribute]
internal void set_AllowSignedNumbers(bool value);
    internal bool get_ForceEndNumberOnTernaryOpChars();
    internal void set_ForceEndNumberOnTernaryOpChars(bool value);
    [CompilerGeneratedAttribute]
internal bool get_WantSimpleName();
    [CompilerGeneratedAttribute]
internal void set_WantSimpleName(bool value);
    [CompilerGeneratedAttribute]
internal bool get_InWorkflowContext();
    [CompilerGeneratedAttribute]
internal void set_InWorkflowContext(bool value);
    [CompilerGeneratedAttribute]
internal List`1<Token> get_TokenList();
    [CompilerGeneratedAttribute]
internal void set_TokenList(List`1<Token> value);
    [CompilerGeneratedAttribute]
internal Token get_FirstToken();
    [CompilerGeneratedAttribute]
private void set_FirstToken(Token value);
    [CompilerGeneratedAttribute]
internal Token get_LastToken();
    [CompilerGeneratedAttribute]
private void set_LastToken(Token value);
    [CompilerGeneratedAttribute]
private List`1<Token> get_RequiresTokens();
    [CompilerGeneratedAttribute]
private void set_RequiresTokens(List`1<Token> value);
    private bool InCommandMode();
    private bool InExpressionMode();
    private bool InTypeNameMode();
    private bool InSignatureMode();
    internal void Initialize(string fileName, string input, List`1<Token> tokenList);
    internal TokenizerState StartNestedScan(UnscannedSubExprToken nestedText);
    internal void FinishNestedScan(TokenizerState ts);
    private char GetChar();
    private void UngetChar();
    private char PeekChar();
    private void SkipChar();
    private bool AtEof();
    internal static bool IsKeyword(string str);
    internal void SkipNewlines(bool skipSemis);
    private void SkipWhiteSpace();
    private void ScanNewline(char c);
    private void ScanSemicolon();
    private void ScanLineContinuation(char c);
    internal int GetRestorePoint();
    internal void Resync(Token token);
    internal void Resync(int start);
    internal void RemoveTokensFromListDuringResync(List`1<Token> tokenList, int start);
    internal void ReplaceSavedTokens(Token firstOldToken, Token lastOldToken, Token newToken);
    private void NormalizeCRLF(char c);
    internal void CheckAstIsBeforeSignature(Ast ast);
    private void ReportError(int errorOffset, string errorId, string errorMsg, Object[] args);
    private void ReportError(IScriptExtent extent, string errorId, string errorMsg);
    private void ReportError(IScriptExtent extent, string errorId, string errorMsg, object arg);
    private void ReportError(IScriptExtent extent, string errorId, string errorMsg, object arg1, object arg2);
    private void ReportIncompleteInput(int errorOffset, string errorId, string errorMsg);
    private void ReportIncompleteInput(int errorOffset, string errorId, string errorMsg, object arg);
    private InternalScriptExtent NewScriptExtent(int start, int end);
    internal InternalScriptExtent CurrentExtent();
    internal IScriptExtent GetScriptExtent();
    private Token NewCommentToken();
    private T SaveToken(T token);
    private Token NewToken(TokenKind kind);
    private Token NewNumberToken(object value);
    private Token NewParameterToken(string name, bool sawColon);
    private VariableToken NewVariableToken(VariablePath path, bool splatted);
    private StringToken NewStringLiteralToken(string value, TokenKind tokenKind, TokenFlags flags);
    private StringToken NewStringExpandableToken(string value, string formatString, TokenKind tokenKind, List`1<Token> nestedTokens, TokenFlags flags);
    private Token NewGenericExpandableToken(string value, string formatString, List`1<Token> nestedTokens);
    private Token NewGenericToken(string value);
    private Token NewInputRedirectionToken();
    private Token NewFileRedirectionToken(int from, bool append, bool fromSpecifiedExplicitly);
    private Token NewMergingRedirectionToken(int from, int to);
    private LabelToken NewLabelToken(string value);
    internal bool IsAtEndOfScript(IScriptExtent extent, bool checkCommentsAndWhitespace);
    private bool OnlyWhitespaceOrCommentsAfterExtent(InternalScriptExtent extent);
    internal bool IsPipeContinuation(IScriptExtent extent);
    private bool ContinuationAfterExtent(IScriptExtent extent, char continuationChar);
    private int SkipLineComment(int i);
    private int SkipBlockComment(int i);
    private char Backtick(char c, Char& surrogateCharacter);
    private char ScanUnicodeEscape(Char& surrogateCharacter);
    private static char GetCharsFromUtf32(UInt32 codepoint, Char& lowSurrogate);
    private void ScanToEndOfCommentLine(Boolean& sawBeginSig, Boolean& matchedRequires);
    private StringBuilder GetStringBuilder();
    private void Release(StringBuilder sb);
    private string GetStringAndRelease(StringBuilder sb);
    private void ScanLineComment();
    private void ScanBlockComment();
    private static int GetStringSimilarity(string first, string second, Int32[0...,0...] distanceMap);
    internal ScriptRequirements GetScriptRequirements();
    private void HandleRequiresParameter(CommandParameterAst parameter, ReadOnlyCollection`1<CommandElementAst> commandElements, bool snapinSpecified, Int32& index, String& snapinName, Version& snapinVersion, String& requiredShellId, Version& requiredVersion, List`1& requiredEditions, List`1& requiredModules, List`1& requiredAssemblies, Boolean& requiresElevation);
    private List`1<string> HandleRequiresAssemblyArgument(Ast argumentAst, object arg, List`1<string> requiredAssemblies);
    private List`1<string> HandleRequiresPSEditionArgument(Ast argumentAst, object arg, List`1& requiredEditions);
    internal StringToken GetVerbatimCommandArgument();
    private TokenFlags ScanStringLiteral(StringBuilder sb);
    private Token ScanStringLiteral();
    private Token ScanSubExpression(bool hereString);
    private TokenFlags ScanStringExpandable(StringBuilder sb, StringBuilder formatSb, List`1<Token> nestedTokens);
    private bool ScanDollarInStringExpandable(StringBuilder sb, StringBuilder formatSb, bool hereString, List`1<Token> nestedTokens);
    private Token ScanStringExpandable();
    private bool ScanAfterHereStringHeader(string header);
    private bool ScanPossibleHereStringFooter(Func`2<char, bool> test, Action`1<char> appendChar, Int32& falseFooterOffset);
    private Token ScanHereStringLiteral();
    private Token ScanHereStringExpandable();
    private Token ScanVariable(bool splatted, bool inStringExpandable);
    private Token ScanParameter();
    private Token CheckOperatorInCommandMode(char c, TokenKind tokenKind);
    private Token CheckOperatorInCommandMode(char c1, char c2, TokenKind tokenKind);
    private Token ScanGenericToken(char firstChar);
    private Token ScanGenericToken(char firstChar, char surrogateCharacter);
    private Token ScanGenericToken(StringBuilder sb);
    private void ScanHexDigits(StringBuilder sb);
    private int ScanDecimalDigits(StringBuilder sb);
    private void ScanBinaryDigits(StringBuilder sb);
    private void ScanExponent(StringBuilder sb, Int32& signIndex, Boolean& notNumber);
    private void ScanNumberAfterDot(StringBuilder sb, Int32& signIndex, Boolean& notNumber);
    private static bool TryGetNumberValue(ReadOnlySpan`1<char> strNum, NumberFormat format, NumberSuffixFlags suffix, bool real, long multiplier, Object& result);
    private Token ScanNumber(char firstChar);
    private string ScanNumberHelper(char firstChar, NumberFormat& format, NumberSuffixFlags& suffix, Boolean& real, Int64& multiplier);
    internal Token GetMemberAccessOperator(bool allowLBracket);
    internal Token GetInvokeMemberOpenParen();
    internal Token GetLBracket();
    private Token ScanDot();
    private Token ScanIdentifier(char firstChar);
    private Token ScanTypeName();
    private void ScanAssemblyNameSpecToken(StringBuilder sb);
    internal string GetAssemblyNameSpec();
    private Token ScanLabel();
    internal Token NextToken();
}
internal enum System.Management.Automation.Language.TokenizerMode : Enum {
    public int value__;
    public static TokenizerMode Command;
    public static TokenizerMode Expression;
    public static TokenizerMode TypeName;
    public static TokenizerMode Signature;
}
internal class System.Management.Automation.Language.TokenizerState : object {
    internal int NestedTokensAdjustment;
    internal string Script;
    internal int TokenStart;
    internal int CurrentIndex;
    internal Token FirstToken;
    internal Token LastToken;
    internal BitArray SkippedCharOffsets;
    internal List`1<Token> TokenList;
}
public enum System.Management.Automation.Language.TokenKind : Enum {
    public int value__;
    public static TokenKind Unknown;
    public static TokenKind Variable;
    public static TokenKind SplattedVariable;
    public static TokenKind Parameter;
    public static TokenKind Number;
    public static TokenKind Label;
    public static TokenKind Identifier;
    public static TokenKind Generic;
    public static TokenKind NewLine;
    public static TokenKind LineContinuation;
    public static TokenKind Comment;
    public static TokenKind EndOfInput;
    public static TokenKind StringLiteral;
    public static TokenKind StringExpandable;
    public static TokenKind HereStringLiteral;
    public static TokenKind HereStringExpandable;
    public static TokenKind LParen;
    public static TokenKind RParen;
    public static TokenKind LCurly;
    public static TokenKind RCurly;
    public static TokenKind LBracket;
    public static TokenKind RBracket;
    public static TokenKind AtParen;
    public static TokenKind AtCurly;
    public static TokenKind DollarParen;
    public static TokenKind Semi;
    public static TokenKind AndAnd;
    public static TokenKind OrOr;
    public static TokenKind Ampersand;
    public static TokenKind Pipe;
    public static TokenKind Comma;
    public static TokenKind MinusMinus;
    public static TokenKind PlusPlus;
    public static TokenKind DotDot;
    public static TokenKind ColonColon;
    public static TokenKind Dot;
    public static TokenKind Exclaim;
    public static TokenKind Multiply;
    public static TokenKind Divide;
    public static TokenKind Rem;
    public static TokenKind Plus;
    public static TokenKind Minus;
    public static TokenKind Equals;
    public static TokenKind PlusEquals;
    public static TokenKind MinusEquals;
    public static TokenKind MultiplyEquals;
    public static TokenKind DivideEquals;
    public static TokenKind RemainderEquals;
    public static TokenKind Redirection;
    public static TokenKind RedirectInStd;
    public static TokenKind Format;
    public static TokenKind Not;
    public static TokenKind Bnot;
    public static TokenKind And;
    public static TokenKind Or;
    public static TokenKind Xor;
    public static TokenKind Band;
    public static TokenKind Bor;
    public static TokenKind Bxor;
    public static TokenKind Join;
    public static TokenKind Ieq;
    public static TokenKind Ine;
    public static TokenKind Ige;
    public static TokenKind Igt;
    public static TokenKind Ilt;
    public static TokenKind Ile;
    public static TokenKind Ilike;
    public static TokenKind Inotlike;
    public static TokenKind Imatch;
    public static TokenKind Inotmatch;
    public static TokenKind Ireplace;
    public static TokenKind Icontains;
    public static TokenKind Inotcontains;
    public static TokenKind Iin;
    public static TokenKind Inotin;
    public static TokenKind Isplit;
    public static TokenKind Ceq;
    public static TokenKind Cne;
    public static TokenKind Cge;
    public static TokenKind Cgt;
    public static TokenKind Clt;
    public static TokenKind Cle;
    public static TokenKind Clike;
    public static TokenKind Cnotlike;
    public static TokenKind Cmatch;
    public static TokenKind Cnotmatch;
    public static TokenKind Creplace;
    public static TokenKind Ccontains;
    public static TokenKind Cnotcontains;
    public static TokenKind Cin;
    public static TokenKind Cnotin;
    public static TokenKind Csplit;
    public static TokenKind Is;
    public static TokenKind IsNot;
    public static TokenKind As;
    public static TokenKind PostfixPlusPlus;
    public static TokenKind PostfixMinusMinus;
    public static TokenKind Shl;
    public static TokenKind Shr;
    public static TokenKind Colon;
    public static TokenKind QuestionMark;
    public static TokenKind QuestionQuestionEquals;
    public static TokenKind QuestionQuestion;
    public static TokenKind QuestionDot;
    public static TokenKind QuestionLBracket;
    public static TokenKind Begin;
    public static TokenKind Break;
    public static TokenKind Catch;
    public static TokenKind Class;
    public static TokenKind Continue;
    public static TokenKind Data;
    public static TokenKind Define;
    public static TokenKind Do;
    public static TokenKind Dynamicparam;
    public static TokenKind Else;
    public static TokenKind ElseIf;
    public static TokenKind End;
    public static TokenKind Exit;
    public static TokenKind Filter;
    public static TokenKind Finally;
    public static TokenKind For;
    public static TokenKind Foreach;
    public static TokenKind From;
    public static TokenKind Function;
    public static TokenKind If;
    public static TokenKind In;
    public static TokenKind Param;
    public static TokenKind Process;
    public static TokenKind Return;
    public static TokenKind Switch;
    public static TokenKind Throw;
    public static TokenKind Trap;
    public static TokenKind Try;
    public static TokenKind Until;
    public static TokenKind Using;
    public static TokenKind Var;
    public static TokenKind While;
    public static TokenKind Workflow;
    public static TokenKind Parallel;
    public static TokenKind Sequence;
    public static TokenKind InlineScript;
    public static TokenKind Configuration;
    public static TokenKind DynamicKeyword;
    public static TokenKind Public;
    public static TokenKind Private;
    public static TokenKind Static;
    public static TokenKind Interface;
    public static TokenKind Enum;
    public static TokenKind Namespace;
    public static TokenKind Module;
    public static TokenKind Type;
    public static TokenKind Assembly;
    public static TokenKind Command;
    public static TokenKind Hidden;
    public static TokenKind Base;
    public static TokenKind Default;
    public static TokenKind Clean;
}
[ExtensionAttribute]
public static class System.Management.Automation.Language.TokenTraits : object {
    private static TokenFlags[] s_staticTokenFlags;
    private static String[] s_tokenText;
    private static TokenTraits();
    [ExtensionAttribute]
public static TokenFlags GetTraits(TokenKind kind);
    [ExtensionAttribute]
public static bool HasTrait(TokenKind kind, TokenFlags flag);
    [ExtensionAttribute]
internal static int GetBinaryPrecedence(TokenKind kind);
    [ExtensionAttribute]
public static string Text(TokenKind kind);
}
public class System.Management.Automation.Language.TrapStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private TypeConstraintAst <TrapType>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    public TypeConstraintAst TrapType { get; }
    public StatementBlockAst Body { get; }
    public TrapStatementAst(IScriptExtent extent, TypeConstraintAst trapType, StatementBlockAst body);
    [CompilerGeneratedAttribute]
public TypeConstraintAst get_TrapType();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.TryStatementAst : StatementAst {
    private static ReadOnlyCollection`1<CatchClauseAst> s_emptyCatchClauses;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Body>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<CatchClauseAst> <CatchClauses>k__BackingField;
    [CompilerGeneratedAttribute]
private StatementBlockAst <Finally>k__BackingField;
    public StatementBlockAst Body { get; }
    public ReadOnlyCollection`1<CatchClauseAst> CatchClauses { get; }
    public StatementBlockAst Finally { get; }
    public TryStatementAst(IScriptExtent extent, StatementBlockAst body, IEnumerable`1<CatchClauseAst> catchClauses, StatementBlockAst finally);
    private static TryStatementAst();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Body();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<CatchClauseAst> get_CatchClauses();
    [CompilerGeneratedAttribute]
public StatementBlockAst get_Finally();
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
[FlagsAttribute]
public enum System.Management.Automation.Language.TypeAttributes : Enum {
    public int value__;
    public static TypeAttributes None;
    public static TypeAttributes Class;
    public static TypeAttributes Interface;
    public static TypeAttributes Enum;
}
internal static class System.Management.Automation.Language.TypeCache : object {
    private static ConcurrentDictionary`2<Tuple`2<ITypeName, TypeResolutionState>, Type> s_cache;
    private static TypeCache();
    internal static Type Lookup(ITypeName typeName, TypeResolutionState typeResolutionState);
    internal static void Add(ITypeName typeName, TypeResolutionState typeResolutionState, Type type);
}
public class System.Management.Automation.Language.TypeConstraintAst : AttributeBaseAst {
    public TypeConstraintAst(IScriptExtent extent, ITypeName typeName);
    public TypeConstraintAst(IScriptExtent extent, Type type);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal virtual Attribute GetAttribute();
}
internal static class System.Management.Automation.Language.TypeDefiner : object {
    internal static string DynamicClassAssemblyName;
    internal static string DynamicClassAssemblyFullNamePrefix;
    private static int s_globalCounter;
    private static CustomAttributeBuilder s_hiddenCustomAttributeBuilder;
    private static string s_sessionStateKeeperFieldName;
    internal static string SessionStateFieldName;
    private static MethodInfo s_sessionStateKeeper_GetSessionState;
    private static int counter;
    private static OpCode[] s_ldc;
    private static OpCode[] s_ldarg;
    private static TypeDefiner();
    private static bool TryConvertArg(object arg, Type type, Object& result, Parser parser, IScriptExtent errorExtent);
    private static CustomAttributeBuilder GetAttributeBuilder(Parser parser, AttributeAst attributeAst, AttributeTargets attributeTargets);
    internal static void DefineCustomAttributes(TypeBuilder member, ReadOnlyCollection`1<AttributeAst> attributes, Parser parser, AttributeTargets attributeTargets);
    internal static void DefineCustomAttributes(PropertyBuilder member, ReadOnlyCollection`1<AttributeAst> attributes, Parser parser, AttributeTargets attributeTargets);
    internal static void DefineCustomAttributes(ConstructorBuilder member, ReadOnlyCollection`1<AttributeAst> attributes, Parser parser, AttributeTargets attributeTargets);
    internal static void DefineCustomAttributes(MethodBuilder member, ReadOnlyCollection`1<AttributeAst> attributes, Parser parser, AttributeTargets attributeTargets);
    internal static void DefineCustomAttributes(EnumBuilder member, ReadOnlyCollection`1<AttributeAst> attributes, Parser parser, AttributeTargets attributeTargets);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.TypeDefiner/<GetAssemblyAttributeBuilders>d__16")]
private static IEnumerable`1<CustomAttributeBuilder> GetAssemblyAttributeBuilders(string scriptFile);
    internal static Assembly DefineTypes(Parser parser, Ast rootAst, TypeDefinitionAst[] typeDefinitions);
    private static string GetClassNameInAssembly(TypeDefinitionAst typeDefinitionAst);
    private static void EmitLdc(ILGenerator emitter, int c);
    private static void EmitLdarg(ILGenerator emitter, int c);
}
public class System.Management.Automation.Language.TypeDefinitionAst : StatementAst {
    private static ReadOnlyCollection`1<AttributeAst> s_emptyAttributeList;
    private static ReadOnlyCollection`1<MemberAst> s_emptyMembersCollection;
    private static ReadOnlyCollection`1<TypeConstraintAst> s_emptyBaseTypesCollection;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<AttributeAst> <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<TypeConstraintAst> <BaseTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<MemberAst> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeAttributes <TypeAttributes>k__BackingField;
    private Type _type;
    public string Name { get; }
    public ReadOnlyCollection`1<AttributeAst> Attributes { get; }
    public ReadOnlyCollection`1<TypeConstraintAst> BaseTypes { get; }
    public ReadOnlyCollection`1<MemberAst> Members { get; }
    public TypeAttributes TypeAttributes { get; }
    public bool IsEnum { get; }
    public bool IsClass { get; }
    public bool IsInterface { get; }
    internal Type Type { get; internal set; }
    public TypeDefinitionAst(IScriptExtent extent, string name, IEnumerable`1<AttributeAst> attributes, IEnumerable`1<MemberAst> members, TypeAttributes typeAttributes, IEnumerable`1<TypeConstraintAst> baseTypes);
    private static TypeDefinitionAst();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<AttributeAst> get_Attributes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<TypeConstraintAst> get_BaseTypes();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<MemberAst> get_Members();
    [CompilerGeneratedAttribute]
public TypeAttributes get_TypeAttributes();
    public bool get_IsEnum();
    public bool get_IsClass();
    public bool get_IsInterface();
    internal Type get_Type();
    internal void set_Type(Type value);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.TypeExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ITypeName <TypeName>k__BackingField;
    public ITypeName TypeName { get; }
    public Type StaticType { get; }
    public TypeExpressionAst(IScriptExtent extent, ITypeName typeName);
    [CompilerGeneratedAttribute]
public ITypeName get_TypeName();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.TypeLookupResult : object {
    [CompilerGeneratedAttribute]
private TypeDefinitionAst <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExternalNamespaces>k__BackingField;
    public TypeDefinitionAst Type { get; public set; }
    public List`1<string> ExternalNamespaces { get; public set; }
    public TypeLookupResult(TypeDefinitionAst type);
    [CompilerGeneratedAttribute]
public TypeDefinitionAst get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(TypeDefinitionAst value);
    [CompilerGeneratedAttribute]
public List`1<string> get_ExternalNamespaces();
    [CompilerGeneratedAttribute]
public void set_ExternalNamespaces(List`1<string> value);
    public bool IsAmbiguous();
}
public class System.Management.Automation.Language.TypeName : object {
    internal string _name;
    internal Type _type;
    internal IScriptExtent _extent;
    internal TypeDefinitionAst _typeDefinitionAst;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    public string FullName { get; }
    public string Name { get; }
    public string AssemblyName { get; internal set; }
    public bool IsArray { get; }
    public bool IsGeneric { get; }
    public IScriptExtent Extent { get; }
    private Type System.Management.Automation.Language.ISupportsTypeCaching.CachedType { get; private set; }
    public TypeName(IScriptExtent extent, string name);
    public TypeName(IScriptExtent extent, string name, string assembly);
    public sealed virtual string get_FullName();
    public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public sealed virtual string get_AssemblyName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyName(string value);
    public sealed virtual bool get_IsArray();
    public sealed virtual bool get_IsGeneric();
    public sealed virtual IScriptExtent get_Extent();
    internal bool HasDefaultCtor();
    public sealed virtual Type GetReflectionType();
    public sealed virtual Type GetReflectionAttributeType();
    internal void SetTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public virtual string ToString();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool IsType(Type type);
    private sealed virtual override Type System.Management.Automation.Language.ISupportsTypeCaching.get_CachedType();
    private sealed virtual override void System.Management.Automation.Language.ISupportsTypeCaching.set_CachedType(Type value);
}
internal class System.Management.Automation.Language.TypeResolutionState : object {
    internal static String[] systemNamespace;
    internal static Assembly[] emptyAssemblies;
    internal static TypeResolutionState UsingSystem;
    internal String[] namespaces;
    internal Assembly[] assemblies;
    private HashSet`1<string> _typesDefined;
    internal int genericArgumentCount;
    internal bool attribute;
    internal TypeResolutionState(String[] namespaces, Assembly[] assemblies);
    internal TypeResolutionState(TypeResolutionState other, int genericArgumentCount, bool attribute);
    private TypeResolutionState(TypeResolutionState other, HashSet`1<string> typesDefined);
    private static TypeResolutionState();
    internal TypeResolutionState CloneWithAddTypesDefined(IEnumerable`1<string> types);
    internal bool ContainsTypeDefined(string type);
    internal static TypeResolutionState GetDefaultUsingState(ExecutionContext context);
    internal string GetAlternateTypeName(string typeName);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal static class System.Management.Automation.Language.TypeResolver : object {
    [ThreadStaticAttribute]
private static HashSet`1<Assembly> t_searchedAssemblies;
    private static Type LookForTypeInSingleAssembly(Assembly assembly, string typename);
    private static Type LookForTypeInAssemblies(TypeName typeName, IEnumerable`1<Assembly> assemblies, HashSet`1<Assembly> searchedAssemblies, TypeResolutionState typeResolutionState, bool reportAmbiguousException, Exception& exception);
    internal static bool IsPublic(Type type);
    private static Type ResolveTypeNameWorker(TypeName typeName, SessionStateScope currentScope, IEnumerable`1<Assembly> loadedAssemblies, HashSet`1<Assembly> searchedAssemblies, TypeResolutionState typeResolutionState, bool onlySearchInGivenAssemblies, bool reportAmbiguousException, Exception& exception);
    private static Type CallResolveTypeNameWorkerHelper(TypeName typeName, ExecutionContext context, IEnumerable`1<Assembly> assemblies, bool isAssembliesExplicitlyPassedIn, TypeResolutionState typeResolutionState, Exception& exception);
    internal static Type ResolveAssemblyQualifiedTypeName(TypeName typeName, Exception& exception);
    internal static Type ResolveTypeNameWithContext(TypeName typeName, Exception& exception, Assembly[] assemblies, TypeResolutionState typeResolutionState);
    internal static Type ResolveTypeName(TypeName typeName, Exception& exception);
    internal static bool TryResolveType(string typeName, Type& type);
    internal static Type ResolveITypeName(ITypeName iTypeName, Exception& exception);
    internal static Type ResolveType(string strTypeName, Exception& exception);
}
public class System.Management.Automation.Language.UnaryExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private TokenKind <TokenKind>k__BackingField;
    [CompilerGeneratedAttribute]
private ExpressionAst <Child>k__BackingField;
    public TokenKind TokenKind { get; }
    public ExpressionAst Child { get; }
    public Type StaticType { get; }
    public UnaryExpressionAst(IScriptExtent extent, TokenKind tokenKind, ExpressionAst child);
    [CompilerGeneratedAttribute]
public TokenKind get_TokenKind();
    [CompilerGeneratedAttribute]
public ExpressionAst get_Child();
    public virtual Ast Copy();
    public virtual Type get_StaticType();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
internal class System.Management.Automation.Language.UnscannedSubExprToken : StringLiteralToken {
    [CompilerGeneratedAttribute]
private BitArray <SkippedCharOffsets>k__BackingField;
    internal BitArray SkippedCharOffsets { get; }
    internal UnscannedSubExprToken(InternalScriptExtent scriptExtent, TokenFlags tokenFlags, string value, BitArray skippedCharOffsets);
    [CompilerGeneratedAttribute]
internal BitArray get_SkippedCharOffsets();
}
internal class System.Management.Automation.Language.UpdatePositionExpr : Expression {
    private IScriptExtent _extent;
    private SymbolDocumentInfo _debugSymbolDocument;
    private int _sequencePoint;
    private bool _checkBreakpoints;
    public bool CanReduce { get; }
    public Type Type { get; }
    public ExpressionType NodeType { get; }
    public UpdatePositionExpr(IScriptExtent extent, int sequencePoint, SymbolDocumentInfo debugSymbolDocument, bool checkBreakpoints);
    public virtual bool get_CanReduce();
    public virtual Type get_Type();
    public virtual ExpressionType get_NodeType();
    public virtual Expression Reduce();
    public sealed virtual void AddInstructions(LightCompiler compiler);
}
public class System.Management.Automation.Language.UsingExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private ExpressionAst <SubExpression>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RuntimeUsingIndex>k__BackingField;
    internal static string UsingPrefix;
    public ExpressionAst SubExpression { get; }
    internal int RuntimeUsingIndex { get; internal set; }
    public UsingExpressionAst(IScriptExtent extent, ExpressionAst expressionAst);
    [CompilerGeneratedAttribute]
public ExpressionAst get_SubExpression();
    [CompilerGeneratedAttribute]
internal int get_RuntimeUsingIndex();
    [CompilerGeneratedAttribute]
internal void set_RuntimeUsingIndex(int value);
    public virtual Ast Copy();
    public static VariableExpressionAst ExtractUsingVariable(UsingExpressionAst usingExpressionAst);
    private static VariableExpressionAst ExtractUsingVariableImpl(ExpressionAst expression);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public class System.Management.Automation.Language.UsingStatementAst : StatementAst {
    [CompilerGeneratedAttribute]
private UsingStatementKind <UsingStatementKind>k__BackingField;
    [CompilerGeneratedAttribute]
private StringConstantExpressionAst <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private StringConstantExpressionAst <Alias>k__BackingField;
    [CompilerGeneratedAttribute]
private HashtableAst <ModuleSpecification>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <ModuleInfo>k__BackingField;
    public UsingStatementKind UsingStatementKind { get; }
    public StringConstantExpressionAst Name { get; }
    public StringConstantExpressionAst Alias { get; }
    public HashtableAst ModuleSpecification { get; }
    internal PSModuleInfo ModuleInfo { get; private set; }
    public UsingStatementAst(IScriptExtent extent, UsingStatementKind kind, StringConstantExpressionAst name);
    public UsingStatementAst(IScriptExtent extent, HashtableAst moduleSpecification);
    public UsingStatementAst(IScriptExtent extent, UsingStatementKind kind, StringConstantExpressionAst aliasName, StringConstantExpressionAst resolvedAliasAst);
    public UsingStatementAst(IScriptExtent extent, StringConstantExpressionAst aliasName, HashtableAst moduleSpecification);
    [CompilerGeneratedAttribute]
public UsingStatementKind get_UsingStatementKind();
    [CompilerGeneratedAttribute]
public StringConstantExpressionAst get_Name();
    [CompilerGeneratedAttribute]
public StringConstantExpressionAst get_Alias();
    [CompilerGeneratedAttribute]
public HashtableAst get_ModuleSpecification();
    [CompilerGeneratedAttribute]
internal PSModuleInfo get_ModuleInfo();
    [CompilerGeneratedAttribute]
private void set_ModuleInfo(PSModuleInfo value);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    internal ReadOnlyDictionary`2<string, TypeDefinitionAst> DefineImportedModule(PSModuleInfo moduleInfo);
    internal bool IsUsingModuleOrAssembly();
}
public enum System.Management.Automation.Language.UsingStatementKind : Enum {
    public int value__;
    public static UsingStatementKind Assembly;
    public static UsingStatementKind Command;
    public static UsingStatementKind Module;
    public static UsingStatementKind Namespace;
    public static UsingStatementKind Type;
}
internal class System.Management.Automation.Language.VariableAnalysis : object {
    internal static int Unanalyzed;
    internal static int ForceDynamic;
    private static ConcurrentDictionary`2<string, bool> s_allScopeVariables;
    private Dictionary`2<string, VariableAnalysisDetails> _variables;
    private Block _entryBlock;
    private Block _exitBlock;
    private Block _currentBlock;
    private bool _disableOptimizations;
    private List`1<LoopGotoTargets> _loopTargets;
    private int _localsAllocated;
    private static VariableAnalysis();
    internal static string GetUnaliasedVariableName(string varName);
    internal static string GetUnaliasedVariableName(VariablePath varPath);
    internal static void NoteAllScopeVariable(string variableName);
    internal static bool AnyVariablesCouldBeAllScope(Dictionary`2<string, int> variableNames);
    internal static Tuple`2<Type, Dictionary`2<string, int>> AnalyzeExpression(ExpressionAst exprAst);
    private Tuple`2<Type, Dictionary`2<string, int>> AnalyzeImpl(ExpressionAst exprAst);
    internal static Tuple`2<Type, Dictionary`2<string, int>> AnalyzeTrap(TrapStatementAst trap);
    private Tuple`2<Type, Dictionary`2<string, int>> AnalyzeImpl(TrapStatementAst trap);
    private void Init();
    internal static Tuple`2<Type, Dictionary`2<string, int>> Analyze(IParameterMetadataProvider ast, bool disableOptimizations, bool scriptCmdlet);
    internal static bool AnalyzeMemberFunction(FunctionMemberAst ast);
    private Tuple`2<Type, Dictionary`2<string, int>> AnalyzeImpl(IParameterMetadataProvider ast, bool disableOptimizations, bool scriptCmdlet);
    private Tuple`2<Type, Dictionary`2<string, int>> FinishAnalysis(bool scriptCmdlet);
    private static bool MustBeBoxed(Type type);
    private static void FixTupleIndex(Ast ast, int newIndex);
    private static void FixAssigned(Ast ast, VariableAnalysisDetails details);
    private void AnalyzeBlock(BitArray assignedBitArray, Block block);
    private void CheckLHSAssign(ExpressionAst lhs, BitArray assignedBitArray);
    private VariableAnalysisDetails CheckLHSAssignVar(string variableName, BitArray assignedBitArray, Type convertType);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    private object VisitStatementBlock(ReadOnlyCollection`1<StatementAst> statements);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    private void GenerateWhileLoop(string loopLabel, Action generateCondition, Action generateLoopBody, Ast continueAction);
    private void GenerateDoLoop(LoopStatementAst loopStatement);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    private void BreakOrContinue(ExpressionAst label, Func`2<LoopGotoTargets, Block> fieldSelector);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    private Block ControlFlowStatement(PipelineBaseAst pipelineAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    [IteratorStateMachineAttribute("System.Management.Automation.Language.VariableAnalysis/<GetAssignmentTargets>d__65")]
private static IEnumerable`1<ExpressionAst> GetAssignmentTargets(ExpressionAst expressionAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatement);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
}
internal class System.Management.Automation.Language.VariableAnalysisDetails : object {
    [CompilerGeneratedAttribute]
private int <BitIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private int <LocalTupleIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Automatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PreferenceVariable>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Assigned>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Ast> <AssociatedAsts>k__BackingField;
    public int BitIndex { get; public set; }
    public int LocalTupleIndex { get; public set; }
    public Type Type { get; public set; }
    public string Name { get; public set; }
    public bool Automatic { get; public set; }
    public bool PreferenceVariable { get; public set; }
    public bool Assigned { get; public set; }
    public List`1<Ast> AssociatedAsts { get; }
    [CompilerGeneratedAttribute]
public int get_BitIndex();
    [CompilerGeneratedAttribute]
public void set_BitIndex(int value);
    [CompilerGeneratedAttribute]
public int get_LocalTupleIndex();
    [CompilerGeneratedAttribute]
public void set_LocalTupleIndex(int value);
    [CompilerGeneratedAttribute]
public Type get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(Type value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_Automatic();
    [CompilerGeneratedAttribute]
public void set_Automatic(bool value);
    [CompilerGeneratedAttribute]
public bool get_PreferenceVariable();
    [CompilerGeneratedAttribute]
public void set_PreferenceVariable(bool value);
    [CompilerGeneratedAttribute]
public bool get_Assigned();
    [CompilerGeneratedAttribute]
public void set_Assigned(bool value);
    [CompilerGeneratedAttribute]
public List`1<Ast> get_AssociatedAsts();
}
public class System.Management.Automation.Language.VariableExpressionAst : ExpressionAst {
    [CompilerGeneratedAttribute]
private VariablePath <VariablePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Splatted>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TupleIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Automatic>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Assigned>k__BackingField;
    public VariablePath VariablePath { get; }
    public bool Splatted { get; }
    internal int TupleIndex { get; internal set; }
    internal bool Automatic { get; internal set; }
    internal bool Assigned { get; internal set; }
    public VariableExpressionAst(IScriptExtent extent, string variableName, bool splatted);
    internal VariableExpressionAst(VariableToken token);
    public VariableExpressionAst(IScriptExtent extent, VariablePath variablePath, bool splatted);
    [CompilerGeneratedAttribute]
public VariablePath get_VariablePath();
    [CompilerGeneratedAttribute]
public bool get_Splatted();
    public bool IsConstantVariable();
    public virtual Ast Copy();
    internal bool IsSafeVariableReference(HashSet`1<string> validVariables, Boolean& usesParameter);
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
    [CompilerGeneratedAttribute]
internal int get_TupleIndex();
    [CompilerGeneratedAttribute]
internal void set_TupleIndex(int value);
    [CompilerGeneratedAttribute]
internal bool get_Automatic();
    [CompilerGeneratedAttribute]
internal void set_Automatic(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Assigned();
    [CompilerGeneratedAttribute]
internal void set_Assigned(bool value);
    private sealed virtual override IAssignableValue System.Management.Automation.Language.ISupportsAssignment.GetAssignableValue();
    private sealed virtual override Expression System.Management.Automation.Language.IAssignableValue.GetValue(Compiler compiler, List`1<Expression> exprs, List`1<ParameterExpression> temps);
    private sealed virtual override Expression System.Management.Automation.Language.IAssignableValue.SetValue(Compiler compiler, Expression rhs);
    internal Type GetVariableType(Compiler compiler, IEnumerable`1& tupleAccessPath, Boolean& localInTuple);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Language.VariablePathExtensions : object {
    [ExtensionAttribute]
internal static bool IsAnyLocal(VariablePath variablePath);
}
public class System.Management.Automation.Language.VariableToken : Token {
    [CompilerGeneratedAttribute]
private VariablePath <VariablePath>k__BackingField;
    public string Name { get; }
    public VariablePath VariablePath { get; }
    internal VariableToken(InternalScriptExtent scriptExtent, VariablePath path, TokenFlags tokenFlags, bool splatted);
    public string get_Name();
    [CompilerGeneratedAttribute]
public VariablePath get_VariablePath();
    internal virtual string ToDebugString(int indent);
}
public class System.Management.Automation.Language.WhileStatementAst : LoopStatementAst {
    public WhileStatementAst(IScriptExtent extent, string label, PipelineBaseAst condition, StatementBlockAst body);
    public virtual Ast Copy();
    internal virtual object Accept(ICustomAstVisitor visitor);
    internal virtual AstVisitAction InternalVisit(AstVisitor visitor);
}
public static class System.Management.Automation.LanguagePrimitives : object {
    [TraceSourceAttribute("ETS", "Extended Type System")]
private static PSTraceSource s_tracer;
    internal static string OrderedAttribute;
    internal static string DoublePrecision;
    internal static string SinglePrecision;
    private static Dictionary`2<Type, GetEnumerableDelegate> s_getEnumerableCache;
    private static CallSite`1<Func`3<CallSite, object, IEnumerator>> s_getEnumeratorSite;
    internal static Type[][] LargestTypeTable;
    private static TypeCodeTraits[] s_typeCodeTraits;
    internal static PSTraceSource typeConversion;
    internal static ConversionData`1<object> NoConversion;
    private static Dictionary`2<string, string> s_nameMap;
    private static Dictionary`2<ConversionTypePair, IConversionData> s_converterCache;
    private static Type[] s_numericTypes;
    private static Type[] s_integerTypes;
    private static Type[] s_signedIntegerTypes;
    private static Type[] s_unsignedIntegerTypes;
    private static Type[] s_realTypes;
    private static Dictionary`2<string, bool> s_possibleTypeConverter;
    private static LanguagePrimitives();
    internal static void CreateMemberNotFoundError(PSObject pso, DictionaryEntry property, Type resultType);
    internal static void CreateMemberSetValueError(SetValueException e);
    internal static void UpdateTypeConvertFromTypeTable(string typeName);
    private static IEnumerable GetEnumerableFromIEnumerableT(object obj);
    private static GetEnumerableDelegate GetOrCalculateEnumerable(Type type);
    private static void InitializeGetEnumerableCache();
    internal static bool IsTypeEnumerable(Type type);
    public static bool IsObjectEnumerable(object obj);
    public static IEnumerable GetEnumerable(object obj);
    private static IEnumerable ReturnNullEnumerable(object obj);
    private static IEnumerable DataTableEnumerable(object obj);
    private static IEnumerable TypicalEnumerable(object obj);
    private static GetEnumerableDelegate CalculateGetEnumerable(Type objectType);
    public static IEnumerator GetEnumerator(object obj);
    public static PSDataCollection`1<PSObject> GetPSDataCollection(object inputValue);
    public static bool Equals(object first, object second);
    public static bool Equals(object first, object second, bool ignoreCase);
    public static bool Equals(object first, object second, bool ignoreCase, IFormatProvider formatProvider);
    private static int CompareObjectToNull(object value, bool numberIsRightHandSide);
    public static int Compare(object first, object second);
    public static int Compare(object first, object second, bool ignoreCase);
    public static int Compare(object first, object second, bool ignoreCase, IFormatProvider formatProvider);
    public static bool TryCompare(object first, object second, Int32& result);
    public static bool TryCompare(object first, object second, bool ignoreCase, Int32& result);
    public static bool TryCompare(object first, object second, bool ignoreCase, IFormatProvider formatProvider, Int32& result);
    public static bool IsTrue(object obj);
    internal static bool IsTrue(string s);
    internal static bool IsTrue(IList objectArray);
    internal static bool IsNull(object obj);
    internal static PSObject AsPSObjectOrNull(object obj);
    internal static int TypeTableIndex(Type type);
    private static int NumericCompareDecimal(decimal decimalNumber, object otherNumber);
    private static int NumericCompare(object number1, object number2, int index1, int index2);
    internal static TypeCode GetTypeCode(Type type);
    internal static T FromObjectAs(object castObject);
    internal static bool IsSignedInteger(TypeCode typeCode);
    internal static bool IsUnsignedInteger(TypeCode typeCode);
    internal static bool IsInteger(TypeCode typeCode);
    internal static bool IsFloating(TypeCode typeCode);
    internal static bool IsNumeric(TypeCode typeCode);
    internal static bool IsCimIntrinsicScalarType(TypeCode typeCode);
    internal static bool IsCimIntrinsicScalarType(Type type);
    internal static bool IsBooleanType(Type type);
    internal static bool IsSwitchParameterType(Type type);
    internal static bool IsBoolOrSwitchParameterType(Type type);
    internal static void DoConversionsForSetInGenericDictionary(IDictionary dictionary, Object& key, Object& value);
    private static TypeConverter GetIntegerSystemConverter(Type type);
    internal static object GetConverter(Type type, TypeTable backupTypeTable);
    private static object NewConverterInstance(string assemblyQualifiedTypeName);
    public static string ConvertTypeNameToPSTypeName(string typeName);
    public static object ConvertTo(object valueToConvert, Type resultType);
    public static object ConvertTo(object valueToConvert, Type resultType, IFormatProvider formatProvider);
    public static object ConvertPSObjectToType(PSObject valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, bool ignoreUnknownMembers);
    public static T ConvertTo(object valueToConvert);
    public static bool TryConvertTo(object valueToConvert, T& result);
    public static bool TryConvertTo(object valueToConvert, IFormatProvider formatProvider, T& result);
    public static bool TryConvertTo(object valueToConvert, Type resultType, Object& result);
    public static bool TryConvertTo(object valueToConvert, Type resultType, IFormatProvider formatProvider, Object& result);
    private static MethodInfo FindCastOperator(string methodName, Type targetType, Type originalType, Type resultType);
    private static object ConvertNumericThroughDouble(object valueToConvert, Type resultType);
    private static ManagementObject ConvertToWMI(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static ManagementObjectSearcher ConvertToWMISearcher(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static ManagementClass ConvertToWMIClass(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static DirectoryEntry ConvertToADSI(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static DirectorySearcher ConvertToADSISearcher(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static StringCollection ConvertToStringCollection(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static void AddItemsToCollection(object valueToConvert, Type resultType, IFormatProvider formatProvider, TypeTable backupTable, StringCollection stringCollection);
    private static XmlDocument ConvertToXml(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static CultureInfo GetCultureFromFormatProvider(IFormatProvider formatProvider);
    private static bool IsCustomTypeConversion(object valueToConvert, Type resultType, IFormatProvider formatProvider, Object& result, TypeTable backupTypeTable);
    private static object ConvertNumericChar(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNumeric(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Char[] ConvertStringToCharArray(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Regex ConvertStringToRegex(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static CimSession ConvertStringToCimSession(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Type ConvertStringToType(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Uri ConvertStringToUri(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool TryScanNumber(string strToConvert, Type resultType, Object& result);
    private static object ConvertStringToInteger(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertStringToDecimal(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertStringToReal(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertAssignableFrom(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static PSObject ConvertToPSObject(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertToVoid(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertClassToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertValueToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertStringToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertInt16ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertInt32ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertInt64ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertUInt16ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertUInt32ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertUInt64ToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertSByteToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertByteToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertSingleToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertDoubleToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertDecimalToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertBigIntegerToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertBoolToBigInteger(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static PSConverter`1<bool> CreateNumericToBoolConverter(Type fromType);
    private static bool ConvertCharToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertSwitchParameterToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertIListToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static string ConvertNumericToString(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static string ConvertNonNumericToString(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Hashtable ConvertIDictionaryToHashtable(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static PSReference ConvertToPSReference(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static Delegate ConvertScriptBlockToDelegate(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertToNullable(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertRelatedArrays(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertUnrelatedArrays(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertEnumerableToArray(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertScalarToArray(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertIntegerToEnum(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertStringToEnum(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertEnumerableToEnum(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertIConvertible(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNumericIConvertible(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNullToNumeric(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static char ConvertNullToChar(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static string ConvertNullToString(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static PSReference ConvertNullToPSReference(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNullToRef(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static bool ConvertNullToBool(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNullToNullable(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static SwitchParameter ConvertNullToSwitch(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNullToVoid(object valueToConvert, Type resultType, bool recursion, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNoConversion(object valueToConvert, Type resultType, bool recurse, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static object ConvertNotSupportedConversion(object valueToConvert, Type resultType, bool recurse, PSObject originalValueToConvert, IFormatProvider formatProvider, TypeTable backupTable);
    private static IConversionData CacheConversion(Type fromType, Type toType, PSConverter`1<T> converter, ConversionRank rank);
    private static IConversionData GetConversionData(Type fromType, Type toType);
    internal static ConversionRank GetConversionRank(Type fromType, Type toType);
    internal static void RebuildConversionCache();
    internal static PSObject SetObjectProperties(object o, PSObject psObject, Type resultType, MemberNotFoundError memberNotFoundErrorAction, MemberSetValueError memberSetValueErrorAction, IFormatProvider formatProvider, bool recursion, bool ignoreUnknownMembers);
    internal static PSObject SetObjectProperties(object o, IDictionary properties, Type resultType, MemberNotFoundError memberNotFoundErrorAction, MemberSetValueError memberSetValueErrorAction, bool enableMethodCall);
    internal static PSObject SetObjectProperties(object o, IDictionary properties, Type resultType, MemberNotFoundError memberNotFoundErrorAction, MemberSetValueError memberSetValueErrorAction, bool enableMethodCall, IFormatProvider formatProvider, bool recursion, bool ignoreUnknownMembers);
    private static string GetSettableProperties(PSObject pso);
    internal static IConversionData FigureConversion(object valueToConvert, Type resultType, Boolean& debase);
    internal static object ConvertTo(object valueToConvert, Type resultType, bool recursion, IFormatProvider formatProvider, TypeTable backupTypeTable);
    internal static Tuple`2<string, string> GetInvalidCastMessages(object valueToConvert, Type resultType);
    internal static object ThrowInvalidCastException(object valueToConvert, Type resultType);
    internal static object ThrowInvalidConversionException(object valueToConvert, Type resultType);
    private static IConversionData FigureLanguageConversion(Type fromType, Type toType, PSConverter`1& valueDependentConversion, ConversionRank& valueDependentRank);
    private static PSConverter`1<object> FigureStaticCreateMethodConversion(Type fromType, Type toType);
    private static PSConverter`1<object> FigureParseConversion(Type fromType, Type toType);
    internal static Tuple`2<PSConverter`1<object>, ConversionRank> FigureIEnumerableConstructorConversion(Type fromType, Type toType);
    private static Func`2<T1, T2> CreateCtorLambdaClosure(ConstructorInfo ctor, Type realParamType, bool useExplicitConversion);
    internal static PSConverter`1<object> FigureConstructorConversion(Type fromType, Type toType);
    private static bool IsIntegralType(Type type);
    internal static PSConverter`1<object> FigurePropertyConversion(Type fromType, Type toType, ConversionRank& rank);
    internal static PSConverter`1<object> FigureCastConversion(Type fromType, Type toType, ConversionRank& rank);
    private static bool TypeConverterPossiblyExists(Type type);
    internal static IConversionData FigureConversion(Type fromType, Type toType);
    private static IConversionData FigureConversionFromNull(Type toType);
    internal static string ObjectToTypeNameString(object o);
}
public class System.Management.Automation.LineBreakpoint : Breakpoint {
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SequencePointIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptExtent[] <SequencePoints>k__BackingField;
    [CompilerGeneratedAttribute]
private BitArray <BreakpointBitArray>k__BackingField;
    public int Column { get; }
    public int Line { get; }
    internal int SequencePointIndex { get; internal set; }
    internal IScriptExtent[] SequencePoints { get; internal set; }
    internal BitArray BreakpointBitArray { get; internal set; }
    public LineBreakpoint(string script, int line);
    public LineBreakpoint(string script, int line, ScriptBlock action);
    public LineBreakpoint(string script, int line, int column);
    public LineBreakpoint(string script, int line, int column, ScriptBlock action);
    public LineBreakpoint(string script, int line, int column, int id);
    public LineBreakpoint(string script, int line, int column, ScriptBlock action, int id);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public int get_Line();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
internal int get_SequencePointIndex();
    [CompilerGeneratedAttribute]
internal void set_SequencePointIndex(int value);
    [CompilerGeneratedAttribute]
internal IScriptExtent[] get_SequencePoints();
    [CompilerGeneratedAttribute]
internal void set_SequencePoints(IScriptExtent[] value);
    [CompilerGeneratedAttribute]
internal BitArray get_BreakpointBitArray();
    [CompilerGeneratedAttribute]
internal void set_BreakpointBitArray(BitArray value);
    internal bool TrySetBreakpoint(string scriptFile, FunctionContext functionContext);
    private static IScriptExtent FindSequencePoint(FunctionContext functionContext, int line, int column, Int32& sequencePointIndex);
    private void SetBreakpoint(FunctionContext functionContext, int sequencePointIndex);
    internal virtual bool RemoveSelf(ScriptDebugger debugger);
    [CompilerGeneratedAttribute]
private bool <RemoveSelf>b__29_0(LineBreakpoint breakpoint);
}
public class System.Management.Automation.ListControl : PSControl {
    [CompilerGeneratedAttribute]
private List`1<ListControlEntry> <Entries>k__BackingField;
    public List`1<ListControlEntry> Entries { get; internal set; }
    internal ListControl(ListControlBody listcontrolbody, ViewDefinition viewDefinition);
    public ListControl(IEnumerable`1<ListControlEntry> entries);
    [CompilerGeneratedAttribute]
public List`1<ListControlEntry> get_Entries();
    [CompilerGeneratedAttribute]
internal void set_Entries(List`1<ListControlEntry> value);
    public static ListControlBuilder Create(bool outOfBand);
    internal virtual void WriteToXml(FormatXmlWriter writer);
    internal virtual bool SafeForExport();
    internal virtual bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.ListControlBuilder : object {
    internal ListControl _list;
    internal ListControlBuilder(ListControl list);
    public ListControlBuilder GroupByProperty(string property, CustomControl customControl, string label);
    public ListControlBuilder GroupByScriptBlock(string scriptBlock, CustomControl customControl, string label);
    public ListEntryBuilder StartEntry(IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    public ListControl EndList();
}
public class System.Management.Automation.ListControlEntry : object {
    [CompilerGeneratedAttribute]
private List`1<ListControlEntryItem> <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private EntrySelectedBy <EntrySelectedBy>k__BackingField;
    public List`1<ListControlEntryItem> Items { get; internal set; }
    public List`1<string> SelectedBy { get; }
    public EntrySelectedBy EntrySelectedBy { get; internal set; }
    internal ListControlEntry(ListControlEntryDefinition entrydefn);
    public ListControlEntry(IEnumerable`1<ListControlEntryItem> listItems);
    public ListControlEntry(IEnumerable`1<ListControlEntryItem> listItems, IEnumerable`1<string> selectedBy);
    [CompilerGeneratedAttribute]
public List`1<ListControlEntryItem> get_Items();
    [CompilerGeneratedAttribute]
internal void set_Items(List`1<ListControlEntryItem> value);
    public List`1<string> get_SelectedBy();
    [CompilerGeneratedAttribute]
public EntrySelectedBy get_EntrySelectedBy();
    [CompilerGeneratedAttribute]
internal void set_EntrySelectedBy(EntrySelectedBy value);
    internal bool SafeForExport();
    internal bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.ListControlEntryItem : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayEntry <DisplayEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayEntry <ItemSelectionCondition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    public string Label { get; internal set; }
    public DisplayEntry DisplayEntry { get; internal set; }
    public DisplayEntry ItemSelectionCondition { get; internal set; }
    public string FormatString { get; internal set; }
    internal ListControlEntryItem(ListControlItemDefinition definition);
    public ListControlEntryItem(string label, DisplayEntry entry);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
internal void set_Label(string value);
    [CompilerGeneratedAttribute]
public DisplayEntry get_DisplayEntry();
    [CompilerGeneratedAttribute]
internal void set_DisplayEntry(DisplayEntry value);
    [CompilerGeneratedAttribute]
public DisplayEntry get_ItemSelectionCondition();
    [CompilerGeneratedAttribute]
internal void set_ItemSelectionCondition(DisplayEntry value);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
internal void set_FormatString(string value);
    internal bool SafeForExport();
    internal bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.ListEntryBuilder : object {
    private ListControlBuilder _listBuilder;
    internal ListControlEntry _listEntry;
    internal ListEntryBuilder(ListControlBuilder listBuilder, ListControlEntry listEntry);
    private ListEntryBuilder AddItem(string value, string label, DisplayEntryValueType kind, string format);
    public ListEntryBuilder AddItemScriptBlock(string scriptBlock, string label, string format);
    public ListEntryBuilder AddItemProperty(string property, string label, string format);
    public ListControlBuilder EndEntry();
}
internal class System.Management.Automation.LocalVariable : PSVariable {
    private MutableTuple _tuple;
    private int _tupleSlot;
    public ScopedItemOptions Options { get; public set; }
    public object Value { get; public set; }
    public LocalVariable(string name, MutableTuple tuple, int tupleSlot);
    public virtual ScopedItemOptions get_Options();
    public virtual void set_Options(ScopedItemOptions value);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    internal virtual object GetValueRaw();
    internal virtual void SetValueRaw(object newValue, bool preserveValueTypeSemantics);
}
public class System.Management.Automation.LocationChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PathInfo <OldPath>k__BackingField;
    [CompilerGeneratedAttribute]
private PathInfo <NewPath>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionState <SessionState>k__BackingField;
    public PathInfo OldPath { get; internal set; }
    public PathInfo NewPath { get; internal set; }
    public SessionState SessionState { get; internal set; }
    internal LocationChangedEventArgs(SessionState sessionState, PathInfo oldPath, PathInfo newPath);
    [CompilerGeneratedAttribute]
public PathInfo get_OldPath();
    [CompilerGeneratedAttribute]
internal void set_OldPath(PathInfo value);
    [CompilerGeneratedAttribute]
public PathInfo get_NewPath();
    [CompilerGeneratedAttribute]
internal void set_NewPath(PathInfo value);
    [CompilerGeneratedAttribute]
public SessionState get_SessionState();
    [CompilerGeneratedAttribute]
internal void set_SessionState(SessionState value);
}
internal class System.Management.Automation.LocationGlobber : object {
    [TraceSourceAttribute("LocationGlobber", "The location globber converts PowerShell paths with glob characters to zero or more paths.")]
private static PSTraceSource s_tracer;
    [TraceSourceAttribute("PathResolution", "Traces the path resolution algorithm.")]
private static PSTraceSource s_pathResolutionTracer;
    private SessionState _sessionState;
    internal LocationGlobber(SessionState sessionState);
    private static LocationGlobber();
    internal Collection`1<PathInfo> GetGlobbedMonadPathsFromMonadPath(string path, bool allowNonexistingPaths, CmdletProvider& providerInstance);
    internal Collection`1<PathInfo> GetGlobbedMonadPathsFromMonadPath(string path, bool allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance);
    private Collection`1<string> ResolveProviderPathFromProviderPath(string providerPath, string providerId, bool allowNonexistingPaths, CmdletProviderContext context, CmdletProvider& providerInstance);
    private Collection`1<PathInfo> ResolvePSPathFromProviderPath(string path, CmdletProviderContext context, bool allowNonexistingPaths, bool isProviderDirectPath, bool isProviderQualifiedPath, CmdletProvider& providerInstance);
    private Collection`1<PathInfo> ResolveDriveQualifiedPath(string path, CmdletProviderContext context, bool allowNonexistingPaths, CmdletProvider& providerInstance);
    internal Collection`1<string> GetGlobbedProviderPathsFromMonadPath(string path, bool allowNonexistingPaths, ProviderInfo& provider, CmdletProvider& providerInstance);
    internal Collection`1<string> GetGlobbedProviderPathsFromMonadPath(string path, bool allowNonexistingPaths, CmdletProviderContext context, ProviderInfo& provider, CmdletProvider& providerInstance);
    internal Collection`1<string> GetGlobbedProviderPathsFromProviderPath(string path, bool allowNonexistingPaths, string providerId, CmdletProvider& providerInstance);
    internal Collection`1<string> GetGlobbedProviderPathsFromProviderPath(string path, bool allowNonexistingPaths, string providerId, CmdletProviderContext context, CmdletProvider& providerInstance);
    internal string GetProviderPath(string path);
    internal string GetProviderPath(string path, ProviderInfo& provider);
    internal string GetProviderPath(string path, CmdletProviderContext context);
    internal string GetProviderPath(string path, CmdletProviderContext context, ProviderInfo& provider, PSDriveInfo& drive);
    internal string GetProviderPath(string path, CmdletProviderContext context, bool isTrusted, ProviderInfo& provider, PSDriveInfo& drive);
    internal static bool IsProviderQualifiedPath(string path);
    internal static bool IsProviderQualifiedPath(string path, String& providerId);
    internal static bool IsSingleFileSystemAbsolutePath(string path);
    internal static bool IsAbsolutePath(string path);
    internal bool IsAbsolutePath(string path, String& driveName);
    private static string RemoveGlobEscaping(string path);
    internal bool IsShellVirtualDrive(string driveName, SessionStateScope& scope);
    internal string GetDriveRootRelativePathFromPSPath(string path, CmdletProviderContext context, bool escapeCurrentLocation, PSDriveInfo& workingDriveForPath, CmdletProvider& providerInstance);
    private string GetDriveRootRelativePathFromProviderPath(string providerPath, PSDriveInfo drive, CmdletProviderContext context);
    internal string GenerateRelativePath(PSDriveInfo drive, string path, bool escapeCurrentLocation, CmdletProvider providerInstance, CmdletProviderContext context);
    private static bool HasRelativePathTokens(string path);
    private string GetProviderSpecificPath(PSDriveInfo drive, string workingPath, CmdletProviderContext context);
    private static string ParseProviderPath(string path, String& providerId);
    internal Collection`1<string> GetGlobbedProviderPathsFromProviderPath(string path, bool allowNonexistingPaths, ContainerCmdletProvider containerProvider, CmdletProviderContext context);
    internal static bool StringContainsGlobCharacters(string path);
    internal static bool ShouldPerformGlobbing(string path, CmdletProviderContext context);
    private Collection`1<string> ExpandMshGlobPath(string path, bool allowNonexistingPaths, PSDriveInfo drive, ContainerCmdletProvider provider, CmdletProviderContext context);
    internal static string GetMshQualifiedPath(string path, PSDriveInfo drive);
    internal static string RemoveMshQualifier(string path, PSDriveInfo drive);
    internal static string GetDriveQualifiedPath(string path, PSDriveInfo drive);
    private static string RemoveDriveQualifier(string path);
    internal static string GetProviderQualifiedPath(string path, ProviderInfo provider);
    internal static string RemoveProviderQualifier(string path);
    private List`1<string> GenerateNewPSPathsWithGlobLeaf(List`1<string> currentDirs, PSDriveInfo drive, string leafElement, bool isLastLeaf, ContainerCmdletProvider provider, CmdletProviderContext context);
    internal Collection`1<string> ExpandGlobPath(string path, bool allowNonexistingPaths, ContainerCmdletProvider provider, CmdletProviderContext context);
    internal List`1<string> GenerateNewPathsWithGlobLeaf(List`1<string> currentDirs, string leafElement, bool isLastLeaf, ContainerCmdletProvider provider, CmdletProviderContext context);
    private Collection`1<PSObject> GetChildNamesInDir(string dir, string leafElement, bool getAllContainers, CmdletProviderContext context, bool dirIsProviderPath, PSDriveInfo drive, ContainerCmdletProvider provider, String& modifiedDirPath);
    private static bool IsChildNameAMatch(PSObject childObject, WildcardPattern stringMatcher, Collection`1<WildcardPattern> includeMatcher, Collection`1<WildcardPattern> excludeMatcher, String& childName);
    private static string ConvertMshEscapeToRegexEscape(string path);
    internal static bool IsHomePath(string path);
    internal static bool IsProviderDirectPath(string path);
    internal string GetHomeRelativePath(string path);
    private static void TraceFilters(CmdletProviderContext context);
}
internal class System.Management.Automation.LogContext : object {
    [CompilerGeneratedAttribute]
private string <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostApplication>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HostId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EngineVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RunspaceId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PipelineId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScriptName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SequenceNumber>k__BackingField;
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectedUser>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Time>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShellId>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionContext <ExecutionContext>k__BackingField;
    internal string Severity { get; internal set; }
    internal string HostName { get; internal set; }
    internal string HostApplication { get; internal set; }
    internal string HostVersion { get; internal set; }
    internal string HostId { get; internal set; }
    internal string EngineVersion { get; internal set; }
    internal string RunspaceId { get; internal set; }
    internal string PipelineId { get; internal set; }
    internal string CommandName { get; internal set; }
    internal string CommandType { get; internal set; }
    internal string ScriptName { get; internal set; }
    internal string CommandPath { get; internal set; }
    internal string CommandLine { get; internal set; }
    internal string SequenceNumber { get; internal set; }
    internal string User { get; internal set; }
    internal string ConnectedUser { get; internal set; }
    internal string Time { get; internal set; }
    internal string ShellId { get; internal set; }
    internal ExecutionContext ExecutionContext { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Severity();
    [CompilerGeneratedAttribute]
internal void set_Severity(string value);
    [CompilerGeneratedAttribute]
internal string get_HostName();
    [CompilerGeneratedAttribute]
internal void set_HostName(string value);
    [CompilerGeneratedAttribute]
internal string get_HostApplication();
    [CompilerGeneratedAttribute]
internal void set_HostApplication(string value);
    [CompilerGeneratedAttribute]
internal string get_HostVersion();
    [CompilerGeneratedAttribute]
internal void set_HostVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_HostId();
    [CompilerGeneratedAttribute]
internal void set_HostId(string value);
    [CompilerGeneratedAttribute]
internal string get_EngineVersion();
    [CompilerGeneratedAttribute]
internal void set_EngineVersion(string value);
    [CompilerGeneratedAttribute]
internal string get_RunspaceId();
    [CompilerGeneratedAttribute]
internal void set_RunspaceId(string value);
    [CompilerGeneratedAttribute]
internal string get_PipelineId();
    [CompilerGeneratedAttribute]
internal void set_PipelineId(string value);
    [CompilerGeneratedAttribute]
internal string get_CommandName();
    [CompilerGeneratedAttribute]
internal void set_CommandName(string value);
    [CompilerGeneratedAttribute]
internal string get_CommandType();
    [CompilerGeneratedAttribute]
internal void set_CommandType(string value);
    [CompilerGeneratedAttribute]
internal string get_ScriptName();
    [CompilerGeneratedAttribute]
internal void set_ScriptName(string value);
    [CompilerGeneratedAttribute]
internal string get_CommandPath();
    [CompilerGeneratedAttribute]
internal void set_CommandPath(string value);
    [CompilerGeneratedAttribute]
internal string get_CommandLine();
    [CompilerGeneratedAttribute]
internal void set_CommandLine(string value);
    [CompilerGeneratedAttribute]
internal string get_SequenceNumber();
    [CompilerGeneratedAttribute]
internal void set_SequenceNumber(string value);
    [CompilerGeneratedAttribute]
internal string get_User();
    [CompilerGeneratedAttribute]
internal void set_User(string value);
    [CompilerGeneratedAttribute]
internal string get_ConnectedUser();
    [CompilerGeneratedAttribute]
internal void set_ConnectedUser(string value);
    [CompilerGeneratedAttribute]
internal string get_Time();
    [CompilerGeneratedAttribute]
internal void set_Time(string value);
    [CompilerGeneratedAttribute]
internal string get_ShellId();
    [CompilerGeneratedAttribute]
internal void set_ShellId(string value);
    [CompilerGeneratedAttribute]
internal ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
internal void set_ExecutionContext(ExecutionContext value);
}
internal class System.Management.Automation.LogContextCache : object {
    [CompilerGeneratedAttribute]
private string <User>k__BackingField;
    internal string User { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_User();
    [CompilerGeneratedAttribute]
internal void set_User(string value);
}
internal abstract class System.Management.Automation.LogProvider : object {
    private static int LogContextInitialSize;
    internal abstract virtual void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary`2<string, string> additionalInfo);
    internal abstract virtual void LogEngineLifecycleEvent(LogContext logContext, EngineState newState, EngineState previousState);
    internal abstract virtual void LogCommandHealthEvent(LogContext logContext, Exception exception);
    internal abstract virtual void LogCommandLifecycleEvent(Func`1<LogContext> getLogContext, CommandState newState);
    internal abstract virtual void LogPipelineExecutionDetailEvent(LogContext logContext, List`1<string> pipelineExecutionDetail);
    internal abstract virtual void LogProviderHealthEvent(LogContext logContext, string providerName, Exception exception);
    internal abstract virtual void LogProviderLifecycleEvent(LogContext logContext, string providerName, ProviderState newState);
    internal abstract virtual void LogSettingsEvent(LogContext logContext, string variableName, string value, string previousValue);
    internal abstract virtual void LogAmsiUtilStateEvent(string state, string context);
    internal abstract virtual void LogWDACQueryEvent(string queryName, string fileName, int querySuccess, int queryResult);
    internal abstract virtual void LogWDACAuditEvent(string title, string message, string fqid);
    internal virtual bool UseLoggingVariables();
    protected static string GetPSLogUserData(ExecutionContext context);
    protected static void AppendException(StringBuilder sb, Exception except);
    protected static void AppendAdditionalInfo(StringBuilder sb, Dictionary`2<string, string> additionalInfo);
    protected static PSLevel GetPSLevelFromSeverity(string severity);
    protected static string LogContextToString(LogContext context);
}
internal static class System.Management.Automation.LongOps : object {
    internal static object Add(long lhs, long rhs);
    internal static object Sub(long lhs, long rhs);
    internal static object Multiply(long lhs, long rhs);
    internal static object Divide(long lhs, long rhs);
    internal static object Remainder(long lhs, long rhs);
    internal static object CompareEq(long lhs, long rhs);
    internal static object CompareNe(long lhs, long rhs);
    internal static object CompareLt(long lhs, long rhs);
    internal static object CompareLe(long lhs, long rhs);
    internal static object CompareGt(long lhs, long rhs);
    internal static object CompareGe(long lhs, long rhs);
}
internal class System.Management.Automation.LookupPathCollection : Collection`1<string> {
    internal LookupPathCollection(IEnumerable`1<string> collection);
    public int Add(string item);
    internal void AddRange(ICollection`1<string> collection);
    public bool Contains(string item);
    internal Collection`1<int> IndexOfRelativePath();
    public int IndexOf(string item);
}
public abstract class System.Management.Automation.LoopFlowException : FlowControlException {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    public string Label { get; internal set; }
    internal LoopFlowException(string label);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
internal void set_Label(string value);
    internal bool MatchLabel(string loopLabel);
    internal static bool MatchLoopLabel(string flowLabel, string loopLabel);
}
internal class System.Management.Automation.MamlClassHelpInfo : HelpInfo {
    private PSObject _fullHelpObject;
    [CompilerGeneratedAttribute]
private HelpCategory <HelpCategory>k__BackingField;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSObject FullHelp { get; }
    internal MamlClassHelpInfo(PSObject helpObject, HelpCategory helpCategory);
    private MamlClassHelpInfo(XmlNode xmlNode, HelpCategory helpCategory);
    internal static MamlClassHelpInfo Load(XmlNode xmlNode, HelpCategory helpCategory);
    internal MamlClassHelpInfo Copy();
    internal MamlClassHelpInfo Copy(HelpCategory newCategoryToUse);
    internal virtual string get_Name();
    internal virtual string get_Synopsis();
    [CompilerGeneratedAttribute]
internal virtual HelpCategory get_HelpCategory();
    internal virtual PSObject get_FullHelp();
}
internal class System.Management.Automation.MamlCommandHelpInfo : BaseCommandHelpInfo {
    private PSObject _fullHelpObject;
    private string _component;
    private string _role;
    private string _functionality;
    internal PSObject FullHelp { get; }
    private string Examples { get; }
    private string Parameters { get; }
    private string Notes { get; }
    internal string Component { get; }
    internal string Role { get; }
    internal string Functionality { get; }
    internal MamlCommandHelpInfo(PSObject helpObject, HelpCategory helpCategory);
    private MamlCommandHelpInfo(XmlNode xmlNode, HelpCategory helpCategory);
    internal void OverrideProviderSpecificHelpWithGenericHelp(HelpInfo genericHelpInfo);
    internal virtual PSObject get_FullHelp();
    private string get_Examples();
    private string get_Parameters();
    private string get_Notes();
    internal virtual string get_Component();
    internal virtual string get_Role();
    internal virtual string get_Functionality();
    internal void SetAdditionalDataFromHelpComment(string component, string functionality, string role);
    internal void AddUserDefinedData(UserDefinedHelpData userDefinedData);
    internal static MamlCommandHelpInfo Load(XmlNode xmlNode, HelpCategory helpCategory);
    private static string ExtractTextForHelpProperty(PSObject psObject, string propertyName);
    private static string ExtractText(PSObject psObject);
    internal virtual bool MatchPatternInContent(WildcardPattern pattern);
    internal MamlCommandHelpInfo Copy();
    internal MamlCommandHelpInfo Copy(HelpCategory newCategoryToUse);
}
internal class System.Management.Automation.MamlNode : object {
    private XmlNode _xmlNode;
    private PSObject _mshObject;
    [CompilerGeneratedAttribute]
private Collection`1<ErrorRecord> <Errors>k__BackingField;
    internal XmlNode XmlNode { get; }
    internal PSObject PSObject { get; }
    internal Collection`1<ErrorRecord> Errors { get; }
    internal MamlNode(XmlNode xmlNode);
    internal XmlNode get_XmlNode();
    internal PSObject get_PSObject();
    private PSObject GetPSObject(XmlNode xmlNode);
    private PSObject GetInsidePSObject(XmlNode xmlNode);
    private Hashtable GetInsideProperties(XmlNode xmlNode);
    private static void RemoveUnsupportedNodes(XmlNode xmlNode);
    private static void AddProperty(Hashtable properties, string name, PSObject mshObject);
    private static Hashtable SimplifyProperties(Hashtable properties);
    private static bool IsAtomic(XmlNode xmlNode);
    private static bool IncludeMamlFormatting(XmlNode xmlNode);
    private static bool IsMamlFormattingNode(XmlNode xmlNode);
    private static bool IsMamlFormattingPSObject(PSObject mshObject);
    private PSObject[] GetMamlFormattingPSObjects(XmlNode xmlNode);
    private static int GetParaMamlNodeCount(XmlNodeList nodes);
    private void WriteMamlInvalidChildNodeError(XmlNode node, XmlNode childNode);
    private void WriteMamlInvalidChildNodeCountError(XmlNode node, string childNodeName, int count);
    private static string GetNodePath(XmlNode xmlNode);
    private static string GetNodeIndex(XmlNode xmlNode);
    private static PSObject GetParaPSObject(XmlNode xmlNode, bool newLine, bool trim);
    private ArrayList GetListPSObjects(XmlNode xmlNode);
    private static bool IsOrderedList(XmlNode xmlNode);
    private PSObject GetListItemPSObject(XmlNode xmlNode, bool ordered, Int32& index);
    private ArrayList GetDefinitionListPSObjects(XmlNode xmlNode);
    private PSObject GetDefinitionListItemPSObject(XmlNode xmlNode);
    private string GetDefinitionText(XmlNode xmlNode);
    private static string GetPreformattedText(string text);
    private static String[] TrimLines(String[] lines);
    private static int GetMinIndentation(String[] lines);
    private static int GetIndentation(string line);
    private static bool IsEmptyLine(string line);
    [CompilerGeneratedAttribute]
internal Collection`1<ErrorRecord> get_Errors();
}
internal static class System.Management.Automation.MamlUtil : object {
    internal static void OverrideName(PSObject maml1, PSObject maml2);
    internal static void OverridePSTypeNames(PSObject maml1, PSObject maml2);
    internal static void AddCommonProperties(PSObject maml1, PSObject maml2);
    internal static void PrependSyntax(PSObject maml1, PSObject maml2);
    internal static void PrependDetailedDescription(PSObject maml1, PSObject maml2);
    internal static void OverrideParameters(PSObject maml1, PSObject maml2);
    internal static void PrependNotes(PSObject maml1, PSObject maml2);
    internal static PSPropertyInfo GetPropertyInfo(PSObject psObject, String[] path);
    internal static void PrependPropertyValue(PSObject maml1, PSObject maml2, String[] path, bool shouldOverride);
    internal static void EnsurePropertyInfoPathExists(PSObject psObject, String[] path);
}
internal class System.Management.Automation.ManagementClassApdapter : BaseWMIAdapter {
    protected virtual void AddAllProperties(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(ManagementBaseObject wmiObject, string propertyName);
    protected virtual object InvokeManagementMethod(ManagementObject wmiObject, string methodName, ManagementBaseObject inParams);
    protected virtual void AddAllMethods(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected virtual T GetManagementObjectMethod(ManagementBaseObject wmiObject, string methodName);
    protected virtual T GetFirstOrDefaultProperty(ManagementBaseObject wmiObject, MemberNamePredicate predicate);
    protected virtual T GetFirstOrDefaultMethod(ManagementBaseObject wmiObject, MemberNamePredicate predicate);
}
internal class System.Management.Automation.ManagementObjectAdapter : ManagementClassApdapter {
    protected virtual void AddAllProperties(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(ManagementBaseObject wmiObject, string propertyName);
    protected virtual object InvokeManagementMethod(ManagementObject obj, string methodName, ManagementBaseObject inParams);
    protected virtual void AddAllMethods(ManagementBaseObject wmiObject, PSMemberInfoInternalCollection`1<T> members);
    protected virtual T GetManagementObjectMethod(ManagementBaseObject wmiObject, string methodName);
}
internal static class System.Management.Automation.MemberInvocationLoggingOps : object {
    private static Lazy`1<bool> DumpLogAMSIContent;
    private static MemberInvocationLoggingOps();
    private static string ArgumentToString(object arg);
    internal static void LogMemberInvocation(string targetName, string name, Object[] args);
}
internal static class System.Management.Automation.MemberMatch : object {
    internal static WildcardPattern GetNamePattern(string name);
    internal static PSMemberInfoInternalCollection`1<T> Match(PSMemberInfoInternalCollection`1<T> memberList, string name, WildcardPattern nameMatch, PSMemberTypes memberTypes);
}
public class System.Management.Automation.MemberNamePredicate : MulticastDelegate {
    public MemberNamePredicate(object object, IntPtr method);
    public virtual bool Invoke(string memberName);
    public virtual IAsyncResult BeginInvoke(string memberName, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal abstract class System.Management.Automation.MemberRedirectionAdapter : Adapter {
    protected virtual AttributeCollection PropertyAttributes(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    protected virtual string PropertyToString(PSProperty property);
    protected virtual object MethodInvoke(PSMethod method, Object[] arguments);
    protected virtual Collection`1<string> MethodDefinitions(PSMethod method);
}
internal class System.Management.Automation.MergedCommandParameterMetadata : object {
    private UInt32 _nextAvailableParameterSetIndex;
    private static UInt32 MaxParameterSetCount;
    private IList`1<string> _parameterSetMap;
    private string _defaultParameterSetName;
    private IDictionary`2<string, MergedCompiledCommandParameter> _bindableParameters;
    private IDictionary`2<string, MergedCompiledCommandParameter> _aliasedParameters;
    internal int ParameterSetCount { get; }
    internal UInt32 AllParameterSetFlags { get; }
    internal IDictionary`2<string, MergedCompiledCommandParameter> BindableParameters { get; }
    internal IDictionary`2<string, MergedCompiledCommandParameter> AliasedParameters { get; }
    internal List`1<MergedCompiledCommandParameter> ReplaceMetadata(MergedCommandParameterMetadata metadata);
    internal Collection`1<MergedCompiledCommandParameter> AddMetadataForBinder(InternalParameterMetadata parameterMetadata, ParameterBinderAssociation binderAssociation);
    internal int get_ParameterSetCount();
    internal UInt32 get_AllParameterSetFlags();
    private int AddParameterSetToMap(string parameterSetName);
    internal UInt32 GenerateParameterSetMappingFromMetadata(string defaultParameterSetName);
    internal string GetParameterSetName(UInt32 parameterSet);
    private static string RetrieveParameterNameForAlias(string key, IDictionary`2<string, MergedCompiledCommandParameter> dict);
    internal MergedCompiledCommandParameter GetMatchingParameter(string name, bool throwOnParameterNotFound, bool tryExactMatching, InvocationInfo invocationInfo);
    internal Collection`1<MergedCompiledCommandParameter> GetParametersInParameterSet(UInt32 parameterSetFlag);
    internal IDictionary`2<string, MergedCompiledCommandParameter> get_BindableParameters();
    internal IDictionary`2<string, MergedCompiledCommandParameter> get_AliasedParameters();
    internal void MakeReadOnly();
    internal void ResetReadOnly();
}
internal class System.Management.Automation.MergedCompiledCommandParameter : object {
    [CompilerGeneratedAttribute]
private CompiledCommandParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterBinderAssociation <BinderAssociation>k__BackingField;
    internal CompiledCommandParameter Parameter { get; }
    internal ParameterBinderAssociation BinderAssociation { get; }
    internal MergedCompiledCommandParameter(CompiledCommandParameter parameter, ParameterBinderAssociation binderAssociation);
    [CompilerGeneratedAttribute]
internal CompiledCommandParameter get_Parameter();
    [CompilerGeneratedAttribute]
internal ParameterBinderAssociation get_BinderAssociation();
    public virtual string ToString();
}
internal class System.Management.Automation.MergingRedirection : CommandRedirection {
    internal MergingRedirection(RedirectionStream from, RedirectionStream to);
    public virtual string ToString();
    internal virtual void Bind(PipelineProcessor pipelineProcessor, CommandProcessorBase commandProcessor, ExecutionContext context);
    internal Pipe[] BindForExpression(ExecutionContext context, FunctionContext funcContext);
}
public class System.Management.Automation.MetadataException : RuntimeException {
    internal static string MetadataMemberInitialization;
    internal static string BaseName;
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected MetadataException(SerializationInfo info, StreamingContext context);
    public MetadataException(string message);
    public MetadataException(string message, Exception innerException);
    internal MetadataException(string errorId, Exception innerException, string resourceStr, Object[] arguments);
}
public class System.Management.Automation.MethodException : ExtendedTypeSystemException {
    internal static string MethodArgumentCountExceptionMsg;
    internal static string MethodAmbiguousExceptionMsg;
    internal static string MethodArgumentConversionExceptionMsg;
    internal static string NonRefArgumentToRefParameterMsg;
    internal static string RefArgumentToNonRefParameterMsg;
    public MethodException(string message);
    public MethodException(string message, Exception innerException);
    internal MethodException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected MethodException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.Management.Automation.MethodGroup : object {
}
internal class System.Management.Automation.MethodGroup`1 : MethodGroup {
}
internal class System.Management.Automation.MethodGroup`16 : MethodGroup {
}
internal class System.Management.Automation.MethodGroup`2 : MethodGroup {
}
internal class System.Management.Automation.MethodGroup`32 : MethodGroup {
}
internal class System.Management.Automation.MethodGroup`4 : MethodGroup {
}
internal class System.Management.Automation.MethodGroup`8 : MethodGroup {
}
[DebuggerDisplayAttribute("MethodInformation: {methodDefinition}")]
internal class System.Management.Automation.MethodInformation : object {
    internal MethodBase method;
    private string _cachedMethodDefinition;
    internal ParameterInformation[] parameters;
    internal bool hasVarArgs;
    internal bool hasOptional;
    internal bool isGeneric;
    private bool _useReflection;
    private MethodInvoker _methodInvoker;
    private static OpCode[] s_ldc;
    internal string methodDefinition { get; }
    internal MethodInformation(MethodBase method, int parametersToIgnore);
    internal MethodInformation(bool hasvarargs, bool hasoptional, ParameterInformation[] arguments);
    private static MethodInformation();
    internal string get_methodDefinition();
    internal object Invoke(object target, Object[] arguments);
    private static void EmitLdc(ILGenerator emitter, int c);
    private static bool CompareMethodParameters(MethodBase method1, MethodBase method2);
    private static Type FindInterfaceForMethod(MethodInfo method, MethodInfo& methodToCall);
    private MethodInvoker GetMethodInvoker(MethodInfo method);
}
public class System.Management.Automation.MethodInvocationException : MethodException {
    internal static string MethodInvocationExceptionMsg;
    internal static string CopyToInvocationExceptionMsg;
    internal static string WMIMethodInvocationException;
    public MethodInvocationException(string message);
    public MethodInvocationException(string message, Exception innerException);
    internal MethodInvocationException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected MethodInvocationException(SerializationInfo info, StreamingContext context);
}
internal class System.Management.Automation.MinishellParameterBinderController : NativeCommandParameterBinderController {
    [CompilerGeneratedAttribute]
private NativeCommandIOFormat <InputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private NativeCommandIOFormat <OutputFormat>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NonInteractive>k__BackingField;
    private static Collection`1<CommandParameterInternal> s_emptyReturnCollection;
    internal static string CommandParameter;
    internal static string EncodedCommandParameter;
    internal static string ArgsParameter;
    internal static string EncodedArgsParameter;
    internal static string InputFormatParameter;
    internal static string OutputFormatParameter;
    internal static string XmlFormatValue;
    internal static string TextFormatValue;
    internal static string NonInteractiveParameter;
    internal NativeCommandIOFormat InputFormat { get; private set; }
    internal NativeCommandIOFormat OutputFormat { get; private set; }
    internal bool NonInteractive { get; private set; }
    internal MinishellParameterBinderController(NativeCommand command);
    private static MinishellParameterBinderController();
    [CompilerGeneratedAttribute]
internal NativeCommandIOFormat get_InputFormat();
    [CompilerGeneratedAttribute]
private void set_InputFormat(NativeCommandIOFormat value);
    [CompilerGeneratedAttribute]
internal NativeCommandIOFormat get_OutputFormat();
    [CompilerGeneratedAttribute]
private void set_OutputFormat(NativeCommandIOFormat value);
    [CompilerGeneratedAttribute]
internal bool get_NonInteractive();
    [CompilerGeneratedAttribute]
private void set_NonInteractive(bool value);
    internal Collection`1<CommandParameterInternal> BindParameters(Collection`1<CommandParameterInternal> parameters, bool outputRedirected, string hostName);
    private void HandleSeenParameter(MinishellParameters& seen, MinishellParameters parameter, string parameterName);
    private string ProcessFormatParameterValue(string parameterName, object value);
    private static string ConvertArgsValueToEncodedString(object value);
    private static ArrayList ConvertArgsValueToArrayList(object value);
    private ParameterBindingException NewParameterBindingException(Exception innerException, ErrorCategory errorCategory, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
}
internal enum System.Management.Automation.MinishellStream : Enum {
    public int value__;
    public static MinishellStream Output;
    public static MinishellStream Error;
    public static MinishellStream Verbose;
    public static MinishellStream Warning;
    public static MinishellStream Debug;
    public static MinishellStream Progress;
    public static MinishellStream Information;
    public static MinishellStream Unknown;
}
public enum System.Management.Automation.ModuleAccessMode : Enum {
    public int value__;
    public static ModuleAccessMode ReadWrite;
    public static ModuleAccessMode ReadOnly;
    public static ModuleAccessMode Constant;
}
[DebuggerDisplayAttribute("ModulePath = {ModulePath}")]
internal class System.Management.Automation.ModuleCacheEntry : object {
    public DateTime LastWriteTime;
    public string ModulePath;
    public bool TypesAnalyzed;
    public ConcurrentDictionary`2<string, CommandTypes> Commands;
    public ConcurrentDictionary`2<string, TypeAttributes> Types;
}
public class System.Management.Automation.ModuleIntrinsics : object {
    [TraceSourceAttribute("Modules", "Module loading and analysis")]
internal static PSTraceSource Tracer;
    private static string s_windowsPowerShellPSHomeModulePath;
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PSModuleInfo> <ModuleTable>k__BackingField;
    private static int MaxModuleNestingDepth;
    [CompilerGeneratedAttribute]
private int <ModuleNestingDepth>k__BackingField;
    internal static String[] PSModuleProcessableExtensions;
    internal static String[] PSModuleExtensions;
    internal static String[] ProcessableAssemblyExtensions;
    private static string s_psHomeModulePath;
    internal Dictionary`2<string, PSModuleInfo> ModuleTable { get; }
    internal int ModuleNestingDepth { get; private set; }
    internal ModuleIntrinsics(ExecutionContext context);
    private static ModuleIntrinsics();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, PSModuleInfo> get_ModuleTable();
    internal void IncrementModuleNestingDepth(PSCmdlet cmdlet, string path);
    internal void DecrementModuleNestingCount();
    [CompilerGeneratedAttribute]
internal int get_ModuleNestingDepth();
    [CompilerGeneratedAttribute]
private void set_ModuleNestingDepth(int value);
    internal PSModuleInfo CreateModule(string name, string path, ScriptBlock scriptBlock, SessionState ss, List`1& results, Object[] arguments);
    internal PSModuleInfo CreateModule(string path, ExternalScriptInfo scriptInfo, IScriptExtent scriptPosition, SessionState ss, object privateData, Object[] arguments);
    private PSModuleInfo CreateModuleImplementation(string name, string path, object moduleCode, IScriptExtent scriptPosition, SessionState ss, object privateData, List`1& result, Object[] arguments);
    internal ScriptBlock CreateBoundScriptBlock(ExecutionContext context, ScriptBlock sb, bool linkToGlobal);
    internal List`1<PSModuleInfo> GetModules(String[] patterns, bool all);
    internal List`1<PSModuleInfo> GetExactMatchModules(string moduleName, bool all, bool exactMatch);
    private List`1<PSModuleInfo> GetModuleCore(String[] patterns, bool all, bool exactMatch);
    internal List`1<PSModuleInfo> GetModules(ModuleSpecification[] fullyQualifiedName, bool all);
    internal static bool IsModuleMatchingModuleSpec(PSModuleInfo moduleInfo, ModuleSpecification moduleSpec, bool skipNameCheck);
    internal static bool IsModuleMatchingModuleSpec(ModuleMatchFailure& matchFailureReason, PSModuleInfo moduleInfo, ModuleSpecification moduleSpec, bool skipNameCheck);
    internal static bool IsModuleMatchingConstraints(PSModuleInfo moduleInfo, string name, Nullable`1<Guid> guid, Version requiredVersion, Version minimumVersion, Version maximumVersion);
    internal static bool IsModuleMatchingConstraints(ModuleMatchFailure& matchFailureReason, PSModuleInfo moduleInfo, string name, Nullable`1<Guid> guid, Version requiredVersion, Version minimumVersion, Version maximumVersion);
    internal static bool AreModuleFieldsMatchingConstraints(string moduleName, string modulePath, Nullable`1<Guid> moduleGuid, Version moduleVersion, string requiredName, Nullable`1<Guid> requiredGuid, Version requiredVersion, Version minimumRequiredVersion, Version maximumRequiredVersion);
    internal static bool AreModuleFieldsMatchingConstraints(ModuleMatchFailure& matchFailureReason, string moduleName, string modulePath, Nullable`1<Guid> moduleGuid, Version moduleVersion, string requiredName, Nullable`1<Guid> requiredGuid, Version requiredVersion, Version minimumRequiredVersion, Version maximumRequiredVersion);
    internal static bool IsVersionMatchingConstraints(Version version, Version requiredVersion, Version minimumVersion, Version maximumVersion);
    internal static bool IsVersionMatchingConstraints(ModuleMatchFailure& matchFailureReason, Version version, Version requiredVersion, Version minimumVersion, Version maximumVersion);
    internal static bool MatchesModulePath(string modulePath, string requiredPath);
    internal static string NormalizeModuleName(string moduleName, string basePath, ExecutionContext executionContext);
    internal static bool IsModuleNamePath(string moduleName);
    internal static Version GetManifestModuleVersion(string manifestPath);
    internal static Guid GetManifestGuid(string manifestPath);
    internal static ExperimentalFeature[] GetExperimentalFeature(string manifestPath);
    internal static bool IsPowerShellModuleExtension(string extension);
    internal static string GetModuleName(string path);
    internal static string GetPersonalModulePath();
    internal static string GetPSHomeModulePath();
    internal static string GetSharedModulePath();
    internal static string GetWindowsPowerShellPSHomeModulePath();
    private static string CombineSystemModulePaths();
    internal static string GetExpandedEnvironmentVariable(string name, EnvironmentVariableTarget target);
    private static int PathContainsSubstring(string pathToScan, string pathToLookFor);
    private static string AddToPath(string basePath, string pathToAdd, int insertPosition);
    public static string GetPSModulePath(PSModulePathScope scope);
    public static string GetModulePath(string currentProcessModulePath, string hklmMachineModulePath, string hkcuUserModulePath);
    private static string UpdatePath(string path, string pathToAdd, Int32& insertIndex);
    internal static string GetModulePath();
    internal static string GetWindowsPowerShellModulePath();
    private static string SetModulePath();
    [IteratorStateMachineAttribute("System.Management.Automation.ModuleIntrinsics/<GetModulePath>d__57")]
internal static IEnumerable`1<string> GetModulePath(bool includeSystemModulePath, ExecutionContext context);
    private static string ProcessOneModulePath(ExecutionContext context, string envPath, HashSet`1<string> processedPathSet);
    [NullableContextAttribute("1")]
private static void SortAndRemoveDuplicates(List`1<T> input, Func`2<T, string> keyGetter);
    internal static void ExportModuleMembers(PSCmdlet cmdlet, SessionStateInternal sessionState, List`1<WildcardPattern> functionPatterns, List`1<WildcardPattern> cmdletPatterns, List`1<WildcardPattern> aliasPatterns, List`1<WildcardPattern> variablePatterns, List`1<string> doNotExportCmdlets);
    internal static bool PatternContainsWildcard(List`1<WildcardPattern> list);
    private static AliasInfo NewAliasInfo(AliasInfo alias, SessionStateInternal sessionState);
}
internal enum System.Management.Automation.ModuleMatchFailure : Enum {
    public int value__;
    public static ModuleMatchFailure None;
    public static ModuleMatchFailure NullModule;
    public static ModuleMatchFailure Name;
    public static ModuleMatchFailure Guid;
    public static ModuleMatchFailure RequiredVersion;
    public static ModuleMatchFailure MinimumVersion;
    public static ModuleMatchFailure MaximumVersion;
    public static ModuleMatchFailure NullModuleSpecification;
}
public enum System.Management.Automation.ModuleType : Enum {
    public int value__;
    public static ModuleType Script;
    public static ModuleType Binary;
    public static ModuleType Manifest;
    public static ModuleType Cim;
}
internal class System.Management.Automation.MonadTraceSource : TraceSource {
    internal MonadTraceSource(string name);
    protected virtual String[] GetSupportedAttributes();
}
internal class System.Management.Automation.MshCommandRuntime : object {
    [CompilerGeneratedAttribute]
private ExecutionContext <Context>k__BackingField;
    private SessionState _state;
    internal InternalHost CBhost;
    [CompilerGeneratedAttribute]
private PSHost <Host>k__BackingField;
    private Pipe _inputPipe;
    private Pipe _outputPipe;
    private Pipe _errorOutputPipe;
    [CompilerGeneratedAttribute]
private bool <IsClosed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutVariable>k__BackingField;
    private IList _outVarList;
    [CompilerGeneratedAttribute]
private PipelineProcessor <PipelineProcessor>k__BackingField;
    private CommandInfo _commandInfo;
    private InternalCommand _thisCommand;
    private InvocationInfo _myInvocation;
    private static long s_lastUsedSourceId;
    private long _sourceId;
    [CompilerGeneratedAttribute]
private bool <LogPipelineExecutionDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PipelineVariable>k__BackingField;
    private PSVariable _pipelineVarReference;
    private bool _shouldRemovePipelineVariable;
    [CompilerGeneratedAttribute]
private MergeDataStream <ErrorMergeTo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MergeUnclaimedPreviousErrorResults>k__BackingField;
    internal static Object[] StaticEmptyArray;
    [CompilerGeneratedAttribute]
private Pipe <WarningOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <VerboseOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <DebugOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <InformationOutputPipe>k__BackingField;
    private IList _errorVarList;
    [CompilerGeneratedAttribute]
private string <ErrorVariable>k__BackingField;
    private IList _warningVarList;
    [CompilerGeneratedAttribute]
private string <WarningVariable>k__BackingField;
    private IList _informationVarList;
    [CompilerGeneratedAttribute]
private string <InformationVariable>k__BackingField;
    internal bool UseSecurityContextRun;
    private bool _isConfirmPreferenceCached;
    private ConfirmImpact _confirmPreference;
    private bool _isDebugPreferenceSet;
    private ActionPreference _debugPreference;
    private bool _isDebugPreferenceCached;
    private bool _isVerbosePreferenceCached;
    private ActionPreference _verbosePreference;
    [CompilerGeneratedAttribute]
private bool <IsWarningActionSet>k__BackingField;
    private bool _isWarningPreferenceCached;
    private ActionPreference _warningPreference;
    private bool _verboseFlag;
    [CompilerGeneratedAttribute]
private bool <IsVerboseFlagSet>k__BackingField;
    private bool _confirmFlag;
    [CompilerGeneratedAttribute]
private bool <IsConfirmFlagSet>k__BackingField;
    private bool _useTransactionFlag;
    [CompilerGeneratedAttribute]
private bool <UseTransactionFlagSet>k__BackingField;
    private bool _debugFlag;
    [CompilerGeneratedAttribute]
private bool <IsDebugFlagSet>k__BackingField;
    private bool _whatIfFlag;
    private bool _isWhatIfPreferenceCached;
    [CompilerGeneratedAttribute]
private bool <IsWhatIfFlagSet>k__BackingField;
    private ActionPreference _errorAction;
    private bool _isErrorActionPreferenceCached;
    [CompilerGeneratedAttribute]
private bool <IsErrorActionSet>k__BackingField;
    private ActionPreference _progressPreference;
    [CompilerGeneratedAttribute]
private bool <IsProgressActionSet>k__BackingField;
    private bool _isProgressPreferenceCached;
    private ActionPreference _informationPreference;
    [CompilerGeneratedAttribute]
private bool <IsInformationActionSet>k__BackingField;
    private bool _isInformationPreferenceCached;
    [CompilerGeneratedAttribute]
private PagingParameters <PagingParameters>k__BackingField;
    internal ContinueStatus lastShouldProcessContinueStatus;
    internal ContinueStatus lastErrorContinueStatus;
    internal ContinueStatus lastDebugContinueStatus;
    internal ContinueStatus lastVerboseContinueStatus;
    internal ContinueStatus lastWarningContinueStatus;
    internal ContinueStatus lastProgressContinueStatus;
    internal ContinueStatus lastInformationContinueStatus;
    internal ExecutionContext Context { get; internal set; }
    public PSHost Host { get; }
    internal bool IsClosed { get; internal set; }
    internal bool IsPipelineInputExpected { get; }
    internal string OutVariable { get; internal set; }
    internal IList OutVarList { get; internal set; }
    internal PipelineProcessor PipelineProcessor { get; internal set; }
    internal InvocationInfo MyInvocation { get; }
    internal bool IsStopping { get; }
    internal bool LogPipelineExecutionDetail { get; }
    internal string PipelineVariable { get; internal set; }
    internal int OutBuffer { get; internal set; }
    public PSTransactionContext CurrentPSTransaction { get; }
    internal MergeDataStream ErrorMergeTo { get; internal set; }
    internal bool MergeUnclaimedPreviousErrorResults { get; internal set; }
    internal Pipe InputPipe { get; internal set; }
    internal Pipe OutputPipe { get; internal set; }
    internal Pipe ErrorOutputPipe { get; internal set; }
    internal Pipe WarningOutputPipe { get; internal set; }
    internal Pipe VerboseOutputPipe { get; internal set; }
    internal Pipe DebugOutputPipe { get; internal set; }
    internal Pipe InformationOutputPipe { get; internal set; }
    internal string ErrorVariable { get; internal set; }
    internal string WarningVariable { get; internal set; }
    internal string InformationVariable { get; internal set; }
    internal ConfirmImpact ConfirmPreference { get; }
    internal ActionPreference DebugPreference { get; internal set; }
    internal ActionPreference VerbosePreference { get; }
    internal bool IsWarningActionSet { get; private set; }
    internal ActionPreference WarningPreference { get; internal set; }
    internal bool Verbose { get; internal set; }
    internal bool IsVerboseFlagSet { get; private set; }
    internal SwitchParameter Confirm { get; internal set; }
    internal bool IsConfirmFlagSet { get; private set; }
    internal SwitchParameter UseTransaction { get; internal set; }
    internal bool UseTransactionFlagSet { get; private set; }
    internal bool Debug { get; internal set; }
    internal bool IsDebugFlagSet { get; private set; }
    internal SwitchParameter WhatIf { get; internal set; }
    internal bool IsWhatIfFlagSet { get; private set; }
    internal ActionPreference ErrorAction { get; internal set; }
    internal bool IsErrorActionSet { get; private set; }
    internal ActionPreference ProgressPreference { get; internal set; }
    internal bool IsProgressActionSet { get; private set; }
    internal ActionPreference InformationPreference { get; internal set; }
    internal bool IsInformationActionSet { get; private set; }
    internal PagingParameters PagingParameters { get; internal set; }
    internal MshCommandRuntime(ExecutionContext context, CommandInfo commandInfo, InternalCommand thisCommand);
    private static MshCommandRuntime();
    [CompilerGeneratedAttribute]
internal ExecutionContext get_Context();
    [CompilerGeneratedAttribute]
internal void set_Context(ExecutionContext value);
    [CompilerGeneratedAttribute]
public sealed virtual PSHost get_Host();
    [CompilerGeneratedAttribute]
internal bool get_IsClosed();
    [CompilerGeneratedAttribute]
internal void set_IsClosed(bool value);
    internal bool get_IsPipelineInputExpected();
    [CompilerGeneratedAttribute]
internal string get_OutVariable();
    [CompilerGeneratedAttribute]
internal void set_OutVariable(string value);
    internal IList get_OutVarList();
    internal void set_OutVarList(IList value);
    [CompilerGeneratedAttribute]
internal PipelineProcessor get_PipelineProcessor();
    [CompilerGeneratedAttribute]
internal void set_PipelineProcessor(PipelineProcessor value);
    public virtual string ToString();
    internal InvocationInfo get_MyInvocation();
    internal bool get_IsStopping();
    public sealed virtual void WriteObject(object sendToPipeline);
    private void DoWriteObject(object sendToPipeline);
    public sealed virtual void WriteObject(object sendToPipeline, bool enumerateCollection);
    private void DoWriteEnumeratedObject(object sendToPipeline);
    public sealed virtual void WriteProgress(ProgressRecord progressRecord);
    internal void WriteProgress(ProgressRecord progressRecord, bool overrideInquire);
    public sealed virtual void WriteProgress(long sourceId, ProgressRecord progressRecord);
    internal void WriteProgress(long sourceId, ProgressRecord progressRecord, bool overrideInquire);
    public sealed virtual void WriteDebug(string text);
    internal void WriteDebug(DebugRecord record, bool overrideInquire);
    public sealed virtual void WriteVerbose(string text);
    internal void WriteVerbose(VerboseRecord record, bool overrideInquire);
    public sealed virtual void WriteWarning(string text);
    internal void WriteWarning(WarningRecord record, bool overrideInquire);
    public sealed virtual void WriteInformation(InformationRecord informationRecord);
    internal void WriteInformation(InformationRecord record, bool overrideInquire);
    public sealed virtual void WriteCommandDetail(string text);
    [CompilerGeneratedAttribute]
internal bool get_LogPipelineExecutionDetail();
    private bool InitShouldLogPipelineExecutionDetail();
    [CompilerGeneratedAttribute]
internal string get_PipelineVariable();
    [CompilerGeneratedAttribute]
internal void set_PipelineVariable(string value);
    internal void SetupOutVariable();
    internal void SetupPipelineVariable();
    internal void RemovePipelineVariable();
    internal int get_OutBuffer();
    internal void set_OutBuffer(int value);
    public sealed virtual bool ShouldProcess(string target);
    public sealed virtual bool ShouldProcess(string target, string action);
    public sealed virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    public sealed virtual bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    private bool CanShouldProcessAutoConfirm();
    private bool DoShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    internal ShouldProcessPossibleOptimization CalculatePossibleShouldProcessOptimization();
    public sealed virtual bool ShouldContinue(string query, string caption);
    public sealed virtual bool ShouldContinue(string query, string caption, bool hasSecurityImpact, Boolean& yesToAll, Boolean& noToAll);
    public sealed virtual bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    private bool DoShouldContinue(string query, string caption, bool hasSecurityImpact, bool supportsToAllOptions, Boolean& yesToAll, Boolean& noToAll);
    public sealed virtual bool TransactionAvailable();
    public sealed virtual PSTransactionContext get_CurrentPSTransaction();
    [DoesNotReturnAttribute]
public sealed virtual void ThrowTerminatingError(ErrorRecord errorRecord);
    [CompilerGeneratedAttribute]
internal MergeDataStream get_ErrorMergeTo();
    [CompilerGeneratedAttribute]
internal void set_ErrorMergeTo(MergeDataStream value);
    internal void SetMergeFromRuntime(MshCommandRuntime fromRuntime);
    [CompilerGeneratedAttribute]
internal bool get_MergeUnclaimedPreviousErrorResults();
    [CompilerGeneratedAttribute]
internal void set_MergeUnclaimedPreviousErrorResults(bool value);
    internal Pipe get_InputPipe();
    internal void set_InputPipe(Pipe value);
    internal Pipe get_OutputPipe();
    internal void set_OutputPipe(Pipe value);
    internal Object[] GetResultsAsArray();
    internal Pipe get_ErrorOutputPipe();
    internal void set_ErrorOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_WarningOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_WarningOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_VerboseOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_VerboseOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_DebugOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_DebugOutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal Pipe get_InformationOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_InformationOutputPipe(Pipe value);
    internal void ThrowIfStopping();
    internal void ThrowIfWriteNotPermitted(bool needsToWriteToPipeline);
    internal IDisposable AllowThisCommandToWrite(bool permittedToWriteToPipeline);
    public Exception ManageException(Exception e);
    [CompilerGeneratedAttribute]
internal string get_ErrorVariable();
    [CompilerGeneratedAttribute]
internal void set_ErrorVariable(string value);
    internal void SetupErrorVariable();
    private void EnsureVariableParameterAllowed();
    internal void AppendErrorToVariables(object obj);
    private void AppendDollarError(object obj);
    [CompilerGeneratedAttribute]
internal string get_WarningVariable();
    [CompilerGeneratedAttribute]
internal void set_WarningVariable(string value);
    internal void SetupWarningVariable();
    internal void AppendWarningVarList(object obj);
    [CompilerGeneratedAttribute]
internal string get_InformationVariable();
    [CompilerGeneratedAttribute]
internal void set_InformationVariable(string value);
    internal void SetupInformationVariable();
    internal void SetupVariable(VariableStreamKind streamKind, string variableName, IList& varList);
    internal void AppendInformationVarList(object obj);
    internal void _WriteObjectSkipAllowCheck(object sendToPipeline);
    internal void _EnumerateAndWriteObjectSkipAllowCheck(object sendToPipeline);
    public sealed virtual void WriteError(ErrorRecord errorRecord);
    internal void WriteError(ErrorRecord errorRecord, bool overrideInquire);
    private void DoWriteError(object obj);
    internal void _WriteErrorSkipAllowCheck(ErrorRecord errorRecord, Nullable`1<ActionPreference> actionPreference, bool isFromNativeStdError);
    internal ConfirmImpact get_ConfirmPreference();
    internal ActionPreference get_DebugPreference();
    internal void set_DebugPreference(ActionPreference value);
    internal ActionPreference get_VerbosePreference();
    [CompilerGeneratedAttribute]
internal bool get_IsWarningActionSet();
    [CompilerGeneratedAttribute]
private void set_IsWarningActionSet(bool value);
    internal ActionPreference get_WarningPreference();
    internal void set_WarningPreference(ActionPreference value);
    internal bool get_Verbose();
    internal void set_Verbose(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsVerboseFlagSet();
    [CompilerGeneratedAttribute]
private void set_IsVerboseFlagSet(bool value);
    internal SwitchParameter get_Confirm();
    internal void set_Confirm(SwitchParameter value);
    [CompilerGeneratedAttribute]
internal bool get_IsConfirmFlagSet();
    [CompilerGeneratedAttribute]
private void set_IsConfirmFlagSet(bool value);
    internal SwitchParameter get_UseTransaction();
    internal void set_UseTransaction(SwitchParameter value);
    [CompilerGeneratedAttribute]
internal bool get_UseTransactionFlagSet();
    [CompilerGeneratedAttribute]
private void set_UseTransactionFlagSet(bool value);
    internal bool get_Debug();
    internal void set_Debug(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsDebugFlagSet();
    [CompilerGeneratedAttribute]
private void set_IsDebugFlagSet(bool value);
    internal SwitchParameter get_WhatIf();
    internal void set_WhatIf(SwitchParameter value);
    [CompilerGeneratedAttribute]
internal bool get_IsWhatIfFlagSet();
    [CompilerGeneratedAttribute]
private void set_IsWhatIfFlagSet(bool value);
    internal ActionPreference get_ErrorAction();
    internal void set_ErrorAction(ActionPreference value);
    [CompilerGeneratedAttribute]
internal bool get_IsErrorActionSet();
    [CompilerGeneratedAttribute]
private void set_IsErrorActionSet(bool value);
    internal ActionPreference get_ProgressPreference();
    internal void set_ProgressPreference(ActionPreference value);
    [CompilerGeneratedAttribute]
internal bool get_IsProgressActionSet();
    [CompilerGeneratedAttribute]
private void set_IsProgressActionSet(bool value);
    internal ActionPreference get_InformationPreference();
    internal void set_InformationPreference(ActionPreference value);
    [CompilerGeneratedAttribute]
internal bool get_IsInformationActionSet();
    [CompilerGeneratedAttribute]
private void set_IsInformationActionSet(bool value);
    [CompilerGeneratedAttribute]
internal PagingParameters get_PagingParameters();
    [CompilerGeneratedAttribute]
internal void set_PagingParameters(PagingParameters value);
    internal bool WriteHelper_ShouldWrite(ActionPreference preference, ContinueStatus lastContinueStatus);
    internal ContinueStatus WriteHelper(string inquireCaption, string inquireMessage, ActionPreference preference, ContinueStatus lastContinueStatus, string preferenceVariableName, string message);
    internal ContinueStatus InquireHelper(string inquireMessage, string inquireCaption, bool allowYesToAll, bool allowNoToAll, bool replaceNoWithHalt, bool hasSecurityImpact);
    private bool IsSuspendPromptAllowed();
    internal void SetVariableListsInPipe();
    internal void RemoveVariableListsInPipe();
}
internal static class System.Management.Automation.MshLog : object {
    private static ConcurrentDictionary`2<string, Collection`1<LogProvider>> s_logProviders;
    private static string _crimsonLogProviderAssemblyName;
    private static string _crimsonLogProviderTypeName;
    private static Collection`1<string> s_ignoredCommands;
    private static int s_nextSequenceNumber;
    internal static int EVENT_ID_GENERAL_HEALTH_ISSUE;
    internal static int EVENT_ID_RESOURCE_NOT_AVAILABLE;
    internal static int EVENT_ID_NETWORK_CONNECTIVITY_ISSUE;
    internal static int EVENT_ID_CONFIGURATION_FAILURE;
    internal static int EVENT_ID_PERFORMANCE_ISSUE;
    internal static int EVENT_ID_SECURITY_ISSUE;
    internal static int EVENT_ID_SYSTEM_OVERLOADED;
    internal static int EVENT_ID_UNEXPECTED_EXCEPTION;
    private static string NextSequenceNumber { get; }
    private static MshLog();
    private static IEnumerable`1<LogProvider> GetLogProvider(string shellId);
    private static IEnumerable`1<LogProvider> GetLogProvider(ExecutionContext executionContext);
    private static IEnumerable`1<LogProvider> GetLogProvider(LogContext logContext);
    private static Collection`1<LogProvider> CreateLogProvider(string shellId);
    internal static void SetDummyLog(string shellId);
    internal static void LogEngineHealthEvent(ExecutionContext executionContext, int eventId, Exception exception, Severity severity, Dictionary`2<string, string> additionalInfo, EngineState newEngineState);
    internal static void LogEngineHealthEvent(ExecutionContext executionContext, int eventId, Exception exception, Severity severity);
    internal static void LogEngineHealthEvent(ExecutionContext executionContext, Exception exception, Severity severity);
    internal static void LogEngineHealthEvent(ExecutionContext executionContext, int eventId, Exception exception, Severity severity, Dictionary`2<string, string> additionalInfo);
    internal static void LogEngineHealthEvent(ExecutionContext executionContext, int eventId, Exception exception, Severity severity, EngineState newEngineState);
    internal static void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary`2<string, string> additionalInfo);
    internal static void LogEngineLifecycleEvent(ExecutionContext executionContext, EngineState engineState, InvocationInfo invocationInfo);
    internal static void LogEngineLifecycleEvent(ExecutionContext executionContext, EngineState engineState);
    internal static void LogCommandHealthEvent(ExecutionContext executionContext, Exception exception, Severity severity);
    internal static void LogCommandLifecycleEvent(ExecutionContext executionContext, CommandState commandState, InvocationInfo invocationInfo);
    internal static void LogCommandLifecycleEvent(ExecutionContext executionContext, CommandState commandState, string commandName);
    internal static void LogPipelineExecutionDetailEvent(ExecutionContext executionContext, List`1<string> detail, InvocationInfo invocationInfo);
    internal static void LogPipelineExecutionDetailEvent(ExecutionContext executionContext, List`1<string> detail, string scriptName, string commandLine);
    internal static void LogProviderHealthEvent(ExecutionContext executionContext, string providerName, Exception exception, Severity severity);
    internal static void LogProviderLifecycleEvent(ExecutionContext executionContext, string providerName, ProviderState providerState);
    internal static void LogSettingsEvent(ExecutionContext executionContext, string variableName, string newValue, string previousValue, InvocationInfo invocationInfo);
    internal static void LogSettingsEvent(ExecutionContext executionContext, string variableName, string newValue, string previousValue);
    private static EngineState GetEngineState(ExecutionContext executionContext);
    private static void SetEngineState(ExecutionContext executionContext, EngineState engineState);
    internal static LogContext GetLogContext(ExecutionContext executionContext, InvocationInfo invocationInfo);
    private static LogContext GetLogContext(ExecutionContext executionContext, InvocationInfo invocationInfo, Severity severity);
    private static bool NeedToLogEngineHealthEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogEngineLifecycleEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogCommandHealthEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogCommandLifecycleEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogPipelineExecutionDetailEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogProviderHealthEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogProviderLifecycleEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static bool NeedToLogSettingsEvent(LogProvider logProvider, ExecutionContext executionContext);
    private static string get_NextSequenceNumber();
}
[FlagsAttribute]
internal enum System.Management.Automation.MshMemberMatchOptions : Enum {
    public int value__;
    public static MshMemberMatchOptions None;
    public static MshMemberMatchOptions IncludeHidden;
    public static MshMemberMatchOptions OnlySerializable;
}
internal class System.Management.Automation.MUIFileSearcher : object {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private SearchMode <SearchMode>k__BackingField;
    private static EnumerationOptions _enumerationOptions;
    private Collection`1<string> _result;
    private Hashtable _uniqueMatches;
    internal string Target { get; }
    internal Collection`1<string> SearchPaths { get; }
    internal SearchMode SearchMode { get; }
    internal Collection`1<string> Result { get; }
    private MUIFileSearcher(string target, Collection`1<string> searchPaths, SearchMode searchMode);
    private MUIFileSearcher(string target, Collection`1<string> searchPaths);
    private static MUIFileSearcher();
    [CompilerGeneratedAttribute]
internal string get_Target();
    [CompilerGeneratedAttribute]
internal Collection`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
internal SearchMode get_SearchMode();
    internal Collection`1<string> get_Result();
    private void SearchForFiles();
    private void AddFiles(string muiDirectory, string directory, string pattern);
    private void SearchForFiles(string pattern, string directory);
    private static Collection`1<string> NormalizeSearchPaths(string target, Collection`1<string> searchPaths);
    internal static Collection`1<string> SearchFiles(string pattern);
    internal static Collection`1<string> SearchFiles(string pattern, Collection`1<string> searchPaths);
    internal static string LocateFile(string file);
    internal static string LocateFile(string file, Collection`1<string> searchPaths);
}
internal abstract class System.Management.Automation.MutableTuple : object {
    private static int MaxSize;
    private static Dictionary`2<Type, int> s_sizeDict;
    private int _size;
    protected BitArray _valuesSet;
    private Dictionary`2<string, int> _nameToIndexMap;
    private static ConcurrentDictionary`2<Type, Func`1<MutableTuple>> s_tupleCreators;
    public int Capacity { get; }
    private static MutableTuple();
    internal bool IsValueSet(int index);
    internal void SetAutomaticVariable(AutomaticVariable auto, object value, ExecutionContext context);
    internal object GetAutomaticVariable(AutomaticVariable auto);
    internal void SetPreferenceVariable(PreferenceVariable pref, object value);
    internal bool TryGetLocalVariable(string name, bool fromNewOrSet, PSVariable& result);
    internal bool TrySetParameter(string name, object value);
    internal PSVariable TrySetVariable(string name, object value);
    internal void GetVariableTable(Dictionary`2<string, PSVariable> result, bool includePrivate);
    public object GetValue(int index);
    public void SetValue(int index, object value);
    protected abstract virtual object GetValueImpl(int index);
    protected abstract virtual void SetValueImpl(int index, object value);
    private void SetNestedValue(int size, int index, object value);
    private object GetNestedValue(int size, int index);
    private static Type GetTupleType(int size);
    public static Type MakeTupleType(Type[] types);
    public static int GetSize(Type tupleType);
    public static Func`1<MutableTuple> TupleCreator(Type type);
    public static MutableTuple MakeTuple(Type tupleType, Dictionary`2<string, int> nameToIndexMap, Func`1<MutableTuple> creator);
    public static Object[] GetTupleValues(MutableTuple tuple);
    public static IEnumerable`1<PropertyInfo> GetAccessPath(Type tupleType, int index);
    [IteratorStateMachineAttribute("System.Management.Automation.MutableTuple/<GetAccessProperties>d__27")]
internal static IEnumerable`1<PropertyInfo> GetAccessProperties(Type tupleType, int size, int index);
    [IteratorStateMachineAttribute("System.Management.Automation.MutableTuple/<GetAccessPath>d__28")]
internal static IEnumerable`1<int> GetAccessPath(int size, int index);
    private static void GetTupleValues(MutableTuple tuple, List`1<object> args);
    private static MutableTuple MakeTuple(Func`1<MutableTuple> creator, Type tupleType, int size, BitArray bitArray);
    private static Type MakeTupleType(Type[] types, int start, int end);
    public abstract virtual int get_Capacity();
    public static Expression Create(Expression[] values);
    private static int PowerOfTwoRound(int value);
    internal static Expression CreateNew(Type tupleType, int start, int end, Expression[] values);
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`1 : MutableTuple {
    private T0 _item0;
    public T0 Item000 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`1(T0 item0);
    public T0 get_Item000();
    public void set_Item000(T0 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`128 : MutableTuple`64<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31, T32, T33, T34, T35, T36, T37, T38, T39, T40, T41, T42, T43, T44, T45, T46, T47, T48, T49, T50, T51, T52, T53, T54, T55, T56, T57, T58, T59, T60, T61, T62, T63> {
    private T64 _item64;
    private T65 _item65;
    private T66 _item66;
    private T67 _item67;
    private T68 _item68;
    private T69 _item69;
    private T70 _item70;
    private T71 _item71;
    private T72 _item72;
    private T73 _item73;
    private T74 _item74;
    private T75 _item75;
    private T76 _item76;
    private T77 _item77;
    private T78 _item78;
    private T79 _item79;
    private T80 _item80;
    private T81 _item81;
    private T82 _item82;
    private T83 _item83;
    private T84 _item84;
    private T85 _item85;
    private T86 _item86;
    private T87 _item87;
    private T88 _item88;
    private T89 _item89;
    private T90 _item90;
    private T91 _item91;
    private T92 _item92;
    private T93 _item93;
    private T94 _item94;
    private T95 _item95;
    private T96 _item96;
    private T97 _item97;
    private T98 _item98;
    private T99 _item99;
    private T100 _item100;
    private T101 _item101;
    private T102 _item102;
    private T103 _item103;
    private T104 _item104;
    private T105 _item105;
    private T106 _item106;
    private T107 _item107;
    private T108 _item108;
    private T109 _item109;
    private T110 _item110;
    private T111 _item111;
    private T112 _item112;
    private T113 _item113;
    private T114 _item114;
    private T115 _item115;
    private T116 _item116;
    private T117 _item117;
    private T118 _item118;
    private T119 _item119;
    private T120 _item120;
    private T121 _item121;
    private T122 _item122;
    private T123 _item123;
    private T124 _item124;
    private T125 _item125;
    private T126 _item126;
    private T127 _item127;
    public T64 Item064 { get; public set; }
    public T65 Item065 { get; public set; }
    public T66 Item066 { get; public set; }
    public T67 Item067 { get; public set; }
    public T68 Item068 { get; public set; }
    public T69 Item069 { get; public set; }
    public T70 Item070 { get; public set; }
    public T71 Item071 { get; public set; }
    public T72 Item072 { get; public set; }
    public T73 Item073 { get; public set; }
    public T74 Item074 { get; public set; }
    public T75 Item075 { get; public set; }
    public T76 Item076 { get; public set; }
    public T77 Item077 { get; public set; }
    public T78 Item078 { get; public set; }
    public T79 Item079 { get; public set; }
    public T80 Item080 { get; public set; }
    public T81 Item081 { get; public set; }
    public T82 Item082 { get; public set; }
    public T83 Item083 { get; public set; }
    public T84 Item084 { get; public set; }
    public T85 Item085 { get; public set; }
    public T86 Item086 { get; public set; }
    public T87 Item087 { get; public set; }
    public T88 Item088 { get; public set; }
    public T89 Item089 { get; public set; }
    public T90 Item090 { get; public set; }
    public T91 Item091 { get; public set; }
    public T92 Item092 { get; public set; }
    public T93 Item093 { get; public set; }
    public T94 Item094 { get; public set; }
    public T95 Item095 { get; public set; }
    public T96 Item096 { get; public set; }
    public T97 Item097 { get; public set; }
    public T98 Item098 { get; public set; }
    public T99 Item099 { get; public set; }
    public T100 Item100 { get; public set; }
    public T101 Item101 { get; public set; }
    public T102 Item102 { get; public set; }
    public T103 Item103 { get; public set; }
    public T104 Item104 { get; public set; }
    public T105 Item105 { get; public set; }
    public T106 Item106 { get; public set; }
    public T107 Item107 { get; public set; }
    public T108 Item108 { get; public set; }
    public T109 Item109 { get; public set; }
    public T110 Item110 { get; public set; }
    public T111 Item111 { get; public set; }
    public T112 Item112 { get; public set; }
    public T113 Item113 { get; public set; }
    public T114 Item114 { get; public set; }
    public T115 Item115 { get; public set; }
    public T116 Item116 { get; public set; }
    public T117 Item117 { get; public set; }
    public T118 Item118 { get; public set; }
    public T119 Item119 { get; public set; }
    public T120 Item120 { get; public set; }
    public T121 Item121 { get; public set; }
    public T122 Item122 { get; public set; }
    public T123 Item123 { get; public set; }
    public T124 Item124 { get; public set; }
    public T125 Item125 { get; public set; }
    public T126 Item126 { get; public set; }
    public T127 Item127 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`128(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31, T32 item32, T33 item33, T34 item34, T35 item35, T36 item36, T37 item37, T38 item38, T39 item39, T40 item40, T41 item41, T42 item42, T43 item43, T44 item44, T45 item45, T46 item46, T47 item47, T48 item48, T49 item49, T50 item50, T51 item51, T52 item52, T53 item53, T54 item54, T55 item55, T56 item56, T57 item57, T58 item58, T59 item59, T60 item60, T61 item61, T62 item62, T63 item63, T64 item64, T65 item65, T66 item66, T67 item67, T68 item68, T69 item69, T70 item70, T71 item71, T72 item72, T73 item73, T74 item74, T75 item75, T76 item76, T77 item77, T78 item78, T79 item79, T80 item80, T81 item81, T82 item82, T83 item83, T84 item84, T85 item85, T86 item86, T87 item87, T88 item88, T89 item89, T90 item90, T91 item91, T92 item92, T93 item93, T94 item94, T95 item95, T96 item96, T97 item97, T98 item98, T99 item99, T100 item100, T101 item101, T102 item102, T103 item103, T104 item104, T105 item105, T106 item106, T107 item107, T108 item108, T109 item109, T110 item110, T111 item111, T112 item112, T113 item113, T114 item114, T115 item115, T116 item116, T117 item117, T118 item118, T119 item119, T120 item120, T121 item121, T122 item122, T123 item123, T124 item124, T125 item125, T126 item126, T127 item127);
    public T64 get_Item064();
    public void set_Item064(T64 value);
    public T65 get_Item065();
    public void set_Item065(T65 value);
    public T66 get_Item066();
    public void set_Item066(T66 value);
    public T67 get_Item067();
    public void set_Item067(T67 value);
    public T68 get_Item068();
    public void set_Item068(T68 value);
    public T69 get_Item069();
    public void set_Item069(T69 value);
    public T70 get_Item070();
    public void set_Item070(T70 value);
    public T71 get_Item071();
    public void set_Item071(T71 value);
    public T72 get_Item072();
    public void set_Item072(T72 value);
    public T73 get_Item073();
    public void set_Item073(T73 value);
    public T74 get_Item074();
    public void set_Item074(T74 value);
    public T75 get_Item075();
    public void set_Item075(T75 value);
    public T76 get_Item076();
    public void set_Item076(T76 value);
    public T77 get_Item077();
    public void set_Item077(T77 value);
    public T78 get_Item078();
    public void set_Item078(T78 value);
    public T79 get_Item079();
    public void set_Item079(T79 value);
    public T80 get_Item080();
    public void set_Item080(T80 value);
    public T81 get_Item081();
    public void set_Item081(T81 value);
    public T82 get_Item082();
    public void set_Item082(T82 value);
    public T83 get_Item083();
    public void set_Item083(T83 value);
    public T84 get_Item084();
    public void set_Item084(T84 value);
    public T85 get_Item085();
    public void set_Item085(T85 value);
    public T86 get_Item086();
    public void set_Item086(T86 value);
    public T87 get_Item087();
    public void set_Item087(T87 value);
    public T88 get_Item088();
    public void set_Item088(T88 value);
    public T89 get_Item089();
    public void set_Item089(T89 value);
    public T90 get_Item090();
    public void set_Item090(T90 value);
    public T91 get_Item091();
    public void set_Item091(T91 value);
    public T92 get_Item092();
    public void set_Item092(T92 value);
    public T93 get_Item093();
    public void set_Item093(T93 value);
    public T94 get_Item094();
    public void set_Item094(T94 value);
    public T95 get_Item095();
    public void set_Item095(T95 value);
    public T96 get_Item096();
    public void set_Item096(T96 value);
    public T97 get_Item097();
    public void set_Item097(T97 value);
    public T98 get_Item098();
    public void set_Item098(T98 value);
    public T99 get_Item099();
    public void set_Item099(T99 value);
    public T100 get_Item100();
    public void set_Item100(T100 value);
    public T101 get_Item101();
    public void set_Item101(T101 value);
    public T102 get_Item102();
    public void set_Item102(T102 value);
    public T103 get_Item103();
    public void set_Item103(T103 value);
    public T104 get_Item104();
    public void set_Item104(T104 value);
    public T105 get_Item105();
    public void set_Item105(T105 value);
    public T106 get_Item106();
    public void set_Item106(T106 value);
    public T107 get_Item107();
    public void set_Item107(T107 value);
    public T108 get_Item108();
    public void set_Item108(T108 value);
    public T109 get_Item109();
    public void set_Item109(T109 value);
    public T110 get_Item110();
    public void set_Item110(T110 value);
    public T111 get_Item111();
    public void set_Item111(T111 value);
    public T112 get_Item112();
    public void set_Item112(T112 value);
    public T113 get_Item113();
    public void set_Item113(T113 value);
    public T114 get_Item114();
    public void set_Item114(T114 value);
    public T115 get_Item115();
    public void set_Item115(T115 value);
    public T116 get_Item116();
    public void set_Item116(T116 value);
    public T117 get_Item117();
    public void set_Item117(T117 value);
    public T118 get_Item118();
    public void set_Item118(T118 value);
    public T119 get_Item119();
    public void set_Item119(T119 value);
    public T120 get_Item120();
    public void set_Item120(T120 value);
    public T121 get_Item121();
    public void set_Item121(T121 value);
    public T122 get_Item122();
    public void set_Item122(T122 value);
    public T123 get_Item123();
    public void set_Item123(T123 value);
    public T124 get_Item124();
    public void set_Item124(T124 value);
    public T125 get_Item125();
    public void set_Item125(T125 value);
    public T126 get_Item126();
    public void set_Item126(T126 value);
    public T127 get_Item127();
    public void set_Item127(T127 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`16 : MutableTuple`8<T0, T1, T2, T3, T4, T5, T6, T7> {
    private T8 _item8;
    private T9 _item9;
    private T10 _item10;
    private T11 _item11;
    private T12 _item12;
    private T13 _item13;
    private T14 _item14;
    private T15 _item15;
    public T8 Item008 { get; public set; }
    public T9 Item009 { get; public set; }
    public T10 Item010 { get; public set; }
    public T11 Item011 { get; public set; }
    public T12 Item012 { get; public set; }
    public T13 Item013 { get; public set; }
    public T14 Item014 { get; public set; }
    public T15 Item015 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`16(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15);
    public T8 get_Item008();
    public void set_Item008(T8 value);
    public T9 get_Item009();
    public void set_Item009(T9 value);
    public T10 get_Item010();
    public void set_Item010(T10 value);
    public T11 get_Item011();
    public void set_Item011(T11 value);
    public T12 get_Item012();
    public void set_Item012(T12 value);
    public T13 get_Item013();
    public void set_Item013(T13 value);
    public T14 get_Item014();
    public void set_Item014(T14 value);
    public T15 get_Item015();
    public void set_Item015(T15 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`2 : MutableTuple`1<T0> {
    private T1 _item1;
    public T1 Item001 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`2(T0 item0, T1 item1);
    public T1 get_Item001();
    public void set_Item001(T1 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`32 : MutableTuple`16<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15> {
    private T16 _item16;
    private T17 _item17;
    private T18 _item18;
    private T19 _item19;
    private T20 _item20;
    private T21 _item21;
    private T22 _item22;
    private T23 _item23;
    private T24 _item24;
    private T25 _item25;
    private T26 _item26;
    private T27 _item27;
    private T28 _item28;
    private T29 _item29;
    private T30 _item30;
    private T31 _item31;
    public T16 Item016 { get; public set; }
    public T17 Item017 { get; public set; }
    public T18 Item018 { get; public set; }
    public T19 Item019 { get; public set; }
    public T20 Item020 { get; public set; }
    public T21 Item021 { get; public set; }
    public T22 Item022 { get; public set; }
    public T23 Item023 { get; public set; }
    public T24 Item024 { get; public set; }
    public T25 Item025 { get; public set; }
    public T26 Item026 { get; public set; }
    public T27 Item027 { get; public set; }
    public T28 Item028 { get; public set; }
    public T29 Item029 { get; public set; }
    public T30 Item030 { get; public set; }
    public T31 Item031 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`32(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31);
    public T16 get_Item016();
    public void set_Item016(T16 value);
    public T17 get_Item017();
    public void set_Item017(T17 value);
    public T18 get_Item018();
    public void set_Item018(T18 value);
    public T19 get_Item019();
    public void set_Item019(T19 value);
    public T20 get_Item020();
    public void set_Item020(T20 value);
    public T21 get_Item021();
    public void set_Item021(T21 value);
    public T22 get_Item022();
    public void set_Item022(T22 value);
    public T23 get_Item023();
    public void set_Item023(T23 value);
    public T24 get_Item024();
    public void set_Item024(T24 value);
    public T25 get_Item025();
    public void set_Item025(T25 value);
    public T26 get_Item026();
    public void set_Item026(T26 value);
    public T27 get_Item027();
    public void set_Item027(T27 value);
    public T28 get_Item028();
    public void set_Item028(T28 value);
    public T29 get_Item029();
    public void set_Item029(T29 value);
    public T30 get_Item030();
    public void set_Item030(T30 value);
    public T31 get_Item031();
    public void set_Item031(T31 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`4 : MutableTuple`2<T0, T1> {
    private T2 _item2;
    private T3 _item3;
    public T2 Item002 { get; public set; }
    public T3 Item003 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`4(T0 item0, T1 item1, T2 item2, T3 item3);
    public T2 get_Item002();
    public void set_Item002(T2 value);
    public T3 get_Item003();
    public void set_Item003(T3 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`64 : MutableTuple`32<T0, T1, T2, T3, T4, T5, T6, T7, T8, T9, T10, T11, T12, T13, T14, T15, T16, T17, T18, T19, T20, T21, T22, T23, T24, T25, T26, T27, T28, T29, T30, T31> {
    private T32 _item32;
    private T33 _item33;
    private T34 _item34;
    private T35 _item35;
    private T36 _item36;
    private T37 _item37;
    private T38 _item38;
    private T39 _item39;
    private T40 _item40;
    private T41 _item41;
    private T42 _item42;
    private T43 _item43;
    private T44 _item44;
    private T45 _item45;
    private T46 _item46;
    private T47 _item47;
    private T48 _item48;
    private T49 _item49;
    private T50 _item50;
    private T51 _item51;
    private T52 _item52;
    private T53 _item53;
    private T54 _item54;
    private T55 _item55;
    private T56 _item56;
    private T57 _item57;
    private T58 _item58;
    private T59 _item59;
    private T60 _item60;
    private T61 _item61;
    private T62 _item62;
    private T63 _item63;
    public T32 Item032 { get; public set; }
    public T33 Item033 { get; public set; }
    public T34 Item034 { get; public set; }
    public T35 Item035 { get; public set; }
    public T36 Item036 { get; public set; }
    public T37 Item037 { get; public set; }
    public T38 Item038 { get; public set; }
    public T39 Item039 { get; public set; }
    public T40 Item040 { get; public set; }
    public T41 Item041 { get; public set; }
    public T42 Item042 { get; public set; }
    public T43 Item043 { get; public set; }
    public T44 Item044 { get; public set; }
    public T45 Item045 { get; public set; }
    public T46 Item046 { get; public set; }
    public T47 Item047 { get; public set; }
    public T48 Item048 { get; public set; }
    public T49 Item049 { get; public set; }
    public T50 Item050 { get; public set; }
    public T51 Item051 { get; public set; }
    public T52 Item052 { get; public set; }
    public T53 Item053 { get; public set; }
    public T54 Item054 { get; public set; }
    public T55 Item055 { get; public set; }
    public T56 Item056 { get; public set; }
    public T57 Item057 { get; public set; }
    public T58 Item058 { get; public set; }
    public T59 Item059 { get; public set; }
    public T60 Item060 { get; public set; }
    public T61 Item061 { get; public set; }
    public T62 Item062 { get; public set; }
    public T63 Item063 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`64(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7, T8 item8, T9 item9, T10 item10, T11 item11, T12 item12, T13 item13, T14 item14, T15 item15, T16 item16, T17 item17, T18 item18, T19 item19, T20 item20, T21 item21, T22 item22, T23 item23, T24 item24, T25 item25, T26 item26, T27 item27, T28 item28, T29 item29, T30 item30, T31 item31, T32 item32, T33 item33, T34 item34, T35 item35, T36 item36, T37 item37, T38 item38, T39 item39, T40 item40, T41 item41, T42 item42, T43 item43, T44 item44, T45 item45, T46 item46, T47 item47, T48 item48, T49 item49, T50 item50, T51 item51, T52 item52, T53 item53, T54 item54, T55 item55, T56 item56, T57 item57, T58 item58, T59 item59, T60 item60, T61 item61, T62 item62, T63 item63);
    public T32 get_Item032();
    public void set_Item032(T32 value);
    public T33 get_Item033();
    public void set_Item033(T33 value);
    public T34 get_Item034();
    public void set_Item034(T34 value);
    public T35 get_Item035();
    public void set_Item035(T35 value);
    public T36 get_Item036();
    public void set_Item036(T36 value);
    public T37 get_Item037();
    public void set_Item037(T37 value);
    public T38 get_Item038();
    public void set_Item038(T38 value);
    public T39 get_Item039();
    public void set_Item039(T39 value);
    public T40 get_Item040();
    public void set_Item040(T40 value);
    public T41 get_Item041();
    public void set_Item041(T41 value);
    public T42 get_Item042();
    public void set_Item042(T42 value);
    public T43 get_Item043();
    public void set_Item043(T43 value);
    public T44 get_Item044();
    public void set_Item044(T44 value);
    public T45 get_Item045();
    public void set_Item045(T45 value);
    public T46 get_Item046();
    public void set_Item046(T46 value);
    public T47 get_Item047();
    public void set_Item047(T47 value);
    public T48 get_Item048();
    public void set_Item048(T48 value);
    public T49 get_Item049();
    public void set_Item049(T49 value);
    public T50 get_Item050();
    public void set_Item050(T50 value);
    public T51 get_Item051();
    public void set_Item051(T51 value);
    public T52 get_Item052();
    public void set_Item052(T52 value);
    public T53 get_Item053();
    public void set_Item053(T53 value);
    public T54 get_Item054();
    public void set_Item054(T54 value);
    public T55 get_Item055();
    public void set_Item055(T55 value);
    public T56 get_Item056();
    public void set_Item056(T56 value);
    public T57 get_Item057();
    public void set_Item057(T57 value);
    public T58 get_Item058();
    public void set_Item058(T58 value);
    public T59 get_Item059();
    public void set_Item059(T59 value);
    public T60 get_Item060();
    public void set_Item060(T60 value);
    public T61 get_Item061();
    public void set_Item061(T61 value);
    public T62 get_Item062();
    public void set_Item062(T62 value);
    public T63 get_Item063();
    public void set_Item063(T63 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
[GeneratedCodeAttribute("DLR", "2.0")]
internal class System.Management.Automation.MutableTuple`8 : MutableTuple`4<T0, T1, T2, T3> {
    private T4 _item4;
    private T5 _item5;
    private T6 _item6;
    private T7 _item7;
    public T4 Item004 { get; public set; }
    public T5 Item005 { get; public set; }
    public T6 Item006 { get; public set; }
    public T7 Item007 { get; public set; }
    public int Capacity { get; }
    public MutableTuple`8(T0 item0, T1 item1, T2 item2, T3 item3, T4 item4, T5 item5, T6 item6, T7 item7);
    public T4 get_Item004();
    public void set_Item004(T4 value);
    public T5 get_Item005();
    public void set_Item005(T5 value);
    public T6 get_Item006();
    public void set_Item006(T6 value);
    public T7 get_Item007();
    public void set_Item007(T7 value);
    protected virtual object GetValueImpl(int index);
    protected virtual void SetValueImpl(int index, object value);
    public virtual int get_Capacity();
}
public enum System.Management.Automation.NativeArgumentPassingStyle : Enum {
    public int value__;
    public static NativeArgumentPassingStyle Legacy;
    public static NativeArgumentPassingStyle Standard;
    public static NativeArgumentPassingStyle Windows;
}
internal class System.Management.Automation.NativeCommand : InternalCommand {
    private NativeCommandProcessor _myCommandProcessor;
    internal NativeCommandProcessor MyCommandProcessor { get; internal set; }
    internal NativeCommandProcessor get_MyCommandProcessor();
    internal void set_MyCommandProcessor(NativeCommandProcessor value);
    internal virtual void DoStopProcessing();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Management.Automation.NativeCommandExitException : RuntimeException {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ExitCode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    public string Path { get; }
    public int ExitCode { get; }
    public int ProcessId { get; }
    [NullableContextAttribute("1")]
internal NativeCommandExitException(string path, int exitCode, int processId, string message, string errorId);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public int get_ExitCode();
    [CompilerGeneratedAttribute]
public int get_ProcessId();
}
internal enum System.Management.Automation.NativeCommandIOFormat : Enum {
    public int value__;
    public static NativeCommandIOFormat Text;
    public static NativeCommandIOFormat Xml;
}
internal class System.Management.Automation.NativeCommandParameterBinder : ParameterBinderBase {
    private StringBuilder _arguments;
    private List`1<string> _argumentList;
    private NativeCommand _nativeCommand;
    internal string Arguments { get; }
    internal String[] ArgumentList { get; }
    internal NativeArgumentPassingStyle ArgumentPassingStyle { get; }
    internal NativeCommandParameterBinder(NativeCommand command);
    internal virtual void BindParameter(string name, object value, CompiledCommandParameter parameterMetadata);
    internal virtual object GetDefaultParameterValue(string name);
    internal void BindParameters(Collection`1<CommandParameterInternal> parameters);
    internal string get_Arguments();
    internal String[] get_ArgumentList();
    internal void AddToArgumentList(CommandParameterInternal parameter, string argument);
    internal NativeArgumentPassingStyle get_ArgumentPassingStyle();
    private void AppendOneNativeArgument(ExecutionContext context, CommandParameterInternal parameter, object obj, ArrayLiteralAst argArrayAst, bool sawVerbatimArgumentMarker, bool usedQuotes);
    private void PossiblyGlobArg(string arg, CommandParameterInternal parameter, bool usedQuotes);
    internal static bool NeedQuotes(string stringToCheck);
    private static string GetEnumerableArgSeparator(ArrayLiteralAst arrayLiteralAst, int index);
}
internal class System.Management.Automation.NativeCommandParameterBinderController : ParameterBinderController {
    private static Collection`1<CommandParameterInternal> s_emptyReturnCollection;
    internal string Arguments { get; }
    internal String[] ArgumentList { get; }
    internal NativeArgumentPassingStyle ArgumentPassingStyle { get; }
    internal NativeCommandParameterBinderController(NativeCommand command);
    private static NativeCommandParameterBinderController();
    internal string get_Arguments();
    internal String[] get_ArgumentList();
    internal NativeArgumentPassingStyle get_ArgumentPassingStyle();
    internal virtual bool BindParameter(CommandParameterInternal argument, ParameterBindingFlags flags);
    internal virtual Collection`1<CommandParameterInternal> BindParameters(Collection`1<CommandParameterInternal> parameters);
}
internal class System.Management.Automation.NativeCommandProcessor : CommandProcessorBase {
    private static IReadOnlySet`1<string> s_legacyFileExtensions;
    private static IReadOnlySet`1<string> s_legacyCommands;
    private ApplicationInfo _applicationInfo;
    [CompilerGeneratedAttribute]
private NativeCommandProcessor <DownStreamNativeCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UpstreamIsNativeCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private BytePipe <StdOutDestination>k__BackingField;
    private NativeCommandParameterBinderController _nativeParameterBinderController;
    private Process _nativeProcess;
    private ProcessInputWriter _inputWriter;
    private bool _runStandAlone;
    private bool _isRunningInBackground;
    private bool _hasNotifiedBeginApplication;
    private BlockingCollection`1<ProcessOutputObject> _nativeProcessOutputQueue;
    private static Nullable`1<bool> s_supportScreenScrape;
    private bool _isTranscribing;
    private Coordinates _startPosition;
    private object _sync;
    private SemaphoreSlim _processInitialized;
    private AsyncByteStreamTransfer _stdOutByteTransfer;
    private bool _stopped;
    private bool _isMiniShell;
    [CompilerGeneratedAttribute]
private static bool <IsServerSide>k__BackingField;
    private NativeCommand nativeCommand { get; }
    private string NativeCommandName { get; }
    private string Path { get; }
    internal NativeCommandProcessor DownStreamNativeCommand { get; internal set; }
    internal bool UpstreamIsNativeCommand { get; internal set; }
    internal BytePipe StdOutDestination { get; internal set; }
    internal NativeCommandParameterBinderController NativeParameterBinderController { get; }
    internal static bool IsServerSide { get; internal set; }
    internal NativeCommandProcessor(ApplicationInfo applicationInfo, ExecutionContext context);
    private static NativeCommandProcessor();
    private NativeCommand get_nativeCommand();
    private string get_NativeCommandName();
    private string get_Path();
    [CompilerGeneratedAttribute]
internal NativeCommandProcessor get_DownStreamNativeCommand();
    [CompilerGeneratedAttribute]
internal void set_DownStreamNativeCommand(NativeCommandProcessor value);
    [CompilerGeneratedAttribute]
internal bool get_UpstreamIsNativeCommand();
    [CompilerGeneratedAttribute]
internal void set_UpstreamIsNativeCommand(bool value);
    [CompilerGeneratedAttribute]
internal BytePipe get_StdOutDestination();
    [CompilerGeneratedAttribute]
internal void set_StdOutDestination(BytePipe value);
    internal ParameterBinderController NewParameterBinderController(InternalCommand command);
    internal NativeCommandParameterBinderController get_NativeParameterBinderController();
    internal virtual void Prepare(IDictionary psDefaultParameterValues);
    internal virtual void ProcessRecord();
    [AsyncStateMachineAttribute("System.Management.Automation.NativeCommandProcessor/<WaitForProcessInitializationAsync>d__39")]
internal Task WaitForProcessInitializationAsync(CancellationToken cancellationToken);
    internal BytePipe CreateBytePipe(bool stdout);
    internal Stream GetStream(bool stdout);
    private void InitNativeProcess();
    private void InitOutputQueue();
    private ProcessOutputObject DequeueProcessOutput(bool blocking);
    private void ConsumeAvailableNativeProcessOutput(bool blocking);
    internal virtual void Complete();
    private static void KillProcess(Process processToKill);
    private static void KillProcessAndChildProcesses(Process processToKill, ProcessWithParentId[] currentlyRunningProcs);
    private static void KillChildProcesses(int parentId, ProcessWithParentId[] currentlyRunningProcs);
    private static bool IsWindowsApplication(string fileName);
    internal void StopProcessing();
    private void CleanUp(bool killBackgroundProcess);
    private void ProcessOutputRecord(ProcessOutputObject outputValue);
    private bool UseSpecialArgumentPassing(string filePath);
    private ProcessStartInfo GetProcessStartInfo(bool redirectOutput, bool redirectError, bool redirectInput, bool soloCommand);
    private static bool ShouldUseLegacyPassingStyle(string filePath);
    private static bool IsDownstreamOutDefault(Pipe downstreamPipe);
    private void CalculateIORedirection(bool isWindowsApplication, Boolean& redirectOutput, Boolean& redirectError, Boolean& redirectInput);
    private bool IsExecutable(string path);
    private bool IsMiniShell();
    [CompilerGeneratedAttribute]
internal static bool get_IsServerSide();
    [CompilerGeneratedAttribute]
internal static void set_IsServerSide(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.NativeCommandProcessorBytePipe : BytePipe {
    private NativeCommandProcessor _nativeCommand;
    private bool _stdout;
    internal NativeCommandProcessorBytePipe(NativeCommandProcessor nativeCommand, bool stdout);
    [AsyncStateMachineAttribute("System.Management.Automation.NativeCommandProcessorBytePipe/<GetStream>d__3")]
public virtual Task`1<Stream> GetStream(CancellationToken cancellationToken);
}
internal abstract class System.Management.Automation.NestedRunspaceDebugger : Debugger {
    private bool _isDisposed;
    protected Runspace _runspace;
    protected Debugger _wrappedDebugger;
    [CompilerGeneratedAttribute]
private PSMonitorRunspaceType <RunspaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <ParentDebuggerId>k__BackingField;
    public PSMonitorRunspaceType RunspaceType { get; }
    public Guid ParentDebuggerId { get; private set; }
    public bool IsActive { get; }
    protected NestedRunspaceDebugger(Runspace runspace, PSMonitorRunspaceType runspaceType, Guid parentDebuggerId);
    [CompilerGeneratedAttribute]
public PSMonitorRunspaceType get_RunspaceType();
    [CompilerGeneratedAttribute]
public Guid get_ParentDebuggerId();
    [CompilerGeneratedAttribute]
private void set_ParentDebuggerId(Guid value);
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual void StopProcessCommand();
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual void SetDebugMode(DebugModes mode);
    public virtual void SetDebuggerStepMode(bool enabled);
    public virtual bool get_IsActive();
    internal virtual void Break(object triggerObject);
    public virtual void Dispose();
    protected virtual void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    protected virtual void HandleBreakpointUpdated(object sender, BreakpointUpdatedEventArgs e);
    protected virtual DebuggerCommandResults HandlePromptCommand(PSDataCollection`1<PSObject> output);
    protected virtual DebuggerCommandResults HandleCallStack(PSDataCollection`1<PSObject> output);
    protected virtual bool HandleListCommand(PSDataCollection`1<PSObject> output);
    internal virtual InvocationInfo FixupInvocationInfo(InvocationInfo debugStopInvocationInfo);
    internal bool IsSameDebugger(Debugger testDebugger);
    internal void CheckStateAndRaiseStopEvent();
    internal PSDataCollection`1<PSObject> GetRSCallStack();
}
public abstract class System.Management.Automation.NullValidationAttributeBase : ValidateArgumentsAttribute {
    protected bool IsArgumentCollection(Type argumentType, Boolean& isElementValueType);
}
internal class System.Management.Automation.NullVariable : PSVariable {
    private string _description;
    public object Value { get; public set; }
    public string Description { get; public set; }
    public ScopedItemOptions Options { get; public set; }
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_Description();
    public virtual void set_Description(string value);
    public virtual ScopedItemOptions get_Options();
    public virtual void set_Options(ScopedItemOptions value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.OrderedHashtable : Hashtable {
    private OrderedDictionary _orderedDictionary;
    public int Count { get; }
    public bool IsFixedSize { get; }
    public bool IsReadOnly { get; }
    public bool IsSynchronized { get; }
    public ICollection Keys { get; }
    public ICollection Values { get; }
    [NullableAttribute("2")]
public object Item { get; public set; }
    public OrderedHashtable(int capacity);
    public OrderedHashtable(IDictionary dictionary);
    public virtual int get_Count();
    public virtual bool get_IsFixedSize();
    public virtual bool get_IsReadOnly();
    public virtual bool get_IsSynchronized();
    public virtual ICollection get_Keys();
    public virtual ICollection get_Values();
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public virtual void Add(object key, object value);
    public virtual void Clear();
    public virtual object Clone();
    public virtual bool Contains(object key);
    public virtual bool ContainsKey(object key);
    [NullableContextAttribute("2")]
public virtual bool ContainsValue(object value);
    public virtual void CopyTo(Array array, int arrayIndex);
    public virtual IDictionaryEnumerator GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual void Remove(object key);
}
internal class System.Management.Automation.OutputProcessingStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <ProcessingOutput>k__BackingField;
    internal bool ProcessingOutput { get; }
    internal OutputProcessingStateEventArgs(bool processingOutput);
    [CompilerGeneratedAttribute]
internal bool get_ProcessingOutput();
}
public enum System.Management.Automation.OutputRendering : Enum {
    public int value__;
    public static OutputRendering Host;
    public static OutputRendering PlainText;
    public static OutputRendering Ansi;
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.OutputTypeAttribute : CmdletMetadataAttribute {
    [CompilerGeneratedAttribute]
private PSTypeName[] <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProviderCmdlet>k__BackingField;
    private String[] _parameterSetName;
    public PSTypeName[] Type { get; }
    public string ProviderCmdlet { get; public set; }
    public String[] ParameterSetName { get; public set; }
    internal OutputTypeAttribute(Type type);
    internal OutputTypeAttribute(string typeName);
    public OutputTypeAttribute(Type[] type);
    public OutputTypeAttribute(String[] type);
    [CompilerGeneratedAttribute]
public PSTypeName[] get_Type();
    [CompilerGeneratedAttribute]
public string get_ProviderCmdlet();
    [CompilerGeneratedAttribute]
public void set_ProviderCmdlet(string value);
    public String[] get_ParameterSetName();
    public void set_ParameterSetName(String[] value);
}
public class System.Management.Automation.PagingParameters : object {
    [CompilerGeneratedAttribute]
private SwitchParameter <IncludeTotalCount>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <Skip>k__BackingField;
    [CompilerGeneratedAttribute]
private ulong <First>k__BackingField;
    [ParameterAttribute]
public SwitchParameter IncludeTotalCount { get; public set; }
    [ParameterAttribute]
public ulong Skip { get; public set; }
    [ParameterAttribute]
public ulong First { get; public set; }
    internal PagingParameters(MshCommandRuntime commandRuntime);
    [CompilerGeneratedAttribute]
public SwitchParameter get_IncludeTotalCount();
    [CompilerGeneratedAttribute]
public void set_IncludeTotalCount(SwitchParameter value);
    [CompilerGeneratedAttribute]
public ulong get_Skip();
    [CompilerGeneratedAttribute]
public void set_Skip(ulong value);
    [CompilerGeneratedAttribute]
public ulong get_First();
    [CompilerGeneratedAttribute]
public void set_First(ulong value);
    public PSObject NewTotalCount(ulong totalCount, double accuracy);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ParameterAttribute : ParsingBaseAttribute {
    public static string AllParameterSets;
    private string _parameterSetName;
    private string _helpMessage;
    private string _helpMessageBaseName;
    private string _helpMessageResourceId;
    [CompilerGeneratedAttribute]
private string <ExperimentName>k__BackingField;
    [CompilerGeneratedAttribute]
private ExperimentAction <ExperimentAction>k__BackingField;
    private ExperimentAction _effectiveAction;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Mandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromPipelineByPropertyName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromRemainingArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DontShow>k__BackingField;
    public string ExperimentName { get; }
    public ExperimentAction ExperimentAction { get; }
    internal bool ToHide { get; }
    internal bool ToShow { get; }
    private ExperimentAction EffectiveAction { get; }
    public int Position { get; public set; }
    public string ParameterSetName { get; public set; }
    public bool Mandatory { get; public set; }
    public bool ValueFromPipeline { get; public set; }
    public bool ValueFromPipelineByPropertyName { get; public set; }
    public bool ValueFromRemainingArguments { get; public set; }
    public string HelpMessage { get; public set; }
    public string HelpMessageBaseName { get; public set; }
    public string HelpMessageResourceId { get; public set; }
    public bool DontShow { get; public set; }
    public ParameterAttribute(string experimentName, ExperimentAction experimentAction);
    [CompilerGeneratedAttribute]
public string get_ExperimentName();
    [CompilerGeneratedAttribute]
public ExperimentAction get_ExperimentAction();
    internal bool get_ToHide();
    internal bool get_ToShow();
    private ExperimentAction get_EffectiveAction();
    [CompilerGeneratedAttribute]
public int get_Position();
    [CompilerGeneratedAttribute]
public void set_Position(int value);
    public string get_ParameterSetName();
    public void set_ParameterSetName(string value);
    [CompilerGeneratedAttribute]
public bool get_Mandatory();
    [CompilerGeneratedAttribute]
public void set_Mandatory(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromPipeline();
    [CompilerGeneratedAttribute]
public void set_ValueFromPipeline(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromPipelineByPropertyName();
    [CompilerGeneratedAttribute]
public void set_ValueFromPipelineByPropertyName(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValueFromRemainingArguments();
    [CompilerGeneratedAttribute]
public void set_ValueFromRemainingArguments(bool value);
    public string get_HelpMessage();
    public void set_HelpMessage(string value);
    public string get_HelpMessageBaseName();
    public void set_HelpMessageBaseName(string value);
    public string get_HelpMessageResourceId();
    public void set_HelpMessageResourceId(string value);
    [CompilerGeneratedAttribute]
public bool get_DontShow();
    [CompilerGeneratedAttribute]
public void set_DontShow(bool value);
}
internal enum System.Management.Automation.ParameterBinderAssociation : Enum {
    public int value__;
    public static ParameterBinderAssociation DeclaredFormalParameters;
    public static ParameterBinderAssociation DynamicParameters;
    public static ParameterBinderAssociation CommonParameters;
    public static ParameterBinderAssociation ShouldProcessParameters;
    public static ParameterBinderAssociation TransactionParameters;
    public static ParameterBinderAssociation PagingParameters;
}
[DebuggerDisplayAttribute("Command = {command}")]
internal abstract class System.Management.Automation.ParameterBinderBase : object {
    [TraceSourceAttribute("ParameterBinderBase", "A abstract helper class for the CommandProcessor that binds parameters to the specified object.")]
private static PSTraceSource s_tracer;
    [TraceSourceAttribute("ParameterBinding", "Traces the process of binding the arguments to the parameters of cmdlets, scripts, and applications.")]
internal static PSTraceSource bindingTracer;
    private object _target;
    private CommandLineParameters _commandLineParameters;
    internal bool RecordBoundParameters;
    internal static string FQIDParameterObsolete;
    private InvocationInfo _invocationInfo;
    private ExecutionContext _context;
    private InternalCommand _command;
    private EngineIntrinsics _engine;
    private bool _isTranscribing;
    internal object Target { get; internal set; }
    internal CommandLineParameters CommandLineParameters { get; internal set; }
    internal InvocationInfo InvocationInfo { get; }
    internal ExecutionContext Context { get; }
    internal InternalCommand Command { get; }
    internal ParameterBinderBase(object target, InvocationInfo invocationInfo, ExecutionContext context, InternalCommand command);
    internal ParameterBinderBase(InvocationInfo invocationInfo, ExecutionContext context, InternalCommand command);
    private static ParameterBinderBase();
    internal object get_Target();
    internal void set_Target(object value);
    internal CommandLineParameters get_CommandLineParameters();
    internal void set_CommandLineParameters(CommandLineParameters value);
    internal abstract virtual object GetDefaultParameterValue(string name);
    internal abstract virtual void BindParameter(string name, object value, CompiledCommandParameter parameterMetadata);
    private void ValidatePSTypeName(CommandParameterInternal parameter, CompiledCommandParameter parameterMetadata, bool retryOtherBindingAfterFailure, object parameterValue);
    internal virtual bool BindParameter(CommandParameterInternal parameter, CompiledCommandParameter parameterMetadata, ParameterBindingFlags flags);
    private void ValidateNullOrEmptyArgument(CommandParameterInternal parameter, CompiledCommandParameter parameterMetadata, Type argumentType, object parameterValue, bool recurseIntoCollections);
    private bool ShouldContinueUncoercedBind(CommandParameterInternal parameter, CompiledCommandParameter parameterMetadata, ParameterBindingFlags flags, Object& parameterValue);
    internal InvocationInfo get_InvocationInfo();
    internal ExecutionContext get_Context();
    internal InternalCommand get_Command();
    private object CoerceTypeAsNeeded(CommandParameterInternal argument, string parameterName, Type toType, ParameterCollectionTypeInformation collectionTypeInfo, object currentValue);
    private static bool IsNullParameterValue(object currentValue);
    private object HandleNullParameterForSpecialTypes(CommandParameterInternal argument, string parameterName, Type toType, object currentValue);
    private object EncodeCollection(CommandParameterInternal argument, string parameterName, ParameterCollectionTypeInformation collectionTypeInformation, Type toType, object currentValue, bool coerceElementTypeIfNeeded, Boolean& coercionRequired);
    internal static IList GetIList(object value);
    protected IScriptExtent GetErrorExtent(CommandParameterInternal cpi);
    protected IScriptExtent GetParameterErrorExtent(CommandParameterInternal cpi);
}
[DebuggerDisplayAttribute("InvocationInfo = {InvocationInfo}")]
internal abstract class System.Management.Automation.ParameterBinderController : object {
    [CompilerGeneratedAttribute]
private ExecutionContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ParameterBinderBase <DefaultParameterBinder>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationInfo <InvocationInfo>k__BackingField;
    protected MergedCommandParameterMetadata _bindableParameters;
    [CompilerGeneratedAttribute]
private List`1<MergedCompiledCommandParameter> <UnboundParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MergedCompiledCommandParameter> <BoundParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DefaultParameterBindingInUse>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <BoundDefaultParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<CommandParameterInternal> <UnboundArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, CommandParameterInternal> <BoundArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<MergedCompiledCommandParameter> <ParametersBoundThroughPipelineInput>k__BackingField;
    internal UInt32 _currentParameterSetFlag;
    internal UInt32 _prePipelineProcessingParameterSetFlags;
    internal ExecutionContext Context { get; }
    internal ParameterBinderBase DefaultParameterBinder { get; }
    internal InvocationInfo InvocationInfo { get; }
    internal MergedCommandParameterMetadata BindableParameters { get; }
    protected List`1<MergedCompiledCommandParameter> UnboundParameters { get; protected set; }
    protected Dictionary`2<string, MergedCompiledCommandParameter> BoundParameters { get; }
    internal CommandLineParameters CommandLineParameters { get; }
    protected bool DefaultParameterBindingInUse { get; protected set; }
    protected Collection`1<string> BoundDefaultParameters { get; }
    protected Collection`1<CommandParameterInternal> UnboundArguments { get; protected set; }
    protected Dictionary`2<string, CommandParameterInternal> BoundArguments { get; }
    internal Collection`1<MergedCompiledCommandParameter> ParametersBoundThroughPipelineInput { get; }
    internal ParameterBinderController(InvocationInfo invocationInfo, ExecutionContext context, ParameterBinderBase parameterBinder);
    [CompilerGeneratedAttribute]
internal ExecutionContext get_Context();
    [CompilerGeneratedAttribute]
internal ParameterBinderBase get_DefaultParameterBinder();
    [CompilerGeneratedAttribute]
internal InvocationInfo get_InvocationInfo();
    internal MergedCommandParameterMetadata get_BindableParameters();
    [CompilerGeneratedAttribute]
protected List`1<MergedCompiledCommandParameter> get_UnboundParameters();
    [CompilerGeneratedAttribute]
protected void set_UnboundParameters(List`1<MergedCompiledCommandParameter> value);
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, MergedCompiledCommandParameter> get_BoundParameters();
    internal CommandLineParameters get_CommandLineParameters();
    [CompilerGeneratedAttribute]
protected bool get_DefaultParameterBindingInUse();
    [CompilerGeneratedAttribute]
protected void set_DefaultParameterBindingInUse(bool value);
    [CompilerGeneratedAttribute]
protected Collection`1<string> get_BoundDefaultParameters();
    [CompilerGeneratedAttribute]
protected Collection`1<CommandParameterInternal> get_UnboundArguments();
    [CompilerGeneratedAttribute]
protected void set_UnboundArguments(Collection`1<CommandParameterInternal> value);
    internal void ClearUnboundArguments();
    [CompilerGeneratedAttribute]
protected Dictionary`2<string, CommandParameterInternal> get_BoundArguments();
    protected void ReparseUnboundArguments();
    protected void InitUnboundArguments(Collection`1<CommandParameterInternal> arguments);
    private static bool IsSwitchAndSetValue(string argumentName, CommandParameterInternal argument, CompiledCommandParameter matchingParameter);
    internal static bool ArgumentLooksLikeParameter(string arg);
    internal static void AddArgumentsToCommandProcessor(CommandProcessorBase commandProcessor, Object[] arguments);
    internal virtual bool BindParameter(CommandParameterInternal argument, ParameterBindingFlags flags);
    internal virtual Collection`1<CommandParameterInternal> BindParameters(Collection`1<CommandParameterInternal> parameters);
    internal virtual bool BindParameter(UInt32 parameterSets, CommandParameterInternal argument, MergedCompiledCommandParameter parameter, ParameterBindingFlags flags);
    protected virtual void BindNamedParameter(UInt32 parameterSets, CommandParameterInternal argument, MergedCompiledCommandParameter parameter);
    protected Collection`1<CommandParameterInternal> BindNamedParameters(UInt32 parameterSets, Collection`1<CommandParameterInternal> arguments);
    internal Collection`1<CommandParameterInternal> BindPositionalParameters(Collection`1<CommandParameterInternal> unboundArguments, UInt32 validParameterSets, UInt32 defaultParameterSet, ParameterBindingException& outgoingBindingException);
    internal static void UpdatePositionalDictionary(SortedDictionary`2<int, Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter>> positionalParameterDictionary, UInt32 validParameterSets);
    private bool BindPositionalParametersInSet(UInt32 validParameterSets, Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter> nextPositionalParameters, CommandParameterInternal argument, ParameterBindingFlags flags, ParameterBindingException& bindingException);
    protected void ThrowElaboratedBindingException(ParameterBindingException pbex);
    private static CommandParameterInternal GetNextPositionalArgument(List`1<CommandParameterInternal> unboundArgumentsCollection, Collection`1<CommandParameterInternal> nonPositionalArguments, Int32& unboundArgumentsIndex);
    internal static SortedDictionary`2<int, Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter>> EvaluateUnboundPositionalParameters(ICollection`1<MergedCompiledCommandParameter> unboundParameters, UInt32 validParameterSetFlag);
    private static void AddNewPosition(SortedDictionary`2<int, Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter>> result, int positionInParameterSet, MergedCompiledCommandParameter parameter, ParameterSetSpecificMetadata parameterSetData);
    private static bool ContainsPositionalParameterInSet(Dictionary`2<MergedCompiledCommandParameter, PositionalCommandParameter> positionalCommandParameters, MergedCompiledCommandParameter parameter, UInt32 parameterSet);
    [CompilerGeneratedAttribute]
internal Collection`1<MergedCompiledCommandParameter> get_ParametersBoundThroughPipelineInput();
    internal void BindUnboundScriptParameters();
    protected virtual void SaveDefaultScriptParameterValue(string name, object value);
    internal void BindUnboundScriptParameterWithDefaultValue(MergedCompiledCommandParameter parameter);
    protected IScriptExtent GetErrorExtent(CommandParameterInternal cpi);
    protected IScriptExtent GetParameterErrorExtent(CommandParameterInternal cpi);
}
internal class System.Management.Automation.ParameterBindingArgumentTransformationException : ParameterBindingException {
    internal ParameterBindingArgumentTransformationException(ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    internal ParameterBindingArgumentTransformationException(Exception innerException, ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParameterBindingArgumentTransformationException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.ParameterBindingException : RuntimeException {
    private string _message;
    private string _parameterName;
    private Type _parameterType;
    private Type _typeSpecified;
    private string _errorId;
    private long _line;
    private long _offset;
    private InvocationInfo _invocationInfo;
    private string _resourceString;
    private Object[] _args;
    private string _commandName;
    public string Message { get; }
    public string ParameterName { get; }
    public Type ParameterType { get; }
    public Type TypeSpecified { get; }
    public string ErrorId { get; }
    public long Line { get; }
    public long Offset { get; }
    public InvocationInfo CommandInvocation { get; }
    internal ParameterBindingException(ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    internal ParameterBindingException(Exception innerException, ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    internal ParameterBindingException(Exception innerException, ParameterBindingException pbex, string resourceString, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParameterBindingException(SerializationInfo info, StreamingContext context);
    public ParameterBindingException(string message);
    public ParameterBindingException(string message, Exception innerException);
    public virtual string get_Message();
    public string get_ParameterName();
    public Type get_ParameterType();
    public Type get_TypeSpecified();
    public string get_ErrorId();
    public long get_Line();
    public long get_Offset();
    public InvocationInfo get_CommandInvocation();
    private string BuildMessage();
}
[FlagsAttribute]
internal enum System.Management.Automation.ParameterBindingFlags : Enum {
    public int value__;
    public static ParameterBindingFlags None;
    public static ParameterBindingFlags ShouldCoerceType;
    public static ParameterBindingFlags IsDefaultValue;
    public static ParameterBindingFlags DelayBindScriptBlock;
    public static ParameterBindingFlags ThrowOnParameterNotFound;
}
internal class System.Management.Automation.ParameterBindingParameterDefaultValueException : ParameterBindingException {
    internal ParameterBindingParameterDefaultValueException(ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    internal ParameterBindingParameterDefaultValueException(Exception innerException, ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParameterBindingParameterDefaultValueException(SerializationInfo info, StreamingContext context);
}
internal class System.Management.Automation.ParameterBindingValidationException : ParameterBindingException {
    private bool _swallowException;
    internal bool SwallowException { get; }
    internal ParameterBindingValidationException(ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    internal ParameterBindingValidationException(Exception innerException, ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string parameterName, Type parameterType, Type typeSpecified, string resourceString, string errorId, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParameterBindingValidationException(SerializationInfo info, StreamingContext context);
    internal bool get_SwallowException();
}
internal enum System.Management.Automation.ParameterCollectionType : Enum {
    public int value__;
    public static ParameterCollectionType NotCollection;
    public static ParameterCollectionType IList;
    public static ParameterCollectionType Array;
    public static ParameterCollectionType ICollectionGeneric;
}
internal class System.Management.Automation.ParameterCollectionTypeInformation : object {
    [CompilerGeneratedAttribute]
private ParameterCollectionType <ParameterCollectionType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ElementType>k__BackingField;
    internal ParameterCollectionType ParameterCollectionType { get; }
    internal Type ElementType { get; }
    internal ParameterCollectionTypeInformation(Type type);
    [CompilerGeneratedAttribute]
internal ParameterCollectionType get_ParameterCollectionType();
    [CompilerGeneratedAttribute]
internal Type get_ElementType();
}
internal class System.Management.Automation.ParameterInformation : object {
    internal Type parameterType;
    internal object defaultValue;
    internal bool isOptional;
    internal bool isByRef;
    internal bool isParamArray;
    internal ParameterInformation(ParameterInfo parameter);
    internal ParameterInformation(Type parameterType, bool isOptional, object defaultValue, bool isByRef);
}
public class System.Management.Automation.ParameterMetadata : object {
    private string _name;
    private Type _parameterType;
    private bool _isDynamic;
    private Dictionary`2<string, ParameterSetMetadata> _parameterSets;
    private Collection`1<string> _aliases;
    private Collection`1<Attribute> _attributes;
    private static string ParameterNameFormat;
    private static string ParameterTypeFormat;
    private static string ParameterSetNameFormat;
    private static string AliasesFormat;
    private static string ValidateLengthFormat;
    private static string ValidateRangeRangeKindFormat;
    private static string ValidateRangeEnumFormat;
    private static string ValidateRangeFloatFormat;
    private static string ValidateRangeFormat;
    private static string ValidatePatternFormat;
    private static string ValidateScriptFormat;
    private static string ValidateCountFormat;
    private static string ValidateSetFormat;
    private static string ValidateNotNullFormat;
    private static string ValidateNotNullOrEmptyFormat;
    private static string ValidateNotNullOrWhiteSpaceFormat;
    private static string AllowNullFormat;
    private static string AllowEmptyStringFormat;
    private static string AllowEmptyCollectionFormat;
    private static string PSTypeNameFormat;
    private static string ObsoleteFormat;
    private static string CredentialAttributeFormat;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public Dictionary`2<string, ParameterSetMetadata> ParameterSets { get; }
    public bool IsDynamic { get; public set; }
    public Collection`1<string> Aliases { get; }
    public Collection`1<Attribute> Attributes { get; }
    public bool SwitchParameter { get; }
    public ParameterMetadata(string name);
    public ParameterMetadata(string name, Type parameterType);
    public ParameterMetadata(ParameterMetadata other);
    internal ParameterMetadata(CompiledCommandParameter cmdParameterMD);
    internal ParameterMetadata(Collection`1<string> aliases, bool isDynamic, string name, Dictionary`2<string, ParameterSetMetadata> parameterSets, Type parameterType);
    public string get_Name();
    public void set_Name(string value);
    public Type get_ParameterType();
    public void set_ParameterType(Type value);
    public Dictionary`2<string, ParameterSetMetadata> get_ParameterSets();
    public bool get_IsDynamic();
    public void set_IsDynamic(bool value);
    public Collection`1<string> get_Aliases();
    public Collection`1<Attribute> get_Attributes();
    public bool get_SwitchParameter();
    public static Dictionary`2<string, ParameterMetadata> GetParameterMetadata(Type type);
    internal void Initialize(CompiledCommandParameter compiledParameterMD);
    internal static Dictionary`2<string, ParameterMetadata> GetParameterMetadata(MergedCommandParameterMetadata cmdParameterMetadata);
    internal bool IsMatchingType(PSTypeName psTypeName);
    internal string GetProxyParameterData(string prefix, string paramNameOverride, bool isProxyForCmdlet);
    private static string GetProxyAttributeData(Attribute attrib, string prefix);
}
public class System.Management.Automation.ParameterSetMetadata : object {
    private bool _isMandatory;
    private int _position;
    private bool _valueFromPipeline;
    private bool _valueFromPipelineByPropertyName;
    private bool _valueFromRemainingArguments;
    private string _helpMessage;
    private string _helpMessageBaseName;
    private string _helpMessageResourceId;
    private static string MandatoryFormat;
    private static string PositionFormat;
    private static string ValueFromPipelineFormat;
    private static string ValueFromPipelineByPropertyNameFormat;
    private static string ValueFromRemainingArgumentsFormat;
    private static string HelpMessageFormat;
    public bool IsMandatory { get; public set; }
    public int Position { get; public set; }
    public bool ValueFromPipeline { get; public set; }
    public bool ValueFromPipelineByPropertyName { get; public set; }
    public bool ValueFromRemainingArguments { get; public set; }
    public string HelpMessage { get; public set; }
    public string HelpMessageBaseName { get; public set; }
    public string HelpMessageResourceId { get; public set; }
    internal ParameterFlags Flags { get; internal set; }
    internal ParameterSetMetadata(ParameterSetSpecificMetadata psMD);
    internal ParameterSetMetadata(ParameterSetMetadata other);
    internal ParameterSetMetadata(int position, ParameterFlags flags, string helpMessage);
    public bool get_IsMandatory();
    public void set_IsMandatory(bool value);
    public int get_Position();
    public void set_Position(int value);
    public bool get_ValueFromPipeline();
    public void set_ValueFromPipeline(bool value);
    public bool get_ValueFromPipelineByPropertyName();
    public void set_ValueFromPipelineByPropertyName(bool value);
    public bool get_ValueFromRemainingArguments();
    public void set_ValueFromRemainingArguments(bool value);
    public string get_HelpMessage();
    public void set_HelpMessage(string value);
    public string get_HelpMessageBaseName();
    public void set_HelpMessageBaseName(string value);
    public string get_HelpMessageResourceId();
    public void set_HelpMessageResourceId(string value);
    internal void Initialize(ParameterSetSpecificMetadata psMD);
    internal bool Equals(ParameterSetMetadata second);
    internal ParameterFlags get_Flags();
    internal void set_Flags(ParameterFlags value);
    internal string GetProxyParameterData();
}
internal class System.Management.Automation.ParameterSetPromptingData : object {
    [CompilerGeneratedAttribute]
private bool <IsDefaultSet>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ParameterSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> <PipelineableMandatoryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> <PipelineableMandatoryByValueParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> <PipelineableMandatoryByPropertyNameParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> <NonpipelineableMandatoryParameters>k__BackingField;
    internal bool IsDefaultSet { get; }
    internal UInt32 ParameterSet { get; }
    internal bool IsAllSet { get; }
    internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> PipelineableMandatoryParameters { get; }
    internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> PipelineableMandatoryByValueParameters { get; }
    internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> PipelineableMandatoryByPropertyNameParameters { get; }
    internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> NonpipelineableMandatoryParameters { get; }
    internal ParameterSetPromptingData(UInt32 parameterSet, bool isDefaultSet);
    [CompilerGeneratedAttribute]
internal bool get_IsDefaultSet();
    [CompilerGeneratedAttribute]
internal UInt32 get_ParameterSet();
    internal bool get_IsAllSet();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> get_PipelineableMandatoryParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> get_PipelineableMandatoryByValueParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> get_PipelineableMandatoryByPropertyNameParameters();
    [CompilerGeneratedAttribute]
internal Dictionary`2<MergedCompiledCommandParameter, ParameterSetSpecificMetadata> get_NonpipelineableMandatoryParameters();
}
internal class System.Management.Automation.ParameterSetSpecificMetadata : object {
    [CompilerGeneratedAttribute]
private bool <IsMandatory>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Position>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValueFromRemainingArguments>k__BackingField;
    internal bool valueFromPipeline;
    internal bool valueFromPipelineByPropertyName;
    [CompilerGeneratedAttribute]
private string <HelpMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpMessageBaseName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpMessageResourceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInAllSets>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ParameterSetFlag>k__BackingField;
    private ParameterAttribute _attribute;
    internal bool IsMandatory { get; }
    internal int Position { get; }
    internal bool IsPositional { get; }
    internal bool ValueFromRemainingArguments { get; }
    internal bool ValueFromPipeline { get; }
    internal bool ValueFromPipelineByPropertyName { get; }
    internal string HelpMessage { get; }
    internal string HelpMessageBaseName { get; }
    internal string HelpMessageResourceId { get; }
    internal bool IsInAllSets { get; internal set; }
    internal UInt32 ParameterSetFlag { get; internal set; }
    internal ParameterSetSpecificMetadata(ParameterAttribute attribute);
    internal ParameterSetSpecificMetadata(bool isMandatory, int position, bool valueFromRemainingArguments, bool valueFromPipeline, bool valueFromPipelineByPropertyName, string helpMessageBaseName, string helpMessageResourceId, string helpMessage);
    [CompilerGeneratedAttribute]
internal bool get_IsMandatory();
    [CompilerGeneratedAttribute]
internal int get_Position();
    internal bool get_IsPositional();
    [CompilerGeneratedAttribute]
internal bool get_ValueFromRemainingArguments();
    internal bool get_ValueFromPipeline();
    internal bool get_ValueFromPipelineByPropertyName();
    [CompilerGeneratedAttribute]
internal string get_HelpMessage();
    [CompilerGeneratedAttribute]
internal string get_HelpMessageBaseName();
    [CompilerGeneratedAttribute]
internal string get_HelpMessageResourceId();
    [CompilerGeneratedAttribute]
internal bool get_IsInAllSets();
    [CompilerGeneratedAttribute]
internal void set_IsInAllSets(bool value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ParameterSetFlag();
    [CompilerGeneratedAttribute]
internal void set_ParameterSetFlag(UInt32 value);
    internal string GetHelpMessage(Cmdlet cmdlet);
}
public class System.Management.Automation.ParentContainsErrorRecordException : SystemException {
    private Exception _wrapperException;
    private string _message;
    public string Message { get; }
    public ParentContainsErrorRecordException(Exception wrapperException);
    public ParentContainsErrorRecordException(string message);
    public ParentContainsErrorRecordException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParentContainsErrorRecordException(SerializationInfo info, StreamingContext context);
    public virtual string get_Message();
}
public class System.Management.Automation.ParseException : RuntimeException {
    private static string errorIdString;
    private ParseError[] _errors;
    public ParseError[] Errors { get; }
    public string Message { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParseException(SerializationInfo info, StreamingContext context);
    public ParseException(string message);
    internal ParseException(string message, string errorId);
    internal ParseException(string message, string errorId, Exception innerException);
    public ParseException(string message, Exception innerException);
    public ParseException(ParseError[] errors);
    public ParseError[] get_Errors();
    public virtual string get_Message();
}
internal static class System.Management.Automation.ParserOps : object {
    internal static string MethodNotFoundErrorId;
    private static int _MinCache;
    private static int _MaxCache;
    private static Object[] s_integerCache;
    private static String[] s_chars;
    internal static object _TrueObject;
    internal static object _FalseObject;
    private static ConcurrentDictionary`2<RegexOptions, ConcurrentDictionary`2<string, Regex>> s_regexCache;
    private static Func`2<RegexOptions, ConcurrentDictionary`2<string, Regex>> s_subordinateRegexCacheCreationDelegate;
    private static int MaxRegexCache;
    private static ParserOps();
    internal static string CharToString(char ch);
    internal static object BoolToObject(bool value);
    internal static object IntToObject(int value);
    internal static PSObject WrappedNumber(object data, string text);
    internal static int FixNum(object obj, IScriptExtent errorPosition);
    internal static T ConvertTo(object obj, IScriptExtent errorPosition);
    internal static object ImplicitOp(object lval, object rval, string op, IScriptExtent errorPosition, string errorOp);
    private static Object[] unfoldTuple(ExecutionContext context, IScriptExtent errorPosition, object tuple);
    [IteratorStateMachineAttribute("System.Management.Automation.ParserOps/<enumerateContent>d__17")]
private static IEnumerable`1<string> enumerateContent(ExecutionContext context, IScriptExtent errorPosition, SplitImplOptions implOptions, object tuple);
    private static RegexOptions parseRegexOptions(SplitOptions options);
    internal static object UnarySplitOperator(ExecutionContext context, IScriptExtent errorPosition, object lval);
    internal static object SplitOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, bool ignoreCase);
    private static IReadOnlyList`1<string> SplitOperatorImpl(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, SplitImplOptions implOptions, bool ignoreCase);
    private static IReadOnlyList`1<string> NegativeSplitWithPredicate(ExecutionContext context, IScriptExtent errorPosition, IEnumerable`1<string> content, ScriptBlock predicate, int limit);
    private static IReadOnlyList`1<string> SplitWithPredicate(ExecutionContext context, IScriptExtent errorPosition, IEnumerable`1<string> content, ScriptBlock predicate, int limit);
    private static IReadOnlyList`1<string> SplitWithPattern(ExecutionContext context, IScriptExtent errorPosition, IEnumerable`1<string> content, string separatorPattern, int limit, SplitOptions options);
    internal static object UnaryJoinOperator(ExecutionContext context, IScriptExtent errorPosition, object lval);
    internal static object JoinOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval);
    internal static object RangeOperator(object lval, object rval);
    internal static IEnumerator GetRangeEnumerator(object lval, object rval);
    private static object AsChar(object obj);
    internal static object ReplaceOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, bool ignoreCase);
    internal static object IsOperator(ExecutionContext context, IScriptExtent errorPosition, object left, object right);
    internal static object IsNotOperator(ExecutionContext context, IScriptExtent errorPosition, object left, object right);
    internal static object LikeOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, TokenKind operator);
    internal static object MatchOperator(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, bool notMatch, bool ignoreCase);
    internal static bool ContainsOperatorCompiled(ExecutionContext context, CallSite`1<Func`3<CallSite, object, IEnumerator>> getEnumeratorSite, CallSite`1<Func`4<CallSite, object, object, object>> comparerSite, object left, object right);
    internal static object ContainsOperator(ExecutionContext context, IScriptExtent errorPosition, object left, object right, bool contains, bool ignoreCase);
    internal static object CompareOperators(ExecutionContext context, IScriptExtent errorPosition, object left, object right, CompareDelegate compareDelegate, bool ignoreCase);
    internal static Regex NewRegex(string patternString, RegexOptions options);
    internal static bool MoveNext(ExecutionContext context, IScriptExtent errorPosition, IEnumerator enumerator);
    internal static object Current(IScriptExtent errorPosition, IEnumerator enumerator);
    internal static string GetTypeFullName(object obj);
    internal static object CallMethod(IScriptExtent errorPosition, object target, string methodName, PSMethodInvocationConstraints invocationConstraints, Object[] paramArray, bool callStatic, object valueToSet);
}
public class System.Management.Automation.ParsingMetadataException : MetadataException {
    internal static string ParsingTooManyParameterSets;
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ParsingMetadataException(SerializationInfo info, StreamingContext context);
    public ParsingMetadataException(string message);
    public ParsingMetadataException(string message, Exception innerException);
    internal ParsingMetadataException(string errorId, Exception innerException, string resourceStr, Object[] arguments);
}
public class System.Management.Automation.PathInfo : object {
    private string _providerPath;
    private SessionState _sessionState;
    private PSDriveInfo _drive;
    private ProviderInfo _provider;
    private string _path;
    public PSDriveInfo Drive { get; }
    public ProviderInfo Provider { get; }
    public string ProviderPath { get; }
    public string Path { get; }
    internal PathInfo(PSDriveInfo drive, ProviderInfo provider, string path, SessionState sessionState);
    public PSDriveInfo get_Drive();
    public ProviderInfo get_Provider();
    internal PSDriveInfo GetDrive();
    public string get_ProviderPath();
    public string get_Path();
    public virtual string ToString();
}
public class System.Management.Automation.PathInfoStack : Stack`1<PathInfo> {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; }
    internal PathInfoStack(string stackName, Stack`1<PathInfo> locationStack);
    [CompilerGeneratedAttribute]
public string get_Name();
}
public class System.Management.Automation.PathIntrinsics : object {
    private LocationGlobber _pathResolver;
    private SessionStateInternal _sessionState;
    public PathInfo CurrentLocation { get; }
    public PathInfo CurrentFileSystemLocation { get; }
    private LocationGlobber PathResolver { get; }
    internal PathIntrinsics(SessionStateInternal sessionState);
    public PathInfo get_CurrentLocation();
    public PathInfo CurrentProviderLocation(string providerName);
    public PathInfo get_CurrentFileSystemLocation();
    public PathInfo SetLocation(string path);
    internal PathInfo SetLocation(string path, CmdletProviderContext context);
    internal PathInfo SetLocation(string path, CmdletProviderContext context, bool literalPath);
    internal bool IsCurrentLocationOrAncestor(string path, CmdletProviderContext context);
    public void PushCurrentLocation(string stackName);
    public PathInfo PopLocation(string stackName);
    public PathInfoStack LocationStack(string stackName);
    public PathInfoStack SetDefaultLocationStack(string stackName);
    public Collection`1<PathInfo> GetResolvedPSPathFromPSPath(string path);
    internal Collection`1<PathInfo> GetResolvedPSPathFromPSPath(string path, CmdletProviderContext context);
    public Collection`1<string> GetResolvedProviderPathFromPSPath(string path, ProviderInfo& provider);
    internal Collection`1<string> GetResolvedProviderPathFromPSPath(string path, bool allowNonexistingPaths, ProviderInfo& provider);
    internal Collection`1<string> GetResolvedProviderPathFromPSPath(string path, CmdletProviderContext context, ProviderInfo& provider);
    public Collection`1<string> GetResolvedProviderPathFromProviderPath(string path, string providerId);
    internal Collection`1<string> GetResolvedProviderPathFromProviderPath(string path, string providerId, CmdletProviderContext context);
    public string GetUnresolvedProviderPathFromPSPath(string path);
    public string GetUnresolvedProviderPathFromPSPath(string path, ProviderInfo& provider, PSDriveInfo& drive);
    internal string GetUnresolvedProviderPathFromPSPath(string path, CmdletProviderContext context, ProviderInfo& provider, PSDriveInfo& drive);
    public bool IsProviderQualified(string path);
    public bool IsPSAbsolute(string path, String& driveName);
    public string Combine(string parent, string child);
    internal string Combine(string parent, string child, CmdletProviderContext context);
    public string ParseParent(string path, string root);
    internal string ParseParent(string path, string root, CmdletProviderContext context);
    internal string ParseParent(string path, string root, CmdletProviderContext context, bool useDefaultProvider);
    public string ParseChildName(string path);
    internal string ParseChildName(string path, CmdletProviderContext context);
    internal string ParseChildName(string path, CmdletProviderContext context, bool useDefaultProvider);
    public string NormalizeRelativePath(string path, string basePath);
    internal string NormalizeRelativePath(string path, string basePath, CmdletProviderContext context);
    public bool IsValid(string path);
    internal bool IsValid(string path, CmdletProviderContext context);
    private LocationGlobber get_PathResolver();
}
internal static class System.Management.Automation.PathUtils : object {
    [NullableAttribute("1")]
private static string ExtendedDevicePathPrefix;
    [NullableAttribute("1")]
private static string UncPathPrefix;
    [NullableAttribute("1")]
private static string UncDevicePrefixToInsert;
    [NullableAttribute("1")]
private static string UncExtendedPathPrefix;
    [NullableAttribute("1")]
private static string DevicePathPrefix;
    private static int MaxShortPath;
    private static int DevicePrefixLength;
    internal static void MasterStreamOpen(PSCmdlet cmdlet, string filePath, string encoding, bool defaultEncoding, bool Append, bool Force, bool NoClobber, FileStream& fileStream, StreamWriter& streamWriter, FileInfo& readOnlyFileInfo, bool isLiteralPath);
    internal static void MasterStreamOpen(PSCmdlet cmdlet, string filePath, Encoding resolvedEncoding, bool defaultEncoding, bool Append, bool Force, bool NoClobber, FileStream& fileStream, StreamWriter& streamWriter, FileInfo& readOnlyFileInfo, bool isLiteralPath);
    internal static void MasterStreamOpen(string filePath, Encoding resolvedEncoding, bool defaultEncoding, bool Append, bool Force, bool NoClobber, FileStream& fileStream, StreamWriter& streamWriter, FileInfo& readOnlyFileInfo, bool isLiteralPath);
    internal static void MasterStreamOpenImpl(string resolvedPath, Encoding resolvedEncoding, bool defaultEncoding, bool Append, bool Force, bool NoClobber, FileStream& fileStream, StreamWriter& streamWriter, FileInfo& readOnlyFileInfo);
    internal static void ReportFileOpenFailure(Cmdlet cmdlet, string filePath, Exception e);
    internal static void ReportFileOpenFailure(string filePath, Exception e);
    internal static StreamReader OpenStreamReader(PSCmdlet command, string filePath, Encoding encoding, bool isLiteralPath);
    internal static FileStream OpenFileStream(string filePath, PSCmdlet command, bool isLiteralPath);
    internal static string ResolveFilePath(string filePath, PSCmdlet command);
    internal static string ResolveFilePath(string filePath, PSCmdlet command, bool isLiteralPath);
    internal static string ResolveFilePath(string filePath, bool isLiteralPath);
    internal static void ReportWrongProviderType(Cmdlet cmdlet, string providerId);
    internal static void ReportWrongProviderType(string providerId);
    internal static void ReportMultipleFilesNotSupported(Cmdlet cmdlet);
    internal static void ReportMultipleFilesNotSupported();
    internal static void ReportWildcardingFailure(Cmdlet cmdlet, string filePath);
    internal static void ReportWildcardingFailure(string filePath);
    internal static DirectoryInfo CreateModuleDirectory(PSCmdlet cmdlet, string moduleNameOrPath, bool force);
    internal static DirectoryInfo CreateTemporaryDirectory();
    internal static bool TryDeleteFile(string filepath);
    [NullableContextAttribute("2")]
internal static string EnsureExtendedPrefixIfNeeded(string path);
    [NullableContextAttribute("1")]
internal static string EnsureExtendedPrefix(string path);
    [NullableContextAttribute("2")]
private static bool EndsWithPeriodOrSpace(string path);
    private static bool IsValidDriveChar(char value);
    [NullableContextAttribute("1")]
private static bool IsDevice(string path);
    [NullableContextAttribute("1")]
private static bool IsExtended(string path);
    [NullableContextAttribute("1")]
private static bool IsPartiallyQualified(string path);
    private static bool IsDirectorySeparator(char c);
    [CompilerGeneratedAttribute]
internal static void <MasterStreamOpen>g__AddFileOpenErrorRecord|2_0(Exception e);
}
internal static class System.Management.Automation.PinvokeDllNames : object {
    internal static string QueryDosDeviceDllName;
    internal static string CreateSymbolicLinkDllName;
    internal static string GetOEMCPDllName;
    internal static string DeviceIoControlDllName;
    internal static string CreateFileDllName;
    internal static string DeleteFileDllName;
    internal static string FindCloseDllName;
    internal static string GetFileAttributesDllName;
    internal static string FindFirstFileDllName;
    internal static string FindNextFileDllName;
    internal static string RegEnumValueDllName;
    internal static string RegOpenKeyExDllName;
    internal static string RegOpenKeyTransactedDllName;
    internal static string RegQueryInfoKeyDllName;
    internal static string RegQueryValueExDllName;
    internal static string RegSetValueExDllName;
    internal static string RegCreateKeyTransactedDllName;
    internal static string CryptGenKeyDllName;
    internal static string CryptDestroyKeyDllName;
    internal static string CryptAcquireContextDllName;
    internal static string CryptReleaseContextDllName;
    internal static string CryptEncryptDllName;
    internal static string CryptDecryptDllName;
    internal static string CryptExportKeyDllName;
    internal static string CryptImportKeyDllName;
    internal static string CryptDuplicateKeyDllName;
    internal static string GetLastErrorDllName;
    internal static string GetCPInfoDllName;
    internal static string CommandLineToArgvDllName;
    internal static string LocalFreeDllName;
    internal static string CloseHandleDllName;
    internal static string GetTokenInformationDllName;
    internal static string LookupAccountSidDllName;
    internal static string OpenProcessTokenDllName;
    internal static string DosDateTimeToFileTimeDllName;
    internal static string LocalFileTimeToFileTimeDllName;
    internal static string SetFileTimeDllName;
    internal static string SetFileAttributesWDllName;
    internal static string CreateHardLinkDllName;
    internal static string RegCloseKeyDllName;
    internal static string GetFileInformationByHandleDllName;
    internal static string FindFirstStreamDllName;
    internal static string FindNextStreamDllName;
    internal static string GetSystemInfoDllName;
    internal static string GetCurrentThreadIdDllName;
    internal static string SetLocalTimeDllName;
    internal static string CryptSetProvParamDllName;
    internal static string GetNamedSecurityInfoDllName;
    internal static string SetNamedSecurityInfoDllName;
    internal static string ConvertStringSidToSidDllName;
    internal static string IsValidSidDllName;
    internal static string GetLengthSidDllName;
    internal static string LsaFreeMemoryDllName;
    internal static string InitializeAclDllName;
    internal static string GetCurrentProcessDllName;
    internal static string GetCurrentThreadDllName;
    internal static string OpenThreadTokenDllName;
    internal static string LookupPrivilegeValueDllName;
    internal static string AdjustTokenPrivilegesDllName;
    internal static string GetStdHandleDllName;
    internal static string CreateProcessWithLogonWDllName;
    internal static string CreateProcessDllName;
    internal static string ResumeThreadDllName;
    internal static string OpenSCManagerWDllName;
    internal static string OpenServiceWDllName;
    internal static string CloseServiceHandleDllName;
    internal static string ChangeServiceConfigWDllName;
    internal static string ChangeServiceConfig2WDllName;
    internal static string CreateServiceWDllName;
    internal static string CreateJobObjectDllName;
    internal static string AssignProcessToJobObjectDllName;
    internal static string QueryInformationJobObjectDllName;
    internal static string CreateNamedPipeDllName;
    internal static string WaitNamedPipeDllName;
    internal static string PrivilegeCheckDllName;
    internal static string ImpersonateNamedPipeClientDllName;
    internal static string RevertToSelfDllName;
    internal static string CreateProcessInComputeSystemDllName;
    internal static string CLSIDFromProgIDDllName;
    internal static string LoadLibraryEx;
    internal static string FreeLibrary;
    internal static string EventActivityIdControlDllName;
    internal static string GetConsoleCPDllName;
    internal static string GetConsoleOutputCPDllName;
    internal static string GetConsoleWindowDllName;
    internal static string GetDCDllName;
    internal static string ReleaseDCDllName;
    internal static string TranslateCharsetInfoDllName;
    internal static string GetTextMetricsDllName;
    internal static string GetCharWidth32DllName;
    internal static string FlushConsoleInputBufferDllName;
    internal static string FillConsoleOutputAttributeDllName;
    internal static string FillConsoleOutputCharacterDllName;
    internal static string WriteConsoleDllName;
    internal static string GetConsoleTitleDllName;
    internal static string SetConsoleTitleDllName;
    internal static string GetConsoleModeDllName;
    internal static string GetConsoleScreenBufferInfoDllName;
    internal static string GetFileTypeDllName;
    internal static string GetLargestConsoleWindowSizeDllName;
    internal static string ReadConsoleDllName;
    internal static string PeekConsoleInputDllName;
    internal static string GetNumberOfConsoleInputEventsDllName;
    internal static string SetConsoleCtrlHandlerDllName;
    internal static string SetConsoleModeDllName;
    internal static string SetConsoleScreenBufferSizeDllName;
    internal static string SetConsoleTextAttributeDllName;
    internal static string SetConsoleWindowInfoDllName;
    internal static string WriteConsoleOutputDllName;
    internal static string ReadConsoleOutputDllName;
    internal static string ScrollConsoleScreenBufferDllName;
    internal static string SendInputDllName;
    internal static string GetConsoleCursorInfoDllName;
    internal static string SetConsoleCursorInfoDllName;
    internal static string ReadConsoleInputDllName;
    internal static string GetVersionExDllName;
    internal static string FormatMessageDllName;
    internal static string CreateToolhelp32SnapshotDllName;
    internal static string Process32FirstDllName;
    internal static string Process32NextDllName;
    internal static string GetACPDllName;
    internal static string DeleteServiceDllName;
    internal static string QueryServiceConfigDllName;
    internal static string QueryServiceConfig2DllName;
    internal static string SetServiceObjectSecurityDllName;
}
public class System.Management.Automation.PipelineClosedException : RuntimeException {
    public PipelineClosedException(string message);
    public PipelineClosedException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PipelineClosedException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.PipelineDepthException : SystemException {
    private ErrorRecord _errorRecord;
    public ErrorRecord ErrorRecord { get; }
    public int CallDepth { get; }
    public PipelineDepthException(string message);
    public PipelineDepthException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PipelineDepthException(SerializationInfo info, StreamingContext context);
    public sealed virtual ErrorRecord get_ErrorRecord();
    public int get_CallDepth();
}
internal static class System.Management.Automation.PipelineOps : object {
    private static CommandProcessorBase AddCommand(PipelineProcessor pipe, CommandParameterInternal[] commandElements, CommandBaseAst commandBaseAst, CommandRedirection[] redirections, ExecutionContext context);
    [IteratorStateMachineAttribute("System.Management.Automation.PipelineOps/<Splat>d__1")]
internal static IEnumerable`1<CommandParameterInternal> Splat(object splattedValue, Ast splatAst);
    private static CommandParameterInternal SplatEnumerableElement(object splattedArgument, Ast splatAst);
    private static string GetParameterText(string parameterName);
    internal static void InvokePipeline(object input, bool ignoreInput, CommandParameterInternal[][] pipeElements, CommandBaseAst[] pipeElementAsts, CommandRedirection[][] commandRedirections, FunctionContext funcContext);
    internal static void InvokePipelineInBackground(PipelineBaseAst pipelineAst, FunctionContext funcContext);
    private static void AddNoopCommandProcessor(PipelineProcessor pipelineProcessor, ExecutionContext context);
    internal static object CheckAutomationNullInCommandArgument(object obj);
    internal static Object[] CheckAutomationNullInCommandArgumentArray(Object[] objArray);
    internal static SteppablePipeline GetSteppablePipeline(PipelineAst pipelineAst, CommandOrigin commandOrigin, ScriptBlock scriptBlock, Object[] args);
    private static CommandParameterInternal GetCommandParameter(CommandParameterAst commandParameterAst, bool isTrusted, ExecutionContext context);
    private static CommandRedirection GetCommandRedirection(RedirectionAst redirectionAst, bool isTrusted, ExecutionContext context);
    internal static object PipelineResult(List`1<object> resultList);
    internal static void FlushPipe(Pipe oldPipe, List`1<object> resultList);
    internal static void ClearPipe(List`1<object> resultList);
    internal static ExitException GetExitException(object exitCodeObj);
    internal static void CheckForInterrupts(ExecutionContext context);
    internal static void Nop();
}
public class System.Management.Automation.PipelineStoppedException : RuntimeException {
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PipelineStoppedException(SerializationInfo info, StreamingContext context);
    public PipelineStoppedException(string message);
    public PipelineStoppedException(string message, Exception innerException);
}
public static class System.Management.Automation.Platform : object {
    internal static string CacheDirectory;
    internal static string ConfigDirectory;
    private static Lazy`1<bool> _isStaSupported;
    private static Nullable`1<bool> _isNanoServer;
    private static Nullable`1<bool> _isIoT;
    private static Nullable`1<bool> _isWindowsDesktop;
    internal static String[] FormatFileNames;
    public static bool IsLinux { get; }
    public static bool IsMacOS { get; }
    public static bool IsWindows { get; }
    public static bool IsCoreCLR { get; }
    public static bool IsNanoServer { get; }
    public static bool IsIoT { get; }
    public static bool IsWindowsDesktop { get; }
    public static bool IsStaSupported { get; }
    private static Platform();
    public static bool get_IsLinux();
    public static bool get_IsMacOS();
    public static bool get_IsWindows();
    public static bool get_IsCoreCLR();
    public static bool get_IsNanoServer();
    public static bool get_IsIoT();
    public static bool get_IsWindowsDesktop();
    public static bool get_IsStaSupported();
    internal static string GetFolderPath(SpecialFolder folder);
    internal static bool NonWindowsIsHardLink(FileSystemInfo fileInfo);
    internal static string NonWindowsGetUserFromPid(int path);
    internal static string NonWindowsInternalGetLinkType(FileSystemInfo fileInfo);
    internal static bool NonWindowsCreateSymbolicLink(string path, string target);
    internal static bool NonWindowsCreateHardLink(string path, string strTargetPath);
    internal static bool NonWindowsSetDate(DateTime dateToUse);
    internal static bool NonWindowsIsSameFileSystemItem(string pathOne, string pathTwo);
    internal static bool NonWindowsGetInodeData(string path, ValueTuple`2& inodeData);
    internal static bool NonWindowsIsExecutable(string path);
    internal static UInt32 NonWindowsGetThreadId();
    internal static int NonWindowsGetProcessParentPid(int pid);
    internal static bool NonWindowsKillProcess(int pid);
    internal static int NonWindowsWaitPid(int pid, bool nohang);
}
internal static class System.Management.Automation.PlatformInvokes : object {
    internal static int TOKEN_ADJUST_PRIVILEGES;
    internal static int TOKEN_QUERY;
    internal static int TOKEN_ALL_ACCESS;
    internal static UInt32 SE_PRIVILEGE_DISABLED;
    internal static UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    internal static UInt32 SE_PRIVILEGE_ENABLED;
    internal static UInt32 SE_PRIVILEGE_USED_FOR_ACCESS;
    internal static int ERROR_SUCCESS;
    internal static IntPtr INVALID_HANDLE_VALUE;
    internal static UInt32 GENERIC_READ;
    internal static UInt32 GENERIC_WRITE;
    internal static UInt32 FILE_ATTRIBUTE_NORMAL;
    internal static UInt32 CREATE_ALWAYS;
    internal static UInt32 FILE_SHARE_WRITE;
    internal static UInt32 FILE_SHARE_READ;
    internal static UInt32 OF_READWRITE;
    internal static UInt32 OPEN_EXISTING;
    internal static UInt32 RESUME_THREAD_FAILED;
    private static PlatformInvokes();
    internal static IntPtr CreateFile(string lpFileName, FileDesiredAccess dwDesiredAccess, FileShareMode dwShareMode, IntPtr lpSecurityAttributes, FileCreationDisposition dwCreationDisposition, FileAttributes dwFlagsAndAttributes, IntPtr hTemplateFile);
    internal static bool CloseHandle(IntPtr handle);
    internal static bool DosDateTimeToFileTime(short wFatDate, short wFatTime, FILETIME lpFileTime);
    internal static bool LocalFileTimeToFileTime(FILETIME lpLocalFileTime, FILETIME lpFileTime);
    internal static bool SetFileTime(IntPtr hFile, FILETIME lpCreationTime, FILETIME lpLastAccessTime, FILETIME lpLastWriteTime);
    internal static bool SetFileAttributesW(string lpFileName, FileAttributes dwFileAttributes);
    internal static bool EnableTokenPrivilege(string privilegeName, TOKEN_PRIVILEGE& oldPrivilegeState);
    internal static bool RestoreTokenPrivilege(string privilegeName, TOKEN_PRIVILEGE& previousPrivilegeState);
    internal static bool LookupPrivilegeValue(string lpSystemName, string lpName, LUID& lpLuid);
    internal static bool PrivilegeCheck(IntPtr tokenHandler, PRIVILEGE_SET& requiredPrivileges, Boolean& pfResult);
    internal static bool AdjustTokenPrivileges(IntPtr tokenHandler, bool disableAllPrivilege, TOKEN_PRIVILEGE& newPrivilegeState, int bufferLength, TOKEN_PRIVILEGE& previousPrivilegeState, Int32& returnLength);
    internal static IntPtr GetCurrentProcess();
    internal static bool OpenProcessToken(IntPtr processHandle, UInt32 desiredAccess, IntPtr& tokenHandle);
    internal static bool CreateProcess(string lpApplicationName, string lpCommandLine, SECURITY_ATTRIBUTES lpProcessAttributes, SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, IntPtr lpEnvironment, string lpCurrentDirectory, STARTUPINFO lpStartupInfo, PROCESS_INFORMATION lpProcessInformation);
    public static UInt32 ResumeThread(IntPtr threadHandle);
}
internal class System.Management.Automation.PositionalCommandParameter : object {
    [CompilerGeneratedAttribute]
private MergedCompiledCommandParameter <Parameter>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<ParameterSetSpecificMetadata> <ParameterSetData>k__BackingField;
    internal MergedCompiledCommandParameter Parameter { get; }
    internal Collection`1<ParameterSetSpecificMetadata> ParameterSetData { get; }
    internal PositionalCommandParameter(MergedCompiledCommandParameter parameter);
    [CompilerGeneratedAttribute]
internal MergedCompiledCommandParameter get_Parameter();
    [CompilerGeneratedAttribute]
internal Collection`1<ParameterSetSpecificMetadata> get_ParameterSetData();
}
public class System.Management.Automation.PowerShell : object {
    private PSCommand _psCommand;
    private Worker _worker;
    private PowerShellAsyncResult _invokeAsyncResult;
    private PowerShellAsyncResult _stopAsyncResult;
    private PowerShellAsyncResult _batchAsyncResult;
    private PSInvocationSettings _batchInvocationSettings;
    private PSCommand _backupPSCommand;
    private object _rsConnection;
    private PSDataCollection`1<ErrorRecord> _errorBuffer;
    private bool _isDisposed;
    private object _syncObject;
    private ConnectCommandInfo _connectCmdInfo;
    private bool _commandInvokedSynchronously;
    private bool _isBatching;
    private bool _stopBatchExecution;
    private Func`2<IAsyncResult, PSDataCollection`1<PSObject>> _endInvokeMethod;
    private Action`1<IAsyncResult> _endStopMethod;
    [CompilerGeneratedAttribute]
private PSDataStreams <Streams>k__BackingField;
    [CompilerGeneratedAttribute]
private PSInformationalBuffers <InformationalBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectShellErrorOutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private PSInvocationStateInfo <InvocationStateInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNested>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsChild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncResult <EndInvokeAsyncResult>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSInvocationStateChangedEventArgs> InvocationStateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs`1<Runspace>> RunspaceAssigned;
    private Runspace _runspace;
    private RunspacePool _runspacePool;
    [CompilerGeneratedAttribute]
private bool <IsRunspaceOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ErrorBufferOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutputBufferOwner>k__BackingField;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<PSObject> <OutputBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsGetCommandMetadataSpecialPipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientRemotePowerShell <RemotePowerShell>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HistoryString>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<PSCommand> <ExtraCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunningExtraCommands>k__BackingField;
    public PSCommand Commands { get; public set; }
    public PSDataStreams Streams { get; }
    internal PSDataCollection`1<ErrorRecord> ErrorBuffer { get; internal set; }
    internal PSDataCollection`1<ProgressRecord> ProgressBuffer { get; internal set; }
    internal PSDataCollection`1<VerboseRecord> VerboseBuffer { get; internal set; }
    internal PSDataCollection`1<DebugRecord> DebugBuffer { get; internal set; }
    internal PSDataCollection`1<WarningRecord> WarningBuffer { get; internal set; }
    internal PSDataCollection`1<InformationRecord> InformationBuffer { get; internal set; }
    internal PSInformationalBuffers InformationalBuffers { get; }
    internal bool RedirectShellErrorOutputPipe { get; internal set; }
    public Guid InstanceId { get; private set; }
    public PSInvocationStateInfo InvocationStateInfo { get; private set; }
    public bool IsNested { get; private set; }
    internal bool IsChild { get; private set; }
    public bool HadErrors { get; private set; }
    internal AsyncResult EndInvokeAsyncResult { get; private set; }
    public Runspace Runspace { get; public set; }
    public RunspacePool RunspacePool { get; public set; }
    public bool IsRunspaceOwner { get; internal set; }
    internal bool ErrorBufferOwner { get; internal set; }
    internal bool OutputBufferOwner { get; internal set; }
    internal PSDataCollection`1<PSObject> OutputBuffer { get; private set; }
    internal bool IsGetCommandMetadataSpecialPipeline { get; internal set; }
    internal ClientRemotePowerShell RemotePowerShell { get; private set; }
    public string HistoryString { get; public set; }
    internal Collection`1<PSCommand> ExtraCommands { get; }
    internal bool RunningExtraCommands { get; private set; }
    private PowerShell(PSCommand command, Collection`1<PSCommand> extraCommands, object rsConnection);
    internal PowerShell(ConnectCommandInfo connectCmdInfo, object rsConnection);
    internal PowerShell(ObjectStreamBase inputstream, ObjectStreamBase outputstream, ObjectStreamBase errorstream, RunspacePool runspacePool);
    internal PowerShell(ConnectCommandInfo connectCmdInfo, ObjectStreamBase inputstream, ObjectStreamBase outputstream, ObjectStreamBase errorstream, RunspacePool runspacePool);
    internal void InitForRemotePipeline(CommandCollection command, ObjectStreamBase inputstream, ObjectStreamBase outputstream, ObjectStreamBase errorstream, PSInvocationSettings settings, bool redirectShellErrorOutputPipe);
    internal void InitForRemotePipelineConnect(ObjectStreamBase inputstream, ObjectStreamBase outputstream, ObjectStreamBase errorstream, PSInvocationSettings settings, bool redirectShellErrorOutputPipe);
    public static PowerShell Create();
    public static PowerShell Create(RunspaceMode runspace);
    public static PowerShell Create(InitialSessionState initialSessionState);
    public static PowerShell Create(Runspace runspace);
    public PowerShell CreateNestedPowerShell();
    private static PowerShell Create(bool isNested, PSCommand psCommand, Collection`1<PSCommand> extraCommands);
    public PowerShell AddCommand(string cmdlet);
    public PowerShell AddCommand(string cmdlet, bool useLocalScope);
    public PowerShell AddScript(string script);
    public PowerShell AddScript(string script, bool useLocalScope);
    internal PowerShell AddCommand(Command command);
    public PowerShell AddCommand(CommandInfo commandInfo);
    public PowerShell AddParameter(string parameterName, object value);
    public PowerShell AddParameter(string parameterName);
    internal PowerShell AddParameter(CommandParameter parameter);
    public PowerShell AddParameters(IList parameters);
    public PowerShell AddParameters(IDictionary parameters);
    public PowerShell AddArgument(object value);
    public PowerShell AddStatement();
    public PSCommand get_Commands();
    public void set_Commands(PSCommand value);
    [CompilerGeneratedAttribute]
public PSDataStreams get_Streams();
    internal PSDataCollection`1<ErrorRecord> get_ErrorBuffer();
    internal void set_ErrorBuffer(PSDataCollection`1<ErrorRecord> value);
    internal PSDataCollection`1<ProgressRecord> get_ProgressBuffer();
    internal void set_ProgressBuffer(PSDataCollection`1<ProgressRecord> value);
    internal PSDataCollection`1<VerboseRecord> get_VerboseBuffer();
    internal void set_VerboseBuffer(PSDataCollection`1<VerboseRecord> value);
    internal PSDataCollection`1<DebugRecord> get_DebugBuffer();
    internal void set_DebugBuffer(PSDataCollection`1<DebugRecord> value);
    internal PSDataCollection`1<WarningRecord> get_WarningBuffer();
    internal void set_WarningBuffer(PSDataCollection`1<WarningRecord> value);
    internal PSDataCollection`1<InformationRecord> get_InformationBuffer();
    internal void set_InformationBuffer(PSDataCollection`1<InformationRecord> value);
    [CompilerGeneratedAttribute]
internal PSInformationalBuffers get_InformationalBuffers();
    [CompilerGeneratedAttribute]
internal bool get_RedirectShellErrorOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_RedirectShellErrorOutputPipe(bool value);
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
private void set_InstanceId(Guid value);
    [CompilerGeneratedAttribute]
public PSInvocationStateInfo get_InvocationStateInfo();
    [CompilerGeneratedAttribute]
private void set_InvocationStateInfo(PSInvocationStateInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsNested();
    [CompilerGeneratedAttribute]
private void set_IsNested(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsChild();
    [CompilerGeneratedAttribute]
private void set_IsChild(bool value);
    [CompilerGeneratedAttribute]
public bool get_HadErrors();
    [CompilerGeneratedAttribute]
private void set_HadErrors(bool value);
    internal void SetHadErrors(bool status);
    [CompilerGeneratedAttribute]
internal AsyncResult get_EndInvokeAsyncResult();
    [CompilerGeneratedAttribute]
private void set_EndInvokeAsyncResult(AsyncResult value);
    [CompilerGeneratedAttribute]
public void add_InvocationStateChanged(EventHandler`1<PSInvocationStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_InvocationStateChanged(EventHandler`1<PSInvocationStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_RunspaceAssigned(EventHandler`1<PSEventArgs`1<Runspace>> value);
    [CompilerGeneratedAttribute]
internal void remove_RunspaceAssigned(EventHandler`1<PSEventArgs`1<Runspace>> value);
    public Runspace get_Runspace();
    public void set_Runspace(Runspace value);
    private void SetRunspace(Runspace runspace, bool owner);
    public RunspacePool get_RunspacePool();
    public void set_RunspacePool(RunspacePool value);
    internal object GetRunspaceConnection();
    public Collection`1<PSObject> Connect();
    public IAsyncResult ConnectAsync();
    public IAsyncResult ConnectAsync(PSDataCollection`1<PSObject> output, AsyncCallback invocationCallback, object state);
    private void CheckRunspacePoolAndConnect();
    internal void InvokeWithDebugger(IEnumerable`1<object> input, IList`1<PSObject> output, PSInvocationSettings settings, bool invokeMustRun);
    public Collection`1<PSObject> Invoke();
    public Collection`1<PSObject> Invoke(IEnumerable input);
    public Collection`1<PSObject> Invoke(IEnumerable input, PSInvocationSettings settings);
    public Collection`1<T> Invoke();
    public Collection`1<T> Invoke(IEnumerable input);
    public Collection`1<T> Invoke(IEnumerable input, PSInvocationSettings settings);
    public void Invoke(IEnumerable input, IList`1<T> output);
    public void Invoke(IEnumerable input, IList`1<T> output, PSInvocationSettings settings);
    public void Invoke(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings);
    public IAsyncResult BeginInvoke();
    public IAsyncResult BeginInvoke(PSDataCollection`1<T> input);
    public IAsyncResult BeginInvoke(PSDataCollection`1<T> input, PSInvocationSettings settings, AsyncCallback callback, object state);
    public IAsyncResult BeginInvoke(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output);
    public IAsyncResult BeginInvoke(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings, AsyncCallback callback, object state);
    public Task`1<PSDataCollection`1<PSObject>> InvokeAsync();
    public Task`1<PSDataCollection`1<PSObject>> InvokeAsync(PSDataCollection`1<T> input);
    public Task`1<PSDataCollection`1<PSObject>> InvokeAsync(PSDataCollection`1<T> input, PSInvocationSettings settings, AsyncCallback callback, object state);
    public Task`1<PSDataCollection`1<PSObject>> InvokeAsync(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output);
    public Task`1<PSDataCollection`1<PSObject>> InvokeAsync(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings, AsyncCallback callback, object state);
    private IAsyncResult BeginBatchInvoke(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings, AsyncCallback callback, object state);
    private void BatchInvocationWorkItem(object state);
    private void BatchInvocationCallback(IAsyncResult result);
    private void DoRemainingBatchCommands(PSDataCollection`1<PSObject> objs);
    private void DetermineIsBatching();
    private void SetupAsyncBatchExecution();
    private void EndAsyncBatchExecution();
    private void AppendExceptionToErrorStream(Exception e);
    public PSDataCollection`1<PSObject> EndInvoke(IAsyncResult asyncResult);
    public void Stop();
    public IAsyncResult BeginStop(AsyncCallback callback, object state);
    public void EndStop(IAsyncResult asyncResult);
    public Task StopAsync(AsyncCallback callback, object state);
    private void PipelineStateChanged(object source, PipelineStateEventArgs stateEventArgs);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public bool get_IsRunspaceOwner();
    [CompilerGeneratedAttribute]
internal void set_IsRunspaceOwner(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ErrorBufferOwner();
    [CompilerGeneratedAttribute]
internal void set_ErrorBufferOwner(bool value);
    [CompilerGeneratedAttribute]
internal bool get_OutputBufferOwner();
    [CompilerGeneratedAttribute]
internal void set_OutputBufferOwner(bool value);
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<PSObject> get_OutputBuffer();
    [CompilerGeneratedAttribute]
private void set_OutputBuffer(PSDataCollection`1<PSObject> value);
    private void ResetOutputBufferAsNeeded();
    public SteppablePipeline GetSteppablePipeline();
    internal ExecutionContext GetContextFromTLS();
    private SteppablePipeline GetSteppablePipeline(ExecutionContext context, CommandOrigin commandOrigin);
    [CompilerGeneratedAttribute]
internal bool get_IsGetCommandMetadataSpecialPipeline();
    [CompilerGeneratedAttribute]
internal void set_IsGetCommandMetadataSpecialPipeline(bool value);
    private bool IsCommandRunning();
    private bool IsDisconnected();
    private void AssertExecutionNotStarted();
    internal void AssertChangesAreAccepted();
    private void AssertNotDisposed();
    private void Dispose(bool disposing);
    private void InternalClearSuppressExceptions();
    private void RaiseStateChangeEvent(PSInvocationStateInfo stateInfo);
    internal void SetStateChanged(PSInvocationStateInfo stateInfo);
    private void CloseInputBufferOnReconnection(PSInvocationState previousState);
    internal void ClearRemotePowerShell();
    internal void SetIsNested(bool isNested);
    private void CoreInvoke(IEnumerable input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings);
    private void CoreInvokeHelper(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings);
    private void CoreInvokeRemoteHelper(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings);
    private void CoreInvoke(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings);
    private IAsyncResult CoreInvokeAsync(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings, AsyncCallback callback, object state, PSDataCollection`1<PSObject> asyncResultOutput);
    private static void VerifyThreadSettings(PSInvocationSettings settings, ApartmentState runspaceApartmentState, PSThreadOptions runspaceThreadOptions, bool isRemote);
    private void Prepare(PSDataCollection`1<TInput> input, PSDataCollection`1<TOutput> output, PSInvocationSettings settings, bool shouldCreateWorker);
    private IAsyncResult CoreStop(bool isSyncCall, AsyncCallback callback, object state);
    private void ReleaseDebugger();
    private void StopHelper(object state);
    private void StopThreadProc(object state);
    [CompilerGeneratedAttribute]
internal ClientRemotePowerShell get_RemotePowerShell();
    [CompilerGeneratedAttribute]
private void set_RemotePowerShell(ClientRemotePowerShell value);
    [CompilerGeneratedAttribute]
public string get_HistoryString();
    [CompilerGeneratedAttribute]
public void set_HistoryString(string value);
    [CompilerGeneratedAttribute]
internal Collection`1<PSCommand> get_ExtraCommands();
    [CompilerGeneratedAttribute]
internal bool get_RunningExtraCommands();
    [CompilerGeneratedAttribute]
private void set_RunningExtraCommands(bool value);
    private bool ServerSupportsBatchInvocation();
    private void AddToRemoteRunspaceRunningList();
    private void RemoveFromRemoteRunspaceRunningList();
    private RemoteRunspacePoolInternal GetRemoteRunspacePoolInternal();
    internal static PowerShell FromPSObjectForRemoting(PSObject powerShellAsPSObject);
    internal PSObject ToPSObjectForRemoting();
    private static List`1<PSObject> CommandsAsListOfPSObjects(CommandCollection commands, Version psRPVersion);
    internal void SuspendIncomingData();
    internal void ResumeIncomingData();
    internal void WaitForServicingComplete();
}
internal class System.Management.Automation.PowerShellAssemblyLoadContext : object {
    private static string BaseFolderDoesNotExist;
    private static string ManifestDefinitionDoesNotMatch;
    private static string SingletonAlreadyInitialized;
    private static object s_syncObj;
    private String[] _probingPaths;
    private String[] _extensions;
    private Dictionary`2<string, string> _coreClrTypeCatalog;
    private Lazy`1<HashSet`1<string>> _availableDotNetAssemblyNames;
    private HashSet`1<string> _denyListedAssemblies;
    private string _winDir;
    private string _gacPathMSIL;
    private string _gacPath32;
    private string _gacPath64;
    private static ConcurrentDictionary`2<string, Assembly> s_assemblyCache;
    [CompilerGeneratedAttribute]
private static PowerShellAssemblyLoadContext <Instance>k__BackingField;
    private static string s_nativeDllSubFolder;
    private static string s_nativeDllExtension;
    internal static PowerShellAssemblyLoadContext Instance { get; private set; }
    internal IEnumerable`1<string> AvailableDotNetTypeNames { get; }
    internal HashSet`1<string> AvailableDotNetAssemblyNames { get; }
    private PowerShellAssemblyLoadContext(string basePaths);
    private static PowerShellAssemblyLoadContext();
    internal static PowerShellAssemblyLoadContext InitializeSingleton(string basePaths);
    [CompilerGeneratedAttribute]
internal static PowerShellAssemblyLoadContext get_Instance();
    [CompilerGeneratedAttribute]
private static void set_Instance(PowerShellAssemblyLoadContext value);
    internal IEnumerable`1<string> get_AvailableDotNetTypeNames();
    internal HashSet`1<string> get_AvailableDotNetAssemblyNames();
    internal IEnumerable`1<Assembly> GetAssembly(string namespaceQualifiedTypeName);
    internal static IntPtr NativeDllHandler(Assembly assembly, string libraryName);
    private Assembly Resolve(AssemblyLoadContext loadContext, AssemblyName assemblyName);
    private bool TryFindInGAC(AssemblyName assemblyName, String& assemblyFilePath);
    private static bool FindInGac(string gacRoot, AssemblyName assemblyName, String& assemblyPath);
    private static bool TryGetAssemblyFromCache(AssemblyName assemblyName, Assembly& asmLoaded);
    private static bool IsAssemblyMatching(AssemblyName requestedAssembly, AssemblyName loadedAssembly);
    private static Assembly GetTrustedPlatformAssembly(string tpaStrongName);
    private static void ThrowFileLoadException(string errorTemplate, Object[] args);
    private static void ThrowFileNotFoundException(string errorTemplate, Object[] args);
    private static string GetNativeDllSubFolderName(String& ext);
    private static Dictionary`2<string, string> InitializeTypeCatalog();
    [CompilerGeneratedAttribute]
private HashSet`1<string> <.ctor>b__4_0();
}
public static class System.Management.Automation.PowerShellAssemblyLoadContextInitializer : object {
    public static void SetPowerShellAssemblyLoadContext(string basePaths);
}
internal class System.Management.Automation.PowerShellAsyncResult : AsyncResult {
    [CompilerGeneratedAttribute]
private bool <IsAssociatedWithAsyncInvoke>k__BackingField;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<PSObject> <Output>k__BackingField;
    internal bool IsAssociatedWithAsyncInvoke { get; }
    internal PSDataCollection`1<PSObject> Output { get; }
    internal PowerShellAsyncResult(Guid ownerId, AsyncCallback callback, object state, PSDataCollection`1<PSObject> output, bool isCalledFromBeginInvoke);
    [CompilerGeneratedAttribute]
internal bool get_IsAssociatedWithAsyncInvoke();
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<PSObject> get_Output();
}
internal class System.Management.Automation.PowerShellBinaryOperator : MulticastDelegate {
    public PowerShellBinaryOperator(object object, IntPtr method);
    public virtual object Invoke(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval);
    public virtual IAsyncResult BeginInvoke(ExecutionContext context, IScriptExtent errorPosition, object lval, object rval, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.PowerShellExecutionHelper : object {
    [CompilerGeneratedAttribute]
private bool <CancelTabCompletion>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShell <CurrentPowerShell>k__BackingField;
    internal bool CancelTabCompletion { get; internal set; }
    internal PowerShell CurrentPowerShell { get; internal set; }
    internal bool IsRunning { get; }
    internal bool IsStopped { get; }
    internal PowerShellExecutionHelper(PowerShell powershell);
    [CompilerGeneratedAttribute]
internal bool get_CancelTabCompletion();
    [CompilerGeneratedAttribute]
internal void set_CancelTabCompletion(bool value);
    [CompilerGeneratedAttribute]
internal PowerShell get_CurrentPowerShell();
    [CompilerGeneratedAttribute]
internal void set_CurrentPowerShell(PowerShell value);
    internal bool get_IsRunning();
    internal bool get_IsStopped();
    internal bool ExecuteCommandAndGetResultAsBool();
    internal Collection`1<PSObject> ExecuteCurrentPowerShell(Exception& exceptionThrown, IEnumerable input);
    internal Collection`1<PSObject> ExecuteCurrentPowerShell(Exception& exceptionThrown, Boolean& hadErrors, IEnumerable input);
    internal static string SafeToString(object obj);
    internal static void SafeAddToStringList(List`1<string> list, object obj);
}
[ExtensionAttribute]
internal static class System.Management.Automation.PowerShellExtensionHelpers : object {
    [ExtensionAttribute]
internal static PowerShell AddCommandWithPreferenceSetting(PowerShellExecutionHelper helper, string command, Type type);
    [ExtensionAttribute]
internal static PowerShell AddCommandWithPreferenceSetting(PowerShell powershell, string command, Type type);
}
internal class System.Management.Automation.PowerShellStopper : object {
    private PipelineBase _pipeline;
    private PowerShell _powerShell;
    private EventHandler`1<PipelineStateEventArgs> _eventHandler;
    private bool _isDisposed;
    internal PowerShellStopper(ExecutionContext context, PowerShell powerShell);
    private void LocalPipeline_StateChanged(object sender, PipelineStateEventArgs e);
    public sealed virtual void Dispose();
}
public class System.Management.Automation.PowerShellStreams`2 : object {
    private PSDataCollection`1<TInput> _inputStream;
    private PSDataCollection`1<TOutput> _outputStream;
    private PSDataCollection`1<ErrorRecord> _errorStream;
    private PSDataCollection`1<WarningRecord> _warningStream;
    private PSDataCollection`1<ProgressRecord> _progressStream;
    private PSDataCollection`1<VerboseRecord> _verboseStream;
    private PSDataCollection`1<DebugRecord> _debugStream;
    private PSDataCollection`1<InformationRecord> _informationStream;
    private bool _disposed;
    private object _syncLock;
    public PSDataCollection`1<TInput> InputStream { get; public set; }
    public PSDataCollection`1<TOutput> OutputStream { get; public set; }
    public PSDataCollection`1<ErrorRecord> ErrorStream { get; public set; }
    public PSDataCollection`1<WarningRecord> WarningStream { get; public set; }
    public PSDataCollection`1<ProgressRecord> ProgressStream { get; public set; }
    public PSDataCollection`1<VerboseRecord> VerboseStream { get; public set; }
    public PSDataCollection`1<DebugRecord> DebugStream { get; public set; }
    public PSDataCollection`1<InformationRecord> InformationStream { get; public set; }
    public PowerShellStreams`2(PSDataCollection`1<TInput> pipelineInput);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public PSDataCollection`1<TInput> get_InputStream();
    public void set_InputStream(PSDataCollection`1<TInput> value);
    public PSDataCollection`1<TOutput> get_OutputStream();
    public void set_OutputStream(PSDataCollection`1<TOutput> value);
    public PSDataCollection`1<ErrorRecord> get_ErrorStream();
    public void set_ErrorStream(PSDataCollection`1<ErrorRecord> value);
    public PSDataCollection`1<WarningRecord> get_WarningStream();
    public void set_WarningStream(PSDataCollection`1<WarningRecord> value);
    public PSDataCollection`1<ProgressRecord> get_ProgressStream();
    public void set_ProgressStream(PSDataCollection`1<ProgressRecord> value);
    public PSDataCollection`1<VerboseRecord> get_VerboseStream();
    public void set_VerboseStream(PSDataCollection`1<VerboseRecord> value);
    public PSDataCollection`1<DebugRecord> get_DebugStream();
    public void set_DebugStream(PSDataCollection`1<DebugRecord> value);
    public PSDataCollection`1<InformationRecord> get_InformationStream();
    public void set_InformationStream(PSDataCollection`1<InformationRecord> value);
    public void CloseAll();
}
[ObsoleteAttribute("This enum type was used only in PowerShell Workflow and is now obsolete.", "True")]
public enum System.Management.Automation.PowerShellStreamType : Enum {
    public int value__;
    public static PowerShellStreamType Input;
    public static PowerShellStreamType Output;
    public static PowerShellStreamType Error;
    public static PowerShellStreamType Warning;
    public static PowerShellStreamType Verbose;
    public static PowerShellStreamType Debug;
    public static PowerShellStreamType Progress;
    public static PowerShellStreamType Information;
}
public static class System.Management.Automation.PowerShellUnsafeAssemblyLoad : object {
    [UnmanagedCallersOnlyAttribute]
public static int LoadAssemblyFromNativeMemory(IntPtr data, int size);
}
internal enum System.Management.Automation.PreferenceVariable : Enum {
    public int value__;
    public static PreferenceVariable Debug;
    public static PreferenceVariable Verbose;
    public static PreferenceVariable Error;
    public static PreferenceVariable WhatIf;
    public static PreferenceVariable Warning;
    public static PreferenceVariable Information;
    public static PreferenceVariable Confirm;
    public static PreferenceVariable Progress;
}
internal class System.Management.Automation.ProcessInputWriter : object {
    private InternalCommand _command;
    private SteppablePipeline _pipeline;
    private Serializer _xmlSerializer;
    private StreamWriter _streamWriter;
    private NativeCommandIOFormat _inputFormat;
    private bool _stopping;
    internal ProcessInputWriter(InternalCommand command);
    internal void Add(object input);
    private void AddTextInput(object input);
    private void AddTextInputFromFormattedArray(Array formattedObjects);
    private void AddXmlInput(object input);
    internal void Start(Process process, NativeCommandIOFormat inputFormat);
    internal void Stop();
    internal void Dispose();
    internal void Done();
}
internal enum System.Management.Automation.ProcessMode : Enum {
    public int value__;
    public static ProcessMode Enumerate;
    public static ProcessMode Delete;
}
internal class System.Management.Automation.ProcessOutputHandler : object {
    internal static string XmlCliTag;
    private int _refCount;
    private BlockingCollection`1<ProcessOutputObject> _queue;
    private bool _isFirstOutput;
    private bool _isFirstError;
    private bool _isXmlCliOutput;
    private bool _isXmlCliError;
    private string _processFileName;
    private AsyncByteStreamTransfer _stdOutDrainer;
    public ProcessOutputHandler(Process process, BlockingCollection`1<ProcessOutputObject> queue);
    public ProcessOutputHandler(Process process, BlockingCollection`1<ProcessOutputObject> queue, BytePipe stdOutDestination, BytePipe stdOutSource, AsyncByteStreamTransfer& stdOutDrainer);
    private void decrementRefCount();
    private void OutputHandler(object sender, DataReceivedEventArgs outputReceived);
    private void ErrorHandler(object sender, DataReceivedEventArgs errorReceived);
    private List`1<ProcessOutputObject> DeserializeCliXmlObject(string xml, bool isOutput);
}
internal class System.Management.Automation.ProcessOutputObject : object {
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private MinishellStream <Stream>k__BackingField;
    internal object Data { get; }
    internal MinishellStream Stream { get; }
    internal ProcessOutputObject(object data, MinishellStream stream);
    [CompilerGeneratedAttribute]
internal object get_Data();
    [CompilerGeneratedAttribute]
internal MinishellStream get_Stream();
}
public class System.Management.Automation.ProcessRunspaceDebugEndEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    public Runspace Runspace { get; }
    public ProcessRunspaceDebugEndEventArgs(Runspace runspace);
    [CompilerGeneratedAttribute]
public Runspace get_Runspace();
}
[DataContractAttribute]
public class System.Management.Automation.ProgressRecord : object {
    [DataMemberAttribute]
private int id;
    [DataMemberAttribute]
private int parentId;
    [DataMemberAttribute]
private string activity;
    [DataMemberAttribute]
private string status;
    [DataMemberAttribute]
private string currentOperation;
    [DataMemberAttribute]
private int percent;
    [DataMemberAttribute]
private int secondsRemaining;
    [DataMemberAttribute]
private ProgressRecordType type;
    public int ActivityId { get; }
    public int ParentActivityId { get; public set; }
    public string Activity { get; public set; }
    public string StatusDescription { get; public set; }
    public string CurrentOperation { get; public set; }
    public int PercentComplete { get; public set; }
    public int SecondsRemaining { get; public set; }
    public ProgressRecordType RecordType { get; public set; }
    public ProgressRecord(int activityId, string activity, string statusDescription);
    public ProgressRecord(int activityId);
    internal ProgressRecord(ProgressRecord other);
    public int get_ActivityId();
    public int get_ParentActivityId();
    public void set_ParentActivityId(int value);
    public string get_Activity();
    public void set_Activity(string value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public string get_CurrentOperation();
    public void set_CurrentOperation(string value);
    public int get_PercentComplete();
    public void set_PercentComplete(int value);
    public int get_SecondsRemaining();
    public void set_SecondsRemaining(int value);
    public ProgressRecordType get_RecordType();
    public void set_RecordType(ProgressRecordType value);
    public virtual string ToString();
    internal static Nullable`1<int> GetSecondsRemaining(DateTime startTime, double percentageComplete);
    internal static int GetPercentageComplete(DateTime startTime, TimeSpan expectedDuration);
    internal static ProgressRecord FromPSObjectForRemoting(PSObject progressAsPSObject);
    internal PSObject ToPSObjectForRemoting();
}
public enum System.Management.Automation.ProgressRecordType : Enum {
    public int value__;
    public static ProgressRecordType Processing;
    public static ProgressRecordType Completed;
}
public enum System.Management.Automation.ProgressView : Enum {
    public int value__;
    public static ProgressView Minimal;
    public static ProgressView Classic;
}
public class System.Management.Automation.PropertyCmdletProviderIntrinsics : object {
    private Cmdlet _cmdlet;
    private SessionStateInternal _sessionState;
    internal PropertyCmdletProviderIntrinsics(Cmdlet cmdlet);
    internal PropertyCmdletProviderIntrinsics(SessionStateInternal sessionState);
    public Collection`1<PSObject> Get(string path, Collection`1<string> providerSpecificPickList);
    public Collection`1<PSObject> Get(String[] path, Collection`1<string> providerSpecificPickList, bool literalPath);
    internal void Get(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    internal object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    public Collection`1<PSObject> Set(string path, PSObject propertyValue);
    public Collection`1<PSObject> Set(String[] path, PSObject propertyValue, bool force, bool literalPath);
    internal void Set(string path, PSObject propertyValue, CmdletProviderContext context);
    internal object SetPropertyDynamicParameters(string path, PSObject propertyValue, CmdletProviderContext context);
    public void Clear(string path, Collection`1<string> propertyToClear);
    public void Clear(String[] path, Collection`1<string> propertyToClear, bool force, bool literalPath);
    internal void Clear(string path, Collection`1<string> propertyToClear, CmdletProviderContext context);
    internal object ClearPropertyDynamicParameters(string path, Collection`1<string> propertyToClear, CmdletProviderContext context);
    public Collection`1<PSObject> New(string path, string propertyName, string propertyTypeName, object value);
    public Collection`1<PSObject> New(String[] path, string propertyName, string propertyTypeName, object value, bool force, bool literalPath);
    internal void New(string path, string propertyName, string type, object value, CmdletProviderContext context);
    internal object NewPropertyDynamicParameters(string path, string propertyName, string type, object value, CmdletProviderContext context);
    public void Remove(string path, string propertyName);
    public void Remove(String[] path, string propertyName, bool force, bool literalPath);
    internal void Remove(string path, string propertyName, CmdletProviderContext context);
    internal object RemovePropertyDynamicParameters(string path, string propertyName, CmdletProviderContext context);
    public Collection`1<PSObject> Rename(string path, string sourceProperty, string destinationProperty);
    public Collection`1<PSObject> Rename(String[] path, string sourceProperty, string destinationProperty, bool force, bool literalPath);
    internal void Rename(string path, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    internal object RenamePropertyDynamicParameters(string path, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    public Collection`1<PSObject> Copy(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public Collection`1<PSObject> Copy(String[] sourcePath, string sourceProperty, string destinationPath, string destinationProperty, bool force, bool literalPath);
    internal void Copy(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal object CopyPropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    public Collection`1<PSObject> Move(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public Collection`1<PSObject> Move(String[] sourcePath, string sourceProperty, string destinationPath, string destinationProperty, bool force, bool literalPath);
    internal void Move(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal object MovePropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
}
internal class System.Management.Automation.PropertyNameCompleter : object {
    private string _parameterNameOfInput;
    public PropertyNameCompleter(string parameterNameOfInput);
    private sealed virtual override IEnumerable`1<CompletionResult> System.Management.Automation.IArgumentCompleter.CompleteArgument(string commandName, string parameterName, string wordToComplete, CommandAst commandAst, IDictionary fakeBoundParameters);
}
public class System.Management.Automation.PropertyNotFoundException : ExtendedTypeSystemException {
    public PropertyNotFoundException(string message);
    public PropertyNotFoundException(string message, Exception innerException);
    internal PropertyNotFoundException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PropertyNotFoundException(SerializationInfo info, StreamingContext context);
}
internal abstract class System.Management.Automation.PropertyOnlyAdapter : DotNetAdapter {
    internal virtual bool CanSiteBinderOptimize(MemberTypes typeToOperateOn);
    protected virtual ConsolidatedString GetInternedTypeNameHierarchy(object obj);
    protected abstract virtual PSProperty DoGetProperty(object obj, string propertyName);
    protected abstract virtual PSProperty DoGetFirstPropertyOrDefault(object obj, MemberNamePredicate predicate);
    protected abstract virtual void DoAddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
}
public abstract class System.Management.Automation.Provider.CmdletProvider : object {
    private CmdletProviderContext _contextBase;
    private ProviderInfo _providerInformation;
    [TraceSourceAttribute("CmdletProviderClasses", "The namespace provider base classes tracer")]
internal static PSTraceSource providerBaseTracer;
    internal CmdletProviderContext Context { get; internal set; }
    public bool Stopping { get; }
    public SessionState SessionState { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    public PSCredential Credential { get; }
    protected internal ProviderInfo ProviderInfo { get; }
    protected PSDriveInfo PSDriveInfo { get; }
    protected object DynamicParameters { get; }
    public SwitchParameter Force { get; }
    public string Filter { get; }
    public Collection`1<string> Include { get; }
    public Collection`1<string> Exclude { get; }
    public PSHost Host { get; }
    public char ItemSeparator { get; }
    public char AltItemSeparator { get; }
    public PSTransactionContext CurrentPSTransaction { get; }
    private static CmdletProvider();
    internal void SetProviderInformation(ProviderInfo providerInfoToSet);
    internal virtual bool IsFilterSet();
    internal CmdletProviderContext get_Context();
    internal void set_Context(CmdletProviderContext value);
    internal ProviderInfo Start(ProviderInfo providerInfo, CmdletProviderContext cmdletProviderContext);
    internal object StartDynamicParameters(CmdletProviderContext cmdletProviderContext);
    internal void Stop(CmdletProviderContext cmdletProviderContext);
    protected internal virtual void StopProcessing();
    internal void GetProperty(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext cmdletProviderContext);
    internal object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext cmdletProviderContext);
    internal void SetProperty(string path, PSObject propertyValue, CmdletProviderContext cmdletProviderContext);
    internal object SetPropertyDynamicParameters(string path, PSObject propertyValue, CmdletProviderContext cmdletProviderContext);
    internal void ClearProperty(string path, Collection`1<string> propertyName, CmdletProviderContext cmdletProviderContext);
    internal object ClearPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext cmdletProviderContext);
    internal void NewProperty(string path, string propertyName, string propertyTypeName, object value, CmdletProviderContext cmdletProviderContext);
    internal object NewPropertyDynamicParameters(string path, string propertyName, string propertyTypeName, object value, CmdletProviderContext cmdletProviderContext);
    internal void RemoveProperty(string path, string propertyName, CmdletProviderContext cmdletProviderContext);
    internal object RemovePropertyDynamicParameters(string path, string propertyName, CmdletProviderContext cmdletProviderContext);
    internal void RenameProperty(string path, string propertyName, string newPropertyName, CmdletProviderContext cmdletProviderContext);
    internal object RenamePropertyDynamicParameters(string path, string sourceProperty, string destinationProperty, CmdletProviderContext cmdletProviderContext);
    internal void CopyProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext cmdletProviderContext);
    internal object CopyPropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext cmdletProviderContext);
    internal void MoveProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext cmdletProviderContext);
    internal object MovePropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext cmdletProviderContext);
    internal IContentReader GetContentReader(string path, CmdletProviderContext cmdletProviderContext);
    internal object GetContentReaderDynamicParameters(string path, CmdletProviderContext cmdletProviderContext);
    internal IContentWriter GetContentWriter(string path, CmdletProviderContext cmdletProviderContext);
    internal object GetContentWriterDynamicParameters(string path, CmdletProviderContext cmdletProviderContext);
    internal void ClearContent(string path, CmdletProviderContext cmdletProviderContext);
    internal object ClearContentDynamicParameters(string path, CmdletProviderContext cmdletProviderContext);
    protected virtual ProviderInfo Start(ProviderInfo providerInfo);
    protected virtual object StartDynamicParameters();
    protected virtual void Stop();
    public bool get_Stopping();
    public SessionState get_SessionState();
    public ProviderIntrinsics get_InvokeProvider();
    public CommandInvocationIntrinsics get_InvokeCommand();
    public PSCredential get_Credential();
    protected internal ProviderInfo get_ProviderInfo();
    protected PSDriveInfo get_PSDriveInfo();
    protected object get_DynamicParameters();
    public SwitchParameter get_Force();
    public string get_Filter();
    public Collection`1<string> get_Include();
    public Collection`1<string> get_Exclude();
    public PSHost get_Host();
    public virtual char get_ItemSeparator();
    public virtual char get_AltItemSeparator();
    public virtual string GetResourceString(string baseName, string resourceId);
    [DoesNotReturnAttribute]
public void ThrowTerminatingError(ErrorRecord errorRecord);
    public bool ShouldProcess(string target);
    public bool ShouldProcess(string target, string action);
    public bool ShouldProcess(string verboseDescription, string verboseWarning, string caption);
    public bool ShouldProcess(string verboseDescription, string verboseWarning, string caption, ShouldProcessReason& shouldProcessReason);
    public bool ShouldContinue(string query, string caption);
    public bool ShouldContinue(string query, string caption, Boolean& yesToAll, Boolean& noToAll);
    public bool TransactionAvailable();
    public PSTransactionContext get_CurrentPSTransaction();
    public void WriteVerbose(string text);
    public void WriteWarning(string text);
    public void WriteProgress(ProgressRecord progressRecord);
    public void WriteDebug(string text);
    public void WriteInformation(InformationRecord record);
    public void WriteInformation(object messageData, String[] tags);
    private void WriteObject(object item, string path, bool isContainer);
    private void WriteObject(object item, string path);
    private PSObject WrapOutputInPSObject(object item, string path);
    public void WriteItemObject(object item, string path, bool isContainer);
    public void WritePropertyObject(object propertyValue, string path);
    public void WriteSecurityDescriptorObject(ObjectSecurity securityDescriptor, string path);
    public void WriteError(ErrorRecord errorRecord);
    internal void GetSecurityDescriptor(string path, AccessControlSections sections, CmdletProviderContext context);
    internal void SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor, CmdletProviderContext context);
    private static void CheckIfSecurityDescriptorInterfaceIsSupported(ISecurityDescriptorCmdletProvider permissionProvider);
}
[AttributeUsageAttribute("4")]
public class System.Management.Automation.Provider.CmdletProviderAttribute : Attribute {
    private Char[] _illegalCharacters;
    [CompilerGeneratedAttribute]
private string <ProviderName>k__BackingField;
    [CompilerGeneratedAttribute]
private ProviderCapabilities <ProviderCapabilities>k__BackingField;
    public string ProviderName { get; }
    public ProviderCapabilities ProviderCapabilities { get; }
    public CmdletProviderAttribute(string providerName, ProviderCapabilities providerCapabilities);
    [CompilerGeneratedAttribute]
public string get_ProviderName();
    [CompilerGeneratedAttribute]
public ProviderCapabilities get_ProviderCapabilities();
}
public abstract class System.Management.Automation.Provider.ContainerCmdletProvider : ItemCmdletProvider {
    internal void GetChildItems(string path, bool recurse, UInt32 depth, CmdletProviderContext context);
    internal object GetChildItemsDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    internal void GetChildNames(string path, ReturnContainers returnContainers, CmdletProviderContext context);
    internal virtual bool ConvertPath(string path, string filter, String& updatedPath, String& updatedFilter, CmdletProviderContext context);
    internal object GetChildNamesDynamicParameters(string path, CmdletProviderContext context);
    internal void RenameItem(string path, string newName, CmdletProviderContext context);
    internal object RenameItemDynamicParameters(string path, string newName, CmdletProviderContext context);
    internal void NewItem(string path, string type, object newItemValue, CmdletProviderContext context);
    internal object NewItemDynamicParameters(string path, string type, object newItemValue, CmdletProviderContext context);
    internal void RemoveItem(string path, bool recurse, CmdletProviderContext context);
    internal object RemoveItemDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    internal bool HasChildItems(string path, CmdletProviderContext context);
    internal void CopyItem(string path, string copyPath, bool recurse, CmdletProviderContext context);
    internal object CopyItemDynamicParameters(string path, string destination, bool recurse, CmdletProviderContext context);
    protected virtual void GetChildItems(string path, bool recurse);
    protected virtual void GetChildItems(string path, bool recurse, UInt32 depth);
    protected virtual object GetChildItemsDynamicParameters(string path, bool recurse);
    protected virtual void GetChildNames(string path, ReturnContainers returnContainers);
    protected virtual bool ConvertPath(string path, string filter, String& updatedPath, String& updatedFilter);
    protected virtual object GetChildNamesDynamicParameters(string path);
    protected virtual void RenameItem(string path, string newName);
    protected virtual object RenameItemDynamicParameters(string path, string newName);
    protected virtual void NewItem(string path, string itemTypeName, object newItemValue);
    protected virtual object NewItemDynamicParameters(string path, string itemTypeName, object newItemValue);
    protected virtual void RemoveItem(string path, bool recurse);
    protected virtual object RemoveItemDynamicParameters(string path, bool recurse);
    protected virtual bool HasChildItems(string path);
    protected virtual void CopyItem(string path, string copyPath, bool recurse);
    protected virtual object CopyItemDynamicParameters(string path, string destination, bool recurse);
}
public abstract class System.Management.Automation.Provider.DriveCmdletProvider : CmdletProvider {
    internal PSDriveInfo NewDrive(PSDriveInfo drive, CmdletProviderContext context);
    internal object NewDriveDynamicParameters(CmdletProviderContext context);
    internal PSDriveInfo RemoveDrive(PSDriveInfo drive, CmdletProviderContext context);
    internal Collection`1<PSDriveInfo> InitializeDefaultDrives(CmdletProviderContext context);
    protected virtual PSDriveInfo NewDrive(PSDriveInfo drive);
    protected virtual object NewDriveDynamicParameters();
    protected virtual PSDriveInfo RemoveDrive(PSDriveInfo drive);
    protected virtual Collection`1<PSDriveInfo> InitializeDefaultDrives();
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Provider.ICmdletProviderSupportsHelp {
    public abstract virtual string GetHelpMaml(string helpItemName, string path);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Provider.IContentCmdletProvider {
    public abstract virtual IContentReader GetContentReader(string path);
    public abstract virtual object GetContentReaderDynamicParameters(string path);
    public abstract virtual IContentWriter GetContentWriter(string path);
    public abstract virtual object GetContentWriterDynamicParameters(string path);
    public abstract virtual void ClearContent(string path);
    public abstract virtual object ClearContentDynamicParameters(string path);
}
public interface System.Management.Automation.Provider.IContentReader {
    [NullableContextAttribute("1")]
public abstract virtual IList Read(long readCount);
    public abstract virtual void Seek(long offset, SeekOrigin origin);
    public abstract virtual void Close();
}
public interface System.Management.Automation.Provider.IContentWriter {
    [NullableContextAttribute("1")]
public abstract virtual IList Write(IList content);
    public abstract virtual void Seek(long offset, SeekOrigin origin);
    public abstract virtual void Close();
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Provider.IDynamicPropertyCmdletProvider {
    public abstract virtual void NewProperty(string path, string propertyName, string propertyTypeName, object value);
    public abstract virtual object NewPropertyDynamicParameters(string path, string propertyName, string propertyTypeName, object value);
    public abstract virtual void RemoveProperty(string path, string propertyName);
    public abstract virtual object RemovePropertyDynamicParameters(string path, string propertyName);
    public abstract virtual void RenameProperty(string path, string sourceProperty, string destinationProperty);
    public abstract virtual object RenamePropertyDynamicParameters(string path, string sourceProperty, string destinationProperty);
    public abstract virtual void CopyProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public abstract virtual object CopyPropertyDynamicParameters(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public abstract virtual void MoveProperty(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
    public abstract virtual object MovePropertyDynamicParameters(string sourcePath, string sourceProperty, string destinationPath, string destinationProperty);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Provider.IPropertyCmdletProvider {
    public abstract virtual void GetProperty(string path, Collection`1<string> providerSpecificPickList);
    public abstract virtual object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList);
    public abstract virtual void SetProperty(string path, PSObject propertyValue);
    public abstract virtual object SetPropertyDynamicParameters(string path, PSObject propertyValue);
    public abstract virtual void ClearProperty(string path, Collection`1<string> propertyToClear);
    public abstract virtual object ClearPropertyDynamicParameters(string path, Collection`1<string> propertyToClear);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Provider.ISecurityDescriptorCmdletProvider {
    public abstract virtual void GetSecurityDescriptor(string path, AccessControlSections includeSections);
    public abstract virtual void SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor);
    public abstract virtual ObjectSecurity NewSecurityDescriptorFromPath(string path, AccessControlSections includeSections);
    public abstract virtual ObjectSecurity NewSecurityDescriptorOfType(string type, AccessControlSections includeSections);
}
public abstract class System.Management.Automation.Provider.ItemCmdletProvider : DriveCmdletProvider {
    internal void GetItem(string path, CmdletProviderContext context);
    internal object GetItemDynamicParameters(string path, CmdletProviderContext context);
    internal void SetItem(string path, object value, CmdletProviderContext context);
    internal object SetItemDynamicParameters(string path, object value, CmdletProviderContext context);
    internal void ClearItem(string path, CmdletProviderContext context);
    internal object ClearItemDynamicParameters(string path, CmdletProviderContext context);
    internal void InvokeDefaultAction(string path, CmdletProviderContext context);
    internal object InvokeDefaultActionDynamicParameters(string path, CmdletProviderContext context);
    internal bool ItemExists(string path, CmdletProviderContext context);
    internal object ItemExistsDynamicParameters(string path, CmdletProviderContext context);
    internal bool IsValidPath(string path, CmdletProviderContext context);
    internal String[] ExpandPath(string path, CmdletProviderContext context);
    protected virtual void GetItem(string path);
    protected virtual object GetItemDynamicParameters(string path);
    protected virtual void SetItem(string path, object value);
    protected virtual object SetItemDynamicParameters(string path, object value);
    protected virtual void ClearItem(string path);
    protected virtual object ClearItemDynamicParameters(string path);
    protected virtual void InvokeDefaultAction(string path);
    protected virtual object InvokeDefaultActionDynamicParameters(string path);
    protected virtual bool ItemExists(string path);
    protected virtual object ItemExistsDynamicParameters(string path);
    protected abstract virtual bool IsValidPath(string path);
    protected virtual String[] ExpandPath(string path);
}
public abstract class System.Management.Automation.Provider.NavigationCmdletProvider : ContainerCmdletProvider {
    internal string MakePath(string parent, string child, CmdletProviderContext context);
    internal string GetParentPath(string path, string root, CmdletProviderContext context);
    internal string NormalizeRelativePath(string path, string basePath, CmdletProviderContext context);
    internal string GetChildName(string path, CmdletProviderContext context);
    internal bool IsItemContainer(string path, CmdletProviderContext context);
    internal void MoveItem(string path, string destination, CmdletProviderContext context);
    internal object MoveItemDynamicParameters(string path, string destination, CmdletProviderContext context);
    protected virtual string MakePath(string parent, string child);
    protected string MakePath(string parent, string child, bool childIsLeaf);
    protected virtual string GetParentPath(string path, string root);
    protected virtual string NormalizeRelativePath(string path, string basePath);
    internal string ContractRelativePath(string path, string basePath, bool allowNonExistingPaths, CmdletProviderContext context);
    private string GetCommonBase(string path1, string path2);
    protected virtual string GetChildName(string path);
    protected virtual bool IsItemContainer(string path);
    protected virtual void MoveItem(string path, string destination);
    protected virtual object MoveItemDynamicParameters(string path, string destination);
    private string NormalizePath(string path);
    private bool IsAbsolutePath(string path);
    private Stack`1<string> TokenizePathToStack(string path, string basePath);
    private static Stack`1<string> NormalizeThePath(Stack`1<string> tokenizedPathStack, string path, string basePath, bool allowNonExistingPaths);
    private string CreateNormalizedRelativePathFromStack(Stack`1<string> normalizedPathStack);
}
[FlagsAttribute]
public enum System.Management.Automation.Provider.ProviderCapabilities : Enum {
    public int value__;
    public static ProviderCapabilities None;
    public static ProviderCapabilities Include;
    public static ProviderCapabilities Exclude;
    public static ProviderCapabilities Filter;
    public static ProviderCapabilities ExpandWildcards;
    public static ProviderCapabilities ShouldProcess;
    public static ProviderCapabilities Credentials;
    public static ProviderCapabilities Transactions;
}
public static class System.Management.Automation.ProviderCmdlet : object {
    public static string AddContent;
    public static string ClearContent;
    public static string ClearItem;
    public static string ClearItemProperty;
    public static string ConvertPath;
    public static string CopyItem;
    public static string CopyItemProperty;
    public static string GetAcl;
    public static string GetChildItem;
    public static string GetContent;
    public static string GetItem;
    public static string GetItemProperty;
    public static string GetLocation;
    public static string GetPSDrive;
    public static string GetPSProvider;
    public static string InvokeItem;
    public static string JoinPath;
    public static string MoveItem;
    public static string MoveItemProperty;
    public static string NewItem;
    public static string NewItemProperty;
    public static string NewPSDrive;
    public static string PopLocation;
    public static string PushLocation;
    public static string RemoveItem;
    public static string RemoveItemProperty;
    public static string RemovePSDrive;
    public static string RenameItem;
    public static string RenameItemProperty;
    public static string ResolvePath;
    public static string SetAcl;
    public static string SetContent;
    public static string SetItem;
    public static string SetItemProperty;
    public static string SetLocation;
    public static string SplitPath;
    public static string TestPath;
}
internal class System.Management.Automation.ProviderCommandHelpInfo : HelpInfo {
    private HelpInfo _helpInfo;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSObject FullHelp { get; }
    internal string Component { get; }
    internal string Role { get; }
    internal string Functionality { get; }
    internal ProviderCommandHelpInfo(HelpInfo genericHelpInfo, ProviderContext providerContext);
    internal virtual PSObject[] GetParameter(string pattern);
    internal virtual Uri GetUriForOnlineHelp();
    internal virtual string get_Name();
    internal virtual string get_Synopsis();
    internal virtual HelpCategory get_HelpCategory();
    internal virtual PSObject get_FullHelp();
    internal virtual string get_Component();
    internal virtual string get_Role();
    internal virtual string get_Functionality();
}
internal class System.Management.Automation.ProviderContext : object {
    private string _requestedPath;
    private ExecutionContext _executionContext;
    private PathIntrinsics _pathIntrinsics;
    internal string RequestedPath { get; }
    internal ProviderContext(string requestedPath, ExecutionContext executionContext, PathIntrinsics pathIntrinsics);
    internal string get_RequestedPath();
    internal MamlCommandHelpInfo GetProviderSpecificHelpInfo(string helpItemName);
}
internal class System.Management.Automation.ProviderHelpInfo : HelpInfo {
    private PSObject _fullHelpObject;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal string DetailedDescription { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSObject FullHelp { get; }
    private ProviderHelpInfo(XmlNode xmlNode);
    internal virtual string get_Name();
    internal virtual string get_Synopsis();
    internal string get_DetailedDescription();
    internal virtual HelpCategory get_HelpCategory();
    internal virtual PSObject get_FullHelp();
    internal virtual bool MatchPatternInContent(WildcardPattern pattern);
    internal static ProviderHelpInfo Load(XmlNode xmlNode);
}
internal class System.Management.Automation.ProviderHelpProvider : HelpProviderWithCache {
    private SessionState _sessionState;
    private Hashtable _helpFiles;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal ProviderHelpProvider(HelpSystem helpSystem);
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    [IteratorStateMachineAttribute("System.Management.Automation.ProviderHelpProvider/<ExactMatchHelp>d__6")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    private static string GetProviderAssemblyPath(ProviderInfo providerInfo);
    private void LoadHelpFile(ProviderInfo providerInfo);
    [IteratorStateMachineAttribute("System.Management.Automation.ProviderHelpProvider/<SearchHelp>d__10")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    [IteratorStateMachineAttribute("System.Management.Automation.ProviderHelpProvider/<ProcessForwardedHelp>d__11")]
internal virtual IEnumerable`1<HelpInfo> ProcessForwardedHelp(HelpInfo helpInfo, HelpRequest helpRequest);
    internal virtual void Reset();
}
public class System.Management.Automation.ProviderInfo : object {
    [CompilerGeneratedAttribute]
private Type <ImplementingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    private SessionState _sessionState;
    private string _fullName;
    private string _cachedModuleName;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSnapInInfo <PSSnapIn>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    private ProviderCapabilities _capabilities;
    private bool _capabilitiesRead;
    [CompilerGeneratedAttribute]
private string <Home>k__BackingField;
    private PSDriveInfo _hiddenDrive;
    [CompilerGeneratedAttribute]
private bool <VolumeSeparatedByColon>k__BackingField;
    [CompilerGeneratedAttribute]
private char <ItemSeparator>k__BackingField;
    [CompilerGeneratedAttribute]
private char <AltItemSeparator>k__BackingField;
    private Dictionary`2<string, List`1<PSTypeName>> _providerOutputType;
    private PSNoteProperty _noteProperty;
    public Type ImplementingType { get; }
    public string HelpFile { get; }
    public string Name { get; }
    internal string FullName { get; }
    public PSSnapInInfo PSSnapIn { get; }
    internal string PSSnapInName { get; }
    internal string ApplicationBase { get; }
    public string ModuleName { get; }
    public PSModuleInfo Module { get; private set; }
    public string Description { get; public set; }
    public ProviderCapabilities Capabilities { get; }
    public string Home { get; public set; }
    public Collection`1<PSDriveInfo> Drives { get; }
    internal PSDriveInfo HiddenDrive { get; }
    public bool VolumeSeparatedByColon { get; internal set; }
    public char ItemSeparator { get; private set; }
    public char AltItemSeparator { get; private set; }
    protected ProviderInfo(ProviderInfo providerInfo);
    internal ProviderInfo(SessionState sessionState, Type implementingType, string name, string helpFile, PSSnapInInfo psSnapIn);
    internal ProviderInfo(SessionState sessionState, Type implementingType, string name, string description, string home, string helpFile, PSSnapInInfo psSnapIn);
    [CompilerGeneratedAttribute]
public Type get_ImplementingType();
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
public string get_Name();
    internal string get_FullName();
    [CompilerGeneratedAttribute]
public PSSnapInInfo get_PSSnapIn();
    internal string get_PSSnapInName();
    internal string get_ApplicationBase();
    public string get_ModuleName();
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(PSModuleInfo value);
    internal void SetModule(PSModuleInfo module);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    public ProviderCapabilities get_Capabilities();
    [CompilerGeneratedAttribute]
public string get_Home();
    [CompilerGeneratedAttribute]
public void set_Home(string value);
    public Collection`1<PSDriveInfo> get_Drives();
    internal PSDriveInfo get_HiddenDrive();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_VolumeSeparatedByColon();
    [CompilerGeneratedAttribute]
internal void set_VolumeSeparatedByColon(bool value);
    [CompilerGeneratedAttribute]
public char get_ItemSeparator();
    [CompilerGeneratedAttribute]
private void set_ItemSeparator(char value);
    [CompilerGeneratedAttribute]
public char get_AltItemSeparator();
    [CompilerGeneratedAttribute]
private void set_AltItemSeparator(char value);
    internal bool NameEquals(string providerName);
    internal bool IsMatch(string providerName);
    internal bool IsMatch(WildcardPattern namePattern, PSSnapinQualifiedName psSnapinQualifiedName);
    private bool IsPSSnapinNameMatch(PSSnapinQualifiedName psSnapinQualifiedName);
    internal CmdletProvider CreateInstance();
    internal void GetOutputTypes(string cmdletname, List`1<PSTypeName> listToAppend);
    internal PSNoteProperty GetNotePropertyForProviderCmdlets(string name);
    [CompilerGeneratedAttribute]
internal static string <get_FullName>g__GetFullName|13_0(string name, string psSnapInName, string moduleName);
}
public class System.Management.Automation.ProviderIntrinsics : object {
    [CompilerGeneratedAttribute]
private ItemCmdletProviderIntrinsics <Item>k__BackingField;
    [CompilerGeneratedAttribute]
private ChildItemCmdletProviderIntrinsics <ChildItem>k__BackingField;
    [CompilerGeneratedAttribute]
private ContentCmdletProviderIntrinsics <Content>k__BackingField;
    [CompilerGeneratedAttribute]
private PropertyCmdletProviderIntrinsics <Property>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityDescriptorCmdletProviderIntrinsics <SecurityDescriptor>k__BackingField;
    private InternalCommand _cmdlet;
    public ItemCmdletProviderIntrinsics Item { get; }
    public ChildItemCmdletProviderIntrinsics ChildItem { get; }
    public ContentCmdletProviderIntrinsics Content { get; }
    public PropertyCmdletProviderIntrinsics Property { get; }
    public SecurityDescriptorCmdletProviderIntrinsics SecurityDescriptor { get; }
    internal ProviderIntrinsics(Cmdlet cmdlet);
    internal ProviderIntrinsics(SessionStateInternal sessionState);
    [CompilerGeneratedAttribute]
public ItemCmdletProviderIntrinsics get_Item();
    [CompilerGeneratedAttribute]
public ChildItemCmdletProviderIntrinsics get_ChildItem();
    [CompilerGeneratedAttribute]
public ContentCmdletProviderIntrinsics get_Content();
    [CompilerGeneratedAttribute]
public PropertyCmdletProviderIntrinsics get_Property();
    [CompilerGeneratedAttribute]
public SecurityDescriptorCmdletProviderIntrinsics get_SecurityDescriptor();
}
public class System.Management.Automation.ProviderInvocationException : RuntimeException {
    internal ProviderInfo _providerInfo;
    private ErrorRecord _errorRecord;
    private string _message;
    public ProviderInfo ProviderInfo { get; }
    public ErrorRecord ErrorRecord { get; }
    public string Message { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ProviderInvocationException(SerializationInfo info, StreamingContext context);
    public ProviderInvocationException(string message);
    internal ProviderInvocationException(ProviderInfo provider, Exception innerException);
    internal ProviderInvocationException(ProviderInfo provider, ErrorRecord errorRecord);
    public ProviderInvocationException(string message, Exception innerException);
    internal ProviderInvocationException(string errorId, string resourceStr, ProviderInfo provider, string path, Exception innerException);
    internal ProviderInvocationException(string errorId, string resourceStr, ProviderInfo provider, string path, Exception innerException, bool useInnerExceptionMessage);
    public ProviderInfo get_ProviderInfo();
    public virtual ErrorRecord get_ErrorRecord();
    private static string RetrieveMessage(string errorId, string resourceStr, ProviderInfo provider, string path, Exception innerException);
    public virtual string get_Message();
}
public class System.Management.Automation.ProviderNameAmbiguousException : ProviderNotFoundException {
    private ReadOnlyCollection`1<ProviderInfo> _possibleMatches;
    public ReadOnlyCollection`1<ProviderInfo> PossibleMatches { get; }
    internal ProviderNameAmbiguousException(string providerName, string errorIdAndResourceId, string resourceStr, Collection`1<ProviderInfo> possibleMatches, Object[] messageArgs);
    public ProviderNameAmbiguousException(string message);
    public ProviderNameAmbiguousException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ProviderNameAmbiguousException(SerializationInfo info, StreamingContext context);
    public ReadOnlyCollection`1<ProviderInfo> get_PossibleMatches();
}
internal abstract class System.Management.Automation.ProviderNames : object {
    internal string Environment { get; }
    internal string Certificate { get; }
    internal string Variable { get; }
    internal string Alias { get; }
    internal string Function { get; }
    internal string FileSystem { get; }
    internal string Registry { get; }
    internal abstract virtual string get_Environment();
    internal abstract virtual string get_Certificate();
    internal abstract virtual string get_Variable();
    internal abstract virtual string get_Alias();
    internal abstract virtual string get_Function();
    internal abstract virtual string get_FileSystem();
    internal abstract virtual string get_Registry();
}
public class System.Management.Automation.ProviderNotFoundException : SessionStateException {
    internal ProviderNotFoundException(string itemName, SessionStateCategory sessionStateCategory, string errorIdAndResourceId, string resourceStr, Object[] messageArgs);
    public ProviderNotFoundException(string message);
    public ProviderNotFoundException(string message, Exception innerException);
}
internal enum System.Management.Automation.ProviderState : Enum {
    public int value__;
    public static ProviderState Started;
    public static ProviderState Stopped;
}
public class System.Management.Automation.ProxyCommand : object {
    public static string Create(CommandMetadata commandMetadata);
    public static string Create(CommandMetadata commandMetadata, string helpComment);
    public static string Create(CommandMetadata commandMetadata, string helpComment, bool generateDynamicParameters);
    public static string GetCmdletBindingAttribute(CommandMetadata commandMetadata);
    public static string GetParamBlock(CommandMetadata commandMetadata);
    public static string GetBegin(CommandMetadata commandMetadata);
    public static string GetProcess(CommandMetadata commandMetadata);
    public static string GetDynamicParam(CommandMetadata commandMetadata);
    public static string GetEnd(CommandMetadata commandMetadata);
    public static string GetClean(CommandMetadata commandMetadata);
    private static T GetProperty(PSObject obj, string property);
    private static string GetObjText(object obj);
    private static void AppendContent(StringBuilder sb, string section, object obj);
    private static void AppendContent(StringBuilder sb, string section, PSObject[] array);
    private static void AppendType(StringBuilder sb, string section, PSObject parent);
    public static string GetHelpComments(PSObject help);
}
public class System.Management.Automation.PSAdaptedProperty : PSProperty {
    public object BaseObject { get; }
    public object Tag { get; }
    public PSAdaptedProperty(string name, object tag);
    internal PSAdaptedProperty(string name, Adapter adapter, object baseObject, object adapterData);
    public virtual PSMemberInfo Copy();
    public object get_BaseObject();
    public object get_Tag();
}
public class System.Management.Automation.PSAliasProperty : PSPropertyInfo {
    [CompilerGeneratedAttribute]
private string <ReferencedMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ConversionType>k__BackingField;
    public string ReferencedMemberName { get; }
    internal PSMemberInfo ReferencedMember { get; }
    public Type ConversionType { get; private set; }
    public PSMemberTypes MemberType { get; }
    public string TypeNameOfValue { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public object Value { get; public set; }
    public PSAliasProperty(string name, string referencedMemberName);
    public PSAliasProperty(string name, string referencedMemberName, Type conversionType);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public string get_ReferencedMemberName();
    internal PSMemberInfo get_ReferencedMember();
    [CompilerGeneratedAttribute]
public Type get_ConversionType();
    [CompilerGeneratedAttribute]
private void set_ConversionType(Type value);
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual string get_TypeNameOfValue();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    private PSMemberInfo LookupMember(string name);
    private void LookupMember(string name, HashSet`1<string> visitedAliases, PSMemberInfo& returnedMember, Boolean& hasCycle);
    public virtual object get_Value();
    public virtual void set_Value(object value);
}
public class System.Management.Automation.PSArgumentException : ArgumentException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    private string _message;
    public ErrorRecord ErrorRecord { get; }
    public string Message { get; }
    public PSArgumentException(string message);
    public PSArgumentException(string message, string paramName);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSArgumentException(SerializationInfo info, StreamingContext context);
    public PSArgumentException(string message, Exception innerException);
    public sealed virtual ErrorRecord get_ErrorRecord();
    public virtual string get_Message();
}
public class System.Management.Automation.PSArgumentNullException : ArgumentNullException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    private string _message;
    public ErrorRecord ErrorRecord { get; }
    public string Message { get; }
    public PSArgumentNullException(string paramName);
    public PSArgumentNullException(string message, Exception innerException);
    public PSArgumentNullException(string paramName, string message);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSArgumentNullException(SerializationInfo info, StreamingContext context);
    public sealed virtual ErrorRecord get_ErrorRecord();
    public virtual string get_Message();
}
public class System.Management.Automation.PSArgumentOutOfRangeException : ArgumentOutOfRangeException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    public ErrorRecord ErrorRecord { get; }
    public PSArgumentOutOfRangeException(string paramName);
    public PSArgumentOutOfRangeException(string paramName, object actualValue, string message);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSArgumentOutOfRangeException(SerializationInfo info, StreamingContext context);
    public PSArgumentOutOfRangeException(string message, Exception innerException);
    public sealed virtual ErrorRecord get_ErrorRecord();
}
internal class System.Management.Automation.PSBoundParametersDictionary : Dictionary`2<string, object> {
    private static IDictionary s_emptyUsingParameters;
    [CompilerGeneratedAttribute]
private List`1<string> <BoundPositionally>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary <ImplicitUsingParameters>k__BackingField;
    public List`1<string> BoundPositionally { get; }
    internal IDictionary ImplicitUsingParameters { get; internal set; }
    private static PSBoundParametersDictionary();
    [CompilerGeneratedAttribute]
public List`1<string> get_BoundPositionally();
    [CompilerGeneratedAttribute]
internal IDictionary get_ImplicitUsingParameters();
    [CompilerGeneratedAttribute]
internal void set_ImplicitUsingParameters(IDictionary value);
}
internal class System.Management.Automation.PSClassHelpProvider : HelpProviderWithCache {
    private ExecutionContext _context;
    private Hashtable _helpFiles;
    [TraceSourceAttribute("PSClassHelpProvider", "PSClassHelpProvider")]
private static PSTraceSource s_tracer;
    internal string Name { get; }
    internal HelpCategory HelpCategory { get; }
    internal PSClassHelpProvider(HelpSystem helpSystem);
    private static PSClassHelpProvider();
    internal virtual string get_Name();
    internal virtual HelpCategory get_HelpCategory();
    [IteratorStateMachineAttribute("System.Management.Automation.PSClassHelpProvider/<SearchHelp>d__8")]
internal virtual IEnumerable`1<HelpInfo> SearchHelp(HelpRequest helpRequest, bool searchOnlyContent);
    [IteratorStateMachineAttribute("System.Management.Automation.PSClassHelpProvider/<ExactMatchHelp>d__9")]
internal virtual IEnumerable`1<HelpInfo> ExactMatchHelp(HelpRequest helpRequest);
    [IteratorStateMachineAttribute("System.Management.Automation.PSClassHelpProvider/<GetHelpInfo>d__10")]
private IEnumerable`1<HelpInfo> GetHelpInfo(PSClassSearcher searcher);
    internal static bool IsMamlHelp(string helpFile, XmlNode helpItemsNode);
    private HelpInfo GetHelpInfoFromHelpFile(PSClassInfo classInfo, string helpFileToFind, Collection`1<string> searchPaths, bool reportErrors, String& helpFile);
    private HelpInfo GetFromPSClassHelpCache(string helpFileIdentifier, HelpCategory helpCategory);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier, string commandName, bool reportErrors);
    private void LoadHelpFile(string helpFile, string helpFileIdentifier);
}
public class System.Management.Automation.PSClassInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<PSClassMemberInfo> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    public string Name { get; }
    public ReadOnlyCollection`1<PSClassMemberInfo> Members { get; private set; }
    public PSModuleInfo Module { get; internal set; }
    public string HelpFile { get; internal set; }
    internal PSClassInfo(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<PSClassMemberInfo> get_Members();
    [CompilerGeneratedAttribute]
private void set_Members(ReadOnlyCollection`1<PSClassMemberInfo> value);
    public void UpdateMembers(IList`1<PSClassMemberInfo> members);
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
internal void set_Module(PSModuleInfo value);
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
internal void set_HelpFile(string value);
}
public class System.Management.Automation.PSClassMemberInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DefaultValue>k__BackingField;
    public string Name { get; }
    public string TypeName { get; }
    public string DefaultValue { get; }
    internal PSClassMemberInfo(string name, string memberType, string defaultValue);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_DefaultValue();
}
internal class System.Management.Automation.PSClassSearcher : object {
    private string _className;
    private ExecutionContext _context;
    private PSClassInfo _currentMatch;
    private IEnumerator`1<PSClassInfo> _matchingClass;
    private Collection`1<PSClassInfo> _matchingClassList;
    private bool _useWildCards;
    private Dictionary`2<string, PSModuleInfo> _moduleInfoCache;
    private object _lockObject;
    private PSClassInfo System.Collections.Generic.IEnumerator<System.Management.Automation.PSClassInfo>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal PSClassSearcher(string className, bool useWildCards, ExecutionContext context);
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    private sealed virtual override IEnumerator`1<PSClassInfo> System.Collections.Generic.IEnumerable<System.Management.Automation.PSClassInfo>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override PSClassInfo System.Collections.Generic.IEnumerator<System.Management.Automation.PSClassInfo>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private PSClassInfo GetNextClass();
    private bool FindTypeByModulePath(WildcardPattern classNameMatcher);
    private PSClassInfo CachedItemToPSClassInfo(WildcardPattern classNameMatcher, string modulePath);
    private Collection`1<PSModuleInfo> GetPSModuleInfo(string modulePath);
    private static PSClassInfo ConvertToClassInfo(PSModuleInfo module, ScriptBlockAst ast, TypeDefinitionAst statement);
}
public abstract class System.Management.Automation.PSCmdlet : Cmdlet {
    private ProviderIntrinsics _invokeProvider;
    private PagingParameters _pagingParameters;
    private CommandInvocationIntrinsics _invokeCommand;
    public PSHost Host { get; }
    public SessionState SessionState { get; }
    public PSEventManager Events { get; }
    public JobRepository JobRepository { get; }
    public JobManager JobManager { get; }
    internal RunspaceRepository RunspaceRepository { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    internal bool HasDynamicParameters { get; }
    public string ParameterSetName { get; }
    public InvocationInfo MyInvocation { get; }
    public PagingParameters PagingParameters { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    public PSHost get_Host();
    public SessionState get_SessionState();
    public PSEventManager get_Events();
    public JobRepository get_JobRepository();
    public JobManager get_JobManager();
    internal RunspaceRepository get_RunspaceRepository();
    public ProviderIntrinsics get_InvokeProvider();
    public PathInfo CurrentProviderLocation(string providerId);
    public string GetUnresolvedProviderPathFromPSPath(string path);
    public Collection`1<string> GetResolvedProviderPathFromPSPath(string path, ProviderInfo& provider);
    public object GetVariableValue(string name);
    public object GetVariableValue(string name, object defaultValue);
    internal bool get_HasDynamicParameters();
    public string get_ParameterSetName();
    public InvocationInfo get_MyInvocation();
    public PagingParameters get_PagingParameters();
    public CommandInvocationIntrinsics get_InvokeCommand();
}
public class System.Management.Automation.PSCodeMethod : PSMethodInfo {
    private MethodInformation[] _codeReferenceMethodInformation;
    [CompilerGeneratedAttribute]
private MethodInfo <CodeReference>k__BackingField;
    public MethodInfo CodeReference { get; private set; }
    public PSMemberTypes MemberType { get; }
    public Collection`1<string> OverloadDefinitions { get; }
    public string TypeNameOfValue { get; }
    internal PSCodeMethod(string name);
    public PSCodeMethod(string name, MethodInfo codeReference);
    public virtual string ToString();
    internal static bool CheckMethodInfo(MethodInfo method);
    internal void SetCodeReference(Type type, string methodName);
    [CompilerGeneratedAttribute]
public MethodInfo get_CodeReference();
    [CompilerGeneratedAttribute]
private void set_CodeReference(MethodInfo value);
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual object Invoke(Object[] arguments);
    public virtual Collection`1<string> get_OverloadDefinitions();
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSCodeProperty : PSPropertyInfo {
    [CompilerGeneratedAttribute]
private MethodInfo <GetterCodeReference>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <SetterCodeReference>k__BackingField;
    public MethodInfo GetterCodeReference { get; private set; }
    public MethodInfo SetterCodeReference { get; private set; }
    public PSMemberTypes MemberType { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    internal PSCodeProperty(string name);
    public PSCodeProperty(string name, MethodInfo getterCodeReference);
    public PSCodeProperty(string name, MethodInfo getterCodeReference, MethodInfo setterCodeReference);
    public virtual string ToString();
    internal void SetGetterFromTypeTable(Type type, string methodName);
    internal void SetSetterFromTypeTable(Type type, string methodName);
    internal void SetGetter(MethodInfo methodForGet);
    internal static bool CheckGetterMethodInfo(MethodInfo methodForGet);
    private void SetSetter(MethodInfo methodForSet, MethodInfo methodForGet);
    internal static bool CheckSetterMethodInfo(MethodInfo methodForSet, MethodInfo methodForGet);
    [CompilerGeneratedAttribute]
public MethodInfo get_GetterCodeReference();
    [CompilerGeneratedAttribute]
private void set_GetterCodeReference(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_SetterCodeReference();
    [CompilerGeneratedAttribute]
private void set_SetterCodeReference(MethodInfo value);
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSCommand : object {
    private PowerShell _owner;
    private CommandCollection _commands;
    private Command _currentCommand;
    public CommandCollection Commands { get; }
    internal PowerShell Owner { get; internal set; }
    internal PSCommand(PSCommand commandToClone);
    internal PSCommand(Command command);
    public PSCommand AddCommand(string command);
    public PSCommand AddCommand(string cmdlet, bool useLocalScope);
    public PSCommand AddScript(string script);
    public PSCommand AddScript(string script, bool useLocalScope);
    public PSCommand AddCommand(Command command);
    public PSCommand AddParameter(string parameterName, object value);
    public PSCommand AddParameter(string parameterName);
    internal PSCommand AddParameter(CommandParameter parameter);
    public PSCommand AddArgument(object value);
    public PSCommand AddStatement();
    public CommandCollection get_Commands();
    internal PowerShell get_Owner();
    internal void set_Owner(PowerShell value);
    public void Clear();
    public PSCommand Clone();
    private void Initialize(string command, bool isScript, Nullable`1<bool> useLocalScope);
}
public abstract class System.Management.Automation.PSControl : object {
    [CompilerGeneratedAttribute]
private PSControlGroupBy <GroupBy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <OutOfBand>k__BackingField;
    public PSControlGroupBy GroupBy { get; public set; }
    public bool OutOfBand { get; public set; }
    [CompilerGeneratedAttribute]
public PSControlGroupBy get_GroupBy();
    [CompilerGeneratedAttribute]
public void set_GroupBy(PSControlGroupBy value);
    [CompilerGeneratedAttribute]
public bool get_OutOfBand();
    [CompilerGeneratedAttribute]
public void set_OutOfBand(bool value);
    internal abstract virtual void WriteToXml(FormatXmlWriter writer);
    internal virtual bool SafeForExport();
    internal virtual bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.PSControlGroupBy : object {
    [CompilerGeneratedAttribute]
private DisplayEntry <Expression>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private CustomControl <CustomControl>k__BackingField;
    public DisplayEntry Expression { get; public set; }
    public string Label { get; public set; }
    public CustomControl CustomControl { get; public set; }
    [CompilerGeneratedAttribute]
public DisplayEntry get_Expression();
    [CompilerGeneratedAttribute]
public void set_Expression(DisplayEntry value);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public CustomControl get_CustomControl();
    [CompilerGeneratedAttribute]
public void set_CustomControl(CustomControl value);
    internal bool IsSafeForExport();
    internal static PSControlGroupBy Get(GroupBy groupBy);
}
public class System.Management.Automation.PSCredential : object {
    private static GetSymmetricEncryptionKey s_delegate;
    private string _userName;
    private SecureString _password;
    private NetworkCredential _netCred;
    private static PSCredential s_empty;
    public static GetSymmetricEncryptionKey GetSymmetricEncryptionKeyDelegate { get; public set; }
    public string UserName { get; }
    public SecureString Password { get; }
    public static PSCredential Empty { get; }
    private PSCredential(SerializationInfo info, StreamingContext context);
    public PSCredential(string userName, SecureString password);
    public PSCredential(PSObject pso);
    private static PSCredential();
    public static GetSymmetricEncryptionKey get_GetSymmetricEncryptionKeyDelegate();
    public static void set_GetSymmetricEncryptionKeyDelegate(GetSymmetricEncryptionKey value);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public string get_UserName();
    public SecureString get_Password();
    public NetworkCredential GetNetworkCredential();
    public static NetworkCredential op_Explicit(PSCredential credential);
    public static PSCredential get_Empty();
    private static bool IsValidUserName(string input, String& user, String& domain);
    private static void SplitUserDomain(string input, String& user, String& domain);
}
[FlagsAttribute]
public enum System.Management.Automation.PSCredentialTypes : Enum {
    public int value__;
    public static PSCredentialTypes Generic;
    public static PSCredentialTypes Domain;
    public static PSCredentialTypes Default;
}
[FlagsAttribute]
public enum System.Management.Automation.PSCredentialUIOptions : Enum {
    public int value__;
    public static PSCredentialUIOptions Default;
    public static PSCredentialUIOptions None;
    public static PSCredentialUIOptions ValidateUserNameSyntax;
    public static PSCredentialUIOptions AlwaysPrompt;
    public static PSCredentialUIOptions ReadOnlyUserName;
}
internal class System.Management.Automation.PSCultureVariable : PSVariable {
    public object Value { get; }
    public virtual object get_Value();
}
public class System.Management.Automation.PSCustomObject : object {
    internal static PSCustomObject SelfInstance;
    private static PSCustomObject();
    public virtual string ToString();
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.PSDataCollection`1 : object {
    private IList`1<T> _data;
    private ManualResetEvent _readWaitHandle;
    private bool _isOpen;
    private bool _releaseOnEnumeration;
    private bool _isEnumerated;
    private int _refCount;
    private bool _isDisposed;
    private bool _blockingEnumerator;
    private bool _refCountIncrementedForBlockingEnumerator;
    private int _countNewData;
    private int _dataAddedFrequency;
    private Guid _sourceGuid;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataAddingEventArgs> DataAdding;
    [CompilerGeneratedAttribute]
private EventHandler`1<DataAddedEventArgs> DataAdded;
    [CompilerGeneratedAttribute]
private EventHandler Completed;
    private bool _serializeInput;
    [CompilerGeneratedAttribute]
private bool <IsAutoGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnumeratorNeverBlocks>k__BackingField;
    private Guid _lastPsInstanceId;
    private int _lastIndex;
    [CompilerGeneratedAttribute]
private object <SyncObject>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> IdleEvent;
    public bool IsOpen { get; }
    public int DataAddedCount { get; public set; }
    public bool SerializeInput { get; public set; }
    public bool IsAutoGenerated { get; public set; }
    internal Guid SourceId { get; internal set; }
    internal bool ReleaseOnEnumeration { get; internal set; }
    internal bool IsEnumerated { get; internal set; }
    public bool BlockingEnumerator { get; public set; }
    public bool EnumeratorNeverBlocks { get; public set; }
    public T Item { get; public set; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private bool System.Collections.IList.IsFixedSize { get; }
    private bool System.Collections.IList.IsReadOnly { get; }
    private object System.Collections.IList.Item { get; private set; }
    private bool System.Collections.ICollection.IsSynchronized { get; }
    private object System.Collections.ICollection.SyncRoot { get; }
    internal WaitHandle WaitHandle { get; }
    internal object SyncObject { get; }
    internal int RefCount { get; internal set; }
    internal bool PulseIdleEvent { get; }
    public PSDataCollection`1(IEnumerable`1<T> items);
    public PSDataCollection`1(int capacity);
    internal PSDataCollection`1(IList`1<T> listToUse);
    protected PSDataCollection`1(SerializationInfo info, StreamingContext context);
    public static PSDataCollection`1<T> op_Implicit(bool valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(string valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(int valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(byte valueToConvert);
    private static PSDataCollection`1<T> CreateAndInitializeFromExplicitValue(object valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(Hashtable valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(T valueToConvert);
    public static PSDataCollection`1<T> op_Implicit(Object[] arrayToConvert);
    [CompilerGeneratedAttribute]
public void add_DataAdding(EventHandler`1<DataAddingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DataAdding(EventHandler`1<DataAddingEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_DataAdded(EventHandler`1<DataAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_DataAdded(EventHandler`1<DataAddedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_Completed(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Completed(EventHandler value);
    public bool get_IsOpen();
    public int get_DataAddedCount();
    public void set_DataAddedCount(int value);
    public bool get_SerializeInput();
    public void set_SerializeInput(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsAutoGenerated();
    [CompilerGeneratedAttribute]
public void set_IsAutoGenerated(bool value);
    internal Guid get_SourceId();
    internal void set_SourceId(Guid value);
    internal bool get_ReleaseOnEnumeration();
    internal void set_ReleaseOnEnumeration(bool value);
    internal bool get_IsEnumerated();
    internal void set_IsEnumerated(bool value);
    public void Complete();
    public bool get_BlockingEnumerator();
    public void set_BlockingEnumerator(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnumeratorNeverBlocks();
    [CompilerGeneratedAttribute]
public void set_EnumeratorNeverBlocks(bool value);
    public sealed virtual T get_Item(int index);
    public sealed virtual void set_Item(int index, T value);
    public sealed virtual int IndexOf(T item);
    public sealed virtual void Insert(int index, T item);
    public sealed virtual void RemoveAt(int index);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public sealed virtual void CopyTo(T[] array, int arrayIndex);
    public sealed virtual bool Remove(T item);
    public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override int System.Collections.IList.Add(object value);
    private sealed virtual override bool System.Collections.IList.Contains(object value);
    private sealed virtual override int System.Collections.IList.IndexOf(object value);
    private sealed virtual override void System.Collections.IList.Insert(int index, object value);
    private sealed virtual override void System.Collections.IList.Remove(object value);
    private sealed virtual override bool System.Collections.IList.get_IsFixedSize();
    private sealed virtual override bool System.Collections.IList.get_IsReadOnly();
    private sealed virtual override object System.Collections.IList.get_Item(int index);
    private sealed virtual override void System.Collections.IList.set_Item(int index, object value);
    private sealed virtual override bool System.Collections.ICollection.get_IsSynchronized();
    private sealed virtual override object System.Collections.ICollection.get_SyncRoot();
    private sealed virtual override void System.Collections.ICollection.CopyTo(Array array, int index);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public Collection`1<T> ReadAll();
    internal Collection`1<T> ReadAndRemove(int readCount);
    internal T ReadAndRemoveAt0();
    protected virtual void InsertItem(Guid psInstanceId, int index, T item);
    protected virtual void RemoveItem(int index);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal WaitHandle get_WaitHandle();
    private void RaiseEvents(Guid psInstanceId, int index);
    private void RaiseDataAddingEvent(Guid psInstanceId, object itemAdded);
    private void RaiseDataAddedEvent(Guid psInstanceId, int index);
    private void InternalInsertItem(Guid psInstanceId, int index, T item);
    internal void InternalAdd(Guid psInstanceId, T item);
    internal void InternalAddRange(Guid psInstanceId, ICollection collection);
    internal void AddRef();
    internal void DecrementRef();
    private int InternalIndexOf(T item);
    private static void VerifyValueType(object value);
    private static PSObject GetSerializedObject(object value);
    private static bool SerializationWouldHaveNoEffect(PSObject result);
    [CompilerGeneratedAttribute]
internal object get_SyncObject();
    internal int get_RefCount();
    internal void set_RefCount(int value);
    internal bool get_PulseIdleEvent();
    [CompilerGeneratedAttribute]
internal void add_IdleEvent(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_IdleEvent(EventHandler`1<EventArgs> value);
    internal void FireIdleEvent();
    internal void Pulse();
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
}
internal class System.Management.Automation.PSDataCollectionEnumerator`1 : object {
    private T _currentElement;
    private int _index;
    private PSDataCollection`1<T> _collToEnumerate;
    private bool _neverBlock;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public object Current { get; }
    internal PSDataCollectionEnumerator`1(PSDataCollection`1<T> collection, bool neverBlock);
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual object get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual bool MoveNext(bool block);
    public sealed virtual void Reset();
    private sealed virtual override void System.IDisposable.Dispose();
}
public class System.Management.Automation.PSDataStreams : object {
    private PowerShell _powershell;
    public PSDataCollection`1<ErrorRecord> Error { get; public set; }
    public PSDataCollection`1<ProgressRecord> Progress { get; public set; }
    public PSDataCollection`1<VerboseRecord> Verbose { get; public set; }
    public PSDataCollection`1<DebugRecord> Debug { get; public set; }
    public PSDataCollection`1<WarningRecord> Warning { get; public set; }
    public PSDataCollection`1<InformationRecord> Information { get; public set; }
    internal PSDataStreams(PowerShell powershell);
    public PSDataCollection`1<ErrorRecord> get_Error();
    public void set_Error(PSDataCollection`1<ErrorRecord> value);
    public PSDataCollection`1<ProgressRecord> get_Progress();
    public void set_Progress(PSDataCollection`1<ProgressRecord> value);
    public PSDataCollection`1<VerboseRecord> get_Verbose();
    public void set_Verbose(PSDataCollection`1<VerboseRecord> value);
    public PSDataCollection`1<DebugRecord> get_Debug();
    public void set_Debug(PSDataCollection`1<DebugRecord> value);
    public PSDataCollection`1<WarningRecord> get_Warning();
    public void set_Warning(PSDataCollection`1<WarningRecord> value);
    public PSDataCollection`1<InformationRecord> get_Information();
    public void set_Information(PSDataCollection`1<InformationRecord> value);
    public void ClearStreams();
}
public class System.Management.Automation.PSDebugContext : object {
    [CompilerGeneratedAttribute]
private InvocationInfo <InvocationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Breakpoint[] <Breakpoints>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Trigger>k__BackingField;
    public InvocationInfo InvocationInfo { get; }
    public Breakpoint[] Breakpoints { get; }
    public object Trigger { get; }
    public PSDebugContext(InvocationInfo invocationInfo, List`1<Breakpoint> breakpoints);
    public PSDebugContext(InvocationInfo invocationInfo, List`1<Breakpoint> breakpoints, object triggerObject);
    [CompilerGeneratedAttribute]
public InvocationInfo get_InvocationInfo();
    [CompilerGeneratedAttribute]
public Breakpoint[] get_Breakpoints();
    [CompilerGeneratedAttribute]
public object get_Trigger();
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.PSDefaultValueAttribute : ParsingBaseAttribute {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Help>k__BackingField;
    public object Value { get; public set; }
    public string Help { get; public set; }
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public string get_Help();
    [CompilerGeneratedAttribute]
public void set_Help(string value);
}
public class System.Management.Automation.PSDriveInfo : object {
    [TraceSourceAttribute("PSDriveInfo", "The namespace navigation tracer")]
private static PSTraceSource s_tracer;
    private string _currentWorkingDirectory;
    private string _name;
    private ProviderInfo _provider;
    private string _root;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <MaximumSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PSCredential <Credential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DriveBeingCreated>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoMounted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAutoMountedManuallyRemoved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Persist>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNetworkDrive>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <VolumeSeparatedByColon>k__BackingField;
    private bool _hidden;
    private PSNoteProperty _noteProperty;
    public string CurrentLocation { get; public set; }
    public string Name { get; }
    public ProviderInfo Provider { get; }
    public string Root { get; internal set; }
    public string Description { get; public set; }
    public Nullable`1<long> MaximumSize { get; internal set; }
    public PSCredential Credential { get; }
    internal bool DriveBeingCreated { get; internal set; }
    internal bool IsAutoMounted { get; internal set; }
    internal bool IsAutoMountedManuallyRemoved { get; internal set; }
    internal bool Persist { get; }
    internal bool IsNetworkDrive { get; internal set; }
    public string DisplayRoot { get; internal set; }
    public bool VolumeSeparatedByColon { get; internal set; }
    internal bool Hidden { get; internal set; }
    protected PSDriveInfo(PSDriveInfo driveInfo);
    public PSDriveInfo(string name, ProviderInfo provider, string root, string description, PSCredential credential);
    public PSDriveInfo(string name, ProviderInfo provider, string root, string description, PSCredential credential, string displayRoot);
    public PSDriveInfo(string name, ProviderInfo provider, string root, string description, PSCredential credential, bool persist);
    private static PSDriveInfo();
    public string get_CurrentLocation();
    public void set_CurrentLocation(string value);
    public string get_Name();
    public ProviderInfo get_Provider();
    public string get_Root();
    internal void set_Root(string value);
    internal void SetRoot(string path);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_MaximumSize();
    [CompilerGeneratedAttribute]
internal void set_MaximumSize(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public PSCredential get_Credential();
    [CompilerGeneratedAttribute]
internal bool get_DriveBeingCreated();
    [CompilerGeneratedAttribute]
internal void set_DriveBeingCreated(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsAutoMounted();
    [CompilerGeneratedAttribute]
internal void set_IsAutoMounted(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsAutoMountedManuallyRemoved();
    [CompilerGeneratedAttribute]
internal void set_IsAutoMountedManuallyRemoved(bool value);
    [CompilerGeneratedAttribute]
internal bool get_Persist();
    [CompilerGeneratedAttribute]
internal bool get_IsNetworkDrive();
    [CompilerGeneratedAttribute]
internal void set_IsNetworkDrive(bool value);
    [CompilerGeneratedAttribute]
public string get_DisplayRoot();
    [CompilerGeneratedAttribute]
internal void set_DisplayRoot(string value);
    [CompilerGeneratedAttribute]
public bool get_VolumeSeparatedByColon();
    [CompilerGeneratedAttribute]
internal void set_VolumeSeparatedByColon(bool value);
    public virtual string ToString();
    internal bool get_Hidden();
    internal void set_Hidden(bool value);
    internal void SetName(string newName);
    internal void SetProvider(ProviderInfo newProvider);
    internal void Trace();
    public int CompareTo(PSDriveInfo drive);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public bool Equals(PSDriveInfo drive);
    public static bool op_Equality(PSDriveInfo drive1, PSDriveInfo drive2);
    public static bool op_Inequality(PSDriveInfo drive1, PSDriveInfo drive2);
    public static bool op_LessThan(PSDriveInfo drive1, PSDriveInfo drive2);
    public static bool op_GreaterThan(PSDriveInfo drive1, PSDriveInfo drive2);
    public virtual int GetHashCode();
    internal PSNoteProperty GetNotePropertyForProviderCmdlets(string name);
}
public class System.Management.Automation.PSDynamicMember : PSMemberInfo {
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    internal PSDynamicMember(string name);
    public virtual string ToString();
    public virtual PSMemberTypes get_MemberType();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
    public virtual PSMemberInfo Copy();
}
public class System.Management.Automation.PSEngineEvent : object {
    public static string Exiting;
    public static string OnIdle;
    internal static string OnScriptBlockInvoke;
    internal static string GetCommandInfoParameterMetadata;
    internal static HashSet`1<string> EngineEvents;
    private static PSEngineEvent();
}
public class System.Management.Automation.PSEvent : PSMemberInfo {
    internal EventInfo baseEvent;
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    internal PSEvent(EventInfo baseEvent);
    public virtual string ToString();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RunspaceId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EventIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Sender>k__BackingField;
    [CompilerGeneratedAttribute]
private EventArgs <SourceEventArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <SourceArgs>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <TimeGenerated>k__BackingField;
    [CompilerGeneratedAttribute]
private PSObject <MessageData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForwardEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEventSlim <EventProcessed>k__BackingField;
    public string ComputerName { get; internal set; }
    public Guid RunspaceId { get; internal set; }
    public int EventIdentifier { get; internal set; }
    public object Sender { get; }
    public EventArgs SourceEventArgs { get; }
    public Object[] SourceArgs { get; }
    public string SourceIdentifier { get; }
    public DateTime TimeGenerated { get; internal set; }
    public PSObject MessageData { get; }
    internal bool ForwardEvent { get; internal set; }
    internal ManualResetEventSlim EventProcessed { get; internal set; }
    internal PSEventArgs(string computerName, Guid runspaceId, int eventIdentifier, string sourceIdentifier, object sender, Object[] originalArgs, PSObject additionalData);
    [CompilerGeneratedAttribute]
public string get_ComputerName();
    [CompilerGeneratedAttribute]
internal void set_ComputerName(string value);
    [CompilerGeneratedAttribute]
public Guid get_RunspaceId();
    [CompilerGeneratedAttribute]
internal void set_RunspaceId(Guid value);
    [CompilerGeneratedAttribute]
public int get_EventIdentifier();
    [CompilerGeneratedAttribute]
internal void set_EventIdentifier(int value);
    [CompilerGeneratedAttribute]
public object get_Sender();
    [CompilerGeneratedAttribute]
public EventArgs get_SourceEventArgs();
    [CompilerGeneratedAttribute]
public Object[] get_SourceArgs();
    [CompilerGeneratedAttribute]
public string get_SourceIdentifier();
    [CompilerGeneratedAttribute]
public DateTime get_TimeGenerated();
    [CompilerGeneratedAttribute]
internal void set_TimeGenerated(DateTime value);
    [CompilerGeneratedAttribute]
public PSObject get_MessageData();
    [CompilerGeneratedAttribute]
internal bool get_ForwardEvent();
    [CompilerGeneratedAttribute]
internal void set_ForwardEvent(bool value);
    [CompilerGeneratedAttribute]
internal ManualResetEventSlim get_EventProcessed();
    [CompilerGeneratedAttribute]
internal void set_EventProcessed(ManualResetEventSlim value);
}
internal class System.Management.Automation.PSEventArgs`1 : EventArgs {
    internal T Args;
    public PSEventArgs`1(T args);
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.PSEventArgsCollection : object {
    [CompilerGeneratedAttribute]
private PSEventReceivedEventHandler PSEventReceived;
    private List`1<PSEventArgs> _eventCollection;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    public int Count { get; }
    public PSEventArgs Item { get; }
    public object SyncRoot { get; }
    [CompilerGeneratedAttribute]
public void add_PSEventReceived(PSEventReceivedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PSEventReceived(PSEventReceivedEventHandler value);
    internal void Add(PSEventArgs eventToAdd);
    public int get_Count();
    public void RemoveAt(int index);
    public PSEventArgs get_Item(int index);
    private void OnPSEventReceived(object sender, PSEventArgs e);
    public sealed virtual IEnumerator`1<PSEventArgs> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [CompilerGeneratedAttribute]
public object get_SyncRoot();
}
public class System.Management.Automation.PSEventHandler : object {
    protected PSEventManager eventManager;
    protected object sender;
    protected string sourceIdentifier;
    protected PSObject extraData;
    public PSEventHandler(PSEventManager eventManager, object sender, string sourceIdentifier, PSObject extraData);
}
public class System.Management.Automation.PSEventJob : Job {
    private PSEventManager _eventManager;
    private PSEventSubscriber _subscriber;
    private int _highestErrorIndex;
    [CompilerGeneratedAttribute]
private string <StatusMessage>k__BackingField;
    private bool _moreData;
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    public PSModuleInfo Module { get; }
    public string StatusMessage { get; }
    public bool HasMoreData { get; }
    public string Location { get; }
    internal ScriptBlock ScriptBlock { get; }
    public PSEventJob(PSEventManager eventManager, PSEventSubscriber subscriber, ScriptBlock action, string name);
    public PSModuleInfo get_Module();
    public virtual void StopJob();
    [CompilerGeneratedAttribute]
public virtual string get_StatusMessage();
    public virtual bool get_HasMoreData();
    public virtual string get_Location();
    [CompilerGeneratedAttribute]
internal ScriptBlock get_ScriptBlock();
    internal void Invoke(PSEventSubscriber eventSubscriber, PSEventArgs eventArgs);
    internal void NotifyJobStopped();
    private void LogErrorsAndOutput(List`1<object> results, SessionState actionState);
}
public abstract class System.Management.Automation.PSEventManager : object {
    private int _nextEventId;
    [CompilerGeneratedAttribute]
private PSEventArgsCollection <ReceivedEvents>k__BackingField;
    public PSEventArgsCollection ReceivedEvents { get; }
    public List`1<PSEventSubscriber> Subscribers { get; }
    protected int GetNextEventId();
    [CompilerGeneratedAttribute]
public PSEventArgsCollection get_ReceivedEvents();
    public abstract virtual List`1<PSEventSubscriber> get_Subscribers();
    protected abstract virtual PSEventArgs CreateEvent(string sourceIdentifier, object sender, Object[] args, PSObject extraData);
    public PSEventArgs GenerateEvent(string sourceIdentifier, object sender, Object[] args, PSObject extraData);
    public PSEventArgs GenerateEvent(string sourceIdentifier, object sender, Object[] args, PSObject extraData, bool processInCurrentThread, bool waitForCompletionInCurrentThread);
    internal abstract virtual void AddForwardedEvent(PSEventArgs forwardedEvent);
    protected abstract virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread);
    protected internal virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread, bool waitForCompletionWhenInCurrentThread);
    public abstract virtual IEnumerable`1<PSEventSubscriber> GetEventSubscribers(string sourceIdentifier);
    public abstract virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent);
    public abstract virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    public abstract virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent);
    public abstract virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    internal virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, bool shouldQueueAndProcessInExecutionThread, int maxTriggerCount);
    public abstract virtual void UnsubscribeEvent(PSEventSubscriber subscriber);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_ForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_ForwardEvent(EventHandler`1<PSEventArgs> value);
}
public class System.Management.Automation.PSEventReceivedEventHandler : MulticastDelegate {
    public PSEventReceivedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PSEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PSEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Management.Automation.PSEventSubscriber : object {
    private ExecutionContext _context;
    [CompilerGeneratedAttribute]
private int <SubscriptionId>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SourceObject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EventName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private PSEventJob <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private PSEventReceivedEventHandler <HandlerDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForwardEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShouldProcessInExecutionThread>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoUnregister>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingTriggerCount>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RemainingActionsToProcess>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBeingUnsubscribed>k__BackingField;
    [CompilerGeneratedAttribute]
private PSEventUnsubscribedEventHandler Unsubscribed;
    public int SubscriptionId { get; public set; }
    public object SourceObject { get; }
    public string EventName { get; }
    public string SourceIdentifier { get; }
    public PSEventJob Action { get; }
    public PSEventReceivedEventHandler HandlerDelegate { get; }
    public bool SupportEvent { get; }
    public bool ForwardEvent { get; }
    internal bool ShouldProcessInExecutionThread { get; internal set; }
    internal bool AutoUnregister { get; }
    internal int RemainingTriggerCount { get; internal set; }
    internal int RemainingActionsToProcess { get; internal set; }
    internal bool IsBeingUnsubscribed { get; internal set; }
    internal PSEventSubscriber(ExecutionContext context, int id, object source, string eventName, string sourceIdentifier, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    internal PSEventSubscriber(ExecutionContext context, int id, object source, string eventName, string sourceIdentifier, ScriptBlock action, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    internal PSEventSubscriber(ExecutionContext context, int id, object source, string eventName, string sourceIdentifier, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    internal void RegisterJob();
    private ScriptBlock CreateBoundScriptBlock(ScriptBlock scriptAction);
    [CompilerGeneratedAttribute]
public int get_SubscriptionId();
    [CompilerGeneratedAttribute]
public void set_SubscriptionId(int value);
    [CompilerGeneratedAttribute]
public object get_SourceObject();
    [CompilerGeneratedAttribute]
public string get_EventName();
    [CompilerGeneratedAttribute]
public string get_SourceIdentifier();
    [CompilerGeneratedAttribute]
public PSEventJob get_Action();
    [CompilerGeneratedAttribute]
public PSEventReceivedEventHandler get_HandlerDelegate();
    [CompilerGeneratedAttribute]
public bool get_SupportEvent();
    [CompilerGeneratedAttribute]
public bool get_ForwardEvent();
    [CompilerGeneratedAttribute]
internal bool get_ShouldProcessInExecutionThread();
    [CompilerGeneratedAttribute]
internal void set_ShouldProcessInExecutionThread(bool value);
    [CompilerGeneratedAttribute]
internal bool get_AutoUnregister();
    [CompilerGeneratedAttribute]
internal int get_RemainingTriggerCount();
    [CompilerGeneratedAttribute]
internal void set_RemainingTriggerCount(int value);
    [CompilerGeneratedAttribute]
internal int get_RemainingActionsToProcess();
    [CompilerGeneratedAttribute]
internal void set_RemainingActionsToProcess(int value);
    [CompilerGeneratedAttribute]
internal bool get_IsBeingUnsubscribed();
    [CompilerGeneratedAttribute]
internal void set_IsBeingUnsubscribed(bool value);
    [CompilerGeneratedAttribute]
public void add_Unsubscribed(PSEventUnsubscribedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_Unsubscribed(PSEventUnsubscribedEventHandler value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(PSEventSubscriber other);
    public virtual int GetHashCode();
    internal void OnPSEventUnsubscribed(object sender, PSEventUnsubscribedEventArgs e);
}
public class System.Management.Automation.PSEventUnsubscribedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PSEventSubscriber <EventSubscriber>k__BackingField;
    public PSEventSubscriber EventSubscriber { get; internal set; }
    internal PSEventUnsubscribedEventArgs(PSEventSubscriber eventSubscriber);
    [CompilerGeneratedAttribute]
public PSEventSubscriber get_EventSubscriber();
    [CompilerGeneratedAttribute]
internal void set_EventSubscriber(PSEventSubscriber value);
}
public class System.Management.Automation.PSEventUnsubscribedEventHandler : MulticastDelegate {
    public PSEventUnsubscribedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, PSEventUnsubscribedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, PSEventUnsubscribedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.PSInferredProperty : PSPropertyInfo {
    [CompilerGeneratedAttribute]
private PSTypeName <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    internal PSTypeName TypeName { get; }
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public PSInferredProperty(string name, PSTypeName typeName);
    [CompilerGeneratedAttribute]
internal PSTypeName get_TypeName();
    public virtual PSMemberTypes get_MemberType();
    [CompilerGeneratedAttribute]
public virtual object get_Value();
    [CompilerGeneratedAttribute]
public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
    public virtual PSMemberInfo Copy();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual string ToString();
}
internal class System.Management.Automation.PSInformationalBuffers : object {
    private Guid _psInstanceId;
    internal PSDataCollection`1<ProgressRecord> progress;
    internal PSDataCollection`1<VerboseRecord> verbose;
    internal PSDataCollection`1<DebugRecord> debug;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<WarningRecord> <Warning>k__BackingField;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<InformationRecord> <Information>k__BackingField;
    internal PSDataCollection`1<ProgressRecord> Progress { get; internal set; }
    internal PSDataCollection`1<VerboseRecord> Verbose { get; internal set; }
    internal PSDataCollection`1<DebugRecord> Debug { get; internal set; }
    internal PSDataCollection`1<WarningRecord> Warning { get; internal set; }
    internal PSDataCollection`1<InformationRecord> Information { get; internal set; }
    internal PSInformationalBuffers(Guid psInstanceId);
    internal PSDataCollection`1<ProgressRecord> get_Progress();
    internal void set_Progress(PSDataCollection`1<ProgressRecord> value);
    internal PSDataCollection`1<VerboseRecord> get_Verbose();
    internal void set_Verbose(PSDataCollection`1<VerboseRecord> value);
    internal PSDataCollection`1<DebugRecord> get_Debug();
    internal void set_Debug(PSDataCollection`1<DebugRecord> value);
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<WarningRecord> get_Warning();
    [CompilerGeneratedAttribute]
internal void set_Warning(PSDataCollection`1<WarningRecord> value);
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<InformationRecord> get_Information();
    [CompilerGeneratedAttribute]
internal void set_Information(PSDataCollection`1<InformationRecord> value);
    internal void AddProgress(ProgressRecord item);
    internal void AddVerbose(VerboseRecord item);
    internal void AddDebug(DebugRecord item);
    internal void AddWarning(WarningRecord item);
    internal void AddInformation(InformationRecord item);
}
internal class System.Management.Automation.PSInternalMemberSet : PSMemberSet {
    private object _syncObject;
    private PSObject _psObject;
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> InternalMembers { get; }
    internal PSInternalMemberSet(string propertyName, PSObject psObject);
    internal virtual PSMemberInfoInternalCollection`1<PSMemberInfo> get_InternalMembers();
    private void GenerateInternalMembersFromBase();
    private PSMemberInfoInternalCollection`1<PSMemberInfo> GetInternalMembersFromAdapted();
    private void GenerateInternalMembersFromPSObject();
}
public class System.Management.Automation.PSInvalidCastException : InvalidCastException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    public ErrorRecord ErrorRecord { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSInvalidCastException(SerializationInfo info, StreamingContext context);
    public PSInvalidCastException(string message);
    public PSInvalidCastException(string message, Exception innerException);
    internal PSInvalidCastException(string errorId, string message, Exception innerException);
    internal PSInvalidCastException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    public sealed virtual ErrorRecord get_ErrorRecord();
}
public class System.Management.Automation.PSInvalidOperationException : InvalidOperationException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    private ErrorCategory _errorCategory;
    private object _target;
    public ErrorRecord ErrorRecord { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSInvalidOperationException(SerializationInfo info, StreamingContext context);
    public PSInvalidOperationException(string message);
    public PSInvalidOperationException(string message, Exception innerException);
    internal PSInvalidOperationException(string message, Exception innerException, string errorId, ErrorCategory errorCategory, object target);
    public sealed virtual ErrorRecord get_ErrorRecord();
    internal void SetErrorId(string errorId);
}
public class System.Management.Automation.PSInvocationSettings : object {
    private PSHost _host;
    [CompilerGeneratedAttribute]
private ApartmentState <ApartmentState>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteStreamOptions <RemoteStreamOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddToHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<ActionPreference> <ErrorActionPreference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FlowImpersonationPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsIdentity <WindowsIdentityToImpersonate>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExposeFlowControlExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InvokeAndDisconnect>k__BackingField;
    public ApartmentState ApartmentState { get; public set; }
    public PSHost Host { get; public set; }
    public RemoteStreamOptions RemoteStreamOptions { get; public set; }
    public bool AddToHistory { get; public set; }
    public Nullable`1<ActionPreference> ErrorActionPreference { get; public set; }
    public bool FlowImpersonationPolicy { get; public set; }
    internal WindowsIdentity WindowsIdentityToImpersonate { get; internal set; }
    public bool ExposeFlowControlExceptions { get; public set; }
    internal bool InvokeAndDisconnect { get; internal set; }
    [CompilerGeneratedAttribute]
public ApartmentState get_ApartmentState();
    [CompilerGeneratedAttribute]
public void set_ApartmentState(ApartmentState value);
    public PSHost get_Host();
    public void set_Host(PSHost value);
    [CompilerGeneratedAttribute]
public RemoteStreamOptions get_RemoteStreamOptions();
    [CompilerGeneratedAttribute]
public void set_RemoteStreamOptions(RemoteStreamOptions value);
    [CompilerGeneratedAttribute]
public bool get_AddToHistory();
    [CompilerGeneratedAttribute]
public void set_AddToHistory(bool value);
    [CompilerGeneratedAttribute]
public Nullable`1<ActionPreference> get_ErrorActionPreference();
    [CompilerGeneratedAttribute]
public void set_ErrorActionPreference(Nullable`1<ActionPreference> value);
    [CompilerGeneratedAttribute]
public bool get_FlowImpersonationPolicy();
    [CompilerGeneratedAttribute]
public void set_FlowImpersonationPolicy(bool value);
    [CompilerGeneratedAttribute]
internal WindowsIdentity get_WindowsIdentityToImpersonate();
    [CompilerGeneratedAttribute]
internal void set_WindowsIdentityToImpersonate(WindowsIdentity value);
    [CompilerGeneratedAttribute]
public bool get_ExposeFlowControlExceptions();
    [CompilerGeneratedAttribute]
public void set_ExposeFlowControlExceptions(bool value);
    [CompilerGeneratedAttribute]
internal bool get_InvokeAndDisconnect();
    [CompilerGeneratedAttribute]
internal void set_InvokeAndDisconnect(bool value);
}
public enum System.Management.Automation.PSInvocationState : Enum {
    public int value__;
    public static PSInvocationState NotStarted;
    public static PSInvocationState Running;
    public static PSInvocationState Stopping;
    public static PSInvocationState Stopped;
    public static PSInvocationState Completed;
    public static PSInvocationState Failed;
    public static PSInvocationState Disconnected;
}
public class System.Management.Automation.PSInvocationStateChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PSInvocationStateInfo <InvocationStateInfo>k__BackingField;
    public PSInvocationStateInfo InvocationStateInfo { get; }
    internal PSInvocationStateChangedEventArgs(PSInvocationStateInfo psStateInfo);
    [CompilerGeneratedAttribute]
public PSInvocationStateInfo get_InvocationStateInfo();
}
public class System.Management.Automation.PSInvocationStateInfo : object {
    private PSInvocationState _executionState;
    private Exception _exceptionReason;
    public PSInvocationState State { get; }
    public Exception Reason { get; }
    internal PSInvocationStateInfo(PSInvocationState state, Exception reason);
    internal PSInvocationStateInfo(PipelineStateInfo pipelineStateInfo);
    public PSInvocationState get_State();
    public Exception get_Reason();
    internal PSInvocationStateInfo Clone();
}
internal class System.Management.Automation.PSInvokeExpressionSyncJob : PSRemotingChildJob {
    private List`1<ExecutionCmdletHelper> _helpers;
    private ThrottleManager _throttleManager;
    private Dictionary`2<Guid, PowerShell> _powershells;
    private int _pipelineFinishedCount;
    private int _pipelineDisconnectedCount;
    private bool _cleanupDone;
    private bool _doFinishCalled;
    internal PSInvokeExpressionSyncJob(List`1<IThrottleOperation> operations, ThrottleManager throttleManager);
    protected virtual void DoCleanupOnFinished();
    protected virtual void Dispose(bool disposing);
    protected virtual void HandleOperationComplete(object sender, OperationStateEventArgs stateEventArgs);
    protected virtual void HandlePipelineStateChanged(object sender, PipelineStateEventArgs e);
    private void CheckForAndSetDisconnectedState(PipelineState pipelineState);
    public virtual void StopJob();
    protected virtual void DoFinish();
    internal virtual PowerShell GetPowerShell(Guid instanceId);
    private void HandleRunspaceStateChanged(object sender, RunspaceStateEventArgs e);
    internal void StartOperations(List`1<IThrottleOperation> operations);
    internal bool IsTerminalState();
    internal Collection`1<PowerShell> GetPowerShells();
    internal PSRemotingJob CreateDisconnectedRemotingJob();
}
public class System.Management.Automation.PSJobStartEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Job <Job>k__BackingField;
    [CompilerGeneratedAttribute]
private Debugger <Debugger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    public Job Job { get; }
    public Debugger Debugger { get; }
    public bool IsAsync { get; }
    public PSJobStartEventArgs(Job job, Debugger debugger, bool isAsync);
    [CompilerGeneratedAttribute]
public Job get_Job();
    [CompilerGeneratedAttribute]
public Debugger get_Debugger();
    [CompilerGeneratedAttribute]
public bool get_IsAsync();
}
public enum System.Management.Automation.PSLanguageMode : Enum {
    public int value__;
    public static PSLanguageMode FullLanguage;
    public static PSLanguageMode RestrictedLanguage;
    public static PSLanguageMode NoLanguage;
    public static PSLanguageMode ConstrainedLanguage;
}
public class System.Management.Automation.PSListModifier : object {
    private Collection`1<object> _itemsToAdd;
    private Collection`1<object> _itemsToRemove;
    private Collection`1<object> _replacementItems;
    internal static string AddKey;
    internal static string RemoveKey;
    internal static string ReplaceKey;
    public Collection`1<object> Add { get; }
    public Collection`1<object> Remove { get; }
    public Collection`1<object> Replace { get; }
    public PSListModifier(Collection`1<object> removeItems, Collection`1<object> addItems);
    public PSListModifier(object replacementItems);
    public PSListModifier(Hashtable hash);
    public Collection`1<object> get_Add();
    public Collection`1<object> get_Remove();
    public Collection`1<object> get_Replace();
    public void ApplyTo(IList collectionToUpdate);
    public void ApplyTo(object collectionToUpdate);
    internal Hashtable ToHashtable();
}
public class System.Management.Automation.PSListModifier`1 : PSListModifier {
    public PSListModifier`1(Collection`1<object> removeItems, Collection`1<object> addItems);
    public PSListModifier`1(object replacementItems);
    public PSListModifier`1(Hashtable hash);
}
internal class System.Management.Automation.PSLocalEventManager : PSEventManager {
    private Dictionary`2<PSEventSubscriber, Delegate> _eventSubscribers;
    private Dictionary`2<string, List`1<PSEventSubscriber>> _engineEventSubscribers;
    private Queue`1<EventAction> _actionQueue;
    private ExecutionContext _context;
    private int _nextSubscriptionId;
    private double _throttleLimit;
    private int _throttleChecks;
    private AssemblyBuilder _eventAssembly;
    private ModuleBuilder _eventModule;
    private int _typeId;
    private Timer _timer;
    private bool _timerInitialized;
    private bool _isTimerActive;
    private int _consecutiveIdleSamples;
    private static Dictionary`2<string, Type> s_generatedEventHandlers;
    private object _actionProcessingLock;
    private EventAction _processingAction;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> ForwardEvent;
    public List`1<PSEventSubscriber> Subscribers { get; }
    internal bool IsExecutingEventAction { get; }
    internal PSLocalEventManager(ExecutionContext context);
    private static PSLocalEventManager();
    public virtual List`1<PSEventSubscriber> get_Subscribers();
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    internal virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, bool shouldQueueAndProcessInExecutionThread, int maxTriggerCount);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    private void OnElapsedEvent(object source);
    private void InitializeTimer();
    private void EnableTimer();
    private void ProcessNewSubscriber(PSEventSubscriber subscriber, object source, string eventName, string sourceIdentifier, PSObject data, bool supportEvent, bool forwardEvent);
    public virtual void UnsubscribeEvent(PSEventSubscriber subscriber);
    private void UnsubscribeEvent(PSEventSubscriber subscriber, bool skipDraining);
    protected virtual PSEventArgs CreateEvent(string sourceIdentifier, object sender, Object[] args, PSObject extraData);
    internal virtual void AddForwardedEvent(PSEventArgs forwardedEvent);
    protected virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread);
    protected internal virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread, bool waitForCompletionWhenInCurrentThread);
    private void ProcessNewEventImplementation(PSEventArgs newEvent, bool processSynchronously);
    private void AddAction(EventAction action, bool processSynchronously);
    private void PulseEngine();
    internal void ProcessPendingActions();
    private void ProcessPendingActionsImpl();
    private void AutoUnregisterEventIfNecessary(PSEventSubscriber subscriber);
    internal void DrainPendingActions(PSEventSubscriber subscriber);
    private void InvokeAction(EventAction nextAction, Boolean& addActionBack);
    internal bool get_IsExecutingEventAction();
    public virtual IEnumerable`1<PSEventSubscriber> GetEventSubscribers(string sourceIdentifier);
    private IEnumerable`1<PSEventSubscriber> GetEventSubscribers(string sourceIdentifier, bool forNewEventProcessing);
    private Type GenerateEventHandler(MethodInfo invokeSignature);
    [CompilerGeneratedAttribute]
internal virtual void add_ForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_ForwardEvent(EventHandler`1<PSEventArgs> value);
    protected virtual void OnForwardEvent(PSEventArgs e);
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
    protected virtual override void Finalize();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <ProcessPendingActionsImpl>b__37_0(object _);
}
public abstract class System.Management.Automation.PSMemberInfo : object {
    internal object instance;
    internal string name;
    [CompilerGeneratedAttribute]
private bool <ShouldSerialize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReservedMember>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstance>k__BackingField;
    internal bool ShouldSerialize { get; internal set; }
    public PSMemberTypes MemberType { get; }
    public string Name { get; }
    internal bool IsReservedMember { get; internal set; }
    internal bool IsHidden { get; internal set; }
    public bool IsInstance { get; internal set; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    [CompilerGeneratedAttribute]
internal bool get_ShouldSerialize();
    [CompilerGeneratedAttribute]
internal void set_ShouldSerialize(bool value);
    internal virtual void ReplicateInstance(object particularInstance);
    internal void SetValueNoConversion(object setValue);
    internal void CloneBaseProperties(PSMemberInfo destiny);
    public abstract virtual PSMemberTypes get_MemberType();
    public string get_Name();
    protected void SetMemberName(string name);
    [CompilerGeneratedAttribute]
internal bool get_IsReservedMember();
    [CompilerGeneratedAttribute]
internal void set_IsReservedMember(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsHidden();
    [CompilerGeneratedAttribute]
internal void set_IsHidden(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsInstance();
    [CompilerGeneratedAttribute]
internal void set_IsInstance(bool value);
    public abstract virtual object get_Value();
    public abstract virtual void set_Value(object value);
    public abstract virtual string get_TypeNameOfValue();
    public abstract virtual PSMemberInfo Copy();
    internal bool MatchesOptions(MshMemberMatchOptions options);
}
[DefaultMemberAttribute("Item")]
public abstract class System.Management.Automation.PSMemberInfoCollection`1 : object {
    public T Item { get; }
    public abstract virtual void Add(T member);
    public abstract virtual void Add(T member, bool preValidated);
    public abstract virtual void Remove(string name);
    public abstract virtual T get_Item(string name);
    public abstract virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name);
    public abstract virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes);
    internal abstract virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes, MshMemberMatchOptions matchOptions);
    internal static bool IsReservedName(string name);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public abstract virtual IEnumerator`1<T> GetEnumerator();
    internal abstract virtual T FirstOrDefault(MemberNamePredicate predicate);
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.PSMemberInfoIntegratingCollection`1 : PSMemberInfoCollection`1<T> {
    [CompilerGeneratedAttribute]
private Collection`1<CollectionEntry`1<T>> <Collections>k__BackingField;
    private PSObject _mshOwner;
    private PSMemberSet _memberSetOwner;
    internal Collection`1<CollectionEntry`1<T>> Collections { get; }
    public T Item { get; }
    internal PSMemberInfoIntegratingCollection`1(object owner, Collection`1<CollectionEntry`1<T>> collections);
    private void GenerateAllReservedMembers();
    [CompilerGeneratedAttribute]
internal Collection`1<CollectionEntry`1<T>> get_Collections();
    public virtual void Add(T member);
    public virtual void Add(T member, bool preValidated);
    internal void AddToReservedMemberSet(T member, bool preValidated);
    internal void AddToTypesXmlCache(T member, bool preValidated);
    public virtual void Remove(string name);
    private void EnsureReservedMemberIsLoaded(string name);
    public virtual T get_Item(string name);
    private PSMemberInfoInternalCollection`1<T> GetIntegratedMembers(MshMemberMatchOptions matchOptions);
    public virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name);
    public virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes);
    internal virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes, MshMemberMatchOptions matchOptions);
    public virtual IEnumerator`1<T> GetEnumerator();
    internal virtual T FirstOrDefault(MemberNamePredicate predicate);
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.PSMemberInfoInternalCollection`1 : PSMemberInfoCollection`1<T> {
    private OrderedDictionary _members;
    private int _countHidden;
    private OrderedDictionary Members { get; }
    public T Item { get; }
    internal int Count { get; }
    internal int VisibleCount { get; }
    internal T Item { get; }
    internal PSMemberInfoInternalCollection`1(int capacity);
    private OrderedDictionary get_Members();
    private void Replace(T oldMember, T newMember);
    internal void Replace(T newMember);
    public virtual void Add(T member);
    public virtual void Add(T member, bool preValidated);
    public virtual void Remove(string name);
    public virtual T get_Item(string name);
    public virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name);
    public virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes);
    internal virtual ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes, MshMemberMatchOptions matchOptions);
    private PSMemberInfoInternalCollection`1<T> GetInternalMembers(MshMemberMatchOptions matchOptions);
    internal int get_Count();
    internal int get_VisibleCount();
    internal T get_Item(int index);
    public virtual IEnumerator`1<T> GetEnumerator();
    internal virtual T FirstOrDefault(MemberNamePredicate predicate);
}
[IsReadOnlyAttribute]
[DebuggerDisplayAttribute("{PSTypeName} {Name}")]
internal class System.Management.Automation.PSMemberNameAndType : ValueType {
    public string Name;
    public PSTypeName PSTypeName;
    public object Value;
    public PSMemberNameAndType(string name, PSTypeName typeName, object value);
}
public class System.Management.Automation.PSMemberSet : PSMemberInfo {
    private PSMemberInfoIntegratingCollection`1<PSMemberInfo> _members;
    private PSMemberInfoIntegratingCollection`1<PSPropertyInfo> _properties;
    private PSMemberInfoIntegratingCollection`1<PSMethodInfo> _methods;
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> internalMembers;
    private PSObject _constructorPSObject;
    private static Collection`1<CollectionEntry`1<PSMemberInfo>> s_emptyMemberCollection;
    private static Collection`1<CollectionEntry`1<PSMethodInfo>> s_emptyMethodCollection;
    private static Collection`1<CollectionEntry`1<PSPropertyInfo>> s_emptyPropertyCollection;
    private static Collection`1<CollectionEntry`1<PSMemberInfo>> s_typeMemberCollection;
    private static Collection`1<CollectionEntry`1<PSMethodInfo>> s_typeMethodCollection;
    private static Collection`1<CollectionEntry`1<PSPropertyInfo>> s_typePropertyCollection;
    internal bool inheritMembers;
    public bool InheritMembers { get; }
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> InternalMembers { get; }
    public PSMemberInfoCollection`1<PSMemberInfo> Members { get; }
    public PSMemberInfoCollection`1<PSPropertyInfo> Properties { get; }
    public PSMemberInfoCollection`1<PSMethodInfo> Methods { get; }
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public PSMemberSet(string name);
    public PSMemberSet(string name, IEnumerable`1<PSMemberInfo> members);
    internal PSMemberSet(string name, PSMemberInfoInternalCollection`1<PSMemberInfo> members);
    internal PSMemberSet(string name, PSObject mshObject);
    private static PSMemberSet();
    internal virtual void ReplicateInstance(object particularInstance);
    public virtual string ToString();
    private static Collection`1<CollectionEntry`1<PSMemberInfo>> GetTypeMemberCollection();
    private static Collection`1<CollectionEntry`1<PSMethodInfo>> GetTypeMethodCollection();
    private static Collection`1<CollectionEntry`1<PSPropertyInfo>> GetTypePropertyCollection();
    public bool get_InheritMembers();
    internal virtual PSMemberInfoInternalCollection`1<PSMemberInfo> get_InternalMembers();
    public PSMemberInfoCollection`1<PSMemberInfo> get_Members();
    public PSMemberInfoCollection`1<PSPropertyInfo> get_Properties();
    public PSMemberInfoCollection`1<PSMethodInfo> get_Methods();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
}
internal class System.Management.Automation.PSMemberSetAdapter : MemberRedirectionAdapter {
    [IteratorStateMachineAttribute("System.Management.Automation.PSMemberSetAdapter/<GetTypeNameHierarchy>d__0")]
protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
}
[TypeConverterAttribute("System.Management.Automation.LanguagePrimitives/EnumMultipleTypeConverter")]
[FlagsAttribute]
public enum System.Management.Automation.PSMemberTypes : Enum {
    public int value__;
    public static PSMemberTypes AliasProperty;
    public static PSMemberTypes CodeProperty;
    public static PSMemberTypes Property;
    public static PSMemberTypes NoteProperty;
    public static PSMemberTypes ScriptProperty;
    public static PSMemberTypes PropertySet;
    public static PSMemberTypes Method;
    public static PSMemberTypes CodeMethod;
    public static PSMemberTypes ScriptMethod;
    public static PSMemberTypes ParameterizedProperty;
    public static PSMemberTypes MemberSet;
    public static PSMemberTypes Event;
    public static PSMemberTypes Dynamic;
    public static PSMemberTypes InferredProperty;
    public static PSMemberTypes Properties;
    public static PSMemberTypes Methods;
    public static PSMemberTypes All;
}
[TypeConverterAttribute("System.Management.Automation.LanguagePrimitives/EnumMultipleTypeConverter")]
[FlagsAttribute]
public enum System.Management.Automation.PSMemberViewTypes : Enum {
    public int value__;
    public static PSMemberViewTypes Extended;
    public static PSMemberViewTypes Adapted;
    public static PSMemberViewTypes Base;
    public static PSMemberViewTypes All;
}
public class System.Management.Automation.PSMethod : PSMethodInfo {
    internal object adapterData;
    internal Adapter _adapter;
    internal object baseObject;
    [CompilerGeneratedAttribute]
private bool <IsSpecial>k__BackingField;
    public PSMemberTypes MemberType { get; }
    public Collection`1<string> OverloadDefinitions { get; }
    public string TypeNameOfValue { get; }
    internal bool IsSpecial { get; }
    internal PSMethod(string name, Adapter adapter, object baseObject, object adapterData);
    internal PSMethod(string name, Adapter adapter, object baseObject, object adapterData, bool isSpecial, bool isHidden);
    internal virtual void ReplicateInstance(object particularInstance);
    public virtual string ToString();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual object Invoke(Object[] arguments);
    internal object Invoke(PSMethodInvocationConstraints invocationConstraints, Object[] arguments);
    public virtual Collection`1<string> get_OverloadDefinitions();
    public virtual string get_TypeNameOfValue();
    [CompilerGeneratedAttribute]
internal bool get_IsSpecial();
    internal static PSMethod Create(string name, DotNetAdapter dotNetInstanceAdapter, object baseObject, MethodCacheEntry method);
    internal static PSMethod Create(string name, DotNetAdapter dotNetInstanceAdapter, object baseObject, MethodCacheEntry method, bool isSpecial, bool isHidden);
    private static Type GetMethodGroupType(MethodInfo methodInfo);
    private static Type GetPSMethodProjectedType(Type type, bool isOut);
    private static Func`7<string, DotNetAdapter, object, object, bool, bool, PSMethod> CreatePSMethodConstructor(MethodInformation[] methods);
    private static Type CreateMethodGroup(Type[] sourceTypes, int start, int count);
}
internal class System.Management.Automation.PSMethod`1 : PSMethod {
    internal PSMethod`1(string name, Adapter adapter, object baseObject, object adapterData);
    internal PSMethod`1(string name, Adapter adapter, object baseObject, object adapterData, bool isSpecial, bool isHidden);
    public virtual PSMemberInfo Copy();
    internal static PSMethod`1<T> Create(string name, Adapter adapter, object baseObject, object adapterData, bool isSpecial, bool isHidden);
}
public abstract class System.Management.Automation.PSMethodInfo : PSMemberInfo {
    public Collection`1<string> OverloadDefinitions { get; }
    public object Value { get; public set; }
    public abstract virtual object Invoke(Object[] arguments);
    public abstract virtual Collection`1<string> get_OverloadDefinitions();
    public sealed virtual object get_Value();
    public sealed virtual void set_Value(object value);
}
internal class System.Management.Automation.PSMethodInvocationConstraints : object {
    [CompilerGeneratedAttribute]
private Type <MethodTargetType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ParameterTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <GenericTypeParameters>k__BackingField;
    public Type MethodTargetType { get; }
    public Type[] ParameterTypes { get; }
    public Object[] GenericTypeParameters { get; }
    internal PSMethodInvocationConstraints(Type methodTargetType, Type[] parameterTypes);
    internal PSMethodInvocationConstraints(Type methodTargetType, Type[] parameterTypes, Object[] genericTypeParameters);
    [CompilerGeneratedAttribute]
public Type get_MethodTargetType();
    [CompilerGeneratedAttribute]
public Type[] get_ParameterTypes();
    [CompilerGeneratedAttribute]
public Object[] get_GenericTypeParameters();
    internal static bool EqualsForCollection(ICollection`1<T> xs, ICollection`1<T> ys);
    public bool Equals(PSMethodInvocationConstraints other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
}
internal class System.Management.Automation.PSMethodSignatureEnumerator : ValueType {
    private int _currentIndex;
    private Type _t;
    [CompilerGeneratedAttribute]
private Type <Current>k__BackingField;
    public Type Current { get; private set; }
    private object System.Collections.IEnumerator.Current { get; }
    internal PSMethodSignatureEnumerator(Type t);
    public sealed virtual bool MoveNext();
    private bool MoveNext(Type type, int index);
    public sealed virtual void Reset();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual Type get_Current();
    [CompilerGeneratedAttribute]
private void set_Current(Type value);
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public sealed virtual void Dispose();
}
public enum System.Management.Automation.PSModuleAutoLoadingPreference : Enum {
    public int value__;
    public static PSModuleAutoLoadingPreference None;
    public static PSModuleAutoLoadingPreference ModuleQualified;
    public static PSModuleAutoLoadingPreference All;
}
public class System.Management.Automation.PSModuleInfo : object {
    internal static string DynamicModulePrefixString;
    private static ReadOnlyDictionary`2<string, TypeDefinitionAst> s_emptyTypeDefinitionDictionary;
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<string, TypeDefinitionAst> <_exportedTypeDefinitionsNoNested>k__BackingField;
    private static HashSet`1<string> s_scriptModuleExtensions;
    [CompilerGeneratedAttribute]
private Nullable`1<PSLanguageMode> <LanguageMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ModuleAutoExportsAllFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ModuleHasPrivateMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HadErrorsLoading>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogPipelineExecutionDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Assembly <ImplementingAssembly>k__BackingField;
    internal IScriptExtent _definitionExtent;
    private string _description;
    [CompilerGeneratedAttribute]
private Guid <Guid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpInfoUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsWindowsPowerShellCompatModule>k__BackingField;
    private string _moduleBase;
    private object _privateData;
    [CompilerGeneratedAttribute]
private IEnumerable`1<ExperimentalFeature> <ExperimentalFeatures>k__BackingField;
    private List`1<string> _tags;
    [CompilerGeneratedAttribute]
private Uri <ProjectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <IconUri>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <LicenseUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RepositorySourceLocation>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private ModuleType <ModuleType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Author>k__BackingField;
    private ModuleAccessMode _accessMode;
    [CompilerGeneratedAttribute]
private Version <ClrVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompanyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <DotNetFrameworkVersion>k__BackingField;
    internal Collection`1<string> DeclaredFunctionExports;
    internal Collection`1<string> DeclaredCmdletExports;
    internal Collection`1<string> DeclaredAliasExports;
    internal Collection`1<string> DeclaredVariableExports;
    internal List`1<string> DetectedFunctionExports;
    internal List`1<string> DetectedCmdletExports;
    internal Dictionary`2<string, string> DetectedAliasExports;
    [CompilerGeneratedAttribute]
private string <Prefix>k__BackingField;
    private List`1<CmdletInfo> _compiledExports;
    [CompilerGeneratedAttribute]
private List`1<AliasInfo> <CompiledAliasExports>k__BackingField;
    private List`1<string> _fileList;
    private List`1<string> _compatiblePSEditions;
    [CompilerGeneratedAttribute]
private bool <IsConsideredEditionCompatible>k__BackingField;
    private Collection`1<object> _moduleList;
    private ReadOnlyCollection`1<PSModuleInfo> _readonlyNestedModules;
    private List`1<PSModuleInfo> _nestedModules;
    [CompilerGeneratedAttribute]
private string <PowerShellHostName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PowerShellHostVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PowerShellVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private ProcessorArchitecture <ProcessorArchitecture>k__BackingField;
    private List`1<string> _scripts;
    private Collection`1<string> _requiredAssemblies;
    private ReadOnlyCollection`1<PSModuleInfo> _readonlyRequiredModules;
    private List`1<PSModuleInfo> _requiredModules;
    private ReadOnlyCollection`1<ModuleSpecification> _readonlyRequiredModulesSpecification;
    private List`1<ModuleSpecification> _requiredModulesSpecification;
    [CompilerGeneratedAttribute]
private string <RootModule>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootModuleForManifest>k__BackingField;
    internal static String[] _builtinVariables;
    internal Collection`1<string> _declaredDscResourceExports;
    [CompilerGeneratedAttribute]
private SessionState <SessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <OnRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ExportedFormatFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <ExportedTypeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <UseAppDomainLevelModuleCache>k__BackingField;
    private static ConcurrentDictionary`2<string, string> s_appdomainModulePathCache;
    private ReadOnlyDictionary`2<string, TypeDefinitionAst> _exportedTypeDefinitionsNoNested { get; private set; }
    internal Nullable`1<PSLanguageMode> LanguageMode { get; internal set; }
    internal bool ModuleAutoExportsAllFunctions { get; internal set; }
    internal bool ModuleHasPrivateMembers { get; internal set; }
    internal bool HadErrorsLoading { get; internal set; }
    public bool LogPipelineExecutionDetails { get; public set; }
    public string Name { get; private set; }
    public string Path { get; internal set; }
    public Assembly ImplementingAssembly { get; internal set; }
    public string Definition { get; }
    public string Description { get; public set; }
    public Guid Guid { get; private set; }
    public string HelpInfoUri { get; private set; }
    internal bool IsWindowsPowerShellCompatModule { get; internal set; }
    public string ModuleBase { get; }
    public object PrivateData { get; public set; }
    public IEnumerable`1<ExperimentalFeature> ExperimentalFeatures { get; internal set; }
    public IEnumerable`1<string> Tags { get; }
    public Uri ProjectUri { get; internal set; }
    public Uri IconUri { get; internal set; }
    public Uri LicenseUri { get; internal set; }
    public string ReleaseNotes { get; internal set; }
    public Uri RepositorySourceLocation { get; internal set; }
    public Version Version { get; private set; }
    public ModuleType ModuleType { get; private set; }
    public string Author { get; internal set; }
    public ModuleAccessMode AccessMode { get; public set; }
    public Version ClrVersion { get; internal set; }
    public string CompanyName { get; internal set; }
    public string Copyright { get; internal set; }
    public Version DotNetFrameworkVersion { get; internal set; }
    public Dictionary`2<string, FunctionInfo> ExportedFunctions { get; }
    public string Prefix { get; internal set; }
    public Dictionary`2<string, CmdletInfo> ExportedCmdlets { get; }
    public Dictionary`2<string, CommandInfo> ExportedCommands { get; }
    internal List`1<CmdletInfo> CompiledExports { get; }
    internal List`1<AliasInfo> CompiledAliasExports { get; }
    public IEnumerable`1<string> FileList { get; }
    public IEnumerable`1<string> CompatiblePSEditions { get; }
    internal bool IsConsideredEditionCompatible { get; internal set; }
    public IEnumerable`1<object> ModuleList { get; }
    public ReadOnlyCollection`1<PSModuleInfo> NestedModules { get; }
    public string PowerShellHostName { get; internal set; }
    public Version PowerShellHostVersion { get; internal set; }
    public Version PowerShellVersion { get; internal set; }
    public ProcessorArchitecture ProcessorArchitecture { get; internal set; }
    public IEnumerable`1<string> Scripts { get; }
    public IEnumerable`1<string> RequiredAssemblies { get; }
    public ReadOnlyCollection`1<PSModuleInfo> RequiredModules { get; }
    internal ReadOnlyCollection`1<ModuleSpecification> RequiredModulesSpecification { get; }
    public string RootModule { get; internal set; }
    internal string RootModuleForManifest { get; internal set; }
    public Dictionary`2<string, PSVariable> ExportedVariables { get; }
    public Dictionary`2<string, AliasInfo> ExportedAliases { get; }
    public ReadOnlyCollection`1<string> ExportedDscResources { get; }
    public SessionState SessionState { get; public set; }
    public ScriptBlock OnRemove { get; public set; }
    public ReadOnlyCollection`1<string> ExportedFormatFiles { get; private set; }
    public ReadOnlyCollection`1<string> ExportedTypeFiles { get; private set; }
    public static bool UseAppDomainLevelModuleCache { get; public set; }
    internal PSModuleInfo(string path, ExecutionContext context, SessionState sessionState);
    internal PSModuleInfo(string name, string path, ExecutionContext context, SessionState sessionState, Nullable`1<PSLanguageMode> languageMode);
    internal PSModuleInfo(string name, string path, ExecutionContext context, SessionState sessionState);
    public PSModuleInfo(bool linkToGlobal);
    internal PSModuleInfo(ExecutionContext context, bool linkToGlobal);
    public PSModuleInfo(ScriptBlock scriptBlock);
    private static PSModuleInfo();
    [CompilerGeneratedAttribute]
private ReadOnlyDictionary`2<string, TypeDefinitionAst> get__exportedTypeDefinitionsNoNested();
    [CompilerGeneratedAttribute]
private void set__exportedTypeDefinitionsNoNested(ReadOnlyDictionary`2<string, TypeDefinitionAst> value);
    internal static void SetDefaultDynamicNameAndPath(PSModuleInfo module);
    [CompilerGeneratedAttribute]
internal Nullable`1<PSLanguageMode> get_LanguageMode();
    [CompilerGeneratedAttribute]
internal void set_LanguageMode(Nullable`1<PSLanguageMode> value);
    [CompilerGeneratedAttribute]
internal bool get_ModuleAutoExportsAllFunctions();
    [CompilerGeneratedAttribute]
internal void set_ModuleAutoExportsAllFunctions(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ModuleHasPrivateMembers();
    [CompilerGeneratedAttribute]
internal void set_ModuleHasPrivateMembers(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HadErrorsLoading();
    [CompilerGeneratedAttribute]
internal void set_HadErrorsLoading(bool value);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public bool get_LogPipelineExecutionDetails();
    [CompilerGeneratedAttribute]
public void set_LogPipelineExecutionDetails(bool value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    internal void SetName(string name);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
internal void set_Path(string value);
    [CompilerGeneratedAttribute]
public Assembly get_ImplementingAssembly();
    [CompilerGeneratedAttribute]
internal void set_ImplementingAssembly(Assembly value);
    public string get_Definition();
    public string get_Description();
    public void set_Description(string value);
    [CompilerGeneratedAttribute]
public Guid get_Guid();
    [CompilerGeneratedAttribute]
private void set_Guid(Guid value);
    internal void SetGuid(Guid guid);
    [CompilerGeneratedAttribute]
public string get_HelpInfoUri();
    [CompilerGeneratedAttribute]
private void set_HelpInfoUri(string value);
    [CompilerGeneratedAttribute]
internal bool get_IsWindowsPowerShellCompatModule();
    [CompilerGeneratedAttribute]
internal void set_IsWindowsPowerShellCompatModule(bool value);
    internal void SetHelpInfoUri(string uri);
    public string get_ModuleBase();
    internal void SetModuleBase(string moduleBase);
    public object get_PrivateData();
    public void set_PrivateData(object value);
    private void SetPSDataPropertiesFromPrivateData();
    private static Uri GetUriFromString(string uriString);
    [CompilerGeneratedAttribute]
public IEnumerable`1<ExperimentalFeature> get_ExperimentalFeatures();
    [CompilerGeneratedAttribute]
internal void set_ExperimentalFeatures(IEnumerable`1<ExperimentalFeature> value);
    public IEnumerable`1<string> get_Tags();
    internal void AddToTags(string tag);
    [CompilerGeneratedAttribute]
public Uri get_ProjectUri();
    [CompilerGeneratedAttribute]
internal void set_ProjectUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_IconUri();
    [CompilerGeneratedAttribute]
internal void set_IconUri(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_LicenseUri();
    [CompilerGeneratedAttribute]
internal void set_LicenseUri(Uri value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
internal void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public Uri get_RepositorySourceLocation();
    [CompilerGeneratedAttribute]
internal void set_RepositorySourceLocation(Uri value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
private void set_Version(Version value);
    internal void SetVersion(Version version);
    [CompilerGeneratedAttribute]
public ModuleType get_ModuleType();
    [CompilerGeneratedAttribute]
private void set_ModuleType(ModuleType value);
    internal void SetModuleType(ModuleType moduleType);
    [CompilerGeneratedAttribute]
public string get_Author();
    [CompilerGeneratedAttribute]
internal void set_Author(string value);
    public ModuleAccessMode get_AccessMode();
    public void set_AccessMode(ModuleAccessMode value);
    [CompilerGeneratedAttribute]
public Version get_ClrVersion();
    [CompilerGeneratedAttribute]
internal void set_ClrVersion(Version value);
    [CompilerGeneratedAttribute]
public string get_CompanyName();
    [CompilerGeneratedAttribute]
internal void set_CompanyName(string value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
internal void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public Version get_DotNetFrameworkVersion();
    [CompilerGeneratedAttribute]
internal void set_DotNetFrameworkVersion(Version value);
    public Dictionary`2<string, FunctionInfo> get_ExportedFunctions();
    private static bool IsScriptModuleFile(string path);
    public ReadOnlyDictionary`2<string, TypeDefinitionAst> GetExportedTypeDefinitions();
    internal void CreateExportedTypeDefinitions(ScriptBlockAst moduleContentScriptBlockAsts);
    internal void AddDetectedTypeExports(List`1<TypeDefinitionAst> typeDefinitions);
    [CompilerGeneratedAttribute]
public string get_Prefix();
    [CompilerGeneratedAttribute]
internal void set_Prefix(string value);
    internal void AddDetectedFunctionExport(string name);
    public Dictionary`2<string, CmdletInfo> get_ExportedCmdlets();
    internal void AddDetectedCmdletExport(string cmdlet);
    public Dictionary`2<string, CommandInfo> get_ExportedCommands();
    internal void AddExportedCmdlet(CmdletInfo cmdlet);
    internal List`1<CmdletInfo> get_CompiledExports();
    internal void AddExportedAlias(AliasInfo aliasInfo);
    [CompilerGeneratedAttribute]
internal List`1<AliasInfo> get_CompiledAliasExports();
    public IEnumerable`1<string> get_FileList();
    internal void AddToFileList(string file);
    public IEnumerable`1<string> get_CompatiblePSEditions();
    internal void AddToCompatiblePSEditions(string psEdition);
    internal void AddToCompatiblePSEditions(IEnumerable`1<string> psEditions);
    [CompilerGeneratedAttribute]
internal bool get_IsConsideredEditionCompatible();
    [CompilerGeneratedAttribute]
internal void set_IsConsideredEditionCompatible(bool value);
    public IEnumerable`1<object> get_ModuleList();
    internal void AddToModuleList(object m);
    public ReadOnlyCollection`1<PSModuleInfo> get_NestedModules();
    internal void AddNestedModule(PSModuleInfo nestedModule);
    [CompilerGeneratedAttribute]
public string get_PowerShellHostName();
    [CompilerGeneratedAttribute]
internal void set_PowerShellHostName(string value);
    [CompilerGeneratedAttribute]
public Version get_PowerShellHostVersion();
    [CompilerGeneratedAttribute]
internal void set_PowerShellHostVersion(Version value);
    [CompilerGeneratedAttribute]
public Version get_PowerShellVersion();
    [CompilerGeneratedAttribute]
internal void set_PowerShellVersion(Version value);
    [CompilerGeneratedAttribute]
public ProcessorArchitecture get_ProcessorArchitecture();
    [CompilerGeneratedAttribute]
internal void set_ProcessorArchitecture(ProcessorArchitecture value);
    public IEnumerable`1<string> get_Scripts();
    internal void AddScript(string s);
    public IEnumerable`1<string> get_RequiredAssemblies();
    internal void AddRequiredAssembly(string assembly);
    public ReadOnlyCollection`1<PSModuleInfo> get_RequiredModules();
    internal void AddRequiredModule(PSModuleInfo requiredModule);
    internal ReadOnlyCollection`1<ModuleSpecification> get_RequiredModulesSpecification();
    internal void AddRequiredModuleSpecification(ModuleSpecification requiredModuleSpecification);
    [CompilerGeneratedAttribute]
public string get_RootModule();
    [CompilerGeneratedAttribute]
internal void set_RootModule(string value);
    [CompilerGeneratedAttribute]
internal string get_RootModuleForManifest();
    [CompilerGeneratedAttribute]
internal void set_RootModuleForManifest(string value);
    private static void AddModuleToList(PSModuleInfo module, List`1<PSModuleInfo> moduleList);
    public Dictionary`2<string, PSVariable> get_ExportedVariables();
    public Dictionary`2<string, AliasInfo> get_ExportedAliases();
    internal void AddDetectedAliasExport(string name, string value);
    public ReadOnlyCollection`1<string> get_ExportedDscResources();
    [CompilerGeneratedAttribute]
public SessionState get_SessionState();
    [CompilerGeneratedAttribute]
public void set_SessionState(SessionState value);
    public ScriptBlock NewBoundScriptBlock(ScriptBlock scriptBlockToBind);
    internal ScriptBlock NewBoundScriptBlock(ScriptBlock scriptBlockToBind, ExecutionContext context);
    public object Invoke(ScriptBlock sb, Object[] args);
    public PSVariable GetVariableFromCallersModule(string variableName);
    internal void CaptureLocals();
    public PSObject AsCustomObject();
    [CompilerGeneratedAttribute]
public ScriptBlock get_OnRemove();
    [CompilerGeneratedAttribute]
public void set_OnRemove(ScriptBlock value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ExportedFormatFiles();
    [CompilerGeneratedAttribute]
private void set_ExportedFormatFiles(ReadOnlyCollection`1<string> value);
    internal void SetExportedFormatFiles(ReadOnlyCollection`1<string> files);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_ExportedTypeFiles();
    [CompilerGeneratedAttribute]
private void set_ExportedTypeFiles(ReadOnlyCollection`1<string> value);
    internal void SetExportedTypeFiles(ReadOnlyCollection`1<string> files);
    public PSModuleInfo Clone();
    [CompilerGeneratedAttribute]
public static bool get_UseAppDomainLevelModuleCache();
    [CompilerGeneratedAttribute]
public static void set_UseAppDomainLevelModuleCache(bool value);
    public static void ClearAppDomainLevelModulePathCache();
    internal static string ResolveUsingAppDomainLevelModuleCache(string moduleName);
    internal static void AddToAppDomainLevelModuleCache(string moduleName, string path, bool force);
    internal static bool RemoveFromAppDomainLevelCache(string moduleName);
}
internal class System.Management.Automation.PSModuleInfoComparer : object {
    public sealed virtual bool Equals(PSModuleInfo x, PSModuleInfo y);
    public sealed virtual int GetHashCode(PSModuleInfo obj);
}
internal abstract class System.Management.Automation.PSNonBindableType : object {
}
public class System.Management.Automation.PSNoteProperty : PSPropertyInfo {
    internal object noteValue;
    public PSMemberTypes MemberType { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public PSNoteProperty(string name, object value);
    public virtual string ToString();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
    internal static string GetDisplayTypeNameOfValue(object val);
}
public class System.Management.Automation.PSNotImplementedException : NotImplementedException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    public ErrorRecord ErrorRecord { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSNotImplementedException(SerializationInfo info, StreamingContext context);
    public PSNotImplementedException(string message);
    public PSNotImplementedException(string message, Exception innerException);
    public sealed virtual ErrorRecord get_ErrorRecord();
}
public class System.Management.Automation.PSNotSupportedException : NotSupportedException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    public ErrorRecord ErrorRecord { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSNotSupportedException(SerializationInfo info, StreamingContext context);
    public PSNotSupportedException(string message);
    public PSNotSupportedException(string message, Exception innerException);
    public sealed virtual ErrorRecord get_ErrorRecord();
}
[TypeDescriptionProviderAttribute("System.Management.Automation.PSObjectTypeDescriptionProvider")]
public class System.Management.Automation.PSObject : object {
    private static ConcurrentDictionary`2<Type, AdapterSet> s_adapterMapping;
    private static List`1<Func`2<object, AdapterSet>> s_adapterSetMappers;
    private object _lockObject;
    private ConsolidatedString _typeNames;
    private object _immediateBaseObject;
    private WeakReference`1<TypeTable> _typeTable;
    private AdapterSet _adapterSet;
    private PSMemberInfoInternalCollection`1<PSMemberInfo> _instanceMembers;
    private PSMemberInfoIntegratingCollection`1<PSMemberInfo> _members;
    private PSMemberInfoIntegratingCollection`1<PSPropertyInfo> _properties;
    private PSMemberInfoIntegratingCollection`1<PSMethodInfo> _methods;
    private PSObjectFlags _flags;
    private static PSTraceSource s_memberResolution;
    private static ConditionalWeakTable`2<object, ConsolidatedString> s_typeNamesResurrectionTable;
    private static Collection`1<CollectionEntry`1<PSMemberInfo>> s_memberCollection;
    private static Collection`1<CollectionEntry`1<PSMethodInfo>> s_methodCollection;
    private static Collection`1<CollectionEntry`1<PSPropertyInfo>> s_propertyCollection;
    private static DotNetAdapter s_dotNetInstanceAdapter;
    private static DotNetAdapter s_baseAdapterForAdaptedObjects;
    private static DotNetAdapter s_dotNetStaticAdapter;
    private static AdapterSet s_dotNetInstanceAdapterSet;
    private static AdapterSet s_mshMemberSetAdapter;
    private static AdapterSet s_mshObjectAdapter;
    private static AdapterSet s_cimInstanceAdapter;
    private static AdapterSet s_managementObjectAdapter;
    private static AdapterSet s_managementClassAdapter;
    private static AdapterSet s_directoryEntryAdapter;
    private static AdapterSet s_dataRowViewAdapter;
    private static AdapterSet s_dataRowAdapter;
    private static AdapterSet s_xmlNodeAdapter;
    private static ConditionalWeakTable`2<object, PSMemberInfoInternalCollection`1<PSMemberInfo>> s_instanceMembersResurrectionTable;
    public static string AdaptedMemberSetName;
    public static string ExtendedMemberSetName;
    public static string BaseObjectMemberSetName;
    internal static string PSObjectMemberSetName;
    internal static string PSTypeNames;
    [CompilerGeneratedAttribute]
private string <TokenText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ToStringFromDeserialization>k__BackingField;
    [CompilerGeneratedAttribute]
private WriteStreamType <WriteStream>k__BackingField;
    [CompilerGeneratedAttribute]
private PSMemberInfoInternalCollection`1<PSPropertyInfo> <AdaptedMembers>k__BackingField;
    [CompilerGeneratedAttribute]
private PSMemberInfoInternalCollection`1<PSPropertyInfo> <ClrMembers>k__BackingField;
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> InstanceMembers { get; internal set; }
    internal Adapter InternalAdapter { get; }
    internal Adapter InternalBaseDotNetAdapter { get; }
    private AdapterSet InternalAdapterSet { get; }
    public PSMemberInfoCollection`1<PSMemberInfo> Members { get; }
    public PSMemberInfoCollection`1<PSPropertyInfo> Properties { get; }
    public PSMemberInfoCollection`1<PSMethodInfo> Methods { get; }
    public object ImmediateBaseObject { get; }
    public object BaseObject { get; }
    public Collection`1<string> TypeNames { get; }
    internal ConsolidatedString InternalTypeNames { get; internal set; }
    internal PSMemberSet PSStandardMembers { get; }
    internal bool IsDeserialized { get; internal set; }
    private bool StoreTypeNameAndInstanceMembersLocally { get; private set; }
    internal bool IsHelpObject { get; internal set; }
    internal bool HasGeneratedReservedMembers { get; internal set; }
    internal bool ImmediateBaseObjectIsEmpty { get; internal set; }
    internal string TokenText { get; internal set; }
    internal string ToStringFromDeserialization { get; internal set; }
    internal WriteStreamType WriteStream { get; internal set; }
    internal PSMemberInfoInternalCollection`1<PSPropertyInfo> AdaptedMembers { get; internal set; }
    internal static DotNetAdapter DotNetStaticAdapter { get; }
    internal static PSTraceSource MemberResolution { get; }
    internal PSMemberInfoInternalCollection`1<PSPropertyInfo> ClrMembers { get; internal set; }
    internal static DotNetAdapter DotNetInstanceAdapter { get; }
    public PSObject(int instanceMemberCapacity);
    public PSObject(object obj);
    protected PSObject(SerializationInfo info, StreamingContext context);
    private static PSObject();
    internal TypeTable GetTypeTable();
    internal static T TypeTableGetMemberDelegate(PSObject msjObj, string name);
    private static T TypeTableGetMemberDelegate(PSObject msjObj, TypeTable typeTableToUse, string name);
    internal static PSMemberInfoInternalCollection`1<T> TypeTableGetMembersDelegate(PSObject msjObj);
    internal static PSMemberInfoInternalCollection`1<T> TypeTableGetMembersDelegate(PSObject msjObj, TypeTable typeTableToUse);
    internal static T TypeTableGetFirstMemberOrDefaultDelegate(PSObject msjObj, MemberNamePredicate predicate);
    internal static T TypeTableGetFirstOrDefaultMemberDelegate(PSObject msjObj, TypeTable typeTableToUse, MemberNamePredicate predicate);
    private static T AdapterGetMemberDelegate(PSObject msjObj, string name);
    private static T AdapterGetFirstMemberOrDefaultDelegate(PSObject msjObj, MemberNamePredicate predicate);
    internal static PSMemberInfoInternalCollection`1<TResult> TransformMemberInfoCollection(PSMemberInfoCollection`1<TSource> source);
    private static PSMemberInfoInternalCollection`1<T> AdapterGetMembersDelegate(PSObject msjObj);
    private static PSMemberInfoInternalCollection`1<T> DotNetGetMembersDelegate(PSObject msjObj);
    private static T DotNetGetMemberDelegate(PSObject msjObj, string name);
    private static T DotNetGetFirstMemberOrDefaultDelegate(PSObject msjObj, MemberNamePredicate predicate);
    internal static Collection`1<CollectionEntry`1<PSMemberInfo>> GetMemberCollection(PSMemberViewTypes viewType);
    internal static Collection`1<CollectionEntry`1<PSMemberInfo>> GetMemberCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable);
    private static Collection`1<CollectionEntry`1<PSMethodInfo>> GetMethodCollection();
    internal static Collection`1<CollectionEntry`1<PSPropertyInfo>> GetPropertyCollection(PSMemberViewTypes viewType);
    internal static Collection`1<CollectionEntry`1<PSPropertyInfo>> GetPropertyCollection(PSMemberViewTypes viewType, TypeTable backupTypeTable);
    private void CommonInitialization(object obj);
    private static AdapterSet MappedInternalAdapterSet(object obj);
    internal static AdapterSet GetMappedAdapter(object obj, TypeTable typeTable);
    internal static AdapterSet CreateThirdPartyAdapterSet(Type adaptedType, PSPropertyAdapter adapter);
    internal static PSObject ConstructPSObjectFromSerializationInfo(SerializationInfo info, StreamingContext context);
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> get_InstanceMembers();
    internal void set_InstanceMembers(PSMemberInfoInternalCollection`1<PSMemberInfo> value);
    internal Adapter get_InternalAdapter();
    internal Adapter get_InternalBaseDotNetAdapter();
    private AdapterSet get_InternalAdapterSet();
    public PSMemberInfoCollection`1<PSMemberInfo> get_Members();
    public PSMemberInfoCollection`1<PSPropertyInfo> get_Properties();
    public PSMemberInfoCollection`1<PSMethodInfo> get_Methods();
    public object get_ImmediateBaseObject();
    public object get_BaseObject();
    public Collection`1<string> get_TypeNames();
    internal ConsolidatedString get_InternalTypeNames();
    internal void set_InternalTypeNames(ConsolidatedString value);
    internal static ConsolidatedString GetTypeNames(object obj);
    internal static bool HasInstanceTypeName(object obj, ConsolidatedString& result);
    internal static bool HasInstanceMembers(object obj, PSMemberInfoInternalCollection`1& instanceMembers);
    public static PSObject op_Implicit(int valueToConvert);
    public static PSObject op_Implicit(string valueToConvert);
    public static PSObject op_Implicit(Hashtable valueToConvert);
    public static PSObject op_Implicit(double valueToConvert);
    public static PSObject op_Implicit(bool valueToConvert);
    internal static object Base(object obj);
    internal static PSMemberInfo GetStaticCLRMember(object obj, string methodName);
    public static PSObject AsPSObject(object obj);
    internal static PSObject AsPSObject(object obj, bool storeTypeNameAndInstanceMembersLocally);
    internal static object GetKeyForResurrectionTables(object obj);
    private static string GetSeparator(ExecutionContext context, string separator);
    internal static string ToStringEnumerator(ExecutionContext context, IEnumerator enumerator, string separator, string format, IFormatProvider formatProvider);
    internal static string ToStringEnumerable(ExecutionContext context, IEnumerable enumerable, string separator, string format, IFormatProvider formatProvider);
    private static string ToStringEmptyBaseObject(ExecutionContext context, PSObject mshObj, string separator, string format, IFormatProvider formatProvider);
    internal static string ToStringParser(ExecutionContext context, object obj);
    internal static string ToStringParser(ExecutionContext context, object obj, IFormatProvider formatProvider);
    internal static string ToString(ExecutionContext context, object obj, string separator, string format, IFormatProvider formatProvider, bool recurse, bool unravelEnumeratorOnRecurse);
    public virtual string ToString();
    public sealed virtual string ToString(string format, IFormatProvider formatProvider);
    private string PrivateToString();
    public virtual PSObject Copy();
    internal static object CopyValueType(object obj);
    public sealed virtual int CompareTo(object obj);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal void AddOrSetProperty(string memberName, object value);
    internal void AddOrSetProperty(PSNoteProperty property);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    internal static object GetNoteSettingValue(PSMemberSet settings, string noteName, object defaultValue, Type expectedType, bool shouldReplicateInstance, PSObject ownerObject);
    internal int GetSerializationDepth(TypeTable backupTypeTable);
    internal PSPropertyInfo GetStringSerializationSource(TypeTable backupTypeTable);
    internal SerializationMethod GetSerializationMethod(TypeTable backupTypeTable);
    internal PSMemberSet get_PSStandardMembers();
    internal PSMemberInfo GetPSStandardMember(TypeTable backupTypeTable, string memberName);
    internal Type GetTargetTypeForDeserialization(TypeTable backupTypeTable);
    internal Collection`1<string> GetSpecificPropertiesToSerialize(TypeTable backupTypeTable);
    internal bool ShouldSerializeAdapter();
    internal PSMemberInfoInternalCollection`1<PSPropertyInfo> GetAdaptedProperties();
    private PSMemberInfoInternalCollection`1<PSPropertyInfo> GetProperties(PSMemberInfoInternalCollection`1<PSPropertyInfo> serializedMembers, Adapter particularAdapter);
    internal static void CopyDeserializerFields(PSObject source, PSObject target);
    internal void SetCoreOnDeserialization(object value, bool overrideTypeInfo);
    private sealed virtual override DynamicMetaObject System.Dynamic.IDynamicMetaObjectProvider.GetMetaObject(Expression parameter);
    internal bool get_IsDeserialized();
    internal void set_IsDeserialized(bool value);
    private bool get_StoreTypeNameAndInstanceMembersLocally();
    private void set_StoreTypeNameAndInstanceMembersLocally(bool value);
    internal bool get_IsHelpObject();
    internal void set_IsHelpObject(bool value);
    internal bool get_HasGeneratedReservedMembers();
    internal void set_HasGeneratedReservedMembers(bool value);
    internal bool get_ImmediateBaseObjectIsEmpty();
    internal void set_ImmediateBaseObjectIsEmpty(bool value);
    [CompilerGeneratedAttribute]
internal string get_TokenText();
    [CompilerGeneratedAttribute]
internal void set_TokenText(string value);
    [CompilerGeneratedAttribute]
internal string get_ToStringFromDeserialization();
    [CompilerGeneratedAttribute]
internal void set_ToStringFromDeserialization(string value);
    [CompilerGeneratedAttribute]
internal WriteStreamType get_WriteStream();
    [CompilerGeneratedAttribute]
internal void set_WriteStream(WriteStreamType value);
    [CompilerGeneratedAttribute]
internal PSMemberInfoInternalCollection`1<PSPropertyInfo> get_AdaptedMembers();
    [CompilerGeneratedAttribute]
internal void set_AdaptedMembers(PSMemberInfoInternalCollection`1<PSPropertyInfo> value);
    internal static DotNetAdapter get_DotNetStaticAdapter();
    internal static PSTraceSource get_MemberResolution();
    [CompilerGeneratedAttribute]
internal PSMemberInfoInternalCollection`1<PSPropertyInfo> get_ClrMembers();
    [CompilerGeneratedAttribute]
internal void set_ClrMembers(PSMemberInfoInternalCollection`1<PSPropertyInfo> value);
    internal static DotNetAdapter get_DotNetInstanceAdapter();
    internal PSPropertyInfo GetFirstPropertyOrDefault(MemberNamePredicate predicate);
    [CompilerGeneratedAttribute]
private ConsolidatedString <get_TypeNames>b__78_0(object _);
    [CompilerGeneratedAttribute]
internal static bool <ToString>g__TryFastTrackPrimitiveTypes|102_0(object value, String& str, <>c__DisplayClass102_0& );
}
internal class System.Management.Automation.PSObjectAdapter : MemberRedirectionAdapter {
    protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual T GetMember(object obj, string memberName);
    protected virtual T GetFirstMemberOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual PSMemberInfoInternalCollection`1<T> GetMembers(object obj);
}
public class System.Management.Automation.PSObjectDisposedException : ObjectDisposedException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    public ErrorRecord ErrorRecord { get; }
    public PSObjectDisposedException(string objectName);
    public PSObjectDisposedException(string objectName, string message);
    public PSObjectDisposedException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSObjectDisposedException(SerializationInfo info, StreamingContext context);
    public sealed virtual ErrorRecord get_ErrorRecord();
}
public class System.Management.Automation.PSObjectPropertyDescriptor : PropertyDescriptor {
    [CompilerGeneratedAttribute]
private EventHandler`1<SettingValueExceptionEventArgs> SettingValueException;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingValueExceptionEventArgs> GettingValueException;
    [CompilerGeneratedAttribute]
private AttributeCollection <Attributes>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsReadOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <PropertyType>k__BackingField;
    public AttributeCollection Attributes { get; }
    public bool IsReadOnly { get; }
    public Type ComponentType { get; }
    public Type PropertyType { get; }
    internal PSObjectPropertyDescriptor(string propertyName, Type propertyType, bool isReadOnly, AttributeCollection propertyAttributes);
    [CompilerGeneratedAttribute]
internal void add_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual AttributeCollection get_Attributes();
    [CompilerGeneratedAttribute]
public virtual bool get_IsReadOnly();
    public virtual void ResetValue(object component);
    public virtual bool CanResetValue(object component);
    public virtual bool ShouldSerializeValue(object component);
    public virtual Type get_ComponentType();
    [CompilerGeneratedAttribute]
public virtual Type get_PropertyType();
    public virtual object GetValue(object component);
    private static PSObject GetComponentPSObject(object component);
    private object DealWithGetValueException(ExtendedTypeSystemException e, Boolean& shouldThrow);
    public virtual void SetValue(object component, object value);
    private void DealWithSetValueException(ExtendedTypeSystemException e, Boolean& shouldThrow);
}
public class System.Management.Automation.PSObjectTypeDescriptionProvider : TypeDescriptionProvider {
    [CompilerGeneratedAttribute]
private EventHandler`1<SettingValueExceptionEventArgs> SettingValueException;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingValueExceptionEventArgs> GettingValueException;
    [CompilerGeneratedAttribute]
public void add_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    public virtual ICustomTypeDescriptor GetTypeDescriptor(Type objectType, object instance);
}
public class System.Management.Automation.PSObjectTypeDescriptor : CustomTypeDescriptor {
    internal static PSTraceSource typeDescriptor;
    [CompilerGeneratedAttribute]
private EventHandler`1<SettingValueExceptionEventArgs> SettingValueException;
    [CompilerGeneratedAttribute]
private EventHandler`1<GettingValueExceptionEventArgs> GettingValueException;
    [CompilerGeneratedAttribute]
private PSObject <Instance>k__BackingField;
    public PSObject Instance { get; }
    public PSObjectTypeDescriptor(PSObject instance);
    private static PSObjectTypeDescriptor();
    [CompilerGeneratedAttribute]
public void add_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_SettingValueException(EventHandler`1<SettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_GettingValueException(EventHandler`1<GettingValueExceptionEventArgs> value);
    [CompilerGeneratedAttribute]
public PSObject get_Instance();
    private void CheckAndAddProperty(PSPropertyInfo propertyInfo, Attribute[] attributes, PropertyDescriptorCollection& returnValue);
    public virtual PropertyDescriptorCollection GetProperties();
    public virtual PropertyDescriptorCollection GetProperties(Attribute[] attributes);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual PropertyDescriptor GetDefaultProperty();
    public virtual TypeConverter GetConverter();
    public virtual object GetPropertyOwner(PropertyDescriptor pd);
    public virtual EventDescriptor GetDefaultEvent();
    public virtual EventDescriptorCollection GetEvents();
    public virtual EventDescriptorCollection GetEvents(Attribute[] attributes);
    public virtual AttributeCollection GetAttributes();
    public virtual string GetClassName();
    public virtual string GetComponentName();
    public virtual object GetEditor(Type editorBaseType);
}
internal class System.Management.Automation.PSOutParameter`1 : object {
}
public class System.Management.Automation.PSParameterizedProperty : PSMethodInfo {
    internal Adapter adapter;
    internal object adapterData;
    internal object baseObject;
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public Collection`1<string> OverloadDefinitions { get; }
    public string TypeNameOfValue { get; }
    public PSMemberTypes MemberType { get; }
    internal PSParameterizedProperty(string name, Adapter adapter, object baseObject, object adapterData);
    internal PSParameterizedProperty(string name);
    public virtual string ToString();
    public bool get_IsSettable();
    public bool get_IsGettable();
    public virtual object Invoke(Object[] arguments);
    public void InvokeSet(object valueToSet, Object[] arguments);
    public virtual Collection`1<string> get_OverloadDefinitions();
    public virtual string get_TypeNameOfValue();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
}
public class System.Management.Automation.PSParseError : object {
    [CompilerGeneratedAttribute]
private PSToken <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public PSToken Token { get; }
    public string Message { get; }
    internal PSParseError(RuntimeException rte);
    internal PSParseError(ParseError error);
    [CompilerGeneratedAttribute]
public PSToken get_Token();
    [CompilerGeneratedAttribute]
public string get_Message();
}
public class System.Management.Automation.PSParser : object {
    private List`1<Token> _tokenList;
    private ParseError[] _errors;
    private Collection`1<PSToken> Tokens { get; }
    private Collection`1<PSParseError> Errors { get; }
    private void Parse(string script);
    private Collection`1<PSToken> get_Tokens();
    private Collection`1<PSParseError> get_Errors();
    public static Collection`1<PSToken> Tokenize(string script, Collection`1& errors);
    public static Collection`1<PSToken> Tokenize(Object[] script, Collection`1& errors);
}
internal class System.Management.Automation.PSPointer`1 : ValueType {
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.PSPrimitiveDictionary : Hashtable {
    private static Type[] s_handshakeFriendlyTypes;
    public object Item { get; public set; }
    public object Item { get; public set; }
    public PSPrimitiveDictionary(Hashtable other);
    private static PSPrimitiveDictionary();
    private static string VerifyKey(object key);
    private static void VerifyValue(object value);
    public virtual void Add(object key, object value);
    public virtual object get_Item(object key);
    public virtual void set_Item(object key, object value);
    public object get_Item(string key);
    public void set_Item(string key, object value);
    public virtual object Clone();
    public void Add(string key, bool value);
    public void Add(string key, Boolean[] value);
    public void Add(string key, byte value);
    public void Add(string key, Byte[] value);
    public void Add(string key, char value);
    public void Add(string key, Char[] value);
    public void Add(string key, DateTime value);
    public void Add(string key, DateTime[] value);
    public void Add(string key, decimal value);
    public void Add(string key, Decimal[] value);
    public void Add(string key, double value);
    public void Add(string key, Double[] value);
    public void Add(string key, Guid value);
    public void Add(string key, Guid[] value);
    public void Add(string key, int value);
    public void Add(string key, Int32[] value);
    public void Add(string key, long value);
    public void Add(string key, Int64[] value);
    public void Add(string key, sbyte value);
    public void Add(string key, SByte[] value);
    public void Add(string key, float value);
    public void Add(string key, Single[] value);
    public void Add(string key, string value);
    public void Add(string key, String[] value);
    public void Add(string key, TimeSpan value);
    public void Add(string key, TimeSpan[] value);
    public void Add(string key, ushort value);
    public void Add(string key, UInt16[] value);
    public void Add(string key, UInt32 value);
    public void Add(string key, UInt32[] value);
    public void Add(string key, ulong value);
    public void Add(string key, UInt64[] value);
    public void Add(string key, Uri value);
    public void Add(string key, Uri[] value);
    public void Add(string key, Version value);
    public void Add(string key, Version[] value);
    public void Add(string key, PSPrimitiveDictionary value);
    public void Add(string key, PSPrimitiveDictionary[] value);
    internal static PSPrimitiveDictionary CloneAndAddPSVersionTable(PSPrimitiveDictionary originalHash);
    internal static bool TryPathGet(IDictionary data, T& result, String[] keys);
}
public class System.Management.Automation.PSProperty : PSPropertyInfo {
    internal string typeOfValue;
    internal object serializedValue;
    internal bool isDeserialized;
    internal Adapter adapter;
    internal object adapterData;
    internal object baseObject;
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public string TypeNameOfValue { get; }
    internal PSProperty(string name, object serializedValue);
    internal PSProperty(string name, Adapter adapter, object baseObject, object adapterData);
    public virtual string ToString();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    private object GetAdaptedValue();
    internal void SetAdaptedValue(object setValue, bool shouldConvert);
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual string get_TypeNameOfValue();
}
public abstract class System.Management.Automation.PSPropertyAdapter : object {
    public virtual Collection`1<string> GetTypeNameHierarchy(object baseObject);
    public abstract virtual Collection`1<PSAdaptedProperty> GetProperties(object baseObject);
    public abstract virtual PSAdaptedProperty GetProperty(object baseObject, string propertyName);
    public abstract virtual bool IsSettable(PSAdaptedProperty adaptedProperty);
    public abstract virtual bool IsGettable(PSAdaptedProperty adaptedProperty);
    public abstract virtual object GetPropertyValue(PSAdaptedProperty adaptedProperty);
    public abstract virtual void SetPropertyValue(PSAdaptedProperty adaptedProperty, object value);
    public abstract virtual string GetPropertyTypeName(PSAdaptedProperty adaptedProperty);
    public virtual PSAdaptedProperty GetFirstPropertyOrDefault(object baseObject, MemberNamePredicate predicate);
}
public abstract class System.Management.Automation.PSPropertyInfo : PSMemberInfo {
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public abstract virtual bool get_IsSettable();
    public abstract virtual bool get_IsGettable();
    internal Exception NewSetValueException(Exception e, string errorId);
    internal Exception NewGetValueException(Exception e, string errorId);
}
public class System.Management.Automation.PSPropertySet : PSMemberInfo {
    [CompilerGeneratedAttribute]
private Collection`1<string> <ReferencedPropertyNames>k__BackingField;
    public Collection`1<string> ReferencedPropertyNames { get; }
    public PSMemberTypes MemberType { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public PSPropertySet(string name, IEnumerable`1<string> referencedPropertyNames);
    internal PSPropertySet(string name, List`1<string> referencedPropertyNameList);
    public virtual string ToString();
    [CompilerGeneratedAttribute]
public Collection`1<string> get_ReferencedPropertyNames();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSReference : object {
    private object _value;
    internal static CallSite`1<Func`4<CallSite, object, object, object>> CreatePsReferenceInstance;
    public object Value { get; public set; }
    public PSReference(object value);
    private static PSReference();
    public object get_Value();
    public void set_Value(object value);
    internal static PSReference CreateInstance(object value, Type typeOfValue);
}
internal class System.Management.Automation.PSReference`1 : PSReference {
    public PSReference`1(object value);
}
internal class System.Management.Automation.PSRemoteEventManager : PSEventManager {
    private string _computerName;
    private Guid _runspaceId;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> ForwardEvent;
    public List`1<PSEventSubscriber> Subscribers { get; }
    internal PSRemoteEventManager(string computerName, Guid runspaceId);
    public virtual List`1<PSEventSubscriber> get_Subscribers();
    protected virtual PSEventArgs CreateEvent(string sourceIdentifier, object sender, Object[] args, PSObject extraData);
    internal virtual void AddForwardedEvent(PSEventArgs forwardedEvent);
    protected virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread);
    protected internal virtual void ProcessNewEvent(PSEventArgs newEvent, bool processInCurrentThread, bool waitForCompletionInCurrentThread);
    public virtual IEnumerable`1<PSEventSubscriber> GetEventSubscribers(string sourceIdentifier);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, ScriptBlock action, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent);
    public virtual PSEventSubscriber SubscribeEvent(object source, string eventName, string sourceIdentifier, PSObject data, PSEventReceivedEventHandler handlerDelegate, bool supportEvent, bool forwardEvent, int maxTriggerCount);
    public virtual void UnsubscribeEvent(PSEventSubscriber subscriber);
    [CompilerGeneratedAttribute]
internal virtual void add_ForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_ForwardEvent(EventHandler`1<PSEventArgs> value);
    protected virtual void OnForwardEvent(PSEventArgs e);
}
internal class System.Management.Automation.PSRemotingChildJob : Job {
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    [CompilerGeneratedAttribute]
private ExecutionCmdletHelper <Helper>k__BackingField;
    private bool _hideComputerName;
    [CompilerGeneratedAttribute]
private bool <DisconnectedAndBlocked>k__BackingField;
    private bool _doFinishCalled;
    private ErrorRecord _failureErrorRecord;
    private bool _isDisposed;
    private bool _cleanupDone;
    [CompilerGeneratedAttribute]
private EventHandler JobUnblocked;
    private RemotePipeline _remotePipeline;
    protected object SyncObject;
    private ThrottleManager _throttleManager;
    private bool _stopIsCalled;
    private Debugger modreq(System.Runtime.CompilerServices.IsVolatile) _jobDebugger;
    private bool _isAsync;
    private RunspaceAvailability _prevRunspaceAvailability;
    public string StatusMessage { get; }
    public bool HasMoreData { get; }
    public string Location { get; }
    public Runspace Runspace { get; }
    internal ExecutionCmdletHelper Helper { get; }
    internal bool HideComputerName { get; internal set; }
    internal bool DisconnectedAndBlocked { get; private set; }
    internal bool CanDisconnect { get; }
    public Debugger Debugger { get; }
    public bool IsAsync { get; public set; }
    internal ErrorRecord FailureErrorRecord { get; }
    internal PSRemotingChildJob(string remoteCommand, ExecutionCmdletHelper helper, ThrottleManager throttleManager);
    internal PSRemotingChildJob(ExecutionCmdletHelper helper, ThrottleManager throttleManager, bool aggregateResults);
    internal void ConnectAsync();
    public virtual void StopJob();
    public virtual string get_StatusMessage();
    public virtual bool get_HasMoreData();
    public virtual string get_Location();
    [CompilerGeneratedAttribute]
public Runspace get_Runspace();
    [CompilerGeneratedAttribute]
internal ExecutionCmdletHelper get_Helper();
    internal bool get_HideComputerName();
    internal void set_HideComputerName(bool value);
    [CompilerGeneratedAttribute]
internal bool get_DisconnectedAndBlocked();
    [CompilerGeneratedAttribute]
private void set_DisconnectedAndBlocked(bool value);
    internal virtual bool get_CanDisconnect();
    public sealed virtual Debugger get_Debugger();
    public sealed virtual bool get_IsAsync();
    public sealed virtual void set_IsAsync(bool value);
    private void HandleOutputReady(object sender, EventArgs eventArgs);
    private void HandleErrorReady(object sender, EventArgs eventArgs);
    protected void HandleURIDirectionReported(object sender, RemoteDataEventArgs`1<Uri> eventArgs);
    private void HandleHostCalls(object sender, EventArgs eventArgs);
    protected virtual void HandlePipelineStateChanged(object sender, PipelineStateEventArgs e);
    private void HandleThrottleComplete(object sender, EventArgs eventArgs);
    protected virtual void HandleOperationComplete(object sender, OperationStateEventArgs stateEventArgs);
    protected virtual void DoFinish();
    internal ErrorRecord get_FailureErrorRecord();
    protected void ProcessJobFailure(ExecutionCmdletHelper helper, Exception& failureException, ErrorRecord& failureErrorRecord);
    protected virtual void Dispose(bool disposing);
    protected virtual void DoCleanupOnFinished();
    protected void AggregateResultsFromHelper(ExecutionCmdletHelper helper);
    private PowerShell GetPipelinePowerShell(RemotePipeline pipeline, Guid instanceId);
    private void HandleDebugAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleVerboseAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleWarningAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleProgressAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleInformationAdded(object sender, DataAddedEventArgs eventArgs);
    protected void StopAggregateResultsFromHelper(ExecutionCmdletHelper helper);
    protected void RemoveAggreateCallbacksFromHelper(ExecutionCmdletHelper helper);
    protected void RegisterThrottleComplete(ThrottleManager throttleManager);
    protected void UnregisterThrottleComplete(ThrottleManager throttleManager);
    protected void DeterminedAndSetJobState(ExecutionCmdletHelper helper);
    internal void UnblockJob();
    internal virtual PowerShell GetPowerShell(Guid instanceId);
    internal PowerShell GetPowerShell();
    private void HandleRunspaceAvailabilityChanged(object sender, RunspaceAvailabilityEventArgs e);
    [CompilerGeneratedAttribute]
internal void add_JobUnblocked(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_JobUnblocked(EventHandler value);
}
internal class System.Management.Automation.PSRemotingJob : Job {
    private bool _moreData;
    private bool _stopIsCalled;
    private string _statusMessage;
    private bool _hideComputerName;
    private bool _atleastOneChildJobFailed;
    private int _finishedChildJobsCount;
    private int _blockedChildJobsCount;
    private int _disconnectedChildJobsCount;
    private int _debugChildJobsCount;
    private bool _isDisposed;
    private ThrottleManager _throttleManager;
    private object _syncObject;
    public bool HasMoreData { get; }
    public string StatusMessage { get; }
    internal bool HideComputerName { get; internal set; }
    public string Location { get; }
    internal bool CanDisconnect { get; }
    internal PSRemotingJob(String[] computerNames, List`1<IThrottleOperation> computerNameHelpers, string remoteCommand, string name);
    internal PSRemotingJob(PSSession[] remoteRunspaceInfos, List`1<IThrottleOperation> runspaceHelpers, string remoteCommand, string name);
    internal PSRemotingJob(String[] computerNames, List`1<IThrottleOperation> computerNameHelpers, string remoteCommand, int throttleLimit, string name);
    internal PSRemotingJob(PSSession[] remoteRunspaceInfos, List`1<IThrottleOperation> runspaceHelpers, string remoteCommand, int throttleLimit, string name);
    internal PSRemotingJob(List`1<IThrottleOperation> helpers, int throttleLimit, string name, bool aggregateResults);
    private void CommonInit(int throttleLimit, List`1<IThrottleOperation> helpers);
    internal List`1<Job> GetJobsForComputer(string computerName);
    internal List`1<Job> GetJobsForRunspace(PSSession runspace);
    internal List`1<Job> GetJobsForOperation(IThrottleOperation operation);
    internal void ConnectJobs();
    internal void ConnectJob(Guid runspaceInstanceId);
    private static void SubmitAndWaitForConnect(List`1<IThrottleOperation> connectJobOperations);
    internal PowerShell GetAssociatedPowerShellObject(Guid runspaceInstanceId);
    private PSRemotingChildJob FindDisconnectedChildJob(Guid runspaceInstanceId);
    internal void InternalStopJob();
    public virtual bool get_HasMoreData();
    public virtual void StopJob();
    public virtual string get_StatusMessage();
    internal bool get_HideComputerName();
    internal void set_HideComputerName(bool value);
    private void SetStatusMessage();
    private void HandleChildJobStateChanged(object sender, JobStateEventArgs e);
    private void CheckDisconnectedAndUpdateState(JobState newState, JobState prevState);
    protected virtual void Dispose(bool disposing);
    private string ConstructLocation();
    public virtual string get_Location();
    internal virtual bool get_CanDisconnect();
    internal virtual IEnumerable`1<RemoteRunspace> GetRunspaces();
    private void HandleJobUnblocked(object sender, EventArgs eventArgs);
}
internal class System.Management.Automation.PSScriptCmdlet : PSCmdlet {
    private ArrayList _input;
    private ScriptBlock _scriptBlock;
    private bool _fromScriptFile;
    private bool _useLocalScope;
    private bool _runOptimized;
    private bool _rethrowExitException;
    private MutableTuple _localsTuple;
    private FunctionContext _functionContext;
    private MshCommandRuntime _commandRuntime;
    private bool _exitWasCalled;
    private bool _anyClauseExecuted;
    [CompilerGeneratedAttribute]
private EventHandler StoppingEvent;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private EventHandler DisposingEvent;
    public PSScriptCmdlet(ScriptBlock scriptBlock, bool useNewScope, bool fromScriptFile, ExecutionContext context);
    protected virtual void BeginProcessing();
    internal virtual void DoProcessRecord();
    internal virtual void DoEndProcessing();
    internal virtual void DoCleanResource();
    private void EnterScope();
    private void ExitScope();
    private void RunClause(Action`1<FunctionContext> clause, object dollarUnderbar, object inputToProcess);
    public sealed virtual object GetDynamicParameters();
    internal void SetLocalsTupleForNewScope(SessionStateScope scope);
    internal void PushDottedScope(SessionStateScope scope);
    internal void PopDottedScope(SessionStateScope scope);
    internal void PrepareForBinding(CommandLineParameters commandLineParameters);
    private void SetPreferenceVariables();
    [CompilerGeneratedAttribute]
internal void add_StoppingEvent(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_StoppingEvent(EventHandler value);
    protected virtual void StopProcessing();
    [CompilerGeneratedAttribute]
internal void add_DisposingEvent(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_DisposingEvent(EventHandler value);
    public sealed virtual void Dispose();
}
public class System.Management.Automation.PSScriptMethod : PSMethodInfo {
    private ScriptBlock _script;
    private bool _shouldCloneOnAccess;
    public ScriptBlock Script { get; }
    public Collection`1<string> OverloadDefinitions { get; }
    public PSMemberTypes MemberType { get; }
    public string TypeNameOfValue { get; }
    public PSScriptMethod(string name, ScriptBlock script);
    internal PSScriptMethod(string name, ScriptBlock script, bool shouldCloneOnAccess);
    public virtual string ToString();
    public ScriptBlock get_Script();
    public virtual object Invoke(Object[] arguments);
    internal static object InvokeScript(string methodName, ScriptBlock script, object this, Object[] arguments);
    public virtual Collection`1<string> get_OverloadDefinitions();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSScriptProperty : PSPropertyInfo {
    private Nullable`1<PSLanguageMode> _languageMode;
    private string _getterScriptText;
    private ScriptBlock _getterScript;
    private string _setterScriptText;
    private ScriptBlock _setterScript;
    private bool _shouldCloneOnAccess;
    public ScriptBlock GetterScript { get; }
    public ScriptBlock SetterScript { get; }
    public PSMemberTypes MemberType { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public PSScriptProperty(string name, ScriptBlock getterScript);
    public PSScriptProperty(string name, ScriptBlock getterScript, ScriptBlock setterScript);
    internal PSScriptProperty(string name, string getterScript, string setterScript, Nullable`1<PSLanguageMode> languageMode);
    internal PSScriptProperty(string name, ScriptBlock getterScript, ScriptBlock setterScript, bool shouldCloneOnAccess);
    internal PSScriptProperty(string name, string getterScript, string setterScript, Nullable`1<PSLanguageMode> languageMode, bool shouldCloneOnAccess);
    public virtual string ToString();
    public ScriptBlock get_GetterScript();
    public ScriptBlock get_SetterScript();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    internal object InvokeSetter(object scriptThis, object value);
    internal object InvokeGetter(object scriptThis);
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSSecurityException : RuntimeException {
    private ErrorRecord _errorRecord;
    private string _message;
    public ErrorRecord ErrorRecord { get; }
    public string Message { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSSecurityException(SerializationInfo info, StreamingContext context);
    public PSSecurityException(string message);
    public PSSecurityException(string message, Exception innerException);
    public virtual ErrorRecord get_ErrorRecord();
    public virtual string get_Message();
}
public static class System.Management.Automation.PSSerializer : object {
    private static int s_mshDefaultSerializationDepth;
    private static PSSerializer();
    public static string Serialize(object source);
    public static string Serialize(object source, int depth);
    public static object Deserialize(string source);
    public static Object[] DeserializeAsList(string source);
}
public abstract class System.Management.Automation.PSSessionTypeOption : object {
    protected internal virtual string ConstructPrivateData();
    protected internal virtual PSSessionTypeOption ConstructObjectFromPrivateData(string privateData);
    protected internal virtual void CopyUpdatedValuesFrom(PSSessionTypeOption updated);
}
public class System.Management.Automation.PSSnapInInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefault>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApplicationBase>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <Types>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<string> <Formats>k__BackingField;
    private string _descriptionIndirect;
    private string _descriptionFallback;
    private string _description;
    private string _vendorIndirect;
    private string _vendorFallback;
    private string _vendor;
    [CompilerGeneratedAttribute]
private bool <LogPipelineExecutionDetails>k__BackingField;
    public string Name { get; }
    public bool IsDefault { get; }
    public string ApplicationBase { get; }
    public string AssemblyName { get; }
    public string ModuleName { get; }
    internal string AbsoluteModulePath { get; }
    public Version PSVersion { get; }
    public Version Version { get; }
    public Collection`1<string> Types { get; }
    public Collection`1<string> Formats { get; }
    public string Description { get; }
    public string Vendor { get; }
    public bool LogPipelineExecutionDetails { get; public set; }
    internal RegistryKey MshSnapinKey { get; }
    internal PSSnapInInfo(string name, bool isDefault, string applicationBase, string assemblyName, string moduleName, Version psVersion, Version version, Collection`1<string> types, Collection`1<string> formats, string descriptionFallback, string vendorFallback);
    internal PSSnapInInfo(string name, bool isDefault, string applicationBase, string assemblyName, string moduleName, Version psVersion, Version version, Collection`1<string> types, Collection`1<string> formats, string description, string descriptionFallback, string vendor, string vendorFallback);
    internal PSSnapInInfo(string name, bool isDefault, string applicationBase, string assemblyName, string moduleName, Version psVersion, Version version, Collection`1<string> types, Collection`1<string> formats, string description, string descriptionFallback, string descriptionIndirect, string vendor, string vendorFallback, string vendorIndirect);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public bool get_IsDefault();
    [CompilerGeneratedAttribute]
public string get_ApplicationBase();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_ModuleName();
    internal string get_AbsoluteModulePath();
    [CompilerGeneratedAttribute]
public Version get_PSVersion();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public Collection`1<string> get_Types();
    [CompilerGeneratedAttribute]
public Collection`1<string> get_Formats();
    public string get_Description();
    public string get_Vendor();
    [CompilerGeneratedAttribute]
public bool get_LogPipelineExecutionDetails();
    [CompilerGeneratedAttribute]
public void set_LogPipelineExecutionDetails(bool value);
    public virtual string ToString();
    internal RegistryKey get_MshSnapinKey();
    internal void LoadIndirectResources();
    internal void LoadIndirectResources(RegistryStringResourceIndirect resourceReader);
    internal PSSnapInInfo Clone();
    internal static bool IsPSSnapinIdValid(string psSnapinId);
    internal static void VerifyPSSnapInFormatThrowIfError(string psSnapinId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.PSSnapinQualifiedName : object {
    private string _fullName;
    [NullableAttribute("2")]
private string _psSnapinName;
    private string _shortName;
    internal string FullName { get; }
    [NullableAttribute("2")]
internal string PSSnapInName { get; }
    internal string ShortName { get; }
    private PSSnapinQualifiedName(String[] splitName);
    [NullableContextAttribute("2")]
internal static PSSnapinQualifiedName GetInstance(string name);
    internal string get_FullName();
    [NullableContextAttribute("2")]
internal string get_PSSnapInName();
    internal string get_ShortName();
    public virtual string ToString();
}
internal static class System.Management.Automation.PSSnapInReader : object {
    private static DefaultPSSnapInInformation s_coreSnapin;
    private static IList`1<DefaultPSSnapInInformation> s_defaultMshSnapins;
    private static object s_syncObject;
    private static PSTraceSource s_mshsnapinTracer;
    private static IList`1<DefaultPSSnapInInformation> DefaultMshSnapins { get; }
    private static PSSnapInReader();
    internal static Collection`1<PSSnapInInfo> ReadAll();
    private static bool MeetsVersionFormat(string version);
    internal static Collection`1<PSSnapInInfo> ReadAll(string psVersion);
    private static Collection`1<PSSnapInInfo> ReadAll(RegistryKey monadRootKey, string psVersion);
    internal static PSSnapInInfo Read(string psVersion, string mshsnapinId);
    private static PSSnapInInfo ReadOne(RegistryKey mshSnapInRoot, string mshsnapinId);
    private static Collection`1<string> ReadMultiStringValue(RegistryKey mshsnapinKey, string name, bool mandatory);
    internal static string ReadStringValue(RegistryKey mshsnapinKey, string name, bool mandatory);
    internal static Version ReadVersionValue(RegistryKey mshsnapinKey, string name, bool mandatory);
    internal static void ReadRegistryInfo(Version& assemblyVersion, String& publicKeyToken, String& culture, String& applicationBase, Version& psVersion);
    internal static string ConvertByteArrayToString(Byte[] tokens);
    internal static PSSnapInInfo ReadCoreEngineSnapIn();
    internal static Collection`1<PSSnapInInfo> ReadEnginePSSnapIns();
    private static void SetSnapInLoggingInformation(PSSnapInInfo psSnapInInfo);
    private static void SetSnapInLoggingInformation(PSSnapInInfo psSnapInInfo, ModuleLoggingGroupPolicyStatus status, IEnumerable`1<string> moduleOrSnapinNames);
    internal static RegistryKey GetMonadRootKey();
    internal static RegistryKey GetPSEngineKey(string psVersion);
    internal static RegistryKey GetVersionRootKey(RegistryKey rootKey, string psVersion);
    private static RegistryKey GetMshSnapinRootKey(RegistryKey versionRootKey, string psVersion);
    internal static RegistryKey GetMshSnapinKey(string mshSnapInName, string psVersion);
    private static IList`1<DefaultPSSnapInInformation> get_DefaultMshSnapins();
}
public class System.Management.Automation.PSSnapInSpecification : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Name { get; internal set; }
    public Version Version { get; internal set; }
    internal PSSnapInSpecification(string psSnapinName);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
internal void set_Version(Version value);
}
public class System.Management.Automation.PSStyle : object {
    [CompilerGeneratedAttribute]
private OutputRendering <OutputRendering>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BlinkOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Blink>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BoldOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Bold>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DimOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Dim>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hidden>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HiddenOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Reverse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReverseOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItalicOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Italic>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UnderlineOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Underline>k__BackingField;
    [CompilerGeneratedAttribute]
private string <StrikethroughOff>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Strikethrough>k__BackingField;
    [CompilerGeneratedAttribute]
private FormattingData <Formatting>k__BackingField;
    [CompilerGeneratedAttribute]
private ProgressConfiguration <Progress>k__BackingField;
    [CompilerGeneratedAttribute]
private ForegroundColor <Foreground>k__BackingField;
    [CompilerGeneratedAttribute]
private BackgroundColor <Background>k__BackingField;
    [CompilerGeneratedAttribute]
private FileInfoFormatting <FileInfo>k__BackingField;
    private static PSStyle s_psstyle;
    private static String[] BackgroundColorMap;
    private static String[] ForegroundColorMap;
    public OutputRendering OutputRendering { get; public set; }
    public string Reset { get; }
    public string BlinkOff { get; }
    public string Blink { get; }
    public string BoldOff { get; }
    public string Bold { get; }
    public string DimOff { get; }
    public string Dim { get; }
    public string Hidden { get; }
    public string HiddenOff { get; }
    public string Reverse { get; }
    public string ReverseOff { get; }
    public string ItalicOff { get; }
    public string Italic { get; }
    public string UnderlineOff { get; }
    public string Underline { get; }
    public string StrikethroughOff { get; }
    public string Strikethrough { get; }
    public FormattingData Formatting { get; }
    public ProgressConfiguration Progress { get; }
    public ForegroundColor Foreground { get; }
    public BackgroundColor Background { get; }
    public FileInfoFormatting FileInfo { get; }
    public static PSStyle Instance { get; }
    private static PSStyle();
    [CompilerGeneratedAttribute]
public OutputRendering get_OutputRendering();
    [CompilerGeneratedAttribute]
public void set_OutputRendering(OutputRendering value);
    [CompilerGeneratedAttribute]
public string get_Reset();
    [CompilerGeneratedAttribute]
public string get_BlinkOff();
    [CompilerGeneratedAttribute]
public string get_Blink();
    [CompilerGeneratedAttribute]
public string get_BoldOff();
    [CompilerGeneratedAttribute]
public string get_Bold();
    [CompilerGeneratedAttribute]
public string get_DimOff();
    [CompilerGeneratedAttribute]
public string get_Dim();
    [CompilerGeneratedAttribute]
public string get_Hidden();
    [CompilerGeneratedAttribute]
public string get_HiddenOff();
    [CompilerGeneratedAttribute]
public string get_Reverse();
    [CompilerGeneratedAttribute]
public string get_ReverseOff();
    [CompilerGeneratedAttribute]
public string get_ItalicOff();
    [CompilerGeneratedAttribute]
public string get_Italic();
    [CompilerGeneratedAttribute]
public string get_UnderlineOff();
    [CompilerGeneratedAttribute]
public string get_Underline();
    [CompilerGeneratedAttribute]
public string get_StrikethroughOff();
    [CompilerGeneratedAttribute]
public string get_Strikethrough();
    public string FormatHyperlink(string text, Uri link);
    [CompilerGeneratedAttribute]
public FormattingData get_Formatting();
    [CompilerGeneratedAttribute]
public ProgressConfiguration get_Progress();
    [CompilerGeneratedAttribute]
public ForegroundColor get_Foreground();
    [CompilerGeneratedAttribute]
public BackgroundColor get_Background();
    [CompilerGeneratedAttribute]
public FileInfoFormatting get_FileInfo();
    private static string ValidateNoContent(string text);
    public static PSStyle get_Instance();
    internal static string MapColorToEscapeSequence(ConsoleColor color, bool isBackground);
    public static string MapForegroundColorToEscapeSequence(ConsoleColor foregroundColor);
    public static string MapBackgroundColorToEscapeSequence(ConsoleColor backgroundColor);
    public static string MapColorPairToEscapeSequence(ConsoleColor foregroundColor, ConsoleColor backgroundColor);
}
internal class System.Management.Automation.PSSyntheticTypeName : PSTypeName {
    [CompilerGeneratedAttribute]
private IList`1<PSMemberNameAndType> <Members>k__BackingField;
    public IList`1<PSMemberNameAndType> Members { get; }
    private PSSyntheticTypeName(string typeName, Type type, IList`1<PSMemberNameAndType> membersTypes);
    internal static PSSyntheticTypeName Create(string typename, IList`1<PSMemberNameAndType> membersTypes);
    internal static PSSyntheticTypeName Create(Type type, IList`1<PSMemberNameAndType> membersTypes);
    internal static PSSyntheticTypeName Create(PSTypeName typename, IList`1<PSMemberNameAndType> membersTypes);
    private static bool IsPSTypeName(PSMemberNameAndType& member);
    private static string GetMemberTypeProjection(string typename, IList`1<PSMemberNameAndType> members);
    [CompilerGeneratedAttribute]
public IList`1<PSMemberNameAndType> get_Members();
}
internal class System.Management.Automation.PSTasks.PSJobTask : PSTaskBase {
    private Job _job;
    public Debugger Debugger { get; }
    public PSJobTask(ScriptBlock scriptBlock, Dictionary`2<string, object> usingValuesMap, object dollarUnderbar, string currentLocationPath, Job job);
    protected virtual void InitializePowershell();
    private void HandleJobOutputData();
    private void HandleJobErrorData();
    private void HandleJobWarningData();
    private void HandleJobVerboseData();
    private void HandleJobDebugData();
    private void HandleJobInformationData();
    private void HandleStateChanged(PSInvocationStateChangedEventArgs stateChangeInfo);
    public Debugger get_Debugger();
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_0(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_1(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_2(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_3(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_4(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_5(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_6(object sender, PSInvocationStateChangedEventArgs args);
}
internal class System.Management.Automation.PSTasks.PSTask : PSTaskBase {
    private PSTaskDataStreamWriter _dataStreamWriter;
    public PSTask(ScriptBlock scriptBlock, Dictionary`2<string, object> usingValuesMap, object dollarUnderbar, string currentLocationPath, PSTaskDataStreamWriter dataStreamWriter);
    protected virtual void InitializePowershell();
    private void HandleOutputData();
    private void HandleErrorData();
    private void HandleWarningData();
    private void HandleVerboseData();
    private void HandleDebugData();
    private void HandleInformationData();
    private void HandleProgressData();
    private void HandleStateChanged(PSInvocationStateChangedEventArgs stateChangeInfo);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_0(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_1(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_2(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_3(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_4(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_5(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_6(object sender, DataAddedEventArgs args);
    [CompilerGeneratedAttribute]
private void <InitializePowershell>b__2_7(object sender, PSInvocationStateChangedEventArgs args);
}
internal abstract class System.Management.Automation.PSTasks.PSTaskBase : object {
    private ScriptBlock _scriptBlockToRun;
    private Dictionary`2<string, object> _usingValuesMap;
    private object _dollarUnderbar;
    private int _id;
    private string _currentLocationPath;
    private Runspace _runspace;
    protected PowerShell _powershell;
    protected PSDataCollection`1<PSObject> _output;
    public static string RunspaceName;
    private static int s_taskId;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSInvocationStateChangedEventArgs> StateChanged;
    public PSInvocationState State { get; }
    public int Id { get; }
    public Runspace Runspace { get; }
    protected PSTaskBase(ScriptBlock scriptBlock, Dictionary`2<string, object> usingValuesMap, object dollarUnderbar, string currentLocationPath);
    [CompilerGeneratedAttribute]
public void add_StateChanged(EventHandler`1<PSInvocationStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(EventHandler`1<PSInvocationStateChangedEventArgs> value);
    internal void RaiseStateChangedEvent(PSInvocationStateChangedEventArgs args);
    public PSInvocationState get_State();
    public int get_Id();
    public Runspace get_Runspace();
    protected abstract virtual void InitializePowershell();
    public sealed virtual void Dispose();
    public void Start(Runspace runspace);
    public void SignalStop();
}
internal class System.Management.Automation.PSTasks.PSTaskChildDebugger : Debugger {
    private Debugger _wrappedDebugger;
    private string _jobName;
    public bool InBreakpoint { get; }
    public PSTaskChildDebugger(Debugger debugger, string jobName);
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void StopProcessCommand();
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual void SetParent(Debugger parent, IEnumerable`1<Breakpoint> breakPoints, Nullable`1<DebuggerResumeAction> startAction, PSHost host, PathInfo path);
    public virtual void SetDebugMode(DebugModes mode);
    public virtual IEnumerable`1<CallStackFrame> GetCallStack();
    public virtual void SetDebuggerStepMode(bool enabled);
    public virtual bool get_InBreakpoint();
    private void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    private void HandleBreakpointUpdated(object sender, BreakpointUpdatedEventArgs e);
    private DebuggerCommandResults HandlePromptCommand(PSDataCollection`1<PSObject> output);
}
internal class System.Management.Automation.PSTasks.PSTaskChildJob : Job {
    private PSJobTask _task;
    private PSTaskChildDebugger _jobDebuggerWrapper;
    [CompilerGeneratedAttribute]
private bool <IsAsync>k__BackingField;
    internal PSTaskBase Task { get; }
    public string Location { get; }
    public bool HasMoreData { get; }
    public string StatusMessage { get; }
    public Debugger Debugger { get; }
    public bool IsAsync { get; public set; }
    public PSTaskChildJob(ScriptBlock scriptBlock, Dictionary`2<string, object> usingValuesMap, object dollarUnderbar, string currentLocationPath);
    internal PSTaskBase get_Task();
    public virtual string get_Location();
    public virtual bool get_HasMoreData();
    public virtual string get_StatusMessage();
    public virtual void StopJob();
    public sealed virtual Debugger get_Debugger();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAsync();
    [CompilerGeneratedAttribute]
public sealed virtual void set_IsAsync(bool value);
    private void HandleTaskStateChange(object sender, PSInvocationStateChangedEventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__3_0(object sender, PSInvocationStateChangedEventArgs args);
}
internal class System.Management.Automation.PSTasks.PSTaskDataStreamWriter : object {
    private PSCmdlet _cmdlet;
    private PSDataCollection`1<PSStreamObject> _dataStream;
    private int _cmdletThreadId;
    internal WaitHandle DataAddedWaitHandle { get; }
    public PSTaskDataStreamWriter(PSCmdlet psCmdlet);
    internal WaitHandle get_DataAddedWaitHandle();
    public void Add(PSStreamObject streamObject);
    public void WriteImmediate();
    public void WaitAndWrite();
    public void Close();
    private void CheckCmdletThread();
    public sealed virtual void Dispose();
}
public class System.Management.Automation.PSTasks.PSTaskJob : Job {
    private PSTaskPool _taskPool;
    private bool _isOpen;
    private bool _stopSignaled;
    public int AllocatedRunspaceCount { get; }
    public string Location { get; }
    public bool HasMoreData { get; }
    public string StatusMessage { get; }
    internal PSTaskJob(string command, int throttleLimit, bool useNewRunspace);
    public int get_AllocatedRunspaceCount();
    public virtual string get_Location();
    public virtual bool get_HasMoreData();
    public virtual string get_StatusMessage();
    public virtual void StopJob();
    protected virtual void Dispose(bool disposing);
    internal bool AddJob(PSTaskChildJob childJob);
    internal void Start();
    private void HandleTaskPoolComplete(object sender, EventArgs args);
    [CompilerGeneratedAttribute]
private void <.ctor>b__6_0(object sender, EventArgs args);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <Start>b__16_0(object _);
}
internal class System.Management.Automation.PSTasks.PSTaskPool : object {
    private ManualResetEvent _addAvailable;
    private int _sizeLimit;
    private ManualResetEvent _stopAll;
    private object _syncObject;
    private Dictionary`2<int, PSTaskBase> _taskPool;
    private ConcurrentQueue`1<Runspace> _runspacePool;
    private ConcurrentDictionary`2<int, Runspace> _activeRunspaces;
    private WaitHandle[] _waitHandles;
    private bool _useRunspacePool;
    private bool _isOpen;
    private bool _stopping;
    private int _createdRunspaceCount;
    private static int AddAvailable;
    private static int Stop;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> PoolComplete;
    public bool IsOpen { get; }
    public int AllocatedRunspaceCount { get; }
    public PSTaskPool(int size, bool useNewRunspace);
    [CompilerGeneratedAttribute]
public void add_PoolComplete(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PoolComplete(EventHandler`1<EventArgs> value);
    public bool get_IsOpen();
    public int get_AllocatedRunspaceCount();
    public sealed virtual void Dispose();
    internal void DisposeRunspaces();
    public bool Add(PSTaskBase task);
    public bool Add(PSTaskChildJob childJob);
    public void StopAll();
    public void Close();
    private void HandleTaskStateChangedDelegate(object sender, PSInvocationStateChangedEventArgs args);
    private void HandleTaskStateChanged(object sender, PSInvocationStateChangedEventArgs args);
    private void CheckForComplete();
    private Runspace GetRunspace(int taskId);
    private void ReturnRunspace(PSTaskBase task);
    private void RemoveActiveRunspace(Runspace runspace);
}
public class System.Management.Automation.PSToken : object {
    private string _content;
    [CompilerGeneratedAttribute]
private PSTokenType <Type>k__BackingField;
    private static PSTokenType[] s_tokenKindMapping;
    private IScriptExtent _extent;
    public string Content { get; }
    public PSTokenType Type { get; }
    public int Start { get; }
    public int Length { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    internal PSToken(Token token);
    internal PSToken(IScriptExtent extent);
    private static PSToken();
    public string get_Content();
    public static PSTokenType GetPSTokenType(Token token);
    [CompilerGeneratedAttribute]
public PSTokenType get_Type();
    public int get_Start();
    public int get_Length();
    public int get_StartLine();
    public int get_StartColumn();
    public int get_EndLine();
    public int get_EndColumn();
}
public enum System.Management.Automation.PSTokenType : Enum {
    public int value__;
    public static PSTokenType Unknown;
    public static PSTokenType Command;
    public static PSTokenType CommandParameter;
    public static PSTokenType CommandArgument;
    public static PSTokenType Number;
    public static PSTokenType String;
    public static PSTokenType Variable;
    public static PSTokenType Member;
    public static PSTokenType LoopLabel;
    public static PSTokenType Attribute;
    public static PSTokenType Type;
    public static PSTokenType Operator;
    public static PSTokenType GroupStart;
    public static PSTokenType GroupEnd;
    public static PSTokenType Keyword;
    public static PSTokenType Comment;
    public static PSTokenType StatementSeparator;
    public static PSTokenType NewLine;
    public static PSTokenType LineContinuation;
    public static PSTokenType Position;
}
public class System.Management.Automation.PSTraceSource : object {
    private static object s_getTracerLock;
    private static bool globalTraceInitialized;
    private static string errorFormatter;
    private static string warningFormatter;
    private static string verboseFormatter;
    private static string writeLineFormatter;
    private static string constructorOutputFormatter;
    private static string constructorLeavingFormatter;
    private static string disposeOutputFormatter;
    private static string disposeLeavingFormatter;
    private static string methodOutputFormatter;
    private static string methodLeavingFormatter;
    private static string propertyOutputFormatter;
    private static string propertyLeavingFormatter;
    private static string delegateHandlerOutputFormatter;
    private static string delegateHandlerLeavingFormatter;
    private static string eventHandlerOutputFormatter;
    private static string eventHandlerLeavingFormatter;
    private static string exceptionOutputFormatter;
    private static string innermostExceptionOutputFormatter;
    private static string lockEnterFormatter;
    private static string lockLeavingFormatter;
    private static string lockAcquiringFormatter;
    private bool _alreadyTracing;
    private static ThreadLocal`1<int> s_localIndentLevel;
    private PSTraceSourceOptions _flags;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    private string _name;
    private TraceSource _traceSource;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, PSTraceSource> <TraceCatalog>k__BackingField;
    [CompilerGeneratedAttribute]
private static Dictionary`2<string, PSTraceSource> <PreConfiguredTraceSource>k__BackingField;
    internal static int ThreadIndentLevel { get; internal set; }
    public string Description { get; public set; }
    internal bool ShowHeaders { get; internal set; }
    internal string FullName { get; }
    internal TraceSource TraceSource { get; }
    public PSTraceSourceOptions Options { get; public set; }
    internal bool IsEnabled { get; }
    public StringDictionary Attributes { get; }
    public TraceListenerCollection Listeners { get; }
    public string Name { get; }
    public SourceSwitch Switch { get; public set; }
    internal static Dictionary`2<string, PSTraceSource> TraceCatalog { get; }
    internal static Dictionary`2<string, PSTraceSource> PreConfiguredTraceSource { get; }
    internal PSTraceSource(string fullName, string name, string description, bool traceHeaders);
    private static PSTraceSource();
    internal static PSTraceSource GetTracer(string name, string description);
    internal static PSTraceSource GetTracer(string name, string description, bool traceHeaders);
    internal static PSTraceSource GetNewTraceSource(string name, string description, bool traceHeaders);
    internal static PSArgumentNullException NewArgumentNullException(string paramName);
    internal static PSArgumentNullException NewArgumentNullException(string paramName, string resourceString, Object[] args);
    internal static PSArgumentException NewArgumentException(string paramName);
    internal static PSArgumentException NewArgumentException(string paramName, string resourceString, Object[] args);
    internal static PSInvalidOperationException NewInvalidOperationException();
    internal static PSInvalidOperationException NewInvalidOperationException(string resourceString, Object[] args);
    internal static PSInvalidOperationException NewInvalidOperationException(Exception innerException, string resourceString, Object[] args);
    internal static PSNotSupportedException NewNotSupportedException();
    internal static PSNotSupportedException NewNotSupportedException(string resourceString, Object[] args);
    internal static PSNotImplementedException NewNotImplementedException();
    internal static PSArgumentOutOfRangeException NewArgumentOutOfRangeException(string paramName, object actualValue);
    internal static PSArgumentOutOfRangeException NewArgumentOutOfRangeException(string paramName, object actualValue, string resourceString, Object[] args);
    internal static PSObjectDisposedException NewObjectDisposedException(string objectName);
    internal void TraceGlobalAppDomainHeader();
    internal void TracerObjectHeader(Assembly callingAssembly);
    internal IDisposable TraceScope(string msg);
    internal IDisposable TraceScope(string format, object arg1);
    internal IDisposable TraceScope(string format, object arg1, object arg2);
    internal IDisposable TraceMethod(string format, Object[] args);
    internal IDisposable TraceEventHandlers();
    internal IDisposable TraceEventHandlers(string format, Object[] args);
    internal IDisposable TraceLock(string lockName);
    internal void TraceLockAcquiring(string lockName);
    internal void TraceLockAcquired(string lockName);
    internal void TraceLockReleased(string lockName);
    private void TraceLockHelper(string formatter, string lockName);
    internal void TraceError(string errorMessageFormat, Object[] args);
    internal void TraceWarning(string warningMessageFormat, Object[] args);
    internal void TraceVerbose(string verboseMessageFormat, Object[] args);
    internal void WriteLine(string format);
    internal void WriteLine(string format, object arg1);
    internal void WriteLine(string format, bool arg1);
    internal void WriteLine(string format, byte arg1);
    internal void WriteLine(string format, char arg1);
    internal void WriteLine(string format, decimal arg1);
    internal void WriteLine(string format, double arg1);
    internal void WriteLine(string format, float arg1);
    internal void WriteLine(string format, int arg1);
    internal void WriteLine(string format, long arg1);
    internal void WriteLine(string format, UInt32 arg1);
    internal void WriteLine(string format, ulong arg1);
    internal void WriteLine(string format, object arg1, object arg2);
    internal void WriteLine(string format, object arg1, object arg2, object arg3);
    internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4);
    internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4, object arg5);
    internal void WriteLine(string format, object arg1, object arg2, object arg3, object arg4, object arg5, object arg6);
    internal void WriteLine(object arg);
    private void FormatOutputLine(PSTraceSourceOptions flag, string classFormatter, string format, Object[] args);
    private static string GetCallingMethodNameAndParameters(int skipFrames);
    private static StringBuilder GetLinePrefix(PSTraceSourceOptions flag);
    private static void AddTab(StringBuilder lineBuilder);
    internal void OutputLine(PSTraceSourceOptions flag, string format, string arg);
    internal static int get_ThreadIndentLevel();
    internal static void set_ThreadIndentLevel(int value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
internal bool get_ShowHeaders();
    [CompilerGeneratedAttribute]
internal void set_ShowHeaders(bool value);
    [CompilerGeneratedAttribute]
internal string get_FullName();
    internal TraceSource get_TraceSource();
    public PSTraceSourceOptions get_Options();
    public void set_Options(PSTraceSourceOptions value);
    internal bool get_IsEnabled();
    public StringDictionary get_Attributes();
    public TraceListenerCollection get_Listeners();
    public string get_Name();
    public SourceSwitch get_Switch();
    public void set_Switch(SourceSwitch value);
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, PSTraceSource> get_TraceCatalog();
    [CompilerGeneratedAttribute]
internal static Dictionary`2<string, PSTraceSource> get_PreConfiguredTraceSource();
}
[FlagsAttribute]
public enum System.Management.Automation.PSTraceSourceOptions : Enum {
    public int value__;
    public static PSTraceSourceOptions None;
    public static PSTraceSourceOptions Constructor;
    public static PSTraceSourceOptions Dispose;
    public static PSTraceSourceOptions Finalizer;
    public static PSTraceSourceOptions Method;
    public static PSTraceSourceOptions Property;
    public static PSTraceSourceOptions Delegates;
    public static PSTraceSourceOptions Events;
    public static PSTraceSourceOptions Exception;
    public static PSTraceSourceOptions Lock;
    public static PSTraceSourceOptions Error;
    public static PSTraceSourceOptions Warning;
    public static PSTraceSourceOptions Verbose;
    public static PSTraceSourceOptions WriteLine;
    public static PSTraceSourceOptions Scope;
    public static PSTraceSourceOptions Assert;
    public static PSTraceSourceOptions ExecutionFlow;
    public static PSTraceSourceOptions Data;
    public static PSTraceSourceOptions Errors;
    public static PSTraceSourceOptions All;
}
public class System.Management.Automation.PSTransactionContext : object {
    internal PSTransactionContext(PSTransactionManager transactionManager);
    public sealed virtual void Dispose();
}
public abstract class System.Management.Automation.PSTransportOption : object {
    internal virtual string ConstructOptionsAsXmlAttributes();
    internal virtual Hashtable ConstructOptionsAsHashtable();
    internal virtual string ConstructQuotas();
    internal virtual Hashtable ConstructQuotasAsHashtable();
    protected internal virtual void LoadFromDefaults(bool keepAssigned);
    public sealed virtual object Clone();
}
public abstract class System.Management.Automation.PSTypeConverter : object {
    private static object GetSourceValueAsObject(PSObject sourceValue);
    public abstract virtual bool CanConvertFrom(object sourceValue, Type destinationType);
    public virtual bool CanConvertFrom(PSObject sourceValue, Type destinationType);
    public abstract virtual object ConvertFrom(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public virtual object ConvertFrom(PSObject sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public abstract virtual bool CanConvertTo(object sourceValue, Type destinationType);
    public virtual bool CanConvertTo(PSObject sourceValue, Type destinationType);
    public abstract virtual object ConvertTo(object sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
    public virtual object ConvertTo(PSObject sourceValue, Type destinationType, IFormatProvider formatProvider, bool ignoreCase);
}
internal class System.Management.Automation.PSTypedReference : ValueType {
}
[ExtensionAttribute]
internal static class System.Management.Automation.PSTypeExtensions : object {
    [ExtensionAttribute]
internal static bool HasDefaultCtor(Type type);
    [ExtensionAttribute]
internal static bool IsNumeric(Type type);
    [ExtensionAttribute]
internal static bool IsNumericOrPrimitive(Type type);
    [ExtensionAttribute]
internal static bool IsSafePrimitive(Type type);
    [ExtensionAttribute]
internal static bool IsFloating(Type type);
    [ExtensionAttribute]
internal static bool IsInteger(Type type);
    [ExtensionAttribute]
internal static TypeCode GetTypeCode(Type type);
    [ExtensionAttribute]
internal static IEnumerable`1<T> GetCustomAttributes(Type type, bool inherit);
}
public class System.Management.Automation.PSTypeName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private Type _type;
    [CompilerGeneratedAttribute]
private TypeDefinitionAst <TypeDefinitionAst>k__BackingField;
    private bool _typeWasCalculated;
    public string Name { get; }
    public Type Type { get; }
    public TypeDefinitionAst TypeDefinitionAst { get; }
    public PSTypeName(Type type);
    public PSTypeName(string name);
    public PSTypeName(string name, Type type);
    public PSTypeName(TypeDefinitionAst typeDefinitionAst);
    public PSTypeName(ITypeName typeName);
    [CompilerGeneratedAttribute]
public string get_Name();
    public Type get_Type();
    [CompilerGeneratedAttribute]
public TypeDefinitionAst get_TypeDefinitionAst();
    public virtual string ToString();
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.PSTypeNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <PSTypeName>k__BackingField;
    public string PSTypeName { get; }
    public PSTypeNameAttribute(string psTypeName);
    [CompilerGeneratedAttribute]
public string get_PSTypeName();
}
internal class System.Management.Automation.PSTypeNameComparer : object {
    public sealed virtual bool Equals(PSTypeName x, PSTypeName y);
    public sealed virtual int GetHashCode(PSTypeName obj);
}
internal class System.Management.Automation.PSUICultureVariable : PSVariable {
    public object Value { get; }
    public virtual object get_Value();
}
internal static class System.Management.Automation.PsUtils : object {
    private static Nullable`1<int> s_currentParentProcessId;
    private static int s_currentProcessId;
    internal static String[] ManifestModuleVersionPropertyName;
    internal static String[] ManifestGuidPropertyName;
    internal static String[] ManifestPrivateDataPropertyName;
    internal static String[] FastModuleManifestAnalysisPropertyNames;
    private static PsUtils();
    internal static Process GetParentProcess(Process current);
    internal static bool IsRunningOnProcessorArchitectureARM();
    internal static string GetHostName();
    internal static UInt32 GetNativeThreadId();
    internal static string GetUsingExpressionKey(UsingExpressionAst usingAst);
    internal static Hashtable EvaluatePowerShellDataFileAsModuleManifest(string parameterName, string psDataFilePath, ExecutionContext context, bool skipPathValidation);
    internal static Hashtable EvaluatePowerShellDataFile(string parameterName, string psDataFilePath, ExecutionContext context, IEnumerable`1<string> allowedCommands, IEnumerable`1<string> allowedVariables, bool allowEnvironmentVariables, bool skipPathValidation);
    internal static Hashtable GetModuleManifestProperties(string psDataFilePath, String[] keys);
}
public class System.Management.Automation.PSVariable : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    private string _description;
    private object _value;
    [CompilerGeneratedAttribute]
private SessionStateEntryVisibility <Visibility>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    private ScopedItemOptions _options;
    private PSVariableAttributeCollection _attributes;
    private bool _wasRemoved;
    [CompilerGeneratedAttribute]
private SessionStateInternal <SessionState>k__BackingField;
    private CallSite`1<Func`3<CallSite, object, object>> _copyMutableValueSite;
    public string Name { get; }
    public string Description { get; public set; }
    public object Value { get; public set; }
    public SessionStateEntryVisibility Visibility { get; public set; }
    public PSModuleInfo Module { get; private set; }
    public string ModuleName { get; }
    public ScopedItemOptions Options { get; public set; }
    public Collection`1<Attribute> Attributes { get; }
    internal bool IsConstant { get; }
    internal bool IsReadOnly { get; }
    internal bool IsPrivate { get; }
    internal bool IsAllScope { get; }
    internal bool WasRemoved { get; internal set; }
    internal SessionStateInternal SessionState { get; internal set; }
    public PSVariable(string name);
    public PSVariable(string name, object value);
    public PSVariable(string name, object value, ScopedItemOptions options);
    internal PSVariable(string name, object value, ScopedItemOptions options, string description);
    internal PSVariable(string name, object value, ScopedItemOptions options, Collection`1<Attribute> attributes, string description);
    public PSVariable(string name, object value, ScopedItemOptions options, Collection`1<Attribute> attributes);
    internal PSVariable(string name, bool dummy);
    [CompilerGeneratedAttribute]
public string get_Name();
    public virtual string get_Description();
    public virtual void set_Description(string value);
    internal void DebuggerCheckVariableRead();
    internal void DebuggerCheckVariableWrite();
    internal virtual object GetValueRaw();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    [CompilerGeneratedAttribute]
public sealed virtual SessionStateEntryVisibility get_Visibility();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Visibility(SessionStateEntryVisibility value);
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(PSModuleInfo value);
    internal void SetModule(PSModuleInfo module);
    public string get_ModuleName();
    public virtual ScopedItemOptions get_Options();
    public virtual void set_Options(ScopedItemOptions value);
    internal void SetOptions(ScopedItemOptions newOptions, bool force);
    public Collection`1<Attribute> get_Attributes();
    public virtual bool IsValidValue(object value);
    internal static bool IsValidValue(IEnumerable`1<Attribute> attributes, object value);
    internal static bool IsValidValue(object value, Attribute attribute);
    internal static object TransformValue(IEnumerable`1<Attribute> attributes, object value);
    internal void AddParameterAttributesNoChecks(Collection`1<Attribute> attributes);
    internal bool get_IsConstant();
    internal bool get_IsReadOnly();
    internal bool get_IsPrivate();
    internal bool get_IsAllScope();
    internal bool get_WasRemoved();
    internal void set_WasRemoved(bool value);
    [CompilerGeneratedAttribute]
internal SessionStateInternal get_SessionState();
    [CompilerGeneratedAttribute]
internal void set_SessionState(SessionStateInternal value);
    private void SetValue(object value);
    private void SetValueRawImpl(object newValue, bool preserveValueTypeSemantics);
    internal virtual void SetValueRaw(object newValue, bool preserveValueTypeSemantics);
    internal object CopyMutableValues(object o);
    internal void WrapValue();
}
internal class System.Management.Automation.PSVariableAttributeCollection : Collection`1<Attribute> {
    private PSVariable _variable;
    internal PSVariableAttributeCollection(PSVariable variable);
    protected virtual void InsertItem(int index, Attribute item);
    protected virtual void SetItem(int index, Attribute item);
    internal void AddAttributeNoCheck(Attribute item);
    private object VerifyNewAttribute(Attribute item);
}
public class System.Management.Automation.PSVariableIntrinsics : object {
    private SessionStateInternal _sessionState;
    internal PSVariableIntrinsics(SessionStateInternal sessionState);
    public PSVariable Get(string name);
    internal PSVariable GetAtScope(string name, string scope);
    public object GetValue(string name);
    public object GetValue(string name, object defaultValue);
    internal object GetValueAtScope(string name, string scope);
    public void Set(string name, object value);
    public void Set(PSVariable variable);
    public void Remove(string name);
    public void Remove(PSVariable variable);
    internal void RemoveAtScope(string name, string scope);
    internal void RemoveAtScope(PSVariable variable, string scope);
}
public class System.Management.Automation.PSVariableProperty : PSNoteProperty {
    internal PSVariable _variable;
    public PSMemberTypes MemberType { get; }
    public bool IsSettable { get; }
    public bool IsGettable { get; }
    public object Value { get; public set; }
    public string TypeNameOfValue { get; }
    public PSVariableProperty(PSVariable variable);
    public virtual string ToString();
    public virtual PSMemberInfo Copy();
    public virtual PSMemberTypes get_MemberType();
    public virtual bool get_IsSettable();
    public virtual bool get_IsGettable();
    public virtual object get_Value();
    public virtual void set_Value(object value);
    public virtual string get_TypeNameOfValue();
}
public class System.Management.Automation.PSVersionHashTable : Hashtable {
    private static PSVersionTableComparer s_keysComparer;
    public ICollection Keys { get; }
    internal PSVersionHashTable(IEqualityComparer equalityComparer);
    private static PSVersionHashTable();
    public virtual ICollection get_Keys();
    [IteratorStateMachineAttribute("System.Management.Automation.PSVersionHashTable/<System-Collections-IEnumerable-GetEnumerator>d__5")]
private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
public static class System.Management.Automation.PSVersionInfo : object {
    internal static string PSVersionTableName;
    internal static string PSRemotingProtocolVersionName;
    internal static string PSVersionName;
    internal static string PSEditionName;
    internal static string PSGitCommitIdName;
    internal static string PSCompatibleVersionsName;
    internal static string PSPlatformName;
    internal static string PSOSName;
    internal static string SerializationVersionName;
    internal static string WSManStackVersionName;
    private static PSVersionHashTable s_psVersionTable;
    private static Version s_psV1Version;
    private static Version s_psV2Version;
    private static Version s_psV3Version;
    private static Version s_psV4Version;
    private static Version s_psV5Version;
    private static Version s_psV51Version;
    private static Version s_psV6Version;
    private static Version s_psV7Version;
    private static Version s_psVersion;
    private static SemanticVersion s_psSemVersion;
    internal static string PSEditionValue;
    internal static string ProductVersion;
    internal static string GitCommitId;
    private static int Version_Major;
    private static int Version_Minor;
    private static int Version_Patch;
    private static string Version_Label;
    public static Version PSVersion { get; }
    public static string PSEdition { get; }
    internal static Version SerializationVersion { get; }
    internal static string RegistryVersionKey { get; }
    internal static SemanticVersion PSCurrentVersion { get; }
    private static PSVersionInfo();
    internal static PSVersionHashTable GetPSVersionTable();
    internal static Hashtable GetPSVersionTableForDownLevel();
    private static Version GetWSManStackVersion();
    public static Version get_PSVersion();
    public static string get_PSEdition();
    internal static Version get_SerializationVersion();
    internal static string get_RegistryVersionKey();
    internal static string GetRegistryVersionKeyForSnapinDiscovery(string majorVersion);
    internal static bool IsValidPSVersion(Version version);
    internal static SemanticVersion get_PSCurrentVersion();
}
internal class System.Management.Automation.QuestionMarkVariable : PSVariable {
    private ExecutionContext _context;
    public object Value { get; public set; }
    internal QuestionMarkVariable(ExecutionContext context);
    public virtual object get_Value();
    public virtual void set_Value(object value);
}
internal class System.Management.Automation.RangeEnumerator : object {
    private int _lowerBound;
    private int _upperBound;
    private int _current;
    private int _increment;
    private bool _firstElement;
    internal int LowerBound { get; }
    internal int UpperBound { get; }
    private object System.Collections.IEnumerator.Current { get; }
    public int Current { get; }
    internal int CurrentValue { get; }
    public RangeEnumerator(int lowerBound, int upperBound);
    internal int get_LowerBound();
    internal int get_UpperBound();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    public virtual int get_Current();
    internal int get_CurrentValue();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.ReadOnlyPSMemberInfoCollection`1 : object {
    private PSMemberInfoInternalCollection`1<T> _members;
    public T Item { get; }
    public int Count { get; }
    public T Item { get; }
    internal ReadOnlyPSMemberInfoCollection`1(PSMemberInfoInternalCollection`1<T> members);
    public T get_Item(string name);
    public ReadOnlyPSMemberInfoCollection`1<T> Match(string name);
    public ReadOnlyPSMemberInfoCollection`1<T> Match(string name, PSMemberTypes memberTypes);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual IEnumerator`1<T> GetEnumerator();
    public int get_Count();
    public T get_Item(int index);
}
public class System.Management.Automation.RedirectedException : RuntimeException {
    public RedirectedException(string message);
    public RedirectedException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected RedirectedException(SerializationInfo info, StreamingContext context);
}
internal class System.Management.Automation.ReferenceEqualityComparer : object {
    private sealed virtual override bool System.Collections.IEqualityComparer.Equals(object x, object y);
    private sealed virtual override int System.Collections.IEqualityComparer.GetHashCode(object obj);
}
internal class System.Management.Automation.ReferenceIdHandlerForDeserializer`1 : object {
    private Dictionary`2<string, T> _refId2object;
    internal void SetRefId(T o, string refId, bool duplicateRefIdsAllowed);
    internal T GetReferencedObject(string refId);
}
internal class System.Management.Automation.ReferenceIdHandlerForSerializer`1 : object {
    private ulong _seed;
    private IDictionary`2<T, ulong> _object2refId;
    internal ReferenceIdHandlerForSerializer`1(IDictionary`2<T, ulong> dictionary);
    private ulong GetNewReferenceId();
    internal string SetRefId(T t);
    internal string GetRefId(T t);
}
internal class System.Management.Automation.ReflectionParameterBinder : ParameterBinderBase {
    private static ConcurrentDictionary`2<Tuple`2<Type, string>, Func`2<object, object>> s_getterMethods;
    private static ConcurrentDictionary`2<Tuple`2<Type, string>, Action`2<object, object>> s_setterMethods;
    internal ReflectionParameterBinder(object target, Cmdlet command);
    internal ReflectionParameterBinder(object target, Cmdlet command, CommandLineParameters commandLineParameters);
    private static ReflectionParameterBinder();
    internal virtual object GetDefaultParameterValue(string name);
    internal virtual void BindParameter(string name, object value, CompiledCommandParameter parameterMetadata);
    private static Func`2<object, object> GetGetter(Type type, string property);
    private static Action`2<object, object> GetSetter(Type type, string property);
    private static Expression GetPropertyOrFieldExpr(Type type, string name, Expression target);
}
[CmdletAttribute("Register", "ArgumentCompleter")]
public class System.Management.Automation.RegisterArgumentCompleterCommand : PSCmdlet {
    [CompilerGeneratedAttribute]
private String[] <CommandName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private SwitchParameter <Native>k__BackingField;
    [ParameterAttribute]
[ParameterAttribute]
public String[] CommandName { get; public set; }
    [ParameterAttribute]
public string ParameterName { get; public set; }
    [ParameterAttribute]
[AllowNullAttribute]
public ScriptBlock ScriptBlock { get; public set; }
    [ParameterAttribute]
public SwitchParameter Native { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_CommandName();
    [CompilerGeneratedAttribute]
public void set_CommandName(String[] value);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
    [CompilerGeneratedAttribute]
public void set_ParameterName(string value);
    [CompilerGeneratedAttribute]
public ScriptBlock get_ScriptBlock();
    [CompilerGeneratedAttribute]
public void set_ScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
public SwitchParameter get_Native();
    [CompilerGeneratedAttribute]
public void set_Native(SwitchParameter value);
    protected virtual void EndProcessing();
}
internal class System.Management.Automation.RegistryStringResourceIndirect : object {
    internal static RegistryStringResourceIndirect GetResourceIndirectReader();
    public sealed virtual void Dispose();
    internal string GetResourceStringIndirect(string assemblyName, string modulePath, string baseNameRIDPair);
    internal string GetResourceStringIndirect(RegistryKey key, string valueName, string assemblyName, string modulePath);
}
internal static class System.Management.Automation.RegistryStrings : object {
    internal static string MonadRootKeyPath;
    internal static string MonadRootKeyName;
    internal static string MonadEngineKey;
    internal static string MonadEngine_ApplicationBase;
    internal static string MonadEngine_ConsoleHostAssemblyName;
    internal static string MonadEngine_ConsoleHostModuleName;
    internal static string MonadEngine_RuntimeVersion;
    internal static string MonadEngine_MonadVersion;
    internal static string MshSnapinKey;
    internal static string MshSnapin_ApplicationBase;
    internal static string MshSnapin_AssemblyName;
    internal static string MshSnapin_ModuleName;
    internal static string MshSnapin_MonadVersion;
    internal static string MshSnapin_BuiltInTypes;
    internal static string MshSnapin_BuiltInFormats;
    internal static string MshSnapin_Description;
    internal static string MshSnapin_Version;
    internal static string MshSnapin_Vendor;
    internal static string MshSnapin_DescriptionResource;
    internal static string MshSnapin_VendorResource;
    internal static string MshSnapin_LogPipelineExecutionDetails;
    internal static string CoreMshSnapinName;
    internal static string HostMshSnapinName;
    internal static string ManagementMshSnapinName;
    internal static string SecurityMshSnapinName;
    internal static string UtilityMshSnapinName;
}
public class System.Management.Automation.RemoteCommandInfo : CommandInfo {
    private string _definition;
    public string Definition { get; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    private RemoteCommandInfo(string name, CommandTypes type);
    public virtual string get_Definition();
    internal static RemoteCommandInfo FromPSObjectForRemoting(PSObject psObject);
    internal static void ToPSObjectForRemoting(CommandInfo commandInfo, PSObject psObject);
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
}
internal class System.Management.Automation.RemoteDataEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RemoteDataObject`1<PSObject> <ReceivedData>k__BackingField;
    public RemoteDataObject`1<PSObject> ReceivedData { get; }
    internal RemoteDataEventArgs(RemoteDataObject`1<PSObject> receivedData);
    [CompilerGeneratedAttribute]
public RemoteDataObject`1<PSObject> get_ReceivedData();
}
internal class System.Management.Automation.RemoteDataEventArgs`1 : EventArgs {
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    internal T Data { get; }
    internal RemoteDataEventArgs`1(object data);
    [CompilerGeneratedAttribute]
internal T get_Data();
}
internal static class System.Management.Automation.RemoteDataNameStrings : object {
    internal static string Destination;
    internal static string RemotingTargetInterface;
    internal static string ClientRunspacePoolId;
    internal static string ClientPowerShellId;
    internal static string Action;
    internal static string DataType;
    internal static string TimeZone;
    internal static string SenderInfoPreferenceVariable;
    internal static string MustComply;
    internal static string IsNegotiationSucceeded;
    internal static string CallId;
    internal static string MethodId;
    internal static string MethodParameters;
    internal static string MethodReturnValue;
    internal static string MethodException;
    internal static string PS_STARTUP_PROTOCOL_VERSION_NAME;
    internal static string PublicKeyAsXml;
    internal static string PSVersion;
    internal static string SerializationVersion;
    internal static string MethodArrayElementType;
    internal static string MethodArrayLengths;
    internal static string MethodArrayElements;
    internal static string ObjectType;
    internal static string ObjectValue;
    internal static string DiscoveryName;
    internal static string DiscoveryType;
    internal static string DiscoveryModule;
    internal static string DiscoveryFullyQualifiedModule;
    internal static string DiscoveryArgumentList;
    internal static string DiscoveryCount;
    internal static string PSInvocationSettings;
    internal static string ApartmentState;
    internal static string RemoteStreamOptions;
    internal static string AddToHistory;
    internal static string PowerShell;
    internal static string IsNested;
    internal static string HistoryString;
    internal static string RedirectShellErrorOutputPipe;
    internal static string Commands;
    internal static string ExtraCommands;
    internal static string CommandText;
    internal static string IsScript;
    internal static string UseLocalScopeNullable;
    internal static string MergeUnclaimedPreviousCommandResults;
    internal static string MergeMyResult;
    internal static string MergeToResult;
    internal static string MergeError;
    internal static string MergeWarning;
    internal static string MergeVerbose;
    internal static string MergeDebug;
    internal static string MergeInformation;
    internal static string Parameters;
    internal static string ParameterName;
    internal static string ParameterValue;
    internal static string NoInput;
    internal static string ExceptionAsErrorRecord;
    internal static string PipelineState;
    internal static string RunspaceState;
    internal static string PSEventArgsComputerName;
    internal static string PSEventArgsRunspaceId;
    internal static string PSEventArgsEventIdentifier;
    internal static string PSEventArgsSourceIdentifier;
    internal static string PSEventArgsTimeGenerated;
    internal static string PSEventArgsSender;
    internal static string PSEventArgsSourceArgs;
    internal static string PSEventArgsMessageData;
    internal static string MinRunspaces;
    internal static string MaxRunspaces;
    internal static string ThreadOptions;
    internal static string HostInfo;
    internal static string RunspacePoolOperationResponse;
    internal static string AvailableRunspaces;
    internal static string PublicKey;
    internal static string EncryptedSessionKey;
    internal static string ApplicationArguments;
    internal static string ApplicationPrivateData;
    internal static string ProgressRecord_Activity;
    internal static string ProgressRecord_ActivityId;
    internal static string ProgressRecord_CurrentOperation;
    internal static string ProgressRecord_ParentActivityId;
    internal static string ProgressRecord_PercentComplete;
    internal static string ProgressRecord_Type;
    internal static string ProgressRecord_SecondsRemaining;
    internal static string ProgressRecord_StatusDescription;
}
internal class System.Management.Automation.RemoteDebugger : Debugger {
    private RemoteRunspace _runspace;
    private PowerShell _psDebuggerCommand;
    private bool _remoteDebugSupported;
    private bool _isActive;
    private int _breakpointCount;
    private RemoteDebuggingCapability _remoteDebuggingCapability;
    private Nullable`1<bool> _remoteBreakpointManagementIsSupported;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _handleDebuggerStop;
    private bool _isDebuggerSteppingEnabled;
    private UnhandledBreakpointProcessingMode _unhandledBreakpointMode;
    private bool _detachCommand;
    private WindowsIdentity _identityToPersonate;
    private bool _identityPersonationChecked;
    public static string RemoteDebuggerStopEvent;
    public static string RemoteDebuggerBreakpointUpdatedEvent;
    public static string DebugModeSetting;
    public static string DebugStopState;
    public static string DebugBreakpointCount;
    public static string BreakAllSetting;
    public static string UnhandledBreakpointModeSetting;
    [CompilerGeneratedAttribute]
private bool <IsRemoteDebug>k__BackingField;
    public bool IsActive { get; }
    public bool InBreakpoint { get; }
    internal bool IsRemote { get; }
    internal UnhandledBreakpointProcessingMode UnhandledBreakpointMode { get; internal set; }
    internal bool IsRemoteDebug { get; private set; }
    internal bool IsDebuggerSteppingEnabled { get; }
    public RemoteDebugger(RemoteRunspace runspace);
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual void StopProcessCommand();
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual void SetDebugMode(DebugModes mode);
    public virtual void SetDebuggerStepMode(bool enabled);
    public virtual bool get_IsActive();
    public virtual bool get_InBreakpoint();
    internal virtual DebuggerCommand InternalProcessCommand(string command, IList`1<PSObject> output);
    internal virtual bool get_IsRemote();
    internal virtual UnhandledBreakpointProcessingMode get_UnhandledBreakpointMode();
    internal virtual void set_UnhandledBreakpointMode(UnhandledBreakpointProcessingMode value);
    public sealed virtual void Dispose();
    internal void CheckStateAndRaiseStopEvent();
    [CompilerGeneratedAttribute]
internal bool get_IsRemoteDebug();
    [CompilerGeneratedAttribute]
private void set_IsRemoteDebug(bool value);
    internal void SetClientDebugInfo(Nullable`1<DebugModes> debugMode, bool inBreakpoint, int breakpointCount, bool breakAll, UnhandledBreakpointProcessingMode unhandledBreakpointMode, Version serverPSVersion);
    internal void OnCommandStopped();
    internal void SendBreakpointUpdatedEvents();
    internal virtual bool get_IsDebuggerSteppingEnabled();
    private static bool TryGetRemoteDebuggerException(PSObject item, Exception& exception);
    private void HandleForwardedDebuggerStopEvent(object sender, PSEventArgs e);
    private void ProcessDebuggerStopEvent(DebuggerStopEventArgs args);
    private void ProcessDebuggerStopEventProc(object state);
    private void HandleForwardedDebuggerBreakpointUpdatedEvent(object sender, PSEventArgs e);
    private PowerShell GetNestedPowerShell();
    private void CheckForValidateState();
    private void SetRemoteDebug(bool remoteDebug, Nullable`1<RunspaceAvailability> availability);
    private void UpdateBreakpointCount(int bpCount);
    private void SetIsActive(int breakpointCount);
    private T InvokeRemoteBreakpointFunction(string functionName, Dictionary`2<string, object> parameters);
    private void CheckRemoteBreakpointManagementSupport(string breakpointCommandNameToCheck);
}
internal static class System.Management.Automation.RemoteDiscoveryHelper : object {
    private static int s_blockingCollectionCapacity;
    private static string DiscoveryProviderNotFoundErrorId;
    private static string DiscoveryProviderNamespace;
    private static string DiscoveryProviderModuleClass;
    private static string DiscoveryProviderFileClass;
    private static string DiscoveryProviderAssociationClass;
    private static String[] s_manifestEntriesToKeepAsString;
    private static String[] s_manifestEntriesToKeepAsStringArray;
    private static ConditionalWeakTable`2<PSModuleInfo, object> s_moduleInfoToSession;
    private static RemoteDiscoveryHelper();
    private static Collection`1<string> RehydrateHashtableKeys(PSObject pso, string propertyName);
    internal static PSModuleInfo RehydratePSModuleInfo(PSObject deserializedModuleInfo);
    private static EventHandler`1<DataAddedEventArgs> GetStreamForwarder(Action`1<T> forwardingAction, bool swallowInvalidOperationExceptions);
    [IteratorStateMachineAttribute("System.Management.Automation.RemoteDiscoveryHelper/<InvokeTopLevelPowerShell>d__4")]
private static IEnumerable`1<PSObject> InvokeTopLevelPowerShell(PowerShell powerShell, PSCmdlet cmdlet, PSInvocationSettings invocationSettings, string errorMessageTemplate, CancellationToken cancellationToken);
    [IteratorStateMachineAttribute("System.Management.Automation.RemoteDiscoveryHelper/<InvokeNestedPowerShell>d__5")]
private static IEnumerable`1<PSObject> InvokeNestedPowerShell(PowerShell powerShell, PSCmdlet cmdlet, PSInvocationSettings invocationSettings, string errorMessageTemplate, CancellationToken cancellationToken);
    private static void CopyParameterFromCmdletToPowerShell(Cmdlet cmdlet, PowerShell powerShell, string parameterName);
    internal static ErrorRecord GetErrorRecordForProcessingOfCimModule(Exception innerException, string moduleName);
    private static ErrorRecord GetErrorRecordForRemoteDiscoveryProvider(Exception innerException);
    private static ErrorRecord GetErrorRecordForRemotePipelineInvocation(Exception innerException, string errorMessageTemplate);
    private static ErrorRecord GetErrorRecordForRemotePipelineInvocation(ErrorRecord innerErrorRecord, string errorMessageTemplate);
    [IteratorStateMachineAttribute("System.Management.Automation.RemoteDiscoveryHelper/<EnumerateWithCatch>d__12`1")]
private static IEnumerable`1<T> EnumerateWithCatch(IEnumerable`1<T> enumerable, Action`1<Exception> exceptionHandler);
    private static void HandleErrorFromPipeline(Cmdlet cmdlet, ErrorRecord errorRecord, PowerShell powerShell);
    internal static IEnumerable`1<PSObject> InvokePowerShell(PowerShell powerShell, PSCmdlet cmdlet, string errorMessageTemplate, CancellationToken cancellationToken);
    private static T GetPropertyValue(CimInstance cimInstance, string propertyName, T defaultValue);
    [IteratorStateMachineAttribute("System.Management.Automation.RemoteDiscoveryHelper/<GetCimModules>d__23")]
internal static IEnumerable`1<CimModule> GetCimModules(CimSession cimSession, Uri resourceUri, string cimNamespace, IEnumerable`1<string> moduleNamePatterns, bool onlyManifests, Cmdlet cmdlet, CancellationToken cancellationToken);
    private static IEnumerable`1<CimModule> GetCimModules(CimSession cimSession, Uri resourceUri, string cimNamespace, string moduleNamePattern, bool onlyManifests, Cmdlet cmdlet, CancellationToken cancellationToken);
    internal static Hashtable RewriteManifest(Hashtable originalManifest);
    internal static Hashtable RewriteManifest(Hashtable originalManifest, IEnumerable`1<string> nestedModules, IEnumerable`1<string> typesToProcess, IEnumerable`1<string> formatsToProcess);
    private static CimCredential GetCimCredentials(PasswordAuthenticationMechanism authenticationMechanism, PSCredential credential);
    private static Exception GetExceptionWhenAuthenticationRequiresCredential(string authentication);
    private static CimCredential GetCimCredentials(string authentication, PSCredential credential);
    internal static CimSession CreateCimSession(string computerName, PSCredential credential, string authentication, bool isLocalHost, PSCmdlet cmdlet, CancellationToken cancellationToken);
    internal static Hashtable ConvertCimModuleFileToManifestHashtable(CimModuleFile cimModuleFile, string temporaryModuleManifestPath, ModuleCmdletBase cmdlet, Boolean& containedErrors);
    internal static string GetModulePath(string remoteModuleName, Version remoteModuleVersion, string computerName, Runspace localRunspace);
    internal static void AssociatePSModuleInfoWithSession(PSModuleInfo moduleInfo, CimSession cimSession, Uri resourceUri, string cimNamespace);
    internal static void AssociatePSModuleInfoWithSession(PSModuleInfo moduleInfo, PSSession psSession);
    private static void AssociatePSModuleInfoWithSession(PSModuleInfo moduleInfo, object weaklyTypedSession);
    internal static void DispatchModuleInfoProcessing(PSModuleInfo moduleInfo, Action localAction, Action`3<CimSession, Uri, string> cimSessionAction, Action`1<PSSession> psSessionAction);
}
public class System.Management.Automation.RemoteException : RuntimeException {
    private PSObject _serializedRemoteException;
    private PSObject _serializedRemoteInvocationInfo;
    private ErrorRecord _remoteErrorRecord;
    public PSObject SerializedRemoteException { get; }
    public PSObject SerializedRemoteInvocationInfo { get; }
    public ErrorRecord ErrorRecord { get; }
    public RemoteException(string message);
    public RemoteException(string message, Exception innerException);
    internal RemoteException(string message, PSObject serializedRemoteException, PSObject serializedRemoteInvocationInfo);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected RemoteException(SerializationInfo info, StreamingContext context);
    public PSObject get_SerializedRemoteException();
    public PSObject get_SerializedRemoteInvocationInfo();
    internal void SetRemoteErrorRecord(ErrorRecord remoteError);
    public virtual ErrorRecord get_ErrorRecord();
}
internal class System.Management.Automation.RemoteHelpInfo : BaseCommandHelpInfo {
    private PSObject _deserializedRemoteHelp;
    internal PSObject FullHelp { get; }
    internal string Component { get; }
    internal string Functionality { get; }
    internal string Role { get; }
    internal RemoteHelpInfo(ExecutionContext context, RemoteRunspace remoteRunspace, string localCommandName, string remoteHelpTopic, string remoteHelpCategory, HelpCategory localHelpCategory);
    internal virtual PSObject get_FullHelp();
    private string GetHelpProperty(string propertyName);
    internal virtual string get_Component();
    internal virtual string get_Functionality();
    internal virtual string get_Role();
}
internal class System.Management.Automation.RemotePipeline : Pipeline {
    private PowerShell _powershell;
    private bool _addToHistory;
    private bool _isNested;
    private bool _isSteppable;
    private Runspace _runspace;
    private object _syncRoot;
    private bool _disposed;
    private string _historyString;
    private PipelineStateInfo _pipelineStateInfo;
    private CommandCollection _commands;
    private string _computerName;
    private Guid _runspaceId;
    private ConnectCommandInfo _connectCmdInfo;
    private Queue`1<ExecutionEventQueueItem> _executionEventQueue;
    private bool _performNestedCheck;
    private PSDataCollection`1<PSObject> _outputCollection;
    private PSDataCollectionStream`1<PSObject> _outputStream;
    private PSDataCollection`1<ErrorRecord> _errorCollection;
    private PSDataCollectionStream`1<ErrorRecord> _errorStream;
    private PSDataCollection`1<object> _inputCollection;
    private PSDataCollectionStream`1<object> _inputStream;
    [CompilerGeneratedAttribute]
private EventHandler`1<PipelineStateEventArgs> StateChanged;
    [CompilerGeneratedAttribute]
private ManualResetEvent <PipelineFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsMethodExecutorStreamEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectStream <MethodExecutorStream>k__BackingField;
    public Runspace Runspace { get; }
    public bool IsNested { get; }
    public PipelineStateInfo PipelineStateInfo { get; }
    public PipelineWriter Input { get; }
    public PipelineReader`1<PSObject> Output { get; }
    public PipelineReader`1<object> Error { get; }
    internal string HistoryString { get; internal set; }
    public bool AddToHistory { get; }
    protected PSDataCollectionStream`1<object> InputStream { get; }
    internal ManualResetEvent PipelineFinishedEvent { get; }
    internal bool IsMethodExecutorStreamEnabled { get; internal set; }
    internal ObjectStream MethodExecutorStream { get; }
    internal PowerShell PowerShell { get; }
    private RemotePipeline(RemoteRunspace runspace, bool addToHistory, bool isNested);
    internal RemotePipeline(RemoteRunspace runspace, string command, bool addToHistory, bool isNested);
    internal RemotePipeline(RemoteRunspace runspace);
    private RemotePipeline(RemotePipeline pipeline);
    public virtual Pipeline Copy();
    public virtual Runspace get_Runspace();
    internal Runspace GetRunspace();
    public virtual bool get_IsNested();
    internal void SetIsNested(bool isNested);
    internal void SetIsSteppable(bool isSteppable);
    public virtual PipelineStateInfo get_PipelineStateInfo();
    public virtual PipelineWriter get_Input();
    public virtual PipelineReader`1<PSObject> get_Output();
    public virtual PipelineReader`1<object> get_Error();
    internal string get_HistoryString();
    internal void set_HistoryString(string value);
    public bool get_AddToHistory();
    protected PSDataCollectionStream`1<object> get_InputStream();
    public virtual void InvokeAsync();
    internal virtual void InvokeAsyncAndDisconnect();
    public virtual Collection`1<PSObject> Invoke(IEnumerable input);
    public virtual Collection`1<PSObject> Connect();
    public virtual void ConnectAsync();
    public virtual void Stop();
    public virtual void StopAsync();
    private bool CanStopPipeline(Boolean& isAlreadyStopping);
    [CompilerGeneratedAttribute]
public virtual void add_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    protected virtual void Dispose(bool disposing);
    private void CoreInvokeAsync();
    private void HandleInvocationStateChanged(object sender, PSInvocationStateChangedEventArgs e);
    private void SetPipelineState(PipelineState state, Exception reason);
    protected void RaisePipelineStateEvents();
    private void InitPowerShell(bool syncCall, bool invokeAndDisconnect);
    private void InitPowerShellForConnect(bool syncCall);
    private void HandleHostCallReceived(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    private void Cleanup();
    [CompilerGeneratedAttribute]
internal ManualResetEvent get_PipelineFinishedEvent();
    [CompilerGeneratedAttribute]
internal bool get_IsMethodExecutorStreamEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsMethodExecutorStreamEnabled(bool value);
    [CompilerGeneratedAttribute]
internal ObjectStream get_MethodExecutorStream();
    internal void DoConcurrentCheck(bool syncCall);
    internal PowerShell get_PowerShell();
    internal virtual void SetHistoryString(string historyString);
    internal virtual void SuspendIncomingData();
    internal virtual void ResumeIncomingData();
    internal virtual void DrainIncomingData();
}
internal class System.Management.Automation.RemoteRunspace : Runspace {
    private List`1<RemotePipeline> _runningPipelines;
    private object _syncRoot;
    private RunspaceStateInfo _runspaceStateInfo;
    private bool _bSessionStateProxyCallInProgress;
    private RunspaceConnectionInfo _connectionInfo;
    private RemoteDebugger _remoteDebugger;
    private PSPrimitiveDictionary _applicationPrivateData;
    private bool _disposed;
    private InvokeCommandCommand _currentInvokeCommand;
    private long _currentLocalPipelineId;
    private Queue`1<RunspaceEventQueueItem> _runspaceEventQueue;
    private bool _bypassRunspaceStateCheck;
    [CompilerGeneratedAttribute]
private bool <ShouldCloseOnPop>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <ServerVersion>k__BackingField;
    private PSThreadOptions _createThreadOptions;
    private RunspaceAvailability _runspaceAvailability;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceStateEventArgs> StateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceAvailabilityEventArgs> AvailabilityChanged;
    [CompilerGeneratedAttribute]
private RunspaceConnectionInfo <OriginalConnectionInfo>k__BackingField;
    private PSRemoteEventManager _eventManager;
    [CompilerGeneratedAttribute]
private int <PSSessionId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfiguredLoopBack>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> RemoteDebuggerStop;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> RemoteDebuggerBreakpointUpdated;
    private RemoteSessionStateProxy _sessionStateProxy;
    [CompilerGeneratedAttribute]
private RunspacePool <RunspacePool>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Uri>> URIRedirectionReported;
    protected bool ByPassRunspaceStateCheck { get; protected set; }
    internal bool ShouldCloseOnPop { get; internal set; }
    public InitialSessionState InitialSessionState { get; }
    public JobManager JobManager { get; }
    public Version Version { get; }
    internal Version ServerVersion { get; private set; }
    public RunspaceStateInfo RunspaceStateInfo { get; }
    public PSThreadOptions ThreadOptions { get; public set; }
    public RunspaceAvailability RunspaceAvailability { get; protected set; }
    internal bool HasAvailabilityChangedSubscribers { get; }
    public RunspaceConnectionInfo ConnectionInfo { get; }
    public RunspaceConnectionInfo OriginalConnectionInfo { get; }
    public PSEventManager Events { get; }
    internal ExecutionContext GetExecutionContext { get; }
    internal bool InNestedPrompt { get; }
    internal ClientRemoteSession ClientRemoteSession { get; }
    internal ConnectCommandInfo RemoteCommand { get; }
    internal string PSSessionName { get; internal set; }
    internal int PSSessionId { get; internal set; }
    internal bool CanDisconnect { get; }
    internal bool CanConnect { get; }
    internal bool IsConfiguredLoopBack { get; internal set; }
    public Debugger Debugger { get; }
    internal RunspacePool RunspacePool { get; }
    internal RemoteRunspace(TypeTable typeTable, RunspaceConnectionInfo connectionInfo, PSHost host, PSPrimitiveDictionary applicationArguments, string name, int id);
    internal RemoteRunspace(RunspacePool runspacePool);
    protected bool get_ByPassRunspaceStateCheck();
    protected void set_ByPassRunspaceStateCheck(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ShouldCloseOnPop();
    [CompilerGeneratedAttribute]
internal void set_ShouldCloseOnPop(bool value);
    private void SetEventHandlers();
    public virtual InitialSessionState get_InitialSessionState();
    public virtual JobManager get_JobManager();
    [CompilerGeneratedAttribute]
public virtual Version get_Version();
    [CompilerGeneratedAttribute]
internal Version get_ServerVersion();
    [CompilerGeneratedAttribute]
private void set_ServerVersion(Version value);
    public virtual RunspaceStateInfo get_RunspaceStateInfo();
    public virtual PSThreadOptions get_ThreadOptions();
    public virtual void set_ThreadOptions(PSThreadOptions value);
    public virtual RunspaceAvailability get_RunspaceAvailability();
    protected virtual void set_RunspaceAvailability(RunspaceAvailability value);
    [CompilerGeneratedAttribute]
public virtual void add_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void add_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    internal virtual bool get_HasAvailabilityChangedSubscribers();
    protected virtual void OnAvailabilityChanged(RunspaceAvailabilityEventArgs e);
    public virtual RunspaceConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
public virtual RunspaceConnectionInfo get_OriginalConnectionInfo();
    public virtual PSEventManager get_Events();
    internal virtual ExecutionContext get_GetExecutionContext();
    internal virtual bool get_InNestedPrompt();
    internal ClientRemoteSession get_ClientRemoteSession();
    internal ConnectCommandInfo get_RemoteCommand();
    internal string get_PSSessionName();
    internal void set_PSSessionName(string value);
    [CompilerGeneratedAttribute]
internal int get_PSSessionId();
    [CompilerGeneratedAttribute]
internal void set_PSSessionId(int value);
    internal bool get_CanDisconnect();
    internal bool get_CanConnect();
    [CompilerGeneratedAttribute]
internal bool get_IsConfiguredLoopBack();
    [CompilerGeneratedAttribute]
internal void set_IsConfiguredLoopBack(bool value);
    public virtual Debugger get_Debugger();
    public virtual void OpenAsync();
    public virtual void Open();
    public virtual void CloseAsync();
    public virtual void Close();
    protected virtual void Dispose(bool disposing);
    public virtual void ResetRunspaceState();
    internal static Runspace[] GetRemoteRunspaces(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    internal static Runspace GetRemoteRunspace(RunspaceConnectionInfo connectionInfo, Guid sessionId, Nullable`1<Guid> commandId, PSHost host, TypeTable typeTable);
    public virtual void Disconnect();
    public virtual void DisconnectAsync();
    public virtual void Connect();
    public virtual void ConnectAsync();
    public virtual Pipeline CreateDisconnectedPipeline();
    public virtual PowerShell CreateDisconnectedPowerShell();
    public virtual RunspaceCapability GetCapabilities();
    private void UpdatePoolDisconnectOptions();
    [CompilerGeneratedAttribute]
internal void add_RemoteDebuggerStop(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RemoteDebuggerStop(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_RemoteDebuggerBreakpointUpdated(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RemoteDebuggerBreakpointUpdated(EventHandler`1<PSEventArgs> value);
    public virtual Pipeline CreatePipeline();
    public virtual Pipeline CreatePipeline(string command);
    public virtual Pipeline CreatePipeline(string command, bool addToHistory);
    public virtual Pipeline CreateNestedPipeline();
    public virtual Pipeline CreateNestedPipeline(string command, bool addToHistory);
    internal void AddToRunningPipelineList(RemotePipeline pipeline);
    internal void RemoveFromRunningPipelineList(RemotePipeline pipeline);
    internal void DoConcurrentCheckAndAddToRunningPipelines(RemotePipeline pipeline, bool syncCall);
    internal virtual SessionStateProxy GetSessionStateProxy();
    private void HandleRunspacePoolStateChanged(object sender, RunspacePoolStateChangedEventArgs e);
    private void SetDebugModeOnOpen();
    private bool SetDebugInfo(PSPrimitiveDictionary psApplicationPrivateData);
    private void AssertIfStateIsBeforeOpen();
    private RunspaceState SetRunspaceState(RunspaceState state, Exception reason);
    private void RaiseRunspaceStateEvents();
    private Pipeline CoreCreatePipeline(string command, bool addToHistory, bool isNested);
    private bool WaitForFinishofPipelines();
    internal virtual Pipeline GetCurrentlyRunningPipeline();
    private void HandleHostCallReceived(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    private void HandleURIDirectionReported(object sender, RemoteDataEventArgs`1<Uri> eventArgs);
    private void HandleRunspacePoolForwardEvent(object sender, PSEventArgs e);
    private void HandleSessionCreateCompleted(object sender, CreateCompleteEventArgs eventArgs);
    private void UpdateDisconnectExpiresOn();
    internal bool IsAnotherInvokeCommandExecuting(InvokeCommandCommand invokeCommand, long localPipelineId);
    internal void SetCurrentInvokeCommand(InvokeCommandCommand invokeCommand, long localPipelineId);
    internal void ClearInvokeCommand();
    internal void AbortOpen();
    [CompilerGeneratedAttribute]
internal RunspacePool get_RunspacePool();
    [CompilerGeneratedAttribute]
internal void add_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    [CompilerGeneratedAttribute]
internal void remove_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    public virtual PSPrimitiveDictionary GetApplicationPrivateData();
    internal virtual void SetApplicationPrivateData(PSPrimitiveDictionary applicationPrivateData);
}
internal abstract class System.Management.Automation.RemoteSession : object {
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseSessionDataStructureHandler <BaseSessionDataStructureHandler>k__BackingField;
    internal Guid InstanceId { get; }
    internal RemotingDestination MySelf { get; }
    internal BaseSessionDataStructureHandler BaseSessionDataStructureHandler { get; internal set; }
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    internal abstract virtual RemotingDestination get_MySelf();
    internal abstract virtual void StartKeyExchange();
    internal abstract virtual void CompleteKeyExchange();
    [CompilerGeneratedAttribute]
internal BaseSessionDataStructureHandler get_BaseSessionDataStructureHandler();
    [CompilerGeneratedAttribute]
internal void set_BaseSessionDataStructureHandler(BaseSessionDataStructureHandler value);
}
internal enum System.Management.Automation.RemoteSessionEvent : Enum {
    public int value__;
    public static RemoteSessionEvent InvalidEvent;
    public static RemoteSessionEvent CreateSession;
    public static RemoteSessionEvent ConnectSession;
    public static RemoteSessionEvent NegotiationSending;
    public static RemoteSessionEvent NegotiationSendingOnConnect;
    public static RemoteSessionEvent NegotiationSendCompleted;
    public static RemoteSessionEvent NegotiationReceived;
    public static RemoteSessionEvent NegotiationCompleted;
    public static RemoteSessionEvent NegotiationPending;
    public static RemoteSessionEvent Close;
    public static RemoteSessionEvent CloseCompleted;
    public static RemoteSessionEvent CloseFailed;
    public static RemoteSessionEvent ConnectFailed;
    public static RemoteSessionEvent NegotiationFailed;
    public static RemoteSessionEvent NegotiationTimeout;
    public static RemoteSessionEvent SendFailed;
    public static RemoteSessionEvent ReceiveFailed;
    public static RemoteSessionEvent FatalError;
    public static RemoteSessionEvent MessageReceived;
    public static RemoteSessionEvent KeySent;
    public static RemoteSessionEvent KeySendFailed;
    public static RemoteSessionEvent KeyReceived;
    public static RemoteSessionEvent KeyReceiveFailed;
    public static RemoteSessionEvent KeyRequested;
    public static RemoteSessionEvent KeyRequestFailed;
    public static RemoteSessionEvent DisconnectStart;
    public static RemoteSessionEvent DisconnectCompleted;
    public static RemoteSessionEvent DisconnectFailed;
    public static RemoteSessionEvent ReconnectStart;
    public static RemoteSessionEvent ReconnectCompleted;
    public static RemoteSessionEvent ReconnectFailed;
    public static RemoteSessionEvent RCDisconnectStarted;
    public static RemoteSessionEvent MaxEvent;
}
internal class System.Management.Automation.RemoteSessionNegotiationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <RemoteSessionCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteDataObject`1<PSObject> <RemoteData>k__BackingField;
    internal RemoteSessionCapability RemoteSessionCapability { get; }
    internal RemoteDataObject`1<PSObject> RemoteData { get; internal set; }
    internal RemoteSessionNegotiationEventArgs(RemoteSessionCapability remoteSessionCapability);
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_RemoteSessionCapability();
    [CompilerGeneratedAttribute]
internal RemoteDataObject`1<PSObject> get_RemoteData();
    [CompilerGeneratedAttribute]
internal void set_RemoteData(RemoteDataObject`1<PSObject> value);
}
internal enum System.Management.Automation.RemoteSessionState : Enum {
    public int value__;
    public static RemoteSessionState UndefinedState;
    public static RemoteSessionState Idle;
    public static RemoteSessionState Connecting;
    public static RemoteSessionState Connected;
    public static RemoteSessionState NegotiationSending;
    public static RemoteSessionState NegotiationSendingOnConnect;
    public static RemoteSessionState NegotiationSent;
    public static RemoteSessionState NegotiationReceived;
    public static RemoteSessionState NegotiationPending;
    public static RemoteSessionState ClosingConnection;
    public static RemoteSessionState Closed;
    public static RemoteSessionState Established;
    public static RemoteSessionState EstablishedAndKeySent;
    public static RemoteSessionState EstablishedAndKeyReceived;
    public static RemoteSessionState EstablishedAndKeyRequested;
    public static RemoteSessionState EstablishedAndKeyExchanged;
    public static RemoteSessionState Disconnecting;
    public static RemoteSessionState Disconnected;
    public static RemoteSessionState Reconnecting;
    public static RemoteSessionState RCDisconnecting;
    public static RemoteSessionState MaxState;
}
internal class System.Management.Automation.RemoteSessionStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RemoteSessionStateInfo <SessionStateInfo>k__BackingField;
    public RemoteSessionStateInfo SessionStateInfo { get; }
    internal RemoteSessionStateEventArgs(RemoteSessionStateInfo remoteSessionStateInfo);
    [CompilerGeneratedAttribute]
public RemoteSessionStateInfo get_SessionStateInfo();
}
internal class System.Management.Automation.RemoteSessionStateInfo : object {
    [CompilerGeneratedAttribute]
private RemoteSessionState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    internal RemoteSessionState State { get; }
    internal Exception Reason { get; }
    internal RemoteSessionStateInfo(RemoteSessionState state);
    internal RemoteSessionStateInfo(RemoteSessionState state, Exception reason);
    internal RemoteSessionStateInfo(RemoteSessionStateInfo sessionStateInfo);
    [CompilerGeneratedAttribute]
internal RemoteSessionState get_State();
    [CompilerGeneratedAttribute]
internal Exception get_Reason();
}
internal class System.Management.Automation.RemoteSessionStateMachineEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RemoteSessionEvent <StateEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <RemoteSessionCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteDataObject`1<PSObject> <RemoteData>k__BackingField;
    internal RemoteSessionEvent StateEvent { get; }
    internal Exception Reason { get; }
    internal RemoteSessionCapability RemoteSessionCapability { get; internal set; }
    internal RemoteDataObject`1<PSObject> RemoteData { get; internal set; }
    internal RemoteSessionStateMachineEventArgs(RemoteSessionEvent stateEvent);
    internal RemoteSessionStateMachineEventArgs(RemoteSessionEvent stateEvent, Exception reason);
    [CompilerGeneratedAttribute]
internal RemoteSessionEvent get_StateEvent();
    [CompilerGeneratedAttribute]
internal Exception get_Reason();
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_RemoteSessionCapability();
    [CompilerGeneratedAttribute]
internal void set_RemoteSessionCapability(RemoteSessionCapability value);
    [CompilerGeneratedAttribute]
internal RemoteDataObject`1<PSObject> get_RemoteData();
    [CompilerGeneratedAttribute]
internal void set_RemoteData(RemoteDataObject`1<PSObject> value);
}
internal class System.Management.Automation.RemoteSessionStateProxy : SessionStateProxy {
    private RemoteRunspace _runspace;
    private Exception _isInNoLanguageModeException;
    private Exception _getVariableCommandNotFoundException;
    private Exception _setVariableCommandNotFoundException;
    public List`1<string> Applications { get; }
    public List`1<string> Scripts { get; }
    public DriveManagementIntrinsics Drive { get; }
    public PSLanguageMode LanguageMode { get; public set; }
    public PSModuleInfo Module { get; }
    public PathIntrinsics Path { get; }
    public CmdletProviderManagementIntrinsics Provider { get; }
    public PSVariableIntrinsics PSVariable { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    internal RemoteSessionStateProxy(RemoteRunspace runspace);
    public virtual void SetVariable(string name, object value);
    public virtual object GetVariable(string name);
    public virtual List`1<string> get_Applications();
    public virtual List`1<string> get_Scripts();
    public virtual DriveManagementIntrinsics get_Drive();
    public virtual PSLanguageMode get_LanguageMode();
    public virtual void set_LanguageMode(PSLanguageMode value);
    public virtual PSModuleInfo get_Module();
    public virtual PathIntrinsics get_Path();
    public virtual CmdletProviderManagementIntrinsics get_Provider();
    public virtual PSVariableIntrinsics get_PSVariable();
    public virtual CommandInvocationIntrinsics get_InvokeCommand();
    public virtual ProviderIntrinsics get_InvokeProvider();
}
[FlagsAttribute]
public enum System.Management.Automation.RemoteStreamOptions : Enum {
    public int value__;
    public static RemoteStreamOptions AddInvocationInfoToErrorRecord;
    public static RemoteStreamOptions AddInvocationInfoToWarningRecord;
    public static RemoteStreamOptions AddInvocationInfoToDebugRecord;
    public static RemoteStreamOptions AddInvocationInfoToVerboseRecord;
    public static RemoteStreamOptions AddInvocationInfo;
}
internal class System.Management.Automation.Remoting.AsyncObject`1 : object {
    private T _value;
    private ManualResetEvent _valueWasSet;
    internal T Value { get; internal set; }
    internal T get_Value();
    internal void set_Value(T value);
}
internal abstract class System.Management.Automation.Remoting.BaseSessionDataStructureHandler : object {
    internal abstract virtual void RaiseKeyExchangeMessageReceived(RemoteDataObject`1<PSObject> receivedData);
}
public abstract class System.Management.Automation.Remoting.BaseTransportManager : object {
    [TraceSourceAttribute("Transport", "Traces BaseWSManTransportManager")]
private static PSTraceSource s_baseTracer;
    internal static int ServerDefaultKeepAliveTimeoutMs;
    internal static int ClientDefaultOperationTimeoutMs;
    internal static int ClientCloseTimeoutMs;
    internal static int UseServerDefaultIdleTimeout;
    internal static UInt32 UseServerDefaultIdleTimeoutUInt;
    internal static int MinimumIdleTimeout;
    internal static int DefaultFragmentSize;
    internal static int MaximumReceivedDataSize;
    internal static int MaximumReceivedObjectSize;
    internal static string MAX_RECEIVED_DATA_PER_COMMAND_MB;
    internal static string MAX_RECEIVED_OBJECT_SIZE_MB;
    private OnDataAvailableCallback _onDataAvailableCallback;
    [CompilerGeneratedAttribute]
private EventHandler`1<TransportErrorOccuredEventArgs> WSManTransportErrorOccured;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs> DataReceived;
    [CompilerGeneratedAttribute]
private EventHandler PowerShellGuidObserver;
    [CompilerGeneratedAttribute]
private Fragmentor <Fragmentor>k__BackingField;
    [CompilerGeneratedAttribute]
private PSRemotingCryptoHelper <CryptoHelper>k__BackingField;
    [CompilerGeneratedAttribute]
private PriorityReceiveDataCollection <ReceivedDataCollection>k__BackingField;
    internal Fragmentor Fragmentor { get; internal set; }
    internal TypeTable TypeTable { get; internal set; }
    internal PSRemotingCryptoHelper CryptoHelper { get; internal set; }
    internal PriorityReceiveDataCollection ReceivedDataCollection { get; }
    internal BaseTransportManager(PSRemotingCryptoHelper cryptoHelper);
    private static BaseTransportManager();
    [CompilerGeneratedAttribute]
internal void add_WSManTransportErrorOccured(EventHandler`1<TransportErrorOccuredEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_WSManTransportErrorOccured(EventHandler`1<TransportErrorOccuredEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_DataReceived(EventHandler`1<RemoteDataEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_DataReceived(EventHandler`1<RemoteDataEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_PowerShellGuidObserver(EventHandler value);
    [CompilerGeneratedAttribute]
public void remove_PowerShellGuidObserver(EventHandler value);
    [CompilerGeneratedAttribute]
internal Fragmentor get_Fragmentor();
    [CompilerGeneratedAttribute]
internal void set_Fragmentor(Fragmentor value);
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    internal virtual void ProcessRawData(Byte[] data, string stream);
    internal void ProcessRawData(Byte[] data, string stream, OnDataAvailableCallback dataAvailableCallback);
    internal void OnDataAvailableCallback(RemoteDataObject`1<PSObject> remoteObject);
    public void MigrateDataReadyEventHandlers(BaseTransportManager transportManager);
    public virtual void RaiseErrorHandler(TransportErrorOccuredEventArgs eventArgs);
    [CompilerGeneratedAttribute]
internal PSRemotingCryptoHelper get_CryptoHelper();
    [CompilerGeneratedAttribute]
internal void set_CryptoHelper(PSRemotingCryptoHelper value);
    [CompilerGeneratedAttribute]
internal PriorityReceiveDataCollection get_ReceivedDataCollection();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
}
internal abstract class System.Management.Automation.Remoting.Client.BaseClientCommandTransportManager : BaseClientTransportManager {
    protected StringBuilder cmdText;
    protected SerializedDataStream serializedPipeline;
    protected Guid powershellInstanceId;
    internal bool startInDisconnectedMode;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> SignalCompleted;
    protected Guid PowershellInstanceId { get; }
    protected BaseClientCommandTransportManager(ClientRemotePowerShell shell, PSRemotingCryptoHelper cryptoHelper, BaseClientSessionTransportManager sessnTM);
    protected Guid get_PowershellInstanceId();
    [CompilerGeneratedAttribute]
internal void add_SignalCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SignalCompleted(EventHandler`1<EventArgs> value);
    internal void RaiseSignalCompleted();
    protected virtual void Dispose(bool isDisposing);
    internal virtual void ReconnectAsync();
    internal virtual void SendStopSignal();
}
public abstract class System.Management.Automation.Remoting.Client.BaseClientSessionTransportManager : BaseClientTransportManager {
    internal BaseClientSessionTransportManager(Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    internal virtual BaseClientCommandTransportManager CreateClientCommandTransportManager(RunspaceConnectionInfo connectionInfo, ClientRemotePowerShell cmd, bool noInput);
    internal virtual void RemoveCommandTransportManager(Guid powerShellCmdId);
    internal virtual void DisconnectAsync();
    internal virtual void ReconnectAsync();
    internal virtual void Redirect(Uri newUri, RunspaceConnectionInfo connectionInfo);
    internal virtual void PrepareForRedirection();
}
public abstract class System.Management.Automation.Remoting.Client.BaseClientTransportManager : BaseTransportManager {
    [TraceSourceAttribute("ClientTransport", "Traces ClientTransportManager")]
internal static PSTraceSource tracer;
    internal bool isClosed;
    internal object syncObject;
    internal PrioritySendDataCollection dataToBeSent;
    private Queue`1<CallbackNotificationInformation> _callbackNotificationQueue;
    private OnDataAvailableCallback _onDataAvailableCallback;
    private bool _isServicingCallbacks;
    private bool _suspendQueueServicing;
    private bool _isDebuggerSuspend;
    internal bool receiveDataInitiated;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreateCompleteEventArgs> CreateCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> CloseCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ConnectCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> DisconnectCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ReconnectCompleted;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ReadyForDisconnect;
    [CompilerGeneratedAttribute]
private EventHandler`1<ConnectionStatusEventArgs> RobustConnectionNotification;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> DelayStreamRequestProcessed;
    [CompilerGeneratedAttribute]
private Guid <RunspacePoolInstanceId>k__BackingField;
    internal PrioritySendDataCollection DataToBeSentCollection { get; }
    internal Guid RunspacePoolInstanceId { get; }
    internal bool IsServicing { get; }
    internal BaseClientTransportManager(Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    private static BaseClientTransportManager();
    [CompilerGeneratedAttribute]
internal void add_CreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_CreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_CloseCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_CloseCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ConnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ConnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_DisconnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_DisconnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ReconnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ReconnectCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_ReadyForDisconnect(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ReadyForDisconnect(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_RobustConnectionNotification(EventHandler`1<ConnectionStatusEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RobustConnectionNotification(EventHandler`1<ConnectionStatusEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_DelayStreamRequestProcessed(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_DelayStreamRequestProcessed(EventHandler`1<EventArgs> value);
    internal PrioritySendDataCollection get_DataToBeSentCollection();
    [CompilerGeneratedAttribute]
internal Guid get_RunspacePoolInstanceId();
    internal void RaiseCreateCompleted(CreateCompleteEventArgs eventArgs);
    internal void RaiseConnectCompleted();
    internal void RaiseDisconnectCompleted();
    internal void RaiseReconnectCompleted();
    internal void RaiseCloseCompleted();
    internal void RaiseReadyForDisconnect();
    internal void QueueRobustConnectionNotification(int flags);
    internal void RaiseRobustConnectionNotification(ConnectionStatusEventArgs args);
    internal void RaiseDelayStreamProcessedEvent();
    internal virtual void ProcessRawData(Byte[] data, string stream);
    private void OnDataAvailableHandler(RemoteDataObject`1<PSObject> remoteObject);
    internal void EnqueueAndStartProcessingThread(RemoteDataObject`1<PSObject> remoteObject, TransportErrorOccuredEventArgs transportErrorArgs, object privateData);
    private static bool CheckForInteractiveHostCall(RemoteDataObject`1<PSObject> remoteObject);
    internal void ServicePendingCallbacks(object objectToProcess);
    internal bool get_IsServicing();
    internal void SuspendQueue(bool debuggerSuspend);
    internal void ResumeQueue();
    internal virtual void ProcessPrivateData(object privateData);
    public abstract virtual void CreateAsync();
    internal abstract virtual void ConnectAsync();
    public virtual void CloseAsync();
    internal virtual void StartReceivingData();
    internal virtual void PrepareForDisconnect();
    internal virtual void PrepareForConnect();
    protected virtual override void Finalize();
    protected virtual void Dispose(bool isDisposing);
    [CompilerGeneratedAttribute]
private void <Finalize>b__66_0(object source, EventArgs args);
}
public abstract class System.Management.Automation.Remoting.Client.ClientSessionTransportManagerBase : BaseClientSessionTransportManager {
    private BlockingCollection`1<string> _sessionMessageQueue;
    private BlockingCollection`1<string> _commandMessageQueue;
    private OnDataAvailableCallback _onDataAvailableToSendCallback;
    private DataProcessingDelegates _dataProcessingCallbacks;
    private Dictionary`2<Guid, OutOfProcessClientCommandTransportManager> _cmdTransportManagers;
    private Timer _closeTimeOutTimer;
    internal PowerShellTraceSource _tracer;
    internal OutOfProcessTextWriter _messageWriter;
    private static string SESSIONDMESSAGETAG;
    protected ClientSessionTransportManagerBase(Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    internal virtual void ConnectAsync();
    public virtual void CloseAsync();
    internal virtual BaseClientCommandTransportManager CreateClientCommandTransportManager(RunspaceConnectionInfo connectionInfo, ClientRemotePowerShell cmd, bool noInput);
    protected virtual void Dispose(bool isDisposing);
    private void AddCommandTransportManager(Guid key, OutOfProcessClientCommandTransportManager cmdTM);
    internal virtual void RemoveCommandTransportManager(Guid key);
    private OutOfProcessClientCommandTransportManager GetCommandTransportManager(Guid key);
    private void OnCloseSessionCompleted();
    protected abstract virtual void CleanupConnection();
    private void ProcessMessageProc(object state);
    protected void HandleOutputDataReceived(string data);
    protected void HandleErrorDataReceived(string data);
    protected void SendOneItem();
    private void OnDataAvailableCallback(Byte[] data, DataPriorityType priorityType);
    private void SendData(Byte[] data, DataPriorityType priorityType);
    private void OnRemoteSessionSendCompleted();
    private void OnDataPacketReceived(Byte[] rawData, string stream, Guid psGuid);
    private void OnDataAckPacketReceived(Guid psGuid);
    private void OnCommandCreationPacketReceived(Guid psGuid);
    private void OnCommandCreationAckReceived(Guid psGuid);
    private void OnSignalPacketReceived(Guid psGuid);
    private void OnSignalAckPacketReceived(Guid psGuid);
    private void OnClosePacketReceived(Guid psGuid);
    private void OnCloseAckReceived(Guid psGuid);
    internal void OnCloseTimeOutTimerElapsed(object source);
    protected void HandleDataReceived(string data);
    protected void SetMessageWriter(TextWriter textWriter);
    protected void DisposeMessageQueue();
}
internal class System.Management.Automation.Remoting.Client.ContainerHyperVSocketClientSessionTransportManager : HyperVSocketClientSessionTransportManagerBase {
    private Guid _targetGuid;
    private ContainerConnectionInfo _connectionInfo;
    internal ContainerHyperVSocketClientSessionTransportManager(ContainerConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper, Guid targetGuid);
    public virtual void CreateAsync();
}
internal class System.Management.Automation.Remoting.Client.ContainerNamedPipeClientSessionTransportManager : NamedPipeClientSessionTransportManagerBase {
    private ContainerConnectionInfo _connectionInfo;
    private static string _threadName;
    internal ContainerNamedPipeClientSessionTransportManager(ContainerConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    public virtual void CreateAsync();
    protected virtual void CleanupConnection();
}
internal abstract class System.Management.Automation.Remoting.Client.HyperVSocketClientSessionTransportManagerBase : ClientSessionTransportManagerBase {
    protected RemoteSessionHyperVSocketClient _client;
    private static string _threadName;
    internal HyperVSocketClientSessionTransportManagerBase(Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void CleanupConnection();
    protected void StartReaderThread(StreamReader reader);
    protected void ProcessReaderThread(object state);
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.Remoting.Client.IWSManNativeApiFacade {
    public abstract virtual int WSManPluginGetOperationParameters(IntPtr requestDetails, int flags, WSManDataStruct data);
    public abstract virtual int WSManPluginOperationComplete(IntPtr requestDetails, int flags, int errorCode, string extendedInformation);
    public abstract virtual int WSManPluginReceiveResult(IntPtr requestDetails, int flags, string stream, IntPtr streamResult, string commandState, int exitCode);
    public abstract virtual int WSManPluginReportContext(IntPtr requestDetails, int flags, IntPtr context);
    public abstract virtual void WSManPluginRegisterShutdownCallback(IntPtr requestDetails, IntPtr shutdownCallback, IntPtr shutdownContext);
}
internal class System.Management.Automation.Remoting.Client.NamedPipeClientSessionTransportManager : NamedPipeClientSessionTransportManagerBase {
    private NamedPipeConnectionInfo _connectionInfo;
    private static string _threadName;
    internal NamedPipeClientSessionTransportManager(NamedPipeConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    public virtual void CreateAsync();
    public void AbortConnect();
}
internal abstract class System.Management.Automation.Remoting.Client.NamedPipeClientSessionTransportManagerBase : ClientSessionTransportManagerBase {
    private RunspaceConnectionInfo _connectionInfo;
    protected NamedPipeClientBase _clientPipe;
    private string _threadName;
    internal NamedPipeClientSessionTransportManagerBase(RunspaceConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper, string threadName);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void CleanupConnection();
    protected void StartReaderThread(StreamReader reader);
    private void ProcessReaderThread(object state);
}
internal class System.Management.Automation.Remoting.Client.OutOfProcessClientCommandTransportManager : BaseClientCommandTransportManager {
    private OutOfProcessTextWriter _stdInWriter;
    private OnDataAvailableCallback _onDataAvailableToSendCallback;
    private Timer _signalTimeOutTimer;
    internal OutOfProcessClientCommandTransportManager(ClientRemotePowerShell cmd, bool noInput, ClientSessionTransportManagerBase sessnTM, OutOfProcessTextWriter stdInWriter);
    internal virtual void ConnectAsync();
    public virtual void CreateAsync();
    public virtual void CloseAsync();
    internal virtual void SendStopSignal();
    protected virtual void Dispose(bool isDisposing);
    internal void OnCreateCmdCompleted();
    internal void OnRemoteCmdSendCompleted();
    internal void OnRemoteCmdDataReceived(Byte[] rawData, string stream);
    internal void OnRemoteCmdSignalCompleted();
    internal void OnSignalTimeOutTimerElapsed(object source);
    private void StopSignalTimerAndDecrementOperations();
    internal virtual void ProcessPrivateData(object privateData);
    internal void OnCloseCmdCompleted();
    private void SendOneItem();
    private void SendData(Byte[] data, DataPriorityType priorityType);
    private void OnDataAvailableCallback(Byte[] data, DataPriorityType priorityType);
}
internal class System.Management.Automation.Remoting.Client.OutOfProcessClientSessionTransportManager : ClientSessionTransportManagerBase {
    private Process _serverProcess;
    private NewProcessConnectionInfo _connectionInfo;
    private bool _processCreated;
    private PowerShellProcessInstance _processInstance;
    internal OutOfProcessClientSessionTransportManager(Guid runspaceId, NewProcessConnectionInfo connectionInfo, PSRemotingCryptoHelper cryptoHelper);
    public virtual void CreateAsync();
    private void StartRedirectionReaderThreads(Process serverProcess);
    private void ProcessOutputData(object arg);
    private void ProcessErrorData(object arg);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void CleanupConnection();
    private void KillServerProcess();
    private void OnExited(object sender, EventArgs e);
}
internal class System.Management.Automation.Remoting.Client.SSHClientSessionTransportManager : ClientSessionTransportManagerBase {
    private SSHConnectionInfo _connectionInfo;
    private int _sshProcessId;
    private StreamWriter _stdInWriter;
    private StreamReader _stdOutReader;
    private StreamReader _stdErrReader;
    private bool _connectionEstablished;
    private Timer _connectionTimer;
    private static string _threadName;
    internal SSHClientSessionTransportManager(SSHConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper);
    protected virtual void Dispose(bool isDisposing);
    protected virtual void CleanupConnection();
    public virtual void CreateAsync();
    public virtual void CloseAsync();
    private void CloseConnection();
    private void StartErrorThread(StreamReader stdErrReader);
    private void ProcessErrorThread(object state);
    private void HandleSSHError(PSRemotingTransportException psrte);
    private void StartReaderThread(StreamReader reader);
    private void ProcessReaderThread(object state);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void <CreateAsync>b__11_0(object _);
}
internal class System.Management.Automation.Remoting.Client.VMHyperVSocketClientSessionTransportManager : HyperVSocketClientSessionTransportManagerBase {
    private Guid _vmGuid;
    private string _configurationName;
    private VMConnectionInfo _connectionInfo;
    private NetworkCredential _networkCredential;
    internal VMHyperVSocketClientSessionTransportManager(VMConnectionInfo connectionInfo, Guid runspaceId, PSRemotingCryptoHelper cryptoHelper, Guid vmGuid, string configurationName);
    public virtual void CreateAsync();
}
internal class System.Management.Automation.Remoting.Client.WSManClientCommandTransportManager : BaseClientCommandTransportManager {
    internal static string StopSignal;
    private IntPtr _wsManShellOperationHandle;
    private IntPtr _wsManCmdOperationHandle;
    private IntPtr _cmdSignalOperationHandle;
    private IntPtr _wsManReceiveOperationHandle;
    private IntPtr _wsManSendOperationHandle;
    private long _cmdContextId;
    private OnDataAvailableCallback _onDataAvailableToSendCallback;
    private bool _shouldStartReceivingData;
    private bool _isCreateCallbackReceived;
    private bool _isStopSignalPending;
    private bool _isDisconnectPending;
    private bool _isSendingInput;
    private bool _isDisconnectedOnInvoke;
    private WSManShellAsync _createCmdCompleted;
    private WSManShellAsync _receivedFromRemote;
    private WSManShellAsync _sendToRemoteCompleted;
    private WSManShellAsync _reconnectCmdCompleted;
    private WSManShellAsync _connectCmdCompleted;
    private GCHandle _createCmdCompletedGCHandle;
    private WSManShellAsync _closeCmdCompleted;
    private WSManShellAsync _signalCmdCompleted;
    private SendDataChunk _chunkToSend;
    private string _cmdLine;
    private WSManClientSessionTransportManager _sessnTm;
    private static WSManShellAsyncCallback s_cmdCreateCallback;
    private static WSManShellAsyncCallback s_cmdCloseCallback;
    private static WSManShellAsyncCallback s_cmdReceiveCallback;
    private static WSManShellAsyncCallback s_cmdSendCallback;
    private static WSManShellAsyncCallback s_cmdSignalCallback;
    private static WSManShellAsyncCallback s_cmdReconnectCallback;
    private static WSManShellAsyncCallback s_cmdConnectCallback;
    private static Delegate s_commandCodeSendRedirect;
    private static Delegate s_commandSendRedirect;
    private static Dictionary`2<long, WSManClientCommandTransportManager> s_cmdTMHandles;
    private static long s_cmdTMSeed;
    private static WSManClientCommandTransportManager();
    internal WSManClientCommandTransportManager(WSManConnectionInfo connectionInfo, IntPtr wsManShellOperationHandle, ClientRemotePowerShell shell, bool noInput, WSManClientSessionTransportManager sessnTM);
    private void HandleRobustConnectionsInitiated(object sender, EventArgs e);
    private void HandleRobusConnectionsCompleted(object sender, EventArgs e);
    internal virtual void ConnectAsync();
    public virtual void CreateAsync();
    internal virtual void ReconnectAsync();
    internal virtual void SendStopSignal();
    public virtual void CloseAsync();
    internal void ProcessWSManTransportError(TransportErrorOccuredEventArgs eventArgs);
    public virtual void RaiseErrorHandler(TransportErrorOccuredEventArgs eventArgs);
    internal virtual void ProcessPrivateData(object privateData);
    internal void ClearReceiveOrSendResources(int flags, bool shouldClearSend);
    internal virtual void PrepareForDisconnect();
    internal virtual void PrepareForConnect();
    private static void OnCreateCmdCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnConnectCmdCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnCloseCmdCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteCmdSendCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteCmdDataReceived(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnReconnectCmdCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteCmdSignalCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private void SendOneItem();
    private void OnDataAvailableCallback(Byte[] data, DataPriorityType priorityType);
    private void SendData(Byte[] data, DataPriorityType priorityType);
    internal virtual void StartReceivingData();
    protected virtual void Dispose(bool isDisposing);
    private static long GetNextCmdTMHandleId();
    private static void AddCmdTransportManager(long cmdTMId, WSManClientCommandTransportManager cmdTransportManager);
    private static void RemoveCmdTransportManager(long cmdTMId);
    private static bool TryGetCmdTransportManager(IntPtr operationContext, WSManClientCommandTransportManager& cmdTransportManager, Int64& cmdTMId);
}
internal class System.Management.Automation.Remoting.Client.WSManClientSessionTransportManager : BaseClientSessionTransportManager {
    internal static string MAX_URI_REDIRECTION_COUNT_VARIABLE;
    internal static int MAX_URI_REDIRECTION_COUNT;
    private IntPtr _wsManSessionHandle;
    private IntPtr _wsManShellOperationHandle;
    private IntPtr _wsManReceiveOperationHandle;
    private IntPtr _wsManSendOperationHandle;
    private long _sessionContextID;
    private tmStartModes _startMode;
    private string _sessionName;
    private OnDataAvailableCallback _onDataAvailableToSendCallback;
    private WSManShellAsync _createSessionCallback;
    private WSManShellAsync _receivedFromRemote;
    private WSManShellAsync _sendToRemoteCompleted;
    private WSManShellAsync _disconnectSessionCompleted;
    private WSManShellAsync _reconnectSessionCompleted;
    private WSManShellAsync _connectSessionCallback;
    private GCHandle _createSessionCallbackGCHandle;
    private WSManShellAsync _closeSessionCompleted;
    private WSManData_ManToUn _openContent;
    private bool _noCompression;
    private bool _noMachineProfile;
    private int _connectionRetryCount;
    private static string resBaseName;
    private int _maxRetryTime;
    private static WSManShellAsyncCallback s_sessionCreateCallback;
    private static WSManShellAsyncCallback s_sessionCloseCallback;
    private static WSManShellAsyncCallback s_sessionReceiveCallback;
    private static WSManShellAsyncCallback s_sessionSendCallback;
    private static WSManShellAsyncCallback s_sessionDisconnectCallback;
    private static WSManShellAsyncCallback s_sessionReconnectCallback;
    private static WSManShellAsyncCallback s_sessionConnectCallback;
    private static Dictionary`2<long, WSManClientSessionTransportManager> s_sessionTMHandles;
    private static long s_sessionTMSeed;
    private static Delegate s_sessionSendRedirect;
    private static Delegate s_protocolVersionRedirect;
    [CompilerGeneratedAttribute]
private WSManAPIDataCommon <WSManAPIData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SupportsDisconnect>k__BackingField;
    [CompilerGeneratedAttribute]
private WSManConnectionInfo <ConnectionInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> RobustConnectionsInitiated;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> RobustConnectionsCompleted;
    internal WSManAPIDataCommon WSManAPIData { get; private set; }
    internal bool SupportsDisconnect { get; private set; }
    internal int MaxRetryConnectionTime { get; }
    internal IntPtr SessionHandle { get; }
    internal WSManConnectionInfo ConnectionInfo { get; private set; }
    private static WSManClientSessionTransportManager();
    internal WSManClientSessionTransportManager(Guid runspacePoolInstanceId, WSManConnectionInfo connectionInfo, PSRemotingCryptoHelper cryptoHelper, string sessionName);
    private void ProcessShellData(string data);
    private static long GetNextSessionTMHandleId();
    private static void AddSessionTransportManager(long sessnTMId, WSManClientSessionTransportManager sessnTransportManager);
    private static void RemoveSessionTransportManager(long sessnTMId);
    private static bool TryGetSessionTransportManager(IntPtr operationContext, WSManClientSessionTransportManager& sessnTransportManager, Int64& sessnTMId);
    internal void SetDefaultTimeOut(int milliseconds);
    internal void SetConnectTimeOut(int milliseconds);
    internal void SetCloseTimeOut(int milliseconds);
    internal void SetSendTimeOut(int milliseconds);
    internal void SetReceiveTimeOut(int milliseconds);
    internal void SetSignalTimeOut(int milliseconds);
    internal void SetWSManSessionOption(WSManSessionOption option, int dwordData);
    internal void SetWSManSessionOption(WSManSessionOption option, string stringData);
    [CompilerGeneratedAttribute]
internal WSManAPIDataCommon get_WSManAPIData();
    [CompilerGeneratedAttribute]
private void set_WSManAPIData(WSManAPIDataCommon value);
    [CompilerGeneratedAttribute]
internal bool get_SupportsDisconnect();
    [CompilerGeneratedAttribute]
private void set_SupportsDisconnect(bool value);
    internal virtual void DisconnectAsync();
    internal virtual void ReconnectAsync();
    internal virtual void ConnectAsync();
    internal virtual void StartReceivingData();
    public virtual void CreateAsync();
    public virtual void CloseAsync();
    internal void AdjustForProtocolVariations(Version serverProtocolVersion);
    internal virtual void PrepareForRedirection();
    internal virtual void Redirect(Uri newUri, RunspaceConnectionInfo connectionInfo);
    internal virtual BaseClientCommandTransportManager CreateClientCommandTransportManager(RunspaceConnectionInfo connectionInfo, ClientRemotePowerShell cmd, bool noInput);
    private void Initialize(Uri connectionUri, WSManConnectionInfo connectionInfo);
    internal void ProcessWSManTransportError(TransportErrorOccuredEventArgs eventArgs);
    public virtual void RaiseErrorHandler(TransportErrorOccuredEventArgs eventArgs);
    internal void ClearReceiveOrSendResources(int flags, bool shouldClearSend);
    internal virtual void ProcessPrivateData(object privateData);
    internal int get_MaxRetryConnectionTime();
    internal IntPtr get_SessionHandle();
    [CompilerGeneratedAttribute]
internal WSManConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
private void set_ConnectionInfo(WSManConnectionInfo value);
    private bool RetrySessionCreation(int sessionCreateErrorCode);
    private void StartCreateRetry(object state);
    private static void OnCreateSessionCallback(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnCloseSessionCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteSessionDisconnectCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteSessionReconnectCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static bool HandleRobustConnectionCallback(int flags, WSManClientSessionTransportManager sessionTM);
    private static void OnRemoteSessionConnectCallback(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteSessionSendCompleted(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private static void OnRemoteSessionDataReceived(IntPtr operationContext, int flags, IntPtr error, IntPtr shellOperationHandle, IntPtr commandOperationHandle, IntPtr operationHandle, IntPtr data);
    private void SendOneItem();
    private void OnDataAvailableCallback(Byte[] data, DataPriorityType priorityType);
    private void SendData(Byte[] data, DataPriorityType priorityType);
    protected virtual void Dispose(bool isDisposing);
    private void CloseSessionAndClearResources();
    private void DisposeWSManAPIDataAsync();
    [CompilerGeneratedAttribute]
internal void add_RobustConnectionsInitiated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RobustConnectionsInitiated(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_RobustConnectionsCompleted(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RobustConnectionsCompleted(EventHandler`1<EventArgs> value);
}
internal static class System.Management.Automation.Remoting.Client.WSManNativeApi : object {
    internal static UInt32 INFINITE;
    internal static string PS_CREATION_XML_TAG;
    internal static string PS_CONNECT_XML_TAG;
    internal static string PS_CONNECTRESPONSE_XML_TAG;
    internal static string PS_XML_NAMESPACE;
    internal static string WSMAN_STREAM_ID_STDOUT;
    internal static string WSMAN_STREAM_ID_PROMPTRESPONSE;
    internal static string WSMAN_STREAM_ID_STDIN;
    internal static string ResourceURIPrefix;
    internal static string NoProfile;
    internal static string CodePage;
    internal static Version WSMAN_STACK_VERSION;
    internal static int WSMAN_FLAG_REQUESTED_API_VERSION_1_1;
    internal static int WSMAN_DEFAULT_MAX_ENVELOPE_SIZE_KB_V2;
    internal static int WSMAN_DEFAULT_MAX_ENVELOPE_SIZE_KB_V3;
    internal static int ERROR_WSMAN_REDIRECT_REQUESTED;
    internal static int ERROR_WSMAN_INVALID_RESOURCE_URI;
    internal static int ERROR_WSMAN_INUSE_CANNOT_RECONNECT;
    internal static int ERROR_WSMAN_SENDDATA_CANNOT_CONNECT;
    internal static int ERROR_WSMAN_SENDDATA_CANNOT_COMPLETE;
    internal static int ERROR_WSMAN_ACCESS_DENIED;
    internal static int ERROR_WSMAN_OUTOF_MEMORY;
    internal static int ERROR_WSMAN_NETWORKPATH_NOTFOUND;
    internal static int ERROR_WSMAN_OPERATION_ABORTED;
    internal static int ERROR_WSMAN_SHUTDOWN_INPROGRESS;
    internal static int ERROR_WSMAN_AUTHENTICATION_FAILED;
    internal static int ERROR_WSMAN_NO_LOGON_SESSION_EXIST;
    internal static int ERROR_WSMAN_LOGON_FAILURE;
    internal static int ERROR_WSMAN_IMPROPER_RESPONSE;
    internal static int ERROR_WSMAN_INCORRECT_PROTOCOLVERSION;
    internal static int ERROR_WSMAN_URL_NOTAVAILABLE;
    internal static int ERROR_WSMAN_INVALID_AUTHENTICATION;
    internal static int ERROR_WSMAN_CANNOT_CONNECT_INVALID;
    internal static int ERROR_WSMAN_CANNOT_CONNECT_MISMATCH;
    internal static int ERROR_WSMAN_CANNOT_CONNECT_RUNASFAILED;
    internal static int ERROR_WSMAN_CREATEFAILED_INVALIDNAME;
    internal static int ERROR_WSMAN_TARGETSESSION_DOESNOTEXIST;
    internal static int ERROR_WSMAN_REMOTESESSION_DISALLOWED;
    internal static int ERROR_WSMAN_REMOTECONNECTION_DISALLOWED;
    internal static int ERROR_WSMAN_INVALID_RESOURCE_URI2;
    internal static int ERROR_WSMAN_CORRUPTED_CONFIG;
    internal static int ERROR_WSMAN_URI_LIMIT;
    internal static int ERROR_WSMAN_CLIENT_KERBEROS_DISABLED;
    internal static int ERROR_WSMAN_SERVER_NOTTRUSTED;
    internal static int ERROR_WSMAN_WORKGROUP_NO_KERBEROS;
    internal static int ERROR_WSMAN_EXPLICIT_CREDENTIALS_REQUIRED;
    internal static int ERROR_WSMAN_REDIRECT_LOCATION_INVALID;
    internal static int ERROR_WSMAN_BAD_METHOD;
    internal static int ERROR_WSMAN_HTTP_SERVICE_UNAVAILABLE;
    internal static int ERROR_WSMAN_HTTP_SERVICE_ERROR;
    internal static int ERROR_WSMAN_COMPUTER_NOTFOUND;
    internal static int ERROR_WSMAN_TARGET_UNKNOWN;
    internal static int ERROR_WSMAN_CANNOTUSE_IP;
    internal static string WSManClientApiDll;
    internal static string WSManProviderApiDll;
    internal static string WSMAN_SHELL_NAMESPACE;
    internal static string WSMAN_COMMAND_STATE_DONE;
    internal static string WSMAN_COMMAND_STATE_PENDING;
    internal static string WSMAN_COMMAND_STATE_RUNNING;
    private static WSManNativeApi();
    internal static int WSManInitialize(int flags, IntPtr& wsManAPIHandle);
    internal static int WSManDeinitialize(IntPtr wsManAPIHandle, int flags);
    internal static int WSManCreateSession(IntPtr wsManAPIHandle, string connection, int flags, IntPtr authenticationCredentials, IntPtr proxyInfo, IntPtr& wsManSessionHandle);
    internal static void WSManCloseSession(IntPtr wsManSessionHandle, int flags);
    internal static int WSManSetSessionOption(IntPtr wsManSessionHandle, WSManSessionOption option, WSManDataDWord data);
    internal static int WSManSetSessionOption(IntPtr wsManSessionHandle, WSManSessionOption option, IntPtr data);
    internal static int WSManGetSessionOptionAsDword(IntPtr wsManSessionHandle, WSManSessionOption option, Int32& value);
    internal static string WSManGetSessionOptionAsString(IntPtr wsManAPIHandle, WSManSessionOption option);
    private static int WSManGetSessionOptionAsString(IntPtr wsManSessionHandle, WSManSessionOption option, int optionLength, Byte[] optionAsString, Int32& optionLengthUsed);
    internal static void WSManCreateShellEx(IntPtr wsManSessionHandle, int flags, string resourceUri, string shellId, WSManShellStartupInfo_ManToUn startupInfo, WSManOptionSet optionSet, WSManData_ManToUn openContent, IntPtr asyncCallback, IntPtr& shellOperationHandle);
    private static void WSManCreateShellExInternal(IntPtr wsManSessionHandle, int flags, string resourceUri, string shellId, IntPtr startupInfo, IntPtr optionSet, IntPtr openContent, IntPtr asyncCallback, IntPtr& shellOperationHandle);
    internal static void WSManConnectShellEx(IntPtr wsManSessionHandle, int flags, string resourceUri, string shellId, IntPtr optionSet, IntPtr connectXml, IntPtr asyncCallback, IntPtr& shellOperationHandle);
    internal static void WSManDisconnectShellEx(IntPtr wsManSessionHandle, int flags, IntPtr disconnectInfo, IntPtr asyncCallback);
    internal static void WSManReconnectShellEx(IntPtr wsManSessionHandle, int flags, IntPtr asyncCallback);
    internal static void WSManReconnectShellCommandEx(IntPtr wsManCommandHandle, int flags, IntPtr asyncCallback);
    internal static void WSManRunShellCommandEx(IntPtr shellOperationHandle, int flags, string commandId, string commandLine, IntPtr commandArgSet, IntPtr optionSet, IntPtr asyncCallback, IntPtr& commandOperationHandle);
    internal static void WSManConnectShellCommandEx(IntPtr shellOperationHandle, int flags, string commandID, IntPtr optionSet, IntPtr connectXml, IntPtr asyncCallback, IntPtr& commandOperationHandle);
    internal static void WSManReceiveShellOutputEx(IntPtr shellOperationHandle, IntPtr commandOperationHandle, int flags, IntPtr desiredStreamSet, IntPtr asyncCallback, IntPtr& receiveOperationHandle);
    internal static void WSManSendShellInputEx(IntPtr shellOperationHandle, IntPtr commandOperationHandle, int flags, string streamId, WSManData_ManToUn streamData, IntPtr asyncCallback, IntPtr& sendOperationHandle);
    private static void WSManSendShellInputExInternal(IntPtr shellOperationHandle, IntPtr commandOperationHandle, int flags, string streamId, IntPtr streamData, bool endOfStream, IntPtr asyncCallback, IntPtr& sendOperationHandle);
    internal static void WSManCloseShell(IntPtr shellHandle, int flags, IntPtr asyncCallback);
    internal static void WSManCloseCommand(IntPtr cmdHandle, int flags, IntPtr asyncCallback);
    internal static void WSManSignalShellEx(IntPtr shellOperationHandle, IntPtr cmdOperationHandle, int flags, string code, IntPtr asyncCallback, IntPtr& signalOperationHandle);
    internal static void WSManCloseOperation(IntPtr operationHandle, int flags);
    internal static string WSManGetErrorMessage(IntPtr wsManAPIHandle, int errorCode);
    internal static int WSManGetErrorMessage(IntPtr wsManAPIHandle, int flags, string languageCode, int errorCode, int messageLength, Byte[] message, Int32& messageLengthUsed);
    internal static int WSManPluginGetOperationParameters(IntPtr requestDetails, int flags, WSManDataStruct data);
    internal static int WSManPluginOperationComplete(IntPtr requestDetails, int flags, int errorCode, string extendedInformation);
    internal static int WSManPluginReceiveResult(IntPtr requestDetails, int flags, string stream, IntPtr streamResult, string commandState, int exitCode);
    internal static int WSManPluginReportContext(IntPtr requestDetails, int flags, IntPtr context);
}
internal class System.Management.Automation.Remoting.Client.WSManNativeApiFacade : object {
    private sealed virtual override int System.Management.Automation.Remoting.Client.IWSManNativeApiFacade.WSManPluginGetOperationParameters(IntPtr requestDetails, int flags, WSManDataStruct data);
    private sealed virtual override int System.Management.Automation.Remoting.Client.IWSManNativeApiFacade.WSManPluginOperationComplete(IntPtr requestDetails, int flags, int errorCode, string extendedInformation);
    private sealed virtual override int System.Management.Automation.Remoting.Client.IWSManNativeApiFacade.WSManPluginReceiveResult(IntPtr requestDetails, int flags, string stream, IntPtr streamResult, string commandState, int exitCode);
    private sealed virtual override int System.Management.Automation.Remoting.Client.IWSManNativeApiFacade.WSManPluginReportContext(IntPtr requestDetails, int flags, IntPtr context);
    private sealed virtual override void System.Management.Automation.Remoting.Client.IWSManNativeApiFacade.WSManPluginRegisterShutdownCallback(IntPtr requestDetails, IntPtr shutdownCallback, IntPtr shutdownContext);
}
internal static class System.Management.Automation.Remoting.Client.WSManTransportManagerUtils : object {
    private static Dictionary`2<int, string> s_transportErrorCodeToFQEID;
    private static WSManTransportManagerUtils();
    internal static TransportErrorOccuredEventArgs ConstructTransportErrorEventArgs(IntPtr wsmanAPIHandle, WSManClientSessionTransportManager wsmanSessionTM, WSManError errorStruct, TransportMethodEnum transportMethodReportingError, string resourceString, Object[] resourceArgs);
    internal static string ParseEscapeWSManErrorMessage(string errorMessage);
    internal static string GetFQEIDFromTransportError(int transportErrorCode, string defaultFQEID);
}
internal class System.Management.Automation.Remoting.ClientMethodExecutor : object {
    private BaseClientTransportManager _transportManager;
    private PSHost _clientHost;
    private Guid _clientRunspacePoolId;
    private Guid _clientPowerShellId;
    private RemoteHostCall _remoteHostCall;
    internal RemoteHostCall RemoteHostCall { get; }
    private ClientMethodExecutor(BaseClientTransportManager transportManager, PSHost clientHost, Guid clientRunspacePoolId, Guid clientPowerShellId, RemoteHostCall remoteHostCall);
    internal RemoteHostCall get_RemoteHostCall();
    internal static void Dispatch(BaseClientTransportManager transportManager, PSHost clientHost, PSDataCollectionStream`1<ErrorRecord> errorStream, ObjectStream methodExecutorStream, bool isMethodExecutorStreamEnabled, RemoteRunspacePoolInternal runspacePool, Guid clientPowerShellId, RemoteHostCall remoteHostCall);
    private static bool IsRunspacePushed(PSHost host);
    internal void Execute(PSDataCollectionStream`1<ErrorRecord> errorStream);
    internal void Execute(Cmdlet cmdlet);
    internal void Execute(Action`1<ErrorRecord> writeErrorAction);
    internal void ExecuteVoid(Action`1<ErrorRecord> writeErrorAction);
}
internal abstract class System.Management.Automation.Remoting.ClientRemoteSession : RemoteSession {
    [TraceSourceAttribute("CRSession", "ClientRemoteSession")]
private static PSTraceSource s_trace;
    [CompilerGeneratedAttribute]
private ClientRemoteSessionContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ClientRemoteSessionDataStructureHandler <SessionDataStructureHandler>k__BackingField;
    protected Version _serverProtocolVersion;
    private RemoteRunspacePoolInternal _remoteRunspacePool;
    internal ClientRemoteSessionContext Context { get; }
    internal ClientRemoteSessionDataStructureHandler SessionDataStructureHandler { get; internal set; }
    internal Version ServerProtocolVersion { get; }
    internal RemoteRunspacePoolInternal RemoteRunspacePoolInternal { get; internal set; }
    private static ClientRemoteSession();
    public abstract virtual void CreateAsync();
    [CompilerGeneratedAttribute]
public abstract virtual void add_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    public abstract virtual void CloseAsync();
    public abstract virtual void DisconnectAsync();
    public abstract virtual void ReconnectAsync();
    public abstract virtual void ConnectAsync();
    [CompilerGeneratedAttribute]
internal ClientRemoteSessionContext get_Context();
    [CompilerGeneratedAttribute]
internal ClientRemoteSessionDataStructureHandler get_SessionDataStructureHandler();
    [CompilerGeneratedAttribute]
internal void set_SessionDataStructureHandler(ClientRemoteSessionDataStructureHandler value);
    internal Version get_ServerProtocolVersion();
    internal RemoteRunspacePoolInternal get_RemoteRunspacePoolInternal();
    internal void set_RemoteRunspacePoolInternal(RemoteRunspacePoolInternal value);
    internal RemoteRunspacePoolInternal GetRunspacePool(Guid clientRunspacePoolId);
}
internal class System.Management.Automation.Remoting.ClientRemoteSessionContext : object {
    [CompilerGeneratedAttribute]
private Uri <RemoteAddress>k__BackingField;
    [CompilerGeneratedAttribute]
private PSCredential <UserCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <ClientCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <ServerCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ShellName>k__BackingField;
    internal Uri RemoteAddress { get; internal set; }
    internal PSCredential UserCredential { get; internal set; }
    internal RemoteSessionCapability ClientCapability { get; internal set; }
    internal RemoteSessionCapability ServerCapability { get; internal set; }
    internal string ShellName { get; internal set; }
    [CompilerGeneratedAttribute]
internal Uri get_RemoteAddress();
    [CompilerGeneratedAttribute]
internal void set_RemoteAddress(Uri value);
    [CompilerGeneratedAttribute]
internal PSCredential get_UserCredential();
    [CompilerGeneratedAttribute]
internal void set_UserCredential(PSCredential value);
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_ClientCapability();
    [CompilerGeneratedAttribute]
internal void set_ClientCapability(RemoteSessionCapability value);
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_ServerCapability();
    [CompilerGeneratedAttribute]
internal void set_ServerCapability(RemoteSessionCapability value);
    [CompilerGeneratedAttribute]
internal string get_ShellName();
    [CompilerGeneratedAttribute]
internal void set_ShellName(string value);
}
internal abstract class System.Management.Automation.Remoting.ClientRemoteSessionDataStructureHandler : BaseSessionDataStructureHandler {
    internal ClientRemoteSessionDSHandlerStateMachine StateMachine { get; }
    internal BaseClientSessionTransportManager TransportManager { get; }
    internal abstract virtual void CreateAsync();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_ConnectionStateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_ConnectionStateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    internal abstract virtual void SendNegotiationAsync(RemoteSessionState sessionState);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    internal abstract virtual void CloseConnectionAsync();
    internal abstract virtual void DisconnectAsync();
    internal abstract virtual void ReconnectAsync();
    internal abstract virtual ClientRemoteSessionDSHandlerStateMachine get_StateMachine();
    internal abstract virtual BaseClientSessionTransportManager get_TransportManager();
    internal abstract virtual BaseClientCommandTransportManager CreateClientCommandTransportManager(ClientRemotePowerShell cmd, bool noInput);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_EncryptedSessionKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_EncryptedSessionKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_PublicKeyRequestReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_PublicKeyRequestReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    internal abstract virtual void SendPublicKeyAsync(string localPublicKey);
}
internal class System.Management.Automation.Remoting.ClientRemoteSessionDSHandlerImpl : ClientRemoteSessionDataStructureHandler {
    [TraceSourceAttribute("CRSDSHdlerImpl", "ClientRemoteSessionDSHandlerImpl")]
private static PSTraceSource s_trace;
    private static string resBaseName;
    private BaseClientSessionTransportManager _transportManager;
    private ClientRemoteSessionDSHandlerStateMachine _stateMachine;
    private ClientRemoteSession _session;
    private RunspaceConnectionInfo _connectionInfo;
    private Uri _redirectUri;
    private int _maxUriRedirectionCount;
    private bool _isCloseCalled;
    private object _syncObject;
    private PSRemotingCryptoHelper _cryptoHelper;
    private URIDirectionReported _uriRedirectionHandler;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteSessionNegotiationEventArgs> NegotiationReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteSessionStateEventArgs> ConnectionStateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<string>> EncryptedSessionKeyReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<string>> PublicKeyRequestReceived;
    internal BaseClientSessionTransportManager TransportManager { get; }
    internal ClientRemoteSessionDSHandlerStateMachine StateMachine { get; }
    internal ClientRemoteSessionDSHandlerImpl(ClientRemoteSession session, PSRemotingCryptoHelper cryptoHelper, RunspaceConnectionInfo connectionInfo, URIDirectionReported uriRedirectionHandler);
    private static ClientRemoteSessionDSHandlerImpl();
    internal virtual BaseClientSessionTransportManager get_TransportManager();
    internal virtual BaseClientCommandTransportManager CreateClientCommandTransportManager(ClientRemotePowerShell cmd, bool noInput);
    internal virtual void CreateAsync();
    private void HandleCreateComplete(object sender, EventArgs args);
    private void HandleConnectComplete(object sender, EventArgs args);
    internal virtual void DisconnectAsync();
    private void HandleDisconnectComplete(object sender, EventArgs args);
    private void HandleRobustConnectionNotification(object sender, ConnectionStatusEventArgs e);
    internal virtual void ReconnectAsync();
    private void HandleReconnectComplete(object sender, EventArgs args);
    internal virtual void CloseConnectionAsync();
    private void HandleCloseComplete(object sender, EventArgs args);
    internal virtual void SendNegotiationAsync(RemoteSessionState sessionState);
    [CompilerGeneratedAttribute]
internal virtual void add_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void add_ConnectionStateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_ConnectionStateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    private void HandleStateChanged(object sender, RemoteSessionStateEventArgs arg);
    private void HandleNegotiationSendingStateChange();
    internal virtual ClientRemoteSessionDSHandlerStateMachine get_StateMachine();
    private void PerformURIRedirection(string newURIString);
    private void HandleTransportCloseCompleteForRedirection(object source, EventArgs args);
    private void HandleTransportErrorForRedirection(object sender, TransportErrorOccuredEventArgs e);
    private void PerformURIRedirectionStep2(Uri newURI);
    internal void HandleTransportError(object sender, TransportErrorOccuredEventArgs e);
    internal void DispatchInputQueueData(object sender, RemoteDataEventArgs dataArg);
    private void ProcessSessionMessages(RemoteDataEventArgs arg);
    internal void ProcessNonSessionMessages(RemoteDataObject`1<PSObject> rcvdData);
    public sealed virtual void Dispose();
    protected void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
internal virtual void add_EncryptedSessionKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_EncryptedSessionKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal virtual void add_PublicKeyRequestReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_PublicKeyRequestReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    internal virtual void SendPublicKeyAsync(string localPublicKey);
    internal virtual void RaiseKeyExchangeMessageReceived(RemoteDataObject`1<PSObject> receivedData);
}
internal class System.Management.Automation.Remoting.ClientRemoteSessionDSHandlerStateMachine : object {
    [TraceSourceAttribute("CRSessionFSM", "CRSessionFSM")]
private static PSTraceSource s_trace;
    private EventHandler`1[0...,0...] _stateMachineHandle;
    private Queue`1<RemoteSessionStateEventArgs> _clientRemoteSessionStateChangeQueue;
    private RemoteSessionState _state;
    private Queue`1<RemoteSessionStateMachineEventArgs> _processPendingEventsQueue;
    private object _syncObject;
    private bool _eventsInProcess;
    private Timer _keyExchangeTimer;
    private bool _keyExchanged;
    private bool _pendingDisconnect;
    private Guid _id;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteSessionStateEventArgs> StateChanged;
    internal RemoteSessionState State { get; }
    private static ClientRemoteSessionDSHandlerStateMachine();
    private void ProcessEvents();
    private void HandleFatalError(Exception ex);
    private void RaiseStateMachineEvents();
    private void SetStateHandler(object sender, RemoteSessionStateMachineEventArgs eventArgs);
    private void HandleKeyExchangeTimeout(object sender);
    private void SetStateToClosedHandler(object sender, RemoteSessionStateMachineEventArgs eventArgs);
    internal bool CanByPassRaiseEvent(RemoteSessionStateMachineEventArgs arg);
    internal void RaiseEvent(RemoteSessionStateMachineEventArgs arg, bool clearQueuedEvents);
    private void RaiseEventPrivate(RemoteSessionStateMachineEventArgs arg);
    internal RemoteSessionState get_State();
    [CompilerGeneratedAttribute]
internal void add_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    private void DoCreateSession(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoConnectSession(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoNegotiationSending(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoDisconnectDuringKeyExchange(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoDisconnect(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoReconnect(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoRCDisconnectStarted(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoClose(object sender, RemoteSessionStateMachineEventArgs arg);
    private void DoFatal(object sender, RemoteSessionStateMachineEventArgs eventArgs);
    private static void CleanAll();
    private void SetState(RemoteSessionState newState, Exception reason);
}
internal class System.Management.Automation.Remoting.ClientRemoteSessionImpl : ClientRemoteSession {
    [TraceSourceAttribute("CRSessionImpl", "ClientRemoteSessionImpl")]
private static PSTraceSource s_trace;
    private PSRemotingCryptoHelperClient _cryptoHelper;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteSessionStateEventArgs> StateChanged;
    private ManualResetEvent _waitHandleForConfigurationReceived;
    [CompilerGeneratedAttribute]
private RemotingDestination <MySelf>k__BackingField;
    internal RemotingDestination MySelf { get; }
    internal ClientRemoteSessionImpl(RemoteRunspacePoolInternal rsPool, URIDirectionReported uriRedirectionHandler);
    private static ClientRemoteSessionImpl();
    public virtual void CreateAsync();
    public virtual void ConnectAsync();
    public virtual void CloseAsync();
    public virtual void DisconnectAsync();
    public virtual void ReconnectAsync();
    [CompilerGeneratedAttribute]
public virtual void add_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_StateChanged(EventHandler`1<RemoteSessionStateEventArgs> value);
    private void HandleConnectionStateChanged(object sender, RemoteSessionStateEventArgs arg);
    internal virtual void StartKeyExchange();
    internal virtual void CompleteKeyExchange();
    private void HandleEncryptedSessionKeyReceived(object sender, RemoteDataEventArgs`1<string> eventArgs);
    private void HandlePublicKeyRequestReceived(object sender, RemoteDataEventArgs`1<string> eventArgs);
    private void HandleNegotiationReceived(object sender, RemoteSessionNegotiationEventArgs arg);
    private bool RunClientNegotiationAlgorithm(RemoteSessionCapability serverRemoteSessionCapability);
    [CompilerGeneratedAttribute]
internal virtual RemotingDestination get_MySelf();
    public sealed virtual void Dispose();
    public void Dispose(bool disposing);
}
public class System.Management.Automation.Remoting.CmdletMethodInvoker`1 : object {
    [CompilerGeneratedAttribute]
private Func`2<Cmdlet, T> <Action>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <ExceptionThrownOnCmdletThread>k__BackingField;
    [CompilerGeneratedAttribute]
private ManualResetEventSlim <Finished>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncObject>k__BackingField;
    [CompilerGeneratedAttribute]
private T <MethodResult>k__BackingField;
    public Func`2<Cmdlet, T> Action { get; public set; }
    public Exception ExceptionThrownOnCmdletThread { get; public set; }
    public ManualResetEventSlim Finished { get; public set; }
    public object SyncObject { get; public set; }
    public T MethodResult { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<Cmdlet, T> get_Action();
    [CompilerGeneratedAttribute]
public void set_Action(Func`2<Cmdlet, T> value);
    [CompilerGeneratedAttribute]
public Exception get_ExceptionThrownOnCmdletThread();
    [CompilerGeneratedAttribute]
public void set_ExceptionThrownOnCmdletThread(Exception value);
    [CompilerGeneratedAttribute]
public ManualResetEventSlim get_Finished();
    [CompilerGeneratedAttribute]
public void set_Finished(ManualResetEventSlim value);
    [CompilerGeneratedAttribute]
public object get_SyncObject();
    [CompilerGeneratedAttribute]
public void set_SyncObject(object value);
    [CompilerGeneratedAttribute]
public T get_MethodResult();
    [CompilerGeneratedAttribute]
public void set_MethodResult(T value);
}
internal static class System.Management.Automation.Remoting.ConfigFileConstants : object {
    internal static string AliasDefinitions;
    internal static string AliasDescriptionToken;
    internal static string AliasNameToken;
    internal static string AliasOptionsToken;
    internal static string AliasValueToken;
    internal static string AssembliesToLoad;
    internal static string Author;
    internal static string CompanyName;
    internal static string Copyright;
    internal static string Description;
    internal static string EnforceInputParameterValidation;
    internal static string EnvironmentVariables;
    internal static string ExecutionPolicy;
    internal static string FormatsToProcess;
    internal static string FunctionDefinitions;
    internal static string FunctionNameToken;
    internal static string FunctionOptionsToken;
    internal static string FunctionValueToken;
    internal static string GMSAAccount;
    internal static string Guid;
    internal static string LanguageMode;
    internal static string ModulesToImport;
    internal static string MountUserDrive;
    internal static string PowerShellVersion;
    internal static string RequiredGroups;
    internal static string RoleDefinitions;
    internal static string SchemaVersion;
    internal static string ScriptsToProcess;
    internal static string SessionType;
    internal static string RoleCapabilities;
    internal static string RoleCapabilityFiles;
    internal static string RunAsVirtualAccount;
    internal static string RunAsVirtualAccountGroups;
    internal static string TranscriptDirectory;
    internal static string TypesToProcess;
    internal static string UserDriveMaxSize;
    internal static string VariableDefinitions;
    internal static string VariableNameToken;
    internal static string VariableValueToken;
    internal static string VisibleAliases;
    internal static string VisibleCmdlets;
    internal static string VisibleFunctions;
    internal static string VisibleProviders;
    internal static string VisibleExternalCommands;
    internal static ConfigTypeEntry[] ConfigFileKeys;
    private static ConfigFileConstants();
    internal static bool IsValidKey(DictionaryEntry de, PSCmdlet cmdlet, string path);
    private static bool ISSValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool LanguageModeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool ExecutionPolicyValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool HashtableTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool AliasDefinitionsTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool FunctionDefinitionsTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool VariableDefinitionsTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool StringTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool StringArrayTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool BooleanTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool IntegerTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
    private static bool StringOrHashtableArrayTypeValidationCallback(string key, object obj, PSCmdlet cmdlet, string path);
}
internal class System.Management.Automation.Remoting.ConfigTypeEntry : object {
    internal string Key;
    internal TypeValidationCallback ValidationCallback;
    internal ConfigTypeEntry(string key, TypeValidationCallback callback);
}
internal class System.Management.Automation.Remoting.ConfigurationDataFromXML : object {
    internal static string INITPARAMETERSTOKEN;
    internal static string PARAMTOKEN;
    internal static string NAMETOKEN;
    internal static string VALUETOKEN;
    internal static string APPBASETOKEN;
    internal static string ASSEMBLYTOKEN;
    internal static string SHELLCONFIGTYPETOKEN;
    internal static string STARTUPSCRIPTTOKEN;
    internal static string MAXRCVDOBJSIZETOKEN;
    internal static string MAXRCVDOBJSIZETOKEN_CamelCase;
    internal static string MAXRCVDCMDSIZETOKEN;
    internal static string MAXRCVDCMDSIZETOKEN_CamelCase;
    internal static string THREADOPTIONSTOKEN;
    internal static string THREADAPTSTATETOKEN;
    internal static string SESSIONCONFIGTOKEN;
    internal static string PSVERSIONTOKEN;
    internal static string MAXPSVERSIONTOKEN;
    internal static string MODULESTOIMPORT;
    internal static string HOSTMODE;
    internal static string CONFIGFILEPATH;
    internal static string CONFIGFILEPATH_CamelCase;
    internal string StartupScript;
    internal string InitializationScriptForOutOfProcessRunspace;
    internal string ApplicationBase;
    internal string AssemblyName;
    internal string EndPointConfigurationTypeName;
    internal Type EndPointConfigurationType;
    internal Nullable`1<int> MaxReceivedObjectSizeMB;
    internal Nullable`1<int> MaxReceivedCommandSizeMB;
    internal Nullable`1<PSThreadOptions> ShellThreadOptions;
    internal Nullable`1<ApartmentState> ShellThreadApartmentState;
    internal PSSessionConfigurationData SessionConfigurationData;
    internal string ConfigFilePath;
    private void Update(string optionName, string optionValue);
    private static void AssertValueNotAssigned(string optionName, object originalValue);
    private static Nullable`1<int> GetIntValueInBytes(string optionValueInMB);
    internal static ConfigurationDataFromXML Create(string initializationParameters);
    internal PSSessionConfiguration CreateEndPointConfigurationInstance();
}
internal enum System.Management.Automation.Remoting.ConnectionStatus : Enum {
    public int value__;
    public static ConnectionStatus NetworkFailureDetected;
    public static ConnectionStatus ConnectionRetryAttempt;
    public static ConnectionStatus ConnectionRetrySucceeded;
    public static ConnectionStatus AutoDisconnectStarting;
    public static ConnectionStatus AutoDisconnectSucceeded;
    public static ConnectionStatus InternalErrorAbort;
}
internal class System.Management.Automation.Remoting.ConnectionStatusEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ConnectionStatus <Notification>k__BackingField;
    internal ConnectionStatus Notification { get; }
    internal ConnectionStatusEventArgs(ConnectionStatus notification);
    [CompilerGeneratedAttribute]
internal ConnectionStatus get_Notification();
}
internal class System.Management.Automation.Remoting.ContainerSessionNamedPipeClient : NamedPipeClientBase {
    public ContainerSessionNamedPipeClient(int procId, string appDomainName, string containerObRoot);
    protected virtual NamedPipeClientStream DoConnect(int timeout);
}
internal class System.Management.Automation.Remoting.CreateCompleteEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RunspaceConnectionInfo <ConnectionInfo>k__BackingField;
    internal RunspaceConnectionInfo ConnectionInfo { get; }
    internal CreateCompleteEventArgs(RunspaceConnectionInfo connectionInfo);
    [CompilerGeneratedAttribute]
internal RunspaceConnectionInfo get_ConnectionInfo();
}
internal enum System.Management.Automation.Remoting.DataPriorityType : Enum {
    public int value__;
    public static DataPriorityType Default;
    public static DataPriorityType PromptResponse;
}
internal class System.Management.Automation.Remoting.DefaultRemotePowerShellConfiguration : PSSessionConfiguration {
    public virtual InitialSessionState GetInitialSessionState(PSSenderInfo senderInfo);
    public virtual InitialSessionState GetInitialSessionState(PSSessionConfigurationData sessionConfigurationData, PSSenderInfo senderInfo, string configProviderId);
}
internal static class System.Management.Automation.Remoting.DISCFileValidation : object {
    private static HashSet`1<string> SupportedConfigOptions;
    private static HashSet`1<string> UnsupportedConfigOptions;
    private static DISCFileValidation();
    internal static void ValidateContents(Hashtable configHash);
}
internal class System.Management.Automation.Remoting.DISCPowerShellConfiguration : PSSessionConfiguration {
    private string _configFile;
    private Hashtable _configHash;
    private static string PSRCExtension;
    internal Hashtable ConfigHash { get; }
    internal DISCPowerShellConfiguration(string configFile, Func`2<string, bool> roleVerifier, bool validateFile);
    internal Hashtable get_ConfigHash();
    private void MergeRoleRulesIntoConfigHash(Func`2<string, bool> roleVerifier);
    private void MergeRoleCapabilitiesIntoConfigHash();
    private void MergeConfigHashIntoConfigHash(IDictionary childConfigHash);
    private static string GetRoleCapabilityPath(string roleCapability);
    public virtual InitialSessionState GetInitialSessionState(PSSenderInfo senderInfo);
    private static void ProcessCopyItemFunctionDefinitions(InitialSessionState iss);
    private static void ProcessVisibleCommands(InitialSessionState iss, Object[] commands);
    private static void ProcessCommandModification(Dictionary`2<string, Hashtable> commandModifications, IDictionary commandModification);
    private static void ProcessVisibleCommand(InitialSessionState iss, string command, HashSet`1<string> moduleNames);
    private static SessionStateAliasEntry CreateSessionStateAliasEntry(Hashtable alias, bool isAliasVisibilityDefined);
    private static SessionStateFunctionEntry CreateSessionStateFunctionEntry(Hashtable function, bool isFunctionVisibilityDefined);
    private static SessionStateVariableEntry CreateSessionStateVariableEntry(Hashtable variable, PSLanguageMode languageMode);
    private bool IsNonDefaultVisibilitySpecified(string configFileKey);
    internal static string TryGetValue(Hashtable table, string key);
    internal static Hashtable[] TryGetHashtableArray(object hashObj);
    internal static String[] TryGetStringArray(object hashObj);
    internal static T[] TryGetObjectsOfType(object hashObj, IEnumerable`1<Type> types);
}
internal static class System.Management.Automation.Remoting.DISCUtils : object {
    internal static Type ExecutionPolicyType;
    private static HashSet`1<string> s_allowedRoleCapabilityKeys;
    private static DISCUtils();
    internal static ExternalScriptInfo GetScriptInfoForFile(ExecutionContext context, string fileName, String& scriptName);
    internal static Hashtable LoadConfigFile(ExecutionContext context, ExternalScriptInfo scriptInfo);
    internal static bool VerifyConfigTable(Hashtable table, PSCmdlet cmdlet, string path);
    private static void ValidatePS1XMLExtension(string key, String[] paths, string filePath);
    private static void ValidatePS1OrPSM1Extension(string key, String[] paths, string filePath);
    internal static void ValidateExtensions(Hashtable table, string filePath);
    internal static void ValidateAbsolutePaths(SessionState state, Hashtable table, string filePath);
    internal static void ValidateAbsolutePath(SessionState state, string key, String[] paths, string filePath);
    internal static void ValidateRoleDefinitions(IDictionary roleDefinitions);
}
internal class System.Management.Automation.Remoting.DispatchTable`1 : object {
    private Dictionary`2<long, AsyncObject`1<T>> _responseAsyncObjects;
    private long _nextCallId;
    internal static long VoidCallId;
    internal long CreateNewCallId();
    private AsyncObject`1<T> GetResponseAsyncObject(long callId);
    internal T GetResponse(long callId, T defaultValue);
    internal void SetResponse(long callId, T remoteHostResponse);
    private void AbortCall(long callId);
    private void AbortCalls(List`1<long> callIds);
    private List`1<long> GetAllCalls();
    internal void AbortAllCalls();
}
internal class System.Management.Automation.Remoting.FragmentedRemoteObject : object {
    private Byte[] _blob;
    private int _blobLength;
    internal static byte SFlag;
    internal static byte EFlag;
    internal static int HeaderLength;
    private static int _objectIdOffset;
    private static int _fragmentIdOffset;
    private static int _flagsOffset;
    private static int _blobLengthOffset;
    private static int _blobOffset;
    [CompilerGeneratedAttribute]
private long <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private long <FragmentId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsStartFragment>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndFragment>k__BackingField;
    internal long ObjectId { get; internal set; }
    internal long FragmentId { get; internal set; }
    internal bool IsStartFragment { get; internal set; }
    internal bool IsEndFragment { get; internal set; }
    internal int BlobLength { get; internal set; }
    internal Byte[] Blob { get; internal set; }
    internal FragmentedRemoteObject(Byte[] blob, long objectId, long fragmentId, bool isEndFragment);
    [CompilerGeneratedAttribute]
internal long get_ObjectId();
    [CompilerGeneratedAttribute]
internal void set_ObjectId(long value);
    [CompilerGeneratedAttribute]
internal long get_FragmentId();
    [CompilerGeneratedAttribute]
internal void set_FragmentId(long value);
    [CompilerGeneratedAttribute]
internal bool get_IsStartFragment();
    [CompilerGeneratedAttribute]
internal void set_IsStartFragment(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsEndFragment();
    [CompilerGeneratedAttribute]
internal void set_IsEndFragment(bool value);
    internal int get_BlobLength();
    internal void set_BlobLength(int value);
    internal Byte[] get_Blob();
    internal void set_Blob(Byte[] value);
    internal Byte[] GetBytes();
    internal static long GetObjectId(Byte[] fragmentBytes, int startIndex);
    internal static long GetFragmentId(Byte[] fragmentBytes, int startIndex);
    internal static bool GetIsStartFragment(Byte[] fragmentBytes, int startIndex);
    internal static bool GetIsEndFragment(Byte[] fragmentBytes, int startIndex);
    internal static int GetBlobLength(Byte[] fragmentBytes, int startIndex);
}
internal class System.Management.Automation.Remoting.Fragmentor : object {
    private static UTF8Encoding s_utf8Encoding;
    private static int SerializationDepthForRemoting;
    private int _fragmentSize;
    private SerializationContext _serializationContext;
    [CompilerGeneratedAttribute]
private DeserializationContext <DeserializationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeTable <TypeTable>k__BackingField;
    internal DeserializationContext DeserializationContext { get; }
    internal int FragmentSize { get; internal set; }
    internal TypeTable TypeTable { get; internal set; }
    internal Fragmentor(int fragmentSize, PSRemotingCryptoHelper cryptoHelper);
    private static Fragmentor();
    internal void Fragment(RemoteDataObject`1<T> obj, SerializedDataStream dataToBeSent);
    [CompilerGeneratedAttribute]
internal DeserializationContext get_DeserializationContext();
    internal int get_FragmentSize();
    internal void set_FragmentSize(int value);
    [CompilerGeneratedAttribute]
internal TypeTable get_TypeTable();
    [CompilerGeneratedAttribute]
internal void set_TypeTable(TypeTable value);
    internal void SerializeToBytes(object obj, Stream streamToWriteTo);
    internal PSObject DeserializeToPSObject(Stream serializedDataStream);
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.Remoting.HostDefaultData : object {
    private Dictionary`2<HostDefaultDataId, object> data;
    internal object Item { get; }
    internal object get_Item(HostDefaultDataId id);
    internal bool HasValue(HostDefaultDataId id);
    internal void SetValue(HostDefaultDataId id, object dataValue);
    internal object GetValue(HostDefaultDataId id);
    internal static HostDefaultData Create(PSHostRawUserInterface hostRawUI);
}
internal enum System.Management.Automation.Remoting.HostDefaultDataId : Enum {
    public int value__;
    public static HostDefaultDataId ForegroundColor;
    public static HostDefaultDataId BackgroundColor;
    public static HostDefaultDataId CursorPosition;
    public static HostDefaultDataId WindowPosition;
    public static HostDefaultDataId CursorSize;
    public static HostDefaultDataId BufferSize;
    public static HostDefaultDataId WindowSize;
    public static HostDefaultDataId MaxWindowSize;
    public static HostDefaultDataId MaxPhysicalWindowSize;
    public static HostDefaultDataId WindowTitle;
}
internal class System.Management.Automation.Remoting.HostInfo : object {
    private bool _isHostUINull;
    private bool _isHostRawUINull;
    private bool _isHostNull;
    private HostDefaultData _hostDefaultData;
    private bool _useRunspaceHost;
    internal HostDefaultData HostDefaultData { get; }
    internal bool IsHostNull { get; }
    internal bool IsHostUINull { get; }
    internal bool IsHostRawUINull { get; }
    internal bool UseRunspaceHost { get; internal set; }
    internal HostInfo(PSHost host);
    internal HostDefaultData get_HostDefaultData();
    internal bool get_IsHostNull();
    internal bool get_IsHostUINull();
    internal bool get_IsHostRawUINull();
    internal bool get_UseRunspaceHost();
    internal void set_UseRunspaceHost(bool value);
    private static void CheckHostChain(PSHost host, Boolean& isHostNull, Boolean& isHostUINull, Boolean& isHostRawUINull);
}
internal class System.Management.Automation.Remoting.HyperVSocketEndPoint : EndPoint {
    private AddressFamily _addressFamily;
    private Guid _vmId;
    private Guid _serviceId;
    public static AddressFamily AF_HYPERV;
    public static int HYPERV_SOCK_ADDR_SIZE;
    public AddressFamily AddressFamily { get; }
    public Guid VmId { get; public set; }
    public Guid ServiceId { get; public set; }
    public HyperVSocketEndPoint(AddressFamily AddrFamily, Guid VmId, Guid ServiceId);
    public virtual AddressFamily get_AddressFamily();
    public Guid get_VmId();
    public void set_VmId(Guid value);
    public Guid get_ServiceId();
    public void set_ServiceId(Guid value);
    public virtual EndPoint Create(SocketAddress SockAddr);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual SocketAddress Serialize();
    public virtual string ToString();
}
internal class System.Management.Automation.Remoting.Indexer : object {
    private Int32[] _current;
    private Int32[] _lengths;
    public object Current { get; }
    internal Indexer(Int32[] lengths);
    public sealed virtual object get_Current();
    private static bool CheckLengthsNonNegative(Int32[] lengths);
    public sealed virtual IEnumerator GetEnumerator();
    public sealed virtual void Reset();
    public sealed virtual bool MoveNext();
}
public class System.Management.Automation.Remoting.Internal.PSStreamObject : object {
    [CompilerGeneratedAttribute]
private PSStreamObjectType <ObjectType>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    public PSStreamObjectType ObjectType { get; public set; }
    internal object Value { get; internal set; }
    internal Guid Id { get; internal set; }
    internal PSStreamObject(PSStreamObjectType objectType, object value, Guid id);
    public PSStreamObject(PSStreamObjectType objectType, object value);
    [CompilerGeneratedAttribute]
public PSStreamObjectType get_ObjectType();
    [CompilerGeneratedAttribute]
public void set_ObjectType(PSStreamObjectType value);
    [CompilerGeneratedAttribute]
internal object get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(object value);
    [CompilerGeneratedAttribute]
internal Guid get_Id();
    [CompilerGeneratedAttribute]
internal void set_Id(Guid value);
    public void WriteStreamObject(Cmdlet cmdlet, bool overrideInquire);
    private static void GetIdentifierInfo(string message, Guid& jobInstanceId, String& computerName);
    internal void WriteStreamObject(Cmdlet cmdlet, Guid instanceId, bool overrideInquire);
    internal void WriteStreamObject(Cmdlet cmdlet, bool writeSourceIdentifier, bool overrideInquire);
    private static void InvokeCmdletMethodAndWaitForResults(CmdletMethodInvoker`1<T> cmdletMethodInvoker, Cmdlet cmdlet);
    internal static void AddSourceJobNoteProperty(PSObject psObj, Guid instanceId);
    internal static string CreateInformationalMessage(Guid instanceId, string message);
    internal static ErrorRecord AddSourceTagToError(ErrorRecord errorRecord, Guid sourceId);
}
public enum System.Management.Automation.Remoting.Internal.PSStreamObjectType : Enum {
    public int value__;
    public static PSStreamObjectType Output;
    public static PSStreamObjectType Error;
    public static PSStreamObjectType MethodExecutor;
    public static PSStreamObjectType Warning;
    public static PSStreamObjectType BlockingError;
    public static PSStreamObjectType ShouldMethod;
    public static PSStreamObjectType WarningRecord;
    public static PSStreamObjectType Debug;
    public static PSStreamObjectType Progress;
    public static PSStreamObjectType Verbose;
    public static PSStreamObjectType Information;
    public static PSStreamObjectType Exception;
}
internal abstract class System.Management.Automation.Remoting.IThrottleOperation : object {
    private bool _ignoreStop;
    [CompilerGeneratedAttribute]
private bool <RunspaceDebuggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunspaceDebugStepInEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<StartRunspaceDebugProcessingEventArgs> RunspaceDebugStop;
    internal bool IgnoreStop { get; internal set; }
    internal bool RunspaceDebuggingEnabled { get; internal set; }
    internal bool RunspaceDebugStepInEnabled { get; internal set; }
    internal abstract virtual void StartOperation();
    internal abstract virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    internal bool get_IgnoreStop();
    internal void set_IgnoreStop(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RunspaceDebuggingEnabled();
    [CompilerGeneratedAttribute]
internal void set_RunspaceDebuggingEnabled(bool value);
    [CompilerGeneratedAttribute]
internal bool get_RunspaceDebugStepInEnabled();
    [CompilerGeneratedAttribute]
internal void set_RunspaceDebugStepInEnabled(bool value);
    [CompilerGeneratedAttribute]
internal void add_RunspaceDebugStop(EventHandler`1<StartRunspaceDebugProcessingEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RunspaceDebugStop(EventHandler`1<StartRunspaceDebugProcessingEventArgs> value);
    internal void RaiseRunspaceDebugStopEvent(Runspace runspace);
}
internal class System.Management.Automation.Remoting.ListenerEndedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RestartListener>k__BackingField;
    public Exception Reason { get; }
    public bool RestartListener { get; }
    public ListenerEndedEventArgs(Exception reason, bool restartListener);
    [CompilerGeneratedAttribute]
public Exception get_Reason();
    [CompilerGeneratedAttribute]
public bool get_RestartListener();
}
internal class System.Management.Automation.Remoting.NamedPipeClientBase : object {
    private NamedPipeClientStream _clientPipeStream;
    private PowerShellTraceSource _tracer;
    [CompilerGeneratedAttribute]
private StreamReader <TextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamWriter <TextWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    public StreamReader TextReader { get; private set; }
    public StreamWriter TextWriter { get; private set; }
    public string PipeName { get; internal set; }
    [CompilerGeneratedAttribute]
public StreamReader get_TextReader();
    [CompilerGeneratedAttribute]
private void set_TextReader(StreamReader value);
    [CompilerGeneratedAttribute]
public StreamWriter get_TextWriter();
    [CompilerGeneratedAttribute]
private void set_TextWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public string get_PipeName();
    [CompilerGeneratedAttribute]
internal void set_PipeName(string value);
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    public void Connect(int timeout);
    public void Close();
    public virtual void AbortConnect();
    protected virtual NamedPipeClientStream DoConnect(int timeout);
}
internal static class System.Management.Automation.Remoting.NamedPipeNative : object {
    internal static UInt32 PIPE_ACCESS_DUPLEX;
    internal static UInt32 PIPE_ACCESS_OUTBOUND;
    internal static UInt32 PIPE_ACCESS_INBOUND;
    internal static UInt32 PIPE_TYPE_BYTE;
    internal static UInt32 PIPE_TYPE_MESSAGE;
    internal static UInt32 FILE_FLAG_OVERLAPPED;
    internal static UInt32 FILE_FLAG_FIRST_PIPE_INSTANCE;
    internal static UInt32 PIPE_WAIT;
    internal static UInt32 PIPE_NOWAIT;
    internal static UInt32 PIPE_READMODE_BYTE;
    internal static UInt32 PIPE_READMODE_MESSAGE;
    internal static UInt32 PIPE_ACCEPT_REMOTE_CLIENTS;
    internal static UInt32 PIPE_REJECT_REMOTE_CLIENTS;
    internal static UInt32 ERROR_FILE_NOT_FOUND;
    internal static UInt32 ERROR_BROKEN_PIPE;
    internal static UInt32 ERROR_PIPE_BUSY;
    internal static UInt32 ERROR_NO_DATA;
    internal static UInt32 ERROR_MORE_DATA;
    internal static UInt32 ERROR_PIPE_CONNECTED;
    internal static UInt32 ERROR_IO_INCOMPLETE;
    internal static UInt32 ERROR_IO_PENDING;
    internal static SafePipeHandle CreateNamedPipe(string lpName, UInt32 dwOpenMode, UInt32 dwPipeMode, UInt32 nMaxInstances, UInt32 nOutBufferSize, UInt32 nInBufferSize, UInt32 nDefaultTimeOut, SECURITY_ATTRIBUTES securityAttributes);
    internal static SECURITY_ATTRIBUTES GetSecurityAttributes(GCHandle securityDescriptorPinnedHandle, bool inheritHandle);
}
internal static class System.Management.Automation.Remoting.NamedPipeUtils : object {
    internal static string NamedPipeNamePrefix;
    internal static string DefaultAppDomainName;
    internal static string NamedPipeNamePrefixSearch;
    internal static int MaxNamedPipeNameSize;
    internal static string CreateProcessPipeName(int procId);
    internal static string CreateProcessPipeName(Process proc);
    internal static string CreateProcessPipeName(int procId, string appDomainName);
    internal static string CreateProcessPipeName(Process proc, string appDomainName);
    private static string CleanAppDomainNameForPipeName(string appDomainName);
    internal static string GetCurrentAppDomainName();
}
internal class System.Management.Automation.Remoting.ObjectRef`1 : object {
    private T _newValue;
    private T _oldValue;
    internal T OldValue { get; }
    internal T Value { get; }
    internal bool IsOverridden { get; }
    internal ObjectRef`1(T oldValue);
    internal T get_OldValue();
    internal T get_Value();
    internal bool get_IsOverridden();
    internal void Override(T newValue);
    internal void Revert();
}
internal enum System.Management.Automation.Remoting.OperationState : Enum {
    public int value__;
    public static OperationState StartComplete;
    public static OperationState StopComplete;
}
internal class System.Management.Automation.Remoting.OperationStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private OperationState <OperationState>k__BackingField;
    [CompilerGeneratedAttribute]
private EventArgs <BaseEvent>k__BackingField;
    internal OperationState OperationState { get; internal set; }
    internal EventArgs BaseEvent { get; internal set; }
    [CompilerGeneratedAttribute]
internal OperationState get_OperationState();
    [CompilerGeneratedAttribute]
internal void set_OperationState(OperationState value);
    [CompilerGeneratedAttribute]
internal EventArgs get_BaseEvent();
    [CompilerGeneratedAttribute]
internal void set_BaseEvent(EventArgs value);
}
[DataContractAttribute]
public class System.Management.Automation.Remoting.OriginInfo : object {
    [DataMemberAttribute]
private string _computerName;
    [DataMemberAttribute]
private Guid _runspaceID;
    [DataMemberAttribute]
private Guid _instanceId;
    public string PSComputerName { get; }
    public Guid RunspaceID { get; }
    public Guid InstanceID { get; public set; }
    public OriginInfo(string computerName, Guid runspaceID);
    public OriginInfo(string computerName, Guid runspaceID, Guid instanceID);
    public string get_PSComputerName();
    public Guid get_RunspaceID();
    public Guid get_InstanceID();
    public void set_InstanceID(Guid value);
    public virtual string ToString();
}
internal class System.Management.Automation.Remoting.OutOfProcessTextWriter : object {
    private TextWriter _writer;
    private bool _isStopped;
    private object _syncObject;
    private static string _errorPrepend;
    public static string ErrorPrefix { get; }
    public OutOfProcessTextWriter(TextWriter writerToWrap);
    public static string get_ErrorPrefix();
    public virtual void WriteLine(string data);
    internal void StopWriting();
}
internal static class System.Management.Automation.Remoting.OutOfProcessUtils : object {
    internal static string PS_OUT_OF_PROC_DATA_TAG;
    internal static string PS_OUT_OF_PROC_DATA_ACK_TAG;
    internal static string PS_OUT_OF_PROC_STREAM_ATTRIBUTE;
    internal static string PS_OUT_OF_PROC_PSGUID_ATTRIBUTE;
    internal static string PS_OUT_OF_PROC_CLOSE_TAG;
    internal static string PS_OUT_OF_PROC_CLOSE_ACK_TAG;
    internal static string PS_OUT_OF_PROC_COMMAND_TAG;
    internal static string PS_OUT_OF_PROC_COMMAND_ACK_TAG;
    internal static string PS_OUT_OF_PROC_SIGNAL_TAG;
    internal static string PS_OUT_OF_PROC_SIGNAL_ACK_TAG;
    internal static int EXITCODE_UNHANDLED_EXCEPTION;
    internal static XmlReaderSettings XmlReaderSettings;
    private static OutOfProcessUtils();
    internal static string CreateDataPacket(Byte[] data, DataPriorityType streamType, Guid psGuid);
    internal static string CreateDataAckPacket(Guid psGuid);
    internal static string CreateCommandPacket(Guid psGuid);
    internal static string CreateCommandAckPacket(Guid psGuid);
    internal static string CreateClosePacket(Guid psGuid);
    internal static string CreateCloseAckPacket(Guid psGuid);
    internal static string CreateSignalPacket(Guid psGuid);
    internal static string CreateSignalAckPacket(Guid psGuid);
    private static string CreatePSGuidPacket(string element, Guid psGuid);
    internal static void ProcessData(string data, DataProcessingDelegates callbacks);
    private static void ProcessElement(XmlReader xmlReader, DataProcessingDelegates callbacks);
}
internal class System.Management.Automation.Remoting.PriorityReceiveDataCollection : object {
    private Fragmentor _defragmentor;
    private ReceiveDataCollection[] _recvdData;
    private bool _isCreateByClientTM;
    unknown Nullable`1<int> MaximumReceivedDataSize {internal set; }
    unknown Nullable`1<int> MaximumReceivedObjectSize {internal set; }
    internal PriorityReceiveDataCollection(Fragmentor defragmentor, bool createdByClientTM);
    internal void set_MaximumReceivedDataSize(Nullable`1<int> value);
    internal void set_MaximumReceivedObjectSize(Nullable`1<int> value);
    internal void PrepareForStreamConnect();
    internal void AllowTwoThreadsToProcessRawData();
    internal void ProcessRawData(Byte[] data, DataPriorityType priorityType, OnDataAvailableCallback callback);
    public sealed virtual void Dispose();
    internal virtual void Dispose(bool isDisposing);
}
internal class System.Management.Automation.Remoting.PrioritySendDataCollection : object {
    private SerializedDataStream[] _dataToBeSent;
    private Object[] _dataSyncObjects;
    private Fragmentor _fragmentor;
    private OnDataAvailableCallback _onDataAvailableCallback;
    private OnDataAvailableCallback _onSendCollectionDataAvailable;
    private bool _isHandlingCallback;
    private object _readSyncObject;
    internal Fragmentor Fragmentor { get; internal set; }
    internal Fragmentor get_Fragmentor();
    internal void set_Fragmentor(Fragmentor value);
    internal void Add(RemoteDataObject`1<T> data, DataPriorityType priority);
    internal void Add(RemoteDataObject`1<T> data);
    internal void Clear();
    internal Byte[] ReadOrRegisterCallback(OnDataAvailableCallback callback, DataPriorityType& priorityType);
    private void OnDataAvailable(Byte[] data, bool isEndFragment);
}
public enum System.Management.Automation.Remoting.ProxyAccessType : Enum {
    public int value__;
    public static ProxyAccessType None;
    public static ProxyAccessType IEConfig;
    public static ProxyAccessType WinHttpConfig;
    public static ProxyAccessType AutoDetect;
    public static ProxyAccessType NoProxyServer;
}
public class System.Management.Automation.Remoting.PSCertificateDetails : object {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuerName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IssuerThumbprint>k__BackingField;
    public string Subject { get; }
    public string IssuerName { get; }
    public string IssuerThumbprint { get; }
    public PSCertificateDetails(string subject, string issuerName, string issuerThumbprint);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public string get_IssuerName();
    [CompilerGeneratedAttribute]
public string get_IssuerThumbprint();
}
public class System.Management.Automation.Remoting.PSDirectException : RuntimeException {
    public PSDirectException(string message);
}
public class System.Management.Automation.Remoting.PSIdentity : object {
    [CompilerGeneratedAttribute]
private string <AuthenticationType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAuthenticated>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PSCertificateDetails <CertificateDetails>k__BackingField;
    public string AuthenticationType { get; }
    public bool IsAuthenticated { get; }
    public string Name { get; }
    public PSCertificateDetails CertificateDetails { get; }
    public PSIdentity(string authType, bool isAuthenticated, string userName, PSCertificateDetails cert);
    [CompilerGeneratedAttribute]
public sealed virtual string get_AuthenticationType();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsAuthenticated();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Name();
    [CompilerGeneratedAttribute]
public PSCertificateDetails get_CertificateDetails();
}
public class System.Management.Automation.Remoting.PSPrincipal : object {
    [CompilerGeneratedAttribute]
private PSIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsIdentity <WindowsIdentity>k__BackingField;
    public PSIdentity Identity { get; }
    public WindowsIdentity WindowsIdentity { get; }
    private IIdentity System.Security.Principal.IPrincipal.Identity { get; }
    public PSPrincipal(PSIdentity identity, WindowsIdentity windowsIdentity);
    [CompilerGeneratedAttribute]
public PSIdentity get_Identity();
    [CompilerGeneratedAttribute]
public WindowsIdentity get_WindowsIdentity();
    private sealed virtual override IIdentity System.Security.Principal.IPrincipal.get_Identity();
    public sealed virtual bool IsInRole(string role);
    internal bool IsInRole(WindowsBuiltInRole role);
}
public class System.Management.Automation.Remoting.PSRemotingDataStructureException : RuntimeException {
    public PSRemotingDataStructureException(string message);
    public PSRemotingDataStructureException(string message, Exception innerException);
    internal PSRemotingDataStructureException(string resourceString, Object[] args);
    internal PSRemotingDataStructureException(Exception innerException, string resourceString, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSRemotingDataStructureException(SerializationInfo info, StreamingContext context);
    private void SetDefaultErrorRecord();
}
internal enum System.Management.Automation.Remoting.PSRemotingErrorId : Enum {
    public UInt32 value__;
    public static PSRemotingErrorId DefaultRemotingExceptionMessage;
    public static PSRemotingErrorId OutOfMemory;
    public static PSRemotingErrorId PipelineIdsDoNotMatch;
    public static PSRemotingErrorId PipelineNotFoundOnServer;
    public static PSRemotingErrorId PipelineStopped;
    public static PSRemotingErrorId RunspaceAlreadyExists;
    public static PSRemotingErrorId RunspaceIdsDoNotMatch;
    public static PSRemotingErrorId RemoteRunspaceOpenFailed;
    public static PSRemotingErrorId RunspaceCannotBeFound;
    public static PSRemotingErrorId ResponsePromptIdCannotBeFound;
    public static PSRemotingErrorId RemoteHostCallFailed;
    public static PSRemotingErrorId RemoteHostMethodNotImplemented;
    public static PSRemotingErrorId RemoteHostDataEncodingNotSupported;
    public static PSRemotingErrorId RemoteHostDataDecodingNotSupported;
    public static PSRemotingErrorId NestedPipelineNotSupported;
    public static PSRemotingErrorId RelativeUriForRunspacePathNotSupported;
    public static PSRemotingErrorId RemoteHostDecodingFailed;
    public static PSRemotingErrorId MustBeAdminToOverrideThreadOptions;
    public static PSRemotingErrorId RemoteHostPromptForCredentialModifiedCaption;
    public static PSRemotingErrorId RemoteHostPromptForCredentialModifiedMessage;
    public static PSRemotingErrorId RemoteHostReadLineAsSecureStringPrompt;
    public static PSRemotingErrorId RemoteHostGetBufferContents;
    public static PSRemotingErrorId RemoteHostPromptSecureStringPrompt;
    public static PSRemotingErrorId WinPERemotingNotSupported;
    public static PSRemotingErrorId ReceivedUnsupportedRemoteHostCall;
    public static PSRemotingErrorId ReceivedUnsupportedAction;
    public static PSRemotingErrorId ReceivedUnsupportedDataType;
    public static PSRemotingErrorId MissingDestination;
    public static PSRemotingErrorId MissingTarget;
    public static PSRemotingErrorId MissingRunspaceId;
    public static PSRemotingErrorId MissingDataType;
    public static PSRemotingErrorId MissingCallId;
    public static PSRemotingErrorId MissingMethodName;
    public static PSRemotingErrorId MissingIsStartFragment;
    public static PSRemotingErrorId MissingProperty;
    public static PSRemotingErrorId ObjectIdsNotMatching;
    public static PSRemotingErrorId FragmentIdsNotInSequence;
    public static PSRemotingErrorId ObjectIsTooBig;
    public static PSRemotingErrorId MissingIsEndFragment;
    public static PSRemotingErrorId DeserializedObjectIsNull;
    public static PSRemotingErrorId BlobLengthNotInRange;
    public static PSRemotingErrorId DecodingErrorForErrorRecord;
    public static PSRemotingErrorId DecodingErrorForPipelineStateInfo;
    public static PSRemotingErrorId DecodingErrorForRunspaceStateInfo;
    public static PSRemotingErrorId ReceivedUnsupportedRemotingTargetInterfaceType;
    public static PSRemotingErrorId UnknownTargetClass;
    public static PSRemotingErrorId MissingTargetClass;
    public static PSRemotingErrorId DecodingErrorForRunspacePoolStateInfo;
    public static PSRemotingErrorId DecodingErrorForMinRunspaces;
    public static PSRemotingErrorId DecodingErrorForMaxRunspaces;
    public static PSRemotingErrorId DecodingErrorForPowerShellStateInfo;
    public static PSRemotingErrorId DecodingErrorForThreadOptions;
    public static PSRemotingErrorId CantCastPropertyToExpectedType;
    public static PSRemotingErrorId CantCastRemotingDataToPSObject;
    public static PSRemotingErrorId CantCastCommandToPSObject;
    public static PSRemotingErrorId CantCastParameterToPSObject;
    public static PSRemotingErrorId ObjectIdCannotBeLessThanZero;
    public static PSRemotingErrorId NotEnoughHeaderForRemoteDataObject;
    public static PSRemotingErrorId RemotingDestinationNotForMe;
    public static PSRemotingErrorId ClientNegotiationTimeout;
    public static PSRemotingErrorId ClientNegotiationFailed;
    public static PSRemotingErrorId ServerRequestedToCloseSession;
    public static PSRemotingErrorId ServerNegotiationFailed;
    public static PSRemotingErrorId ServerNegotiationTimeout;
    public static PSRemotingErrorId ClientRequestedToCloseSession;
    public static PSRemotingErrorId FatalErrorCausingClose;
    public static PSRemotingErrorId ClientKeyExchangeFailed;
    public static PSRemotingErrorId ServerKeyExchangeFailed;
    public static PSRemotingErrorId ClientNotFoundCapabilityProperties;
    public static PSRemotingErrorId ServerNotFoundCapabilityProperties;
    public static PSRemotingErrorId ConnectFailed;
    public static PSRemotingErrorId CloseIsCalled;
    public static PSRemotingErrorId ForceClosed;
    public static PSRemotingErrorId CloseFailed;
    public static PSRemotingErrorId CloseCompleted;
    public static PSRemotingErrorId UnsupportedWaitHandleType;
    public static PSRemotingErrorId ReceivedDataStreamIsNotStdout;
    public static PSRemotingErrorId StdInIsNotOpen;
    public static PSRemotingErrorId NativeWriteFileFailed;
    public static PSRemotingErrorId NativeReadFileFailed;
    public static PSRemotingErrorId InvalidSchemeValue;
    public static PSRemotingErrorId ClientReceiveFailed;
    public static PSRemotingErrorId ClientSendFailed;
    public static PSRemotingErrorId CommandHandleIsNull;
    public static PSRemotingErrorId StdInCannotBeSetToNoWait;
    public static PSRemotingErrorId PortIsOutOfRange;
    public static PSRemotingErrorId ServerProcessExited;
    public static PSRemotingErrorId CannotGetStdInHandle;
    public static PSRemotingErrorId CannotGetStdOutHandle;
    public static PSRemotingErrorId CannotGetStdErrHandle;
    public static PSRemotingErrorId CannotSetStdInHandle;
    public static PSRemotingErrorId CannotSetStdOutHandle;
    public static PSRemotingErrorId CannotSetStdErrHandle;
    public static PSRemotingErrorId InvalidConfigurationName;
    public static PSRemotingErrorId ConnectSkipCheckFailed;
    public static PSRemotingErrorId CreateSessionFailed;
    public static PSRemotingErrorId CreateExFailed;
    public static PSRemotingErrorId ConnectExCallBackError;
    public static PSRemotingErrorId SendExFailed;
    public static PSRemotingErrorId SendExCallBackError;
    public static PSRemotingErrorId ReceiveExFailed;
    public static PSRemotingErrorId ReceiveExCallBackError;
    public static PSRemotingErrorId RunShellCommandExFailed;
    public static PSRemotingErrorId RunShellCommandExCallBackError;
    public static PSRemotingErrorId CommandSendExFailed;
    public static PSRemotingErrorId CommandSendExCallBackError;
    public static PSRemotingErrorId CommandReceiveExFailed;
    public static PSRemotingErrorId CommandReceiveExCallBackError;
    public static PSRemotingErrorId CloseExCallBackError;
    public static PSRemotingErrorId RedirectedURINotWellFormatted;
    public static PSRemotingErrorId URIEndPointNotResolved;
    public static PSRemotingErrorId ReceivedObjectSizeExceededMaximumClient;
    public static PSRemotingErrorId ReceivedDataSizeExceededMaximumClient;
    public static PSRemotingErrorId ReceivedObjectSizeExceededMaximumServer;
    public static PSRemotingErrorId ReceivedDataSizeExceededMaximumServer;
    public static PSRemotingErrorId StartupScriptThrewTerminatingError;
    public static PSRemotingErrorId TroubleShootingHelpTopic;
    public static PSRemotingErrorId DisconnectShellExFailed;
    public static PSRemotingErrorId DisconnectShellExCallBackErrr;
    public static PSRemotingErrorId ReconnectShellExFailed;
    public static PSRemotingErrorId ReconnectShellExCallBackErrr;
    public static PSRemotingErrorId RemoteRunspaceInfoHasDuplicates;
    public static PSRemotingErrorId RemoteRunspaceInfoLimitExceeded;
    public static PSRemotingErrorId RemoteRunspaceOpenUnknownState;
    public static PSRemotingErrorId UriSpecifiedNotValid;
    public static PSRemotingErrorId RemoteRunspaceClosed;
    public static PSRemotingErrorId RemoteRunspaceNotAvailableForSpecifiedComputer;
    public static PSRemotingErrorId RemoteRunspaceNotAvailableForSpecifiedRunspaceId;
    public static PSRemotingErrorId StopPSJobWhatIfTarget;
    public static PSRemotingErrorId InvalidJobStateGeneral;
    public static PSRemotingErrorId JobWithSpecifiedNameNotFound;
    public static PSRemotingErrorId JobWithSpecifiedInstanceIdNotFound;
    public static PSRemotingErrorId JobWithSpecifiedSessionIdNotFound;
    public static PSRemotingErrorId JobWithSpecifiedNameNotCompleted;
    public static PSRemotingErrorId JobWithSpecifiedSessionIdNotCompleted;
    public static PSRemotingErrorId JobWithSpecifiedInstanceIdNotCompleted;
    public static PSRemotingErrorId RemovePSJobWhatIfTarget;
    public static PSRemotingErrorId ComputerNameParamNotSupported;
    public static PSRemotingErrorId RunspaceParamNotSupported;
    public static PSRemotingErrorId RemoteRunspaceNotAvailableForSpecifiedName;
    public static PSRemotingErrorId RemoteRunspaceNotAvailableForSpecifiedSessionId;
    public static PSRemotingErrorId ItemNotFoundInRepository;
    public static PSRemotingErrorId CannotRemoveJob;
    public static PSRemotingErrorId NewRunspaceAmbiguousAuthentication;
    public static PSRemotingErrorId WildCardErrorFilePathParameter;
    public static PSRemotingErrorId FilePathNotFromFileSystemProvider;
    public static PSRemotingErrorId FilePathShouldPS1Extension;
    public static PSRemotingErrorId PSSessionConfigurationName;
    public static PSRemotingErrorId PSSessionAppName;
    public static PSRemotingErrorId CSCDoubleParameterOutOfRange;
    public static PSRemotingErrorId URIRedirectionReported;
    public static PSRemotingErrorId NoMoreInputWrites;
    public static PSRemotingErrorId InvalidComputerName;
    public static PSRemotingErrorId ProxyAmbiguousAuthentication;
    public static PSRemotingErrorId ProxyCredentialWithoutAccess;
    public static PSRemotingErrorId PushedRunspaceMustBeOpen;
    public static PSRemotingErrorId HostDoesNotSupportPushRunspace;
    public static PSRemotingErrorId RemoteRunspaceHasMultipleMatchesForSpecifiedRunspaceId;
    public static PSRemotingErrorId RemoteRunspaceHasMultipleMatchesForSpecifiedSessionId;
    public static PSRemotingErrorId RemoteRunspaceHasMultipleMatchesForSpecifiedName;
    public static PSRemotingErrorId RemoteRunspaceDoesNotSupportPushRunspace;
    public static PSRemotingErrorId HostInNestedPrompt;
    public static PSRemotingErrorId InvalidVMId;
    public static PSRemotingErrorId InvalidVMNameNoVM;
    public static PSRemotingErrorId InvalidVMNameMultipleVM;
    public static PSRemotingErrorId HyperVModuleNotAvailable;
    public static PSRemotingErrorId InvalidUsername;
    public static PSRemotingErrorId InvalidCredential;
    public static PSRemotingErrorId VMSessionConnectFailed;
    public static PSRemotingErrorId InvalidContainerId;
    public static PSRemotingErrorId CannotCreateProcessInContainer;
    public static PSRemotingErrorId CannotTerminateProcessInContainer;
    public static PSRemotingErrorId ContainersFeatureNotEnabled;
    public static PSRemotingErrorId RemoteSessionHyperVSocketServerConstructorFailure;
    public static PSRemotingErrorId ContainerSessionConnectFailed;
    public static PSRemotingErrorId RemoteSessionHyperVSocketClientConstructorSetSocketOptionFailure;
    public static PSRemotingErrorId InvalidVMState;
    public static PSRemotingErrorId InvalidVMIdNotSingle;
    public static PSRemotingErrorId InvalidVMNameNotSingle;
    public static PSRemotingErrorId WsmanMaxRedirectionCountVariableDescription;
    public static PSRemotingErrorId PSDefaultSessionOptionDescription;
    public static PSRemotingErrorId PSSenderInfoDescription;
    public static PSRemotingErrorId IPCUnknownNodeType;
    public static PSRemotingErrorId IPCInsufficientDataforElement;
    public static PSRemotingErrorId IPCWrongAttributeCountForDataElement;
    public static PSRemotingErrorId IPCOnlyTextExpectedInDataElement;
    public static PSRemotingErrorId IPCWrongAttributeCountForElement;
    public static PSRemotingErrorId IPCUnknownElementReceived;
    public static PSRemotingErrorId IPCSupportsOnlyDefaultAuth;
    public static PSRemotingErrorId IPCWowComponentNotPresent;
    public static PSRemotingErrorId IPCServerProcessReportedError;
    public static PSRemotingErrorId IPCServerProcessExited;
    public static PSRemotingErrorId IPCErrorProcessingServerData;
    public static PSRemotingErrorId IPCUnknownCommandGuid;
    public static PSRemotingErrorId IPCNoSignalForSession;
    public static PSRemotingErrorId IPCSignalTimedOut;
    public static PSRemotingErrorId IPCCloseTimedOut;
    public static PSRemotingErrorId IPCExceptionLaunchingProcess;
}
internal static class System.Management.Automation.Remoting.PSRemotingErrorInvariants : object {
    internal static string FormatResourceString(string resourceString, Object[] args);
}
public class System.Management.Automation.Remoting.PSRemotingTransportException : RuntimeException {
    private int _errorCode;
    private string _transportMessage;
    public int ErrorCode { get; public set; }
    public string TransportMessage { get; public set; }
    public PSRemotingTransportException(string message);
    public PSRemotingTransportException(string message, Exception innerException);
    internal PSRemotingTransportException(PSRemotingErrorId errorId, string resourceString, Object[] args);
    internal PSRemotingTransportException(Exception innerException, string resourceString, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSRemotingTransportException(SerializationInfo info, StreamingContext context);
    protected void SetDefaultErrorRecord();
    public int get_ErrorCode();
    public void set_ErrorCode(int value);
    public string get_TransportMessage();
    public void set_TransportMessage(string value);
}
public class System.Management.Automation.Remoting.PSRemotingTransportRedirectException : PSRemotingTransportException {
    [CompilerGeneratedAttribute]
private string <RedirectLocation>k__BackingField;
    public string RedirectLocation { get; }
    public PSRemotingTransportRedirectException(string message);
    public PSRemotingTransportRedirectException(string message, Exception innerException);
    internal PSRemotingTransportRedirectException(Exception innerException, string resourceString, Object[] args);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSRemotingTransportRedirectException(SerializationInfo info, StreamingContext context);
    internal PSRemotingTransportRedirectException(string redirectLocation, PSRemotingErrorId errorId, string resourceString, Object[] args);
    [CompilerGeneratedAttribute]
public string get_RedirectLocation();
}
public class System.Management.Automation.Remoting.PSSenderInfo : object {
    private PSPrimitiveDictionary _applicationArguments;
    [CompilerGeneratedAttribute]
private PSPrincipal <UserInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    public PSPrincipal UserInfo { get; }
    public TimeZoneInfo ClientTimeZone { get; }
    public string ConnectionString { get; }
    public PSPrimitiveDictionary ApplicationArguments { get; internal set; }
    public string ConfigurationName { get; internal set; }
    private PSSenderInfo(SerializationInfo info, StreamingContext context);
    public PSSenderInfo(PSPrincipal userPrincipal, string httpUrl);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public PSPrincipal get_UserInfo();
    public TimeZoneInfo get_ClientTimeZone();
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    public PSPrimitiveDictionary get_ApplicationArguments();
    internal void set_ApplicationArguments(PSPrimitiveDictionary value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
internal void set_ConfigurationName(string value);
}
public abstract class System.Management.Automation.Remoting.PSSessionConfiguration : object {
    [TraceSourceAttribute("ServerRemoteSession", "ServerRemoteSession")]
private static PSTraceSource s_tracer;
    private static string configProvidersKeyName;
    private static string configProviderApplicationBaseKeyName;
    private static string configProviderAssemblyNameKeyName;
    private static Dictionary`2<string, ConfigurationDataFromXML> s_ssnStateProviders;
    private static object s_syncObject;
    private static PSSessionConfiguration();
    public abstract virtual InitialSessionState GetInitialSessionState(PSSenderInfo senderInfo);
    public virtual InitialSessionState GetInitialSessionState(PSSessionConfigurationData sessionConfigurationData, PSSenderInfo senderInfo, string configProviderId);
    public virtual Nullable`1<int> GetMaximumReceivedObjectSize(PSSenderInfo senderInfo);
    public virtual Nullable`1<int> GetMaximumReceivedDataSizePerCommand(PSSenderInfo senderInfo);
    public virtual PSPrimitiveDictionary GetApplicationPrivateData(PSSenderInfo senderInfo);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool isDisposing);
    internal static ConfigurationDataFromXML LoadEndPointConfiguration(string shellId, string initializationParameters);
    private static void LoadRSConfigProvider(string shellId, string initializationParameters);
    private static Type LoadAndAnalyzeAssembly(string shellId, string applicationBase, string assemblyName, string typeToLoad);
    private static Assembly LoadSsnStateProviderAssembly(string applicationBase, string assemblyName);
    private static RegistryKey GetConfigurationProvidersRegistryKey();
    private static string ReadStringValue(RegistryKey registryKey, string name, bool mandatory);
}
public class System.Management.Automation.Remoting.PSSessionConfigurationData : object {
    public static bool IsServerManager;
    private List`1<string> _modulesToImport;
    private List`1<object> _modulesToImportInternal;
    private string _privateData;
    private static string SessionConfigToken;
    internal static string ModulesToImportToken;
    internal static string PrivateDataToken;
    internal static string InProcActivityToken;
    private static string ParamToken;
    private static string NameToken;
    private static string ValueToken;
    public List`1<string> ModulesToImport { get; }
    internal List`1<object> ModulesToImportInternal { get; }
    public string PrivateData { get; internal set; }
    public List`1<string> get_ModulesToImport();
    internal List`1<object> get_ModulesToImportInternal();
    public string get_PrivateData();
    internal void set_PrivateData(string value);
    internal static string Unescape(string s);
    internal static PSSessionConfigurationData Create(string configurationData);
    private static void AssertValueNotAssigned(string optionName, object originalValue);
    private void Update(string optionName, string optionValue);
    private void CreateCollectionIfNecessary();
}
public class System.Management.Automation.Remoting.PSSessionOption : object {
    [CompilerGeneratedAttribute]
private int <MaximumConnectionRedirectionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoMachineProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyAccessType <ProxyAccessType>k__BackingField;
    private AuthenticationMechanism _proxyAuthentication;
    [CompilerGeneratedAttribute]
private PSCredential <ProxyCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipCACheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipCNCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipRevocationCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUTF16>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePortInSPN>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputBufferingMode <OutputBufferingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConnectionRetryCount>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <Culture>k__BackingField;
    [CompilerGeneratedAttribute]
private CultureInfo <UICulture>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumReceivedDataSizePerCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumReceivedObjectSize>k__BackingField;
    [CompilerGeneratedAttribute]
private PSPrimitiveDictionary <ApplicationArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <OpenTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <CancelTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <IdleTimeout>k__BackingField;
    public int MaximumConnectionRedirectionCount { get; public set; }
    public bool NoCompression { get; public set; }
    public bool NoMachineProfile { get; public set; }
    public ProxyAccessType ProxyAccessType { get; public set; }
    public AuthenticationMechanism ProxyAuthentication { get; public set; }
    public PSCredential ProxyCredential { get; public set; }
    public bool SkipCACheck { get; public set; }
    public bool SkipCNCheck { get; public set; }
    public bool SkipRevocationCheck { get; public set; }
    public TimeSpan OperationTimeout { get; public set; }
    public bool NoEncryption { get; public set; }
    public bool UseUTF16 { get; public set; }
    public bool IncludePortInSPN { get; public set; }
    public OutputBufferingMode OutputBufferingMode { get; public set; }
    public int MaxConnectionRetryCount { get; public set; }
    public CultureInfo Culture { get; public set; }
    public CultureInfo UICulture { get; public set; }
    public Nullable`1<int> MaximumReceivedDataSizePerCommand { get; public set; }
    public Nullable`1<int> MaximumReceivedObjectSize { get; public set; }
    public PSPrimitiveDictionary ApplicationArguments { get; public set; }
    public TimeSpan OpenTimeout { get; public set; }
    public TimeSpan CancelTimeout { get; public set; }
    public TimeSpan IdleTimeout { get; public set; }
    [CompilerGeneratedAttribute]
public int get_MaximumConnectionRedirectionCount();
    [CompilerGeneratedAttribute]
public void set_MaximumConnectionRedirectionCount(int value);
    [CompilerGeneratedAttribute]
public bool get_NoCompression();
    [CompilerGeneratedAttribute]
public void set_NoCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoMachineProfile();
    [CompilerGeneratedAttribute]
public void set_NoMachineProfile(bool value);
    [CompilerGeneratedAttribute]
public ProxyAccessType get_ProxyAccessType();
    [CompilerGeneratedAttribute]
public void set_ProxyAccessType(ProxyAccessType value);
    public AuthenticationMechanism get_ProxyAuthentication();
    public void set_ProxyAuthentication(AuthenticationMechanism value);
    [CompilerGeneratedAttribute]
public PSCredential get_ProxyCredential();
    [CompilerGeneratedAttribute]
public void set_ProxyCredential(PSCredential value);
    [CompilerGeneratedAttribute]
public bool get_SkipCACheck();
    [CompilerGeneratedAttribute]
public void set_SkipCACheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipCNCheck();
    [CompilerGeneratedAttribute]
public void set_SkipCNCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipRevocationCheck();
    [CompilerGeneratedAttribute]
public void set_SkipRevocationCheck(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_NoEncryption();
    [CompilerGeneratedAttribute]
public void set_NoEncryption(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseUTF16();
    [CompilerGeneratedAttribute]
public void set_UseUTF16(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludePortInSPN();
    [CompilerGeneratedAttribute]
public void set_IncludePortInSPN(bool value);
    [CompilerGeneratedAttribute]
public OutputBufferingMode get_OutputBufferingMode();
    [CompilerGeneratedAttribute]
public void set_OutputBufferingMode(OutputBufferingMode value);
    [CompilerGeneratedAttribute]
public int get_MaxConnectionRetryCount();
    [CompilerGeneratedAttribute]
public void set_MaxConnectionRetryCount(int value);
    [CompilerGeneratedAttribute]
public CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
public void set_Culture(CultureInfo value);
    [CompilerGeneratedAttribute]
public CultureInfo get_UICulture();
    [CompilerGeneratedAttribute]
public void set_UICulture(CultureInfo value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumReceivedDataSizePerCommand();
    [CompilerGeneratedAttribute]
public void set_MaximumReceivedDataSizePerCommand(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumReceivedObjectSize();
    [CompilerGeneratedAttribute]
public void set_MaximumReceivedObjectSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public PSPrimitiveDictionary get_ApplicationArguments();
    [CompilerGeneratedAttribute]
public void set_ApplicationArguments(PSPrimitiveDictionary value);
    [CompilerGeneratedAttribute]
public TimeSpan get_OpenTimeout();
    [CompilerGeneratedAttribute]
public void set_OpenTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_CancelTimeout();
    [CompilerGeneratedAttribute]
public void set_CancelTimeout(TimeSpan value);
    [CompilerGeneratedAttribute]
public TimeSpan get_IdleTimeout();
    [CompilerGeneratedAttribute]
public void set_IdleTimeout(TimeSpan value);
}
internal class System.Management.Automation.Remoting.ReceiveDataCollection : object {
    [TraceSourceAttribute("Transport", "Traces BaseWSManTransportManager")]
private static PSTraceSource s_baseTracer;
    private Fragmentor _defragmentor;
    private MemoryStream _pendingDataStream;
    private MemoryStream _dataToProcessStream;
    private long _currentObjectId;
    private long _currentFrgId;
    private Nullable`1<int> _maxReceivedObjectSize;
    private int _totalReceivedObjectSizeSoFar;
    private bool _isCreateByClientTM;
    private bool _canIgnoreOffSyncFragments;
    private object _syncObject;
    private bool _isDisposed;
    private int _numberOfThreadsProcessing;
    private int _maxNumberOfThreadsToAllowForProcessing;
    unknown Nullable`1<int> MaximumReceivedObjectSize {internal set; }
    internal ReceiveDataCollection(Fragmentor defragmentor, bool createdByClientTM);
    private static ReceiveDataCollection();
    internal void set_MaximumReceivedObjectSize(Nullable`1<int> value);
    internal void AllowTwoThreadsToProcessRawData();
    internal void PrepareForStreamConnect();
    internal void ProcessRawData(Byte[] data, OnDataAvailableCallback callback);
    private void ResetReceiveData();
    private void ReleaseResources();
    public sealed virtual void Dispose();
    internal virtual void Dispose(bool isDisposing);
}
internal class System.Management.Automation.Remoting.RemoteDataObject : RemoteDataObject`1<object> {
    private RemoteDataObject(RemotingDestination destination, RemotingDataType dataType, Guid runspacePoolId, Guid powerShellId, object data);
    internal static RemoteDataObject CreateFrom(RemotingDestination destination, RemotingDataType dataType, Guid runspacePoolId, Guid powerShellId, object data);
}
internal class System.Management.Automation.Remoting.RemoteDataObject`1 : object {
    private static int destinationOffset;
    private static int dataTypeOffset;
    private static int rsPoolIdOffset;
    private static int psIdOffset;
    private static int headerLength;
    private static int SessionMask;
    private static int RunspacePoolMask;
    private static int PowerShellMask;
    [CompilerGeneratedAttribute]
private RemotingDestination <Destination>k__BackingField;
    [CompilerGeneratedAttribute]
private RemotingDataType <DataType>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RunspacePoolId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <PowerShellId>k__BackingField;
    [CompilerGeneratedAttribute]
private T <Data>k__BackingField;
    internal RemotingDestination Destination { get; }
    internal RemotingTargetInterface TargetInterface { get; }
    internal RemotingDataType DataType { get; }
    internal Guid RunspacePoolId { get; }
    internal Guid PowerShellId { get; }
    internal T Data { get; }
    protected RemoteDataObject`1(RemotingDestination destination, RemotingDataType dataType, Guid runspacePoolId, Guid powerShellId, T data);
    [CompilerGeneratedAttribute]
internal RemotingDestination get_Destination();
    internal RemotingTargetInterface get_TargetInterface();
    [CompilerGeneratedAttribute]
internal RemotingDataType get_DataType();
    [CompilerGeneratedAttribute]
internal Guid get_RunspacePoolId();
    [CompilerGeneratedAttribute]
internal Guid get_PowerShellId();
    [CompilerGeneratedAttribute]
internal T get_Data();
    internal static RemoteDataObject`1<T> CreateFrom(RemotingDestination destination, RemotingDataType dataType, Guid runspacePoolId, Guid powerShellId, T data);
    internal static RemoteDataObject`1<T> CreateFrom(Stream serializedDataStream, Fragmentor defragmentor);
    internal virtual void Serialize(Stream streamToWriteTo, Fragmentor fragmentor);
    private void SerializeHeader(Stream streamToWriteTo);
    private static void SerializeUInt(UInt32 data, Stream streamToWriteTo);
    private static UInt32 DeserializeUInt(Stream serializedDataStream);
    private static void SerializeGuid(Guid guid, Stream streamToWriteTo);
    private static Guid DeserializeGuid(Stream serializedDataStream);
}
internal class System.Management.Automation.Remoting.RemoteDebuggingCapability : object {
    private HashSet`1<string> _supportedCommands;
    [CompilerGeneratedAttribute]
private Version <PSVersion>k__BackingField;
    internal Version PSVersion { get; }
    private RemoteDebuggingCapability(Version powerShellVersion);
    [CompilerGeneratedAttribute]
internal Version get_PSVersion();
    internal static RemoteDebuggingCapability CreateDebuggingCapability(Version powerShellVersion);
    internal bool IsCommandSupported(string commandName);
}
internal static class System.Management.Automation.Remoting.RemoteDebuggingCommands : object {
    internal static string GetDebuggerStopArgs;
    internal static string SetDebuggerAction;
    internal static string SetDebuggerStepMode;
    internal static string SetDebugMode;
    internal static string SetUnhandledBreakpointMode;
    internal static string GetBreakpoint;
    internal static string SetBreakpoint;
    internal static string EnableBreakpoint;
    internal static string DisableBreakpoint;
    internal static string RemoveBreakpoint;
    internal static string CleanCommandName(string commandName);
}
internal class System.Management.Automation.Remoting.RemoteHostCall : object {
    [CompilerGeneratedAttribute]
private RemoteHostMethodId <MethodId>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    private RemoteHostMethodInfo _methodInfo;
    private long _callId;
    private string _computerName;
    internal string MethodName { get; }
    internal RemoteHostMethodId MethodId { get; }
    internal Object[] Parameters { get; }
    internal long CallId { get; }
    internal bool IsVoidMethod { get; }
    private MethodBase MyMethodBase { get; }
    internal bool IsSetShouldExit { get; }
    internal bool IsSetShouldExitOrPopRunspace { get; }
    internal RemoteHostCall(long callId, RemoteHostMethodId methodId, Object[] parameters);
    internal string get_MethodName();
    [CompilerGeneratedAttribute]
internal RemoteHostMethodId get_MethodId();
    [CompilerGeneratedAttribute]
internal Object[] get_Parameters();
    internal long get_CallId();
    private static PSObject EncodeParameters(Object[] parameters);
    private static Object[] DecodeParameters(PSObject parametersPSObject, Type[] parameterTypes);
    internal PSObject Encode();
    internal static RemoteHostCall Decode(PSObject data);
    internal bool get_IsVoidMethod();
    internal void ExecuteVoidMethod(PSHost clientHost);
    private static RemoteRunspace GetRemoteRunspaceToClose(PSHost clientHost);
    private MethodBase get_MyMethodBase();
    internal RemoteHostResponse ExecuteNonVoidMethod(PSHost clientHost);
    private RemoteHostResponse ExecuteNonVoidMethodOnObject(object instance);
    private object SelectTargetObject(PSHost host);
    internal bool get_IsSetShouldExit();
    internal bool get_IsSetShouldExitOrPopRunspace();
    internal Collection`1<RemoteHostCall> PerformSecurityChecksOnHostMessage(string computerName);
    private static string ModifyCaption(string caption);
    private static string ModifyMessage(string message, string computerName);
    private static RemoteHostCall ConstructWarningMessageForSecureString(string computerName, string resourceString);
    private static RemoteHostCall ConstructWarningMessageForGetBufferContents(string computerName);
}
internal static class System.Management.Automation.Remoting.RemoteHostEncoder : object {
    private static bool IsKnownType(Type type);
    private static bool IsEncodingAllowedForClassOrStruct(Type type);
    private static PSObject EncodeClassOrStruct(object obj);
    private static object DecodeClassOrStruct(PSObject psObject, Type type);
    private static bool IsCollection(Type type);
    private static bool IsGenericIEnumerableOfInt(Type type);
    private static PSObject EncodeCollection(IList collection);
    private static IList DecodeCollection(PSObject psObject, Type collectionType);
    private static bool IsDictionary(Type type);
    private static PSObject EncodeDictionary(IDictionary dictionary);
    private static IDictionary DecodeDictionary(PSObject psObject, Type dictionaryType);
    private static PSObject EncodePSObject(PSObject psObject);
    private static PSObject DecodePSObject(object obj);
    private static PSObject EncodeException(Exception exception);
    private static Exception DecodeException(PSObject psObject);
    private static FieldDescription UpcastFieldDescriptionSubclassAndDropAttributes(FieldDescription fieldDescription1);
    internal static object EncodeObject(object obj);
    internal static object DecodeObject(object obj, Type type);
    internal static void EncodeAndAddAsProperty(PSObject psObject, string propertyName, object propertyValue);
    internal static object DecodePropertyValue(PSObject psObject, string propertyName, Type propertyValueType);
    private static PSObject EncodeObjectArray(Object[] objects);
    private static Object[] DecodeObjectArray(PSObject psObject);
    private static PSObject EncodeObjectWithType(object obj);
    private static object DecodeObjectWithType(object obj);
    private static bool ArrayIsZeroBased(Array array);
    private static PSObject EncodeArray(Array array);
    private static Array DecodeArray(PSObject psObject, Type type);
    private static bool IsObjectDictionaryType(Type dictionaryType);
    private static PSObject EncodeObjectDictionary(IDictionary dictionary);
    private static IDictionary DecodeObjectDictionary(PSObject psObject, Type dictionaryType);
    private static T SafelyGetBaseObject(PSObject psObject);
    private static T SafelyCastObject(object obj);
    private static T SafelyGetPropertyValue(PSObject psObject, string key);
}
internal static class System.Management.Automation.Remoting.RemoteHostExceptions : object {
    internal static Exception NewRemoteRunspaceDoesNotSupportPushRunspaceException();
    internal static Exception NewDecodingFailedException();
    internal static Exception NewNotImplementedException(RemoteHostMethodId methodId);
    internal static Exception NewRemoteHostCallFailedException(RemoteHostMethodId methodId);
    internal static Exception NewDecodingErrorForErrorRecordException();
    internal static Exception NewRemoteHostDataEncodingNotSupportedException(Type type);
    internal static Exception NewRemoteHostDataDecodingNotSupportedException(Type type);
    internal static Exception NewUnknownTargetClassException(string className);
    internal static Exception NewNullClientHostException();
}
internal enum System.Management.Automation.Remoting.RemoteHostMethodId : Enum {
    public int value__;
    public static RemoteHostMethodId GetName;
    public static RemoteHostMethodId GetVersion;
    public static RemoteHostMethodId GetInstanceId;
    public static RemoteHostMethodId GetCurrentCulture;
    public static RemoteHostMethodId GetCurrentUICulture;
    public static RemoteHostMethodId SetShouldExit;
    public static RemoteHostMethodId EnterNestedPrompt;
    public static RemoteHostMethodId ExitNestedPrompt;
    public static RemoteHostMethodId NotifyBeginApplication;
    public static RemoteHostMethodId NotifyEndApplication;
    public static RemoteHostMethodId ReadLine;
    public static RemoteHostMethodId ReadLineAsSecureString;
    public static RemoteHostMethodId Write1;
    public static RemoteHostMethodId Write2;
    public static RemoteHostMethodId WriteLine1;
    public static RemoteHostMethodId WriteLine2;
    public static RemoteHostMethodId WriteLine3;
    public static RemoteHostMethodId WriteErrorLine;
    public static RemoteHostMethodId WriteDebugLine;
    public static RemoteHostMethodId WriteProgress;
    public static RemoteHostMethodId WriteVerboseLine;
    public static RemoteHostMethodId WriteWarningLine;
    public static RemoteHostMethodId Prompt;
    public static RemoteHostMethodId PromptForCredential1;
    public static RemoteHostMethodId PromptForCredential2;
    public static RemoteHostMethodId PromptForChoice;
    public static RemoteHostMethodId GetForegroundColor;
    public static RemoteHostMethodId SetForegroundColor;
    public static RemoteHostMethodId GetBackgroundColor;
    public static RemoteHostMethodId SetBackgroundColor;
    public static RemoteHostMethodId GetCursorPosition;
    public static RemoteHostMethodId SetCursorPosition;
    public static RemoteHostMethodId GetWindowPosition;
    public static RemoteHostMethodId SetWindowPosition;
    public static RemoteHostMethodId GetCursorSize;
    public static RemoteHostMethodId SetCursorSize;
    public static RemoteHostMethodId GetBufferSize;
    public static RemoteHostMethodId SetBufferSize;
    public static RemoteHostMethodId GetWindowSize;
    public static RemoteHostMethodId SetWindowSize;
    public static RemoteHostMethodId GetWindowTitle;
    public static RemoteHostMethodId SetWindowTitle;
    public static RemoteHostMethodId GetMaxWindowSize;
    public static RemoteHostMethodId GetMaxPhysicalWindowSize;
    public static RemoteHostMethodId GetKeyAvailable;
    public static RemoteHostMethodId ReadKey;
    public static RemoteHostMethodId FlushInputBuffer;
    public static RemoteHostMethodId SetBufferContents1;
    public static RemoteHostMethodId SetBufferContents2;
    public static RemoteHostMethodId GetBufferContents;
    public static RemoteHostMethodId ScrollBufferContents;
    public static RemoteHostMethodId PushRunspace;
    public static RemoteHostMethodId PopRunspace;
    public static RemoteHostMethodId GetIsRunspacePushed;
    public static RemoteHostMethodId GetRunspace;
    public static RemoteHostMethodId PromptForChoiceMultipleSelection;
}
internal class System.Management.Automation.Remoting.RemoteHostMethodInfo : object {
    [CompilerGeneratedAttribute]
private Type <InterfaceType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <ReturnType>k__BackingField;
    [CompilerGeneratedAttribute]
private Type[] <ParameterTypes>k__BackingField;
    internal Type InterfaceType { get; }
    internal string Name { get; }
    internal Type ReturnType { get; }
    internal Type[] ParameterTypes { get; }
    internal RemoteHostMethodInfo(Type interfaceType, string name, Type returnType, Type[] parameterTypes);
    [CompilerGeneratedAttribute]
internal Type get_InterfaceType();
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal Type get_ReturnType();
    [CompilerGeneratedAttribute]
internal Type[] get_ParameterTypes();
    internal static RemoteHostMethodInfo LookUp(RemoteHostMethodId methodId);
}
internal class System.Management.Automation.Remoting.RemoteHostResponse : object {
    private long _callId;
    private RemoteHostMethodId _methodId;
    private object _returnValue;
    private Exception _exception;
    internal long CallId { get; }
    internal RemoteHostResponse(long callId, RemoteHostMethodId methodId, object returnValue, Exception exception);
    internal long get_CallId();
    internal object SimulateExecution();
    private static void EncodeAndAddReturnValue(PSObject psObject, object returnValue);
    private static object DecodeReturnValue(PSObject psObject, Type returnType);
    private static void EncodeAndAddException(PSObject psObject, Exception exception);
    private static Exception DecodeException(PSObject psObject);
    internal PSObject Encode();
    internal static RemoteHostResponse Decode(PSObject data);
}
internal class System.Management.Automation.Remoting.RemoteSessionCapability : object {
    private Version _psversion;
    private Version _serversion;
    private Version _protocolVersion;
    private RemotingDestination _remotingDestination;
    internal Version ProtocolVersion { get; internal set; }
    internal Version PSVersion { get; }
    internal Version SerializationVersion { get; }
    internal RemotingDestination RemotingDestination { get; }
    internal RemoteSessionCapability(RemotingDestination remotingDestination);
    internal RemoteSessionCapability(RemotingDestination remotingDestination, Version protocolVersion, Version psVersion, Version serVersion);
    internal Version get_ProtocolVersion();
    internal void set_ProtocolVersion(Version value);
    internal Version get_PSVersion();
    internal Version get_SerializationVersion();
    internal RemotingDestination get_RemotingDestination();
    internal static RemoteSessionCapability CreateClientCapability();
    internal static RemoteSessionCapability CreateServerCapability();
}
internal class System.Management.Automation.Remoting.RemoteSessionHyperVSocketClient : object {
    private object _syncObject;
    private PowerShellTraceSource _tracer;
    private static ManualResetEvent s_connectDone;
    public static int HV_PROTOCOL_RAW;
    public static int HVSOCKET_CONTAINER_PASSTHRU;
    [CompilerGeneratedAttribute]
private HyperVSocketEndPoint <EndPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Socket <HyperVSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamReader <TextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamWriter <TextWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public HyperVSocketEndPoint EndPoint { get; }
    public Socket HyperVSocket { get; }
    public NetworkStream Stream { get; private set; }
    public StreamReader TextReader { get; private set; }
    public StreamWriter TextWriter { get; private set; }
    public bool IsDisposed { get; private set; }
    internal RemoteSessionHyperVSocketClient(Guid vmId, bool isFirstConnection, bool isContainer);
    private static RemoteSessionHyperVSocketClient();
    [CompilerGeneratedAttribute]
public HyperVSocketEndPoint get_EndPoint();
    [CompilerGeneratedAttribute]
public Socket get_HyperVSocket();
    [CompilerGeneratedAttribute]
public NetworkStream get_Stream();
    [CompilerGeneratedAttribute]
private void set_Stream(NetworkStream value);
    [CompilerGeneratedAttribute]
public StreamReader get_TextReader();
    [CompilerGeneratedAttribute]
private void set_TextReader(StreamReader value);
    [CompilerGeneratedAttribute]
public StreamWriter get_TextWriter();
    [CompilerGeneratedAttribute]
private void set_TextWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
    public bool Connect(NetworkCredential networkCredential, string configurationName, bool isFirstConnection);
    public void Close();
}
internal class System.Management.Automation.Remoting.RemoteSessionHyperVSocketServer : object {
    private object _syncObject;
    private PowerShellTraceSource _tracer;
    [CompilerGeneratedAttribute]
private Socket <HyperVSocket>k__BackingField;
    [CompilerGeneratedAttribute]
private NetworkStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamReader <TextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamWriter <TextWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    public Socket HyperVSocket { get; }
    public NetworkStream Stream { get; }
    public StreamReader TextReader { get; private set; }
    public StreamWriter TextWriter { get; private set; }
    public bool IsDisposed { get; private set; }
    public RemoteSessionHyperVSocketServer(bool LoopbackMode);
    [CompilerGeneratedAttribute]
public Socket get_HyperVSocket();
    [CompilerGeneratedAttribute]
public NetworkStream get_Stream();
    [CompilerGeneratedAttribute]
public StreamReader get_TextReader();
    [CompilerGeneratedAttribute]
private void set_TextReader(StreamReader value);
    [CompilerGeneratedAttribute]
public StreamWriter get_TextWriter();
    [CompilerGeneratedAttribute]
private void set_TextWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
public bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.Remoting.RemoteSessionNamedPipeClient : NamedPipeClientBase {
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _connecting;
    public RemoteSessionNamedPipeClient(Process process, string appDomainName);
    public RemoteSessionNamedPipeClient(int procId, string appDomainName);
    internal RemoteSessionNamedPipeClient(string pipeName);
    internal RemoteSessionNamedPipeClient(string serverName, string namespaceName, string coreName);
    public virtual void AbortConnect();
    protected virtual NamedPipeClientStream DoConnect(int timeout);
}
public class System.Management.Automation.Remoting.RemoteSessionNamedPipeServer : object {
    private object _syncObject;
    private PowerShellTraceSource _tracer;
    private static string _threadName;
    private static int _namedPipeBufferSizeForRemoting;
    private static int _maxPipePathLengthLinux;
    private static int _maxPipePathLengthMacOS;
    private static object s_syncObject;
    internal static RemoteSessionNamedPipeServer IPCNamedPipeServer;
    internal static bool IPCNamedPipeServerEnabled;
    private static RemoteSessionNamedPipeServer _customNamedPipeServer;
    private static int _pipeAccessMaskFullControl;
    [CompilerGeneratedAttribute]
private NamedPipeServerStream <Stream>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PipeName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsListenerRunning>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamReader <TextReader>k__BackingField;
    [CompilerGeneratedAttribute]
private StreamWriter <TextWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<ListenerEndedEventArgs> ListenerEnded;
    internal NamedPipeServerStream Stream { get; }
    internal string PipeName { get; }
    internal bool IsListenerRunning { get; private set; }
    internal string ConfigurationName { get; internal set; }
    internal StreamReader TextReader { get; private set; }
    internal StreamWriter TextWriter { get; private set; }
    internal bool IsDisposed { get; private set; }
    internal static int NamedPipeBufferSizeForRemoting { get; }
    internal RemoteSessionNamedPipeServer(string pipeName);
    private static RemoteSessionNamedPipeServer();
    [CompilerGeneratedAttribute]
internal NamedPipeServerStream get_Stream();
    [CompilerGeneratedAttribute]
internal string get_PipeName();
    [CompilerGeneratedAttribute]
internal bool get_IsListenerRunning();
    [CompilerGeneratedAttribute]
private void set_IsListenerRunning(bool value);
    [CompilerGeneratedAttribute]
internal string get_ConfigurationName();
    [CompilerGeneratedAttribute]
internal void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
internal StreamReader get_TextReader();
    [CompilerGeneratedAttribute]
private void set_TextReader(StreamReader value);
    [CompilerGeneratedAttribute]
internal StreamWriter get_TextWriter();
    [CompilerGeneratedAttribute]
private void set_TextWriter(StreamWriter value);
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    internal static int get_NamedPipeBufferSizeForRemoting();
    [CompilerGeneratedAttribute]
internal void add_ListenerEnded(EventHandler`1<ListenerEndedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ListenerEnded(EventHandler`1<ListenerEndedEventArgs> value);
    internal static RemoteSessionNamedPipeServer CreateRemoteSessionNamedPipeServer();
    private static NamedPipeServerStream CreateNamedPipe(string serverName, string namespaceName, string coreName, CommonSecurityDescriptor securityDesc);
    public sealed virtual void Dispose();
    public static void CreateCustomNamedPipeServer(string pipeName);
    internal void StartListening(Action`1<RemoteSessionNamedPipeServer> clientConnectCallback);
    internal static CommonSecurityDescriptor GetServerPipeSecurity();
    private void WaitForConnection();
    private void ProcessListeningThread(object state);
    internal static void RunServerMode(string configurationName);
    internal static void CreateIPCNamedPipeServerSingleton();
    private static void CreateProcessExitHandler();
    private static void OnIPCNamedPipeServerEnded(object sender, ListenerEndedEventArgs args);
    private static void OnCustomNamedPipeServerEnded(object sender, ListenerEndedEventArgs args);
    private static void ClientConnectionCallback(RemoteSessionNamedPipeServer pipeServer);
}
internal class System.Management.Automation.Remoting.RunspacePoolInitInfo : object {
    [CompilerGeneratedAttribute]
private int <MinRunspaces>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRunspaces>k__BackingField;
    internal int MinRunspaces { get; }
    internal int MaxRunspaces { get; }
    internal RunspacePoolInitInfo(int minRS, int maxRS);
    [CompilerGeneratedAttribute]
internal int get_MinRunspaces();
    [CompilerGeneratedAttribute]
internal int get_MaxRunspaces();
}
internal class System.Management.Automation.Remoting.RunspaceRef : object {
    private ObjectRef`1<Runspace> _runspaceRef;
    private bool _stopInvoke;
    private object _localSyncObject;
    private static RobustConnectionProgress s_RCProgress;
    internal Runspace Runspace { get; }
    internal Runspace OldRunspace { get; }
    internal bool IsRunspaceOverridden { get; }
    internal RunspaceRef(Runspace runspace);
    private static RunspaceRef();
    internal void Revert();
    internal Runspace get_Runspace();
    internal Runspace get_OldRunspace();
    internal bool get_IsRunspaceOverridden();
    private PSCommand ParsePsCommandUsingScriptBlock(string line, Nullable`1<bool> useLocalScope);
    internal PSCommand CreatePsCommand(string line, bool isScript, Nullable`1<bool> useNewScope);
    private static PSCommand CreatePsCommandNotOverridden(string line, bool isScript, Nullable`1<bool> useNewScope);
    internal Pipeline CreatePipeline(string line, bool addToHistory, bool useNestedPipelines);
    internal Pipeline CreatePipeline();
    internal Pipeline CreateNestedPipeline();
    internal void Override(RemoteRunspace remoteRunspace);
    internal void Override(RemoteRunspace remoteRunspace, object syncObject, Boolean& isRunspacePushed);
    private void HandleHostCall(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    private void HandleRCConnectionNotification(object sender, PSConnectionRetryStatusEventArgs e);
    private void WriteRCFailedError();
    private void StartProgressBar(long sourceId, string computerName, int totalSeconds);
    private static void StopProgressBar(long sourceId);
    [CompilerGeneratedAttribute]
private void <CreatePipeline>b__15_0(object sender, DataAddedEventArgs eventArgs);
}
internal class System.Management.Automation.Remoting.SerializedDataStream : Stream {
    [TraceSourceAttribute("SerializedDataStream", "SerializedDataStream")]
private static PSTraceSource s_trace;
    private static long s_objectIdSequenceNumber;
    private bool _isEntered;
    private FragmentedRemoteObject _currentFragment;
    private long _fragmentId;
    private int _fragmentSize;
    private object _syncObject;
    private bool _isDisposed;
    private bool _notifyOnWriteFragmentImmediately;
    private Queue`1<MemoryStream> _queuedStreams;
    private MemoryStream _writeStream;
    private MemoryStream _readStream;
    private int _writeOffset;
    private int _readOffSet;
    private long _length;
    private OnDataAvailableCallback _onDataAvailableCallback;
    private bool _disposed;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal SerializedDataStream(int fragmentSize);
    internal SerializedDataStream(int fragmentSize, OnDataAvailableCallback callbackToNotify);
    private static SerializedDataStream();
    internal void Enter();
    internal void Exit();
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual void WriteByte(byte value);
    internal Byte[] ReadOrRegisterCallback(OnDataAvailableCallback callback);
    internal Byte[] Read();
    public virtual int Read(Byte[] buffer, int offset, int count);
    private void WriteCurrentFragmentAndReset();
    private void EnqueueWriteStream();
    private static long GetObjectId();
    protected virtual void Dispose(bool disposing);
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual void Flush();
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public sealed virtual void Dispose();
}
internal abstract class System.Management.Automation.Remoting.Server.AbstractServerSessionTransportManager : AbstractServerTransportManager {
    protected AbstractServerSessionTransportManager(int fragmentSize, PSRemotingCryptoHelper cryptoHelper);
    internal abstract virtual AbstractServerTransportManager GetCommandTransportManager(Guid powerShellCmdId);
    internal abstract virtual void RemoveCommandTransportManager(Guid powerShellCmdId);
}
internal abstract class System.Management.Automation.Remoting.Server.AbstractServerTransportManager : BaseTransportManager {
    private object _syncObject;
    private OnDataAvailableCallback _onDataAvailable;
    private bool _shouldFlushData;
    private bool _reportAsPending;
    private Guid _runspacePoolInstanceId;
    private Guid _powerShellInstanceId;
    private RemotingDataType _dataType;
    private RemotingTargetInterface _targetInterface;
    private Queue`1<Tuple`3<RemoteDataObject, bool, bool>> _dataToBeSentQueue;
    private bool _isSerializing;
    [CompilerGeneratedAttribute]
private EventHandler Closing;
    protected AbstractServerTransportManager(int fragmentSize, PSRemotingCryptoHelper cryptoHelper);
    internal void SendDataToClient(RemoteDataObject`1<T> data, bool flush, bool reportPending);
    private void OnDataAvailable(Byte[] dataToSend, bool isEndFragment);
    internal void SendDataToClient(RemoteDataObject psObjectData, bool flush, bool reportAsPending);
    internal void ReportError(int errorCode, string methodName);
    internal void RaiseClosingEvent();
    [CompilerGeneratedAttribute]
internal void add_Closing(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_Closing(EventHandler value);
    protected abstract virtual void SendDataToClient(Byte[] data, bool flush, bool reportAsPending, bool reportAsDataBoundary);
    internal abstract virtual void ReportExecutionStatusAsRunning();
    internal abstract virtual void Close(Exception reasonForClose);
    internal virtual void Prepare();
}
internal class System.Management.Automation.Remoting.Server.FormattedErrorTextWriter : OutOfProcessTextWriter {
    internal FormattedErrorTextWriter(TextWriter textWriter);
    public virtual void WriteLine(string data);
}
internal class System.Management.Automation.Remoting.Server.HyperVSocketErrorTextWriter : OutOfProcessTextWriter {
    private static string _errorPrepend;
    internal static string ErrorPrepend { get; }
    internal HyperVSocketErrorTextWriter(TextWriter textWriter);
    internal static string get_ErrorPrepend();
    public virtual void WriteLine(string data);
}
internal class System.Management.Automation.Remoting.Server.HyperVSocketMediator : OutOfProcessMediatorBase {
    private static HyperVSocketMediator s_instance;
    private RemoteSessionHyperVSocketServer _hypervSocketServer;
    internal bool IsDisposed { get; }
    internal bool get_IsDisposed();
    internal static void Run(string initialCommand, string configurationName);
}
internal class System.Management.Automation.Remoting.Server.NamedPipeProcessMediator : OutOfProcessMediatorBase {
    private static NamedPipeProcessMediator s_singletonInstance;
    private RemoteSessionNamedPipeServer _namedPipeServer;
    internal bool IsDisposed { get; }
    private NamedPipeProcessMediator(RemoteSessionNamedPipeServer namedPipeServer);
    internal bool get_IsDisposed();
    internal static void Run(string initialCommand, RemoteSessionNamedPipeServer namedPipeServer);
}
internal abstract class System.Management.Automation.Remoting.Server.OutOfProcessMediatorBase : object {
    protected TextReader originalStdIn;
    protected OutOfProcessTextWriter originalStdOut;
    protected OutOfProcessTextWriter originalStdErr;
    protected OutOfProcessServerSessionTransportManager sessionTM;
    protected DataProcessingDelegates callbacks;
    protected static object SyncObject;
    protected object _syncObject;
    protected string _initialCommand;
    protected ManualResetEvent allcmdsClosedEvent;
    protected WindowsIdentity _windowsIdentityToImpersonate;
    protected int _inProgressCommandsCount;
    protected PowerShellTraceSource tracer;
    protected bool _exitProcessOnError;
    protected OutOfProcessMediatorBase(bool exitProcessOnError);
    private static OutOfProcessMediatorBase();
    protected void ProcessingThreadStart(object state);
    protected void OnDataPacketReceived(Byte[] rawData, string stream, Guid psGuid);
    protected void OnDataAckPacketReceived(Guid psGuid);
    protected void OnCommandCreationPacketReceived(Guid psGuid);
    protected void OnCommandCreationAckReceived(Guid psGuid);
    protected void OnSignalPacketReceived(Guid psGuid);
    protected void OnSignalAckPacketReceived(Guid psGuid);
    protected void OnClosePacketReceived(Guid psGuid);
    protected void OnCloseAckPacketReceived(Guid psGuid);
    protected OutOfProcessServerSessionTransportManager CreateSessionTransportManager(string configurationName, string configurationFile, PSRemotingCryptoHelperServer cryptoHelper, string workingDirectory);
    protected void Start(string initialCommand, PSRemotingCryptoHelperServer cryptoHelper, string workingDirectory, string configurationName, string configurationFile);
}
internal class System.Management.Automation.Remoting.Server.OutOfProcessServerSessionTransportManager : AbstractServerSessionTransportManager {
    private OutOfProcessTextWriter _stdOutWriter;
    private OutOfProcessTextWriter _stdErrWriter;
    private Dictionary`2<Guid, OutOfProcessServerTransportManager> _cmdTransportManagers;
    private object _syncObject;
    internal OutOfProcessServerSessionTransportManager(OutOfProcessTextWriter outWriter, OutOfProcessTextWriter errWriter, PSRemotingCryptoHelperServer cryptoHelper);
    internal virtual void ProcessRawData(Byte[] data, string stream);
    internal virtual void Prepare();
    protected virtual void SendDataToClient(Byte[] data, bool flush, bool reportAsPending, bool reportAsDataBoundary);
    internal virtual void ReportExecutionStatusAsRunning();
    internal void CreateCommandTransportManager(Guid powerShellCmdId);
    internal virtual AbstractServerTransportManager GetCommandTransportManager(Guid powerShellCmdId);
    internal virtual void RemoveCommandTransportManager(Guid powerShellCmdId);
    internal virtual void Close(Exception reasonForClose);
    [CompilerGeneratedAttribute]
private void <.ctor>b__4_0(object sender, TransportErrorOccuredEventArgs e);
}
internal class System.Management.Automation.Remoting.Server.OutOfProcessServerTransportManager : AbstractServerTransportManager {
    private OutOfProcessTextWriter _stdOutWriter;
    private OutOfProcessTextWriter _stdErrWriter;
    private Guid _powershellInstanceId;
    private bool _isDataAckSendPending;
    internal OutOfProcessServerTransportManager(OutOfProcessTextWriter stdOutWriter, OutOfProcessTextWriter stdErrWriter, Guid powershellInstanceId, TypeTable typeTableToUse, int fragmentSize, PSRemotingCryptoHelper cryptoHelper);
    private void HandleWSManTransportError(object sender, TransportErrorOccuredEventArgs e);
    internal virtual void ProcessRawData(Byte[] data, string stream);
    internal virtual void ReportExecutionStatusAsRunning();
    protected virtual void SendDataToClient(Byte[] data, bool flush, bool reportAsPending, bool reportAsDataBoundary);
    internal virtual void Prepare();
    internal virtual void Close(Exception reasonForClose);
}
internal static class System.Management.Automation.Remoting.Server.ServerOperationHelpers : object {
    internal static Byte[] ExtractEncodedXmlElement(string xmlBuffer, string xmlTag);
}
internal class System.Management.Automation.Remoting.Server.StdIOProcessMediator : OutOfProcessMediatorBase {
    private static StdIOProcessMediator s_singletonInstance;
    private StdIOProcessMediator(bool combineErrOutStream);
    internal static void Run(string initialCommand, string workingDirectory, string configurationName, string configurationFile, bool combineErrOutStream);
}
internal class System.Management.Automation.Remoting.ServerDispatchTable : DispatchTable`1<RemoteHostResponse> {
}
internal class System.Management.Automation.Remoting.ServerDriverRemoteHost : ServerRemoteHost {
    private RemoteRunspace _pushedRunspace;
    private ServerRemoteDebugger _debugger;
    private bool _hostSupportsPSEdit;
    [CompilerGeneratedAttribute]
private bool <PropagatePop>k__BackingField;
    public bool IsRunspacePushed { get; }
    internal Debugger ServerDebugger { get; internal set; }
    internal Runspace PushedRunspace { get; }
    internal bool PropagatePop { get; internal set; }
    internal ServerDriverRemoteHost(Guid clientRunspacePoolId, Guid clientPowerShellId, HostInfo hostInfo, AbstractServerSessionTransportManager transportManager, ServerRemoteDebugger debugger);
    public virtual bool get_IsRunspacePushed();
    public virtual void PushRunspace(Runspace runspace);
    public virtual void PopRunspace();
    internal Debugger get_ServerDebugger();
    internal void set_ServerDebugger(Debugger value);
    internal Runspace get_PushedRunspace();
    [CompilerGeneratedAttribute]
internal bool get_PropagatePop();
    [CompilerGeneratedAttribute]
internal void set_PropagatePop(bool value);
    private void AddPSEditForRunspace(RemoteRunspace remoteRunspace);
    private void RemovePSEditFromRunspace(RemoteRunspace remoteRunspace);
    private void HandleRemoteSessionForwardedEvent(object sender, PSEventArgs args);
}
internal class System.Management.Automation.Remoting.ServerMethodExecutor : object {
    private static long DefaultClientPipelineId;
    private Guid _clientRunspacePoolId;
    private Guid _clientPowerShellId;
    private ServerDispatchTable _serverDispatchTable;
    private RemotingDataType _remoteHostCallDataType;
    private AbstractServerTransportManager _transportManager;
    internal ServerMethodExecutor(Guid clientRunspacePoolId, Guid clientPowerShellId, AbstractServerTransportManager transportManager);
    internal void HandleRemoteHostResponseFromClient(RemoteHostResponse remoteHostResponse);
    internal void AbortAllCalls();
    internal void ExecuteVoidMethod(RemoteHostMethodId methodId);
    internal void ExecuteVoidMethod(RemoteHostMethodId methodId, Object[] parameters);
    internal T ExecuteMethod(RemoteHostMethodId methodId);
    internal T ExecuteMethod(RemoteHostMethodId methodId, Object[] parameters);
}
internal class System.Management.Automation.Remoting.ServerRemoteHost : PSHost {
    private ServerRemoteHostUserInterface _remoteHostUserInterface;
    private ServerMethodExecutor _serverMethodExecutor;
    private Guid _clientRunspacePoolId;
    private Guid _clientPowerShellId;
    protected AbstractServerTransportManager _transportManager;
    private ServerDriverRemoteHost _serverDriverRemoteHost;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    [CompilerGeneratedAttribute]
private HostInfo <HostInfo>k__BackingField;
    internal ServerMethodExecutor ServerMethodExecutor { get; }
    public PSHostUserInterface UI { get; }
    public string Name { get; }
    public Version Version { get; }
    public Guid InstanceId { get; }
    public bool IsRunspacePushed { get; }
    public Runspace Runspace { get; internal set; }
    internal HostInfo HostInfo { get; }
    public CultureInfo CurrentCulture { get; }
    public CultureInfo CurrentUICulture { get; }
    internal ServerRemoteHost(Guid clientRunspacePoolId, Guid clientPowerShellId, HostInfo hostInfo, AbstractServerTransportManager transportManager, Runspace runspace, ServerDriverRemoteHost serverDriverRemoteHost);
    internal ServerMethodExecutor get_ServerMethodExecutor();
    public virtual PSHostUserInterface get_UI();
    public virtual string get_Name();
    public virtual Version get_Version();
    [CompilerGeneratedAttribute]
public virtual Guid get_InstanceId();
    public virtual bool get_IsRunspacePushed();
    [CompilerGeneratedAttribute]
public sealed virtual Runspace get_Runspace();
    [CompilerGeneratedAttribute]
internal void set_Runspace(Runspace value);
    [CompilerGeneratedAttribute]
internal HostInfo get_HostInfo();
    public virtual void SetShouldExit(int exitCode);
    public virtual void EnterNestedPrompt();
    public virtual void ExitNestedPrompt();
    public virtual void NotifyBeginApplication();
    public virtual void NotifyEndApplication();
    public virtual CultureInfo get_CurrentCulture();
    public virtual CultureInfo get_CurrentUICulture();
    public virtual void PushRunspace(Runspace runspace);
    public virtual void PopRunspace();
}
internal class System.Management.Automation.Remoting.ServerRemoteHostRawUserInterface : PSHostRawUserInterface {
    private ServerRemoteHostUserInterface _remoteHostUserInterface;
    private ServerMethodExecutor _serverMethodExecutor;
    private HostDefaultData HostDefaultData { get; }
    public ConsoleColor ForegroundColor { get; public set; }
    public ConsoleColor BackgroundColor { get; public set; }
    public Coordinates CursorPosition { get; public set; }
    public Coordinates WindowPosition { get; public set; }
    public int CursorSize { get; public set; }
    public Size BufferSize { get; public set; }
    public Size WindowSize { get; public set; }
    public string WindowTitle { get; public set; }
    public Size MaxWindowSize { get; }
    public Size MaxPhysicalWindowSize { get; }
    public bool KeyAvailable { get; }
    internal ServerRemoteHostRawUserInterface(ServerRemoteHostUserInterface remoteHostUserInterface);
    private HostDefaultData get_HostDefaultData();
    public virtual ConsoleColor get_ForegroundColor();
    public virtual void set_ForegroundColor(ConsoleColor value);
    public virtual ConsoleColor get_BackgroundColor();
    public virtual void set_BackgroundColor(ConsoleColor value);
    public virtual Coordinates get_CursorPosition();
    public virtual void set_CursorPosition(Coordinates value);
    public virtual Coordinates get_WindowPosition();
    public virtual void set_WindowPosition(Coordinates value);
    public virtual int get_CursorSize();
    public virtual void set_CursorSize(int value);
    public virtual Size get_BufferSize();
    public virtual void set_BufferSize(Size value);
    public virtual Size get_WindowSize();
    public virtual void set_WindowSize(Size value);
    public virtual string get_WindowTitle();
    public virtual void set_WindowTitle(string value);
    public virtual Size get_MaxWindowSize();
    public virtual Size get_MaxPhysicalWindowSize();
    public virtual bool get_KeyAvailable();
    public virtual KeyInfo ReadKey(ReadKeyOptions options);
    public virtual void FlushInputBuffer();
    public virtual void ScrollBufferContents(Rectangle source, Coordinates destination, Rectangle clip, BufferCell fill);
    public virtual void SetBufferContents(Rectangle rectangle, BufferCell fill);
    public virtual void SetBufferContents(Coordinates origin, BufferCell[0...,0...] contents);
    public virtual BufferCell[0...,0...] GetBufferContents(Rectangle rectangle);
    public virtual int LengthInBufferCells(string source);
    public virtual int LengthInBufferCells(string source, int offset);
}
internal class System.Management.Automation.Remoting.ServerRemoteHostUserInterface : PSHostUserInterface {
    private ServerMethodExecutor _serverMethodExecutor;
    [CompilerGeneratedAttribute]
private PSHostRawUserInterface <RawUI>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerRemoteHost <ServerRemoteHost>k__BackingField;
    public PSHostRawUserInterface RawUI { get; }
    internal ServerRemoteHost ServerRemoteHost { get; }
    internal ServerRemoteHostUserInterface(ServerRemoteHost remoteHost);
    [CompilerGeneratedAttribute]
public virtual PSHostRawUserInterface get_RawUI();
    [CompilerGeneratedAttribute]
internal ServerRemoteHost get_ServerRemoteHost();
    public virtual string ReadLine();
    public virtual int PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, int defaultChoice);
    public sealed virtual Collection`1<int> PromptForChoice(string caption, string message, Collection`1<ChoiceDescription> choices, IEnumerable`1<int> defaultChoices);
    public virtual Dictionary`2<string, PSObject> Prompt(string caption, string message, Collection`1<FieldDescription> descriptions);
    public virtual void Write(string message);
    public virtual void Write(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string message);
    public virtual void WriteLine();
    public virtual void WriteLine(string message);
    public virtual void WriteLine(ConsoleColor foregroundColor, ConsoleColor backgroundColor, string message);
    public virtual void WriteErrorLine(string message);
    public virtual void WriteDebugLine(string message);
    public virtual void WriteProgress(long sourceId, ProgressRecord record);
    public virtual void WriteVerboseLine(string message);
    public virtual void WriteWarningLine(string message);
    public virtual SecureString ReadLineAsSecureString();
    public virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName);
    public virtual PSCredential PromptForCredential(string caption, string message, string userName, string targetName, PSCredentialTypes allowedCredentialTypes, PSCredentialUIOptions options);
}
internal class System.Management.Automation.Remoting.ServerRemoteSession : RemoteSession {
    [TraceSourceAttribute("ServerRemoteSession", "ServerRemoteSession")]
private static PSTraceSource s_trace;
    private PSSenderInfo _senderInfo;
    private string _configProviderId;
    private string _initParameters;
    private string _initScriptForOutOfProcRS;
    private PSSessionConfiguration _sessionConfigProvider;
    private Nullable`1<int> _maxRecvdObjectSize;
    private Nullable`1<int> _maxRecvdDataSizeCommand;
    private ServerRunspacePoolDriver _runspacePoolDriver;
    private PSRemotingCryptoHelperServer _cryptoHelper;
    private string _configurationName;
    private string _configurationFile;
    private string _initialLocation;
    internal EventHandler`1<RemoteSessionStateMachineEventArgs> Closed;
    [CompilerGeneratedAttribute]
private ServerRemoteSessionContext <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerRemoteSessionDataStructureHandler <SessionDataStructureHandler>k__BackingField;
    internal RemotingDestination MySelf { get; }
    internal ServerRemoteSessionContext Context { get; }
    internal ServerRemoteSessionDataStructureHandler SessionDataStructureHandler { get; }
    internal ServerRemoteSession(PSSenderInfo senderInfo, string configurationProviderId, string initializationParameters, AbstractServerSessionTransportManager transportManager);
    private static ServerRemoteSession();
    internal static ServerRemoteSession CreateServerRemoteSession(PSSenderInfo senderInfo, string configurationProviderId, string initializationParameters, AbstractServerSessionTransportManager transportManager, string initialCommand, string configurationName, string configurationFile, string initialLocation);
    internal virtual RemotingDestination get_MySelf();
    internal void DispatchInputQueueData(object sender, RemoteDataEventArgs dataEventArg);
    private void HandlePublicKeyReceived(object sender, RemoteDataEventArgs`1<string> eventArgs);
    internal virtual void StartKeyExchange();
    internal virtual void CompleteKeyExchange();
    internal void SendEncryptedSessionKey();
    [CompilerGeneratedAttribute]
internal ServerRemoteSessionContext get_Context();
    [CompilerGeneratedAttribute]
internal ServerRemoteSessionDataStructureHandler get_SessionDataStructureHandler();
    internal void Close(RemoteSessionStateMachineEventArgs reasonForClose);
    internal void ExecuteConnect(Byte[] connectData, Byte[]& connectResponseData);
    internal void HandlePostConnect();
    private void HandleCreateRunspacePool(object sender, RemoteDataEventArgs createRunspaceEventArg);
    private void HandleNegotiationReceived(object sender, RemoteSessionNegotiationEventArgs negotiationEventArg);
    private void HandleSessionDSHandlerClosing(object sender, EventArgs eventArgs);
    private void HandleResourceClosing(object sender, EventArgs args);
    private bool RunServerNegotiationAlgorithm(RemoteSessionCapability clientCapability, bool onConnect);
    internal ServerRunspacePoolDriver GetRunspacePoolDriver(Guid clientRunspacePoolId);
    internal void ApplyQuotaOnCommandTransportManager(AbstractServerTransportManager cmdTransportManager);
    [CompilerGeneratedAttribute]
private void <ExecuteConnect>b__30_0(object state);
}
internal class System.Management.Automation.Remoting.ServerRemoteSessionContext : object {
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <ClientCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteSessionCapability <ServerCapability>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsNegotiationSucceeded>k__BackingField;
    internal RemoteSessionCapability ClientCapability { get; internal set; }
    internal RemoteSessionCapability ServerCapability { get; internal set; }
    internal bool IsNegotiationSucceeded { get; internal set; }
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_ClientCapability();
    [CompilerGeneratedAttribute]
internal void set_ClientCapability(RemoteSessionCapability value);
    [CompilerGeneratedAttribute]
internal RemoteSessionCapability get_ServerCapability();
    [CompilerGeneratedAttribute]
internal void set_ServerCapability(RemoteSessionCapability value);
    [CompilerGeneratedAttribute]
internal bool get_IsNegotiationSucceeded();
    [CompilerGeneratedAttribute]
internal void set_IsNegotiationSucceeded(bool value);
}
internal abstract class System.Management.Automation.Remoting.ServerRemoteSessionDataStructureHandler : BaseSessionDataStructureHandler {
    internal ServerRemoteSessionDSHandlerStateMachine StateMachine { get; }
    internal AbstractServerSessionTransportManager TransportManager { get; }
    internal abstract virtual void ConnectAsync();
    internal abstract virtual void SendNegotiationAsync();
    [CompilerGeneratedAttribute]
internal abstract virtual void add_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    internal abstract virtual void CloseConnectionAsync(Exception reasonForClose);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_SessionClosing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_SessionClosing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_CreateRunspacePoolReceived(EventHandler`1<RemoteDataEventArgs> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_CreateRunspacePoolReceived(EventHandler`1<RemoteDataEventArgs> value);
    internal abstract virtual ServerRemoteSessionDSHandlerStateMachine get_StateMachine();
    internal abstract virtual AbstractServerSessionTransportManager get_TransportManager();
    internal abstract virtual void RaiseDataReceivedEvent(RemoteDataEventArgs arg);
    [CompilerGeneratedAttribute]
internal abstract virtual void add_PublicKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal abstract virtual void remove_PublicKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    internal abstract virtual void SendRequestForPublicKey();
    internal abstract virtual void SendEncryptedSessionKey(string encryptedSessionKey);
}
internal class System.Management.Automation.Remoting.ServerRemoteSessionDSHandlerImpl : ServerRemoteSessionDataStructureHandler {
    private AbstractServerSessionTransportManager _transportManager;
    private ServerRemoteSessionDSHandlerStateMachine _stateMachine;
    private ServerRemoteSession _session;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteSessionNegotiationEventArgs> NegotiationReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> SessionClosing;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<string>> PublicKeyReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs> CreateRunspacePoolReceived;
    internal AbstractServerSessionTransportManager TransportManager { get; }
    internal ServerRemoteSessionDSHandlerStateMachine StateMachine { get; }
    internal ServerRemoteSessionDSHandlerImpl(ServerRemoteSession session, AbstractServerSessionTransportManager transportManager);
    internal virtual AbstractServerSessionTransportManager get_TransportManager();
    internal virtual void ConnectAsync();
    internal virtual void SendNegotiationAsync();
    [CompilerGeneratedAttribute]
internal virtual void add_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_NegotiationReceived(EventHandler`1<RemoteSessionNegotiationEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void add_SessionClosing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_SessionClosing(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void add_PublicKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_PublicKeyReceived(EventHandler`1<RemoteDataEventArgs`1<string>> value);
    internal virtual void SendEncryptedSessionKey(string encryptedSessionKey);
    internal virtual void SendRequestForPublicKey();
    internal virtual void RaiseKeyExchangeMessageReceived(RemoteDataObject`1<PSObject> receivedData);
    internal virtual void CloseConnectionAsync(Exception reasonForClose);
    [CompilerGeneratedAttribute]
internal virtual void add_CreateRunspacePoolReceived(EventHandler`1<RemoteDataEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_CreateRunspacePoolReceived(EventHandler`1<RemoteDataEventArgs> value);
    internal virtual ServerRemoteSessionDSHandlerStateMachine get_StateMachine();
    internal virtual void RaiseDataReceivedEvent(RemoteDataEventArgs dataArg);
}
internal class System.Management.Automation.Remoting.ServerRemoteSessionDSHandlerStateMachine : object {
    [TraceSourceAttribute("ServerRemoteSessionDSHandlerStateMachine", "ServerRemoteSessionDSHandlerStateMachine")]
private static PSTraceSource s_trace;
    private ServerRemoteSession _session;
    private object _syncObject;
    private Queue`1<RemoteSessionStateMachineEventArgs> _processPendingEventsQueue;
    private bool _eventsInProcess;
    private EventHandler`1[0...,0...] _stateMachineHandle;
    private RemoteSessionState _state;
    private Timer _keyExchangeTimer;
    internal RemoteSessionState State { get; }
    internal ServerRemoteSessionDSHandlerStateMachine(ServerRemoteSession session);
    private static ServerRemoteSessionDSHandlerStateMachine();
    internal RemoteSessionState get_State();
    internal bool CanByPassRaiseEvent(RemoteSessionStateMachineEventArgs arg);
    internal void RaiseEvent(RemoteSessionStateMachineEventArgs fsmEventArg);
    private void ProcessEvents();
    private void RaiseEventPrivate(RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoCreateSession(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationPending(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationReceived(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationSending(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationCompleted(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoEstablished(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    internal void DoMessageReceived(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoConnectFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoFatalError(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoConnect(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoClose(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoCloseFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoCloseCompleted(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoNegotiationTimeout(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoSendFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoReceiveFailed(object sender, RemoteSessionStateMachineEventArgs fsmEventArg);
    private void DoKeyExchange(object sender, RemoteSessionStateMachineEventArgs eventArgs);
    private void HandleKeyExchangeTimeout(object sender);
    private static void CleanAll();
    private void SetState(RemoteSessionState newState, Exception reason);
}
public enum System.Management.Automation.Remoting.SessionType : Enum {
    public int value__;
    public static SessionType Empty;
    public static SessionType RestrictedRemoteServer;
    public static SessionType Default;
}
internal class System.Management.Automation.Remoting.ThrottleManager : object {
    private int _throttleLimit;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> ThrottleComplete;
    private static int s_DEFAULT_THROTTLE_LIMIT;
    private static int s_THROTTLE_LIMIT_MAX;
    private List`1<IThrottleOperation> _operationsQueue;
    private List`1<IThrottleOperation> _startOperationQueue;
    private List`1<IThrottleOperation> _stopOperationQueue;
    private object _syncObject;
    private bool _submitComplete;
    private bool _stopping;
    internal int ThrottleLimit { get; internal set; }
    private static ThrottleManager();
    internal int get_ThrottleLimit();
    internal void set_ThrottleLimit(int value);
    internal void SubmitOperations(List`1<IThrottleOperation> operations);
    internal void AddOperation(IThrottleOperation operation);
    internal void StopAllOperations();
    internal void StopOperation(IThrottleOperation operation);
    internal void EndSubmitOperations();
    [CompilerGeneratedAttribute]
internal void add_ThrottleComplete(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ThrottleComplete(EventHandler`1<EventArgs> value);
    private void OperationCompleteHandler(object source, OperationStateEventArgs stateEventArgs);
    private void StartOneOperationFromQueue();
    private void StartOperationsFromQueue();
    private void RaiseThrottleManagerEvents();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
}
public class System.Management.Automation.Remoting.TransportErrorOccuredEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PSRemotingTransportException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private TransportMethodEnum <ReportingTransportMethod>k__BackingField;
    internal PSRemotingTransportException Exception { get; internal set; }
    internal TransportMethodEnum ReportingTransportMethod { get; }
    public TransportErrorOccuredEventArgs(PSRemotingTransportException e, TransportMethodEnum m);
    [CompilerGeneratedAttribute]
internal PSRemotingTransportException get_Exception();
    [CompilerGeneratedAttribute]
internal void set_Exception(PSRemotingTransportException value);
    [CompilerGeneratedAttribute]
internal TransportMethodEnum get_ReportingTransportMethod();
}
public enum System.Management.Automation.Remoting.TransportMethodEnum : Enum {
    public int value__;
    public static TransportMethodEnum CreateShellEx;
    public static TransportMethodEnum RunShellCommandEx;
    public static TransportMethodEnum SendShellInputEx;
    public static TransportMethodEnum ReceiveShellOutputEx;
    public static TransportMethodEnum CloseShellOperationEx;
    public static TransportMethodEnum CommandInputEx;
    public static TransportMethodEnum ReceiveCommandOutputEx;
    public static TransportMethodEnum DisconnectShellEx;
    public static TransportMethodEnum ReconnectShellEx;
    public static TransportMethodEnum ConnectShellEx;
    public static TransportMethodEnum ReconnectShellCommandEx;
    public static TransportMethodEnum ConnectShellCommandEx;
    public static TransportMethodEnum Unknown;
}
internal class System.Management.Automation.Remoting.WaitOrTimerCallbackDelegate : MulticastDelegate {
    public WaitOrTimerCallbackDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr state, bool timedOut);
    public virtual IAsyncResult BeginInvoke(IntPtr state, bool timedOut, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Management.Automation.Remoting.WSMan.ActiveSessionsChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private int <ActiveSessionsCount>k__BackingField;
    public int ActiveSessionsCount { get; internal set; }
    public ActiveSessionsChangedEventArgs(int activeSessionsCount);
    [CompilerGeneratedAttribute]
public int get_ActiveSessionsCount();
    [CompilerGeneratedAttribute]
internal void set_ActiveSessionsCount(int value);
}
public static class System.Management.Automation.Remoting.WSMan.WSManServerChannelEvents : object {
    [CompilerGeneratedAttribute]
private static EventHandler ShuttingDown;
    [CompilerGeneratedAttribute]
private static EventHandler`1<ActiveSessionsChangedEventArgs> ActiveSessionsChanged;
    [CompilerGeneratedAttribute]
public static void add_ShuttingDown(EventHandler value);
    [CompilerGeneratedAttribute]
public static void remove_ShuttingDown(EventHandler value);
    [CompilerGeneratedAttribute]
public static void add_ActiveSessionsChanged(EventHandler`1<ActiveSessionsChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_ActiveSessionsChanged(EventHandler`1<ActiveSessionsChangedEventArgs> value);
    internal static void RaiseShuttingDownEvent();
    internal static void RaiseActiveSessionsChangedEvent(ActiveSessionsChangedEventArgs eventArgs);
}
internal class System.Management.Automation.Remoting.WSManPluginCommandDelegate : MulticastDelegate {
    public WSManPluginCommandDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, string commandLine, IntPtr arguments);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, string commandLine, IntPtr arguments, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginCommandSession : WSManPluginServerSession {
    private ServerRemoteSession _remoteSession;
    internal object cmdSyncObject;
    internal WSManPluginCommandSession(WSManPluginRequest creationRequestDetails, WSManPluginServerTransportManager transportMgr, ServerRemoteSession remoteSession);
    internal bool ProcessArguments(WSManCommandArgSet arguments);
    internal void Stop(WSManPluginRequest requestDetails);
    internal virtual void CloseOperation(WSManPluginOperationShutdownContext context, Exception reasonForClose);
    internal virtual void ExecuteConnect(WSManPluginRequest requestDetails, int flags, WSManData_UnToMan inboundConnectInformation);
}
internal class System.Management.Automation.Remoting.WSManPluginCommandTransportManager : WSManPluginServerTransportManager {
    private WSManPluginServerTransportManager _serverTransportMgr;
    private Guid _cmdId;
    internal WSManPluginCommandTransportManager(WSManPluginServerTransportManager srvrTransportMgr);
    internal void Initialize();
    private void OnPowershellGuidReported(object src, EventArgs args);
}
internal class System.Management.Automation.Remoting.WSManPluginConnectDelegate : MulticastDelegate {
    public WSManPluginConnectDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr inboundConnectInformation);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr inboundConnectInformation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Management.Automation.Remoting.WSManPluginConstants : object {
    internal static int ExitCodeSuccess;
    internal static int ExitCodeFailure;
    internal static string CtrlCSignal;
    internal static string SupportedInputStream;
    internal static string SupportedOutputStream;
    internal static string SupportedPromptResponseStream;
    internal static string PowerShellStartupProtocolVersionName;
    internal static string PowerShellStartupProtocolVersionValue;
    internal static string PowerShellOptionPrefix;
    internal static int WSManPluginParamsGetRequestedLocale;
    internal static int WSManPluginParamsGetRequestedDataLocale;
}
internal class System.Management.Automation.Remoting.WSManPluginEntryDelegates : object {
    private WSManPluginEntryDelegatesInternal _unmanagedStruct;
    private bool _disposed;
    private GCHandle _pluginShellGCHandle;
    private GCHandle _pluginReleaseShellContextGCHandle;
    private GCHandle _pluginCommandGCHandle;
    private GCHandle _pluginReleaseCommandContextGCHandle;
    private GCHandle _pluginSendGCHandle;
    private GCHandle _pluginReceiveGCHandle;
    private GCHandle _pluginSignalGCHandle;
    private GCHandle _pluginConnectGCHandle;
    private GCHandle _shutdownPluginGCHandle;
    private GCHandle _WSManPluginOperationShutdownGCHandle;
    internal WSManPluginEntryDelegatesInternal UnmanagedStruct { get; }
    internal WSManPluginEntryDelegatesInternal get_UnmanagedStruct();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    private void populateDelegates();
    private void CleanUpDelegates();
}
internal enum System.Management.Automation.Remoting.WSManPluginErrorCodes : Enum {
    public int value__;
    public static WSManPluginErrorCodes NullPluginContext;
    public static WSManPluginErrorCodes PluginContextNotFound;
    public static WSManPluginErrorCodes NullInvalidInput;
    public static WSManPluginErrorCodes NullInvalidStreamSets;
    public static WSManPluginErrorCodes SessionCreationFailed;
    public static WSManPluginErrorCodes NullShellContext;
    public static WSManPluginErrorCodes InvalidShellContext;
    public static WSManPluginErrorCodes InvalidCommandContext;
    public static WSManPluginErrorCodes InvalidInputStream;
    public static WSManPluginErrorCodes InvalidInputDatatype;
    public static WSManPluginErrorCodes InvalidOutputStream;
    public static WSManPluginErrorCodes InvalidSenderDetails;
    public static WSManPluginErrorCodes ShutdownRegistrationFailed;
    public static WSManPluginErrorCodes ReportContextFailed;
    public static WSManPluginErrorCodes InvalidArgSet;
    public static WSManPluginErrorCodes ProtocolVersionNotMatch;
    public static WSManPluginErrorCodes OptionNotUnderstood;
    public static WSManPluginErrorCodes ProtocolVersionNotFound;
    public static WSManPluginErrorCodes ManagedException;
    public static WSManPluginErrorCodes PluginOperationClose;
    public static WSManPluginErrorCodes PluginConnectNoNegotiationData;
    public static WSManPluginErrorCodes PluginConnectOperationFailed;
    public static WSManPluginErrorCodes NoError;
    public static WSManPluginErrorCodes OutOfMemory;
}
internal class System.Management.Automation.Remoting.WSManPluginInstance : object {
    private Dictionary`2<IntPtr, WSManPluginShellSession> _activeShellSessions;
    private object _syncObject;
    private static Dictionary`2<IntPtr, WSManPluginInstance> s_activePlugins;
    internal static IWSManNativeApiFacade wsmanPinvokeStatic;
    private static string WSManRunAsClientTokenName;
    private static WSManPluginInstance();
    internal void CreateShell(IntPtr pluginContext, WSManPluginRequest requestDetails, int flags, string extraInfo, WSManShellStartupInfo_UnToMan startupInfo, WSManData_UnToMan inboundShellInformation);
    internal void CloseShellOperation(WSManPluginOperationShutdownContext context);
    internal void CloseCommandOperation(WSManPluginOperationShutdownContext context);
    private void AddToActiveShellSessions(WSManPluginShellSession newShellSession);
    private WSManPluginShellSession GetFromActiveShellSessions(IntPtr key);
    private void DeleteFromActiveShellSessions(IntPtr keyToDelete);
    private void HandleShellSessionClosed(object source, EventArgs e);
    private static bool validateIncomingContexts(WSManPluginRequest requestDetails, IntPtr shellContext, string inputFunctionName);
    internal void CreateCommand(IntPtr pluginContext, WSManPluginRequest requestDetails, int flags, IntPtr shellContext, string commandLine, WSManCommandArgSet arguments);
    internal void StopCommand(WSManPluginRequest requestDetails, IntPtr shellContext, IntPtr commandContext);
    internal void Shutdown();
    internal void ConnectShellOrCommand(WSManPluginRequest requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, WSManData_UnToMan inboundConnectInformation);
    internal void SendOneItemToShellOrCommand(WSManPluginRequest requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string stream, WSManData_UnToMan inboundData);
    internal void EnableShellOrCommandToSendDataToClient(IntPtr pluginContext, WSManPluginRequest requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, WSManStreamIDSet_UnToMan streamSet);
    private static PSSenderInfo GetPSSenderInfo(WSManSenderDetails senderDetails);
    private static IntPtr GetRunAsClientToken();
    protected internal bool EnsureOptionsComply(WSManPluginRequest requestDetails);
    protected internal bool EnsureProtocolVersionComplies(WSManPluginRequest requestDetails, string clientVersionString);
    internal static void PerformWSManPluginShell(IntPtr pluginContext, IntPtr requestDetails, int flags, string extraInfo, IntPtr startupInfo, IntPtr inboundShellInformation);
    internal static void PerformWSManPluginCommand(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, string commandLine, IntPtr arguments);
    internal static void PerformWSManPluginConnect(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr inboundConnectInformation);
    internal static void PerformWSManPluginSend(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string stream, IntPtr inboundData);
    internal static void PerformWSManPluginReceive(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr streamSet);
    internal static void PerformWSManPluginSignal(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string code);
    internal static void PerformCloseOperation(WSManPluginOperationShutdownContext context);
    internal static void PerformShutdown(IntPtr pluginContext);
    private static WSManPluginInstance GetFromActivePlugins(IntPtr pluginContext);
    private static void AddToActivePlugins(IntPtr pluginContext, WSManPluginInstance plugin);
    internal static void ReportWSManOperationComplete(WSManPluginRequest requestDetails, WSManPluginErrorCodes errorCode);
    internal static void ReportWSManOperationComplete(WSManPluginRequest requestDetails, Exception reasonForClose);
    internal static void SetThreadProperties(WSManPluginRequest requestDetails);
    internal static void ReportOperationComplete(WSManPluginRequest requestDetails, WSManPluginErrorCodes errorCode, string errorMessage);
    internal static void ReportOperationComplete(WSManPluginRequest requestDetails, WSManPluginErrorCodes errorCode);
    internal static void ReportOperationComplete(IntPtr requestDetails, WSManPluginErrorCodes errorCode, string errorMessage);
}
public class System.Management.Automation.Remoting.WSManPluginManagedEntryInstanceWrapper : object {
    private bool _disposed;
    private GCHandle _initDelegateHandle;
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    protected virtual override void Finalize();
    public IntPtr GetEntryDelegate();
}
public class System.Management.Automation.Remoting.WSManPluginManagedEntryWrapper : object {
    internal static WSManPluginEntryDelegates workerPtrs;
    private static WSManPluginManagedEntryWrapper();
    public static int InitPlugin(IntPtr wkrPtrs);
    public static void ShutdownPlugin(IntPtr pluginContext);
    public static void WSManPluginConnect(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr inboundConnectInformation);
    public static void WSManPluginShell(IntPtr pluginContext, IntPtr requestDetails, int flags, string extraInfo, IntPtr startupInfo, IntPtr inboundShellInformation);
    public static void WSManPluginReleaseShellContext(IntPtr pluginContext, IntPtr shellContext);
    public static void WSManPluginCommand(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, string commandLine, IntPtr arguments);
    public static void WSManPSShutdown(IntPtr shutdownContext);
    public static void WSManPluginReleaseCommandContext(IntPtr pluginContext, IntPtr shellContext, IntPtr commandContext);
    public static void WSManPluginSend(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string stream, IntPtr inboundData);
    public static void WSManPluginReceive(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr streamSet);
    public static void WSManPluginSignal(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string code);
    public static void PSPluginOperationShutdownCallback(object operationContext, bool timedOut);
}
internal class System.Management.Automation.Remoting.WSManPluginOperationShutdownContext : object {
    internal IntPtr pluginContext;
    internal IntPtr shellContext;
    internal IntPtr commandContext;
    internal bool isReceiveOperation;
    internal bool isShuttingDown;
    internal WSManPluginOperationShutdownContext(IntPtr plgContext, IntPtr shContext, IntPtr cmdContext, bool isRcvOp);
}
internal class System.Management.Automation.Remoting.WSManPluginOperationShutdownDelegate : MulticastDelegate {
    public WSManPluginOperationShutdownDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr shutdownContext);
    public virtual IAsyncResult BeginInvoke(IntPtr shutdownContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginReceiveDelegate : MulticastDelegate {
    public WSManPluginReceiveDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr streamSet);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, IntPtr streamSet, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginReleaseCommandContextDelegate : MulticastDelegate {
    public WSManPluginReleaseCommandContextDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr shellContext, IntPtr commandContext);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr shellContext, IntPtr commandContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginReleaseShellContextDelegate : MulticastDelegate {
    public WSManPluginReleaseShellContextDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr shellContext);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr shellContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginSendDelegate : MulticastDelegate {
    public WSManPluginSendDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string stream, IntPtr inboundData);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string stream, IntPtr inboundData, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal abstract class System.Management.Automation.Remoting.WSManPluginServerSession : object {
    private object _syncObject;
    protected bool isClosed;
    protected bool isContextReported;
    protected Exception lastErrorReported;
    internal WSManPluginRequest creationRequestDetails;
    internal WSManPluginRequest sendRequestDetails;
    internal WSManPluginOperationShutdownContext shutDownContext;
    internal RegisteredWaitHandle registeredShutDownWaitHandle;
    internal WSManPluginServerTransportManager transportMgr;
    internal int registeredShutdownNotification;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> SessionClosed;
    private bool _disposed;
    protected WSManPluginServerSession(WSManPluginRequest creationRequestDetails, WSManPluginServerTransportManager transportMgr);
    [CompilerGeneratedAttribute]
internal void add_SessionClosed(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionClosed(EventHandler`1<EventArgs> value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal void SendOneItemToSession(WSManPluginRequest requestDetails, int flags, string stream, WSManData_UnToMan inboundData);
    internal void SendOneItemToSessionHelper(Byte[] data, string stream);
    internal bool EnableSessionToSendDataToClient(WSManPluginRequest requestDetails, int flags, WSManStreamIDSet_UnToMan streamSet, WSManPluginOperationShutdownContext ctxtToReport);
    internal void ReportContext();
    protected internal void SafeInvokeSessionClosed(object sender, EventArgs eventArgs);
    internal void HandleTransportError(object sender, TransportErrorOccuredEventArgs eventArgs);
    internal void HandlePrepareFromTransportManager(object sender, EventArgs eventArgs);
    internal void Close(bool isShuttingDown);
    internal void Close(Exception reasonForClose);
    internal void ReportSendOperationComplete();
    internal abstract virtual void CloseOperation(WSManPluginOperationShutdownContext context, Exception reasonForClose);
    internal abstract virtual void ExecuteConnect(WSManPluginRequest requestDetails, int flags, WSManData_UnToMan inboundConnectInformation);
}
internal class System.Management.Automation.Remoting.WSManPluginServerTransportManager : AbstractServerSessionTransportManager {
    private WSManPluginRequest _requestDetails;
    private bool _isRequestPending;
    private object _syncObject;
    private ManualResetEvent _waitHandle;
    private Dictionary`2<Guid, WSManPluginServerTransportManager> _activeCmdTransportManagers;
    private bool _isClosed;
    private Exception _lastErrorReported;
    private WSManPluginOperationShutdownContext _shutDownContext;
    private RegisteredWaitHandle _registeredShutDownWaitHandle;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> PrepareCalled;
    internal WSManPluginServerTransportManager(int fragmentSize, PSRemotingCryptoHelper cryptoHelper);
    [CompilerGeneratedAttribute]
public void add_PrepareCalled(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_PrepareCalled(EventHandler`1<EventArgs> value);
    internal virtual void Close(Exception reasonForClose);
    internal void DoClose(bool isShuttingDown, Exception reasonForClose);
    internal virtual void ReportExecutionStatusAsRunning();
    protected virtual void SendDataToClient(Byte[] data, bool flush, bool reportAsPending, bool reportAsDataBoundary);
    internal virtual void Prepare();
    internal virtual AbstractServerTransportManager GetCommandTransportManager(Guid powerShellCmdId);
    internal void ReportTransportMgrForCmd(Guid cmdId, WSManPluginServerTransportManager transportManager);
    internal virtual void RemoveCommandTransportManager(Guid cmdId);
    internal bool EnableTransportManagerSendDataToClient(WSManPluginRequest requestDetails, WSManPluginOperationShutdownContext ctxtToReport);
    internal void PerformStop();
}
internal class System.Management.Automation.Remoting.WSManPluginShellDelegate : MulticastDelegate {
    public WSManPluginShellDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, string extraInfo, IntPtr startupInfo, IntPtr inboundShellInformation);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, string extraInfo, IntPtr startupInfo, IntPtr inboundShellInformation, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManPluginShellSession : WSManPluginServerSession {
    private Dictionary`2<IntPtr, WSManPluginCommandSession> _activeCommandSessions;
    private ServerRemoteSession _remoteSession;
    internal object shellSyncObject;
    internal WSManPluginShellSession(WSManPluginRequest creationRequestDetails, WSManPluginServerTransportManager transportMgr, ServerRemoteSession remoteSession, WSManPluginOperationShutdownContext shutDownContext);
    internal virtual void ExecuteConnect(WSManPluginRequest requestDetails, int flags, WSManData_UnToMan inboundConnectInformation);
    internal void CreateCommand(IntPtr pluginContext, WSManPluginRequest requestDetails, int flags, string commandLine, WSManCommandArgSet arguments);
    internal void CloseCommandOperation(WSManPluginOperationShutdownContext context);
    private void AddToActiveCmdSessions(WSManPluginCommandSession newCmdSession);
    private void DeleteFromActiveCmdSessions(IntPtr keyToDelete);
    private void CloseAndClearCommandSessions(Exception reasonForClose);
    internal WSManPluginCommandSession GetCommandSession(IntPtr cmdContext);
    private void HandleServerRemoteSessionClosed(object sender, RemoteSessionStateMachineEventArgs eventArgs);
    private void HandleCommandSessionClosed(object source, EventArgs e);
    internal virtual void CloseOperation(WSManPluginOperationShutdownContext context, Exception reasonForClose);
}
internal class System.Management.Automation.Remoting.WSManPluginSignalDelegate : MulticastDelegate {
    public WSManPluginSignalDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string code);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, IntPtr requestDetails, int flags, IntPtr shellContext, IntPtr commandContext, string code, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.Remoting.WSManShutdownPluginDelegate : MulticastDelegate {
    public WSManShutdownPluginDelegate(object object, IntPtr method);
    public virtual void Invoke(IntPtr pluginContext);
    public virtual IAsyncResult BeginInvoke(IntPtr pluginContext, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public enum System.Management.Automation.RemotingBehavior : Enum {
    public int value__;
    public static RemotingBehavior None;
    public static RemotingBehavior PowerShell;
    public static RemotingBehavior Custom;
}
public enum System.Management.Automation.RemotingCapability : Enum {
    public int value__;
    public static RemotingCapability None;
    public static RemotingCapability PowerShell;
    public static RemotingCapability SupportedByCommand;
    public static RemotingCapability OwnedByCommand;
}
internal static class System.Management.Automation.RemotingConstants : object {
    internal static Version HostVersion;
    internal static Version ProtocolVersionWin7RC;
    internal static Version ProtocolVersionWin7RTM;
    internal static Version ProtocolVersionWin8RTM;
    internal static Version ProtocolVersionWin10RTM;
    internal static Version ProtocolVersionCurrent;
    internal static Version ProtocolVersion;
    internal static string ComputerNameNoteProperty;
    internal static string RunspaceIdNoteProperty;
    internal static string ShowComputerNameNoteProperty;
    internal static string SourceJobInstanceId;
    internal static string EventObject;
    internal static string PSSessionConfigurationNoun;
    internal static string PSRemotingNoun;
    internal static string PSPluginDLLName;
    internal static string DefaultShellName;
    internal static string MaxIdleTimeoutMS;
    private static RemotingConstants();
}
internal enum System.Management.Automation.RemotingDataType : Enum {
    public UInt32 value__;
    public static RemotingDataType InvalidDataType;
    public static RemotingDataType ExceptionAsErrorRecord;
    public static RemotingDataType SessionCapability;
    public static RemotingDataType CloseSession;
    public static RemotingDataType CreateRunspacePool;
    public static RemotingDataType PublicKey;
    public static RemotingDataType EncryptedSessionKey;
    public static RemotingDataType PublicKeyRequest;
    public static RemotingDataType ConnectRunspacePool;
    public static RemotingDataType SetMaxRunspaces;
    public static RemotingDataType SetMinRunspaces;
    public static RemotingDataType RunspacePoolOperationResponse;
    public static RemotingDataType RunspacePoolStateInfo;
    public static RemotingDataType CreatePowerShell;
    public static RemotingDataType AvailableRunspaces;
    public static RemotingDataType PSEventArgs;
    public static RemotingDataType ApplicationPrivateData;
    public static RemotingDataType GetCommandMetadata;
    public static RemotingDataType RunspacePoolInitData;
    public static RemotingDataType ResetRunspaceState;
    public static RemotingDataType RemoteHostCallUsingRunspaceHost;
    public static RemotingDataType RemoteRunspaceHostResponseData;
    public static RemotingDataType PowerShellInput;
    public static RemotingDataType PowerShellInputEnd;
    public static RemotingDataType PowerShellOutput;
    public static RemotingDataType PowerShellErrorRecord;
    public static RemotingDataType PowerShellStateInfo;
    public static RemotingDataType PowerShellDebug;
    public static RemotingDataType PowerShellVerbose;
    public static RemotingDataType PowerShellWarning;
    public static RemotingDataType PowerShellProgress;
    public static RemotingDataType PowerShellInformationStream;
    public static RemotingDataType StopPowerShell;
    public static RemotingDataType RemoteHostCallUsingPowerShellHost;
    public static RemotingDataType RemotePowerShellHostResponseData;
}
internal static class System.Management.Automation.RemotingDecoder : object {
    private static T ConvertPropertyValueTo(string propertyName, object propertyValue);
    private static PSPropertyInfo GetProperty(PSObject psObject, string propertyName);
    internal static T GetPropertyValue(PSObject psObject, string propertyName);
    [IteratorStateMachineAttribute("System.Management.Automation.RemotingDecoder/<EnumerateListProperty>d__3`1")]
internal static IEnumerable`1<T> EnumerateListProperty(PSObject psObject, string propertyName);
    [IteratorStateMachineAttribute("System.Management.Automation.RemotingDecoder/<EnumerateHashtableProperty>d__4`2")]
internal static IEnumerable`1<KeyValuePair`2<TKey, TValue>> EnumerateHashtableProperty(PSObject psObject, string propertyName);
    internal static RunspacePoolStateInfo GetRunspacePoolStateInfo(PSObject dataAsPSObject);
    internal static PSPrimitiveDictionary GetApplicationPrivateData(PSObject dataAsPSObject);
    internal static string GetPublicKey(PSObject dataAsPSObject);
    internal static string GetEncryptedSessionKey(PSObject dataAsPSObject);
    internal static PSEventArgs GetPSEventArgs(PSObject dataAsPSObject);
    internal static int GetMinRunspaces(PSObject dataAsPSObject);
    internal static int GetMaxRunspaces(PSObject dataAsPSObject);
    internal static PSPrimitiveDictionary GetApplicationArguments(PSObject dataAsPSObject);
    internal static RunspacePoolInitInfo GetRunspacePoolInitInfo(PSObject dataAsPSObject);
    internal static PSThreadOptions GetThreadOptions(PSObject dataAsPSObject);
    internal static HostInfo GetHostInfo(PSObject dataAsPSObject);
    private static Exception GetExceptionFromStateInfoObject(PSObject stateInfo);
    internal static Exception GetExceptionFromSerializedErrorRecord(object serializedErrorRecord);
    internal static object GetPowerShellOutput(object data);
    internal static PSInvocationStateInfo GetPowerShellStateInfo(object data);
    internal static ErrorRecord GetPowerShellError(object data);
    internal static WarningRecord GetPowerShellWarning(object data);
    internal static VerboseRecord GetPowerShellVerbose(object data);
    internal static DebugRecord GetPowerShellDebug(object data);
    internal static ProgressRecord GetPowerShellProgress(object data);
    internal static InformationRecord GetPowerShellInformation(object data);
    internal static PowerShell GetPowerShell(object data);
    internal static PowerShell GetCommandDiscoveryPipeline(object data);
    internal static bool GetNoInput(object data);
    internal static bool GetAddToHistory(object data);
    internal static bool GetIsNested(object data);
    internal static ApartmentState GetApartmentState(object data);
    internal static RemoteStreamOptions GetRemoteStreamOptions(object data);
    internal static RemoteSessionCapability GetSessionCapability(object data);
    internal static bool ServerSupportsBatchInvocation(Runspace runspace);
}
[FlagsAttribute]
internal enum System.Management.Automation.RemotingDestination : Enum {
    public UInt32 value__;
    public static RemotingDestination InvalidDestination;
    public static RemotingDestination Client;
    public static RemotingDestination Server;
    public static RemotingDestination Listener;
}
internal static class System.Management.Automation.RemotingEncoder : object {
    internal static void AddNoteProperty(PSObject pso, string propertyName, ValueGetterDelegate`1<T> valueGetter);
    internal static PSObject CreateEmptyPSObject();
    private static PSNoteProperty CreateHostInfoProperty(HostInfo hostInfo);
    internal static RemoteDataObject GenerateCreateRunspacePool(Guid clientRunspacePoolId, int minRunspaces, int maxRunspaces, RemoteRunspacePoolInternal runspacePool, PSHost host, PSPrimitiveDictionary applicationArguments);
    internal static RemoteDataObject GenerateConnectRunspacePool(Guid clientRunspacePoolId, int minRunspaces, int maxRunspaces);
    internal static RemoteDataObject GenerateRunspacePoolInitData(Guid runspacePoolId, int minRunspaces, int maxRunspaces);
    internal static RemoteDataObject GenerateSetMaxRunspaces(Guid clientRunspacePoolId, int maxRunspaces, long callId);
    internal static RemoteDataObject GenerateSetMinRunspaces(Guid clientRunspacePoolId, int minRunspaces, long callId);
    internal static RemoteDataObject GenerateRunspacePoolOperationResponse(Guid clientRunspacePoolId, object response, long callId);
    internal static RemoteDataObject GenerateGetAvailableRunspaces(Guid clientRunspacePoolId, long callId);
    internal static RemoteDataObject GenerateMyPublicKey(Guid runspacePoolId, string publicKey, RemotingDestination destination);
    internal static RemoteDataObject GeneratePublicKeyRequest(Guid runspacePoolId);
    internal static RemoteDataObject GenerateEncryptedSessionKeyResponse(Guid runspacePoolId, string encryptedSessionKey);
    internal static RemoteDataObject GenerateGetCommandMetadata(ClientRemotePowerShell shell);
    internal static RemoteDataObject GenerateCreatePowerShell(ClientRemotePowerShell shell);
    internal static RemoteDataObject GenerateApplicationPrivateData(Guid clientRunspacePoolId, PSPrimitiveDictionary applicationPrivateData);
    internal static RemoteDataObject GenerateRunspacePoolStateInfo(Guid clientRunspacePoolId, RunspacePoolStateInfo stateInfo);
    internal static RemoteDataObject GeneratePSEventArgs(Guid clientRunspacePoolId, PSEventArgs e);
    internal static RemoteDataObject GenerateResetRunspaceState(Guid clientRunspacePoolId, long callId);
    internal static Version GetPSRemotingProtocolVersion(RunspacePool rsPool);
    internal static RemoteDataObject GeneratePowerShellInput(object data, Guid clientRemoteRunspacePoolId, Guid clientPowerShellId);
    internal static RemoteDataObject GeneratePowerShellInputEnd(Guid clientRemoteRunspacePoolId, Guid clientPowerShellId);
    internal static RemoteDataObject GeneratePowerShellOutput(PSObject data, Guid clientPowerShellId, Guid clientRunspacePoolId);
    internal static RemoteDataObject GeneratePowerShellInformational(object data, Guid clientRunspacePoolId, Guid clientPowerShellId, RemotingDataType dataType);
    internal static RemoteDataObject GeneratePowerShellInformational(ProgressRecord progressRecord, Guid clientRunspacePoolId, Guid clientPowerShellId);
    internal static RemoteDataObject GeneratePowerShellInformational(InformationRecord informationRecord, Guid clientRunspacePoolId, Guid clientPowerShellId);
    internal static RemoteDataObject GeneratePowerShellError(object errorRecord, Guid clientRunspacePoolId, Guid clientPowerShellId);
    internal static RemoteDataObject GeneratePowerShellStateInfo(PSInvocationStateInfo stateInfo, Guid clientPowerShellId, Guid clientRunspacePoolId);
    internal static ErrorRecord GetErrorRecordFromException(Exception exception);
    private static PSNoteProperty GetExceptionProperty(Exception exception, string errorId, ErrorCategory category);
    internal static RemoteDataObject GenerateClientSessionCapability(RemoteSessionCapability capability, Guid runspacePoolId);
    internal static RemoteDataObject GenerateServerSessionCapability(RemoteSessionCapability capability, Guid runspacePoolId);
    private static PSObject GenerateSessionCapability(RemoteSessionCapability capability);
}
internal class System.Management.Automation.RemotingJobDebugger : Debugger {
    private Debugger _wrappedDebugger;
    private Runspace _runspace;
    private string _jobName;
    public bool InBreakpoint { get; }
    public RemotingJobDebugger(Debugger debugger, Runspace runspace, string jobName);
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual void StopProcessCommand();
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual void SetParent(Debugger parent, IEnumerable`1<Breakpoint> breakPoints, Nullable`1<DebuggerResumeAction> startAction, PSHost host, PathInfo path);
    public virtual void SetDebugMode(DebugModes mode);
    public virtual IEnumerable`1<CallStackFrame> GetCallStack();
    public virtual void SetDebuggerStepMode(bool enabled);
    internal void CheckStateAndRaiseStopEvent();
    public virtual bool get_InBreakpoint();
    private void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    private Pipeline DrainAndBlockRemoteOutput();
    private static void RestoreRemoteOutput(Pipeline runningCmd);
    private void HandleBreakpointUpdated(object sender, BreakpointUpdatedEventArgs e);
    private DebuggerCommandResults HandlePromptCommand(PSDataCollection`1<PSObject> output);
}
internal enum System.Management.Automation.RemotingTargetInterface : Enum {
    public int value__;
    public static RemotingTargetInterface InvalidTargetInterface;
    public static RemotingTargetInterface Session;
    public static RemotingTargetInterface RunspacePool;
    public static RemotingTargetInterface PowerShell;
}
public abstract class System.Management.Automation.Repository`1 : object {
    private Dictionary`2<Guid, T> _repository;
    private object _syncObject;
    private string _identifier;
    internal List`1<T> Items { get; }
    internal Dictionary`2<Guid, T> Dictionary { get; }
    protected Repository`1(string identifier);
    public void Add(T item);
    public void Remove(T item);
    public List`1<T> GetItems();
    protected abstract virtual Guid GetKey(T item);
    internal List`1<T> get_Items();
    public T GetItem(Guid instanceId);
    internal Dictionary`2<Guid, T> get_Dictionary();
}
internal class System.Management.Automation.RequiredModuleInfo : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <CommandsToPostFilter>k__BackingField;
    internal string Name { get; internal set; }
    internal List`1<string> CommandsToPostFilter { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_CommandsToPostFilter();
    [CompilerGeneratedAttribute]
internal void set_CommandsToPostFilter(List`1<string> value);
}
internal static class System.Management.Automation.ReservedNameMembers : object {
    private static object GenerateMemberSet(string name, object obj);
    internal static object GeneratePSBaseMemberSet(object obj);
    internal static object GeneratePSAdaptedMemberSet(object obj);
    internal static object GeneratePSObjectMemberSet(object obj);
    internal static object GeneratePSExtendedMemberSet(object obj);
    public static Collection`1<string> PSTypeNames(PSObject o);
    internal static void GeneratePSTypeNames(object obj);
}
public enum System.Management.Automation.ResolutionPurpose : Enum {
    public int value__;
    public static ResolutionPurpose Encryption;
    public static ResolutionPurpose Decryption;
}
internal static class System.Management.Automation.ResourceManagerCache : object {
    private static Dictionary`2<string, Dictionary`2<string, ResourceManager>> s_resourceManagerCache;
    private static object s_syncRoot;
    private static bool s_DFT_monitorFailingResourceLookup;
    internal static bool DFT_DoMonitorFailingResourceLookup { get; internal set; }
    private static ResourceManagerCache();
    internal static ResourceManager GetResourceManager(Assembly assembly, string baseName);
    internal static bool get_DFT_DoMonitorFailingResourceLookup();
    internal static void set_DFT_DoMonitorFailingResourceLookup(bool value);
    internal static string GetResourceString(Assembly assembly, string baseName, string resourceId);
    private static ResourceManager InitRMWithAssembly(string baseName, Assembly assemblyToUse);
}
public enum System.Management.Automation.ReturnContainers : Enum {
    public int value__;
    public static ReturnContainers ReturnMatchingContainers;
    public static ReturnContainers ReturnAllContainers;
}
internal class System.Management.Automation.ReturnException : FlowControlException {
    [CompilerGeneratedAttribute]
private object <Argument>k__BackingField;
    internal object Argument { get; internal set; }
    internal ReturnException(object argument);
    [CompilerGeneratedAttribute]
internal object get_Argument();
    [CompilerGeneratedAttribute]
internal void set_Argument(object value);
}
public enum System.Management.Automation.RollbackSeverity : Enum {
    public int value__;
    public static RollbackSeverity Error;
    public static RollbackSeverity TerminatingError;
    public static RollbackSeverity Never;
}
public enum System.Management.Automation.RunspaceMode : Enum {
    public int value__;
    public static RunspaceMode CurrentRunspace;
    public static RunspaceMode NewRunspace;
}
public class System.Management.Automation.RunspacePoolStateInfo : object {
    [CompilerGeneratedAttribute]
private RunspacePoolState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public RunspacePoolState State { get; }
    public Exception Reason { get; }
    public RunspacePoolStateInfo(RunspacePoolState state, Exception reason);
    [CompilerGeneratedAttribute]
public RunspacePoolState get_State();
    [CompilerGeneratedAttribute]
public Exception get_Reason();
}
public class System.Management.Automation.RunspaceRepository : Repository`1<PSSession> {
    public List`1<PSSession> Runspaces { get; }
    public List`1<PSSession> get_Runspaces();
    protected virtual Guid GetKey(PSSession item);
    internal void AddOrReplace(PSSession item);
}
[DebuggerDisplayAttribute("AliasProperty: {Name,nq} = {ReferencedMemberName,nq}")]
public class System.Management.Automation.Runspaces.AliasPropertyData : TypeMemberData {
    [CompilerGeneratedAttribute]
private string <ReferencedMemberName>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <MemberType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    public string ReferencedMemberName { get; public set; }
    public Type MemberType { get; public set; }
    public bool IsHidden { get; public set; }
    public AliasPropertyData(string name, string referencedMemberName);
    public AliasPropertyData(string name, string referencedMemberName, Type type);
    [CompilerGeneratedAttribute]
public string get_ReferencedMemberName();
    [CompilerGeneratedAttribute]
public void set_ReferencedMemberName(string value);
    [CompilerGeneratedAttribute]
public Type get_MemberType();
    [CompilerGeneratedAttribute]
public void set_MemberType(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
internal class System.Management.Automation.Runspaces.AsyncResult : object {
    private ManualResetEvent _completedWaitHandle;
    private AutoResetEvent _invokeOnThreadEvent;
    private WaitCallback _invokeCallback;
    private object _invokeCallbackState;
    [CompilerGeneratedAttribute]
private bool <IsCompleted>k__BackingField;
    [CompilerGeneratedAttribute]
private object <AsyncState>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <OwnerId>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private AsyncCallback <Callback>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncObject>k__BackingField;
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; private set; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    internal Guid OwnerId { get; }
    internal Exception Exception { get; private set; }
    internal AsyncCallback Callback { get; }
    internal object SyncObject { get; }
    internal AsyncResult(Guid ownerId, AsyncCallback callback, object state);
    public sealed virtual bool get_CompletedSynchronously();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsCompleted();
    [CompilerGeneratedAttribute]
private void set_IsCompleted(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    [CompilerGeneratedAttribute]
internal Guid get_OwnerId();
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
    [CompilerGeneratedAttribute]
private void set_Exception(Exception value);
    [CompilerGeneratedAttribute]
internal AsyncCallback get_Callback();
    [CompilerGeneratedAttribute]
internal object get_SyncObject();
    internal void SetAsCompleted(Exception exception);
    internal void Release();
    internal void SignalWaitHandle();
    internal void EndInvoke();
    internal bool InvokeCallbackOnThread(WaitCallback callback, object state);
}
public enum System.Management.Automation.Runspaces.AuthenticationMechanism : Enum {
    public int value__;
    public static AuthenticationMechanism Default;
    public static AuthenticationMechanism Basic;
    public static AuthenticationMechanism Negotiate;
    public static AuthenticationMechanism NegotiateWithImplicitCredential;
    public static AuthenticationMechanism Credssp;
    public static AuthenticationMechanism Digest;
    public static AuthenticationMechanism Kerberos;
}
internal class System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml/<ViewsOf_System_Security_Cryptography_X509Certificates_X509Certificate2>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Security_Cryptography_X509Certificates_X509Certificate2();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml/<ViewsOf_CertificateProviderTypes>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_CertificateProviderTypes();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Signature>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Signature(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Certificate_Format_Ps1Xml/<ViewsOf_System_Security_Cryptography_X509Certificates_X509CertificateEx>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Security_Cryptography_X509Certificates_X509CertificateEx();
}
internal class System.Management.Automation.Runspaces.CloseOrDisconnectRunspaceOperationHelper : IThrottleOperation {
    private RemoteRunspace _remoteRunspace;
    [CompilerGeneratedAttribute]
private EventHandler`1<OperationStateEventArgs> OperationComplete;
    internal CloseOrDisconnectRunspaceOperationHelper(RemoteRunspace remoteRunspace);
    private void HandleRunspaceStateChanged(object sender, RunspaceStateEventArgs eventArgs);
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void RaiseOperationCompleteEvent();
}
[DebuggerDisplayAttribute("CodeMethod: {Name,nq}")]
public class System.Management.Automation.Runspaces.CodeMethodData : TypeMemberData {
    [CompilerGeneratedAttribute]
private MethodInfo <CodeReference>k__BackingField;
    public MethodInfo CodeReference { get; public set; }
    public CodeMethodData(string name, MethodInfo methodToCall);
    [CompilerGeneratedAttribute]
public MethodInfo get_CodeReference();
    [CompilerGeneratedAttribute]
public void set_CodeReference(MethodInfo value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public class System.Management.Automation.Runspaces.CodePropertyData : TypeMemberData {
    [CompilerGeneratedAttribute]
private MethodInfo <GetCodeReference>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodInfo <SetCodeReference>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    public MethodInfo GetCodeReference { get; public set; }
    public MethodInfo SetCodeReference { get; public set; }
    public bool IsHidden { get; public set; }
    public CodePropertyData(string name, MethodInfo getMethod);
    public CodePropertyData(string name, MethodInfo getMethod, MethodInfo setMethod);
    [CompilerGeneratedAttribute]
public MethodInfo get_GetCodeReference();
    [CompilerGeneratedAttribute]
public void set_GetCodeReference(MethodInfo value);
    [CompilerGeneratedAttribute]
public MethodInfo get_SetCodeReference();
    [CompilerGeneratedAttribute]
public void set_SetCodeReference(MethodInfo value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public class System.Management.Automation.Runspaces.Command : object {
    [CompilerGeneratedAttribute]
private CommandParameterCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandInfo <CommandInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsScript>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandOrigin <CommandOrigin>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DollarUnderbar>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsEndOfStatement>k__BackingField;
    private PipelineResultTypes _mergeUnclaimedPreviousCommandResults;
    [CompilerGeneratedAttribute]
private PipelineResultTypes <MergeMyResult>k__BackingField;
    [CompilerGeneratedAttribute]
private PipelineResultTypes <MergeToResult>k__BackingField;
    internal static int MaxMergeType;
    [CompilerGeneratedAttribute]
private PipelineResultTypes[] <MergeInstructions>k__BackingField;
    private Nullable`1<bool> _useLocalScope;
    public CommandParameterCollection Parameters { get; }
    public string CommandText { get; }
    internal CommandInfo CommandInfo { get; }
    public bool IsScript { get; }
    public bool UseLocalScope { get; }
    public CommandOrigin CommandOrigin { get; public set; }
    internal Nullable`1<bool> UseLocalScopeNullable { get; }
    internal object DollarUnderbar { get; internal set; }
    public bool IsEndOfStatement { get; internal set; }
    public PipelineResultTypes MergeUnclaimedPreviousCommandResults { get; public set; }
    internal PipelineResultTypes MergeMyResult { get; private set; }
    internal PipelineResultTypes MergeToResult { get; private set; }
    internal PipelineResultTypes[] MergeInstructions { get; internal set; }
    public Command(string command);
    public Command(string command, bool isScript);
    public Command(string command, bool isScript, bool useLocalScope);
    internal Command(string command, bool isScript, Nullable`1<bool> useLocalScope);
    internal Command(string command, bool isScript, Nullable`1<bool> useLocalScope, bool mergeUnclaimedPreviousErrorResults);
    internal Command(CommandInfo commandInfo);
    internal Command(CommandInfo commandInfo, bool isScript);
    internal Command(Command command);
    [CompilerGeneratedAttribute]
public CommandParameterCollection get_Parameters();
    [CompilerGeneratedAttribute]
public string get_CommandText();
    [CompilerGeneratedAttribute]
internal CommandInfo get_CommandInfo();
    [CompilerGeneratedAttribute]
public bool get_IsScript();
    public bool get_UseLocalScope();
    [CompilerGeneratedAttribute]
public CommandOrigin get_CommandOrigin();
    [CompilerGeneratedAttribute]
public void set_CommandOrigin(CommandOrigin value);
    internal Nullable`1<bool> get_UseLocalScopeNullable();
    [CompilerGeneratedAttribute]
internal object get_DollarUnderbar();
    [CompilerGeneratedAttribute]
internal void set_DollarUnderbar(object value);
    [CompilerGeneratedAttribute]
public bool get_IsEndOfStatement();
    [CompilerGeneratedAttribute]
internal void set_IsEndOfStatement(bool value);
    internal Command Clone();
    public virtual string ToString();
    public PipelineResultTypes get_MergeUnclaimedPreviousCommandResults();
    public void set_MergeUnclaimedPreviousCommandResults(PipelineResultTypes value);
    [CompilerGeneratedAttribute]
internal PipelineResultTypes get_MergeMyResult();
    [CompilerGeneratedAttribute]
private void set_MergeMyResult(PipelineResultTypes value);
    [CompilerGeneratedAttribute]
internal PipelineResultTypes get_MergeToResult();
    [CompilerGeneratedAttribute]
private void set_MergeToResult(PipelineResultTypes value);
    [CompilerGeneratedAttribute]
internal PipelineResultTypes[] get_MergeInstructions();
    [CompilerGeneratedAttribute]
internal void set_MergeInstructions(PipelineResultTypes[] value);
    public void MergeMyResults(PipelineResultTypes myResult, PipelineResultTypes toResult);
    private void SetMergeSettingsOnCommandProcessor(CommandProcessorBase commandProcessor);
    private static Pipe GetRedirectionPipe(PipelineResultTypes toType, MshCommandRuntime mcr);
    internal CommandProcessorBase CreateCommandProcessor(ExecutionContext executionContext, bool addToHistory, CommandOrigin origin);
    internal static Command FromPSObjectForRemoting(PSObject commandAsPSObject);
    internal PSObject ToPSObjectForRemoting(Version psRPVersion);
}
public class System.Management.Automation.Runspaces.CommandCollection : Collection`1<Command> {
    public void Add(string command);
    internal void Add(string command, bool mergeUnclaimedPreviousCommandError);
    public void AddScript(string scriptContents);
    public void AddScript(string scriptContents, bool useLocalScope);
    internal string GetCommandStringForHistory();
}
public class System.Management.Automation.Runspaces.CommandParameter : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FromHashtableSplatting>k__BackingField;
    public string Name { get; }
    public object Value { get; }
    private bool FromHashtableSplatting { get; private set; }
    public CommandParameter(string name);
    public CommandParameter(string name, object value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private bool get_FromHashtableSplatting();
    [CompilerGeneratedAttribute]
private void set_FromHashtableSplatting(bool value);
    internal static CommandParameter FromCommandParameterInternal(CommandParameterInternal internalParameter);
    internal static CommandParameterInternal ToCommandParameterInternal(CommandParameter publicParameter, bool forNativeCommand);
    internal static CommandParameter FromPSObjectForRemoting(PSObject parameterAsPSObject);
    internal PSObject ToPSObjectForRemoting();
}
public class System.Management.Automation.Runspaces.CommandParameterCollection : Collection`1<CommandParameter> {
    public void Add(string name);
    public void Add(string name, object value);
}
internal class System.Management.Automation.Runspaces.ConsolidatedString : Collection`1<string> {
    [CompilerGeneratedAttribute]
private string <Key>k__BackingField;
    internal static ConsolidatedString Empty;
    internal static IEqualityComparer`1<ConsolidatedString> EqualityComparer;
    internal string Key { get; private set; }
    internal bool IsReadOnly { get; }
    public ConsolidatedString(ConsolidatedString other);
    internal ConsolidatedString(IEnumerable`1<string> strings, bool interned);
    public ConsolidatedString(IEnumerable`1<string> strings);
    private static ConsolidatedString();
    protected virtual void SetItem(int index, string item);
    protected virtual void ClearItems();
    protected virtual void InsertItem(int index, string item);
    protected virtual void RemoveItem(int index);
    [CompilerGeneratedAttribute]
internal string get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(string value);
    internal bool get_IsReadOnly();
    private void UpdateKey();
}
public abstract class System.Management.Automation.Runspaces.ConstrainedSessionStateEntry : InitialSessionStateEntry {
    [CompilerGeneratedAttribute]
private SessionStateEntryVisibility <Visibility>k__BackingField;
    public SessionStateEntryVisibility Visibility { get; public set; }
    protected ConstrainedSessionStateEntry(string name, SessionStateEntryVisibility visibility);
    [CompilerGeneratedAttribute]
public SessionStateEntryVisibility get_Visibility();
    [CompilerGeneratedAttribute]
public void set_Visibility(SessionStateEntryVisibility value);
}
public class System.Management.Automation.Runspaces.ContainerConnectionInfo : RunspaceConnectionInfo {
    private AuthenticationMechanism _authMechanism;
    private PSCredential _credential;
    private static int _defaultOpenTimeout;
    [CompilerGeneratedAttribute]
private ContainerProcess <ContainerProc>k__BackingField;
    internal ContainerProcess ContainerProc { get; internal set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public PSCredential Credential { get; public set; }
    public string ComputerName { get; public set; }
    internal ContainerConnectionInfo(ContainerProcess containerProc);
    [CompilerGeneratedAttribute]
internal ContainerProcess get_ContainerProc();
    [CompilerGeneratedAttribute]
internal void set_ContainerProc(ContainerProcess value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual string get_ComputerName();
    public virtual void set_ComputerName(string value);
    public virtual RunspaceConnectionInfo Clone();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
    public static ContainerConnectionInfo CreateContainerConnectionInfo(string containerId, bool runAsAdmin, string configurationName);
    public void CreateContainerProcess();
    public bool TerminateContainerProcess();
}
internal class System.Management.Automation.Runspaces.ContainerProcess : object {
    private static UInt32 NoError;
    private static UInt32 InvalidContainerId;
    private static UInt32 ContainersFeatureNotEnabled;
    private static UInt32 OtherError;
    private static UInt32 FileNotFoundHResult;
    private static String[] Executables;
    [CompilerGeneratedAttribute]
private Guid <RuntimeId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerObRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ContainerId>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunAsAdmin>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessTerminated>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Executable>k__BackingField;
    public Guid RuntimeId { get; public set; }
    public string ContainerObRoot { get; public set; }
    public string ContainerId { get; public set; }
    internal int ProcessId { get; internal set; }
    internal bool RunAsAdmin { get; internal set; }
    internal string ConfigurationName { get; internal set; }
    internal bool ProcessTerminated { get; internal set; }
    internal UInt32 ErrorCode { get; internal set; }
    internal string ErrorMessage { get; internal set; }
    internal string Executable { get; internal set; }
    public ContainerProcess(string containerId, string containerObRoot, int processId, bool runAsAdmin, string configurationName);
    private static ContainerProcess();
    [CompilerGeneratedAttribute]
public Guid get_RuntimeId();
    [CompilerGeneratedAttribute]
public void set_RuntimeId(Guid value);
    [CompilerGeneratedAttribute]
public string get_ContainerObRoot();
    [CompilerGeneratedAttribute]
public void set_ContainerObRoot(string value);
    [CompilerGeneratedAttribute]
public string get_ContainerId();
    [CompilerGeneratedAttribute]
public void set_ContainerId(string value);
    [CompilerGeneratedAttribute]
internal int get_ProcessId();
    [CompilerGeneratedAttribute]
internal void set_ProcessId(int value);
    [CompilerGeneratedAttribute]
internal bool get_RunAsAdmin();
    [CompilerGeneratedAttribute]
internal void set_RunAsAdmin(bool value);
    [CompilerGeneratedAttribute]
internal string get_ConfigurationName();
    [CompilerGeneratedAttribute]
internal void set_ConfigurationName(string value);
    [CompilerGeneratedAttribute]
internal bool get_ProcessTerminated();
    [CompilerGeneratedAttribute]
internal void set_ProcessTerminated(bool value);
    [CompilerGeneratedAttribute]
internal UInt32 get_ErrorCode();
    [CompilerGeneratedAttribute]
internal void set_ErrorCode(UInt32 value);
    [CompilerGeneratedAttribute]
internal string get_ErrorMessage();
    [CompilerGeneratedAttribute]
internal void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
internal string get_Executable();
    [CompilerGeneratedAttribute]
internal void set_Executable(string value);
    internal static UInt32 HcsOpenComputeSystem(string id, IntPtr& computeSystem, String& result);
    internal static UInt32 HcsGetComputeSystemProperties(IntPtr computeSystem, string propertyQuery, String& properties, String& result);
    internal static UInt32 HcsCreateProcess(IntPtr computeSystem, string processParameters, HCS_PROCESS_INFORMATION& processInformation, IntPtr& process, String& result);
    internal static UInt32 HcsOpenProcess(IntPtr computeSystem, int processId, IntPtr& process, String& result);
    internal static UInt32 HcsTerminateProcess(IntPtr process, String& result);
    public void CreateContainerProcess();
    public bool TerminateContainerProcess();
    public void GetContainerProperties();
    private static void GetHostComputeInteropTypes(Type& computeSystemPropertiesType, Type& hostComputeInteropType);
    private void CreateContainerProcessInternal();
    private string GetContainerProcessCommand(string executable);
    private void TerminateContainerProcessInternal();
    private void GetContainerPropertiesInternal();
    private static void RunOnMTAThread(ThreadStart threadProc);
    private static string GetErrorMessageFromException(Exception e);
}
internal class System.Management.Automation.Runspaces.Diagnostics_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Diagnostics_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Diagnostics_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_GetCounter_PerformanceCounterSampleSet>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_GetCounter_PerformanceCounterSampleSet();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Diagnostics_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_GetCounter_CounterFileInfo>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_GetCounter_CounterFileInfo();
}
internal class System.Management.Automation.Runspaces.DiscardingPipelineWriter : PipelineWriter {
    private ManualResetEvent _waitHandle;
    private bool _isOpen;
    private int _count;
    public WaitHandle WaitHandle { get; }
    public bool IsOpen { get; }
    public int Count { get; }
    public int MaxCapacity { get; }
    public virtual WaitHandle get_WaitHandle();
    public virtual bool get_IsOpen();
    public virtual int get_Count();
    public virtual int get_MaxCapacity();
    public virtual void Close();
    public virtual void Flush();
    public virtual int Write(object obj);
    public virtual int Write(object obj, bool enumerateCollection);
}
internal class System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_CodeDom_Compiler_CompilerError>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_CodeDom_Compiler_CompilerError();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Reflection_Assembly>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Reflection_Assembly();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Reflection_AssemblyName>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Reflection_AssemblyName();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Globalization_CultureInfo>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Globalization_CultureInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_FileVersionInfo>d__5")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_FileVersionInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_EventLogEntry>d__6")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_EventLogEntry();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_EventLog>d__7")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_EventLog();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Version>d__8")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Version();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Version_With_Label>d__9")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Version_With_Label();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Semantic_Version_With_Label>d__10")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Semantic_Version_With_Label();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Drawing_Printing_PrintDocument>d__11")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Drawing_Printing_PrintDocument();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Collections_DictionaryEntry>d__12")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Collections_DictionaryEntry();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_ProcessModule>d__13")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_ProcessModule();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_Process>d__14")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_Process();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Diagnostics_Process_IncludeUserName>d__15")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_Process_IncludeUserName();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_DirectoryServices_DirectoryEntry>d__16")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_DirectoryServices_DirectoryEntry();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSSnapInInfo>d__17")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSSnapInInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_ServiceProcess_ServiceController>d__18")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_ServiceProcess_ServiceController();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_TimeSpan>d__19")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_TimeSpan();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_AppDomain>d__20")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_AppDomain();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_DateTime>d__21")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_DateTime();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Security_AccessControl_ObjectSecurity>d__22")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Security_AccessControl_ObjectSecurity();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_ManagementClass>d__23")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_ManagementClass();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimClass>d__24")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimClass();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Guid>d__25")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Guid();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_ManagementObject_root_cimv2_Win32_PingStatus>d__26")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_ManagementObject_root_cimv2_Win32_PingStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PingStatus>d__27")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PingStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_ManagementObject_root_default_SystemRestore>d__28")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_ManagementObject_root_default_SystemRestore();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_default_SystemRestore>d__29")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_default_SystemRestore();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_ManagementObject_root_cimv2_Win32_QuickFixEngineering>d__30")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_ManagementObject_root_cimv2_Win32_QuickFixEngineering();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_QuickFixEngineering>d__31")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_QuickFixEngineering();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Process>d__32")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Process();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_ComputerSystem>d__33")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_ComputerSystem();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_PROCESSOR>d__34")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_PROCESSOR();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DCOMApplication>d__35")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DCOMApplication();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DESKTOP>d__36")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DESKTOP();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DESKTOPMONITOR>d__37")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_WIN32_DESKTOPMONITOR();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DeviceMemoryAddress>d__38")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DeviceMemoryAddress();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskDrive>d__39")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskDrive();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskQuota>d__40")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskQuota();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Environment>d__41")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Environment();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Directory>d__42")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Directory();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Group>d__43")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Group();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_IDEController>d__44")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_IDEController();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_IRQResource>d__45")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_IRQResource();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_ScheduledJob>d__46")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_ScheduledJob();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LoadOrderGroup>d__47")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LoadOrderGroup();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LogicalDisk>d__48")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LogicalDisk();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LogonSession>d__49")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_LogonSession();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PhysicalMemoryArray>d__50")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PhysicalMemoryArray();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_OnBoardDevice>d__51")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_OnBoardDevice();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_OperatingSystem>d__52")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_OperatingSystem();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskPartition>d__53")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_DiskPartition();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PortConnector>d__54")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PortConnector();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_QuotaSetting>d__55")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_QuotaSetting();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_SCSIController>d__56")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_SCSIController();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Service>d__57")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Service();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_UserAccount>d__58")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_UserAccount();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkProtocol>d__59")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkProtocol();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkAdapter>d__60")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkAdapter();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkAdapterConfiguration>d__61")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NetworkAdapterConfiguration();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NTDomain>d__62")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_NTDomain();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Printer>d__63")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Printer();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PrintJob>d__64")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_PrintJob();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Product>d__65")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance_root_cimv2_Win32_Product();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Net_NetworkCredential>d__66")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Net_NetworkCredential();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSMethod>d__67")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSMethod();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_Microsoft_Management_Infrastructure_CimInstance___PartialCIMInstance>d__68")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Management_Infrastructure_CimInstance___PartialCIMInstance();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.DotNetTypes_Format_Ps1Xml/<ViewsOf_System_Threading_Tasks_Task>d__69")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Threading_Tasks_Task();
}
internal static class System.Management.Automation.Runspaces.EarlyStartup : object {
    internal static void Init();
}
internal class System.Management.Automation.Runspaces.Event_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Event_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Event_Format_Ps1Xml/<ViewsOf_System_Diagnostics_Eventing_Reader_EventLogRecord>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_Eventing_Reader_EventLogRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Event_Format_Ps1Xml/<ViewsOf_System_Diagnostics_Eventing_Reader_EventLogConfiguration>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_Eventing_Reader_EventLogConfiguration();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Event_Format_Ps1Xml/<ViewsOf_System_Diagnostics_Eventing_Reader_ProviderMetadata>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Diagnostics_Eventing_Reader_ProviderMetadata();
}
internal class System.Management.Automation.Runspaces.FileSystem_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.FileSystem_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.FileSystem_Format_Ps1Xml/<ViewsOf_FileSystemTypes>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_FileSystemTypes(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.FileSystem_Format_Ps1Xml/<ViewsOf_System_Security_AccessControl_FileSystemSecurity>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Security_AccessControl_FileSystemSecurity(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.FileSystem_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_AlternateStreamData>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_AlternateStreamData();
}
internal static class System.Management.Automation.Runspaces.FormatAndTypeDataHelper : object {
    private static string FileNotFound;
    private static string CannotFindRegistryKey;
    private static string CannotFindRegistryKeyPath;
    private static string EntryShouldBeMshXml;
    private static string DuplicateFile;
    internal static string ValidationException;
    private static string GetBaseFolder(Collection`1<string> independentErrors);
    private static string GetAndCheckFullFileName(string psSnapinName, HashSet`1<string> fullFileNameSet, string baseFolder, string baseFileName, Collection`1<string> independentErrors, Boolean& needToRemoveEntry, bool checkFileExists);
    internal static void ThrowExceptionOnError(string errorId, Collection`1<string> independentErrors, Collection`1<PSSnapInTypeAndFormatErrors> PSSnapinFilesCollection, Category category);
    internal static void ThrowExceptionOnError(string errorId, ConcurrentBag`1<string> errors, Category category);
}
public class System.Management.Automation.Runspaces.FormatTable : object {
    private TypeInfoDataBaseManager _formatDBMgr;
    internal TypeInfoDataBaseManager FormatDBManager { get; }
    public FormatTable(IEnumerable`1<string> formatFiles);
    internal FormatTable(IEnumerable`1<string> formatFiles, AuthorizationManager authorizationManager, PSHost host);
    public void AppendFormatData(IEnumerable`1<ExtendedTypeDefinition> formatData);
    public void PrependFormatData(IEnumerable`1<ExtendedTypeDefinition> formatData);
    internal TypeInfoDataBaseManager get_FormatDBManager();
    internal void Add(string formatFile, bool shouldPrepend);
    internal void Remove(string formatFile);
    public static FormatTable LoadDefaultFormatFiles();
}
public class System.Management.Automation.Runspaces.FormatTableLoadException : RuntimeException {
    private Collection`1<string> _errors;
    public Collection`1<string> Errors { get; }
    public FormatTableLoadException(string message);
    public FormatTableLoadException(string message, Exception innerException);
    internal FormatTableLoadException(ConcurrentBag`1<string> loadErrors);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected FormatTableLoadException(SerializationInfo info, StreamingContext context);
    protected void SetDefaultErrorRecord();
    public Collection`1<string> get_Errors();
}
internal class System.Management.Automation.Runspaces.GetRunspaceAsyncResult : AsyncResult {
    private bool _isActive;
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    internal Runspace Runspace { get; internal set; }
    internal bool IsActive { get; internal set; }
    internal GetRunspaceAsyncResult(Guid ownerId, AsyncCallback callback, object state);
    [CompilerGeneratedAttribute]
internal Runspace get_Runspace();
    [CompilerGeneratedAttribute]
internal void set_Runspace(Runspace value);
    internal bool get_IsActive();
    internal void set_IsActive(bool value);
    internal void DoComplete(object state);
}
internal class System.Management.Automation.Runspaces.Help_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_HelpInfoShort>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_HelpInfoShort();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_CmdletHelpInfo>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_CmdletHelpInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_DetailedView>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_DetailedView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_ExamplesView>d__5")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_ExamplesView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_FullView>d__6")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_FullView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_ProviderHelpInfo>d__7")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ProviderHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_FaqHelpInfo>d__8")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_FaqHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_GeneralHelpInfo>d__9")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_GeneralHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_GlossaryHelpInfo>d__10")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_GlossaryHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_ScriptHelpInfo>d__11")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ScriptHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_Examples>d__12")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_Examples(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_Example>d__13")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_Example(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_commandDetails>d__14")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_commandDetails(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_Parameters>d__15")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_Parameters(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_Parameter>d__16")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_Parameter(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_Syntax>d__17")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_Syntax(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlDefinitionTextItem_MamlOrderedListTextItem_MamlParaTextItem_MamlUnorderedListTextItem>d__18")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlDefinitionTextItem_MamlOrderedListTextItem_MamlParaTextItem_MamlUnorderedListTextItem(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_inputTypes>d__19")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_inputTypes(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_nonTerminatingErrors>d__20")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_nonTerminatingErrors(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_terminatingErrors>d__21")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_terminatingErrors(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_relatedLinks>d__22")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_relatedLinks(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_returnValues>d__23")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_returnValues(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_alertSet>d__24")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_alertSet(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Help_Format_Ps1Xml/<ViewsOf_MamlCommandHelpInfo_details>d__25")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_MamlCommandHelpInfo_details(CustomControl[] sharedControls);
}
internal class System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_ExtendedCmdletHelpInfo>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ExtendedCmdletHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_ExtendedCmdletHelpInfo_DetailedView>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ExtendedCmdletHelpInfo_DetailedView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_ExtendedCmdletHelpInfo_FullView>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ExtendedCmdletHelpInfo_FullView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_ExtendedCmdletHelpInfo_ExamplesView>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ExtendedCmdletHelpInfo_ExamplesView();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_ExtendedCmdletHelpInfo_parameter>d__5")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ExtendedCmdletHelpInfo_parameter(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_System_Management_Automation_VerboseRecord>d__6")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_VerboseRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_Deserialized_System_Management_Automation_VerboseRecord>d__7")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_System_Management_Automation_VerboseRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_System_Management_Automation_DebugRecord>d__8")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_DebugRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_Deserialized_System_Management_Automation_DebugRecord>d__9")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_System_Management_Automation_DebugRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_DscResourceHelpInfo_FullView>d__10")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_DscResourceHelpInfo_FullView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_DscResourceHelpInfo_DetailedView>d__11")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_DscResourceHelpInfo_DetailedView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_DscResourceHelpInfo>d__12")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_DscResourceHelpInfo(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_PSClassHelpInfo_FullView>d__13")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_PSClassHelpInfo_FullView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_PSClassHelpInfo_DetailedView>d__14")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_PSClassHelpInfo_DetailedView(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.HelpV3_Format_Ps1Xml/<ViewsOf_PSClassHelpInfo>d__15")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_PSClassHelpInfo(CustomControl[] sharedControls);
}
public class System.Management.Automation.Runspaces.InitialSessionState : object {
    [CompilerGeneratedAttribute]
private PSLanguageMode <LanguageMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TranscriptDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UserDriveEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserDriveUserName>k__BackingField;
    [CompilerGeneratedAttribute]
private long <UserDriveMaximumSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnforceInputParameterValidation>k__BackingField;
    private ExecutionPolicy _executionPolicy;
    private bool _wasExecutionPolicySet;
    [CompilerGeneratedAttribute]
private bool <UseFullLanguageModeInDebugger>k__BackingField;
    [CompilerGeneratedAttribute]
private ApartmentState <ApartmentState>k__BackingField;
    [CompilerGeneratedAttribute]
private PSThreadOptions <ThreadOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ThrowOnRunspaceOpenError>k__BackingField;
    internal bool RefreshTypeAndFormatSetting;
    [CompilerGeneratedAttribute]
private AuthorizationManager <AuthorizationManager>k__BackingField;
    internal PSHost Host;
    [CompilerGeneratedAttribute]
private Collection`1<ModuleSpecification> <ModuleSpecificationsToImport>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PSSnapInInfo> <ImportedSnapins>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <CoreModulesToImport>k__BackingField;
    private InitialSessionStateEntryCollection`1<SessionStateAssemblyEntry> _assemblies;
    private InitialSessionStateEntryCollection`1<SessionStateTypeEntry> _types;
    private InitialSessionStateEntryCollection`1<SessionStateFormatEntry> _formats;
    [CompilerGeneratedAttribute]
private bool <DisableFormatUpdates>k__BackingField;
    private InitialSessionStateEntryCollection`1<SessionStateProviderEntry> _providers;
    private InitialSessionStateEntryCollection`1<SessionStateCommandEntry> _commands;
    [CompilerGeneratedAttribute]
private SessionStateEntryVisibility <DefaultCommandVisibility>k__BackingField;
    private HashSet`1<string> _unresolvedCommandsToExpose;
    private Dictionary`2<string, Hashtable> _commandModifications;
    private List`1<Hashtable> _dynamicVariablesToDefine;
    private InitialSessionStateEntryCollection`1<SessionStateVariableEntry> _variables;
    private InitialSessionStateEntryCollection`1<SessionStateVariableEntry> _environmentVariables;
    private HashSet`1<string> _startupScripts;
    private object _syncObject;
    internal static string FormatEnumerationLimit;
    internal static int DefaultFormatEnumerationLimit;
    private static string s_tabExpansionFunctionText;
    internal static string WindowsHelpFunctionText;
    internal static string UnixHelpFunctionText;
    internal static ActionPreference DefaultDebugPreference;
    internal static ActionPreference DefaultErrorActionPreference;
    internal static ActionPreference DefaultProgressPreference;
    internal static ActionPreference DefaultVerbosePreference;
    internal static ActionPreference DefaultWarningPreference;
    internal static ActionPreference DefaultInformationPreference;
    internal static ErrorView DefaultErrorView;
    internal static bool DefaultWhatIfPreference;
    internal static ConfirmImpact DefaultConfirmPreference;
    internal static SessionStateVariableEntry[] BuiltInVariables;
    internal static string DefaultPromptFunctionText;
    internal static string DefaultSetDriveFunctionText;
    internal static ScriptBlock SetDriveScriptBlock;
    private static PSLanguageMode systemLanguageMode;
    internal static SessionStateFunctionEntry[] BuiltInFunctions;
    private static PSTraceSource s_PSSnapInTracer;
    internal static string CoreSnapin;
    internal static string CoreModule;
    internal static HashSet`1<string> EngineModules;
    internal static HashSet`1<string> NestedEngineModules;
    internal static Dictionary`2<string, string> EngineModuleNestedModuleMapping;
    internal static Dictionary`2<string, string> NestedModuleEngineModuleMapping;
    internal static HashSet`1<string> ConstantEngineModules;
    internal static HashSet`1<string> ConstantEngineNestedModules;
    public PSLanguageMode LanguageMode { get; public set; }
    public string TranscriptDirectory { get; public set; }
    internal bool UserDriveEnabled { get; internal set; }
    internal string UserDriveUserName { get; internal set; }
    internal long UserDriveMaximumSize { get; internal set; }
    internal bool EnforceInputParameterValidation { get; internal set; }
    public ExecutionPolicy ExecutionPolicy { get; public set; }
    public bool UseFullLanguageModeInDebugger { get; public set; }
    public ApartmentState ApartmentState { get; public set; }
    public PSThreadOptions ThreadOptions { get; public set; }
    public bool ThrowOnRunspaceOpenError { get; public set; }
    public AuthorizationManager AuthorizationManager { get; public set; }
    public ReadOnlyCollection`1<ModuleSpecification> Modules { get; }
    internal Collection`1<ModuleSpecification> ModuleSpecificationsToImport { get; }
    internal Dictionary`2<string, PSSnapInInfo> ImportedSnapins { get; }
    internal HashSet`1<string> CoreModulesToImport { get; }
    public InitialSessionStateEntryCollection`1<SessionStateAssemblyEntry> Assemblies { get; }
    public InitialSessionStateEntryCollection`1<SessionStateTypeEntry> Types { get; }
    public InitialSessionStateEntryCollection`1<SessionStateFormatEntry> Formats { get; }
    public bool DisableFormatUpdates { get; public set; }
    public InitialSessionStateEntryCollection`1<SessionStateProviderEntry> Providers { get; }
    public InitialSessionStateEntryCollection`1<SessionStateCommandEntry> Commands { get; }
    internal SessionStateEntryVisibility DefaultCommandVisibility { get; internal set; }
    internal HashSet`1<string> UnresolvedCommandsToExpose { get; }
    internal Dictionary`2<string, Hashtable> CommandModifications { get; }
    internal List`1<Hashtable> DynamicVariablesToDefine { get; }
    public InitialSessionStateEntryCollection`1<SessionStateVariableEntry> Variables { get; }
    public InitialSessionStateEntryCollection`1<SessionStateVariableEntry> EnvironmentVariables { get; }
    public HashSet`1<string> StartupScripts { get; }
    internal static SessionStateAliasEntry[] BuiltInAliases { get; }
    private static InitialSessionState();
    private static void RemoveDisallowedEntries(InitialSessionStateEntryCollection`1<T> list, List`1<string> allowedNames, Func`2<T, string> nameGetter);
    private static void MakeDisallowedEntriesPrivate(InitialSessionStateEntryCollection`1<T> list, List`1<string> allowedNames, Func`2<T, string> nameGetter);
    public static InitialSessionState CreateFromSessionConfigurationFile(string path);
    public static InitialSessionState CreateFromSessionConfigurationFile(string path, Func`2<string, bool> roleVerifier);
    public static InitialSessionState CreateFromSessionConfigurationFile(string path, Func`2<string, bool> roleVerifier, bool validateFile);
    public static InitialSessionState CreateRestricted(SessionCapabilities sessionCapabilities);
    private static InitialSessionState CreateRestrictedForRemoteServer();
    private static void IncludePowerShellCoreFormats(InitialSessionState iss);
    public static InitialSessionState Create();
    public static InitialSessionState CreateDefault();
    public static InitialSessionState CreateDefault2();
    internal static bool IsEngineModule(string moduleName);
    internal static bool IsNestedEngineModule(string moduleName);
    internal static bool IsConstantEngineModule(string moduleName);
    public InitialSessionState Clone();
    public static InitialSessionState Create(string snapInName);
    public static InitialSessionState Create(String[] snapInNameCollection, PSConsoleLoadException& warning);
    public static InitialSessionState CreateFrom(string snapInPath, PSConsoleLoadException& warnings);
    public static InitialSessionState CreateFrom(String[] snapInPathCollection, PSConsoleLoadException& warnings);
    [CompilerGeneratedAttribute]
public PSLanguageMode get_LanguageMode();
    [CompilerGeneratedAttribute]
public void set_LanguageMode(PSLanguageMode value);
    [CompilerGeneratedAttribute]
public string get_TranscriptDirectory();
    [CompilerGeneratedAttribute]
public void set_TranscriptDirectory(string value);
    [CompilerGeneratedAttribute]
internal bool get_UserDriveEnabled();
    [CompilerGeneratedAttribute]
internal void set_UserDriveEnabled(bool value);
    [CompilerGeneratedAttribute]
internal string get_UserDriveUserName();
    [CompilerGeneratedAttribute]
internal void set_UserDriveUserName(string value);
    [CompilerGeneratedAttribute]
internal long get_UserDriveMaximumSize();
    [CompilerGeneratedAttribute]
internal void set_UserDriveMaximumSize(long value);
    [CompilerGeneratedAttribute]
internal bool get_EnforceInputParameterValidation();
    [CompilerGeneratedAttribute]
internal void set_EnforceInputParameterValidation(bool value);
    public ExecutionPolicy get_ExecutionPolicy();
    public void set_ExecutionPolicy(ExecutionPolicy value);
    [CompilerGeneratedAttribute]
public bool get_UseFullLanguageModeInDebugger();
    [CompilerGeneratedAttribute]
public void set_UseFullLanguageModeInDebugger(bool value);
    [CompilerGeneratedAttribute]
public ApartmentState get_ApartmentState();
    [CompilerGeneratedAttribute]
public void set_ApartmentState(ApartmentState value);
    [CompilerGeneratedAttribute]
public PSThreadOptions get_ThreadOptions();
    [CompilerGeneratedAttribute]
public void set_ThreadOptions(PSThreadOptions value);
    [CompilerGeneratedAttribute]
public bool get_ThrowOnRunspaceOpenError();
    [CompilerGeneratedAttribute]
public void set_ThrowOnRunspaceOpenError(bool value);
    [CompilerGeneratedAttribute]
public virtual AuthorizationManager get_AuthorizationManager();
    [CompilerGeneratedAttribute]
public virtual void set_AuthorizationManager(AuthorizationManager value);
    public void ImportPSModule(String[] name);
    internal void ClearPSModules();
    public void ImportPSModule(IEnumerable`1<ModuleSpecification> modules);
    public void ImportPSModulesFromPath(string path);
    internal void ImportPSCoreModule(String[] name);
    public ReadOnlyCollection`1<ModuleSpecification> get_Modules();
    [CompilerGeneratedAttribute]
internal Collection`1<ModuleSpecification> get_ModuleSpecificationsToImport();
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, PSSnapInInfo> get_ImportedSnapins();
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_CoreModulesToImport();
    public virtual InitialSessionStateEntryCollection`1<SessionStateAssemblyEntry> get_Assemblies();
    public virtual InitialSessionStateEntryCollection`1<SessionStateTypeEntry> get_Types();
    public virtual InitialSessionStateEntryCollection`1<SessionStateFormatEntry> get_Formats();
    [CompilerGeneratedAttribute]
public bool get_DisableFormatUpdates();
    [CompilerGeneratedAttribute]
public void set_DisableFormatUpdates(bool value);
    public virtual InitialSessionStateEntryCollection`1<SessionStateProviderEntry> get_Providers();
    public virtual InitialSessionStateEntryCollection`1<SessionStateCommandEntry> get_Commands();
    [CompilerGeneratedAttribute]
internal SessionStateEntryVisibility get_DefaultCommandVisibility();
    [CompilerGeneratedAttribute]
internal void set_DefaultCommandVisibility(SessionStateEntryVisibility value);
    internal HashSet`1<string> get_UnresolvedCommandsToExpose();
    internal Dictionary`2<string, Hashtable> get_CommandModifications();
    internal List`1<Hashtable> get_DynamicVariablesToDefine();
    public virtual InitialSessionStateEntryCollection`1<SessionStateVariableEntry> get_Variables();
    public virtual InitialSessionStateEntryCollection`1<SessionStateVariableEntry> get_EnvironmentVariables();
    public virtual HashSet`1<string> get_StartupScripts();
    internal void Bind(ExecutionContext context, bool updateOnly, PSModuleInfo module, bool noClobber, bool local, bool setLocation);
    private void Bind_SetVariables(SessionStateInternal ss);
    private void Bind_SetEnvironment();
    private void Bind_UpdateTypes(ExecutionContext context, bool updateOnly);
    private void Bind_UpdateFormats(ExecutionContext context, bool updateOnly);
    private void Bind_LoadProviders(SessionStateInternal ss);
    private void Bind_BindCommands(PSModuleInfo module, bool noClobber, bool local, SessionStateInternal ss);
    private void Bind_LoadAssemblies(ExecutionContext context);
    internal Exception BindRunspace(Runspace initializedRunspace, PSTraceSource runspaceInitTracer);
    private static String[] GetModulesForUnResolvedCommands(IEnumerable`1<string> unresolvedCommands, ExecutionContext context);
    private void ProcessCommandModifications(Runspace initializedRunspace);
    private static void ProcessCommandModification(Hashtable commandModification, CommandMetadata metadata, string parameterName);
    private Exception ProcessDynamicVariables(Runspace initializedRunspace);
    private Exception ProcessUserDrive(Runspace initializedRunspace);
    private string MakeUserNamePath();
    private Exception ProcessStartupScripts(Runspace initializedRunspace);
    private Exception ProcessPowerShellCommand(PowerShell psToInvoke, Runspace initializedRunspace);
    private RunspaceOpenModuleLoadException ProcessModulesToImport(Runspace initializedRunspace, IEnumerable moduleList, string path, HashSet`1<CommandInfo> publicCommands, HashSet`1<string> unresolvedCmdsToExpose);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.InitialSessionState/<LookupCommands>d__147")]
private static IEnumerable`1<CommandInfo> LookupCommands(string commandPattern, string moduleName, ExecutionContext context, List`1<PSModuleInfo> processedModules);
    private RunspaceOpenModuleLoadException ProcessOneModule(Runspace initializedRunspace, string name, PSModuleInfo moduleInfoToLoad, string path, HashSet`1<CommandInfo> publicCommands, List`1<PSModuleInfo> processedModules);
    private RunspaceOpenModuleLoadException ValidateAndReturnRunspaceOpenModuleLoadException(PowerShell pse, string moduleName, RunspaceOpenModuleLoadException exception);
    internal void ResetRunspaceState(ExecutionContext context);
    internal static void SetSessionStateDrive(ExecutionContext context, bool setLocation);
    internal static void CreateQuestionVariable(ExecutionContext context);
    internal static void RemoveTypesAndFormats(ExecutionContext context, IList`1<string> formatFilesToRemove, IList`1<string> typeFilesToRemove);
    internal void UpdateTypes(ExecutionContext context, bool updateOnly);
    internal void UpdateFormats(ExecutionContext context, bool update);
    private static void ThrowTypeOrFormatErrors(string resourceString, string errorMsg, string errorId);
    [ObsoleteAttribute("Custom PSSnapIn is deprecated. Please use a module instead.", "True")]
public PSSnapInInfo ImportPSSnapIn(string name, PSSnapInException& warning);
    internal PSSnapInInfo ImportCorePSSnapIn();
    internal PSSnapInInfo ImportPSSnapIn(PSSnapInInfo psSnapInInfo, PSSnapInException& warning);
    internal PSSnapInInfo GetPSSnapIn(string psSnapinName);
    internal static Assembly LoadAssemblyFromFile(string fileName);
    internal void ImportCmdletsFromAssembly(Assembly assembly, PSModuleInfo module);
    internal static string GetClearHostFunctionText();
    internal static string GetHelpPagingFunctionText();
    internal static string GetMkdirFunctionText();
    internal static string GetOSTFunctionText();
    private static NativeArgumentPassingStyle GetPassingStyle();
    internal static SessionStateAliasEntry[] get_BuiltInAliases();
    internal static void RemoveAllDrivesForProvider(ProviderInfo pi, SessionStateInternal ssi);
    internal static string GetNestedModuleDllName(string moduleName);
    [CompilerGeneratedAttribute]
internal static HashSet`1<CommandInfo> <BindRunspace>g__GetPublicCommands|137_0(<>c__DisplayClass137_0& );
}
public abstract class System.Management.Automation.Runspaces.InitialSessionStateEntry : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PSSnapInInfo <PSSnapIn>k__BackingField;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    public string Name { get; internal set; }
    public PSSnapInInfo PSSnapIn { get; private set; }
    public PSModuleInfo Module { get; private set; }
    protected InitialSessionStateEntry(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public PSSnapInInfo get_PSSnapIn();
    [CompilerGeneratedAttribute]
private void set_PSSnapIn(PSSnapInInfo value);
    internal void SetPSSnapIn(PSSnapInInfo psSnapIn);
    [CompilerGeneratedAttribute]
public PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
private void set_Module(PSModuleInfo value);
    internal void SetModule(PSModuleInfo module);
    public abstract virtual InitialSessionStateEntry Clone();
}
[DefaultMemberAttribute("Item")]
public class System.Management.Automation.Runspaces.InitialSessionStateEntryCollection`1 : object {
    private Collection`1<T> _internalCollection;
    private object _syncObject;
    public int Count { get; }
    public T Item { get; }
    public Collection`1<T> Item { get; }
    public InitialSessionStateEntryCollection`1(IEnumerable`1<T> items);
    public InitialSessionStateEntryCollection`1<T> Clone();
    public void Reset();
    public int get_Count();
    public T get_Item(int index);
    public Collection`1<T> get_Item(string name);
    internal Collection`1<T> LookUpByName(string name);
    public void RemoveItem(int index);
    public void RemoveItem(int index, int count);
    public void Clear();
    public void Remove(string name, object type);
    public void Add(T item);
    public void Add(IEnumerable`1<T> items);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
}
internal class System.Management.Automation.Runspaces.Internal.ClientRemotePowerShell : object {
    [TraceSourceAttribute("CRPS", "ClientRemotePowerShell")]
private static PSTraceSource s_tracer;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> HostCallReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSConnectionRetryStatusEventArgs> RCConnectionNotification;
    private ObjectStreamBase inputstream;
    private ObjectStreamBase errorstream;
    private PSInformationalBuffers informationalBuffers;
    private PowerShell shell;
    private Guid clientRunspacePoolId;
    private bool noInput;
    private PSInvocationSettings settings;
    private ObjectStreamBase outputstream;
    private string computerName;
    private ClientPowerShellDataStructureHandler dataStructureHandler;
    private bool stopCalled;
    private PSHost hostToUse;
    private RemoteRunspacePoolInternal runspacePool;
    private static string WRITE_DEBUG_LINE;
    private static string WRITE_VERBOSE_LINE;
    private static string WRITE_WARNING_LINE;
    private static string WRITE_PROGRESS;
    private bool initialized;
    private Queue`1<PSInvocationStateInfo> _stateInfoQueue;
    private PSConnectionRetryStatus _connectionRetryStatus;
    internal Guid InstanceId { get; }
    internal PowerShell PowerShell { get; }
    internal bool NoInput { get; }
    internal ObjectStreamBase InputStream { get; internal set; }
    internal ObjectStreamBase OutputStream { get; internal set; }
    internal ClientPowerShellDataStructureHandler DataStructureHandler { get; }
    internal PSInvocationSettings Settings { get; }
    internal bool Initialized { get; }
    internal PSConnectionRetryStatus ConnectionRetryStatus { get; }
    internal ClientRemotePowerShell(PowerShell shell, RemoteRunspacePoolInternal runspacePool);
    private static ClientRemotePowerShell();
    internal Guid get_InstanceId();
    internal PowerShell get_PowerShell();
    internal void SetStateInfo(PSInvocationStateInfo stateInfo);
    internal bool get_NoInput();
    internal ObjectStreamBase get_InputStream();
    internal void set_InputStream(ObjectStreamBase value);
    internal ObjectStreamBase get_OutputStream();
    internal void set_OutputStream(ObjectStreamBase value);
    internal ClientPowerShellDataStructureHandler get_DataStructureHandler();
    internal PSInvocationSettings get_Settings();
    internal void UnblockCollections();
    internal void StopAsync();
    internal void SendInput();
    [CompilerGeneratedAttribute]
internal void add_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void remove_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    internal void Initialize(ObjectStreamBase inputstream, ObjectStreamBase outputstream, ObjectStreamBase errorstream, PSInformationalBuffers informationalBuffers, PSInvocationSettings settings);
    internal void Clear();
    internal bool get_Initialized();
    internal static void ExitHandler(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    internal void ConnectAsync(ConnectCommandInfo connectCmdInfo);
    [CompilerGeneratedAttribute]
internal void add_RCConnectionNotification(EventHandler`1<PSConnectionRetryStatusEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RCConnectionNotification(EventHandler`1<PSConnectionRetryStatusEventArgs> value);
    internal PSConnectionRetryStatus get_ConnectionRetryStatus();
    private void HandleErrorReceived(object sender, RemoteDataEventArgs`1<ErrorRecord> eventArgs);
    private void HandleOutputReceived(object sender, RemoteDataEventArgs`1<object> eventArgs);
    private void HandleInvocationStateInfoReceived(object sender, RemoteDataEventArgs`1<PSInvocationStateInfo> eventArgs);
    private void CheckAndCloseRunspaceAfterStop(Exception ex);
    private void HandleInformationalMessageReceived(object sender, RemoteDataEventArgs`1<InformationalMessage> eventArgs);
    private void HandleHostCallReceived(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    private void HandleConnectCompleted(object sender, RemoteDataEventArgs`1<Exception> e);
    private void HandleCloseCompleted(object sender, EventArgs args);
    private static bool IsFinished(PSInvocationState state);
    private void ExecuteHostCall(RemoteHostCall hostcall);
    private void HandleCloseNotificationFromRunspacePool(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void HandleBrokenNotificationFromRunspacePool(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void HandleRobustConnectionNotification(object sender, ConnectionStatusEventArgs e);
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.Runspaces.Internal.ConnectCommandInfo : object {
    [CompilerGeneratedAttribute]
private Guid <CommandId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Command>k__BackingField;
    public Guid CommandId { get; }
    public string Command { get; }
    public ConnectCommandInfo(Guid cmdId, string cmdStr);
    [CompilerGeneratedAttribute]
public Guid get_CommandId();
    [CompilerGeneratedAttribute]
public string get_Command();
}
internal enum System.Management.Automation.Runspaces.Internal.PSConnectionRetryStatus : Enum {
    public int value__;
    public static PSConnectionRetryStatus None;
    public static PSConnectionRetryStatus NetworkFailureDetected;
    public static PSConnectionRetryStatus ConnectionRetryAttempt;
    public static PSConnectionRetryStatus ConnectionRetrySucceeded;
    public static PSConnectionRetryStatus AutoDisconnectStarting;
    public static PSConnectionRetryStatus AutoDisconnectSucceeded;
    public static PSConnectionRetryStatus InternalErrorAbort;
}
internal class System.Management.Automation.Runspaces.Internal.PSConnectionRetryStatusEventArgs : EventArgs {
    internal static string FQIDNetworkFailureDetected;
    internal static string FQIDConnectionRetryAttempt;
    internal static string FQIDConnectionRetrySucceeded;
    internal static string FQIDAutoDisconnectStarting;
    internal static string FQIDAutoDisconnectSucceeded;
    internal static string FQIDNetworkOrDisconnectFailed;
    [CompilerGeneratedAttribute]
private PSConnectionRetryStatus <Notification>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxRetryConnectionTime>k__BackingField;
    [CompilerGeneratedAttribute]
private object <InformationRecord>k__BackingField;
    internal PSConnectionRetryStatus Notification { get; }
    internal string ComputerName { get; }
    internal int MaxRetryConnectionTime { get; }
    internal object InformationRecord { get; }
    internal PSConnectionRetryStatusEventArgs(PSConnectionRetryStatus notification, string computerName, int maxRetryConnectionTime, object infoRecord);
    [CompilerGeneratedAttribute]
internal PSConnectionRetryStatus get_Notification();
    [CompilerGeneratedAttribute]
internal string get_ComputerName();
    [CompilerGeneratedAttribute]
internal int get_MaxRetryConnectionTime();
    [CompilerGeneratedAttribute]
internal object get_InformationRecord();
}
internal static class System.Management.Automation.Runspaces.Internal.RemoteRunspacePoolEnumeration : object {
    internal static Collection`1<PSObject> GetRemotePools(WSManConnectionInfo wsmanConnectionInfo);
    internal static Collection`1<PSObject> GetRemoteCommands(Guid shellId, WSManConnectionInfo wsmanConnectionInfo);
    private static object GetSessionOptions(WSManConnectionInfo wsmanConnectionInfo);
    private static bool CheckForSSL(WSManConnectionInfo wsmanConnectionInfo);
    private static int ConvertPSAuthToWSManAuth(AuthenticationMechanism psAuth);
}
internal class System.Management.Automation.Runspaces.Internal.RemoteRunspacePoolInternal : RunspacePoolInternal {
    [CompilerGeneratedAttribute]
private ClientRunspacePoolDataStructureHandler <DataStructureHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private ConnectCommandInfo[] <ConnectCommands>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AvailableForConnection>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemoteDebugStop>k__BackingField;
    [CompilerGeneratedAttribute]
private PSPrimitiveDictionary <ApplicationArguments>k__BackingField;
    private PSPrimitiveDictionary _applicationPrivateData;
    private ManualResetEvent _applicationPrivateDataReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> HostCallReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<Uri>> URIRedirectionReported;
    [CompilerGeneratedAttribute]
private EventHandler`1<CreateCompleteEventArgs> SessionCreateCompleted;
    private RunspaceConnectionInfo _connectionInfo;
    private RunspacePoolAsyncResult _openAsyncResult;
    private RunspacePoolAsyncResult _closeAsyncResult;
    private Exception _closingReason;
    private RunspacePoolAsyncResult _disconnectAsyncResult;
    private RunspacePoolAsyncResult _reconnectAsyncResult;
    private bool _isDisposed;
    [CompilerGeneratedAttribute]
private DispatchTable`1<object> <DispatchTable>k__BackingField;
    private bool _canReconnect;
    private string _friendlyName;
    private ConcurrentStack`1<PowerShell> _runningPowerShells;
    public RunspaceConnectionInfo ConnectionInfo { get; }
    internal ClientRunspacePoolDataStructureHandler DataStructureHandler { get; private set; }
    internal ConnectCommandInfo[] ConnectCommands { get; internal set; }
    internal string Name { get; internal set; }
    internal bool AvailableForConnection { get; private set; }
    internal int MaxRetryConnectionTime { get; }
    public RunspacePoolAvailability RunspacePoolAvailability { get; }
    internal bool IsRemoteDebugStop { get; internal set; }
    internal PSHost Host { get; }
    internal PSPrimitiveDictionary ApplicationArguments { get; }
    internal bool CanDisconnect { get; }
    internal Version PSRemotingProtocolVersion { get; }
    private DispatchTable`1<object> DispatchTable { get; }
    internal RemoteRunspacePoolInternal(int minRunspaces, int maxRunspaces, TypeTable typeTable, PSHost host, PSPrimitiveDictionary applicationArguments, RunspaceConnectionInfo connectionInfo, string name);
    internal RemoteRunspacePoolInternal(Guid instanceId, string name, bool isDisconnected, ConnectCommandInfo[] connectCommands, RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    private void CreateDSHandler(TypeTable typeTable);
    public virtual RunspaceConnectionInfo get_ConnectionInfo();
    [CompilerGeneratedAttribute]
internal ClientRunspacePoolDataStructureHandler get_DataStructureHandler();
    [CompilerGeneratedAttribute]
private void set_DataStructureHandler(ClientRunspacePoolDataStructureHandler value);
    [CompilerGeneratedAttribute]
internal ConnectCommandInfo[] get_ConnectCommands();
    [CompilerGeneratedAttribute]
internal void set_ConnectCommands(ConnectCommandInfo[] value);
    internal string get_Name();
    internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal bool get_AvailableForConnection();
    [CompilerGeneratedAttribute]
private void set_AvailableForConnection(bool value);
    internal int get_MaxRetryConnectionTime();
    public virtual RunspacePoolAvailability get_RunspacePoolAvailability();
    [CompilerGeneratedAttribute]
internal bool get_IsRemoteDebugStop();
    [CompilerGeneratedAttribute]
internal void set_IsRemoteDebugStop(bool value);
    internal virtual bool ResetRunspaceState();
    internal virtual bool SetMaxRunspaces(int maxRunspaces);
    internal virtual bool SetMinRunspaces(int minRunspaces);
    internal virtual int GetAvailableRunspaces();
    internal void HandleApplicationPrivateDataReceived(object sender, RemoteDataEventArgs`1<PSPrimitiveDictionary> eventArgs);
    internal void HandleInitInfoReceived(object sender, RemoteDataEventArgs`1<RunspacePoolInitInfo> eventArgs);
    internal void HandleStateInfoReceived(object sender, RemoteDataEventArgs`1<RunspacePoolStateInfo> eventArgs);
    internal void HandleRemoteHostCalls(object sender, RemoteDataEventArgs`1<RemoteHostCall> eventArgs);
    internal PSHost get_Host();
    [CompilerGeneratedAttribute]
internal PSPrimitiveDictionary get_ApplicationArguments();
    internal virtual PSPrimitiveDictionary GetApplicationPrivateData();
    internal void SetApplicationPrivateData(PSPrimitiveDictionary applicationPrivateData);
    internal virtual void PropagateApplicationPrivateData(Runspace runspace);
    [CompilerGeneratedAttribute]
internal void add_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void remove_HostCallReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostCall>> value);
    [CompilerGeneratedAttribute]
internal void add_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    [CompilerGeneratedAttribute]
internal void remove_URIRedirectionReported(EventHandler`1<RemoteDataEventArgs`1<Uri>> value);
    [CompilerGeneratedAttribute]
internal void add_SessionCreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_SessionCreateCompleted(EventHandler`1<CreateCompleteEventArgs> value);
    internal void CreatePowerShellOnServerAndInvoke(ClientRemotePowerShell shell);
    internal void AddRemotePowerShellDSHandler(Guid psShellInstanceId, ClientPowerShellDataStructureHandler psDSHandler);
    internal bool get_CanDisconnect();
    internal Version get_PSRemotingProtocolVersion();
    internal void PushRunningPowerShell(PowerShell ps);
    internal PowerShell PopRunningPowerShell();
    internal PowerShell GetCurrentRunningPowerShell();
    protected virtual IAsyncResult CoreOpen(bool isAsync, AsyncCallback callback, object asyncState);
    public virtual void Open();
    public virtual void Close();
    public virtual IAsyncResult BeginClose(AsyncCallback callback, object asyncState);
    public virtual void Disconnect();
    public virtual IAsyncResult BeginDisconnect(AsyncCallback callback, object state);
    public virtual void EndDisconnect(IAsyncResult asyncResult);
    public virtual void Connect();
    public virtual IAsyncResult BeginConnect(AsyncCallback callback, object state);
    public virtual void EndConnect(IAsyncResult asyncResult);
    public virtual Collection`1<PowerShell> CreateDisconnectedPowerShells(RunspacePool runspacePool);
    public virtual RunspacePoolCapability GetCapabilities();
    internal static RunspacePool[] GetRemoteRunspacePools(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    internal static RunspacePool GetRemoteRunspacePool(RunspaceConnectionInfo connectionInfo, Guid sessionId, Nullable`1<Guid> commandId, PSHost host, TypeTable typeTable);
    private static void UpdateWSManConnectionInfo(WSManConnectionInfo wsmanConnectionInfo, PSObject rsInfoObject);
    private static void ComputeDisconnectedOnExpiresOn(PSObject rsInfoObject, Nullable`1& disconnectedOn, Nullable`1& expiresOn);
    private static bool GetTimeIntValue(string timeString, Int32& value);
    private void SetRunspacePoolState(RunspacePoolStateInfo newStateInfo);
    private void SetRunspacePoolState(RunspacePoolStateInfo newStateInfo, bool raiseEvents);
    private void HandleSessionDisconnected(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void SetDisconnectAsCompleted();
    private void HandleSessionReconnected(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void SetReconnectAsCompleted();
    private void HandleSessionClosing(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void HandleSessionClosed(object sender, RemoteDataEventArgs`1<Exception> eventArgs);
    private void SetOpenAsCompleted();
    private void SetCloseAsCompleted();
    private void HandleResponseReceived(object sender, RemoteDataEventArgs`1<PSObject> eventArgs);
    private void HandleURIDirectionReported(object sender, RemoteDataEventArgs`1<Uri> eventArgs);
    private void HandlePSEventArgsReceived(object sender, RemoteDataEventArgs`1<PSEventArgs> e);
    private void HandleSessionRCDisconnecting(object sender, RemoteDataEventArgs`1<Exception> e);
    private void HandleSessionCreateCompleted(object sender, CreateCompleteEventArgs eventArgs);
    private void ResetDisconnectedOnExpiresOn();
    private void UpdateDisconnectedExpiresOn();
    private void WaitAndRaiseConnectEventsProc(object state);
    [CompilerGeneratedAttribute]
private DispatchTable`1<object> get_DispatchTable();
    public sealed virtual void Dispose();
    public virtual void Dispose(bool disposing);
}
internal class System.Management.Automation.Runspaces.Internal.RunspacePoolInternal : object {
    protected int maxPoolSz;
    protected int minPoolSz;
    protected int totalRunspaces;
    protected List`1<Runspace> runspaceList;
    protected Stack`1<Runspace> pool;
    protected Queue`1<GetRunspaceAsyncResult> runspaceRequestQueue;
    protected Queue`1<GetRunspaceAsyncResult> ultimateRequestQueue;
    protected RunspacePoolStateInfo stateInfo;
    protected InitialSessionState _initialSessionState;
    protected PSHost host;
    protected Guid instanceId;
    private bool _isDisposed;
    protected bool isServicingRequests;
    protected object syncObject;
    private static TimeSpan s_defaultCleanupPeriod;
    private TimeSpan _cleanupInterval;
    private Timer _cleanupTimer;
    private PSPrimitiveDictionary _applicationPrivateData;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspacePoolStateChangedEventArgs> StateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> ForwardEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceCreatedEventArgs> RunspaceCreated;
    [CompilerGeneratedAttribute]
private PSThreadOptions <ThreadOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private ApartmentState <ApartmentState>k__BackingField;
    public Guid InstanceId { get; }
    public bool IsDisposed { get; }
    public RunspacePoolStateInfo RunspacePoolStateInfo { get; }
    public InitialSessionState InitialSessionState { get; }
    public RunspaceConnectionInfo ConnectionInfo { get; }
    public TimeSpan CleanupInterval { get; public set; }
    public RunspacePoolAvailability RunspacePoolAvailability { get; }
    internal PSThreadOptions ThreadOptions { get; internal set; }
    internal ApartmentState ApartmentState { get; internal set; }
    public RunspacePoolInternal(int minRunspaces, int maxRunspaces, PSHost host);
    public RunspacePoolInternal(int minRunspaces, int maxRunspaces, InitialSessionState initialSessionState, PSHost host);
    protected RunspacePoolInternal(int minRunspaces, int maxRunspaces);
    private static RunspacePoolInternal();
    public Guid get_InstanceId();
    public bool get_IsDisposed();
    public RunspacePoolStateInfo get_RunspacePoolStateInfo();
    internal virtual PSPrimitiveDictionary GetApplicationPrivateData();
    internal virtual void PropagateApplicationPrivateData(Runspace runspace);
    public InitialSessionState get_InitialSessionState();
    public virtual RunspaceConnectionInfo get_ConnectionInfo();
    public TimeSpan get_CleanupInterval();
    public void set_CleanupInterval(TimeSpan value);
    public virtual RunspacePoolAvailability get_RunspacePoolAvailability();
    [CompilerGeneratedAttribute]
public void add_StateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
public void add_ForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_ForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
internal void add_RunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_RunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    public virtual void Disconnect();
    public virtual IAsyncResult BeginDisconnect(AsyncCallback callback, object state);
    public virtual void EndDisconnect(IAsyncResult asyncResult);
    public virtual void Connect();
    public virtual IAsyncResult BeginConnect(AsyncCallback callback, object state);
    public virtual void EndConnect(IAsyncResult asyncResult);
    public virtual Collection`1<PowerShell> CreateDisconnectedPowerShells(RunspacePool runspacePool);
    public virtual RunspacePoolCapability GetCapabilities();
    internal virtual bool ResetRunspaceState();
    internal virtual bool SetMaxRunspaces(int maxRunspaces);
    public int GetMaxRunspaces();
    internal virtual bool SetMinRunspaces(int minRunspaces);
    public int GetMinRunspaces();
    internal virtual int GetAvailableRunspaces();
    public virtual void Open();
    public IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult asyncResult);
    public virtual void Close();
    public virtual IAsyncResult BeginClose(AsyncCallback callback, object state);
    public virtual void EndClose(IAsyncResult asyncResult);
    public Runspace GetRunspace();
    public void ReleaseRunspace(Runspace runspace);
    public virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
internal PSThreadOptions get_ThreadOptions();
    [CompilerGeneratedAttribute]
internal void set_ThreadOptions(PSThreadOptions value);
    [CompilerGeneratedAttribute]
internal ApartmentState get_ApartmentState();
    [CompilerGeneratedAttribute]
internal void set_ApartmentState(ApartmentState value);
    internal IAsyncResult BeginGetRunspace(AsyncCallback callback, object state);
    internal void CancelGetRunspace(IAsyncResult asyncResult);
    internal Runspace EndGetRunspace(IAsyncResult asyncResult);
    protected virtual IAsyncResult CoreOpen(bool isAsync, AsyncCallback callback, object asyncState);
    protected void OpenHelper();
    private void SetStateToBroken(Exception reason);
    protected void OpenThreadProc(object o);
    private IAsyncResult CoreClose(bool isAsync, AsyncCallback callback, object asyncState);
    private void CloseHelper();
    private void CloseThreadProc(object o);
    protected void RaiseStateChangeEvent(RunspacePoolStateInfo stateInfo);
    internal void AssertPoolIsOpen();
    protected Runspace CreateRunspace();
    protected void DestroyRunspace(Runspace runspace);
    protected void CleanupCallback(object state);
    private void InternalClearAllResources();
    protected void EnqueueCheckAndStartRequestServicingThread(GetRunspaceAsyncResult requestToEnqueue, bool useCallingThread);
    protected void ServicePendingRequests(object useCallingThreadState);
    protected void AssertIfStateIsBeforeOpen();
    protected virtual void OnForwardEvent(PSEventArgs e);
    private void OnRunspaceForwardEvent(object sender, PSEventArgs e);
}
public class System.Management.Automation.Runspaces.InvalidPipelineStateException : SystemException {
    private PipelineState _currentState;
    private PipelineState _expectedState;
    public PipelineState CurrentState { get; }
    public PipelineState ExpectedState { get; }
    public InvalidPipelineStateException(string message);
    public InvalidPipelineStateException(string message, Exception innerException);
    internal InvalidPipelineStateException(string message, PipelineState currentState, PipelineState expectedState);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
private InvalidPipelineStateException(SerializationInfo info, StreamingContext context);
    public PipelineState get_CurrentState();
    public PipelineState get_ExpectedState();
}
public class System.Management.Automation.Runspaces.InvalidRunspacePoolStateException : SystemException {
    private RunspacePoolState _currentState;
    private RunspacePoolState _expectedState;
    public RunspacePoolState CurrentState { get; }
    public RunspacePoolState ExpectedState { get; }
    public InvalidRunspacePoolStateException(string message);
    public InvalidRunspacePoolStateException(string message, Exception innerException);
    internal InvalidRunspacePoolStateException(string message, RunspacePoolState currentState, RunspacePoolState expectedState);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected InvalidRunspacePoolStateException(SerializationInfo info, StreamingContext context);
    public RunspacePoolState get_CurrentState();
    public RunspacePoolState get_ExpectedState();
    internal InvalidRunspaceStateException ToInvalidRunspaceStateException();
    private static RunspaceState RunspacePoolStateToRunspaceState(RunspacePoolState state);
}
public class System.Management.Automation.Runspaces.InvalidRunspaceStateException : SystemException {
    private RunspaceState _currentState;
    private RunspaceState _expectedState;
    public RunspaceState CurrentState { get; internal set; }
    public RunspaceState ExpectedState { get; internal set; }
    public InvalidRunspaceStateException(string message);
    public InvalidRunspaceStateException(string message, Exception innerException);
    internal InvalidRunspaceStateException(string message, RunspaceState currentState, RunspaceState expectedState);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected InvalidRunspaceStateException(SerializationInfo info, StreamingContext context);
    public RunspaceState get_CurrentState();
    internal void set_CurrentState(RunspaceState value);
    public RunspaceState get_ExpectedState();
    internal void set_ExpectedState(RunspaceState value);
}
internal class System.Management.Automation.Runspaces.LoadContext : object {
    internal XmlReader reader;
    internal ConcurrentBag`1<string> errors;
    internal string fileName;
    internal string PSSnapinName;
    internal bool isFullyTrusted;
    [CompilerGeneratedAttribute]
private bool <IsProductCode>k__BackingField;
    internal bool IsFullyTrusted { get; internal set; }
    internal bool IsProductCode { get; internal set; }
    internal LoadContext(string PSSnapinName, string fileName, ConcurrentBag`1<string> errors);
    internal bool get_IsFullyTrusted();
    internal void set_IsFullyTrusted(bool value);
    [CompilerGeneratedAttribute]
internal bool get_IsProductCode();
    [CompilerGeneratedAttribute]
internal void set_IsProductCode(bool value);
    internal void AddError(string resourceString, Object[] formatArguments);
    internal void AddError(int errorLineNumber, string resourceString, Object[] formatArguments);
    internal void AddError(string typeName, int errorLineNumber, string resourceString, Object[] formatArguments);
}
internal class System.Management.Automation.Runspaces.LocalPipeline : PipelineBase {
    internal static int DefaultPipelineStackSize;
    private PipelineStopper _stopper;
    private DateTime _pipelineStartTime;
    private long _historyIdForThisPipeline;
    private bool _useExternalInput;
    private PipelineWriter _oldExternalErrorOutput;
    private PipelineWriter _oldExternalSuccessOutput;
    private WindowsIdentity _identityToImpersonate;
    private bool _disposed;
    internal PipelineStopper Stopper { get; }
    internal bool IsStopping { get; }
    private LocalRunspace LocalRunspace { get; }
    internal LocalPipeline(LocalRunspace runspace, string command, bool addToHistory, bool isNested);
    internal LocalPipeline(LocalRunspace runspace, CommandCollection command, bool addToHistory, bool isNested, ObjectStreamBase inputStream, ObjectStreamBase outputStream, ObjectStreamBase errorStream, PSInformationalBuffers infoBuffers);
    internal LocalPipeline(LocalPipeline pipeline);
    public virtual Pipeline Copy();
    protected virtual void StartPipelineExecution();
    private void SetupInvokeThread(Thread invokeThread, bool changeName);
    private FlowControlException InvokeHelper();
    private void InvokeThreadProcImpersonate();
    private void InvokeThreadProc();
    protected virtual void ImplementStop(bool syncCall);
    private void StopThreadProc();
    internal PipelineStopper get_Stopper();
    private void StopHelper();
    internal bool get_IsStopping();
    private PipelineProcessor CreatePipelineProcessor();
    private CommandProcessorBase CreateCommandProcessBase(Command command);
    private void InitStreams();
    private void ClearStreams();
    private void RecordPipelineStartTime();
    private void AddHistoryEntry(bool skipIfLocked);
    internal void AddHistoryEntryFromAddHistoryCmdlet();
    internal void UpdateHistoryEntryAddedByAddHistoryCmdlet(bool skipIfLocked);
    internal virtual void SetHistoryString(string historyString);
    internal static ExecutionContext GetExecutionContextFromTLS();
    private LocalRunspace get_LocalRunspace();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private void <InvokeThreadProcImpersonate>b__8_0();
}
internal class System.Management.Automation.Runspaces.LocalRunspace : RunspaceBase {
    private PSPrimitiveDictionary _applicationPrivateData;
    private PSThreadOptions _createThreadOptions;
    [CompilerGeneratedAttribute]
private bool <InInternalNestedPrompt>k__BackingField;
    private TranscriptionData _transcriptionData;
    private JobRepository _jobRepository;
    private JobManager _jobManager;
    private RunspaceRepository _runspaceRepository;
    private static string s_debugPreferenceCachePath;
    private static object s_debugPreferenceLockObject;
    private PipelineThread _pipelineThread;
    private bool _disposed;
    private AutomationEngine _engine;
    private History _history;
    [TraceSourceAttribute("RunspaceInit", "Initialization code for Runspace")]
private static PSTraceSource s_runspaceInitTracer;
    private static RemoteSessionNamedPipeServer s_IPCNamedPipeServer;
    public PSEventManager Events { get; }
    public PSThreadOptions ThreadOptions { get; public set; }
    internal ExecutionContext GetExecutionContext { get; }
    internal bool InNestedPrompt { get; }
    internal bool InInternalNestedPrompt { get; internal set; }
    internal History History { get; }
    internal TranscriptionData TranscriptionData { get; }
    internal JobRepository JobRepository { get; }
    public JobManager JobManager { get; }
    internal RunspaceRepository RunspaceRepository { get; }
    public Debugger Debugger { get; }
    protected List`1<string> DoApplications { get; }
    protected List`1<string> DoScripts { get; }
    protected DriveManagementIntrinsics DoDrive { get; }
    protected PSLanguageMode DoLanguageMode { get; protected set; }
    protected PSModuleInfo DoModule { get; }
    protected PathIntrinsics DoPath { get; }
    protected CmdletProviderManagementIntrinsics DoProvider { get; }
    protected PSVariableIntrinsics DoPSVariable { get; }
    protected CommandInvocationIntrinsics DoInvokeCommand { get; }
    protected ProviderIntrinsics DoInvokeProvider { get; }
    internal AutomationEngine Engine { get; }
    internal LocalRunspace(PSHost host, InitialSessionState initialSessionState, bool suppressClone);
    internal LocalRunspace(PSHost host, InitialSessionState initialSessionState);
    private static LocalRunspace();
    public virtual PSPrimitiveDictionary GetApplicationPrivateData();
    internal virtual void SetApplicationPrivateData(PSPrimitiveDictionary applicationPrivateData);
    public virtual PSEventManager get_Events();
    public virtual PSThreadOptions get_ThreadOptions();
    public virtual void set_ThreadOptions(PSThreadOptions value);
    private bool IsValidThreadOptionsConfiguration(PSThreadOptions options);
    public virtual void ResetRunspaceState();
    protected virtual Pipeline CoreCreatePipeline(string command, bool addToHistory, bool isNested);
    internal virtual ExecutionContext get_GetExecutionContext();
    internal virtual bool get_InNestedPrompt();
    [CompilerGeneratedAttribute]
internal bool get_InInternalNestedPrompt();
    [CompilerGeneratedAttribute]
internal void set_InInternalNestedPrompt(bool value);
    internal History get_History();
    internal TranscriptionData get_TranscriptionData();
    internal JobRepository get_JobRepository();
    public virtual JobManager get_JobManager();
    internal RunspaceRepository get_RunspaceRepository();
    public virtual Debugger get_Debugger();
    private static DebugPreference CreateDebugPreference(String[] AppDomainNames);
    internal static void SetDebugPreference(string processName, List`1<string> appDomainName, bool enable);
    private static Hashtable GetDebugPreferenceCache(Runspace runspace);
    private static DebugPreference GetProcessSpecificDebugPreference(object debugPreference);
    protected virtual void OpenHelper(bool syncCall);
    private void OpenThreadProc();
    private void DoOpenHelper();
    internal void LogEngineHealthEvent(Exception exception);
    internal void LogEngineHealthEvent(Exception exception, Severity severity, int id, Dictionary`2<string, string> additionalInfo);
    internal PipelineThread GetPipelineThread();
    protected virtual void CloseHelper(bool syncCall);
    private void CloseThreadProc();
    private void DoCloseHelper();
    private static void CloseOrDisconnectAllRemoteRunspaces(Func`1<List`1<RemoteRunspace>> getRunspaces);
    private void StopOrDisconnectAllJobs();
    internal void ReleaseDebugger();
    protected virtual void DoSetVariable(string name, object value);
    protected virtual object DoGetVariable(string name);
    protected virtual List`1<string> get_DoApplications();
    protected virtual List`1<string> get_DoScripts();
    protected virtual DriveManagementIntrinsics get_DoDrive();
    protected virtual PSLanguageMode get_DoLanguageMode();
    protected virtual void set_DoLanguageMode(PSLanguageMode value);
    protected virtual PSModuleInfo get_DoModule();
    protected virtual PathIntrinsics get_DoPath();
    protected virtual CmdletProviderManagementIntrinsics get_DoProvider();
    protected virtual PSVariableIntrinsics get_DoPSVariable();
    protected virtual CommandInvocationIntrinsics get_DoInvokeCommand();
    protected virtual ProviderIntrinsics get_DoInvokeProvider();
    protected virtual void Dispose(bool disposing);
    public virtual void Close();
    internal AutomationEngine get_Engine();
    private void InitializeDefaults();
    [CompilerGeneratedAttribute]
private List`1<RemoteRunspace> <DoCloseHelper>b__54_0();
}
public class System.Management.Automation.Runspaces.MemberSetData : TypeMemberData {
    [CompilerGeneratedAttribute]
private Collection`1<TypeMemberData> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <InheritMembers>k__BackingField;
    public Collection`1<TypeMemberData> Members { get; }
    public bool IsHidden { get; public set; }
    public bool InheritMembers { get; public set; }
    public MemberSetData(string name, Collection`1<TypeMemberData> members);
    [CompilerGeneratedAttribute]
public Collection`1<TypeMemberData> get_Members();
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    [CompilerGeneratedAttribute]
public bool get_InheritMembers();
    [CompilerGeneratedAttribute]
public void set_InheritMembers(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public class System.Management.Automation.Runspaces.NamedPipeConnectionInfo : RunspaceConnectionInfo {
    private PSCredential _credential;
    private AuthenticationMechanism _authMechanism;
    private string _appDomainName;
    private static int _defaultOpenTimeout;
    [CompilerGeneratedAttribute]
private int <ProcessId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CustomPipeName>k__BackingField;
    public int ProcessId { get; public set; }
    public string AppDomainName { get; public set; }
    public string CustomPipeName { get; public set; }
    public string ComputerName { get; public set; }
    public PSCredential Credential { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public NamedPipeConnectionInfo(int processId);
    public NamedPipeConnectionInfo(int processId, string appDomainName);
    public NamedPipeConnectionInfo(int processId, string appDomainName, int openTimeout);
    public NamedPipeConnectionInfo(string customPipeName);
    public NamedPipeConnectionInfo(string customPipeName, int openTimeout);
    [CompilerGeneratedAttribute]
public int get_ProcessId();
    [CompilerGeneratedAttribute]
public void set_ProcessId(int value);
    public string get_AppDomainName();
    public void set_AppDomainName(string value);
    [CompilerGeneratedAttribute]
public string get_CustomPipeName();
    [CompilerGeneratedAttribute]
public void set_CustomPipeName(string value);
    public virtual string get_ComputerName();
    public virtual void set_ComputerName(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public virtual RunspaceConnectionInfo Clone();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
}
internal class System.Management.Automation.Runspaces.NewProcessConnectionInfo : RunspaceConnectionInfo {
    private PSCredential _credential;
    private AuthenticationMechanism _authMechanism;
    [CompilerGeneratedAttribute]
private ScriptBlock <InitializationScript>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RunAs32>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WorkingDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <PSVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShellProcessInstance <Process>k__BackingField;
    public ScriptBlock InitializationScript { get; public set; }
    public bool RunAs32 { get; public set; }
    public string WorkingDirectory { get; public set; }
    public Version PSVersion { get; public set; }
    internal PowerShellProcessInstance Process { get; internal set; }
    public string ComputerName { get; public set; }
    public PSCredential Credential { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    internal NewProcessConnectionInfo(PSCredential credential);
    [CompilerGeneratedAttribute]
public ScriptBlock get_InitializationScript();
    [CompilerGeneratedAttribute]
public void set_InitializationScript(ScriptBlock value);
    [CompilerGeneratedAttribute]
public bool get_RunAs32();
    [CompilerGeneratedAttribute]
public void set_RunAs32(bool value);
    [CompilerGeneratedAttribute]
public string get_WorkingDirectory();
    [CompilerGeneratedAttribute]
public void set_WorkingDirectory(string value);
    [CompilerGeneratedAttribute]
public Version get_PSVersion();
    [CompilerGeneratedAttribute]
public void set_PSVersion(Version value);
    [CompilerGeneratedAttribute]
internal PowerShellProcessInstance get_Process();
    [CompilerGeneratedAttribute]
internal void set_Process(PowerShellProcessInstance value);
    public virtual string get_ComputerName();
    public virtual void set_ComputerName(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public NewProcessConnectionInfo Copy();
    public virtual RunspaceConnectionInfo Clone();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
}
[DebuggerDisplayAttribute("NoteProperty: {Name,nq} = {Value,nq}")]
public class System.Management.Automation.Runspaces.NotePropertyData : TypeMemberData {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    public object Value { get; public set; }
    public bool IsHidden { get; public set; }
    public NotePropertyData(string name, object value);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public enum System.Management.Automation.Runspaces.OutputBufferingMode : Enum {
    public int value__;
    public static OutputBufferingMode None;
    public static OutputBufferingMode Drop;
    public static OutputBufferingMode Block;
}
public abstract class System.Management.Automation.Runspaces.Pipeline : object {
    private bool _hadErrors;
    [CompilerGeneratedAttribute]
private long <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandCollection <Commands>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetPipelineSessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private PSInvocationSettings <InvocationSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RedirectShellErrorOutputPipe>k__BackingField;
    public Runspace Runspace { get; }
    public bool IsNested { get; }
    internal bool IsChild { get; internal set; }
    public PipelineWriter Input { get; }
    public PipelineReader`1<PSObject> Output { get; }
    public PipelineReader`1<object> Error { get; }
    public PipelineStateInfo PipelineStateInfo { get; }
    public bool HadErrors { get; }
    public long InstanceId { get; }
    public CommandCollection Commands { get; private set; }
    public bool SetPipelineSessionState { get; public set; }
    internal PSInvocationSettings InvocationSettings { get; internal set; }
    internal bool RedirectShellErrorOutputPipe { get; internal set; }
    internal Pipeline(Runspace runspace);
    internal Pipeline(Runspace runspace, CommandCollection command);
    public abstract virtual Runspace get_Runspace();
    public abstract virtual bool get_IsNested();
    internal virtual bool get_IsChild();
    internal virtual void set_IsChild(bool value);
    public abstract virtual PipelineWriter get_Input();
    public abstract virtual PipelineReader`1<PSObject> get_Output();
    public abstract virtual PipelineReader`1<object> get_Error();
    public abstract virtual PipelineStateInfo get_PipelineStateInfo();
    public virtual bool get_HadErrors();
    internal void SetHadErrors(bool status);
    [CompilerGeneratedAttribute]
public long get_InstanceId();
    [CompilerGeneratedAttribute]
public CommandCollection get_Commands();
    [CompilerGeneratedAttribute]
private void set_Commands(CommandCollection value);
    [CompilerGeneratedAttribute]
public bool get_SetPipelineSessionState();
    [CompilerGeneratedAttribute]
public void set_SetPipelineSessionState(bool value);
    [CompilerGeneratedAttribute]
internal PSInvocationSettings get_InvocationSettings();
    [CompilerGeneratedAttribute]
internal void set_InvocationSettings(PSInvocationSettings value);
    [CompilerGeneratedAttribute]
internal bool get_RedirectShellErrorOutputPipe();
    [CompilerGeneratedAttribute]
internal void set_RedirectShellErrorOutputPipe(bool value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    public Collection`1<PSObject> Invoke();
    public abstract virtual Collection`1<PSObject> Invoke(IEnumerable input);
    public abstract virtual void InvokeAsync();
    public abstract virtual void Stop();
    public abstract virtual void StopAsync();
    public abstract virtual Pipeline Copy();
    public abstract virtual Collection`1<PSObject> Connect();
    public abstract virtual void ConnectAsync();
    internal void SetCommandCollection(CommandCollection commands);
    internal abstract virtual void SetHistoryString(string historyString);
    internal abstract virtual void InvokeAsyncAndDisconnect();
    internal virtual void SuspendIncomingData();
    internal virtual void ResumeIncomingData();
    internal virtual void DrainIncomingData();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class System.Management.Automation.Runspaces.PipelineBase : Pipeline {
    private Runspace _runspace;
    private bool _isNested;
    [CompilerGeneratedAttribute]
private bool <IsPulsePipeline>k__BackingField;
    private PipelineStateInfo _pipelineStateInfo;
    [CompilerGeneratedAttribute]
private bool <IsChild>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SyncInvokeCall>k__BackingField;
    private bool _performNestedCheck;
    [CompilerGeneratedAttribute]
private Thread <NestedPipelineExecutionThread>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<PipelineStateEventArgs> StateChanged;
    private Queue`1<ExecutionEventQueueItem> _executionEventQueue;
    [CompilerGeneratedAttribute]
private ManualResetEvent <PipelineFinishedEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectStreamBase <OutputStream>k__BackingField;
    private ObjectStreamBase _errorStream;
    [CompilerGeneratedAttribute]
private PSInformationalBuffers <InformationalBuffers>k__BackingField;
    [CompilerGeneratedAttribute]
private ObjectStreamBase <InputStream>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddToHistory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HistoryString>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    private bool _disposed;
    public Runspace Runspace { get; }
    public bool IsNested { get; }
    internal bool IsPulsePipeline { get; internal set; }
    public PipelineStateInfo PipelineStateInfo { get; }
    public PipelineWriter Input { get; }
    public PipelineReader`1<PSObject> Output { get; }
    public PipelineReader`1<object> Error { get; }
    internal bool IsChild { get; internal set; }
    protected bool SyncInvokeCall { get; private set; }
    unknown bool PerformNestedCheck {internal set; }
    internal Thread NestedPipelineExecutionThread { get; internal set; }
    protected PipelineState PipelineState { get; }
    internal ManualResetEvent PipelineFinishedEvent { get; private set; }
    protected ObjectStreamBase OutputStream { get; }
    protected ObjectStreamBase ErrorStream { get; private set; }
    protected PSInformationalBuffers InformationalBuffers { get; }
    protected ObjectStreamBase InputStream { get; }
    internal bool AddToHistory { get; internal set; }
    internal string HistoryString { get; internal set; }
    private RunspaceBase RunspaceBase { get; }
    protected internal object SyncRoot { get; }
    protected PipelineBase(Runspace runspace, string command, bool addToHistory, bool isNested);
    protected PipelineBase(Runspace runspace, CommandCollection command, bool addToHistory, bool isNested, ObjectStreamBase inputStream, ObjectStreamBase outputStream, ObjectStreamBase errorStream, PSInformationalBuffers infoBuffers);
    protected PipelineBase(PipelineBase pipeline);
    public virtual Runspace get_Runspace();
    internal Runspace GetRunspace();
    public virtual bool get_IsNested();
    [CompilerGeneratedAttribute]
internal bool get_IsPulsePipeline();
    [CompilerGeneratedAttribute]
internal void set_IsPulsePipeline(bool value);
    public virtual PipelineStateInfo get_PipelineStateInfo();
    public virtual PipelineWriter get_Input();
    public virtual PipelineReader`1<PSObject> get_Output();
    public virtual PipelineReader`1<object> get_Error();
    [CompilerGeneratedAttribute]
internal virtual bool get_IsChild();
    [CompilerGeneratedAttribute]
internal virtual void set_IsChild(bool value);
    public virtual void Stop();
    public virtual void StopAsync();
    private void CoreStop(bool syncCall);
    protected abstract virtual void ImplementStop(bool syncCall);
    public virtual Collection`1<PSObject> Invoke(IEnumerable input);
    public virtual void InvokeAsync();
    [CompilerGeneratedAttribute]
protected bool get_SyncInvokeCall();
    [CompilerGeneratedAttribute]
private void set_SyncInvokeCall(bool value);
    private void CoreInvoke(IEnumerable input, bool syncCall);
    internal virtual void InvokeAsyncAndDisconnect();
    protected abstract virtual void StartPipelineExecution();
    internal void set_PerformNestedCheck(bool value);
    [CompilerGeneratedAttribute]
internal Thread get_NestedPipelineExecutionThread();
    [CompilerGeneratedAttribute]
internal void set_NestedPipelineExecutionThread(Thread value);
    internal void DoConcurrentCheck(bool syncCall, object syncObject, bool isInLock);
    public virtual Collection`1<PSObject> Connect();
    public virtual void ConnectAsync();
    [CompilerGeneratedAttribute]
public virtual void add_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_StateChanged(EventHandler`1<PipelineStateEventArgs> value);
    protected PipelineState get_PipelineState();
    protected bool IsPipelineFinished();
    protected void SetPipelineState(PipelineState state, Exception reason);
    protected void SetPipelineState(PipelineState state);
    protected void RaisePipelineStateEvents();
    [CompilerGeneratedAttribute]
internal ManualResetEvent get_PipelineFinishedEvent();
    [CompilerGeneratedAttribute]
private void set_PipelineFinishedEvent(ManualResetEvent value);
    [CompilerGeneratedAttribute]
protected ObjectStreamBase get_OutputStream();
    protected ObjectStreamBase get_ErrorStream();
    private void set_ErrorStream(ObjectStreamBase value);
    private void OnErrorStreamDataReady(object sender, EventArgs e);
    [CompilerGeneratedAttribute]
protected PSInformationalBuffers get_InformationalBuffers();
    [CompilerGeneratedAttribute]
protected ObjectStreamBase get_InputStream();
    [CompilerGeneratedAttribute]
internal bool get_AddToHistory();
    [CompilerGeneratedAttribute]
internal void set_AddToHistory(bool value);
    [CompilerGeneratedAttribute]
internal string get_HistoryString();
    [CompilerGeneratedAttribute]
internal void set_HistoryString(string value);
    private void Initialize(Runspace runspace, string command, bool addToHistory, bool isNested);
    private RunspaceBase get_RunspaceBase();
    [CompilerGeneratedAttribute]
protected internal object get_SyncRoot();
    protected virtual void Dispose(bool disposing);
}
public abstract class System.Management.Automation.Runspaces.PipelineReader`1 : object {
    public WaitHandle WaitHandle { get; }
    public bool EndOfPipeline { get; }
    public bool IsOpen { get; }
    public int Count { get; }
    public int MaxCapacity { get; }
    [CompilerGeneratedAttribute]
public abstract virtual void add_DataReady(EventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_DataReady(EventHandler value);
    public abstract virtual WaitHandle get_WaitHandle();
    public abstract virtual bool get_EndOfPipeline();
    public abstract virtual bool get_IsOpen();
    public abstract virtual int get_Count();
    public abstract virtual int get_MaxCapacity();
    public abstract virtual void Close();
    public abstract virtual Collection`1<T> Read(int count);
    public abstract virtual T Read();
    public abstract virtual Collection`1<T> ReadToEnd();
    public abstract virtual Collection`1<T> NonBlockingRead();
    public abstract virtual Collection`1<T> NonBlockingRead(int maxRequested);
    public abstract virtual T Peek();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PipelineReader`1/<GetReadEnumerator>d__20")]
internal IEnumerator`1<T> GetReadEnumerator();
}
[FlagsAttribute]
public enum System.Management.Automation.Runspaces.PipelineResultTypes : Enum {
    public int value__;
    public static PipelineResultTypes None;
    public static PipelineResultTypes Output;
    public static PipelineResultTypes Error;
    public static PipelineResultTypes Warning;
    public static PipelineResultTypes Verbose;
    public static PipelineResultTypes Debug;
    public static PipelineResultTypes Information;
    public static PipelineResultTypes All;
    public static PipelineResultTypes Null;
}
public enum System.Management.Automation.Runspaces.PipelineState : Enum {
    public int value__;
    public static PipelineState NotStarted;
    public static PipelineState Running;
    public static PipelineState Stopping;
    public static PipelineState Stopped;
    public static PipelineState Completed;
    public static PipelineState Failed;
    public static PipelineState Disconnected;
}
public class System.Management.Automation.Runspaces.PipelineStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private PipelineStateInfo <PipelineStateInfo>k__BackingField;
    public PipelineStateInfo PipelineStateInfo { get; }
    internal PipelineStateEventArgs(PipelineStateInfo pipelineStateInfo);
    [CompilerGeneratedAttribute]
public PipelineStateInfo get_PipelineStateInfo();
}
public class System.Management.Automation.Runspaces.PipelineStateInfo : object {
    [CompilerGeneratedAttribute]
private PipelineState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public PipelineState State { get; }
    public Exception Reason { get; }
    internal PipelineStateInfo(PipelineState state);
    internal PipelineStateInfo(PipelineState state, Exception reason);
    internal PipelineStateInfo(PipelineStateInfo pipelineStateInfo);
    [CompilerGeneratedAttribute]
public PipelineState get_State();
    [CompilerGeneratedAttribute]
public Exception get_Reason();
    internal PipelineStateInfo Clone();
}
internal class System.Management.Automation.Runspaces.PipelineStopper : object {
    private Stack`1<PipelineProcessor> _stack;
    private object _syncRoot;
    private LocalPipeline _localPipeline;
    private bool _stopping;
    internal bool IsStopping { get; internal set; }
    internal PipelineStopper(LocalPipeline localPipeline);
    internal bool get_IsStopping();
    internal void set_IsStopping(bool value);
    internal void Push(PipelineProcessor item);
    internal void Pop(bool fromSteppablePipeline);
    internal void Stop();
}
internal class System.Management.Automation.Runspaces.PipelineThread : object {
    private Thread _worker;
    private ThreadStart _workItem;
    private AutoResetEvent _workItemReady;
    private bool _closed;
    internal Thread Worker { get; }
    internal PipelineThread(ApartmentState apartmentState);
    internal Thread get_Worker();
    internal void Start(ThreadStart workItem);
    internal void Close();
    private void WorkerProc();
    public sealed virtual void Dispose();
    protected virtual override void Finalize();
}
public abstract class System.Management.Automation.Runspaces.PipelineWriter : object {
    public WaitHandle WaitHandle { get; }
    public bool IsOpen { get; }
    public int Count { get; }
    public int MaxCapacity { get; }
    public abstract virtual WaitHandle get_WaitHandle();
    public abstract virtual bool get_IsOpen();
    public abstract virtual int get_Count();
    public abstract virtual int get_MaxCapacity();
    public abstract virtual void Close();
    public abstract virtual void Flush();
    public abstract virtual int Write(object obj);
    public abstract virtual int Write(object obj, bool enumerateCollection);
}
internal class System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml : object {
    private static string PreReleaseStringScriptBlock;
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_RuntimeType>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_RuntimeType();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_MemberDefinition>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_MemberDefinition();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_GroupInfo>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_GroupInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_GroupInfoNoElement>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_GroupInfoNoElement();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_HistoryInfo>d__5")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_HistoryInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_MatchInfo>d__6")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_MatchInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Deserialized_Microsoft_PowerShell_Commands_MatchInfo>d__7")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_Microsoft_PowerShell_Commands_MatchInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSVariable>d__8")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSVariable();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PathInfo>d__9")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PathInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_CommandInfo>d__10")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_CommandInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_AliasInfo_System_Management_Automation_ApplicationInfo_System_Management_Automation_CmdletInfo_System_Management_Automation_ExternalScriptInfo_System_Management_Automation_FilterInfo_System_Management_Automation_FunctionInfo_System_Management_Automation_ScriptInfo>d__11")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_AliasInfo_System_Management_Automation_ApplicationInfo_System_Management_Automation_CmdletInfo_System_Management_Automation_ExternalScriptInfo_System_Management_Automation_FilterInfo_System_Management_Automation_FunctionInfo_System_Management_Automation_ScriptInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Runspaces_TypeData>d__12")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Runspaces_TypeData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_ControlPanelItem>d__13")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_ControlPanelItem();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ApplicationInfo>d__14")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ApplicationInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ScriptInfo>d__15")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ScriptInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ExternalScriptInfo>d__16")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ExternalScriptInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_FunctionInfo>d__17")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_FunctionInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_FilterInfo>d__18")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_FilterInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_AliasInfo>d__19")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_AliasInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_ListCommand_MemberInfo>d__20")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_ListCommand_MemberInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_ActiveDirectoryProvider_ADPSDriveInfo_System_Management_Automation_PSDriveInfo>d__21")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_ActiveDirectoryProvider_ADPSDriveInfo_System_Management_Automation_PSDriveInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ProviderInfo>d__22")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ProviderInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_CmdletInfo>d__23")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_CmdletInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_FilterInfo_System_Management_Automation_FunctionInfo>d__24")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_FilterInfo_System_Management_Automation_FunctionInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSDriveInfo>d__25")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSDriveInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Subsystem_SubsystemInfo>d__26")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Subsystem_SubsystemInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Subsystem_SubsystemInfo_ImplementationInfo>d__27")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Subsystem_SubsystemInfo_ImplementationInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ShellVariable>d__28")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ShellVariable();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ScriptBlock>d__29")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ScriptBlock();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_GetError>d__30")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_GetError();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ErrorRecord>d__31")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ErrorRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_WarningRecord>d__32")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_WarningRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Deserialized_System_Management_Automation_WarningRecord>d__33")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_System_Management_Automation_WarningRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_InformationRecord>d__34")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_InformationRecord();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_CommandParameterSetInfo>d__35")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_CommandParameterSetInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Runspaces_Runspace>d__36")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Runspaces_Runspace();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Runspaces_PSSession>d__37")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Runspaces_PSSession();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_Job>d__38")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_Job();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Deserialized_Microsoft_PowerShell_Commands_TextMeasureInfo>d__39")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_Microsoft_PowerShell_Commands_TextMeasureInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Deserialized_Microsoft_PowerShell_Commands_GenericMeasureInfo>d__40")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Deserialized_Microsoft_PowerShell_Commands_GenericMeasureInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_CallStackFrame>d__41")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_CallStackFrame();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_BreakpointTypes>d__42")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_BreakpointTypes();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_PSSessionConfigurationCommands_PSSessionConfiguration>d__43")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_PSSessionConfigurationCommands_PSSessionConfiguration();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_ComputerChangeInfo>d__44")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_ComputerChangeInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_RenameComputerChangeInfo>d__45")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_RenameComputerChangeInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_ModuleInfoGrouping>d__47")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_ModuleInfoGrouping(CustomControl[] sharedControls);
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSModuleInfo>d__48")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSModuleInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_ExperimentalFeature>d__49")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_ExperimentalFeature();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_BasicHtmlWebResponseObject>d__50")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_BasicHtmlWebResponseObject();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_WebResponseObject>d__51")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_WebResponseObject();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_Powershell_Utility_FileHashInfo>d__52")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_Powershell_Utility_FileHashInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_PSRunspaceDebug>d__53")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_PSRunspaceDebug();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_MarkdownRender_MarkdownOptionInfo>d__54")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_MarkdownRender_MarkdownOptionInfo();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_TcpPortStatus>d__55")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_TcpPortStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_PingStatus>d__56")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_PingStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_PingMtuStatus>d__57")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_PingMtuStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_TraceStatus>d__58")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_TestConnectionCommand_TraceStatus();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_ByteCollection>d__59")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_ByteCollection();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyle>d__60")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyle();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyleFormattingData>d__61")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyleFormattingData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyleProgressConfiguration>d__62")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyleProgressConfiguration();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyleFileInfoFormat>d__63")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyleFileInfoFormat();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyleForegroundColor>d__64")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyleForegroundColor();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellCore_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSStyleBackgroundColor>d__65")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSStyleBackgroundColor();
}
public class System.Management.Automation.Runspaces.PowerShellProcessInstance : object {
    private ProcessStartInfo _startInfo;
    private RunspacePool _runspacePool;
    private object _syncObject;
    private bool _started;
    private bool _isDisposed;
    private bool _processExited;
    internal static string PwshExePath;
    internal static string WinPwshExePath;
    [CompilerGeneratedAttribute]
private Process <Process>k__BackingField;
    [CompilerGeneratedAttribute]
private OutOfProcessTextWriter <StdInWriter>k__BackingField;
    public bool HasExited { get; }
    public Process Process { get; }
    internal RunspacePool RunspacePool { get; internal set; }
    internal OutOfProcessTextWriter StdInWriter { get; internal set; }
    private static PowerShellProcessInstance();
    public PowerShellProcessInstance(Version powerShellVersion, PSCredential credential, ScriptBlock initializationScript, bool useWow64, string workingDirectory);
    public PowerShellProcessInstance(Version powerShellVersion, PSCredential credential, ScriptBlock initializationScript, bool useWow64);
    public bool get_HasExited();
    public sealed virtual void Dispose();
    private void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public Process get_Process();
    internal RunspacePool get_RunspacePool();
    internal void set_RunspacePool(RunspacePool value);
    [CompilerGeneratedAttribute]
internal OutOfProcessTextWriter get_StdInWriter();
    [CompilerGeneratedAttribute]
internal void set_StdInWriter(OutOfProcessTextWriter value);
    internal void Start();
    private void ProcessExited(object sender, EventArgs e);
}
internal class System.Management.Automation.Runspaces.PowerShellTrace_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellTrace_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.PowerShellTrace_Format_Ps1Xml/<ViewsOf_System_Management_Automation_PSTraceSource>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Management_Automation_PSTraceSource();
}
[DebuggerDisplayAttribute("PropertySet: {Name,nq}")]
public class System.Management.Automation.Runspaces.PropertySetData : TypeMemberData {
    [CompilerGeneratedAttribute]
private Collection`1<string> <ReferencedProperties>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    public Collection`1<string> ReferencedProperties { get; }
    internal string Name { get; internal set; }
    public bool IsHidden { get; public set; }
    public PropertySetData(IEnumerable`1<string> referencedProperties);
    [CompilerGeneratedAttribute]
public Collection`1<string> get_ReferencedProperties();
    internal string get_Name();
    internal void set_Name(string value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public class System.Management.Automation.Runspaces.PSConsoleLoadException : SystemException {
    private ErrorRecord _errorRecord;
    private Collection`1<PSSnapInException> _PSSnapInExceptions;
    public ErrorRecord ErrorRecord { get; }
    internal Collection`1<PSSnapInException> PSSnapInExceptions { get; }
    public string Message { get; }
    public PSConsoleLoadException(string message);
    public PSConsoleLoadException(string message, Exception innerException);
    public sealed virtual ErrorRecord get_ErrorRecord();
    private void CreateErrorRecord();
    internal Collection`1<PSSnapInException> get_PSSnapInExceptions();
    public virtual string get_Message();
}
public class System.Management.Automation.Runspaces.PSSession : object {
    private RemoteRunspace _remoteRunspace;
    private string _transportName;
    private static int s_seed;
    [CompilerGeneratedAttribute]
private TargetMachineType <ComputerType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public TargetMachineType ComputerType { get; public set; }
    public string ComputerName { get; }
    public string ContainerId { get; }
    public string VMName { get; }
    public Nullable`1<Guid> VMId { get; }
    public string ConfigurationName { get; }
    public Guid InstanceId { get; }
    public int Id { get; }
    public string Name { get; public set; }
    public RunspaceAvailability Availability { get; }
    public PSPrimitiveDictionary ApplicationPrivateData { get; }
    public Runspace Runspace { get; }
    public string Transport { get; }
    internal PSSession(RemoteRunspace remoteRunspace);
    [CompilerGeneratedAttribute]
public TargetMachineType get_ComputerType();
    [CompilerGeneratedAttribute]
public void set_ComputerType(TargetMachineType value);
    public string get_ComputerName();
    public string get_ContainerId();
    public string get_VMName();
    public Nullable`1<Guid> get_VMId();
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
public int get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    public RunspaceAvailability get_Availability();
    public PSPrimitiveDictionary get_ApplicationPrivateData();
    public Runspace get_Runspace();
    public string get_Transport();
    public virtual string ToString();
    internal bool InsertRunspace(RemoteRunspace remoteRunspace);
    private string GetTransportName();
    private static string GetDisplayShellName(string shell);
    public static PSSession Create(Runspace runspace, string transportName, PSCmdlet psCmdlet);
    internal static string GenerateRunspaceName(Int32& rtnId);
    internal static int GenerateRunspaceId();
}
public enum System.Management.Automation.Runspaces.PSSessionConfigurationAccessMode : Enum {
    public int value__;
    public static PSSessionConfigurationAccessMode Disabled;
    public static PSSessionConfigurationAccessMode Local;
    public static PSSessionConfigurationAccessMode Remote;
}
public class System.Management.Automation.Runspaces.PSSnapInException : RuntimeException {
    private bool _warning;
    private ErrorRecord _errorRecord;
    private bool _isErrorRecordOriginallyNull;
    private string _PSSnapin;
    private string _reason;
    public ErrorRecord ErrorRecord { get; }
    public string Message { get; }
    internal PSSnapInException(string PSSnapin, string message);
    internal PSSnapInException(string PSSnapin, string message, bool warning);
    internal PSSnapInException(string PSSnapin, string message, Exception exception);
    public PSSnapInException(string message);
    public PSSnapInException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected PSSnapInException(SerializationInfo info, StreamingContext context);
    private void CreateErrorRecord();
    public virtual ErrorRecord get_ErrorRecord();
    public virtual string get_Message();
}
internal static class System.Management.Automation.Runspaces.PSSnapInHelpers : object {
    private static Lazy`1<ConcurrentDictionary`2<Assembly, Dictionary`2<string, Tuple`2<SessionStateCmdletEntry, List`1<SessionStateAliasEntry>>>>> s_cmdletCache;
    private static Lazy`1<ConcurrentDictionary`2<Assembly, Dictionary`2<string, SessionStateProviderEntry>>> s_providerCache;
    private static Lazy`1<ConcurrentDictionary`2<Assembly, bool>> s_assembliesWithModuleInitializerCache;
    private static PSTraceSource s_PSSnapInTracer;
    private static PSSnapInHelpers();
    internal static Assembly LoadPSSnapInAssembly(PSSnapInInfo psSnapInInfo);
    private static bool TryGetCustomAttribute(Type decoratedType, T& attribute);
    internal static void AnalyzePSSnapInAssembly(Assembly assembly, string name, PSSnapInInfo psSnapInInfo, PSModuleInfo moduleInfo, Dictionary`2& cmdlets, Dictionary`2& aliases, Dictionary`2& providers, String& helpFile);
    private static void AnalyzeModuleAssemblyWithReflection(Assembly assembly, string name, PSSnapInInfo psSnapInInfo, PSModuleInfo moduleInfo, string helpFile, Dictionary`2& cmdlets, Dictionary`2& aliases, Dictionary`2& providers);
    private static void InitializeCoreCmdletsAndProviders(PSSnapInInfo psSnapInInfo, Dictionary`2& cmdlets, Dictionary`2& providers, string helpFile);
    private static void ExecuteModuleInitializer(Assembly assembly, IEnumerable`1<Type> assemblyTypes);
    internal static IEnumerable`1<Type> GetAssemblyTypes(Assembly assembly, string name);
    private static bool IsCmdletClass(Type type);
    private static bool IsProviderClass(Type type);
    private static bool HasDefaultConstructor(Type type);
    private static string GetHelpFile(string assemblyPath);
}
internal class System.Management.Automation.Runspaces.PSSnapInTypeAndFormatErrors : object {
    public string psSnapinName;
    [CompilerGeneratedAttribute]
private ExtendedTypeDefinition <FormatData>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeData <TypeData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemove>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullPath>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatTable <FormatTable>k__BackingField;
    [CompilerGeneratedAttribute]
private ConcurrentBag`1<string> <Errors>k__BackingField;
    internal bool FailToLoadFile;
    internal ExtendedTypeDefinition FormatData { get; }
    internal TypeData TypeData { get; }
    internal bool IsRemove { get; }
    internal string FullPath { get; }
    internal FormatTable FormatTable { get; }
    internal ConcurrentBag`1<string> Errors { get; internal set; }
    internal string PSSnapinName { get; }
    internal PSSnapInTypeAndFormatErrors(string psSnapinName, string fullPath);
    internal PSSnapInTypeAndFormatErrors(string psSnapinName, FormatTable formatTable);
    internal PSSnapInTypeAndFormatErrors(string psSnapinName, TypeData typeData, bool isRemove);
    internal PSSnapInTypeAndFormatErrors(string psSnapinName, ExtendedTypeDefinition typeDefinition);
    [CompilerGeneratedAttribute]
internal ExtendedTypeDefinition get_FormatData();
    [CompilerGeneratedAttribute]
internal TypeData get_TypeData();
    [CompilerGeneratedAttribute]
internal bool get_IsRemove();
    [CompilerGeneratedAttribute]
internal string get_FullPath();
    [CompilerGeneratedAttribute]
internal FormatTable get_FormatTable();
    [CompilerGeneratedAttribute]
internal ConcurrentBag`1<string> get_Errors();
    [CompilerGeneratedAttribute]
internal void set_Errors(ConcurrentBag`1<string> value);
    internal string get_PSSnapinName();
}
public enum System.Management.Automation.Runspaces.PSThreadOptions : Enum {
    public int value__;
    public static PSThreadOptions Default;
    public static PSThreadOptions UseNewThread;
    public static PSThreadOptions ReuseThread;
    public static PSThreadOptions UseCurrentThread;
}
internal class System.Management.Automation.Runspaces.Registry_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Registry_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.Registry_Format_Ps1Xml/<ViewsOf_Microsoft_PowerShell_Commands_Internal_TransactedRegistryKey_Microsoft_Win32_RegistryKey_System_Management_Automation_TreatAs_RegistryValue>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_PowerShell_Commands_Internal_TransactedRegistryKey_Microsoft_Win32_RegistryKey_System_Management_Automation_TreatAs_RegistryValue(CustomControl[] sharedControls);
}
[DataContractAttribute]
public class System.Management.Automation.Runspaces.RemotingDebugRecord : DebugRecord {
    [DataMemberAttribute]
private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingDebugRecord(string message, OriginInfo originInfo);
    public OriginInfo get_OriginInfo();
}
public class System.Management.Automation.Runspaces.RemotingErrorRecord : ErrorRecord {
    private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingErrorRecord(ErrorRecord errorRecord, OriginInfo originInfo);
    private RemotingErrorRecord(ErrorRecord errorRecord, OriginInfo originInfo, Exception replaceParentContainsErrorRecordException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected RemotingErrorRecord(SerializationInfo info, StreamingContext context);
    public OriginInfo get_OriginInfo();
    internal virtual ErrorRecord WrapException(Exception replaceParentContainsErrorRecordException);
}
[DataContractAttribute]
public class System.Management.Automation.Runspaces.RemotingInformationRecord : InformationRecord {
    [DataMemberAttribute]
private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingInformationRecord(InformationRecord record, OriginInfo originInfo);
    public OriginInfo get_OriginInfo();
}
[DataContractAttribute]
public class System.Management.Automation.Runspaces.RemotingProgressRecord : ProgressRecord {
    [DataMemberAttribute]
private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingProgressRecord(ProgressRecord progressRecord, OriginInfo originInfo);
    public OriginInfo get_OriginInfo();
    private static ProgressRecord Validate(ProgressRecord progressRecord);
}
[DataContractAttribute]
public class System.Management.Automation.Runspaces.RemotingVerboseRecord : VerboseRecord {
    [DataMemberAttribute]
private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingVerboseRecord(string message, OriginInfo originInfo);
    public OriginInfo get_OriginInfo();
}
[DataContractAttribute]
public class System.Management.Automation.Runspaces.RemotingWarningRecord : WarningRecord {
    [DataMemberAttribute]
private OriginInfo _originInfo;
    public OriginInfo OriginInfo { get; }
    public RemotingWarningRecord(string message, OriginInfo originInfo);
    internal RemotingWarningRecord(WarningRecord warningRecord, OriginInfo originInfo);
    public OriginInfo get_OriginInfo();
}
public abstract class System.Management.Automation.Runspaces.Runspace : object {
    private static int s_globalId;
    private Stack`1<PowerShell> _runningPowerShells;
    private PowerShell _baseRunningPowerShell;
    private object _syncObject;
    [ThreadStaticAttribute]
private static Runspace t_threadSpecificDefaultRunspace;
    private static Runspace s_primaryRunspace;
    internal static ApartmentState DefaultApartmentState;
    private ApartmentState apartmentState;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipUserProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DisconnectedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <EngineActivityId>k__BackingField;
    private static SortedDictionary`2<int, WeakReference`1<Runspace>> s_runspaceDictionary;
    private static object s_syncObject;
    [CompilerGeneratedAttribute]
private Debugger <InternalDebugger>k__BackingField;
    private long _pipelineIdSeed;
    public static Runspace DefaultRunspace { get; public set; }
    internal static Runspace PrimaryRunspace { get; internal set; }
    public static bool CanUseDefaultRunspace { get; }
    public ApartmentState ApartmentState { get; public set; }
    public PSThreadOptions ThreadOptions { get; public set; }
    public Version Version { get; }
    public bool RunspaceIsRemote { get; }
    public RunspaceStateInfo RunspaceStateInfo { get; }
    public RunspaceAvailability RunspaceAvailability { get; protected set; }
    public InitialSessionState InitialSessionState { get; }
    public Guid InstanceId { get; internal set; }
    internal ExecutionContext ExecutionContext { get; }
    internal bool SkipUserProfile { get; internal set; }
    public RunspaceConnectionInfo ConnectionInfo { get; }
    public RunspaceConnectionInfo OriginalConnectionInfo { get; }
    public JobManager JobManager { get; }
    public Nullable`1<DateTime> DisconnectedOn { get; internal set; }
    public Nullable`1<DateTime> ExpiresOn { get; internal set; }
    public string Name { get; public set; }
    public int Id { get; }
    internal Guid EngineActivityId { get; internal set; }
    internal static ReadOnlyDictionary`2<int, WeakReference`1<Runspace>> RunspaceDictionary { get; }
    internal static IReadOnlyList`1<Runspace> RunspaceList { get; }
    internal bool HasAvailabilityChangedSubscribers { get; }
    public SessionStateProxy SessionStateProxy { get; }
    internal ExecutionContext GetExecutionContext { get; }
    internal bool InNestedPrompt { get; }
    public Debugger Debugger { get; }
    internal Debugger InternalDebugger { get; internal set; }
    public PSEventManager Events { get; }
    private static Runspace();
    public static Runspace get_DefaultRunspace();
    public static void set_DefaultRunspace(Runspace value);
    internal static Runspace get_PrimaryRunspace();
    internal static void set_PrimaryRunspace(Runspace value);
    public static bool get_CanUseDefaultRunspace();
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    public abstract virtual PSThreadOptions get_ThreadOptions();
    public abstract virtual void set_ThreadOptions(PSThreadOptions value);
    public abstract virtual Version get_Version();
    public bool get_RunspaceIsRemote();
    public abstract virtual RunspaceStateInfo get_RunspaceStateInfo();
    public abstract virtual RunspaceAvailability get_RunspaceAvailability();
    protected abstract virtual void set_RunspaceAvailability(RunspaceAvailability value);
    public abstract virtual InitialSessionState get_InitialSessionState();
    [CompilerGeneratedAttribute]
public Guid get_InstanceId();
    [CompilerGeneratedAttribute]
internal void set_InstanceId(Guid value);
    internal ExecutionContext get_ExecutionContext();
    [CompilerGeneratedAttribute]
internal bool get_SkipUserProfile();
    [CompilerGeneratedAttribute]
internal void set_SkipUserProfile(bool value);
    public abstract virtual RunspaceConnectionInfo get_ConnectionInfo();
    public abstract virtual RunspaceConnectionInfo get_OriginalConnectionInfo();
    public abstract virtual JobManager get_JobManager();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_DisconnectedOn();
    [CompilerGeneratedAttribute]
internal void set_DisconnectedOn(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public int get_Id();
    internal Version GetRemoteProtocolVersion();
    [CompilerGeneratedAttribute]
internal Guid get_EngineActivityId();
    [CompilerGeneratedAttribute]
internal void set_EngineActivityId(Guid value);
    internal static ReadOnlyDictionary`2<int, WeakReference`1<Runspace>> get_RunspaceDictionary();
    internal static IReadOnlyList`1<Runspace> get_RunspaceList();
    [CompilerGeneratedAttribute]
public abstract virtual void add_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void add_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    internal abstract virtual bool get_HasAvailabilityChangedSubscribers();
    protected abstract virtual void OnAvailabilityChanged(RunspaceAvailabilityEventArgs e);
    internal void UpdateRunspaceAvailability(PipelineState pipelineState, bool raiseEvent, Nullable`1<Guid> cmdInstanceId);
    internal void UpdateRunspaceAvailability(PSInvocationState invocationState, bool raiseEvent, Guid cmdInstanceId);
    protected void UpdateRunspaceAvailability(RunspaceState runspaceState, bool raiseEvent);
    internal void UpdateRunspaceAvailability(RunspaceAvailability availability, bool raiseEvent);
    internal void RaiseAvailabilityChangedEvent(RunspaceAvailability availability);
    public static Runspace[] GetRunspaces(RunspaceConnectionInfo connectionInfo);
    public static Runspace[] GetRunspaces(RunspaceConnectionInfo connectionInfo, PSHost host);
    public static Runspace[] GetRunspaces(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    public static Runspace GetRunspace(RunspaceConnectionInfo connectionInfo, Guid sessionId, Nullable`1<Guid> commandId, PSHost host, TypeTable typeTable);
    public abstract virtual void Disconnect();
    public abstract virtual void DisconnectAsync();
    public abstract virtual void Connect();
    public abstract virtual void ConnectAsync();
    public abstract virtual Pipeline CreateDisconnectedPipeline();
    public abstract virtual PowerShell CreateDisconnectedPowerShell();
    public abstract virtual RunspaceCapability GetCapabilities();
    public abstract virtual void Open();
    public abstract virtual void OpenAsync();
    public abstract virtual void Close();
    public abstract virtual void CloseAsync();
    public abstract virtual Pipeline CreatePipeline();
    public abstract virtual Pipeline CreatePipeline(string command);
    public abstract virtual Pipeline CreatePipeline(string command, bool addToHistory);
    public abstract virtual Pipeline CreateNestedPipeline();
    public abstract virtual Pipeline CreateNestedPipeline(string command, bool addToHistory);
    internal abstract virtual Pipeline GetCurrentlyRunningPipeline();
    public abstract virtual PSPrimitiveDictionary GetApplicationPrivateData();
    internal abstract virtual void SetApplicationPrivateData(PSPrimitiveDictionary applicationPrivateData);
    internal void PushRunningPowerShell(PowerShell ps);
    internal PowerShell PopRunningPowerShell();
    internal PowerShell GetCurrentBasePowerShell();
    public SessionStateProxy get_SessionStateProxy();
    internal abstract virtual SessionStateProxy GetSessionStateProxy();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal abstract virtual ExecutionContext get_GetExecutionContext();
    internal abstract virtual bool get_InNestedPrompt();
    public virtual Debugger get_Debugger();
    [CompilerGeneratedAttribute]
internal Debugger get_InternalDebugger();
    [CompilerGeneratedAttribute]
internal void set_InternalDebugger(Debugger value);
    public abstract virtual PSEventManager get_Events();
    public virtual void ResetRunspaceState();
    internal long GeneratePipelineId();
}
public enum System.Management.Automation.Runspaces.RunspaceAvailability : Enum {
    public int value__;
    public static RunspaceAvailability None;
    public static RunspaceAvailability Available;
    public static RunspaceAvailability AvailableForNestedCommand;
    public static RunspaceAvailability Busy;
    public static RunspaceAvailability RemoteDebug;
}
public class System.Management.Automation.Runspaces.RunspaceAvailabilityEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RunspaceAvailability <RunspaceAvailability>k__BackingField;
    public RunspaceAvailability RunspaceAvailability { get; }
    internal RunspaceAvailabilityEventArgs(RunspaceAvailability runspaceAvailability);
    [CompilerGeneratedAttribute]
public RunspaceAvailability get_RunspaceAvailability();
}
internal abstract class System.Management.Automation.Runspaces.RunspaceBase : Runspace {
    [CompilerGeneratedAttribute]
private PSHost <Host>k__BackingField;
    [CompilerGeneratedAttribute]
private InitialSessionState <InitialSessionState>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    private RunspaceStateInfo _runspaceStateInfo;
    private RunspaceAvailability _runspaceAvailability;
    [CompilerGeneratedAttribute]
private object <SyncRoot>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceStateEventArgs> StateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceAvailabilityEventArgs> AvailabilityChanged;
    private Queue`1<RunspaceEventQueueItem> _runspaceEventQueue;
    internal ManualResetEventSlim RunspaceOpening;
    [CompilerGeneratedAttribute]
private bool <ByPassRunspaceStateCheck>k__BackingField;
    private object _pipelineListLock;
    [CompilerGeneratedAttribute]
private List`1<Pipeline> <RunningPipelines>k__BackingField;
    private Pipeline _currentlyRunningPipeline;
    [CompilerGeneratedAttribute]
private PipelineBase <PulsePipeline>k__BackingField;
    private bool _bSessionStateProxyCallInProgress;
    private SessionStateProxy _sessionStateProxy;
    protected PSHost Host { get; }
    public InitialSessionState InitialSessionState { get; }
    public Version Version { get; }
    public RunspaceStateInfo RunspaceStateInfo { get; }
    public RunspaceAvailability RunspaceAvailability { get; protected set; }
    protected internal object SyncRoot { get; }
    public RunspaceConnectionInfo ConnectionInfo { get; }
    public RunspaceConnectionInfo OriginalConnectionInfo { get; }
    internal bool HasAvailabilityChangedSubscribers { get; }
    protected RunspaceState RunspaceState { get; }
    protected bool ByPassRunspaceStateCheck { get; protected set; }
    protected List`1<Pipeline> RunningPipelines { get; }
    internal PipelineBase PulsePipeline { get; private set; }
    internal List`1<string> Applications { get; }
    internal List`1<string> Scripts { get; }
    internal DriveManagementIntrinsics Drive { get; }
    public PSLanguageMode LanguageMode { get; public set; }
    internal PSModuleInfo Module { get; }
    internal PathIntrinsics PathIntrinsics { get; }
    internal CmdletProviderManagementIntrinsics Provider { get; }
    internal PSVariableIntrinsics PSVariable { get; }
    internal CommandInvocationIntrinsics InvokeCommand { get; }
    internal ProviderIntrinsics InvokeProvider { get; }
    protected List`1<string> DoApplications { get; }
    protected List`1<string> DoScripts { get; }
    protected DriveManagementIntrinsics DoDrive { get; }
    protected PSLanguageMode DoLanguageMode { get; protected set; }
    protected PSModuleInfo DoModule { get; }
    protected PathIntrinsics DoPath { get; }
    protected CmdletProviderManagementIntrinsics DoProvider { get; }
    protected PSVariableIntrinsics DoPSVariable { get; }
    protected CommandInvocationIntrinsics DoInvokeCommand { get; }
    protected ProviderIntrinsics DoInvokeProvider { get; }
    protected RunspaceBase(PSHost host);
    protected RunspaceBase(PSHost host, InitialSessionState initialSessionState);
    protected RunspaceBase(PSHost host, InitialSessionState initialSessionState, bool suppressClone);
    [CompilerGeneratedAttribute]
protected PSHost get_Host();
    [CompilerGeneratedAttribute]
public virtual InitialSessionState get_InitialSessionState();
    [CompilerGeneratedAttribute]
public virtual Version get_Version();
    public virtual RunspaceStateInfo get_RunspaceStateInfo();
    public virtual RunspaceAvailability get_RunspaceAvailability();
    protected virtual void set_RunspaceAvailability(RunspaceAvailability value);
    [CompilerGeneratedAttribute]
protected internal object get_SyncRoot();
    public virtual RunspaceConnectionInfo get_ConnectionInfo();
    public virtual RunspaceConnectionInfo get_OriginalConnectionInfo();
    public virtual void Open();
    public virtual void OpenAsync();
    private void CoreOpen(bool syncCall);
    protected abstract virtual void OpenHelper(bool syncCall);
    public virtual void Close();
    public virtual void CloseAsync();
    private void CoreClose(bool syncCall);
    protected abstract virtual void CloseHelper(bool syncCall);
    public virtual void Disconnect();
    public virtual void DisconnectAsync();
    public virtual void Connect();
    public virtual void ConnectAsync();
    public virtual Pipeline CreateDisconnectedPipeline();
    public virtual PowerShell CreateDisconnectedPowerShell();
    public virtual RunspaceCapability GetCapabilities();
    public virtual Pipeline CreatePipeline();
    public virtual Pipeline CreatePipeline(string command);
    public virtual Pipeline CreatePipeline(string command, bool addToHistory);
    public virtual Pipeline CreateNestedPipeline();
    public virtual Pipeline CreateNestedPipeline(string command, bool addToHistory);
    protected abstract virtual Pipeline CoreCreatePipeline(string command, bool addToHistory, bool isNested);
    [CompilerGeneratedAttribute]
public virtual void add_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_StateChanged(EventHandler`1<RunspaceStateEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void add_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    [CompilerGeneratedAttribute]
public virtual void remove_AvailabilityChanged(EventHandler`1<RunspaceAvailabilityEventArgs> value);
    internal virtual bool get_HasAvailabilityChangedSubscribers();
    protected virtual void OnAvailabilityChanged(RunspaceAvailabilityEventArgs e);
    protected RunspaceState get_RunspaceState();
    protected void SetRunspaceState(RunspaceState state, Exception reason);
    protected void SetRunspaceState(RunspaceState state);
    protected void RaiseRunspaceStateEvents();
    [CompilerGeneratedAttribute]
protected bool get_ByPassRunspaceStateCheck();
    [CompilerGeneratedAttribute]
protected void set_ByPassRunspaceStateCheck(bool value);
    [CompilerGeneratedAttribute]
protected List`1<Pipeline> get_RunningPipelines();
    internal void AddToRunningPipelineList(PipelineBase pipeline);
    internal void RemoveFromRunningPipelineList(PipelineBase pipeline);
    internal bool WaitForFinishofPipelines();
    protected void StopPipelines();
    internal bool CanRunActionInCurrentPipeline();
    internal virtual Pipeline GetCurrentlyRunningPipeline();
    internal void StopNestedPipelines(Pipeline pipeline);
    internal void DoConcurrentCheckAndAddToRunningPipelines(PipelineBase pipeline, bool syncCall);
    internal void Pulse();
    [CompilerGeneratedAttribute]
internal PipelineBase get_PulsePipeline();
    [CompilerGeneratedAttribute]
private void set_PulsePipeline(PipelineBase value);
    private void DoConcurrentCheckAndMarkSessionStateProxyCallInProgress();
    internal void SetVariable(string name, object value);
    internal object GetVariable(string name);
    internal List`1<string> get_Applications();
    internal List`1<string> get_Scripts();
    internal DriveManagementIntrinsics get_Drive();
    public PSLanguageMode get_LanguageMode();
    public void set_LanguageMode(PSLanguageMode value);
    internal PSModuleInfo get_Module();
    internal PathIntrinsics get_PathIntrinsics();
    internal CmdletProviderManagementIntrinsics get_Provider();
    internal PSVariableIntrinsics get_PSVariable();
    internal CommandInvocationIntrinsics get_InvokeCommand();
    internal ProviderIntrinsics get_InvokeProvider();
    protected abstract virtual void DoSetVariable(string name, object value);
    protected abstract virtual object DoGetVariable(string name);
    protected abstract virtual List`1<string> get_DoApplications();
    protected abstract virtual List`1<string> get_DoScripts();
    protected abstract virtual DriveManagementIntrinsics get_DoDrive();
    protected abstract virtual PSLanguageMode get_DoLanguageMode();
    protected abstract virtual void set_DoLanguageMode(PSLanguageMode value);
    protected abstract virtual PSModuleInfo get_DoModule();
    protected abstract virtual PathIntrinsics get_DoPath();
    protected abstract virtual CmdletProviderManagementIntrinsics get_DoProvider();
    protected abstract virtual PSVariableIntrinsics get_DoPSVariable();
    protected abstract virtual CommandInvocationIntrinsics get_DoInvokeCommand();
    protected abstract virtual ProviderIntrinsics get_DoInvokeProvider();
    internal virtual SessionStateProxy GetSessionStateProxy();
}
public enum System.Management.Automation.Runspaces.RunspaceCapability : Enum {
    public int value__;
    public static RunspaceCapability Default;
    public static RunspaceCapability SupportsDisconnect;
    public static RunspaceCapability NamedPipeTransport;
    public static RunspaceCapability VMSocketTransport;
    public static RunspaceCapability SSHTransport;
    public static RunspaceCapability CustomTransport;
}
public abstract class System.Management.Automation.Runspaces.RunspaceConnectionInfo : object {
    private CultureInfo _culture;
    private CultureInfo _uiCulture;
    private int _openTimeout;
    internal static int DefaultOpenTimeout;
    internal static int DefaultTimeout;
    internal static int InfiniteTimeout;
    [CompilerGeneratedAttribute]
private int <CancelTimeout>k__BackingField;
    internal static int defaultCancelTimeout;
    [CompilerGeneratedAttribute]
private int <OperationTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private int <IdleTimeout>k__BackingField;
    internal static int DefaultIdleTimeout;
    [CompilerGeneratedAttribute]
private int <MaxIdleTimeout>k__BackingField;
    protected static int MaxPort;
    protected static int MinPort;
    public string ComputerName { get; public set; }
    public PSCredential Credential { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public CultureInfo Culture { get; public set; }
    public CultureInfo UICulture { get; public set; }
    public int OpenTimeout { get; public set; }
    public int CancelTimeout { get; public set; }
    public int OperationTimeout { get; public set; }
    public int IdleTimeout { get; public set; }
    public int MaxIdleTimeout { get; internal set; }
    public abstract virtual string get_ComputerName();
    public abstract virtual void set_ComputerName(string value);
    public abstract virtual PSCredential get_Credential();
    public abstract virtual void set_Credential(PSCredential value);
    public abstract virtual AuthenticationMechanism get_AuthenticationMechanism();
    public abstract virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public abstract virtual string get_CertificateThumbprint();
    public abstract virtual void set_CertificateThumbprint(string value);
    public CultureInfo get_Culture();
    public void set_Culture(CultureInfo value);
    public CultureInfo get_UICulture();
    public void set_UICulture(CultureInfo value);
    public int get_OpenTimeout();
    public void set_OpenTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_CancelTimeout();
    [CompilerGeneratedAttribute]
public void set_CancelTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_OperationTimeout();
    [CompilerGeneratedAttribute]
public void set_OperationTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_IdleTimeout();
    [CompilerGeneratedAttribute]
public void set_IdleTimeout(int value);
    [CompilerGeneratedAttribute]
public int get_MaxIdleTimeout();
    [CompilerGeneratedAttribute]
internal void set_MaxIdleTimeout(int value);
    public virtual void SetSessionOptions(PSSessionOption options);
    internal int TimeSpanToTimeOutMs(TimeSpan t);
    internal virtual void ValidatePortInRange(int port);
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
    public virtual RunspaceConnectionInfo Clone();
}
internal class System.Management.Automation.Runspaces.RunspaceCreatedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    internal Runspace Runspace { get; }
    internal RunspaceCreatedEventArgs(Runspace runspace);
    [CompilerGeneratedAttribute]
internal Runspace get_Runspace();
}
[EventSourceAttribute]
internal class System.Management.Automation.Runspaces.RunspaceEventSource : EventSource {
    internal static RunspaceEventSource Log;
    private static RunspaceEventSource();
    public void OpenRunspaceStart();
    public void OpenRunspaceStop();
    public void LoadAssembliesStart();
    public void LoadAssembliesStop();
    public void UpdateFormatTableStart();
    public void UpdateFormatTableStop();
    public void UpdateTypeTableStart();
    public void UpdateTypeTableStop();
    public void LoadProvidersStart();
    public void LoadProvidersStop();
    public void LoadCommandsStart();
    public void LoadCommandsStop();
    public void LoadVariablesStart();
    public void LoadVariablesStop();
    public void LoadEnvironmentVariablesStart();
    public void LoadEnvironmentVariablesStop();
    public void LoadAssemblyStart(string Name, string FileName);
    public void LoadAssemblyStop(string Name, string FileName);
    public void ProcessFormatFileStart(string FileName);
    public void ProcessFormatFileStop(string FileName);
    public void ProcessTypeFileStart(string FileName);
    public void ProcessTypeFileStop(string FileName);
    public void LoadProviderStart(string Name);
    public void LoadProviderStop(string Name);
    public void LoadCommandStart(string Name);
    public void LoadCommandStop(string Name);
}
public static class System.Management.Automation.Runspaces.RunspaceFactory : object {
    private static RunspaceFactory();
    public static Runspace CreateRunspace();
    public static Runspace CreateRunspace(PSHost host);
    public static Runspace CreateRunspace(InitialSessionState initialSessionState);
    public static Runspace CreateRunspace(PSHost host, InitialSessionState initialSessionState);
    internal static Runspace CreateRunspaceFromSessionStateNoClone(PSHost host, InitialSessionState initialSessionState);
    public static RunspacePool CreateRunspacePool();
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces);
    public static RunspacePool CreateRunspacePool(InitialSessionState initialSessionState);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, PSHost host);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, InitialSessionState initialSessionState, PSHost host);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, RunspaceConnectionInfo connectionInfo);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, RunspaceConnectionInfo connectionInfo, PSHost host);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    public static RunspacePool CreateRunspacePool(int minRunspaces, int maxRunspaces, RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable, PSPrimitiveDictionary applicationArguments);
    public static Runspace CreateRunspace(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    public static Runspace CreateRunspace(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable, PSPrimitiveDictionary applicationArguments);
    public static Runspace CreateRunspace(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable, PSPrimitiveDictionary applicationArguments, string name);
    public static Runspace CreateRunspace(PSHost host, RunspaceConnectionInfo connectionInfo);
    public static Runspace CreateRunspace(RunspaceConnectionInfo connectionInfo);
    public static Runspace CreateOutOfProcessRunspace(TypeTable typeTable);
    public static Runspace CreateOutOfProcessRunspace(TypeTable typeTable, PowerShellProcessInstance processInstance);
}
public class System.Management.Automation.Runspaces.RunspaceOpenModuleLoadException : RuntimeException {
    private PSDataCollection`1<ErrorRecord> _errors;
    public PSDataCollection`1<ErrorRecord> ErrorRecords { get; }
    public RunspaceOpenModuleLoadException(string message);
    public RunspaceOpenModuleLoadException(string message, Exception innerException);
    internal RunspaceOpenModuleLoadException(string moduleName, PSDataCollection`1<ErrorRecord> errors);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected RunspaceOpenModuleLoadException(SerializationInfo info, StreamingContext context);
    public PSDataCollection`1<ErrorRecord> get_ErrorRecords();
}
public class System.Management.Automation.Runspaces.RunspacePool : object {
    private RunspacePoolInternal _internalPool;
    private object _syncObject;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspacePoolStateChangedEventArgs> InternalStateChanged;
    [CompilerGeneratedAttribute]
private EventHandler`1<PSEventArgs> InternalForwardEvent;
    [CompilerGeneratedAttribute]
private EventHandler`1<RunspaceCreatedEventArgs> InternalRunspaceCreated;
    [CompilerGeneratedAttribute]
private bool <IsRemote>k__BackingField;
    public Guid InstanceId { get; }
    public bool IsDisposed { get; }
    public RunspacePoolStateInfo RunspacePoolStateInfo { get; }
    public InitialSessionState InitialSessionState { get; }
    public RunspaceConnectionInfo ConnectionInfo { get; }
    public TimeSpan CleanupInterval { get; public set; }
    public RunspacePoolAvailability RunspacePoolAvailability { get; }
    public PSThreadOptions ThreadOptions { get; public set; }
    public ApartmentState ApartmentState { get; public set; }
    internal bool IsRemote { get; }
    internal RemoteRunspacePoolInternal RemoteRunspacePoolInternal { get; }
    internal RunspacePool(int minRunspaces, int maxRunspaces, PSHost host);
    internal RunspacePool(int minRunspaces, int maxRunspaces, InitialSessionState initialSessionState, PSHost host);
    internal RunspacePool(int minRunspaces, int maxRunspaces, TypeTable typeTable, PSHost host, PSPrimitiveDictionary applicationArguments, RunspaceConnectionInfo connectionInfo, string name);
    internal RunspacePool(bool isDisconnected, Guid instanceId, string name, ConnectCommandInfo[] connectCommands, RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    [CompilerGeneratedAttribute]
private void add_InternalStateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_InternalStateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_InternalForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_InternalForwardEvent(EventHandler`1<PSEventArgs> value);
    [CompilerGeneratedAttribute]
private void add_InternalRunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    [CompilerGeneratedAttribute]
private void remove_InternalRunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    public Guid get_InstanceId();
    public bool get_IsDisposed();
    public RunspacePoolStateInfo get_RunspacePoolStateInfo();
    public InitialSessionState get_InitialSessionState();
    public RunspaceConnectionInfo get_ConnectionInfo();
    public TimeSpan get_CleanupInterval();
    public void set_CleanupInterval(TimeSpan value);
    public RunspacePoolAvailability get_RunspacePoolAvailability();
    public void add_StateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    public void remove_StateChanged(EventHandler`1<RunspacePoolStateChangedEventArgs> value);
    private void OnStateChanged(object source, RunspacePoolStateChangedEventArgs args);
    internal void add_ForwardEvent(EventHandler`1<PSEventArgs> value);
    internal void remove_ForwardEvent(EventHandler`1<PSEventArgs> value);
    private void OnInternalPoolForwardEvent(object sender, PSEventArgs e);
    private void OnEventForwarded(PSEventArgs e);
    internal void add_RunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    internal void remove_RunspaceCreated(EventHandler`1<RunspaceCreatedEventArgs> value);
    private void OnRunspaceCreated(object source, RunspaceCreatedEventArgs args);
    public static RunspacePool[] GetRunspacePools(RunspaceConnectionInfo connectionInfo);
    public static RunspacePool[] GetRunspacePools(RunspaceConnectionInfo connectionInfo, PSHost host);
    public static RunspacePool[] GetRunspacePools(RunspaceConnectionInfo connectionInfo, PSHost host, TypeTable typeTable);
    public void Disconnect();
    public IAsyncResult BeginDisconnect(AsyncCallback callback, object state);
    public void EndDisconnect(IAsyncResult asyncResult);
    public void Connect();
    public IAsyncResult BeginConnect(AsyncCallback callback, object state);
    public void EndConnect(IAsyncResult asyncResult);
    public Collection`1<PowerShell> CreateDisconnectedPowerShells();
    public RunspacePoolCapability GetCapabilities();
    public bool SetMaxRunspaces(int maxRunspaces);
    public int GetMaxRunspaces();
    public bool SetMinRunspaces(int minRunspaces);
    public int GetMinRunspaces();
    public int GetAvailableRunspaces();
    public void Open();
    public IAsyncResult BeginOpen(AsyncCallback callback, object state);
    public void EndOpen(IAsyncResult asyncResult);
    public void Close();
    public IAsyncResult BeginClose(AsyncCallback callback, object state);
    public void EndClose(IAsyncResult asyncResult);
    public sealed virtual void Dispose();
    public PSPrimitiveDictionary GetApplicationPrivateData();
    public PSThreadOptions get_ThreadOptions();
    public void set_ThreadOptions(PSThreadOptions value);
    public ApartmentState get_ApartmentState();
    public void set_ApartmentState(ApartmentState value);
    internal IAsyncResult BeginGetRunspace(AsyncCallback callback, object state);
    internal void CancelGetRunspace(IAsyncResult asyncResult);
    internal Runspace EndGetRunspace(IAsyncResult asyncResult);
    internal void ReleaseRunspace(Runspace runspace);
    [CompilerGeneratedAttribute]
internal bool get_IsRemote();
    internal RemoteRunspacePoolInternal get_RemoteRunspacePoolInternal();
    internal void AssertPoolIsOpen();
}
internal class System.Management.Automation.Runspaces.RunspacePoolAsyncResult : AsyncResult {
    [CompilerGeneratedAttribute]
private bool <IsAssociatedWithAsyncOpen>k__BackingField;
    internal bool IsAssociatedWithAsyncOpen { get; }
    internal RunspacePoolAsyncResult(Guid ownerId, AsyncCallback callback, object state, bool isCalledFromOpenAsync);
    [CompilerGeneratedAttribute]
internal bool get_IsAssociatedWithAsyncOpen();
}
public enum System.Management.Automation.Runspaces.RunspacePoolAvailability : Enum {
    public int value__;
    public static RunspacePoolAvailability None;
    public static RunspacePoolAvailability Available;
    public static RunspacePoolAvailability Busy;
}
public enum System.Management.Automation.Runspaces.RunspacePoolCapability : Enum {
    public int value__;
    public static RunspacePoolCapability Default;
    public static RunspacePoolCapability SupportsDisconnect;
}
public enum System.Management.Automation.Runspaces.RunspacePoolState : Enum {
    public int value__;
    public static RunspacePoolState BeforeOpen;
    public static RunspacePoolState Opening;
    public static RunspacePoolState Opened;
    public static RunspacePoolState Closed;
    public static RunspacePoolState Closing;
    public static RunspacePoolState Broken;
    public static RunspacePoolState Disconnecting;
    public static RunspacePoolState Disconnected;
    public static RunspacePoolState Connecting;
}
public class System.Management.Automation.Runspaces.RunspacePoolStateChangedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RunspacePoolStateInfo <RunspacePoolStateInfo>k__BackingField;
    public RunspacePoolStateInfo RunspacePoolStateInfo { get; }
    internal RunspacePoolStateChangedEventArgs(RunspacePoolState state);
    internal RunspacePoolStateChangedEventArgs(RunspacePoolStateInfo stateInfo);
    [CompilerGeneratedAttribute]
public RunspacePoolStateInfo get_RunspacePoolStateInfo();
}
public enum System.Management.Automation.Runspaces.RunspaceState : Enum {
    public int value__;
    public static RunspaceState BeforeOpen;
    public static RunspaceState Opening;
    public static RunspaceState Opened;
    public static RunspaceState Closed;
    public static RunspaceState Closing;
    public static RunspaceState Broken;
    public static RunspaceState Disconnecting;
    public static RunspaceState Disconnected;
    public static RunspaceState Connecting;
}
public class System.Management.Automation.Runspaces.RunspaceStateEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private RunspaceStateInfo <RunspaceStateInfo>k__BackingField;
    public RunspaceStateInfo RunspaceStateInfo { get; }
    internal RunspaceStateEventArgs(RunspaceStateInfo runspaceStateInfo);
    [CompilerGeneratedAttribute]
public RunspaceStateInfo get_RunspaceStateInfo();
}
public class System.Management.Automation.Runspaces.RunspaceStateInfo : object {
    [CompilerGeneratedAttribute]
private RunspaceState <State>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Reason>k__BackingField;
    public RunspaceState State { get; }
    public Exception Reason { get; }
    internal RunspaceStateInfo(RunspaceState state);
    internal RunspaceStateInfo(RunspaceState state, Exception reason);
    internal RunspaceStateInfo(RunspaceStateInfo runspaceStateInfo);
    [CompilerGeneratedAttribute]
public RunspaceState get_State();
    [CompilerGeneratedAttribute]
public Exception get_Reason();
    public virtual string ToString();
    internal RunspaceStateInfo Clone();
}
[DebuggerDisplayAttribute("ScriptMethod: {Name,nq}")]
public class System.Management.Automation.Runspaces.ScriptMethodData : TypeMemberData {
    [CompilerGeneratedAttribute]
private ScriptBlock <Script>k__BackingField;
    public ScriptBlock Script { get; public set; }
    public ScriptMethodData(string name, ScriptBlock scriptToInvoke);
    [CompilerGeneratedAttribute]
public ScriptBlock get_Script();
    [CompilerGeneratedAttribute]
public void set_Script(ScriptBlock value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
[DebuggerDisplayAttribute("ScriptProperty: {Name,nq}")]
public class System.Management.Automation.Runspaces.ScriptPropertyData : TypeMemberData {
    [CompilerGeneratedAttribute]
private ScriptBlock <GetScriptBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <SetScriptBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsHidden>k__BackingField;
    public ScriptBlock GetScriptBlock { get; public set; }
    public ScriptBlock SetScriptBlock { get; public set; }
    public bool IsHidden { get; public set; }
    public ScriptPropertyData(string name, ScriptBlock getScriptBlock);
    public ScriptPropertyData(string name, ScriptBlock getScriptBlock, ScriptBlock setScriptBlock);
    [CompilerGeneratedAttribute]
public ScriptBlock get_GetScriptBlock();
    [CompilerGeneratedAttribute]
public void set_GetScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
public ScriptBlock get_SetScriptBlock();
    [CompilerGeneratedAttribute]
public void set_SetScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
public bool get_IsHidden();
    [CompilerGeneratedAttribute]
public void set_IsHidden(bool value);
    internal virtual TypeMemberData Copy();
    internal virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
public class System.Management.Automation.Runspaces.SessionStateAliasEntry : SessionStateCommandEntry {
    [CompilerGeneratedAttribute]
private string <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedItemOptions <Options>k__BackingField;
    public string Definition { get; }
    public string Description { get; }
    public ScopedItemOptions Options { get; }
    public SessionStateAliasEntry(string name, string definition);
    public SessionStateAliasEntry(string name, string definition, string description);
    public SessionStateAliasEntry(string name, string definition, string description, ScopedItemOptions options);
    internal SessionStateAliasEntry(string name, string definition, string description, ScopedItemOptions options, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_Definition();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public ScopedItemOptions get_Options();
}
public class System.Management.Automation.Runspaces.SessionStateApplicationEntry : SessionStateCommandEntry {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    public SessionStateApplicationEntry(string path);
    internal SessionStateApplicationEntry(string path, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_Path();
}
public class System.Management.Automation.Runspaces.SessionStateAssemblyEntry : InitialSessionStateEntry {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    public string FileName { get; }
    public SessionStateAssemblyEntry(string name, string fileName);
    public SessionStateAssemblyEntry(string name);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_FileName();
}
public class System.Management.Automation.Runspaces.SessionStateCmdletEntry : SessionStateCommandEntry {
    [CompilerGeneratedAttribute]
private Type <ImplementingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFileName>k__BackingField;
    public Type ImplementingType { get; }
    public string HelpFileName { get; }
    public SessionStateCmdletEntry(string name, Type implementingType, string helpFileName);
    internal SessionStateCmdletEntry(string name, Type implementingType, string helpFileName, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public Type get_ImplementingType();
    [CompilerGeneratedAttribute]
public string get_HelpFileName();
}
public abstract class System.Management.Automation.Runspaces.SessionStateCommandEntry : ConstrainedSessionStateEntry {
    [CompilerGeneratedAttribute]
private CommandTypes <CommandType>k__BackingField;
    internal bool _isImported;
    public CommandTypes CommandType { get; internal set; }
    protected SessionStateCommandEntry(string name);
    protected internal SessionStateCommandEntry(string name, SessionStateEntryVisibility visibility);
    [CompilerGeneratedAttribute]
public CommandTypes get_CommandType();
    [CompilerGeneratedAttribute]
internal void set_CommandType(CommandTypes value);
}
public class System.Management.Automation.Runspaces.SessionStateFormatEntry : InitialSessionStateEntry {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private FormatTable <Formattable>k__BackingField;
    [CompilerGeneratedAttribute]
private ExtendedTypeDefinition <FormatData>k__BackingField;
    public string FileName { get; }
    public FormatTable Formattable { get; }
    public ExtendedTypeDefinition FormatData { get; }
    public SessionStateFormatEntry(string fileName);
    public SessionStateFormatEntry(FormatTable formattable);
    public SessionStateFormatEntry(ExtendedTypeDefinition typeDefinition);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public FormatTable get_Formattable();
    [CompilerGeneratedAttribute]
public ExtendedTypeDefinition get_FormatData();
}
public class System.Management.Automation.Runspaces.SessionStateFunctionEntry : SessionStateCommandEntry {
    [CompilerGeneratedAttribute]
private string <Definition>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedItemOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFile>k__BackingField;
    public string Definition { get; }
    internal ScriptBlock ScriptBlock { get; internal set; }
    public ScopedItemOptions Options { get; }
    public string HelpFile { get; private set; }
    public SessionStateFunctionEntry(string name, string definition, ScopedItemOptions options, string helpFile);
    public SessionStateFunctionEntry(string name, string definition, string helpFile);
    public SessionStateFunctionEntry(string name, string definition);
    internal SessionStateFunctionEntry(string name, string definition, ScopedItemOptions options, SessionStateEntryVisibility visibility, ScriptBlock scriptBlock, string helpFile);
    internal static SessionStateFunctionEntry GetDelayParsedFunctionEntry(string name, string definition, bool isProductCode, PSLanguageMode languageMode);
    internal static SessionStateFunctionEntry GetDelayParsedFunctionEntry(string name, string definition, bool isProductCode);
    internal static SessionStateFunctionEntry GetDelayParsedFunctionEntry(string name, string definition, ScriptBlock sb);
    public virtual InitialSessionStateEntry Clone();
    internal void SetHelpFile(string help);
    [CompilerGeneratedAttribute]
public string get_Definition();
    [CompilerGeneratedAttribute]
internal ScriptBlock get_ScriptBlock();
    [CompilerGeneratedAttribute]
internal void set_ScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
public ScopedItemOptions get_Options();
    [CompilerGeneratedAttribute]
public string get_HelpFile();
    [CompilerGeneratedAttribute]
private void set_HelpFile(string value);
}
public class System.Management.Automation.Runspaces.SessionStateProviderEntry : ConstrainedSessionStateEntry {
    [CompilerGeneratedAttribute]
private Type <ImplementingType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HelpFileName>k__BackingField;
    public Type ImplementingType { get; }
    public string HelpFileName { get; }
    public SessionStateProviderEntry(string name, Type implementingType, string helpFileName);
    internal SessionStateProviderEntry(string name, Type implementingType, string helpFileName, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public Type get_ImplementingType();
    [CompilerGeneratedAttribute]
public string get_HelpFileName();
}
public class System.Management.Automation.Runspaces.SessionStateProxy : object {
    private RunspaceBase _runspace;
    public List`1<string> Applications { get; }
    public List`1<string> Scripts { get; }
    public DriveManagementIntrinsics Drive { get; }
    public PSLanguageMode LanguageMode { get; public set; }
    public PSModuleInfo Module { get; }
    public PathIntrinsics Path { get; }
    public CmdletProviderManagementIntrinsics Provider { get; }
    public PSVariableIntrinsics PSVariable { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    internal SessionStateProxy(RunspaceBase runspace);
    public virtual void SetVariable(string name, object value);
    public virtual object GetVariable(string name);
    public virtual List`1<string> get_Applications();
    public virtual List`1<string> get_Scripts();
    public virtual DriveManagementIntrinsics get_Drive();
    public virtual PSLanguageMode get_LanguageMode();
    public virtual void set_LanguageMode(PSLanguageMode value);
    public virtual PSModuleInfo get_Module();
    public virtual PathIntrinsics get_Path();
    public virtual CmdletProviderManagementIntrinsics get_Provider();
    public virtual PSVariableIntrinsics get_PSVariable();
    public virtual CommandInvocationIntrinsics get_InvokeCommand();
    public virtual ProviderIntrinsics get_InvokeProvider();
}
public class System.Management.Automation.Runspaces.SessionStateScriptEntry : SessionStateCommandEntry {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    public string Path { get; }
    public SessionStateScriptEntry(string path);
    internal SessionStateScriptEntry(string path, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_Path();
}
public class System.Management.Automation.Runspaces.SessionStateTypeEntry : InitialSessionStateEntry {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeTable <TypeTable>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeData <TypeData>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRemove>k__BackingField;
    public string FileName { get; }
    public TypeTable TypeTable { get; }
    public TypeData TypeData { get; }
    public bool IsRemove { get; }
    public SessionStateTypeEntry(string fileName);
    public SessionStateTypeEntry(TypeTable typeTable);
    public SessionStateTypeEntry(TypeData typeData, bool isRemove);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public TypeTable get_TypeTable();
    [CompilerGeneratedAttribute]
public TypeData get_TypeData();
    [CompilerGeneratedAttribute]
public bool get_IsRemove();
}
public class System.Management.Automation.Runspaces.SessionStateVariableEntry : ConstrainedSessionStateEntry {
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private ScopedItemOptions <Options>k__BackingField;
    private Collection`1<Attribute> _attributes;
    public object Value { get; }
    public string Description { get; }
    public ScopedItemOptions Options { get; }
    public Collection`1<Attribute> Attributes { get; }
    public SessionStateVariableEntry(string name, object value, string description);
    public SessionStateVariableEntry(string name, object value, string description, ScopedItemOptions options);
    public SessionStateVariableEntry(string name, object value, string description, ScopedItemOptions options, Collection`1<Attribute> attributes);
    public SessionStateVariableEntry(string name, object value, string description, ScopedItemOptions options, Attribute attribute);
    internal SessionStateVariableEntry(string name, object value, string description, ScopedItemOptions options, Collection`1<Attribute> attributes, SessionStateEntryVisibility visibility);
    public virtual InitialSessionStateEntry Clone();
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public ScopedItemOptions get_Options();
    public Collection`1<Attribute> get_Attributes();
}
public class System.Management.Automation.Runspaces.SSHConnectionInfo : RunspaceConnectionInfo {
    private static string DefaultSubsystem;
    private static int DefaultConnectingTimeoutTime;
    [CompilerGeneratedAttribute]
private string <UserName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Port>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subsystem>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ConnectingTimeout>k__BackingField;
    [CompilerGeneratedAttribute]
private Hashtable <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    private static int CREATE_NEW_PROCESS_GROUP;
    private static int CREATE_SUSPENDED;
    public string UserName { get; private set; }
    public string KeyFilePath { get; public set; }
    public int Port { get; public set; }
    public string Subsystem { get; public set; }
    public int ConnectingTimeout { get; public set; }
    private Hashtable Options { get; private set; }
    public string ComputerName { get; public set; }
    public PSCredential Credential { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public SSHConnectionInfo(string userName, string computerName, string keyFilePath);
    public SSHConnectionInfo(string userName, string computerName, string keyFilePath, int port);
    public SSHConnectionInfo(string userName, string computerName, string keyFilePath, int port, string subsystem);
    public SSHConnectionInfo(string userName, string computerName, string keyFilePath, int port, string subsystem, int connectingTimeout);
    public SSHConnectionInfo(string userName, string computerName, string keyFilePath, int port, string subsystem, int connectingTimeout, Hashtable options);
    [CompilerGeneratedAttribute]
public string get_UserName();
    [CompilerGeneratedAttribute]
private void set_UserName(string value);
    [CompilerGeneratedAttribute]
public string get_KeyFilePath();
    [CompilerGeneratedAttribute]
public void set_KeyFilePath(string value);
    [CompilerGeneratedAttribute]
public int get_Port();
    [CompilerGeneratedAttribute]
public void set_Port(int value);
    [CompilerGeneratedAttribute]
public string get_Subsystem();
    [CompilerGeneratedAttribute]
public void set_Subsystem(string value);
    [CompilerGeneratedAttribute]
public int get_ConnectingTimeout();
    [CompilerGeneratedAttribute]
public void set_ConnectingTimeout(int value);
    [CompilerGeneratedAttribute]
private Hashtable get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(Hashtable value);
    [CompilerGeneratedAttribute]
public virtual string get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public virtual RunspaceConnectionInfo Clone();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
    internal int StartSSHProcess(StreamWriter& stdInWriterVar, StreamReader& stdOutReaderVar, StreamReader& stdErrReaderVar);
    internal void KillSSHProcess(int pid);
    private static int StartSSHProcessImpl(ProcessStartInfo startInfo, StreamWriter& stdInWriterVar, StreamReader& stdOutReaderVar, StreamReader& stdErrReaderVar);
    private static void KillSSHProcessImpl(int pid);
    private static Process CreateProcessWithRedirectedStd(ProcessStartInfo startInfo, SafePipeHandle& stdInPipeServer, SafePipeHandle& stdOutPipeServer, SafePipeHandle& stdErrPipeServer);
    private static SafeFileHandle GetNamedPipeHandle(string pipeName);
    private static SafePipeHandle CreateNamedPipe(string pipeName, CommonSecurityDescriptor securityDesc);
}
internal class System.Management.Automation.Runspaces.StopJobOperationHelper : IThrottleOperation {
    private Job _job;
    [CompilerGeneratedAttribute]
private EventHandler`1<OperationStateEventArgs> OperationComplete;
    internal StopJobOperationHelper(Job job);
    private void HandleJobStateChanged(object sender, JobStateEventArgs eventArgs);
    internal virtual void StartOperation();
    internal virtual void StopOperation();
    [CompilerGeneratedAttribute]
internal virtual void add_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    [CompilerGeneratedAttribute]
internal virtual void remove_OperationComplete(EventHandler`1<OperationStateEventArgs> value);
    private void RaiseOperationCompleteEvent();
}
public enum System.Management.Automation.Runspaces.TargetMachineType : Enum {
    public int value__;
    public static TargetMachineType RemoteMachine;
    public static TargetMachineType VirtualMachine;
    public static TargetMachineType Container;
}
public class System.Management.Automation.Runspaces.TypeData : object {
    internal static string NoteProperty;
    internal static string AliasProperty;
    internal static string ScriptProperty;
    internal static string CodeProperty;
    internal static string ScriptMethod;
    internal static string CodeMethod;
    internal static string PropertySet;
    internal static string MemberSet;
    [CompilerGeneratedAttribute]
private bool <fromTypesXmlFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TypeMemberData> <Members>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeConverter>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <TypeAdapter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, TypeMemberData> <StandardMembers>k__BackingField;
    private string _serializationMethod;
    private Type _targetTypeForDeserialization;
    private UInt32 _serializationDepth;
    private string _defaultDisplayProperty;
    private bool _inheritPropertySerializationSet;
    private string _stringSerializationSource;
    private TypeMemberData _stringSerializationSourceProperty;
    private PropertySetData _defaultDisplayPropertySet;
    private PropertySetData _defaultKeyPropertySet;
    private PropertySetData _propertySerializationSet;
    internal bool fromTypesXmlFile { get; }
    public string TypeName { get; }
    public Dictionary`2<string, TypeMemberData> Members { get; }
    public Type TypeConverter { get; public set; }
    public Type TypeAdapter { get; public set; }
    public bool IsOverride { get; public set; }
    internal Dictionary`2<string, TypeMemberData> StandardMembers { get; }
    public string SerializationMethod { get; public set; }
    public Type TargetTypeForDeserialization { get; public set; }
    public UInt32 SerializationDepth { get; public set; }
    public string DefaultDisplayProperty { get; public set; }
    public bool InheritPropertySerializationSet { get; public set; }
    public string StringSerializationSource { get; public set; }
    public TypeMemberData StringSerializationSourceProperty { get; public set; }
    public PropertySetData DefaultDisplayPropertySet { get; public set; }
    public PropertySetData DefaultKeyPropertySet { get; public set; }
    public PropertySetData PropertySerializationSet { get; public set; }
    public TypeData(string typeName);
    internal TypeData(string typeName, bool typesXml);
    public TypeData(Type type);
    [CompilerGeneratedAttribute]
internal bool get_fromTypesXmlFile();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, TypeMemberData> get_Members();
    [CompilerGeneratedAttribute]
public Type get_TypeConverter();
    [CompilerGeneratedAttribute]
public void set_TypeConverter(Type value);
    [CompilerGeneratedAttribute]
public Type get_TypeAdapter();
    [CompilerGeneratedAttribute]
public void set_TypeAdapter(Type value);
    [CompilerGeneratedAttribute]
public bool get_IsOverride();
    [CompilerGeneratedAttribute]
public void set_IsOverride(bool value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, TypeMemberData> get_StandardMembers();
    public string get_SerializationMethod();
    public void set_SerializationMethod(string value);
    public Type get_TargetTypeForDeserialization();
    public void set_TargetTypeForDeserialization(Type value);
    public UInt32 get_SerializationDepth();
    public void set_SerializationDepth(UInt32 value);
    public string get_DefaultDisplayProperty();
    public void set_DefaultDisplayProperty(string value);
    public bool get_InheritPropertySerializationSet();
    public void set_InheritPropertySerializationSet(bool value);
    public string get_StringSerializationSource();
    public void set_StringSerializationSource(string value);
    public TypeMemberData get_StringSerializationSourceProperty();
    public void set_StringSerializationSourceProperty(TypeMemberData value);
    public PropertySetData get_DefaultDisplayPropertySet();
    public void set_DefaultDisplayPropertySet(PropertySetData value);
    public PropertySetData get_DefaultKeyPropertySet();
    public void set_DefaultKeyPropertySet(PropertySetData value);
    public PropertySetData get_PropertySerializationSet();
    public void set_PropertySerializationSet(PropertySetData value);
    public TypeData Copy();
}
public abstract class System.Management.Automation.Runspaces.TypeMemberData : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public string Name { get; protected set; }
    internal TypeMemberData(string name);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
protected void set_Name(string value);
    internal abstract virtual TypeMemberData Copy();
    internal abstract virtual void Process(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
}
internal class System.Management.Automation.Runspaces.TypesPs1xmlReader : object {
    private LoadContext _context;
    private XmlReader _reader;
    private IXmlLineInfo _readerLineInfo;
    private string _idTypeName;
    private string _idSetCodeReference;
    private string _idScriptMethod;
    private string _idValue;
    private string _idScriptProperty;
    private string _idIsHidden;
    private string _idScript;
    private string _idCodeMethod;
    private string _idMemberSet;
    private string _idCodeProperty;
    private string _idMembers;
    private string _idName;
    private string _idGetCodeReference;
    private string _idMethodName;
    private string _idInheritMembers;
    private string _idNoteProperty;
    private string _idTypeAdapter;
    private string _idSetScriptBlock;
    private string _idPropertySet;
    private string _idTypeConverter;
    private string _idAliasProperty;
    private string _idType;
    private string _idCodeReference;
    private string _idTypes;
    private string _idReferencedProperties;
    private string _idGetScriptBlock;
    private string _idReferencedMemberName;
    public TypesPs1xmlReader(LoadContext context);
    private string ReadElementString(string nodeName);
    private Nullable`1<bool> ReadIsHiddenAttribute();
    private void ReadIsHiddenAttributeNotSupported(string node);
    private void ReadEndElement();
    private void UnknownNode(string node, string expectedNodes);
    private void SkipUntilNodeEnd(string nodeName);
    private void NotMoreThanOnce(string node, string parent);
    private void NodeNotFound(int lineNumber, string node, string parent);
    private ScriptBlock GetScriptBlock(string text, int initialLine);
    private Type ResolveType(string typeName, int line);
    private bool ToBoolean(string value);
    private T Converter(object value, string name);
    private bool BoolConverter(object value, string name);
    private void CheckStandardNote(TypeMemberData member, TypeData typeData, Action`2<TypeData, T> setter, Func`3<object, string, T> converter);
    private static bool CheckStandardPropertySet(TypeMemberData member, TypeData typeData, Action`2<TypeData, PropertySetData> setter);
    public IEnumerable`1<TypeData> Read();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.TypesPs1xmlReader/<Read_Types>d__20")]
private IEnumerable`1<TypeData> Read_Types();
    private TypeData Read_Type();
    private Type Read_TypeX(string elementName);
    private Collection`1<TypeMemberData> Read_Members(MemberSetData& standardMembers);
    private MemberSetData Read_MemberSet();
    private PropertySetData Read_PropertySet();
    private CodeMethodData Read_CodeMethod();
    private MethodInfo Read_CodeReference();
    private ScriptMethodData Read_ScriptMethod();
    private CodePropertyData Read_CodeProperty();
    private ScriptPropertyData Read_ScriptProperty();
    private AliasPropertyData Read_AliasProperty();
    private NotePropertyData Read_NoteProperty();
    protected void InitIDs();
}
public class System.Management.Automation.Runspaces.TypeTable : object {
    internal static string PSStandardMembers;
    internal static string SerializationDepth;
    internal static string StringSerializationSource;
    internal static string SerializationMethodNode;
    internal static string TargetTypeForDeserialization;
    internal static string PropertySerializationSet;
    internal static string InheritPropertySerializationSet;
    internal static string Types;
    internal static string Type;
    internal static string DefaultDisplayPropertySet;
    internal static string DefaultKeyPropertySet;
    internal static string DefaultDisplayProperty;
    internal static string IsHiddenAttribute;
    private ConcurrentDictionary`2<string, PSMemberInfoInternalCollection`1<PSMemberInfo>> _consolidatedMembers;
    private ConcurrentDictionary`2<string, Collection`1<string>> _consolidatedSpecificProperties;
    private ConcurrentDictionary`2<string, PSMemberInfoInternalCollection`1<PSMemberInfo>> _extendedMembers;
    private ConcurrentDictionary`2<string, object> _typeConverters;
    private ConcurrentDictionary`2<string, AdapterSet> _typeAdapters;
    internal bool isShared;
    private List`1<string> _typeFileList;
    private Func`3<string, ConsolidatedString, PSMemberInfoInternalCollection`1<PSMemberInfo>> _memberFactoryFunc;
    internal InitialSessionStateEntryCollection`1<SessionStateTypeEntry> typesInfo;
    internal static SerializationMethod DefaultSerializationMethod;
    internal static bool DefaultInheritPropertySerializationSet;
    private static String[] s_standardMembers;
    internal static string TypesFilePath;
    internal static string TypesV3FilePath;
    internal static string GetEventTypesFilePath;
    private static int ValueFactoryCacheCount;
    private static Func`2[] s_valueFactoryCache;
    private static TypeTable();
    internal TypeTable(bool isShared);
    public TypeTable(IEnumerable`1<string> typeFiles);
    internal TypeTable(IEnumerable`1<string> typeFiles, AuthorizationManager authorizationManager, PSHost host);
    private static void AddMember(ConcurrentBag`1<string> errors, string typeName, PSMemberInfo member, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    private static bool GetCheckNote(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> members, string noteName, Type noteType, PSNoteProperty& note);
    private static bool EnsureNotPresent(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> members, string memberName);
    private static bool GetCheckMemberType(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> members, string noteName, Type memberType, PSMemberInfo& member);
    private static bool CheckStandardMembers(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> members);
    private static bool CreateInstance(ConcurrentBag`1<string> errors, string typeName, Type type, string errorFormatString, Object& instance);
    private static void AddError(ConcurrentBag`1<string> errors, string typeName, string resourceString, Object[] formatArguments);
    private static void ProcessMembersData(ConcurrentBag`1<string> errors, string typeName, Dictionary`2<string, TypeMemberData> membersData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessNoteData(ConcurrentBag`1<string> errors, string typeName, NotePropertyData nodeData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessAliasData(ConcurrentBag`1<string> errors, string typeName, AliasPropertyData aliasData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessScriptPropertyData(ConcurrentBag`1<string> errors, string typeName, ScriptPropertyData scriptPropertyData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessCodePropertyData(ConcurrentBag`1<string> errors, string typeName, CodePropertyData codePropertyData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessScriptMethodData(ConcurrentBag`1<string> errors, string typeName, ScriptMethodData scriptMethodData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessCodeMethodData(ConcurrentBag`1<string> errors, string typeName, CodeMethodData codeMethodData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessPropertySetData(ConcurrentBag`1<string> errors, string typeName, PropertySetData propertySetData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    internal static void ProcessMemberSetData(ConcurrentBag`1<string> errors, string typeName, MemberSetData memberSetData, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    private static void ProcessStandardMembers(ConcurrentBag`1<string> errors, string typeName, Dictionary`2<string, TypeMemberData> standardMembers, List`1<PropertySetData> propertySets, PSMemberInfoInternalCollection`1<PSMemberInfo> membersCollection, bool isOverride);
    private static void ProcessStandardMembers(ConcurrentBag`1<string> errors, string typeName, PSMemberInfoInternalCollection`1<PSMemberInfo> memberSetMembers, PSMemberInfoInternalCollection`1<PSMemberInfo> typeMemberCollection, bool isOverride);
    private static void ProcessTypeConverter(ConcurrentBag`1<string> errors, string typeName, Type converterType, ConcurrentDictionary`2<string, object> typeConverters, bool isOverride);
    private static void ProcessTypeAdapter(ConcurrentBag`1<string> errors, string typeName, Type adapterType, ConcurrentDictionary`2<string, AdapterSet> typeAdapters, bool isOverride);
    private void ProcessTypeDataToAdd(ConcurrentBag`1<string> errors, TypeData typeData);
    private void ProcessTypeDataToRemove(ConcurrentBag`1<string> errors, TypeData typeData);
    private void Update(LoadContext context);
    private void Update(ConcurrentBag`1<string> errors, TypeData typeData, bool isRemove);
    public static TypeTable LoadDefaultTypeFiles();
    public static List`1<string> GetDefaultTypeFiles();
    internal Collection`1<string> GetSpecificProperties(ConsolidatedString types);
    internal PSMemberInfoInternalCollection`1<T> GetMembers(ConsolidatedString types);
    internal T GetFirstMemberOrDefault(ConsolidatedString types, MemberNamePredicate predicate);
    internal PSMemberInfoInternalCollection`1<PSMemberInfo> GetMembers(ConsolidatedString types);
    private PSMemberInfoInternalCollection`1<PSMemberInfo> MemberFactory(string k, ConsolidatedString types);
    internal object GetTypeConverter(string typeName);
    internal AdapterSet GetTypeAdapter(Type type);
    private static TypeMemberData GetTypeMemberDataFromPSMemberInfo(PSMemberInfo member);
    private static void LoadMembersToTypeData(PSMemberInfo member, TypeData typeData);
    private static T GetParameterType(object sourceValue);
    private static void LoadStandardMembersToTypeData(PSMemberSet memberSet, TypeData typeData);
    internal Dictionary`2<string, TypeData> GetAllTypeData();
    private bool RetrieveMembersToTypeData(TypeData typeData);
    private bool RetrieveConverterToTypeData(TypeData typeData);
    private bool RetrieveAdapterToTypeData(TypeData typeData);
    public TypeTable Clone(bool unshared);
    internal void Clear();
    internal void ClearConsolidatedMembers();
    private static void StandardMembersUpdated();
    internal void Initialize(string snapinName, string fileToLoad, ConcurrentBag`1<string> errors, AuthorizationManager authorizationManager, PSHost host, Boolean& failToLoadFile);
    private static string GetModuleContents(string moduleName, string fileToLoad, ConcurrentBag`1<string> errors, AuthorizationManager authorizationManager, PSHost host, Boolean& isFullyTrusted, Boolean& failToLoadFile, Boolean& isProductCode);
    private void UpdateWithModuleContents(string fileContents, string moduleName, string fileToLoad, bool isFullyTrusted, bool isProductCode, ConcurrentBag`1<string> errors);
    public void AddType(TypeData typeData);
    public void RemoveType(string typeName);
    internal void Update(string moduleName, string filePath, ConcurrentBag`1<string> errors, AuthorizationManager authorizationManager, PSHost host, Boolean& failToLoadFile);
    private bool ProcessIsBuiltIn(string filePath, ConcurrentBag`1<string> errors, Boolean& failToLoadFile);
    internal void Update(TypeData type, ConcurrentBag`1<string> errors, bool isRemove);
    private void Process_GetEvent_Types_Ps1Xml(string filePath, ConcurrentBag`1<string> errors);
    private void Process_TypesV3_Ps1Xml(string filePath, ConcurrentBag`1<string> errors);
    private static Func`2<string, PSMemberInfoInternalCollection`1<PSMemberInfo>> GetValueFactoryBasedOnInitCapacity(int capacity);
    private static MethodInfo GetMethodInfo(Type type, string method);
    private static ScriptBlock GetScriptBlock(string s);
    private void Process_Types_Ps1Xml(string filePath, ConcurrentBag`1<string> errors);
    [CompilerGeneratedAttribute]
internal static Func`2<string, PSMemberInfoInternalCollection`1<PSMemberInfo>> <GetValueFactoryBasedOnInitCapacity>g__CreateValueFactory|90_0(int capacity);
}
public class System.Management.Automation.Runspaces.TypeTableLoadException : RuntimeException {
    private Collection`1<string> _errors;
    public Collection`1<string> Errors { get; }
    public TypeTableLoadException(string message);
    public TypeTableLoadException(string message, Exception innerException);
    internal TypeTableLoadException(ConcurrentBag`1<string> loadErrors);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected TypeTableLoadException(SerializationInfo info, StreamingContext context);
    protected void SetDefaultErrorRecord();
    public Collection`1<string> get_Errors();
}
public class System.Management.Automation.Runspaces.VMConnectionInfo : RunspaceConnectionInfo {
    private AuthenticationMechanism _authMechanism;
    private PSCredential _credential;
    private static int _defaultOpenTimeout;
    [CompilerGeneratedAttribute]
private Guid <VMGuid>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConfigurationName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ComputerName>k__BackingField;
    public Guid VMGuid { get; public set; }
    public string ConfigurationName { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    public string CertificateThumbprint { get; public set; }
    public PSCredential Credential { get; public set; }
    public string ComputerName { get; public set; }
    internal VMConnectionInfo(PSCredential credential, Guid vmGuid, string vmName, string configurationName);
    [CompilerGeneratedAttribute]
public Guid get_VMGuid();
    [CompilerGeneratedAttribute]
public void set_VMGuid(Guid value);
    [CompilerGeneratedAttribute]
public string get_ConfigurationName();
    [CompilerGeneratedAttribute]
public void set_ConfigurationName(string value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    [CompilerGeneratedAttribute]
public virtual string get_ComputerName();
    [CompilerGeneratedAttribute]
public virtual void set_ComputerName(string value);
    public virtual RunspaceConnectionInfo Clone();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
}
internal class System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml : object {
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<GetFormatData>d__0")]
internal static IEnumerable`1<ExtendedTypeDefinition> GetFormatData();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_System_Xml_XmlElement_http___schemas_dmtf_org_wbem_wsman_identity_1_wsmanidentity_xsd_IdentifyResponse>d__1")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_System_Xml_XmlElement_http___schemas_dmtf_org_wbem_wsman_identity_1_wsmanidentity_xsd_IdentifyResponse();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_Microsoft_WSMan_Management_WSManConfigElement>d__2")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_WSMan_Management_WSManConfigElement();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_Microsoft_WSMan_Management_WSManConfigContainerElement>d__3")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_WSMan_Management_WSManConfigContainerElement();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_Microsoft_WSMan_Management_WSManConfigLeafElement>d__4")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_WSMan_Management_WSManConfigLeafElement();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_Microsoft_WSMan_Management_WSManConfigLeafElement_InitParams>d__5")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_WSMan_Management_WSManConfigLeafElement_InitParams();
    [IteratorStateMachineAttribute("System.Management.Automation.Runspaces.WSMan_Format_Ps1Xml/<ViewsOf_Microsoft_WSMan_Management_WSManConfigContainerElement_ComputerLevel>d__6")]
private static IEnumerable`1<FormatViewDefinition> ViewsOf_Microsoft_WSMan_Management_WSManConfigContainerElement_ComputerLevel();
}
public class System.Management.Automation.Runspaces.WSManConnectionInfo : RunspaceConnectionInfo {
    [CompilerGeneratedAttribute]
private WSManAuthenticationMechanism <WSManAuthenticationMechanism>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowImplicitCredentialForNegotiate>k__BackingField;
    [CompilerGeneratedAttribute]
private int <PortSetting>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaximumConnectionRedirectionCount>k__BackingField;
    internal static int defaultMaximumConnectionRedirectionCount;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumReceivedDataSizePerCommand>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <MaximumReceivedObjectSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCompression>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoMachineProfile>k__BackingField;
    [CompilerGeneratedAttribute]
private ProxyAccessType <ProxyAccessType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipCACheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipCNCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SkipRevocationCheck>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoEncryption>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseUTF16>k__BackingField;
    [CompilerGeneratedAttribute]
private OutputBufferingMode <OutputBufferingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludePortInSPN>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableNetworkAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxConnectionRetryCount>k__BackingField;
    public static string HttpScheme;
    public static string HttpsScheme;
    private string _scheme;
    private string _computerName;
    private string _appName;
    private Uri _connectionUri;
    private PSCredential _credential;
    private string _shellUri;
    private string _thumbPrint;
    private AuthenticationMechanism _proxyAuthentication;
    private PSCredential _proxyCredential;
    internal static OutputBufferingMode DefaultOutputBufferingMode;
    internal static int DefaultMaxConnectionRetryCount;
    private static string DefaultScheme;
    private static string DefaultSslScheme;
    private static string s_defaultAppName;
    [CompilerGeneratedAttribute]
private bool <UseDefaultWSManPort>k__BackingField;
    private static int DefaultPortHttp;
    private static int DefaultPortHttps;
    private static int DefaultPort;
    private static string DefaultComputerName;
    private static string LocalHostUriString;
    private static string DefaultShellUri;
    private static PSCredential DefaultCredential;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <DisconnectedOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpiresOn>k__BackingField;
    public Uri ConnectionUri { get; public set; }
    public string ComputerName { get; public set; }
    public string Scheme { get; public set; }
    public int Port { get; public set; }
    public string AppName { get; public set; }
    public PSCredential Credential { get; public set; }
    public string ShellUri { get; public set; }
    public AuthenticationMechanism AuthenticationMechanism { get; public set; }
    internal WSManAuthenticationMechanism WSManAuthenticationMechanism { get; private set; }
    internal bool AllowImplicitCredentialForNegotiate { get; private set; }
    internal int PortSetting { get; private set; }
    public string CertificateThumbprint { get; public set; }
    public int MaximumConnectionRedirectionCount { get; public set; }
    public Nullable`1<int> MaximumReceivedDataSizePerCommand { get; public set; }
    public Nullable`1<int> MaximumReceivedObjectSize { get; public set; }
    public bool UseCompression { get; public set; }
    public bool NoMachineProfile { get; public set; }
    public ProxyAccessType ProxyAccessType { get; public set; }
    public AuthenticationMechanism ProxyAuthentication { get; public set; }
    public PSCredential ProxyCredential { get; public set; }
    public bool SkipCACheck { get; public set; }
    public bool SkipCNCheck { get; public set; }
    public bool SkipRevocationCheck { get; public set; }
    public bool NoEncryption { get; public set; }
    public bool UseUTF16 { get; public set; }
    public OutputBufferingMode OutputBufferingMode { get; public set; }
    public bool IncludePortInSPN { get; public set; }
    public bool EnableNetworkAccess { get; public set; }
    public int MaxConnectionRetryCount { get; public set; }
    internal bool UseDefaultWSManPort { get; internal set; }
    internal bool IsLocalhostAndNetworkAccess { get; }
    internal Nullable`1<DateTime> DisconnectedOn { get; internal set; }
    internal Nullable`1<DateTime> ExpiresOn { get; internal set; }
    public WSManConnectionInfo(string scheme, string computerName, int port, string appName, string shellUri, PSCredential credential, int openTimeout);
    public WSManConnectionInfo(string scheme, string computerName, int port, string appName, string shellUri, PSCredential credential);
    public WSManConnectionInfo(bool useSsl, string computerName, int port, string appName, string shellUri, PSCredential credential);
    public WSManConnectionInfo(bool useSsl, string computerName, int port, string appName, string shellUri, PSCredential credential, int openTimeout);
    public WSManConnectionInfo(Uri uri, string shellUri, PSCredential credential);
    public WSManConnectionInfo(Uri uri, string shellUri, string certificateThumbprint);
    public WSManConnectionInfo(Uri uri);
    private static WSManConnectionInfo();
    public Uri get_ConnectionUri();
    public void set_ConnectionUri(Uri value);
    public virtual string get_ComputerName();
    public virtual void set_ComputerName(string value);
    public string get_Scheme();
    public void set_Scheme(string value);
    public int get_Port();
    public void set_Port(int value);
    public string get_AppName();
    public void set_AppName(string value);
    public virtual PSCredential get_Credential();
    public virtual void set_Credential(PSCredential value);
    public string get_ShellUri();
    public void set_ShellUri(string value);
    public virtual AuthenticationMechanism get_AuthenticationMechanism();
    public virtual void set_AuthenticationMechanism(AuthenticationMechanism value);
    [CompilerGeneratedAttribute]
internal WSManAuthenticationMechanism get_WSManAuthenticationMechanism();
    [CompilerGeneratedAttribute]
private void set_WSManAuthenticationMechanism(WSManAuthenticationMechanism value);
    [CompilerGeneratedAttribute]
internal bool get_AllowImplicitCredentialForNegotiate();
    [CompilerGeneratedAttribute]
private void set_AllowImplicitCredentialForNegotiate(bool value);
    [CompilerGeneratedAttribute]
internal int get_PortSetting();
    [CompilerGeneratedAttribute]
private void set_PortSetting(int value);
    public virtual string get_CertificateThumbprint();
    public virtual void set_CertificateThumbprint(string value);
    [CompilerGeneratedAttribute]
public int get_MaximumConnectionRedirectionCount();
    [CompilerGeneratedAttribute]
public void set_MaximumConnectionRedirectionCount(int value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumReceivedDataSizePerCommand();
    [CompilerGeneratedAttribute]
public void set_MaximumReceivedDataSizePerCommand(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_MaximumReceivedObjectSize();
    [CompilerGeneratedAttribute]
public void set_MaximumReceivedObjectSize(Nullable`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_UseCompression();
    [CompilerGeneratedAttribute]
public void set_UseCompression(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoMachineProfile();
    [CompilerGeneratedAttribute]
public void set_NoMachineProfile(bool value);
    [CompilerGeneratedAttribute]
public ProxyAccessType get_ProxyAccessType();
    [CompilerGeneratedAttribute]
public void set_ProxyAccessType(ProxyAccessType value);
    public AuthenticationMechanism get_ProxyAuthentication();
    public void set_ProxyAuthentication(AuthenticationMechanism value);
    public PSCredential get_ProxyCredential();
    public void set_ProxyCredential(PSCredential value);
    [CompilerGeneratedAttribute]
public bool get_SkipCACheck();
    [CompilerGeneratedAttribute]
public void set_SkipCACheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipCNCheck();
    [CompilerGeneratedAttribute]
public void set_SkipCNCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_SkipRevocationCheck();
    [CompilerGeneratedAttribute]
public void set_SkipRevocationCheck(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoEncryption();
    [CompilerGeneratedAttribute]
public void set_NoEncryption(bool value);
    [CompilerGeneratedAttribute]
public bool get_UseUTF16();
    [CompilerGeneratedAttribute]
public void set_UseUTF16(bool value);
    [CompilerGeneratedAttribute]
public OutputBufferingMode get_OutputBufferingMode();
    [CompilerGeneratedAttribute]
public void set_OutputBufferingMode(OutputBufferingMode value);
    [CompilerGeneratedAttribute]
public bool get_IncludePortInSPN();
    [CompilerGeneratedAttribute]
public void set_IncludePortInSPN(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableNetworkAccess();
    [CompilerGeneratedAttribute]
public void set_EnableNetworkAccess(bool value);
    [CompilerGeneratedAttribute]
public int get_MaxConnectionRetryCount();
    [CompilerGeneratedAttribute]
public void set_MaxConnectionRetryCount(int value);
    public virtual void SetSessionOptions(PSSessionOption options);
    public virtual RunspaceConnectionInfo Clone();
    public WSManConnectionInfo Copy();
    public virtual BaseClientSessionTransportManager CreateClientSessionTransportManager(Guid instanceId, string sessionName, PSRemotingCryptoHelper cryptoHelper);
    private static string ResolveShellUri(string shell);
    internal static T ExtractPropertyAsWsManConnectionInfo(RunspaceConnectionInfo rsCI, string property, T defaultValue);
    internal void SetConnectionUri(Uri newUri);
    internal void ConstructUri(string scheme, string computerName, Nullable`1<int> port, string appName);
    internal static string GetConnectionString(Uri connectionUri, Boolean& isSSLSpecified);
    private void ValidateSpecifiedAuthentication();
    private void UpdateUri(Uri uri);
    [CompilerGeneratedAttribute]
internal bool get_UseDefaultWSManPort();
    [CompilerGeneratedAttribute]
internal void set_UseDefaultWSManPort(bool value);
    internal bool get_IsLocalhostAndNetworkAccess();
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_DisconnectedOn();
    [CompilerGeneratedAttribute]
internal void set_DisconnectedOn(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTime> get_ExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_ExpiresOn(Nullable`1<DateTime> value);
    internal void NullDisconnectedExpiresOn();
    internal void SetDisconnectedExpiresOnToNow();
}
public class System.Management.Automation.RuntimeDefinedParameter : object {
    private string _name;
    private Type _parameterType;
    private object _value;
    [CompilerGeneratedAttribute]
private bool <IsSet>k__BackingField;
    [CompilerGeneratedAttribute]
private Collection`1<Attribute> <Attributes>k__BackingField;
    public string Name { get; public set; }
    public Type ParameterType { get; public set; }
    public object Value { get; public set; }
    public bool IsSet { get; public set; }
    public Collection`1<Attribute> Attributes { get; }
    public RuntimeDefinedParameter(string name, Type parameterType, Collection`1<Attribute> attributes);
    public string get_Name();
    public void set_Name(string value);
    public Type get_ParameterType();
    public void set_ParameterType(Type value);
    public object get_Value();
    public void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_IsSet();
    [CompilerGeneratedAttribute]
public void set_IsSet(bool value);
    [CompilerGeneratedAttribute]
public Collection`1<Attribute> get_Attributes();
    internal bool IsDisabled();
}
internal class System.Management.Automation.RuntimeDefinedParameterBinder : ParameterBinderBase {
    internal RuntimeDefinedParameterDictionary Target { get; internal set; }
    internal RuntimeDefinedParameterBinder(RuntimeDefinedParameterDictionary target, InternalCommand command, CommandLineParameters commandLineParameters);
    internal RuntimeDefinedParameterDictionary get_Target();
    internal void set_Target(RuntimeDefinedParameterDictionary value);
    internal virtual object GetDefaultParameterValue(string name);
    internal virtual void BindParameter(string name, object value, CompiledCommandParameter parameterMetadata);
}
public class System.Management.Automation.RuntimeDefinedParameterDictionary : Dictionary`2<string, RuntimeDefinedParameter> {
    private string _helpFile;
    [CompilerGeneratedAttribute]
private object <Data>k__BackingField;
    internal static RuntimeDefinedParameter[] EmptyParameterArray;
    public string HelpFile { get; public set; }
    public object Data { get; public set; }
    private static RuntimeDefinedParameterDictionary();
    public string get_HelpFile();
    public void set_HelpFile(string value);
    [CompilerGeneratedAttribute]
public object get_Data();
    [CompilerGeneratedAttribute]
public void set_Data(object value);
}
public class System.Management.Automation.RuntimeException : SystemException {
    private ErrorRecord _errorRecord;
    private string _errorId;
    private ErrorCategory _errorCategory;
    private object _targetObject;
    private bool _thrownByThrowStatement;
    [CompilerGeneratedAttribute]
private bool <WasRethrown>k__BackingField;
    private bool _suppressPromptInInterpreter;
    private Token _errorToken;
    public ErrorRecord ErrorRecord { get; }
    public bool WasThrownFromThrowStatement { get; public set; }
    internal bool WasRethrown { get; internal set; }
    internal bool SuppressPromptInInterpreter { get; internal set; }
    internal Token ErrorToken { get; internal set; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected RuntimeException(SerializationInfo info, StreamingContext context);
    public RuntimeException(string message);
    public RuntimeException(string message, Exception innerException);
    public RuntimeException(string message, Exception innerException, ErrorRecord errorRecord);
    internal RuntimeException(ErrorCategory errorCategory, InvocationInfo invocationInfo, IScriptExtent errorPosition, string errorIdAndResourceId, string message, Exception innerException);
    public virtual ErrorRecord get_ErrorRecord();
    internal void SetErrorId(string errorId);
    internal void SetErrorCategory(ErrorCategory errorCategory);
    internal void SetTargetObject(object targetObject);
    internal static string RetrieveMessage(ErrorRecord errorRecord);
    internal static string RetrieveMessage(Exception e);
    internal static Exception RetrieveException(ErrorRecord errorRecord);
    public bool get_WasThrownFromThrowStatement();
    public void set_WasThrownFromThrowStatement(bool value);
    [CompilerGeneratedAttribute]
internal bool get_WasRethrown();
    [CompilerGeneratedAttribute]
internal void set_WasRethrown(bool value);
    internal bool get_SuppressPromptInInterpreter();
    internal void set_SuppressPromptInInterpreter(bool value);
    internal Token get_ErrorToken();
    internal void set_ErrorToken(Token value);
}
internal class System.Management.Automation.SafeExprEvaluator : object {
    internal static bool TrySafeEval(ExpressionAst ast, ExecutionContext executionContext, Object& value);
    public sealed virtual object VisitErrorStatement(ErrorStatementAst errorStatementAst);
    public sealed virtual object VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    public sealed virtual object VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    public sealed virtual object VisitParamBlock(ParamBlockAst paramBlockAst);
    public sealed virtual object VisitNamedBlock(NamedBlockAst namedBlockAst);
    public sealed virtual object VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    public sealed virtual object VisitAttribute(AttributeAst attributeAst);
    public sealed virtual object VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    public sealed virtual object VisitParameter(ParameterAst parameterAst);
    public sealed virtual object VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    public sealed virtual object VisitIfStatement(IfStatementAst ifStmtAst);
    public sealed virtual object VisitTrap(TrapStatementAst trapStatementAst);
    public sealed virtual object VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    public sealed virtual object VisitDataStatement(DataStatementAst dataStatementAst);
    public sealed virtual object VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    public sealed virtual object VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    public sealed virtual object VisitForStatement(ForStatementAst forStatementAst);
    public sealed virtual object VisitWhileStatement(WhileStatementAst whileStatementAst);
    public sealed virtual object VisitCatchClause(CatchClauseAst catchClauseAst);
    public sealed virtual object VisitTryStatement(TryStatementAst tryStatementAst);
    public sealed virtual object VisitBreakStatement(BreakStatementAst breakStatementAst);
    public sealed virtual object VisitContinueStatement(ContinueStatementAst continueStatementAst);
    public sealed virtual object VisitReturnStatement(ReturnStatementAst returnStatementAst);
    public sealed virtual object VisitExitStatement(ExitStatementAst exitStatementAst);
    public sealed virtual object VisitThrowStatement(ThrowStatementAst throwStatementAst);
    public sealed virtual object VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    public sealed virtual object VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    public sealed virtual object VisitCommand(CommandAst commandAst);
    public sealed virtual object VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    public sealed virtual object VisitCommandParameter(CommandParameterAst commandParameterAst);
    public sealed virtual object VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    public sealed virtual object VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    public sealed virtual object VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    public sealed virtual object VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    public sealed virtual object VisitBlockStatement(BlockStatementAst blockStatementAst);
    public sealed virtual object VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    public sealed virtual object VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    public sealed virtual object VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    public sealed virtual object VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    public sealed virtual object VisitFunctionMember(FunctionMemberAst functionMemberAst);
    public sealed virtual object VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    public sealed virtual object VisitUsingStatement(UsingStatementAst usingStatementAst);
    public sealed virtual object VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordStatementAst);
    public sealed virtual object VisitPipelineChain(PipelineChainAst pipelineChainAst);
    public sealed virtual object VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    public sealed virtual object VisitStatementBlock(StatementBlockAst statementBlockAst);
    public sealed virtual object VisitPipeline(PipelineAst pipelineAst);
    public sealed virtual object VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    public sealed virtual object VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    public sealed virtual object VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    public sealed virtual object VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    public sealed virtual object VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    public sealed virtual object VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    public sealed virtual object VisitSubExpression(SubExpressionAst subExpressionAst);
    public sealed virtual object VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public sealed virtual object VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    public sealed virtual object VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    public sealed virtual object VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    public sealed virtual object VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    public sealed virtual object VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    public sealed virtual object VisitHashtable(HashtableAst hashtableAst);
    public sealed virtual object VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public sealed virtual object VisitParenExpression(ParenExpressionAst parenExpressionAst);
    [CompilerGeneratedAttribute]
private bool <VisitArrayLiteral>b__60_0(ExpressionAst e);
}
[FlagsAttribute]
public enum System.Management.Automation.ScopedItemOptions : Enum {
    public int value__;
    public static ScopedItemOptions None;
    public static ScopedItemOptions ReadOnly;
    public static ScopedItemOptions Constant;
    public static ScopedItemOptions Private;
    public static ScopedItemOptions AllScope;
    public static ScopedItemOptions Unspecified;
}
internal abstract class System.Management.Automation.ScopedItemSearcher`1 : object {
    private SessionStateScope _currentScope;
    private SessionStateScope _initialScope;
    private T _current;
    protected SessionStateInternal sessionState;
    private VariablePath _lookupPath;
    private SessionStateScopeEnumerator _scopeEnumerable;
    private bool _isSingleScopeLookup;
    private bool _isInitialized;
    private T System.Collections.Generic.IEnumerator<T>.Current { get; }
    public object Current { get; }
    internal SessionStateScope CurrentLookupScope { get; }
    internal SessionStateScope InitialScope { get; }
    internal ScopedItemSearcher`1(SessionStateInternal sessionState, VariablePath lookupPath);
    private sealed virtual override IEnumerator`1<T> System.Collections.Generic.IEnumerable<T>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual bool MoveNext();
    private sealed virtual override T System.Collections.Generic.IEnumerator<T>.get_Current();
    public sealed virtual object get_Current();
    public sealed virtual void Reset();
    public sealed virtual void Dispose();
    protected abstract virtual bool GetScopeItem(SessionStateScope scope, VariablePath name, T& newCurrentItem);
    internal SessionStateScope get_CurrentLookupScope();
    internal SessionStateScope get_InitialScope();
    private bool TryGetNewScopeItem(SessionStateScope lookupScope, T& newCurrentItem);
    private void InitializeScopeEnumerator();
}
internal class System.Management.Automation.ScopeTracer : object {
    private PSTraceSource _tracer;
    private PSTraceSourceOptions _flag;
    private string _scopeName;
    private string _leavingScopeFormatter;
    internal ScopeTracer(PSTraceSource tracer, PSTraceSourceOptions flag, string scopeOutputFormatter, string leavingScopeFormatter, string scopeName);
    internal ScopeTracer(PSTraceSource tracer, PSTraceSourceOptions flag, string scopeOutputFormatter, string leavingScopeFormatter, string scopeName, string format, Object[] args);
    internal void ScopeTracerHelper(PSTraceSourceOptions flag, string scopeOutputFormatter, string leavingScopeFormatter, string scopeName, string format, Object[] args);
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.ScriptAnalysis : object {
    [CompilerGeneratedAttribute]
private List`1<string> <DiscoveredExports>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <DiscoveredAliases>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<RequiredModuleInfo> <DiscoveredModules>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <DiscoveredCommandFilters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddsSelfToPath>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TypeDefinitionAst> <DiscoveredClasses>k__BackingField;
    internal List`1<string> DiscoveredExports { get; internal set; }
    internal Dictionary`2<string, string> DiscoveredAliases { get; internal set; }
    internal List`1<RequiredModuleInfo> DiscoveredModules { get; internal set; }
    internal List`1<string> DiscoveredCommandFilters { get; internal set; }
    internal bool AddsSelfToPath { get; internal set; }
    internal List`1<TypeDefinitionAst> DiscoveredClasses { get; internal set; }
    internal static ScriptAnalysis Analyze(string path, ExecutionContext context);
    internal static string ReadScript(string path);
    [CompilerGeneratedAttribute]
internal List`1<string> get_DiscoveredExports();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredExports(List`1<string> value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_DiscoveredAliases();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredAliases(Dictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
internal List`1<RequiredModuleInfo> get_DiscoveredModules();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredModules(List`1<RequiredModuleInfo> value);
    [CompilerGeneratedAttribute]
internal List`1<string> get_DiscoveredCommandFilters();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredCommandFilters(List`1<string> value);
    [CompilerGeneratedAttribute]
internal bool get_AddsSelfToPath();
    [CompilerGeneratedAttribute]
internal void set_AddsSelfToPath(bool value);
    [CompilerGeneratedAttribute]
internal List`1<TypeDefinitionAst> get_DiscoveredClasses();
    [CompilerGeneratedAttribute]
internal void set_DiscoveredClasses(List`1<TypeDefinitionAst> value);
}
public class System.Management.Automation.ScriptBlock : object {
    [CompilerGeneratedAttribute]
private Nullable`1<PSLanguageMode> <LanguageMode>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateInternal <SessionStateInternal>k__BackingField;
    private static ConditionalWeakTable`2<ScriptBlock, ConcurrentDictionary`2<Type, Delegate>> s_delegateTable;
    private CompiledScriptBlockData _scriptBlockData;
    private static ConcurrentDictionary`2<Tuple`2<string, string>, ScriptBlock> s_cachedScripts;
    internal static ScriptBlock EmptyScriptBlock;
    [CompilerGeneratedAttribute]
private Assembly <AssemblyDefiningPSTypes>k__BackingField;
    private static object s_syncObject;
    private static string s_lastSeenCertificate;
    private static bool s_hasProcessedCertificate;
    private static CmsMessageRecipient[] s_encryptionRecipients;
    private static Lazy`1<ScriptBlockLogging> s_sbLoggingSettingCache;
    public List`1<Attribute> Attributes { get; }
    public string File { get; }
    public bool IsFilter { get; }
    public bool IsConfiguration { get; }
    public PSModuleInfo Module { get; }
    public PSToken StartPosition { get; }
    internal Nullable`1<PSLanguageMode> LanguageMode { get; internal set; }
    internal ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal SessionStateInternal SessionStateInternal { get; internal set; }
    internal SessionState SessionState { get; internal set; }
    internal MergedCommandParameterMetadata ParameterMetadata { get; }
    internal bool UsesCmdletBinding { get; }
    internal bool HasDynamicParameters { get; }
    public bool DebuggerHidden { get; public set; }
    public Guid Id { get; }
    internal bool DebuggerStepThrough { get; internal set; }
    internal RuntimeDefinedParameterDictionary RuntimeDefinedParameters { get; }
    internal bool HasLogged { get; internal set; }
    internal bool SkipLogging { get; internal set; }
    internal Assembly AssemblyDefiningPSTypes { get; internal set; }
    internal CmdletBindingAttribute CmdletBindingAttribute { get; }
    internal ObsoleteAttribute ObsoleteAttribute { get; }
    internal ExperimentalAttribute ExperimentalAttribute { get; }
    internal CompiledScriptBlockData ScriptBlockData { get; }
    public Ast Ast { get; }
    internal IParameterMetadataProvider AstInternal { get; }
    internal IScriptExtent[] SequencePoints { get; }
    internal Action`1<FunctionContext> DynamicParamBlock { get; }
    internal Action`1<FunctionContext> UnoptimizedDynamicParamBlock { get; }
    internal Action`1<FunctionContext> BeginBlock { get; }
    internal Action`1<FunctionContext> UnoptimizedBeginBlock { get; }
    internal Action`1<FunctionContext> ProcessBlock { get; }
    internal Action`1<FunctionContext> UnoptimizedProcessBlock { get; }
    internal Action`1<FunctionContext> EndBlock { get; }
    internal Action`1<FunctionContext> UnoptimizedEndBlock { get; }
    internal Action`1<FunctionContext> CleanBlock { get; }
    internal Action`1<FunctionContext> UnoptimizedCleanBlock { get; }
    internal bool HasBeginBlock { get; }
    internal bool HasProcessBlock { get; }
    internal bool HasEndBlock { get; }
    internal bool HasCleanBlock { get; }
    internal ScriptBlock(IParameterMetadataProvider ast, bool isFilter);
    private ScriptBlock(CompiledScriptBlockData scriptBlockData);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ScriptBlock(SerializationInfo info, StreamingContext context);
    private static ScriptBlock();
    internal static ScriptBlock Create(ExecutionContext context, string script);
    public static ScriptBlock Create(string script);
    internal static ScriptBlock CreateDelayParsedScriptBlock(string script, bool isProductCode);
    public ScriptBlock GetNewClosure();
    public PowerShell GetPowerShell(Object[] args);
    public PowerShell GetPowerShell(bool isTrustedInput, Object[] args);
    public PowerShell GetPowerShell(Dictionary`2<string, object> variables, Object[] args);
    public PowerShell GetPowerShell(Dictionary`2<string, object> variables, Dictionary`2& usingVariables, Object[] args);
    public PowerShell GetPowerShell(Dictionary`2<string, object> variables, Dictionary`2& usingVariables, bool isTrustedInput, Object[] args);
    internal PowerShell GetPowerShell(ExecutionContext context, bool isTrustedInput, Nullable`1<bool> useLocalScope, Object[] args);
    public SteppablePipeline GetSteppablePipeline();
    public SteppablePipeline GetSteppablePipeline(CommandOrigin commandOrigin);
    public SteppablePipeline GetSteppablePipeline(CommandOrigin commandOrigin, Object[] args);
    public Collection`1<PSObject> Invoke(Object[] args);
    public Collection`1<PSObject> InvokeWithContext(IDictionary functionsToDefine, List`1<PSVariable> variablesToDefine, Object[] args);
    public Collection`1<PSObject> InvokeWithContext(Dictionary`2<string, ScriptBlock> functionsToDefine, List`1<PSVariable> variablesToDefine, Object[] args);
    public object InvokeReturnAsIs(Object[] args);
    internal T InvokeAsMemberFunctionT(object instance, Object[] args);
    internal void InvokeAsMemberFunction(object instance, Object[] args);
    public List`1<Attribute> get_Attributes();
    public string get_File();
    public bool get_IsFilter();
    public bool get_IsConfiguration();
    public PSModuleInfo get_Module();
    public PSToken get_StartPosition();
    [CompilerGeneratedAttribute]
internal Nullable`1<PSLanguageMode> get_LanguageMode();
    [CompilerGeneratedAttribute]
internal void set_LanguageMode(Nullable`1<PSLanguageMode> value);
    internal ReadOnlyCollection`1<PSTypeName> get_OutputType();
    internal static object GetRawResult(List`1<object> result, bool wrapToPSObject);
    internal void InvokeUsingCmdlet(Cmdlet contextCmdlet, bool useLocalScope, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Object[] args);
    [CompilerGeneratedAttribute]
internal SessionStateInternal get_SessionStateInternal();
    [CompilerGeneratedAttribute]
internal void set_SessionStateInternal(SessionStateInternal value);
    internal SessionState get_SessionState();
    internal void set_SessionState(SessionState value);
    internal Delegate GetDelegate(Type delegateType);
    internal Delegate CreateDelegate(Type delegateType);
    internal object InvokeAsDelegateHelper(object dollarUnder, object dollarThis, Object[] args);
    internal ExecutionContext GetContextFromTLS();
    internal Collection`1<PSObject> DoInvoke(object dollarUnder, object input, Object[] args);
    private static Collection`1<PSObject> GetWrappedResult(List`1<object> result);
    internal object DoInvokeReturnAsIs(bool useLocalScope, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Object[] args);
    internal void InvokeWithPipe(bool useLocalScope, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Pipe outputPipe, InvocationInfo invocationInfo, bool propagateAllExceptionsToTop, List`1<PSVariable> variablesToDefine, Dictionary`2<string, ScriptBlock> functionsToDefine, Object[] args);
    private static void OnScriptBlockInvokeEventHandler(object sender, PSEventArgs args);
    internal void SetPSScriptRootAndPSCommandPath(MutableTuple locals, ExecutionContext context);
    internal static ScriptBlock TryGetCachedScriptBlock(string fileName, string fileContents);
    private static bool IsDynamicKeyword(Ast ast);
    private static bool IsUsingTypes(Ast ast);
    internal static void CacheScriptBlock(ScriptBlock scriptBlock, string fileName, string fileContents);
    internal static void ClearScriptBlockCache();
    internal static ScriptBlock Create(Parser parser, string fileName, string fileContents);
    internal ScriptBlock Clone();
    public virtual string ToString();
    internal string ToStringWithDollarUsingHandling(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    internal PowerShell GetPowerShellImpl(ExecutionContext context, Dictionary`2<string, object> variables, bool isTrustedInput, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    internal SteppablePipeline GetSteppablePipelineImpl(CommandOrigin commandOrigin, Object[] args);
    private PipelineAst GetSimplePipeline(Func`2<string, PipelineAst> errorHandler);
    internal List`1<Attribute> GetAttributes();
    internal string GetFileName();
    internal bool IsMetaConfiguration();
    internal PSToken GetStartPosition();
    internal MergedCommandParameterMetadata get_ParameterMetadata();
    internal bool get_UsesCmdletBinding();
    internal bool get_HasDynamicParameters();
    public bool get_DebuggerHidden();
    public void set_DebuggerHidden(bool value);
    public Guid get_Id();
    internal bool get_DebuggerStepThrough();
    internal void set_DebuggerStepThrough(bool value);
    internal RuntimeDefinedParameterDictionary get_RuntimeDefinedParameters();
    internal bool get_HasLogged();
    internal void set_HasLogged(bool value);
    internal bool get_SkipLogging();
    internal void set_SkipLogging(bool value);
    [CompilerGeneratedAttribute]
internal Assembly get_AssemblyDefiningPSTypes();
    [CompilerGeneratedAttribute]
internal void set_AssemblyDefiningPSTypes(Assembly value);
    internal HelpInfo GetHelpInfo(ExecutionContext context, CommandInfo commandInfo, bool dontSearchOnRemoteComputer, Dictionary`2<Ast, Token[]> scriptBlockTokenCache, String& helpFile, String& helpUriFromDotLink);
    public void CheckRestrictedLanguage(IEnumerable`1<string> allowedCommands, IEnumerable`1<string> allowedVariables, bool allowEnvironmentVariables);
    internal string GetWithInputHandlingForInvokeCommand();
    internal string GetWithInputHandlingForInvokeCommandWithUsingExpression(Tuple`2<List`1<VariableExpressionAst>, string> usingVariablesTuple);
    internal bool IsUsingDollarInput();
    internal void InvokeWithPipeImpl(bool createLocalScope, Dictionary`2<string, ScriptBlock> functionsToDefine, List`1<PSVariable> variablesToDefine, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Pipe outputPipe, InvocationInfo invocationInfo, Object[] args);
    internal void InvokeWithPipeImpl(ScriptBlockClauseToInvoke clauseToInvoke, bool createLocalScope, Dictionary`2<string, ScriptBlock> functionsToDefine, List`1<PSVariable> variablesToDefine, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Pipe outputPipe, InvocationInfo invocationInfo, Object[] args);
    internal MutableTuple MakeLocalsTuple(bool createLocalScope);
    internal static Object[] BindArgumentsForScriptblockInvoke(RuntimeDefinedParameter[] parameters, Object[] args, ExecutionContext context, bool dotting, Dictionary`2<string, PSVariable> backupWhenDotting, MutableTuple locals);
    internal static void SetAutomaticVariable(AutomaticVariable variable, object value, MutableTuple locals);
    private Action`1<FunctionContext> GetCodeToInvoke(Boolean& optimized, ScriptBlockClauseToInvoke clauseToInvoke);
    internal CmdletBindingAttribute get_CmdletBindingAttribute();
    internal ObsoleteAttribute get_ObsoleteAttribute();
    internal ExperimentalAttribute get_ExperimentalAttribute();
    internal bool Compile(bool optimized);
    internal static void LogScriptBlockCreation(ScriptBlock scriptBlock, bool force);
    private static bool WriteScriptBlockToLog(ScriptBlock scriptBlock, int segment, int segments, string textToLog);
    private static string FormatLogString(string textToLog);
    private static bool GetAndValidateEncryptionRecipients(ScriptBlock scriptBlock, ProtectedEventLogging logSetting);
    private static void ResetCertificateCacheIfNeeded(string certificate);
    private static ScriptBlockLogging GetScriptBlockLoggingSetting();
    internal static string CheckSuspiciousContent(Ast scriptBlockAst);
    internal static void LogScriptBlockStart(ScriptBlock scriptBlock, Guid runspaceId);
    internal static void LogScriptBlockEnd(ScriptBlock scriptBlock, Guid runspaceId);
    internal CompiledScriptBlockData get_ScriptBlockData();
    public Ast get_Ast();
    internal IParameterMetadataProvider get_AstInternal();
    internal IScriptExtent[] get_SequencePoints();
    internal Action`1<FunctionContext> get_DynamicParamBlock();
    internal Action`1<FunctionContext> get_UnoptimizedDynamicParamBlock();
    internal Action`1<FunctionContext> get_BeginBlock();
    internal Action`1<FunctionContext> get_UnoptimizedBeginBlock();
    internal Action`1<FunctionContext> get_ProcessBlock();
    internal Action`1<FunctionContext> get_UnoptimizedProcessBlock();
    internal Action`1<FunctionContext> get_EndBlock();
    internal Action`1<FunctionContext> get_UnoptimizedEndBlock();
    internal Action`1<FunctionContext> get_CleanBlock();
    internal Action`1<FunctionContext> get_UnoptimizedCleanBlock();
    internal bool get_HasBeginBlock();
    internal bool get_HasProcessBlock();
    internal bool get_HasEndBlock();
    internal bool get_HasCleanBlock();
}
internal enum System.Management.Automation.ScriptBlockClauseToInvoke : Enum {
    public int value__;
    public static ScriptBlockClauseToInvoke Begin;
    public static ScriptBlockClauseToInvoke Process;
    public static ScriptBlockClauseToInvoke End;
    public static ScriptBlockClauseToInvoke Clean;
    public static ScriptBlockClauseToInvoke ProcessBlockOnly;
}
internal class System.Management.Automation.ScriptBlockExpressionWrapper : object {
    private ScriptBlock _scriptBlock;
    private IParameterMetadataProvider _ast;
    internal ScriptBlockExpressionWrapper(IParameterMetadataProvider ast);
    internal ScriptBlock GetScriptBlock(ExecutionContext context, bool isFilter);
}
internal class System.Management.Automation.ScriptBlockInvocationEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseLocalScope>k__BackingField;
    [CompilerGeneratedAttribute]
private ErrorHandlingBehavior <ErrorHandlingBehavior>k__BackingField;
    [CompilerGeneratedAttribute]
private object <DollarUnder>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private object <ScriptThis>k__BackingField;
    [CompilerGeneratedAttribute]
private Pipe <OutputPipe>k__BackingField;
    [CompilerGeneratedAttribute]
private InvocationInfo <InvocationInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Args>k__BackingField;
    [CompilerGeneratedAttribute]
private ExceptionDispatchInfo <Exception>k__BackingField;
    internal ScriptBlock ScriptBlock { get; internal set; }
    internal bool UseLocalScope { get; internal set; }
    internal ErrorHandlingBehavior ErrorHandlingBehavior { get; internal set; }
    internal object DollarUnder { get; internal set; }
    internal object Input { get; internal set; }
    internal object ScriptThis { get; internal set; }
    internal Pipe OutputPipe { get; internal set; }
    internal InvocationInfo InvocationInfo { get; internal set; }
    internal Object[] Args { get; internal set; }
    internal ExceptionDispatchInfo Exception { get; internal set; }
    internal ScriptBlockInvocationEventArgs(ScriptBlock scriptBlock, bool useLocalScope, ErrorHandlingBehavior errorHandlingBehavior, object dollarUnder, object input, object scriptThis, Pipe outputPipe, InvocationInfo invocationInfo, Object[] args);
    [CompilerGeneratedAttribute]
internal ScriptBlock get_ScriptBlock();
    [CompilerGeneratedAttribute]
internal void set_ScriptBlock(ScriptBlock value);
    [CompilerGeneratedAttribute]
internal bool get_UseLocalScope();
    [CompilerGeneratedAttribute]
internal void set_UseLocalScope(bool value);
    [CompilerGeneratedAttribute]
internal ErrorHandlingBehavior get_ErrorHandlingBehavior();
    [CompilerGeneratedAttribute]
internal void set_ErrorHandlingBehavior(ErrorHandlingBehavior value);
    [CompilerGeneratedAttribute]
internal object get_DollarUnder();
    [CompilerGeneratedAttribute]
internal void set_DollarUnder(object value);
    [CompilerGeneratedAttribute]
internal object get_Input();
    [CompilerGeneratedAttribute]
internal void set_Input(object value);
    [CompilerGeneratedAttribute]
internal object get_ScriptThis();
    [CompilerGeneratedAttribute]
internal void set_ScriptThis(object value);
    [CompilerGeneratedAttribute]
internal Pipe get_OutputPipe();
    [CompilerGeneratedAttribute]
internal void set_OutputPipe(Pipe value);
    [CompilerGeneratedAttribute]
internal InvocationInfo get_InvocationInfo();
    [CompilerGeneratedAttribute]
internal void set_InvocationInfo(InvocationInfo value);
    [CompilerGeneratedAttribute]
internal Object[] get_Args();
    [CompilerGeneratedAttribute]
internal void set_Args(Object[] value);
    [CompilerGeneratedAttribute]
internal ExceptionDispatchInfo get_Exception();
    [CompilerGeneratedAttribute]
internal void set_Exception(ExceptionDispatchInfo value);
}
internal class System.Management.Automation.ScriptBlockToPowerShellChecker : AstVisitor {
    private HashSet`1<string> _validVariables;
    [CompilerGeneratedAttribute]
private ScriptBlockAst <ScriptBeingConverted>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesParameter>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasUsingExpr>k__BackingField;
    internal ScriptBlockAst ScriptBeingConverted { get; internal set; }
    internal bool UsesParameter { get; private set; }
    internal bool HasUsingExpr { get; private set; }
    [CompilerGeneratedAttribute]
internal ScriptBlockAst get_ScriptBeingConverted();
    [CompilerGeneratedAttribute]
internal void set_ScriptBeingConverted(ScriptBlockAst value);
    [CompilerGeneratedAttribute]
internal bool get_UsesParameter();
    [CompilerGeneratedAttribute]
private void set_UsesParameter(bool value);
    [CompilerGeneratedAttribute]
internal bool get_HasUsingExpr();
    [CompilerGeneratedAttribute]
private void set_HasUsingExpr(bool value);
    public virtual AstVisitAction VisitParameter(ParameterAst parameterAst);
    public virtual AstVisitAction VisitPipeline(PipelineAst pipelineAst);
    public virtual AstVisitAction VisitCommand(CommandAst commandAst);
    public virtual AstVisitAction VisitMergingRedirection(MergingRedirectionAst redirectionAst);
    public virtual AstVisitAction VisitFileRedirection(FileRedirectionAst redirectionAst);
    public virtual AstVisitAction VisitVariableExpression(VariableExpressionAst variableExpressionAst);
    public virtual AstVisitAction VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    public virtual AstVisitAction VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    internal static void ThrowError(ScriptBlockToPowerShellNotSupportedException ex, Ast ast);
}
internal class System.Management.Automation.ScriptBlockToPowerShellConverter : object {
    private PowerShell _powershell;
    private ExecutionContext _context;
    private Dictionary`2<string, object> _usingValueMap;
    private Nullable`1<bool> _createLocalScope;
    private static String[] forEachNames;
    private static ScriptBlockToPowerShellConverter();
    internal static PowerShell Convert(ScriptBlockAst body, ReadOnlyCollection`1<ParameterAst> functionParameters, bool isTrustedInput, ExecutionContext context, Dictionary`2<string, object> variables, bool filterNonUsingVariables, Nullable`1<bool> createLocalScope, Object[] args);
    internal static Dictionary`2<string, object> GetUsingValuesForEachParallel(ScriptBlock scriptBlock, bool isTrustedInput, ExecutionContext context);
    private static bool FindForEachInCommand(CommandAst commandAst);
    private static bool IsInForeachParallelCallingScope(Ast scriptblockAst, UsingExpressionAst usingAst);
    internal static Dictionary`2<string, object> GetUsingValuesAsDictionary(ScriptBlock scriptBlock, bool isTrustedInput, ExecutionContext context, Dictionary`2<string, object> variables);
    internal static Object[] GetUsingValuesAsArray(ScriptBlock scriptBlock, bool isTrustedInput, ExecutionContext context, Dictionary`2<string, object> variables);
    private static Tuple`2<Dictionary`2<string, object>, Object[]> GetUsingValues(Ast body, bool isTrustedInput, ExecutionContext context, Dictionary`2<string, object> variables, bool filterNonUsingVariables);
    private static bool HasUsingExpressionsInDifferentScopes(UsingExpressionAst usingExpr, Ast topLevelParent, ScriptBlockAst& sbClosestToPreviousUsingExpr);
    private void ConvertPipeline(PipelineAst pipelineAst, bool isTrustedInput);
    private void ConvertCommand(CommandAst commandAst, bool isTrustedInput);
    private string GetCommandName(CommandElementAst commandNameAst, bool isTrustedInput);
    private void GetSplattedVariable(VariableExpressionAst variableAst);
    private object GetExpressionValue(ExpressionAst exprAst, bool isTrustedInput);
    private void AddParameter(CommandParameterAst commandParameterAst, bool isTrustedInput);
}
public class System.Management.Automation.ScriptBlockToPowerShellNotSupportedException : RuntimeException {
    public ScriptBlockToPowerShellNotSupportedException(string message);
    public ScriptBlockToPowerShellNotSupportedException(string message, Exception innerException);
    internal ScriptBlockToPowerShellNotSupportedException(string errorId, Exception innerException, string message, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ScriptBlockToPowerShellNotSupportedException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.ScriptCallDepthException : SystemException {
    private ErrorRecord _errorRecord;
    public ErrorRecord ErrorRecord { get; }
    public int CallDepth { get; }
    public ScriptCallDepthException(string message);
    public ScriptCallDepthException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ScriptCallDepthException(SerializationInfo info, StreamingContext context);
    public sealed virtual ErrorRecord get_ErrorRecord();
    public int get_CallDepth();
}
internal class System.Management.Automation.ScriptCommand : InternalCommand {
}
internal class System.Management.Automation.ScriptCommandHelpProvider : CommandHelpProvider {
    internal HelpCategory HelpCategory { get; }
    internal ScriptCommandHelpProvider(HelpSystem helpSystem);
    internal virtual HelpCategory get_HelpCategory();
    internal virtual CommandSearcher GetCommandSearcherForExactMatch(string commandName, ExecutionContext context);
    internal virtual CommandSearcher GetCommandSearcherForSearch(string pattern, ExecutionContext context);
}
internal abstract class System.Management.Automation.ScriptCommandProcessorBase : CommandProcessorBase {
    protected bool _dontUseScopeCommandOrigin;
    protected bool _rethrowExitException;
    protected bool _exitWasCalled;
    protected ScriptBlock _scriptBlock;
    private ScriptParameterBinderController _scriptParameterBinderController;
    internal ScriptParameterBinderController ScriptParameterBinderController { get; }
    protected ScriptCommandProcessorBase(ScriptBlock scriptBlock, ExecutionContext context, bool useLocalScope, CommandOrigin origin, SessionStateInternal sessionState);
    protected ScriptCommandProcessorBase(IScriptCommandInfo commandInfo, ExecutionContext context, bool useLocalScope, SessionStateInternal sessionState);
    internal ScriptParameterBinderController get_ScriptParameterBinderController();
    protected void CommonInitialization(ScriptBlock scriptBlock, ExecutionContext context, bool useLocalScope, CommandOrigin origin, SessionStateInternal sessionState);
    internal virtual bool IsHelpRequested(String& helpTarget, HelpCategory& helpCategory);
}
internal class System.Management.Automation.ScriptDebugger : Debugger {
    private Nullable`1<bool> _isLocalSession;
    [CompilerGeneratedAttribute]
private object <TriggerObject>k__BackingField;
    private ConditionalWeakTable`2<IScriptExtent[], Tuple`2<Dictionary`2<int, List`1<LineBreakpoint>>, BitArray>> _mapScriptToBreakpoints;
    private ExecutionContext _context;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<int, LineBreakpoint>> _pendingBreakpoints;
    private ConcurrentDictionary`2<string, Tuple`2<WeakReference, ConcurrentDictionary`2<int, LineBreakpoint>>> _boundBreakpoints;
    private ConcurrentDictionary`2<int, CommandBreakpoint> _commandBreakpoints;
    private ConcurrentDictionary`2<string, ConcurrentDictionary`2<int, VariableBreakpoint>> _variableBreakpoints;
    private ConcurrentDictionary`2<int, Breakpoint> _idToBreakpoint;
    private SteppingMode _steppingMode;
    private CallStackInfo _overOrOutFrame;
    private CallStackList _callStack;
    private static List`1<Breakpoint> s_emptyBreakpointList;
    private DebuggerCommandProcessor _commandProcessor;
    private InvocationInfo _currentInvocationInfo;
    private bool _inBreakpoint;
    private PowerShell _psDebuggerCommand;
    private bool _nestedDebuggerStop;
    private Dictionary`2<Guid, PSJobStartEventArgs> _runningJobs;
    private ConcurrentStack`1<Debugger> _activeDebuggers;
    private ConcurrentStack`1<DebuggerStopEventArgs> _debuggerStopEventArgs;
    private DebuggerResumeAction _lastActiveDebuggerAction;
    private DebuggerResumeAction _currentDebuggerAction;
    private DebuggerResumeAction _previousDebuggerAction;
    private CallStackInfo _nestedRunningFrame;
    private object _syncObject;
    private object _syncActiveDebuggerStopObject;
    private int _processingOutputCount;
    private ManualResetEventSlim _processingOutputCompleteEvent;
    private Dictionary`2<Guid, PSMonitorRunspaceInfo> _runningRunspaces;
    private static int _jobCallStackOffset;
    private static int _runspaceCallStackOffset;
    private bool _preserveUnhandledDebugStopEvent;
    private ManualResetEventSlim _preserveDebugStopEvent;
    private Lazy`1<ConcurrentQueue`1<StartRunspaceDebugProcessingEventArgs>> _runspaceDebugQueue;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _processingRunspaceDebugQueue;
    private ManualResetEventSlim _runspaceDebugCompleteEvent;
    private Nullable`1<bool> _isSystemLockedDown;
    private static string s_processDebugPromptMatch;
    private bool _savedIgnoreScriptDebug;
    public bool InBreakpoint { get; }
    internal bool IsPushed { get; }
    internal bool IsPendingDebugStopEvent { get; }
    internal bool IsDebuggerSteppingEnabled { get; }
    private bool IsLocalSession { get; }
    private object TriggerObject { get; private set; }
    private bool CanEnableDebugger { get; }
    private bool CanDisableDebugger { get; }
    private bool IsSystemLockedDown { get; }
    public bool IsActive { get; }
    internal bool IsRemote { get; }
    internal UnhandledBreakpointProcessingMode UnhandledBreakpointMode { get; internal set; }
    internal ScriptDebugger(ExecutionContext context);
    private static ScriptDebugger();
    public virtual bool get_InBreakpoint();
    internal virtual bool get_IsPushed();
    internal virtual bool get_IsPendingDebugStopEvent();
    internal virtual bool get_IsDebuggerSteppingEnabled();
    private bool get_IsLocalSession();
    [CompilerGeneratedAttribute]
private object get_TriggerObject();
    [CompilerGeneratedAttribute]
private void set_TriggerObject(object value);
    internal void ResetDebugger();
    internal void EnterScriptFunction(FunctionContext functionContext);
    private void SetupBreakpoints(FunctionContext functionContext);
    internal void ExitScriptFunction();
    internal void RegisterScriptFile(ExternalScriptInfo scriptCommandInfo);
    internal void RegisterScriptFile(string path, string scriptContents);
    internal void AddBreakpointCommon(Breakpoint breakpoint);
    private CommandBreakpoint AddCommandBreakpoint(CommandBreakpoint breakpoint);
    private LineBreakpoint AddLineBreakpoint(LineBreakpoint breakpoint);
    private void AddPendingBreakpoint(LineBreakpoint breakpoint);
    private void AddNewBreakpoint(Breakpoint breakpoint);
    internal VariableBreakpoint AddVariableBreakpoint(VariableBreakpoint breakpoint);
    private void UpdateBreakpoints(FunctionContext functionContext);
    private void OnBreakpointUpdated(BreakpointUpdatedEventArgs e);
    internal bool RemoveVariableBreakpoint(VariableBreakpoint breakpoint);
    internal bool RemoveCommandBreakpoint(CommandBreakpoint breakpoint);
    internal bool RemoveLineBreakpoint(LineBreakpoint breakpoint);
    internal bool CheckCommand(InvocationInfo invocationInfo);
    internal void CheckVariableRead(string variableName);
    internal void CheckVariableWrite(string variableName);
    private List`1<VariableBreakpoint> GetVariableBreakpointsToTrigger(string variableName, bool read);
    internal void TriggerVariableBreakpoints(List`1<VariableBreakpoint> breakpoints);
    internal Dictionary`2<int, List`1<LineBreakpoint>> GetBoundBreakpoints(IScriptExtent[] sequencePoints);
    private List`1<Breakpoint> TriggerBreakpoints(List`1<Breakpoint> breakpoints);
    internal void OnSequencePointHit(FunctionContext functionContext);
    private void OnDebuggerStop(InvocationInfo invocationInfo, List`1<Breakpoint> breakpoints);
    private void ResumeExecution(DebuggerResumeAction action);
    private bool WaitForDebugStopSubscriber();
    private void UnbindBoundBreakpoints(List`1<LineBreakpoint> boundBreakpoints);
    private void SetPendingBreakpoints(FunctionContext functionContext);
    private void StopOnSequencePoint(FunctionContext functionContext, List`1<Breakpoint> breakpoints);
    private void SetInternalDebugMode(InternalDebugMode mode);
    private bool get_CanEnableDebugger();
    private bool get_CanDisableDebugger();
    private bool get_IsSystemLockedDown();
    private void CheckForBreakpointSupport();
    private void EnableDebuggerStepping(EnableNestedType nestedType);
    private void DisableDebuggerStepping();
    private void RestoreInternalDebugMode();
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual void StopProcessCommand();
    public virtual void SetDebugMode(DebugModes mode);
    [IteratorStateMachineAttribute("System.Management.Automation.ScriptDebugger/<GetCallStack>d__106")]
public virtual IEnumerable`1<CallStackFrame> GetCallStack();
    public virtual bool get_IsActive();
    public virtual void ResetCommandProcessorSource();
    public virtual void SetDebuggerStepMode(bool enabled);
    internal virtual void Break(object triggerObject);
    internal virtual string GetCurrentScriptPosition();
    internal virtual DebuggerCommand InternalProcessCommand(string command, IList`1<PSObject> output);
    internal virtual bool InternalProcessListCommand(int lineNum, IList`1<PSObject> output);
    internal virtual bool get_IsRemote();
    internal virtual CallStackFrame[] GetActiveDebuggerCallStack();
    internal virtual UnhandledBreakpointProcessingMode get_UnhandledBreakpointMode();
    internal virtual void set_UnhandledBreakpointMode(UnhandledBreakpointProcessingMode value);
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    private static Debugger GetRunspaceDebugger(int runspaceId);
    internal virtual void DebugJob(Job job, bool breakAll);
    private bool TryAddDebugJob(Job job, bool breakAll);
    internal virtual void StopDebugJob(Job job);
    internal static void SetDebugJobAsync(IJobDebugger debuggableJob, bool isAsync);
    internal virtual void DebugRunspace(Runspace runspace, bool breakAll);
    internal virtual void StopDebugRunspace(Runspace runspace);
    internal virtual void QueueRunspaceForDebug(Runspace runspace);
    public virtual void CancelDebuggerProcessing();
    private void ReleaseInternalRunspaceDebugProcessing(object sender, bool emptyQueue);
    private void RunspaceStateChangedHandler(object sender, RunspaceStateEventArgs args);
    private void RunspaceAvailabilityChangedHandler(object sender, RunspaceAvailabilityEventArgs args);
    private void AddToJobRunningList(PSJobStartEventArgs jobArgs, DebuggerResumeAction startAction);
    private void SetRunningJobListToStep(bool enableStepping);
    private void SetRunspaceListToStep(bool enableStepping);
    private void RemoveFromRunningJobList(Job job);
    private void ClearRunningJobList();
    private bool PushActiveDebugger(Debugger debugger, int callstackOffset);
    private Debugger PopActiveDebugger();
    private void HandleActiveJobDebuggerStop(object sender, DebuggerStopEventArgs args);
    private CallStackInfo FixUpCallStack();
    private void RestoreCallStack(CallStackInfo item);
    private void HandleMonitorRunningJobsDebuggerStop(object sender, DebuggerStopEventArgs args);
    private bool IsJobDebuggingMode();
    private bool IsRunningWFJobsDebugger(Debugger debugger);
    private void HandleJobStateChanged(object sender, JobStateEventArgs args);
    private void HandleOutputProcessingStateChanged(object sender, OutputProcessingStateEventArgs e);
    private DebuggerCommandResults ProcessCommandForActiveDebugger(PSCommand command, PSDataCollection`1<PSObject> output);
    private bool StopCommandForActiveDebugger();
    internal virtual void StartMonitoringRunspace(PSMonitorRunspaceInfo runspaceInfo);
    internal virtual void EndMonitoringRunspace(PSMonitorRunspaceInfo runspaceInfo);
    internal virtual void ReleaseSavedDebugStop();
    private void AddToRunningRunspaceList(PSMonitorRunspaceInfo args);
    private void RemoveFromRunningRunspaceList(Runspace runspace);
    private void ClearRunningRunspaceList();
    private void HandleRunspaceStateChanged(object sender, RunspaceStateEventArgs e);
    private void HandleMonitorRunningRSDebuggerStop(object sender, DebuggerStopEventArgs args);
    private void HandleActiveRunspaceDebuggerStop(object sender, DebuggerStopEventArgs args);
    private bool IsRunningRSDebugger(Debugger debugger);
    private bool SetUpDebuggerOnRunspace(Runspace runspace);
    private void StartRunspaceForDebugQueueProcessing();
    private void DebuggerQueueThreadProc();
    private void ProcessRunspaceDebugInternally(Runspace runspace);
    private void WaitForReadyDebug();
    private bool IsDebuggerReady();
    private void WaitForDebugComplete();
    public sealed virtual void Dispose();
    internal void EnableTracing(int traceLevel, Nullable`1<bool> step);
    internal void DisableTracing();
    internal void Trace(string messageId, string resourceString, Object[] args);
    internal void TraceLine(IScriptExtent extent);
    internal void TraceScriptFunctionEntry(FunctionContext functionContext);
    internal void TraceVariableSet(string varName, object value);
}
public class System.Management.Automation.ScriptInfo : CommandInfo {
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    private CommandMetadata _commandMetadata;
    internal HelpCategory HelpCategory { get; }
    public ScriptBlock ScriptBlock { get; }
    public string Definition { get; }
    public ReadOnlyCollection`1<PSTypeName> OutputType { get; }
    internal bool ImplementsDynamicParameters { get; }
    internal CommandMetadata CommandMetadata { get; }
    internal ScriptInfo(string name, ScriptBlock script, ExecutionContext context);
    internal ScriptInfo(ScriptInfo other);
    internal virtual CommandInfo CreateGetCommandCopy(Object[] argumentList);
    internal virtual HelpCategory get_HelpCategory();
    [CompilerGeneratedAttribute]
public sealed virtual ScriptBlock get_ScriptBlock();
    public virtual string get_Definition();
    public virtual ReadOnlyCollection`1<PSTypeName> get_OutputType();
    public virtual string ToString();
    internal virtual bool get_ImplementsDynamicParameters();
    internal virtual CommandMetadata get_CommandMetadata();
}
internal class System.Management.Automation.ScriptParameterBinder : ParameterBinderBase {
    private CallSite`1<Func`3<CallSite, object, object>> _copyMutableValueSite;
    [CompilerGeneratedAttribute]
private ScriptBlock <Script>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateScope <LocalScope>k__BackingField;
    internal ScriptBlock Script { get; }
    internal SessionStateScope LocalScope { get; internal set; }
    internal ScriptParameterBinder(ScriptBlock script, InvocationInfo invocationInfo, ExecutionContext context, InternalCommand command, SessionStateScope localScope);
    internal object CopyMutableValues(object o);
    internal virtual object GetDefaultParameterValue(string name);
    internal virtual void BindParameter(string name, object value, CompiledCommandParameter parameterMetadata);
    internal object GetDefaultScriptParameterValue(RuntimeDefinedParameter parameter, IDictionary implicitUsingParameters);
    [CompilerGeneratedAttribute]
internal ScriptBlock get_Script();
    [CompilerGeneratedAttribute]
internal SessionStateScope get_LocalScope();
    [CompilerGeneratedAttribute]
internal void set_LocalScope(SessionStateScope value);
}
internal class System.Management.Automation.ScriptParameterBinderController : ParameterBinderController {
    [CompilerGeneratedAttribute]
private List`1<object> <DollarArgs>k__BackingField;
    internal static string NotePropertyNameForSplattingParametersInArgs;
    internal List`1<object> DollarArgs { get; }
    internal ScriptParameterBinderController(ScriptBlock script, InvocationInfo invocationInfo, ExecutionContext context, InternalCommand command, SessionStateScope localScope);
    [CompilerGeneratedAttribute]
internal List`1<object> get_DollarArgs();
    internal void BindCommandLineParameters(Collection`1<CommandParameterInternal> arguments);
    internal virtual bool BindParameter(CommandParameterInternal argument, ParameterBindingFlags flags);
    private void HandleRemainingArguments(Collection`1<CommandParameterInternal> arguments);
}
public class System.Management.Automation.ScriptRequiresException : RuntimeException {
    private string _commandName;
    private Version _requiresPSVersion;
    private ReadOnlyCollection`1<string> _missingPSSnapIns;
    private string _requiresShellId;
    private string _requiresShellPath;
    public string CommandName { get; }
    public Version RequiresPSVersion { get; }
    public ReadOnlyCollection`1<string> MissingPSSnapIns { get; }
    public string RequiresShellId { get; }
    public string RequiresShellPath { get; }
    internal ScriptRequiresException(string commandName, string requiresShellId, string requiresShellPath, string errorId);
    internal ScriptRequiresException(string commandName, Version requiresPSVersion, string currentPSVersion, string errorId);
    internal ScriptRequiresException(string commandName, Collection`1<string> missingItems, string errorId, bool forSnapins);
    internal ScriptRequiresException(string commandName, Collection`1<string> missingItems, string errorId, bool forSnapins, ErrorRecord errorRecord);
    internal ScriptRequiresException(string commandName, string errorId);
    public ScriptRequiresException(string message);
    public ScriptRequiresException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ScriptRequiresException(SerializationInfo info, StreamingContext context);
    public string get_CommandName();
    public Version get_RequiresPSVersion();
    public ReadOnlyCollection`1<string> get_MissingPSSnapIns();
    public string get_RequiresShellId();
    public string get_RequiresShellPath();
    private static string BuildMessage(string commandName, Collection`1<string> missingItems, bool forSnapins);
    private static string BuildMessage(string commandName, string first, string second, bool forShellId);
    private static string BuildMessage(string commandName);
}
internal class System.Management.Automation.ScriptRequiresSyntaxException : ScriptRequiresException {
    internal ScriptRequiresSyntaxException(string message);
}
internal static class System.Management.Automation.ScriptTrace : object {
    internal static void Trace(int level, string messageId, string resourceString, Object[] args);
    internal static void Trace(ExecutionContext context, int level, string messageId, string resourceString, Object[] args);
}
internal enum System.Management.Automation.SearchMode : Enum {
    public int value__;
    public static SearchMode First;
    public static SearchMode All;
    public static SearchMode Unique;
}
[FlagsAttribute]
internal enum System.Management.Automation.SearchResolutionOptions : Enum {
    public int value__;
    public static SearchResolutionOptions None;
    public static SearchResolutionOptions ResolveAliasPatterns;
    public static SearchResolutionOptions ResolveFunctionPatterns;
    public static SearchResolutionOptions CommandNameIsPattern;
    public static SearchResolutionOptions SearchAllScopes;
    public static SearchResolutionOptions UseAbbreviationExpansion;
    public static SearchResolutionOptions ResolveLiteralThenPathPatterns;
}
internal class System.Management.Automation.Security.Anonymous_9320654f_2227_43bf_a385_74cc8c562686 : ValueType {
    public UInt32 LowPart;
    public int HighPart;
}
internal class System.Management.Automation.Security.Anonymous_947eb392_1446_4e25_bbd4_10e98165f3a9 : ValueType {
    public UInt32 LowPart;
    public int HighPart;
}
internal class System.Management.Automation.Security.HWND__ : ValueType {
    public int unused;
}
internal class System.Management.Automation.Security.LARGE_INTEGER : ValueType {
    public Anonymous_9320654f_2227_43bf_a385_74cc8c562686 Struct1;
    public Anonymous_947eb392_1446_4e25_bbd4_10e98165f3a9 u;
    public long QuadPart;
}
internal static class System.Management.Automation.Security.NativeConstants : object {
    internal static int CRYPT_OID_INFO_OID_KEY;
    internal static int CRYPT_OID_INFO_NAME_KEY;
    internal static int CRYPT_OID_INFO_CNG_ALGID_KEY;
    public static int SAFER_TOKEN_NULL_IF_EQUAL;
    public static int SAFER_TOKEN_COMPARE_ONLY;
    public static int SAFER_TOKEN_MAKE_INERT;
    public static int SAFER_CRITERIA_IMAGEPATH;
    public static int SAFER_CRITERIA_NOSIGNEDHASH;
    public static int SAFER_CRITERIA_IMAGEHASH;
    public static int SAFER_CRITERIA_AUTHENTICODE;
    public static int SAFER_CRITERIA_URLZONE;
    public static int SAFER_CRITERIA_IMAGEPATH_NT;
    public static int WTD_UI_NONE;
    public static int S_OK;
    public static int S_FALSE;
    public static int ERROR_MORE_DATA;
    public static int ERROR_ACCESS_DISABLED_BY_POLICY;
    public static int ERROR_ACCESS_DISABLED_NO_SAFER_UI_BY_POLICY;
    public static int SAFER_MAX_HASH_SIZE;
    public static string SRP_POLICY_SCRIPT;
    internal static int SIGNATURE_DISPLAYNAME_LENGTH;
    internal static int SIGNATURE_PUBLISHER_LENGTH;
    internal static int SIGNATURE_HASH_LENGTH;
    internal static int MAX_PATH;
    internal static int FUNCTION_NOT_SUPPORTED;
    public static int CRYPTCAT_E_AREA_HEADER;
    public static int CRYPTCAT_E_AREA_MEMBER;
    public static int CRYPTCAT_E_AREA_ATTRIBUTE;
    public static int CRYPTCAT_E_CDF_UNSUPPORTED;
    public static int CRYPTCAT_E_CDF_DUPLICATE;
    public static int CRYPTCAT_E_CDF_TAGNOTFOUND;
    public static int CRYPTCAT_E_CDF_MEMBER_FILE_PATH;
    public static int CRYPTCAT_E_CDF_MEMBER_INDIRECTDATA;
    public static int CRYPTCAT_E_CDF_MEMBER_FILENOTFOUND;
    public static int CRYPTCAT_E_CDF_BAD_GUID_CONV;
    public static int CRYPTCAT_E_CDF_ATTR_TOOFEWVALUES;
    public static int CRYPTCAT_E_CDF_ATTR_TYPECOMBO;
}
internal static class System.Management.Automation.Security.NativeMethods : object {
    internal static string NCRYPT_WINDOW_HANDLE_PROPERTY;
    internal static int CRYPT_E_NOT_FOUND;
    internal static int E_INVALID_DATA;
    internal static int NTE_NOT_SUPPORTED;
    internal static UInt32 ERROR_SUCCESS;
    internal static UInt32 ERROR_NO_TOKEN;
    internal static UInt32 STATUS_SUCCESS;
    internal static UInt32 STATUS_INVALID_PARAMETER;
    internal static UInt32 ACL_REVISION;
    internal static UInt32 SYSTEM_SCOPED_POLICY_ID_ACE_TYPE;
    internal static UInt32 SUB_CONTAINERS_AND_OBJECTS_INHERIT;
    internal static UInt32 INHERIT_ONLY_ACE;
    internal static UInt32 TOKEN_ASSIGN_PRIMARY;
    internal static UInt32 TOKEN_DUPLICATE;
    internal static UInt32 TOKEN_IMPERSONATE;
    internal static UInt32 TOKEN_QUERY;
    internal static UInt32 TOKEN_QUERY_SOURCE;
    internal static UInt32 TOKEN_ADJUST_PRIVILEGES;
    internal static UInt32 TOKEN_ADJUST_GROUPS;
    internal static UInt32 TOKEN_ADJUST_DEFAULT;
    internal static UInt32 TOKEN_ADJUST_SESSIONID;
    internal static UInt32 SE_PRIVILEGE_ENABLED_BY_DEFAULT;
    internal static UInt32 SE_PRIVILEGE_ENABLED;
    internal static UInt32 SE_PRIVILEGE_REMOVED;
    internal static UInt32 SE_PRIVILEGE_USED_FOR_ACCESS;
    internal static UInt32 DONT_RESOLVE_DLL_REFERENCES;
    internal static UInt32 LOAD_LIBRARY_AS_DATAFILE;
    internal static UInt32 LOAD_WITH_ALTERED_SEARCH_PATH;
    internal static UInt32 LOAD_IGNORE_CODE_AUTHZ_LEVEL;
    internal static UInt32 LOAD_LIBRARY_AS_IMAGE_RESOURCE;
    internal static UInt32 LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE;
    internal static UInt32 LOAD_LIBRARY_REQUIRE_SIGNED_TARGET;
    internal static UInt32 LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR;
    internal static UInt32 LOAD_LIBRARY_SEARCH_APPLICATION_DIR;
    internal static UInt32 LOAD_LIBRARY_SEARCH_USER_DIRS;
    internal static UInt32 LOAD_LIBRARY_SEARCH_SYSTEM32;
    internal static UInt32 LOAD_LIBRARY_SEARCH_DEFAULT_DIRS;
    internal static bool CertEnumSystemStore(CertStoreFlags Flags, IntPtr notUsed1, IntPtr notUsed2, CertEnumSystemStoreCallBackProto fn);
    internal static IntPtr CertEnumCertificatesInStore(IntPtr storeHandle, IntPtr certContext);
    internal static IntPtr CertFindCertificateInStore(IntPtr hCertStore, CertOpenStoreEncodingType dwEncodingType, UInt32 dwFindFlags, CertFindType dwFindType, string pvFindPara, IntPtr notUsed1);
    internal static bool CertCloseStore(IntPtr hCertStore, int dwFlags);
    internal static bool CertGetEnhancedKeyUsage(IntPtr pCertContext, UInt32 dwFlags, IntPtr pUsage, Int32& pcbUsage);
    internal static IntPtr CertOpenStore(CertOpenStoreProvider storeProvider, CertOpenStoreEncodingType dwEncodingType, IntPtr notUsed1, CertOpenStoreFlags dwFlags, string storeName);
    internal static bool CertControlStore(IntPtr hCertStore, UInt32 dwFlags, CertControlStoreType dwCtrlType, IntPtr pvCtrlPara);
    internal static bool CertDeleteCertificateFromStore(IntPtr pCertContext);
    internal static IntPtr CertDuplicateCertificateContext(IntPtr pCertContext);
    internal static bool CertAddCertificateContextToStore(IntPtr hCertStore, IntPtr pCertContext, UInt32 dwAddDisposition, IntPtr& ppStoreContext);
    internal static bool CertFreeCertificateContext(IntPtr certContext);
    internal static bool CertGetCertificateContextProperty(IntPtr pCertContext, CertPropertyId dwPropId, IntPtr pvData, Int32& pcbData);
    internal static bool CertSetCertificateContextProperty(IntPtr pCertContext, CertPropertyId dwPropId, UInt32 dwFlags, IntPtr pvData);
    internal static IntPtr CryptFindLocalizedName(string pwszCryptName);
    internal static bool CryptAcquireContext(IntPtr& hProv, string strContainerName, string strProviderName, int nProviderType, UInt32 uiProviderFlags);
    internal static bool CryptReleaseContext(IntPtr hProv, int dwFlags);
    internal static bool CryptSetProvParam(IntPtr hProv, ProviderParam dwParam, Void* pbData, int dwFlags);
    internal static int NCryptOpenStorageProvider(IntPtr& hProv, string strProviderName, UInt32 dwFlags);
    internal static int NCryptOpenKey(IntPtr hProv, IntPtr& hKey, string strKeyName, UInt32 dwLegacySpec, UInt32 dwFlags);
    internal static int NCryptSetProperty(IntPtr hProv, string pszProperty, Void* pbInput, int cbInput, int dwFlags);
    internal static int NCryptDeleteKey(IntPtr hKey, UInt32 dwFlags);
    internal static int NCryptFreeObject(IntPtr hObject);
    internal static bool CryptUIWizDigitalSign(UInt32 dwFlags, IntPtr hwndParentNotUsed, IntPtr pwszWizardTitleNotUsed, IntPtr pDigitalSignInfo, IntPtr ppSignContextNotUsed);
    internal static CRYPTUI_WIZ_DIGITAL_SIGN_EXTENDED_INFO InitSignInfoExtendedStruct(string description, string moreInfoUrl, string hashAlgorithm);
    internal static IntPtr CryptFindOIDInfo(UInt32 dwKeyType, IntPtr pvKey, UInt32 dwGroupId);
    internal static UInt32 GetCertChoiceFromSigningOption(SigningOption option);
    internal static CRYPTUI_WIZ_DIGITAL_SIGN_INFO InitSignInfoStruct(string fileName, X509Certificate2 signingCert, string timeStampServerUrl, string hashAlgorithm, SigningOption option);
    internal static bool SaferIdentifyLevel(UInt32 dwNumProperties, SAFER_CODE_PROPERTIES& pCodeProperties, IntPtr& pLevelHandle, string bucket);
    internal static bool SaferComputeTokenFromLevel(IntPtr LevelHandle, IntPtr InAccessToken, IntPtr& OutAccessToken, UInt32 dwFlags, IntPtr lpReserved);
    internal static bool SaferCloseLevel(IntPtr hLevelHandle);
    internal static bool CloseHandle(IntPtr hObject);
    internal static UInt32 GetNamedSecurityInfo(string pObjectName, SeObjectType ObjectType, SecurityInformation SecurityInfo, IntPtr& ppsidOwner, IntPtr& ppsidGroup, IntPtr& ppDacl, IntPtr& ppSacl, IntPtr& ppSecurityDescriptor);
    internal static UInt32 SetNamedSecurityInfo(string pObjectName, SeObjectType ObjectType, SecurityInformation SecurityInfo, IntPtr psidOwner, IntPtr psidGroup, IntPtr pDacl, IntPtr pSacl);
    internal static bool ConvertStringSidToSid(string StringSid, IntPtr& Sid);
    internal static bool IsValidSid(IntPtr pSid);
    internal static UInt32 GetLengthSid(IntPtr pSid);
    internal static UInt32 LsaQueryCAPs(IntPtr[] CAPIDs, UInt32 CAPIDCount, IntPtr& CAPs, UInt32& CAPCount);
    internal static UInt32 LsaFreeMemory(IntPtr Buffer);
    internal static bool InitializeAcl(IntPtr pAcl, UInt32 nAclLength, UInt32 dwAclRevision);
    internal static UInt32 AddScopedPolicyIDAce(IntPtr Acl, UInt32 AceRevision, UInt32 AceFlags, UInt32 AccessMask, IntPtr Sid);
    internal static IntPtr GetCurrentProcess();
    internal static IntPtr GetCurrentThread();
    internal static bool OpenProcessToken(IntPtr ProcessHandle, UInt32 DesiredAccess, IntPtr& TokenHandle);
    internal static bool OpenThreadToken(IntPtr ThreadHandle, UInt32 DesiredAccess, bool OpenAsSelf, IntPtr& TokenHandle);
    internal static bool LookupPrivilegeValue(string lpSystemName, string lpName, LUID& lpLuid);
    internal static bool AdjustTokenPrivileges(IntPtr TokenHandle, bool DisableAllPrivileges, TOKEN_PRIVILEGE& NewState, UInt32 BufferLength, TOKEN_PRIVILEGE& PreviousState, UInt32& ReturnLength);
    internal static IntPtr LocalFree(IntPtr hMem);
}
internal class System.Management.Automation.Security.SAFER_CODE_PROPERTIES : ValueType {
    public UInt32 cbSize;
    public UInt32 dwCheckFlags;
    public string ImagePath;
    public IntPtr hImageFileHandle;
    public UInt32 UrlZoneId;
    public Byte[] ImageHash;
    public UInt32 dwImageHashSize;
    public LARGE_INTEGER ImageSize;
    public UInt32 HashAlgorithm;
    public IntPtr pByteBlock;
    public IntPtr hWndParent;
    public UInt32 dwWVTUIChoice;
}
public enum System.Management.Automation.Security.SystemEnforcementMode : Enum {
    public int value__;
    public static SystemEnforcementMode None;
    public static SystemEnforcementMode Audit;
    public static SystemEnforcementMode Enforce;
}
public class System.Management.Automation.Security.SystemPolicy : object {
    private static object s_systemLockdownPolicyLock;
    private static Nullable`1<SystemEnforcementMode> s_systemLockdownPolicy;
    private static bool s_allowDebugOverridePolicy;
    private static bool s_wldpCanExecuteAvailable;
    private static Nullable`1<SystemEnforcementMode> s_cachedWldpSystemPolicy;
    private static string AppLockerTestFileName;
    private static string AppLockerTestFileContents;
    private static Nullable`1<SaferPolicy> s_cachedSaferSystemPolicy;
    private static bool s_hadMissingWldpAssembly;
    [CompilerGeneratedAttribute]
private static bool <XamlWorkflowSupported>k__BackingField;
    internal static Guid PowerShellHost;
    internal static bool XamlWorkflowSupported { get; internal set; }
    private static SystemPolicy();
    internal static void LogWDACAuditMessage(ExecutionContext context, string title, string message, string fqid, bool dropIntoDebugger);
    public static SystemEnforcementMode GetSystemLockdownPolicy();
    public static SystemScriptFileEnforcement GetFilePolicyEnforcement(string filePath, FileStream fileStream);
    public static SystemEnforcementMode GetLockdownPolicy(string path, SafeHandle handle);
    private static SystemEnforcementMode GetWldpPolicy(string path, SafeHandle handle);
    private static SystemEnforcementMode GetAppLockerPolicy(string path, SafeHandle handle);
    private static string GetKnownFolderPath(Guid knownFolderId);
    private static SaferPolicy TestSaferPolicy(string testPathScript, string testPathModule);
    private static SystemEnforcementMode GetDebugLockdownPolicy(string path);
    internal static bool IsClassInApprovedList(Guid clsid);
    private static SystemEnforcementMode GetLockdownPolicyForResult(UInt32 pdwLockdownState);
    internal static string DumpLockdownState(UInt32 pdwLockdownState);
    [CompilerGeneratedAttribute]
internal static bool get_XamlWorkflowSupported();
    [CompilerGeneratedAttribute]
internal static void set_XamlWorkflowSupported(bool value);
}
public enum System.Management.Automation.Security.SystemScriptFileEnforcement : Enum {
    public int value__;
    public static SystemScriptFileEnforcement None;
    public static SystemScriptFileEnforcement Block;
    public static SystemScriptFileEnforcement Allow;
    public static SystemScriptFileEnforcement AllowConstrained;
    public static SystemScriptFileEnforcement AllowConstrainedAudit;
}
public class System.Management.Automation.SecurityDescriptorCmdletProviderIntrinsics : object {
    private Cmdlet _cmdlet;
    private SessionStateInternal _sessionState;
    internal SecurityDescriptorCmdletProviderIntrinsics(Cmdlet cmdlet);
    internal SecurityDescriptorCmdletProviderIntrinsics(SessionStateInternal sessionState);
    public Collection`1<PSObject> Get(string path, AccessControlSections includeSections);
    internal void Get(string path, AccessControlSections includeSections, CmdletProviderContext context);
    public Collection`1<PSObject> Set(string path, ObjectSecurity sd);
    internal void Set(string path, ObjectSecurity sd, CmdletProviderContext context);
    public ObjectSecurity NewFromPath(string path, AccessControlSections includeSections);
    public ObjectSecurity NewOfType(string providerId, string type, AccessControlSections includeSections);
}
public class System.Management.Automation.SemanticVersion : object {
    private static string VersionSansRegEx;
    private static string LabelRegEx;
    private static string LabelUnitRegEx;
    private static string PreLabelPropertyName;
    private static string BuildLabelPropertyName;
    private static string TypeNameForVersionWithLabel;
    private string versionString;
    [CompilerGeneratedAttribute]
private int <Major>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Minor>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Patch>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreReleaseLabel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <BuildLabel>k__BackingField;
    public int Major { get; }
    public int Minor { get; }
    public int Patch { get; }
    public string PreReleaseLabel { get; }
    public string BuildLabel { get; }
    public SemanticVersion(string version);
    public SemanticVersion(int major, int minor, int patch, string preReleaseLabel, string buildLabel);
    public SemanticVersion(int major, int minor, int patch, string label);
    public SemanticVersion(int major, int minor, int patch);
    public SemanticVersion(int major, int minor);
    public SemanticVersion(int major);
    public SemanticVersion(Version version);
    public static Version op_Implicit(SemanticVersion semver);
    [CompilerGeneratedAttribute]
public int get_Major();
    [CompilerGeneratedAttribute]
public int get_Minor();
    [CompilerGeneratedAttribute]
public int get_Patch();
    [CompilerGeneratedAttribute]
public string get_PreReleaseLabel();
    [CompilerGeneratedAttribute]
public string get_BuildLabel();
    public static SemanticVersion Parse(string version);
    public static bool TryParse(string version, SemanticVersion& result);
    private static bool TryParseVersion(string version, VersionResult& result);
    public virtual string ToString();
    public static int Compare(SemanticVersion versionA, SemanticVersion versionB);
    public sealed virtual int CompareTo(object version);
    public sealed virtual int CompareTo(SemanticVersion value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(SemanticVersion other);
    public virtual int GetHashCode();
    public static bool op_Equality(SemanticVersion v1, SemanticVersion v2);
    public static bool op_Inequality(SemanticVersion v1, SemanticVersion v2);
    public static bool op_LessThan(SemanticVersion v1, SemanticVersion v2);
    public static bool op_LessThanOrEqual(SemanticVersion v1, SemanticVersion v2);
    public static bool op_GreaterThan(SemanticVersion v1, SemanticVersion v2);
    public static bool op_GreaterThanOrEqual(SemanticVersion v1, SemanticVersion v2);
    private static int ComparePreLabel(string preLabel1, string preLabel2);
}
internal class System.Management.Automation.SerializationContext : object {
    private static int DefaultSerializationDepth;
    internal int depth;
    internal SerializationOptions options;
    internal PSRemotingCryptoHelper cryptoHelper;
    internal CimClassSerializationCache`1<CimClassSerializationId> cimClassSerializationIdCache;
    internal SerializationContext(int depth, bool useDepthFromTypes);
    internal SerializationContext(int depth, SerializationOptions options, PSRemotingCryptoHelper cryptoHelper);
}
internal enum System.Management.Automation.SerializationMethod : Enum {
    public int value__;
    public static SerializationMethod AllPublicProperties;
    public static SerializationMethod String;
    public static SerializationMethod SpecificProperties;
}
[FlagsAttribute]
internal enum System.Management.Automation.SerializationOptions : Enum {
    public int value__;
    public static SerializationOptions None;
    public static SerializationOptions UseDepthFromTypes;
    public static SerializationOptions NoRootElement;
    public static SerializationOptions NoNamespace;
    public static SerializationOptions NoObjectRefIds;
    public static SerializationOptions PreserveSerializationSettingOfOriginal;
    public static SerializationOptions RemotingOptions;
}
internal static class System.Management.Automation.SerializationStrings : object {
    internal static string RootElementTag;
    internal static string PSObjectTag;
    internal static string AdapterProperties;
    internal static string TypeNamesTag;
    internal static string TypeNamesItemTag;
    internal static string TypeNamesReferenceTag;
    internal static string MemberSet;
    internal static string NoteProperty;
    internal static string ToStringElementTag;
    internal static string CollectionTag;
    internal static string DictionaryTag;
    internal static string DictionaryEntryTag;
    internal static string DictionaryKey;
    internal static string DictionaryValue;
    internal static string StackTag;
    internal static string QueueTag;
    internal static string ListTag;
    internal static string CharTag;
    internal static string GuidTag;
    internal static string BooleanTag;
    internal static string UnsignedByteTag;
    internal static string DateTimeTag;
    internal static string DecimalTag;
    internal static string DoubleTag;
    internal static string DurationTag;
    internal static string FloatTag;
    internal static string IntTag;
    internal static string LongTag;
    internal static string ByteTag;
    internal static string ShortTag;
    internal static string Base64BinaryTag;
    internal static string ScriptBlockTag;
    internal static string StringTag;
    internal static string SecureStringTag;
    internal static string UnsignedShortTag;
    internal static string UnsignedIntTag;
    internal static string UnsignedLongTag;
    internal static string AnyUriTag;
    internal static string VersionTag;
    internal static string SemanticVersionTag;
    internal static string XmlDocumentTag;
    internal static string NilTag;
    internal static string ReferenceTag;
    internal static string ProgressRecord;
    internal static string ProgressRecordActivityId;
    internal static string ProgressRecordParentActivityId;
    internal static string ProgressRecordActivity;
    internal static string ProgressRecordStatusDescription;
    internal static string ProgressRecordCurrentOperation;
    internal static string ProgressRecordPercentComplete;
    internal static string ProgressRecordSecondsRemaining;
    internal static string ProgressRecordType;
    internal static string ReferenceIdAttribute;
    internal static string NameAttribute;
    internal static string VersionAttribute;
    internal static string StreamNameAttribute;
    internal static string MonadNamespace;
    internal static string MonadNamespacePrefix;
}
internal static class System.Management.Automation.SerializationUtilities : object {
    internal static object GetPropertyValue(PSObject psObject, string propertyName);
    internal static object GetPsObjectPropertyBaseObject(PSObject psObject, string propertyName);
    internal static void GetKnownContainerTypeInfo(object source, ContainerType& ct, IDictionary& dictionary, IEnumerable& enumerable);
    private static bool DerivesFromGenericType(Type derived, Type baseType);
    internal static string GetToString(object source);
    internal static string GetToStringForPrimitiveObject(PSObject pso);
    internal static PSMemberInfoInternalCollection`1<PSPropertyInfo> GetSpecificPropertiesToSerialize(PSObject source, Collection`1<CollectionEntry`1<PSPropertyInfo>> allPropertiesCollection, TypeTable typeTable);
    internal static object GetPropertyValueInThreadSafeManner(PSPropertyInfo property, bool canUseDefaultRunspaceInThreadSafeManner, Boolean& success);
}
internal class System.Management.Automation.Serializer : object {
    private InternalSerializer _serializer;
    internal TypeTable TypeTable { get; internal set; }
    internal Serializer(XmlWriter writer);
    internal Serializer(XmlWriter writer, int depth, bool useDepthFromTypes);
    internal Serializer(XmlWriter writer, SerializationContext context);
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    internal void Serialize(object source);
    internal void Serialize(object source, string streamName);
    internal void Done();
    internal void Stop();
}
internal class System.Management.Automation.ServerPowerShellDataStructureHandler : object {
    private AbstractServerTransportManager _transportManager;
    private Guid _clientRunspacePoolId;
    private Guid _clientPowerShellId;
    private RemoteStreamOptions _streamSerializationOptions;
    private Runspace _rsUsedToInvokePowerShell;
    [CompilerGeneratedAttribute]
private EventHandler RemoveAssociation;
    [CompilerGeneratedAttribute]
private EventHandler StopPowerShellReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<object>> InputReceived;
    [CompilerGeneratedAttribute]
private EventHandler InputEndReceived;
    [CompilerGeneratedAttribute]
private EventHandler OnSessionConnected;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> HostResponseReceived;
    internal Guid PowerShellId { get; }
    internal Runspace RunspaceUsedToInvokePowerShell { get; }
    internal ServerPowerShellDataStructureHandler(Guid instanceId, Guid runspacePoolId, RemoteStreamOptions remoteStreamOptions, AbstractServerTransportManager transportManager, PowerShell localPowerShell);
    private void LocalPowerShell_RunspaceAssigned(object sender, PSEventArgs`1<Runspace> e);
    internal void Prepare();
    internal void SendStateChangedInformationToClient(PSInvocationStateInfo stateInfo);
    internal void SendOutputDataToClient(PSObject data);
    internal void SendErrorRecordToClient(ErrorRecord errorRecord);
    internal void SendWarningRecordToClient(WarningRecord record);
    internal void SendDebugRecordToClient(DebugRecord record);
    internal void SendVerboseRecordToClient(VerboseRecord record);
    internal void SendProgressRecordToClient(ProgressRecord record);
    internal void SendInformationRecordToClient(InformationRecord record);
    internal void ProcessConnect();
    internal void ProcessReceivedData(RemoteDataObject`1<PSObject> receivedData);
    internal void RaiseRemoveAssociationEvent();
    internal ServerRemoteHost GetHostAssociatedWithPowerShell(HostInfo powerShellHostInfo, ServerRemoteHost runspaceServerRemoteHost);
    [CompilerGeneratedAttribute]
internal void add_RemoveAssociation(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_RemoveAssociation(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_StopPowerShellReceived(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_StopPowerShellReceived(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_InputReceived(EventHandler`1<RemoteDataEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
internal void remove_InputReceived(EventHandler`1<RemoteDataEventArgs`1<object>> value);
    [CompilerGeneratedAttribute]
internal void add_InputEndReceived(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_InputEndReceived(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_OnSessionConnected(EventHandler value);
    [CompilerGeneratedAttribute]
internal void remove_OnSessionConnected(EventHandler value);
    [CompilerGeneratedAttribute]
internal void add_HostResponseReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> value);
    [CompilerGeneratedAttribute]
internal void remove_HostResponseReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> value);
    internal Guid get_PowerShellId();
    internal Runspace get_RunspaceUsedToInvokePowerShell();
    private void SendDataAsync(RemoteDataObject data);
    private void HandleTransportClosing(object sender, EventArgs args);
}
internal class System.Management.Automation.ServerPowerShellDriver : object {
    private bool _extraPowerShellAlreadyScheduled;
    private PowerShell _extraPowerShell;
    private PSDataCollection`1<PSObject> _localPowerShellOutput;
    private Boolean[] _datasent;
    private object _syncObject;
    private bool _noInput;
    private bool _addToHistory;
    private ServerRemoteHost _remoteHost;
    private ApartmentState apartmentState;
    private IRSPDriverInvoke _psDriverInvoker;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<object> <InputCollection>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShell <LocalPowerShell>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteStreamOptions <RemoteStreamOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RunspacePoolId>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerPowerShellDataStructureHandler <DataStructureHandler>k__BackingField;
    internal PSDataCollection`1<object> InputCollection { get; }
    internal PowerShell LocalPowerShell { get; }
    internal Guid InstanceId { get; }
    internal RemoteStreamOptions RemoteStreamOptions { get; }
    internal Guid RunspacePoolId { get; }
    internal ServerPowerShellDataStructureHandler DataStructureHandler { get; }
    internal ServerPowerShellDriver(PowerShell powershell, PowerShell extraPowerShell, bool noInput, Guid clientPowerShellId, Guid clientRunspacePoolId, ServerRunspacePoolDriver runspacePoolDriver, ApartmentState apartmentState, HostInfo hostInfo, RemoteStreamOptions streamOptions, bool addToHistory, Runspace rsToUse);
    internal ServerPowerShellDriver(PowerShell powershell, PowerShell extraPowerShell, bool noInput, Guid clientPowerShellId, Guid clientRunspacePoolId, ServerRunspacePoolDriver runspacePoolDriver, ApartmentState apartmentState, HostInfo hostInfo, RemoteStreamOptions streamOptions, bool addToHistory, Runspace rsToUse, PSDataCollection`1<PSObject> output);
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<object> get_InputCollection();
    [CompilerGeneratedAttribute]
internal PowerShell get_LocalPowerShell();
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
internal RemoteStreamOptions get_RemoteStreamOptions();
    [CompilerGeneratedAttribute]
internal Guid get_RunspacePoolId();
    [CompilerGeneratedAttribute]
internal ServerPowerShellDataStructureHandler get_DataStructureHandler();
    private PSInvocationSettings PrepInvoke(bool startMainPowerShell);
    private IAsyncResult Start(bool startMainPowerShell);
    internal IAsyncResult Start();
    internal void RunNoOpCommand(IReadOnlyCollection`1<object> output);
    internal void InvokeMain();
    private void RegisterPowerShellEventHandlers(PowerShell powerShell);
    private void UnregisterPowerShellEventHandlers(PowerShell powerShell);
    private void RegisterDataStructureHandlerEventHandlers(ServerPowerShellDataStructureHandler dsHandler);
    private void UnregisterDataStructureHandlerEventHandlers(ServerPowerShellDataStructureHandler dsHandler);
    private void RegisterPipelineOutputEventHandlers(PSDataCollection`1<PSObject> pipelineOutput);
    private void UnregisterPipelineOutputEventHandlers(PSDataCollection`1<PSObject> pipelineOutput);
    private void HandlePowerShellInvocationStateChanged(object sender, PSInvocationStateChangedEventArgs eventArgs);
    private void HandleOutputDataAdded(object sender, DataAddedEventArgs e);
    private void HandleErrorDataAdded(object sender, DataAddedEventArgs e);
    private void HandleProgressAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleWarningAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleVerboseAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleDebugAdded(object sender, DataAddedEventArgs eventArgs);
    private void HandleInformationAdded(object sender, DataAddedEventArgs eventArgs);
    private void SendRemainingData();
    private void HandleStopReceived(object sender, EventArgs eventArgs);
    private void HandleInputReceived(object sender, RemoteDataEventArgs`1<object> eventArgs);
    private void HandleInputEndReceived(object sender, EventArgs eventArgs);
    private void HandleSessionConnected(object sender, EventArgs eventArgs);
    private void HandleHostResponseReceived(object sender, RemoteDataEventArgs`1<RemoteHostResponse> eventArgs);
    private void HandleIdleEvent(object sender, EventArgs args);
}
internal class System.Management.Automation.ServerRemoteDebugger : Debugger {
    private IRSPDriverInvoke _driverInvoker;
    private Runspace _runspace;
    private ObjectRef`1<Debugger> _wrappedDebugger;
    private bool _inDebugMode;
    private DebuggerStopEventArgs _debuggerStopEventArgs;
    private ManualResetEventSlim _nestedDebugStopCompleteEvent;
    private bool _nestedDebugging;
    private ManualResetEventSlim _processCommandCompleteEvent;
    private ThreadCommandProcessing _threadCommandProcessing;
    private bool _raiseStopEventLocally;
    internal static string SetPSBreakCommandText;
    [CompilerGeneratedAttribute]
private bool <LocalDebugMode>k__BackingField;
    public bool InBreakpoint { get; }
    public bool IsActive { get; }
    internal bool IsPushed { get; }
    internal bool IsRemote { get; }
    internal bool IsDebuggerSteppingEnabled { get; }
    internal UnhandledBreakpointProcessingMode UnhandledBreakpointMode { get; internal set; }
    internal bool IsPendingDebugStopEvent { get; }
    internal bool LocalDebugMode { get; internal set; }
    internal ServerRemoteDebugger(IRSPDriverInvoke driverInvoker, Runspace runspace, Debugger debugger);
    public virtual bool get_InBreakpoint();
    public virtual void SetBreakpoints(IEnumerable`1<Breakpoint> breakpoints, Nullable`1<int> runspaceId);
    public virtual Breakpoint GetBreakpoint(int id, Nullable`1<int> runspaceId);
    public virtual List`1<Breakpoint> GetBreakpoints(Nullable`1<int> runspaceId);
    public virtual CommandBreakpoint SetCommandBreakpoint(string command, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual LineBreakpoint SetLineBreakpoint(string path, int line, int column, ScriptBlock action, Nullable`1<int> runspaceId);
    public virtual VariableBreakpoint SetVariableBreakpoint(string variableName, VariableAccessMode accessMode, ScriptBlock action, string path, Nullable`1<int> runspaceId);
    public virtual bool RemoveBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint EnableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual Breakpoint DisableBreakpoint(Breakpoint breakpoint, Nullable`1<int> runspaceId);
    public virtual void SetDebuggerAction(DebuggerResumeAction resumeAction);
    public virtual DebuggerStopEventArgs GetDebuggerStopArgs();
    public virtual DebuggerCommandResults ProcessCommand(PSCommand command, PSDataCollection`1<PSObject> output);
    public virtual void StopProcessCommand();
    public virtual void SetDebugMode(DebugModes mode);
    public virtual bool get_IsActive();
    public virtual void SetDebuggerStepMode(bool enabled);
    internal virtual DebuggerCommand InternalProcessCommand(string command, IList`1<PSObject> output);
    internal virtual void DebugJob(Job job, bool breakAll);
    internal virtual void StopDebugJob(Job job);
    internal virtual void DebugRunspace(Runspace runspace, bool breakAll);
    internal virtual void StopDebugRunspace(Runspace runspace);
    internal virtual bool get_IsPushed();
    internal virtual bool get_IsRemote();
    internal virtual bool get_IsDebuggerSteppingEnabled();
    internal virtual UnhandledBreakpointProcessingMode get_UnhandledBreakpointMode();
    internal virtual void set_UnhandledBreakpointMode(UnhandledBreakpointProcessingMode value);
    internal virtual bool get_IsPendingDebugStopEvent();
    internal virtual void ReleaseSavedDebugStop();
    public virtual IEnumerable`1<CallStackFrame> GetCallStack();
    internal virtual void Break(object triggerObject);
    public sealed virtual void Dispose();
    private void SetDebuggerCallbacks();
    private void RemoveDebuggerCallbacks();
    private void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    private void HandleBreakpointUpdated(object sender, BreakpointUpdatedEventArgs e);
    private void HandleNestedDebuggingCancelEvent(object sender, EventArgs e);
    private void EnterDebugMode(bool isNestedStop);
    private void OnEnterDebugMode(ManualResetEventSlim debugModeCompletedEvent);
    private void ExitDebugMode(DebuggerResumeAction resumeAction);
    private void SubscribeWrappedDebugger(Debugger wrappedDebugger);
    private void UnsubscribeWrappedDebugger(Debugger wrappedDebugger);
    private bool IsDebuggingSupported();
    internal bool HandleStopSignal();
    internal void CheckDebuggerState();
    internal void StartPowerShellCommand(PowerShell powershell, Guid powershellId, Guid runspacePoolId, ServerRunspacePoolDriver runspacePoolDriver, ApartmentState apartmentState, ServerRemoteHost remoteHost, HostInfo hostInfo, RemoteStreamOptions streamOptions, bool addToHistory);
    private void HandlePowerShellInvocationStateChanged(object sender, PSInvocationStateChangedEventArgs e);
    internal int GetBreakpointCount();
    internal void PushDebugger(Debugger debugger);
    internal void PopDebugger();
    internal void ReleaseAndRaiseDebugStopLocal();
    [CompilerGeneratedAttribute]
internal bool get_LocalDebugMode();
    [CompilerGeneratedAttribute]
internal void set_LocalDebugMode(bool value);
}
internal class System.Management.Automation.ServerRunspacePoolDataStructureHandler : object {
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> CreateAndInvokePowerShell;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> GetCommandMetadata;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> HostResponseReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSObject>> SetMaxRunspacesReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSObject>> SetMinRunspacesReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSObject>> GetAvailableRunspacesReceived;
    [CompilerGeneratedAttribute]
private EventHandler`1<RemoteDataEventArgs`1<PSObject>> ResetRunspaceState;
    private Guid _clientRunspacePoolId;
    private AbstractServerSessionTransportManager _transportManager;
    private Dictionary`2<Guid, ServerPowerShellDataStructureHandler> _associatedShells;
    private object _associationSyncObject;
    internal TypeTable TypeTable { get; internal set; }
    internal ServerRunspacePoolDataStructureHandler(ServerRunspacePoolDriver driver, AbstractServerSessionTransportManager transportManager);
    internal void SendApplicationPrivateDataToClient(PSPrimitiveDictionary applicationPrivateData, RemoteSessionCapability serverCapability);
    internal void SendStateInfoToClient(RunspacePoolStateInfo stateInfo);
    internal void SendPSEventArgsToClient(PSEventArgs e);
    internal void ProcessConnect();
    internal void ProcessReceivedData(RemoteDataObject`1<PSObject> receivedData);
    internal ServerPowerShellDataStructureHandler CreatePowerShellDataStructureHandler(Guid instanceId, Guid runspacePoolId, RemoteStreamOptions remoteStreamOptions, PowerShell localPowerShell);
    internal ServerPowerShellDataStructureHandler GetPowerShellDataStructureHandler();
    internal void DispatchMessageToPowerShell(RemoteDataObject`1<PSObject> rcvdData);
    internal void SendResponseToClient(long callId, object response);
    internal TypeTable get_TypeTable();
    internal void set_TypeTable(TypeTable value);
    [CompilerGeneratedAttribute]
internal void add_CreateAndInvokePowerShell(EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> value);
    [CompilerGeneratedAttribute]
internal void remove_CreateAndInvokePowerShell(EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> value);
    [CompilerGeneratedAttribute]
internal void add_GetCommandMetadata(EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> value);
    [CompilerGeneratedAttribute]
internal void remove_GetCommandMetadata(EventHandler`1<RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>>> value);
    [CompilerGeneratedAttribute]
internal void add_HostResponseReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> value);
    [CompilerGeneratedAttribute]
internal void remove_HostResponseReceived(EventHandler`1<RemoteDataEventArgs`1<RemoteHostResponse>> value);
    [CompilerGeneratedAttribute]
internal void add_SetMaxRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void remove_SetMaxRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void add_SetMinRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void remove_SetMinRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void add_GetAvailableRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void remove_GetAvailableRunspacesReceived(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void add_ResetRunspaceState(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    [CompilerGeneratedAttribute]
internal void remove_ResetRunspaceState(EventHandler`1<RemoteDataEventArgs`1<PSObject>> value);
    private void SendDataAsync(RemoteDataObject data);
    internal ServerPowerShellDataStructureHandler GetAssociatedPowerShellDataStructureHandler(Guid clientPowerShellId);
    private void HandleRemoveAssociation(object sender, EventArgs e);
}
internal class System.Management.Automation.ServerRunspacePoolDriver : object {
    private string _initialLocation;
    private ConfigurationDataFromXML _configData;
    private PSPrimitiveDictionary _applicationPrivateData;
    private Dictionary`2<Guid, ServerPowerShellDriver> _associatedShells;
    private ServerDriverRemoteHost _remoteHost;
    private bool _isClosed;
    private RemoteSessionCapability _serverCapability;
    private Runspace _rsToUseForSteppablePipeline;
    private ServerSteppablePipelineSubscriber _eventSubscriber;
    private PSDataCollection`1<object> _inputCollection;
    private PowerShellDriverInvoker _driverNestedInvoker;
    private ServerRemoteDebugger _serverRemoteDebugger;
    private Version _clientPSVersion;
    private string _configurationName;
    internal EventHandler`1<EventArgs> Closed;
    [CompilerGeneratedAttribute]
private ServerRunspacePoolDataStructureHandler <DataStructureHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private RunspacePool <RunspacePool>k__BackingField;
    private Nullable`1<bool> _initialSessionStateIncludesGetCommandWithListImportedSwitch;
    private object _initialSessionStateIncludesGetCommandWithListImportedSwitchLock;
    internal ServerRunspacePoolDataStructureHandler DataStructureHandler { get; }
    internal ServerRemoteHost ServerRemoteHost { get; }
    internal Guid InstanceId { get; }
    internal RunspacePool RunspacePool { get; private set; }
    internal ServerRunspacePoolDriver(Guid clientRunspacePoolId, int minRunspaces, int maxRunspaces, PSThreadOptions threadOptions, ApartmentState apartmentState, HostInfo hostInfo, InitialSessionState initialSessionState, PSPrimitiveDictionary applicationPrivateData, ConfigurationDataFromXML configData, AbstractServerSessionTransportManager transportManager, bool isAdministrator, RemoteSessionCapability serverCapability, Version psClientVersion, string configurationName, string initialLocation);
    [CompilerGeneratedAttribute]
internal ServerRunspacePoolDataStructureHandler get_DataStructureHandler();
    internal ServerRemoteHost get_ServerRemoteHost();
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
internal RunspacePool get_RunspacePool();
    [CompilerGeneratedAttribute]
private void set_RunspacePool(RunspacePool value);
    internal void Start();
    internal void SendApplicationPrivateDataToClient();
    internal void Close();
    public sealed virtual void EnterNestedPipeline();
    public sealed virtual void ExitNestedPipeline();
    public sealed virtual bool HandleStopSignal();
    private void HandleRunspaceCreatedForTypeTable(object sender, RunspaceCreatedEventArgs args);
    private void SetupRemoteDebugger(Runspace runspace);
    private void DisposeRemoteDebugger();
    private PSDataCollection`1<PSObject> InvokeScript(Command cmdToRun, RunspaceCreatedEventArgs args);
    private PSDataCollection`1<PSObject> InvokePowerShell(PowerShell powershell, RunspaceCreatedEventArgs args);
    private void HandleRunspaceCreated(object sender, RunspaceCreatedEventArgs args);
    private void InvokeStartupScripts(RunspaceCreatedEventArgs args);
    private void HandleRunspacePoolStateChanged(object sender, RunspacePoolStateChangedEventArgs eventArgs);
    private void HandleRunspacePoolForwardEvent(object sender, PSEventArgs e);
    private void HandleCreateAndInvokePowerShell(object _, RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>> eventArgs);
    private bool DoesInitialSessionStateIncludeGetCommandWithListImportedSwitch();
    private void HandleGetCommandMetadata(object sender, RemoteDataEventArgs`1<RemoteDataObject`1<PSObject>> eventArgs);
    private void HandleHostResponseReceived(object sender, RemoteDataEventArgs`1<RemoteHostResponse> eventArgs);
    private void HandleSetMaxRunspacesReceived(object sender, RemoteDataEventArgs`1<PSObject> eventArgs);
    private void HandleSetMinRunspacesReceived(object sender, RemoteDataEventArgs`1<PSObject> eventArgs);
    private void HandleGetAvailableRunspacesReceived(object sender, RemoteDataEventArgs`1<PSObject> eventArgs);
    private void HandleResetRunspaceState(object sender, RemoteDataEventArgs`1<PSObject> eventArgs);
    private bool ResetRunspaceState();
    private void StartPowerShellCommandOnPushedRunspace(PowerShell powershell, PowerShell extraPowerShell, Guid powershellId, Guid runspacePoolId, HostInfo hostInfo, RemoteStreamOptions streamOptions, bool noInput, bool addToHistory);
    private static PreProcessCommandResult PreProcessDebuggerCommand(PSCommand commands, ServerRemoteDebugger serverRemoteDebugger, Collection`1<object> preProcessOutput, DebuggerCommandArgument& commandArgument);
    private static void ReplaceVirtualCommandWithScript(PSCommand commands, string script);
    private static T GetParameter(Command command, string parameterName);
    private static bool TryGetParameter(Command command, string parameterName, T& value);
}
internal class System.Management.Automation.ServerSteppablePipelineDriver : object {
    private bool _addToHistory;
    private ApartmentState apartmentState;
    private ServerSteppablePipelineSubscriber _eventSubscriber;
    private PSDataCollection`1<object> _powershellInput;
    [CompilerGeneratedAttribute]
private PowerShell <LocalPowerShell>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <InstanceId>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerRemoteHost <RemoteHost>k__BackingField;
    [CompilerGeneratedAttribute]
private RemoteStreamOptions <RemoteStreamOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <RunspacePoolId>k__BackingField;
    [CompilerGeneratedAttribute]
private ServerPowerShellDataStructureHandler <DataStructureHandler>k__BackingField;
    [CompilerGeneratedAttribute]
private PSInvocationState <PipelineState>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoInput>k__BackingField;
    [CompilerGeneratedAttribute]
private SteppablePipeline <SteppablePipeline>k__BackingField;
    [CompilerGeneratedAttribute]
private object <SyncObject>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ProcessingInput>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerator`1<object> <InputEnumerator>k__BackingField;
    [CompilerGeneratedAttribute]
private PSDataCollection`1<object> <Input>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Pulsed>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TotalObjectsProcessed>k__BackingField;
    internal PowerShell LocalPowerShell { get; }
    internal Guid InstanceId { get; }
    internal ServerRemoteHost RemoteHost { get; }
    internal RemoteStreamOptions RemoteStreamOptions { get; }
    internal Guid RunspacePoolId { get; }
    internal ServerPowerShellDataStructureHandler DataStructureHandler { get; }
    internal PSInvocationState PipelineState { get; private set; }
    internal bool NoInput { get; }
    internal SteppablePipeline SteppablePipeline { get; internal set; }
    internal object SyncObject { get; }
    internal bool ProcessingInput { get; internal set; }
    internal IEnumerator`1<object> InputEnumerator { get; }
    internal PSDataCollection`1<object> Input { get; }
    internal bool Pulsed { get; internal set; }
    internal int TotalObjectsProcessed { get; internal set; }
    internal ServerSteppablePipelineDriver(PowerShell powershell, bool noInput, Guid clientPowerShellId, Guid clientRunspacePoolId, ServerRunspacePoolDriver runspacePoolDriver, ApartmentState apartmentState, HostInfo hostInfo, RemoteStreamOptions streamOptions, bool addToHistory, Runspace rsToUse, ServerSteppablePipelineSubscriber eventSubscriber, PSDataCollection`1<object> powershellInput);
    [CompilerGeneratedAttribute]
internal PowerShell get_LocalPowerShell();
    [CompilerGeneratedAttribute]
internal Guid get_InstanceId();
    [CompilerGeneratedAttribute]
internal ServerRemoteHost get_RemoteHost();
    [CompilerGeneratedAttribute]
internal RemoteStreamOptions get_RemoteStreamOptions();
    [CompilerGeneratedAttribute]
internal Guid get_RunspacePoolId();
    [CompilerGeneratedAttribute]
internal ServerPowerShellDataStructureHandler get_DataStructureHandler();
    [CompilerGeneratedAttribute]
internal PSInvocationState get_PipelineState();
    [CompilerGeneratedAttribute]
private void set_PipelineState(PSInvocationState value);
    [CompilerGeneratedAttribute]
internal bool get_NoInput();
    [CompilerGeneratedAttribute]
internal SteppablePipeline get_SteppablePipeline();
    [CompilerGeneratedAttribute]
internal void set_SteppablePipeline(SteppablePipeline value);
    [CompilerGeneratedAttribute]
internal object get_SyncObject();
    [CompilerGeneratedAttribute]
internal bool get_ProcessingInput();
    [CompilerGeneratedAttribute]
internal void set_ProcessingInput(bool value);
    [CompilerGeneratedAttribute]
internal IEnumerator`1<object> get_InputEnumerator();
    [CompilerGeneratedAttribute]
internal PSDataCollection`1<object> get_Input();
    [CompilerGeneratedAttribute]
internal bool get_Pulsed();
    [CompilerGeneratedAttribute]
internal void set_Pulsed(bool value);
    [CompilerGeneratedAttribute]
internal int get_TotalObjectsProcessed();
    [CompilerGeneratedAttribute]
internal void set_TotalObjectsProcessed(int value);
    internal void Start();
    internal void HandleInputEndReceived(object sender, EventArgs eventArgs);
    private void HandleSessionConnected(object sender, EventArgs eventArgs);
    internal void HandleHostResponseReceived(object sender, RemoteDataEventArgs`1<RemoteHostResponse> eventArgs);
    private void HandleStopReceived(object sender, EventArgs eventArgs);
    private void HandleInputReceived(object sender, RemoteDataEventArgs`1<object> eventArgs);
    internal void CheckAndPulseForProcessing(bool complete);
    internal void PerformStop();
    internal void SetState(PSInvocationState newState, Exception reason);
}
internal class System.Management.Automation.ServerSteppablePipelineDriverEventArg : EventArgs {
    internal ServerSteppablePipelineDriver SteppableDriver;
    internal ServerSteppablePipelineDriverEventArg(ServerSteppablePipelineDriver driver);
}
internal class System.Management.Automation.ServerSteppablePipelineSubscriber : object {
    private object _syncObject;
    private bool _initialized;
    private PSLocalEventManager _eventManager;
    private PSEventSubscriber _startSubscriber;
    private PSEventSubscriber _processSubscriber;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> StartSteppablePipeline;
    [CompilerGeneratedAttribute]
private EventHandler`1<EventArgs> RunProcessRecord;
    internal void SubscribeEvents(ServerSteppablePipelineDriver driver);
    [CompilerGeneratedAttribute]
public void add_StartSteppablePipeline(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_StartSteppablePipeline(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void add_RunProcessRecord(EventHandler`1<EventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_RunProcessRecord(EventHandler`1<EventArgs> value);
    private void HandleStartEvent(object sender, PSEventArgs args);
    private void HandleProcessRecord(object sender, PSEventArgs args);
    internal void FireStartSteppablePipeline(ServerSteppablePipelineDriver driver);
    internal void FireHandleProcessRecord(ServerSteppablePipelineDriver driver);
}
[FlagsAttribute]
public enum System.Management.Automation.SessionCapabilities : Enum {
    public int value__;
    public static SessionCapabilities RemoteServer;
    public static SessionCapabilities Language;
}
public class System.Management.Automation.SessionState : object {
    private SessionStateInternal _sessionState;
    private DriveManagementIntrinsics _drive;
    private CmdletProviderManagementIntrinsics _provider;
    private PathIntrinsics _path;
    private PSVariableIntrinsics _variable;
    public DriveManagementIntrinsics Drive { get; }
    public CmdletProviderManagementIntrinsics Provider { get; }
    public PathIntrinsics Path { get; }
    public PSVariableIntrinsics PSVariable { get; }
    public PSLanguageMode LanguageMode { get; public set; }
    public bool UseFullLanguageModeInDebugger { get; }
    public List`1<string> Scripts { get; }
    public List`1<string> Applications { get; }
    public PSModuleInfo Module { get; }
    public ProviderIntrinsics InvokeProvider { get; }
    public CommandInvocationIntrinsics InvokeCommand { get; }
    internal SessionStateInternal Internal { get; }
    internal SessionState(SessionStateInternal sessionState);
    internal SessionState(ExecutionContext context, bool createAsChild, bool linkToGlobal);
    public DriveManagementIntrinsics get_Drive();
    public CmdletProviderManagementIntrinsics get_Provider();
    public PathIntrinsics get_Path();
    public PSVariableIntrinsics get_PSVariable();
    public PSLanguageMode get_LanguageMode();
    public void set_LanguageMode(PSLanguageMode value);
    public bool get_UseFullLanguageModeInDebugger();
    public List`1<string> get_Scripts();
    public List`1<string> get_Applications();
    public PSModuleInfo get_Module();
    public ProviderIntrinsics get_InvokeProvider();
    public CommandInvocationIntrinsics get_InvokeCommand();
    public static void ThrowIfNotVisible(CommandOrigin origin, object valueToCheck);
    public static bool IsVisible(CommandOrigin origin, object valueToCheck);
    public static bool IsVisible(CommandOrigin origin, PSVariable variable);
    public static bool IsVisible(CommandOrigin origin, CommandInfo commandInfo);
    internal SessionStateInternal get_Internal();
}
public enum System.Management.Automation.SessionStateCategory : Enum {
    public int value__;
    public static SessionStateCategory Variable;
    public static SessionStateCategory Alias;
    public static SessionStateCategory Function;
    public static SessionStateCategory Filter;
    public static SessionStateCategory Drive;
    public static SessionStateCategory CmdletProvider;
    public static SessionStateCategory Scope;
    public static SessionStateCategory Command;
    public static SessionStateCategory Resource;
    public static SessionStateCategory Cmdlet;
}
internal static class System.Management.Automation.SessionStateConstants : object {
    internal static int DefaultVariableCapacity;
    internal static int MaxVariablesCapacity;
    internal static int MinVariablesCapacity;
    internal static int DefaultAliasCapacity;
    internal static int MaxAliasCapacity;
    internal static int MinAliasCapacity;
    internal static int DefaultFunctionCapacity;
    internal static int MaxFunctionCapacity;
    internal static int MinFunctionCapacity;
    internal static int DefaultDriveCapacity;
    internal static int MaxDriveCapacity;
    internal static int MinDriveCapacity;
    internal static int DefaultErrorCapacity;
    internal static int MaxErrorCapacity;
    internal static int MinErrorCapacity;
    internal static int DefaultDictionaryCapacity;
    internal static float DefaultHashTableLoadFactor;
}
public enum System.Management.Automation.SessionStateEntryVisibility : Enum {
    public int value__;
    public static SessionStateEntryVisibility Public;
    public static SessionStateEntryVisibility Private;
}
public class System.Management.Automation.SessionStateException : RuntimeException {
    private ErrorRecord _errorRecord;
    private string _itemName;
    private SessionStateCategory _sessionStateCategory;
    private string _errorId;
    private ErrorCategory _errorCategory;
    public ErrorRecord ErrorRecord { get; }
    public string ItemName { get; }
    public SessionStateCategory SessionStateCategory { get; }
    internal SessionStateException(string itemName, SessionStateCategory sessionStateCategory, string errorIdAndResourceId, string resourceStr, ErrorCategory errorCategory, Object[] messageArgs);
    public SessionStateException(string message);
    public SessionStateException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected SessionStateException(SerializationInfo info, StreamingContext context);
    public virtual ErrorRecord get_ErrorRecord();
    public string get_ItemName();
    public SessionStateCategory get_SessionStateCategory();
    private static string BuildMessage(string itemName, string resourceStr, Object[] messageArgs);
}
internal class System.Management.Automation.SessionStateInternal : object {
    [TraceSourceAttribute("SessionState", "SessionState Class")]
private static PSTraceSource s_tracer;
    private LocationGlobber _globberPrivate;
    [CompilerGeneratedAttribute]
private ExecutionContext <ExecutionContext>k__BackingField;
    private SessionState _publicSessionState;
    private ProviderIntrinsics _invokeProvider;
    [CompilerGeneratedAttribute]
private PSModuleInfo <Module>k__BackingField;
    internal List`1<string> ModuleTableKeys;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, PSModuleInfo> <ModuleTable>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Applications>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<CmdletInfo> <ExportedCmdlets>k__BackingField;
    internal SessionStateEntryVisibility DefaultCommandVisibility;
    [CompilerGeneratedAttribute]
private List`1<AliasInfo> <ExportedAliases>k__BackingField;
    private PSDriveInfo _currentDrive;
    [CompilerGeneratedAttribute]
private List`1<FunctionInfo> <ExportedFunctions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseExportList>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <FunctionsExported>k__BackingField;
    private bool _functionsExportedWithWildcard;
    [CompilerGeneratedAttribute]
private bool <ManifestWithExplicitFunctionExport>k__BackingField;
    private HistoryStack`1<PathInfo> _setLocationHistory;
    private Dictionary`2<string, Stack`1<PathInfo>> _workingLocationStack;
    private static string startingDefaultStackName;
    private string _defaultStackName;
    private Dictionary`2<string, List`1<ProviderInfo>> _providers;
    private Dictionary`2<ProviderInfo, PSDriveInfo> _providersCurrentWorkingDrive;
    private SessionStateScope _currentScope;
    internal static string ScopeParameterName;
    [CompilerGeneratedAttribute]
private SessionStateScope <GlobalScope>k__BackingField;
    [CompilerGeneratedAttribute]
private SessionStateScope <ModuleScope>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PSVariable> <ExportedVariables>k__BackingField;
    internal LocationGlobber Globber { get; }
    internal ExecutionContext ExecutionContext { get; }
    internal SessionState PublicSessionState { get; internal set; }
    internal ProviderIntrinsics InvokeProvider { get; }
    internal PSModuleInfo Module { get; internal set; }
    internal Dictionary`2<string, PSModuleInfo> ModuleTable { get; }
    internal PSLanguageMode LanguageMode { get; internal set; }
    internal bool UseFullLanguageModeInDebugger { get; }
    public List`1<string> Scripts { get; }
    public List`1<string> Applications { get; }
    internal List`1<CmdletInfo> ExportedCmdlets { get; }
    internal List`1<AliasInfo> ExportedAliases { get; }
    internal PSDriveInfo CurrentDrive { get; internal set; }
    internal List`1<FunctionInfo> ExportedFunctions { get; }
    internal bool UseExportList { get; internal set; }
    internal bool FunctionsExported { get; internal set; }
    internal bool FunctionsExportedWithWildcard { get; internal set; }
    internal bool ManifestWithExplicitFunctionExport { get; internal set; }
    internal PathInfo CurrentLocation { get; }
    internal Dictionary`2<string, List`1<ProviderInfo>> Providers { get; }
    internal Dictionary`2<ProviderInfo, PSDriveInfo> ProvidersCurrentWorkingDrive { get; }
    internal IEnumerable`1<ProviderInfo> ProviderList { get; }
    internal int ProviderCount { get; }
    internal SessionStateScope GlobalScope { get; }
    internal SessionStateScope ModuleScope { get; }
    internal SessionStateScope CurrentScope { get; internal set; }
    internal SessionStateScope ScriptScope { get; }
    internal List`1<PSVariable> ExportedVariables { get; }
    internal SessionStateInternal(ExecutionContext context);
    internal SessionStateInternal(SessionStateInternal parent, bool linkToGlobal, ExecutionContext context);
    private static SessionStateInternal();
    internal void InitializeSessionStateInternalSpecialVariables(bool clearVariablesTable);
    internal LocationGlobber get_Globber();
    [CompilerGeneratedAttribute]
internal ExecutionContext get_ExecutionContext();
    internal SessionState get_PublicSessionState();
    internal void set_PublicSessionState(SessionState value);
    internal ProviderIntrinsics get_InvokeProvider();
    [CompilerGeneratedAttribute]
internal PSModuleInfo get_Module();
    [CompilerGeneratedAttribute]
internal void set_Module(PSModuleInfo value);
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, PSModuleInfo> get_ModuleTable();
    internal PSLanguageMode get_LanguageMode();
    internal void set_LanguageMode(PSLanguageMode value);
    internal bool get_UseFullLanguageModeInDebugger();
    [CompilerGeneratedAttribute]
public List`1<string> get_Scripts();
    internal SessionStateEntryVisibility CheckScriptVisibility(string scriptPath);
    [CompilerGeneratedAttribute]
public List`1<string> get_Applications();
    [CompilerGeneratedAttribute]
internal List`1<CmdletInfo> get_ExportedCmdlets();
    internal void AddSessionStateEntry(SessionStateCmdletEntry entry);
    internal void AddSessionStateEntry(SessionStateCmdletEntry entry, bool local);
    internal void AddSessionStateEntry(SessionStateApplicationEntry entry);
    internal void AddSessionStateEntry(SessionStateScriptEntry entry);
    internal void InitializeFixedVariables();
    internal SessionStateEntryVisibility CheckApplicationVisibility(string applicationPath);
    private static SessionStateEntryVisibility checkPathVisibility(List`1<string> list, string path);
    internal void RunspaceClosingNotification();
    internal ProviderInvocationException NewProviderInvocationException(string resourceId, string resourceStr, ProviderInfo provider, string path, Exception e);
    internal ProviderInvocationException NewProviderInvocationException(string resourceId, string resourceStr, ProviderInfo provider, string path, Exception e, bool useInnerExceptionErrorMessage);
    internal void AddSessionStateEntry(SessionStateAliasEntry entry, string scopeID);
    internal IDictionary`2<string, AliasInfo> GetAliasTable();
    internal IDictionary`2<string, AliasInfo> GetAliasTableAtScope(string scopeID);
    [CompilerGeneratedAttribute]
internal List`1<AliasInfo> get_ExportedAliases();
    internal AliasInfo GetAlias(string aliasName, CommandOrigin origin);
    internal AliasInfo GetAlias(string aliasName);
    internal AliasInfo GetAliasAtScope(string aliasName, string scopeID);
    internal AliasInfo SetAliasValue(string aliasName, string value, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasValue(string aliasName, string value, bool force);
    internal AliasInfo SetAliasValue(string aliasName, string value, ScopedItemOptions options, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasValue(string aliasName, string value, ScopedItemOptions options, bool force);
    internal AliasInfo SetAliasItem(AliasInfo alias, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasItemAtScope(AliasInfo alias, string scopeID, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasItemAtScope(AliasInfo alias, string scopeID, bool force);
    internal void RemoveAlias(string aliasName, bool force);
    [IteratorStateMachineAttribute("System.Management.Automation.SessionStateInternal/<GetAliasesByCommandName>d__68")]
internal IEnumerable`1<string> GetAliasesByCommandName(string command);
    internal CmdletInfo GetCmdlet(string cmdletName);
    internal CmdletInfo GetCmdlet(string cmdletName, CommandOrigin origin);
    internal CmdletInfo GetCmdletAtScope(string cmdletName, string scopeID);
    internal IDictionary`2<string, List`1<CmdletInfo>> GetCmdletTable();
    internal IDictionary`2<string, List`1<CmdletInfo>> GetCmdletTableAtScope(string scopeID);
    internal void RemoveCmdlet(string name, int index, bool force);
    internal void RemoveCmdlet(string name, int index, bool force, CommandOrigin origin);
    internal void RemoveCmdletEntry(string name, bool force);
    internal bool ItemExists(string path, bool force, bool literalPath);
    internal bool ItemExists(string path, CmdletProviderContext context);
    internal bool ItemExists(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object ItemExistsDynamicParameters(string path, CmdletProviderContext context);
    private object ItemExistsDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal bool IsValidPath(string path);
    internal bool IsValidPath(string path, CmdletProviderContext context);
    private bool IsValidPath(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal bool IsItemContainer(string path);
    internal bool IsItemContainer(string path, CmdletProviderContext context);
    private bool IsItemContainer(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal void RemoveItem(String[] paths, bool recurse, bool force, bool literalPath);
    internal void RemoveItem(String[] paths, bool recurse, CmdletProviderContext context);
    internal void RemoveItem(string providerId, string path, bool recurse, CmdletProviderContext context);
    internal void RemoveItem(CmdletProvider providerInstance, string path, bool recurse, CmdletProviderContext context);
    internal object RemoveItemDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    private object RemoveItemDynamicParameters(CmdletProvider providerInstance, string path, bool recurse, CmdletProviderContext context);
    internal Collection`1<PSObject> GetChildItems(String[] paths, bool recurse, UInt32 depth, bool force, bool literalPath);
    internal void GetChildItems(string path, bool recurse, UInt32 depth, CmdletProviderContext context);
    private void GetChildItems(CmdletProvider providerInstance, string path, bool recurse, UInt32 depth, CmdletProviderContext context);
    private bool IsPathContainer(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    private void ProcessPathItems(CmdletProvider providerInstance, string path, bool recurse, CmdletProviderContext context, Int32& childrenNotMatchingFilterCriteria, ProcessMode processMode, bool skipIsItemContainerCheck);
    private void ProcessPathItems(CmdletProvider providerInstance, string path, bool recurse, UInt32 depth, CmdletProviderContext context, Int32& childrenNotMatchingFilterCriteria, ProcessMode processMode, bool skipIsItemContainerCheck);
    internal object GetChildItemsDynamicParameters(string path, bool recurse, CmdletProviderContext context);
    private static bool HasGetChildItemDynamicParameters(ProviderInfo providerInfo);
    private object GetChildItemsDynamicParameters(CmdletProvider providerInstance, string path, bool recurse, CmdletProviderContext context);
    internal Collection`1<string> GetChildNames(String[] paths, ReturnContainers returnContainers, bool recurse, UInt32 depth, bool force, bool literalPath);
    internal void GetChildNames(string path, ReturnContainers returnContainers, bool recurse, UInt32 depth, CmdletProviderContext context);
    private void DoGetChildNamesManually(CmdletProvider providerInstance, string providerPath, string relativePath, ReturnContainers returnContainers, Collection`1<WildcardPattern> includeMatcher, Collection`1<WildcardPattern> excludeMatcher, CmdletProviderContext context, bool recurse, UInt32 depth);
    private void GetChildNames(CmdletProvider providerInstance, string path, ReturnContainers returnContainers, CmdletProviderContext context);
    internal object GetChildNamesDynamicParameters(string path, CmdletProviderContext context);
    private object GetChildNamesDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal Collection`1<PSObject> RenameItem(string path, string newName, bool force);
    internal void RenameItem(string path, string newName, CmdletProviderContext context);
    private void RenameItem(CmdletProvider providerInstance, string path, string newName, CmdletProviderContext context);
    internal object RenameItemDynamicParameters(string path, string newName, CmdletProviderContext context);
    private object RenameItemDynamicParameters(CmdletProvider providerInstance, string path, string newName, CmdletProviderContext context);
    internal Collection`1<PSObject> NewItem(String[] paths, string name, string type, object content, bool force);
    internal void NewItem(String[] paths, string name, string type, object content, CmdletProviderContext context);
    private void NewItemPrivate(CmdletProvider providerInstance, string path, string type, object content, CmdletProviderContext context);
    internal object NewItemDynamicParameters(string path, string type, object newItemValue, CmdletProviderContext context);
    private object NewItemDynamicParameters(CmdletProvider providerInstance, string path, string type, object newItemValue, CmdletProviderContext context);
    internal bool HasChildItems(string path, bool force, bool literalPath);
    internal bool HasChildItems(string path, CmdletProviderContext context);
    internal bool HasChildItems(string providerId, string path);
    internal bool HasChildItems(string providerId, string path, CmdletProviderContext context);
    private bool HasChildItems(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal Collection`1<PSObject> CopyItem(String[] paths, string copyPath, bool recurse, CopyContainers copyContainers, bool force, bool literalPath);
    internal void CopyItem(String[] paths, string copyPath, bool recurse, CopyContainers copyContainers, CmdletProviderContext context);
    private void CopyItem(CmdletProvider providerInstance, string path, string copyPath, bool recurse, CmdletProviderContext context);
    private void CopyRecurseToSingleContainer(CmdletProvider providerInstance, string sourcePath, string destinationPath, CmdletProviderContext context);
    internal object CopyItemDynamicParameters(string path, string destination, bool recurse, CmdletProviderContext context);
    private object CopyItemDynamicParameters(CmdletProvider providerInstance, string path, string destination, bool recurse, CmdletProviderContext context);
    private static string ValidateRemotePathAndGetRoot(string path, PSSession session, CmdletProviderContext context, Nullable`1<PSLanguageMode> languageMode, bool sourceIsRemote);
    private static bool isValidSession(PSSession session, CmdletProviderContext context, Nullable`1& languageMode);
    internal Collection`1<IContentReader> GetContentReader(String[] paths, bool force, bool literalPath);
    internal Collection`1<IContentReader> GetContentReader(String[] paths, CmdletProviderContext context);
    private IContentReader GetContentReaderPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object GetContentReaderDynamicParameters(string path, CmdletProviderContext context);
    private object GetContentReaderDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal Collection`1<IContentWriter> GetContentWriter(String[] paths, bool force, bool literalPath);
    internal Collection`1<IContentWriter> GetContentWriter(String[] paths, CmdletProviderContext context);
    private IContentWriter GetContentWriterPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object GetContentWriterDynamicParameters(string path, CmdletProviderContext context);
    private object GetContentWriterDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal void ClearContent(String[] paths, bool force, bool literalPath);
    internal void ClearContent(String[] paths, CmdletProviderContext context);
    private void ClearContentPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object ClearContentDynamicParameters(string path, CmdletProviderContext context);
    private object ClearContentDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal PSDriveInfo NewDrive(PSDriveInfo drive, string scopeID);
    internal void NewDrive(PSDriveInfo drive, string scopeID, CmdletProviderContext context);
    private static bool IsValidDriveName(string name);
    private string GetProviderRootFromSpecifiedRoot(string root, ProviderInfo provider);
    internal object NewDriveDynamicParameters(string providerId, CmdletProviderContext context);
    internal PSDriveInfo GetDrive(string name);
    private PSDriveInfo GetDrive(string name, bool automount);
    internal PSDriveInfo GetDrive(string name, string scopeID);
    private PSDriveInfo AutomountFileSystemDrive(string name);
    private PSDriveInfo AutomountFileSystemDrive(DriveInfo systemDriveInfo);
    internal PSDriveInfo AutomountBuiltInDrive(string name);
    internal static void MountDefaultDrive(string name, ExecutionContext context);
    private bool ValidateOrRemoveAutoMountedDrive(PSDriveInfo drive, SessionStateScope scope);
    private bool IsAStaleVhdMountedDrive(PSDriveInfo drive);
    internal Collection`1<PSDriveInfo> GetDrivesForProvider(string providerId);
    internal void RemoveDrive(string driveName, bool force, string scopeID);
    internal void RemoveDrive(string driveName, bool force, string scopeID, CmdletProviderContext context);
    internal void RemoveDrive(PSDriveInfo drive, bool force, string scopeID);
    internal void RemoveDrive(PSDriveInfo drive, bool force, string scopeID, CmdletProviderContext context);
    private bool CanRemoveDrive(PSDriveInfo drive, CmdletProviderContext context);
    internal Collection`1<PSDriveInfo> Drives(string scope);
    internal PSDriveInfo get_CurrentDrive();
    internal void set_CurrentDrive(PSDriveInfo value);
    internal Collection`1<PSObject> NewProperty(String[] paths, string property, string type, object value, bool force, bool literalPath);
    internal void NewProperty(String[] paths, string property, string type, object value, CmdletProviderContext context);
    private void NewProperty(CmdletProvider providerInstance, string path, string property, string type, object value, CmdletProviderContext context);
    internal object NewPropertyDynamicParameters(string path, string propertyName, string type, object value, CmdletProviderContext context);
    private object NewPropertyDynamicParameters(CmdletProvider providerInstance, string path, string propertyName, string type, object value, CmdletProviderContext context);
    internal void RemoveProperty(String[] paths, string property, bool force, bool literalPath);
    internal void RemoveProperty(String[] paths, string property, CmdletProviderContext context);
    private void RemoveProperty(CmdletProvider providerInstance, string path, string property, CmdletProviderContext context);
    internal object RemovePropertyDynamicParameters(string path, string propertyName, CmdletProviderContext context);
    private object RemovePropertyDynamicParameters(CmdletProvider providerInstance, string path, string propertyName, CmdletProviderContext context);
    internal Collection`1<PSObject> CopyProperty(String[] sourcePaths, string sourceProperty, string destinationPath, string destinationProperty, bool force, bool literalPath);
    internal void CopyProperty(String[] sourcePaths, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    private void CopyProperty(CmdletProvider providerInstance, string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal object CopyPropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    private object CopyPropertyDynamicParameters(CmdletProvider providerInstance, string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal Collection`1<PSObject> MoveProperty(String[] sourcePaths, string sourceProperty, string destinationPath, string destinationProperty, bool force, bool literalPath);
    internal void MoveProperty(String[] sourcePaths, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    private void MoveProperty(CmdletProvider providerInstance, string sourcePath, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal object MovePropertyDynamicParameters(string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    private object MovePropertyDynamicParameters(CmdletProvider providerInstance, string path, string sourceProperty, string destinationPath, string destinationProperty, CmdletProviderContext context);
    internal Collection`1<PSObject> RenameProperty(String[] sourcePaths, string sourceProperty, string destinationProperty, bool force, bool literalPath);
    internal void RenameProperty(String[] paths, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    private void RenameProperty(CmdletProvider providerInstance, string sourcePath, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    internal object RenamePropertyDynamicParameters(string path, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    private object RenamePropertyDynamicParameters(CmdletProvider providerInstance, string path, string sourceProperty, string destinationProperty, CmdletProviderContext context);
    internal void AddSessionStateEntry(SessionStateFunctionEntry entry);
    internal IDictionary`2<string, FunctionInfo> GetFunctionTable();
    internal IDictionary`2<string, FunctionInfo> GetFunctionTableAtScope(string scopeID);
    [CompilerGeneratedAttribute]
internal List`1<FunctionInfo> get_ExportedFunctions();
    [CompilerGeneratedAttribute]
internal bool get_UseExportList();
    [CompilerGeneratedAttribute]
internal void set_UseExportList(bool value);
    [CompilerGeneratedAttribute]
internal bool get_FunctionsExported();
    [CompilerGeneratedAttribute]
internal void set_FunctionsExported(bool value);
    internal bool get_FunctionsExportedWithWildcard();
    internal void set_FunctionsExportedWithWildcard(bool value);
    [CompilerGeneratedAttribute]
internal bool get_ManifestWithExplicitFunctionExport();
    [CompilerGeneratedAttribute]
internal void set_ManifestWithExplicitFunctionExport(bool value);
    internal FunctionInfo GetFunction(string name, CommandOrigin origin);
    private bool IsFunctionVisibleInDebugger(FunctionInfo fnInfo, CommandOrigin origin);
    internal FunctionInfo GetFunction(string name);
    [IteratorStateMachineAttribute("System.Management.Automation.SessionStateInternal/<GetFunctionAliases>d__222")]
private static IEnumerable`1<string> GetFunctionAliases(IParameterMetadataProvider ipmp);
    internal FunctionInfo SetFunctionRaw(string name, ScriptBlock function, CommandOrigin origin);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, string helpFile);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, ExecutionContext context, string helpFile);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, ExecutionContext context, string helpFile, bool isPreValidated);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, bool force, CommandOrigin origin);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, bool force);
    internal void RemoveFunction(string name, bool force, CommandOrigin origin);
    internal void RemoveFunction(string name, bool force);
    internal void RemoveFunction(string name, PSModuleInfo module);
    internal Collection`1<PSObject> GetItem(String[] paths, bool force, bool literalPath);
    internal void GetItem(String[] paths, CmdletProviderContext context);
    private void GetItemPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object GetItemDynamicParameters(string path, CmdletProviderContext context);
    private object GetItemDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal Collection`1<PSObject> SetItem(String[] paths, object value, bool force, bool literalPath);
    internal void SetItem(String[] paths, object value, CmdletProviderContext context);
    private void SetItem(CmdletProvider providerInstance, string path, object value, CmdletProviderContext context);
    internal object SetItemDynamicParameters(string path, object value, CmdletProviderContext context);
    private object SetItemDynamicParameters(CmdletProvider providerInstance, string path, object value, CmdletProviderContext context);
    internal Collection`1<PSObject> ClearItem(String[] paths, bool force, bool literalPath);
    internal void ClearItem(String[] paths, CmdletProviderContext context);
    private void ClearItemPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object ClearItemDynamicParameters(string path, CmdletProviderContext context);
    private object ClearItemDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal void InvokeDefaultAction(String[] paths, bool literalPath);
    internal void InvokeDefaultAction(String[] paths, CmdletProviderContext context);
    private void InvokeDefaultActionPrivate(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal object InvokeDefaultActionDynamicParameters(string path, CmdletProviderContext context);
    private object InvokeDefaultActionDynamicParameters(CmdletProvider providerInstance, string path, CmdletProviderContext context);
    internal PathInfo get_CurrentLocation();
    internal PathInfo GetNamespaceCurrentLocation(string namespaceID);
    internal PathInfo SetLocation(string path);
    internal PathInfo SetLocation(string path, CmdletProviderContext context);
    internal PathInfo SetLocation(string path, CmdletProviderContext context, bool literalPath);
    internal bool IsCurrentLocationOrAncestor(string path, CmdletProviderContext context);
    internal void PushCurrentLocation(string stackName);
    private PathInfo GetNewPushPathInfo();
    internal PathInfo PopLocation(string stackName);
    internal PathInfoStack LocationStack(string stackName);
    internal PathInfoStack SetDefaultLocationStack(string stackName);
    internal string GetParentPath(string path, string root);
    internal string GetParentPath(string path, string root, CmdletProviderContext context);
    internal string GetParentPath(string path, string root, CmdletProviderContext context, bool useDefaultProvider);
    private static string AddQualifier(string path, ProviderInfo provider, string qualifier, bool isProviderQualified, bool isDriveQualified);
    private string RemoveQualifier(string path, ProviderInfo provider, String& qualifier, Boolean& isProviderQualified, Boolean& isDriveQualified);
    internal string GetParentPath(ProviderInfo provider, string path, string root, CmdletProviderContext context);
    internal string GetParentPath(CmdletProvider providerInstance, string path, string root, CmdletProviderContext context);
    internal string NormalizeRelativePath(string path, string basePath);
    internal string NormalizeRelativePath(string path, string basePath, CmdletProviderContext context);
    private static bool IsPathSeparator(char c);
    internal string NormalizeRelativePath(ProviderInfo provider, string path, string basePath, CmdletProviderContext context);
    internal string MakePath(string parent, string child);
    internal string MakePath(string parent, string child, CmdletProviderContext context);
    internal string MakePath(ProviderInfo provider, string parent, string child, CmdletProviderContext context);
    internal string MakePath(CmdletProvider providerInstance, string parent, string child, CmdletProviderContext context);
    internal string GetChildName(string path);
    internal string GetChildName(string path, CmdletProviderContext context);
    internal string GetChildName(string path, CmdletProviderContext context, bool useDefaultProvider);
    private string GetChildName(ProviderInfo provider, string path, CmdletProviderContext context);
    private string GetChildName(CmdletProvider providerInstance, string path, CmdletProviderContext context, bool acceptNonContainerProviders);
    internal Collection`1<PSObject> MoveItem(String[] paths, string destination, bool force, bool literalPath);
    internal void MoveItem(String[] paths, string destination, CmdletProviderContext context);
    private void MoveItemPrivate(CmdletProvider providerInstance, string path, string destination, CmdletProviderContext context);
    internal object MoveItemDynamicParameters(string path, string destination, CmdletProviderContext context);
    private object MoveItemDynamicParameters(CmdletProvider providerInstance, string path, string destination, CmdletProviderContext context);
    internal Collection`1<PSObject> GetProperty(String[] paths, Collection`1<string> providerSpecificPickList, bool literalPath);
    internal void GetProperty(String[] paths, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    private void GetPropertyPrivate(CmdletProvider providerInstance, string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    internal object GetPropertyDynamicParameters(string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    private object GetPropertyDynamicParameters(CmdletProvider providerInstance, string path, Collection`1<string> providerSpecificPickList, CmdletProviderContext context);
    internal Collection`1<PSObject> SetProperty(String[] paths, PSObject property, bool force, bool literalPath);
    internal void SetProperty(String[] paths, PSObject property, CmdletProviderContext context);
    private void SetPropertyPrivate(CmdletProvider providerInstance, string path, PSObject property, CmdletProviderContext context);
    internal object SetPropertyDynamicParameters(string path, PSObject propertyValue, CmdletProviderContext context);
    private object SetPropertyDynamicParameters(CmdletProvider providerInstance, string path, PSObject propertyValue, CmdletProviderContext context);
    internal void ClearProperty(String[] paths, Collection`1<string> propertyToClear, bool force, bool literalPath);
    internal void ClearProperty(String[] paths, Collection`1<string> propertyToClear, CmdletProviderContext context);
    private void ClearPropertyPrivate(CmdletProvider providerInstance, string path, Collection`1<string> propertyToClear, CmdletProviderContext context);
    internal object ClearPropertyDynamicParameters(string path, Collection`1<string> propertyToClear, CmdletProviderContext context);
    private object ClearPropertyDynamicParameters(CmdletProvider providerInstance, string path, Collection`1<string> propertyToClear, CmdletProviderContext context);
    internal Dictionary`2<string, List`1<ProviderInfo>> get_Providers();
    internal Dictionary`2<ProviderInfo, PSDriveInfo> get_ProvidersCurrentWorkingDrive();
    internal void AddSessionStateEntry(SessionStateProviderEntry providerEntry);
    private ProviderInfo AddProvider(Type implementingType, string name, string helpFileName, PSSnapInInfo psSnapIn, PSModuleInfo module);
    private PSDriveInfo ValidateDriveWithProvider(PSDriveInfo drive, CmdletProviderContext context, bool resolvePathIfPossible);
    private PSDriveInfo ValidateDriveWithProvider(DriveCmdletProvider driveProvider, PSDriveInfo drive, CmdletProviderContext context, bool resolvePathIfPossible);
    internal CmdletProvider GetProviderInstance(string providerId);
    internal CmdletProvider GetProviderInstance(ProviderInfo provider);
    internal static ProviderNameAmbiguousException NewAmbiguousProviderName(string name, Collection`1<ProviderInfo> matchingProviders);
    private static string GetPossibleMatches(Collection`1<ProviderInfo> matchingProviders);
    internal DriveCmdletProvider GetDriveProviderInstance(string providerId);
    internal DriveCmdletProvider GetDriveProviderInstance(ProviderInfo provider);
    private static DriveCmdletProvider GetDriveProviderInstance(CmdletProvider providerInstance);
    internal ItemCmdletProvider GetItemProviderInstance(string providerId);
    internal ItemCmdletProvider GetItemProviderInstance(ProviderInfo provider);
    private static ItemCmdletProvider GetItemProviderInstance(CmdletProvider providerInstance);
    internal ContainerCmdletProvider GetContainerProviderInstance(string providerId);
    internal ContainerCmdletProvider GetContainerProviderInstance(ProviderInfo provider);
    private static ContainerCmdletProvider GetContainerProviderInstance(CmdletProvider providerInstance);
    internal NavigationCmdletProvider GetNavigationProviderInstance(ProviderInfo provider);
    private static NavigationCmdletProvider GetNavigationProviderInstance(CmdletProvider providerInstance, bool acceptNonContainerProviders);
    internal bool IsProviderLoaded(string name);
    internal Collection`1<ProviderInfo> GetProvider(string name);
    internal ProviderInfo GetSingleProvider(string name);
    internal Collection`1<ProviderInfo> GetProvider(PSSnapinQualifiedName providerName);
    internal IEnumerable`1<ProviderInfo> get_ProviderList();
    internal void CopyProviders(SessionStateInternal ss);
    internal void InitializeProvider(CmdletProvider providerInstance, ProviderInfo provider, CmdletProviderContext context);
    internal ProviderInfo NewProvider(ProviderInfo provider);
    private ProviderInfo ProviderExists(ProviderInfo provider);
    private void NewProviderEntry(ProviderInfo provider);
    internal void RemoveProvider(string providerName, bool force, CmdletProviderContext context);
    private void RemoveProviderFromCollection(ProviderInfo provider);
    internal int get_ProviderCount();
    internal SessionStateScope GetScopeByID(string scopeID);
    internal SessionStateScope GetScopeByID(int scopeID);
    [CompilerGeneratedAttribute]
internal SessionStateScope get_GlobalScope();
    [CompilerGeneratedAttribute]
internal SessionStateScope get_ModuleScope();
    internal SessionStateScope get_CurrentScope();
    internal void set_CurrentScope(SessionStateScope value);
    internal SessionStateScope get_ScriptScope();
    internal SessionStateScope NewScope(bool isScriptScope);
    internal void RemoveScope(SessionStateScope scope);
    internal static ISecurityDescriptorCmdletProvider GetPermissionProviderInstance(CmdletProvider providerInstance);
    internal Collection`1<PSObject> GetSecurityDescriptor(string path, AccessControlSections sections);
    internal void GetSecurityDescriptor(string path, AccessControlSections sections, CmdletProviderContext context);
    private void GetSecurityDescriptor(CmdletProvider providerInstance, string path, AccessControlSections sections, CmdletProviderContext context);
    internal Collection`1<PSObject> SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor);
    internal void SetSecurityDescriptor(string path, ObjectSecurity securityDescriptor, CmdletProviderContext context);
    private void SetSecurityDescriptor(CmdletProvider providerInstance, string path, ObjectSecurity securityDescriptor, CmdletProviderContext context);
    internal ObjectSecurity NewSecurityDescriptorFromPath(string path, AccessControlSections sections);
    private ObjectSecurity NewSecurityDescriptorFromPath(CmdletProvider providerInstance, string path, AccessControlSections sections);
    internal ObjectSecurity NewSecurityDescriptorOfType(string providerId, string type, AccessControlSections sections);
    internal ObjectSecurity NewSecurityDescriptorOfType(CmdletProvider providerInstance, string type, AccessControlSections sections);
    internal void AddSessionStateEntry(SessionStateVariableEntry entry);
    internal PSVariable GetVariable(string name, CommandOrigin origin);
    internal PSVariable GetVariable(string name);
    internal object GetVariableValue(string name);
    internal object GetVariableValue(string name, object defaultValue);
    internal object GetVariableValue(VariablePath variablePath, CmdletProviderContext& context, SessionStateScope& scope);
    internal object GetVariableValueFromProvider(VariablePath variablePath, CmdletProviderContext& context, SessionStateScope& scope, CommandOrigin origin);
    internal PSVariable GetVariableItem(VariablePath variablePath, SessionStateScope& scope, CommandOrigin origin);
    internal PSVariable GetVariableItem(VariablePath variablePath, SessionStateScope& scope);
    internal PSVariable GetVariableAtScope(string name, string scopeID);
    internal object GetVariableValueAtScope(string name, string scopeID);
    internal object GetAutomaticVariableValue(AutomaticVariable variable);
    internal void SetVariableValue(string name, object newValue, CommandOrigin origin);
    internal void SetVariableValue(string name, object newValue);
    internal object SetVariable(PSVariable variable, bool force, CommandOrigin origin);
    internal object SetVariable(VariablePath variablePath, object newValue, bool asValue, CommandOrigin origin);
    internal object SetVariable(VariablePath variablePath, object newValue, bool asValue, bool force, CommandOrigin origin);
    internal object SetVariableAtScope(PSVariable variable, string scopeID, bool force, CommandOrigin origin);
    internal object NewVariable(PSVariable variable, bool force);
    internal object NewVariableAtScope(PSVariable variable, string scopeID, bool force);
    internal void RemoveVariable(string name);
    internal void RemoveVariable(string name, bool force);
    internal void RemoveVariable(PSVariable variable);
    internal void RemoveVariable(PSVariable variable, bool force);
    internal void RemoveVariableAtScope(string name, string scopeID);
    internal void RemoveVariableAtScope(string name, string scopeID, bool force);
    internal void RemoveVariableAtScope(PSVariable variable, string scopeID);
    internal void RemoveVariableAtScope(PSVariable variable, string scopeID, bool force);
    internal IDictionary`2<string, PSVariable> GetVariableTable();
    private static void GetScopeVariableTable(SessionStateScope scope, Dictionary`2<string, PSVariable> result, bool includePrivate);
    internal IDictionary`2<string, PSVariable> GetVariableTableAtScope(string scopeID);
    [CompilerGeneratedAttribute]
internal List`1<PSVariable> get_ExportedVariables();
}
internal class System.Management.Automation.SessionStateScope : object {
    [CompilerGeneratedAttribute]
private SessionStateScope <Parent>k__BackingField;
    [CompilerGeneratedAttribute]
private CommandOrigin <ScopeOrigin>k__BackingField;
    private SessionStateScope _scriptScope;
    [CompilerGeneratedAttribute]
private Version <StrictModeVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private MutableTuple <LocalsTuple>k__BackingField;
    private Stack`1<MutableTuple> _dottedScopes;
    private TypeResolutionState _typeResolutionState;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, Type> <TypeTable>k__BackingField;
    private Dictionary`2<string, PSDriveInfo> _drives;
    private Dictionary`2<string, PSDriveInfo> _automountedDrives;
    private Dictionary`2<string, PSVariable> _variables;
    private Dictionary`2<string, AliasInfo> _alias;
    private Dictionary`2<string, FunctionInfo> _functions;
    private Dictionary`2<string, FunctionInfo> _allScopeFunctions;
    private Dictionary`2<string, List`1<CmdletInfo>> _cmdlets;
    private Dictionary`2<string, List`1<CmdletInfo>> _allScopeCmdlets;
    private static PSVariable s_trueVar;
    private static PSVariable s_falseVar;
    private static NullVariable s_nullVar;
    private Dictionary`2<string, List`1<string>> _commandsToAliasesCache;
    internal SessionStateScope Parent { get; internal set; }
    internal CommandOrigin ScopeOrigin { get; internal set; }
    internal SessionStateScope ScriptScope { get; internal set; }
    internal Version StrictModeVersion { get; internal set; }
    internal MutableTuple LocalsTuple { get; internal set; }
    internal Stack`1<MutableTuple> DottedScopes { get; }
    internal IEnumerable`1<PSDriveInfo> Drives { get; }
    internal IDictionary`2<string, PSVariable> Variables { get; }
    internal IEnumerable`1<AliasInfo> AliasTable { get; }
    internal Dictionary`2<string, FunctionInfo> FunctionTable { get; }
    internal Dictionary`2<string, List`1<CmdletInfo>> CmdletTable { get; }
    internal TypeResolutionState TypeResolutionState { get; internal set; }
    internal IDictionary`2<string, Type> TypeTable { get; private set; }
    internal SessionStateScope(SessionStateScope parentScope);
    private static SessionStateScope();
    [CompilerGeneratedAttribute]
internal SessionStateScope get_Parent();
    [CompilerGeneratedAttribute]
internal void set_Parent(SessionStateScope value);
    [CompilerGeneratedAttribute]
internal CommandOrigin get_ScopeOrigin();
    [CompilerGeneratedAttribute]
internal void set_ScopeOrigin(CommandOrigin value);
    internal SessionStateScope get_ScriptScope();
    internal void set_ScriptScope(SessionStateScope value);
    [CompilerGeneratedAttribute]
internal Version get_StrictModeVersion();
    [CompilerGeneratedAttribute]
internal void set_StrictModeVersion(Version value);
    [CompilerGeneratedAttribute]
internal MutableTuple get_LocalsTuple();
    [CompilerGeneratedAttribute]
internal void set_LocalsTuple(MutableTuple value);
    internal Stack`1<MutableTuple> get_DottedScopes();
    internal void NewDrive(PSDriveInfo newDrive);
    internal void RemoveDrive(PSDriveInfo drive);
    internal void RemoveAllDrives();
    internal PSDriveInfo GetDrive(string name);
    internal IEnumerable`1<PSDriveInfo> get_Drives();
    internal IDictionary`2<string, PSVariable> get_Variables();
    internal PSVariable GetVariable(string name, CommandOrigin origin);
    internal PSVariable GetVariable(string name);
    internal bool TryGetVariable(string name, CommandOrigin origin, bool fromNewOrSet, PSVariable& variable);
    internal object GetAutomaticVariableValue(AutomaticVariable variable);
    internal PSVariable SetVariable(string name, object value, bool asValue, bool force, SessionStateInternal sessionState, CommandOrigin origin, bool fastPath);
    internal void SetVariableForce(PSVariable variableToSet, SessionStateInternal sessionState);
    internal PSVariable NewVariable(PSVariable newVariable, bool force, SessionStateInternal sessionState);
    internal void RemoveVariable(string name, bool force);
    internal bool TrySetLocalParameterValue(string name, object value);
    internal bool TryGetLocalVariableFromTuple(string name, bool fromNewOrSet, PSVariable& result);
    internal IEnumerable`1<AliasInfo> get_AliasTable();
    internal AliasInfo GetAlias(string name);
    internal AliasInfo SetAliasValue(string name, string value, ExecutionContext context, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasValue(string name, string value, ScopedItemOptions options, ExecutionContext context, bool force, CommandOrigin origin);
    internal AliasInfo SetAliasItem(AliasInfo aliasToSet, bool force, CommandOrigin origin);
    internal void RemoveAlias(string name, bool force);
    internal Dictionary`2<string, FunctionInfo> get_FunctionTable();
    internal FunctionInfo GetFunction(string name);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, bool force, CommandOrigin origin, ExecutionContext context);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, bool force, CommandOrigin origin, ExecutionContext context);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, ExecutionContext context);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, ExecutionContext context, string helpFile);
    internal FunctionInfo SetFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, bool force, CommandOrigin origin, ExecutionContext context, string helpFile, Func`7<string, ScriptBlock, FunctionInfo, ScopedItemOptions, ExecutionContext, string, FunctionInfo> functionFactory);
    internal void RemoveFunction(string name, bool force);
    internal Dictionary`2<string, List`1<CmdletInfo>> get_CmdletTable();
    internal CmdletInfo GetCmdlet(string name);
    internal CmdletInfo AddCmdletToCache(string name, CmdletInfo cmdlet, CommandOrigin origin, ExecutionContext context);
    internal void RemoveCmdlet(string name, int index, bool force);
    internal void RemoveCmdletEntry(string name, bool force);
    internal TypeResolutionState get_TypeResolutionState();
    internal void set_TypeResolutionState(TypeResolutionState value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, Type> get_TypeTable();
    [CompilerGeneratedAttribute]
private void set_TypeTable(IDictionary`2<string, Type> value);
    internal void AddType(string name, Type type);
    internal Type LookupType(string name);
    private static bool IsFunctionOptionSet(FunctionInfo function, ScopedItemOptions options);
    private static FunctionInfo CreateFunction(string name, ScriptBlock function, FunctionInfo originalFunction, ScopedItemOptions options, ExecutionContext context, string helpFile);
    private Dictionary`2<string, PSDriveInfo> GetDrives();
    private Dictionary`2<string, PSDriveInfo> GetAutomountedDrives();
    private Dictionary`2<string, PSVariable> GetPrivateVariables();
    internal void AddSessionStateScopeDefaultVariables();
    private Dictionary`2<string, AliasInfo> GetAliases();
    private Dictionary`2<string, FunctionInfo> GetFunctions();
    private Dictionary`2<string, FunctionInfo> GetAllScopeFunctions();
    [IteratorStateMachineAttribute("System.Management.Automation.SessionStateScope/<GetAliasesByCommandName>d__95")]
internal IEnumerable`1<string> GetAliasesByCommandName(string command);
    private void AddAliasToCache(string alias, string value);
    private void RemoveAliasFromCache(string alias, string value);
    private void CheckVariableChangeInConstrainedLanguage(PSVariable variable);
}
internal class System.Management.Automation.SessionStateScopeEnumerator : object {
    private SessionStateScope _initialScope;
    private SessionStateScope _currentEnumeratedScope;
    private SessionStateScope System.Collections.Generic.IEnumerator<System.Management.Automation.SessionStateScope>.Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal SessionStateScopeEnumerator(SessionStateScope scope);
    public sealed virtual bool MoveNext();
    public sealed virtual void Reset();
    private sealed virtual override SessionStateScope System.Collections.Generic.IEnumerator<System.Management.Automation.SessionStateScope>.get_Current();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
    private sealed virtual override IEnumerator`1<SessionStateScope> System.Collections.Generic.IEnumerable<System.Management.Automation.SessionStateScope>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual void Dispose();
}
public class System.Management.Automation.SessionStateUnauthorizedAccessException : SessionStateException {
    internal SessionStateUnauthorizedAccessException(string itemName, SessionStateCategory sessionStateCategory, string errorIdAndResourceId, string resourceStr);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected SessionStateUnauthorizedAccessException(SerializationInfo info, StreamingContext context);
    public SessionStateUnauthorizedAccessException(string message);
    public SessionStateUnauthorizedAccessException(string message, Exception innerException);
}
internal static class System.Management.Automation.SessionStateUtilities : object {
    internal static Collection`1<T> ConvertArrayToCollection(T[] array);
    internal static bool CollectionContainsValue(IEnumerable collection, object value, IComparer comparer);
    internal static Collection`1<WildcardPattern> CreateWildcardsFromStrings(IEnumerable`1<string> globPatterns, WildcardOptions options);
    internal static bool MatchesAnyWildcardPattern(string text, IEnumerable`1<WildcardPattern> patterns, bool defaultValue);
    internal static FileMode GetFileModeFromOpenMode(OpenMode openMode);
}
public class System.Management.Automation.SettingValueExceptionEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private bool <ShouldThrow>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    public bool ShouldThrow { get; public set; }
    public Exception Exception { get; }
    internal SettingValueExceptionEventArgs(Exception exception);
    [CompilerGeneratedAttribute]
public bool get_ShouldThrow();
    [CompilerGeneratedAttribute]
public void set_ShouldThrow(bool value);
    [CompilerGeneratedAttribute]
public Exception get_Exception();
}
public class System.Management.Automation.SetValueException : ExtendedTypeSystemException {
    public SetValueException(string message);
    public SetValueException(string message, Exception innerException);
    internal SetValueException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected SetValueException(SerializationInfo info, StreamingContext context);
}
public class System.Management.Automation.SetValueInvocationException : SetValueException {
    public SetValueInvocationException(string message);
    public SetValueInvocationException(string message, Exception innerException);
    internal SetValueInvocationException(string errorId, Exception innerException, string resourceString, Object[] arguments);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected SetValueInvocationException(SerializationInfo info, StreamingContext context);
}
internal enum System.Management.Automation.Severity : Enum {
    public int value__;
    public static Severity None;
    public static Severity Critical;
    public static Severity Error;
    public static Severity Warning;
    public static Severity Informational;
}
[FlagsAttribute]
public enum System.Management.Automation.ShouldProcessReason : Enum {
    public int value__;
    public static ShouldProcessReason None;
    public static ShouldProcessReason WhatIf;
}
public class System.Management.Automation.Signature : object {
    private string _path;
    private SignatureStatus _status;
    private UInt32 _win32Error;
    private X509Certificate2 _signerCert;
    private string _statusMessage;
    private X509Certificate2 _timeStamperCert;
    internal static Nullable`1<bool> CatalogApiAvailable;
    [CompilerGeneratedAttribute]
private SignatureType <SignatureType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsOSBinary>k__BackingField;
    public X509Certificate2 SignerCertificate { get; }
    public X509Certificate2 TimeStamperCertificate { get; }
    public SignatureStatus Status { get; }
    public string StatusMessage { get; }
    public string Path { get; }
    public SignatureType SignatureType { get; internal set; }
    public bool IsOSBinary { get; internal set; }
    internal Signature(string filePath, UInt32 error, X509Certificate2 signer, X509Certificate2 timestamper);
    internal Signature(string filePath, X509Certificate2 signer);
    internal Signature(string filePath, UInt32 error, X509Certificate2 signer);
    internal Signature(string filePath, UInt32 error);
    public X509Certificate2 get_SignerCertificate();
    public X509Certificate2 get_TimeStamperCertificate();
    public SignatureStatus get_Status();
    public string get_StatusMessage();
    public string get_Path();
    [CompilerGeneratedAttribute]
public SignatureType get_SignatureType();
    [CompilerGeneratedAttribute]
internal void set_SignatureType(SignatureType value);
    [CompilerGeneratedAttribute]
public bool get_IsOSBinary();
    [CompilerGeneratedAttribute]
internal void set_IsOSBinary(bool value);
    private void Init(string filePath, X509Certificate2 signer, UInt32 error, X509Certificate2 timestamper);
    private static SignatureStatus GetSignatureStatusFromWin32Error(UInt32 error);
    private static string GetSignatureStatusMessage(SignatureStatus status, UInt32 error, string filePath);
}
internal static class System.Management.Automation.SignatureHelper : object {
    private static Guid WINTRUST_ACTION_GENERIC_VERIFY_V2;
    [TraceSourceAttribute("SignatureHelper", "tracer for SignatureHelper")]
private static PSTraceSource s_tracer;
    private static SignatureHelper();
    internal static Signature SignFile(SigningOption option, string fileName, X509Certificate2 certificate, string timeStampServerUrl, string hashAlgorithm);
    internal static Signature GetSignature(string fileName, Byte[] fileContent);
    private static Signature GetSignatureFromMSSecurityExtensions(string filename);
    private static UInt32 GetErrorFromSignatureState(SignatureState signatureState);
    private static Signature GetSignatureFromWinVerifyTrust(string fileName, Byte[] fileContent);
    private static UInt32 GetWinTrustData(string fileName, Byte[] fileContent, WINTRUST_DATA& wtData);
    private static X509Certificate2 GetCertFromChain(IntPtr pSigner);
    private static Signature GetSignatureFromWintrustData(string filePath, UInt32 error, WINTRUST_DATA wtd);
    private static bool TryGetProviderSigner(IntPtr wvtStateData, IntPtr& pProvSigner, X509Certificate2& timestamperCert);
    private static UInt32 GetLastWin32Error();
}
public enum System.Management.Automation.SignatureStatus : Enum {
    public int value__;
    public static SignatureStatus Valid;
    public static SignatureStatus UnknownError;
    public static SignatureStatus NotSigned;
    public static SignatureStatus HashMismatch;
    public static SignatureStatus NotTrusted;
    public static SignatureStatus NotSupportedFileFormat;
    public static SignatureStatus Incompatible;
}
public enum System.Management.Automation.SignatureType : Enum {
    public int value__;
    public static SignatureType None;
    public static SignatureType Authenticode;
    public static SignatureType Catalog;
}
public enum System.Management.Automation.SigningOption : Enum {
    public int value__;
    public static SigningOption AddOnlyCertificate;
    public static SigningOption AddFullCertificateChain;
    public static SigningOption AddFullCertificateChainExceptRoot;
    public static SigningOption Default;
}
internal class System.Management.Automation.SingleShellProviderNames : ProviderNames {
    internal string Environment { get; }
    internal string Certificate { get; }
    internal string Variable { get; }
    internal string Alias { get; }
    internal string Function { get; }
    internal string FileSystem { get; }
    internal string Registry { get; }
    internal virtual string get_Environment();
    internal virtual string get_Certificate();
    internal virtual string get_Variable();
    internal virtual string get_Alias();
    internal virtual string get_Function();
    internal virtual string get_FileSystem();
    internal virtual string get_Registry();
}
internal static class System.Management.Automation.SpecialVariables : object {
    internal static string HistorySize;
    internal static VariablePath HistorySizeVarPath;
    internal static string MyInvocation;
    internal static VariablePath MyInvocationVarPath;
    internal static string OFS;
    internal static VariablePath OFSVarPath;
    internal static string PSStyle;
    internal static VariablePath PSStyleVarPath;
    internal static string OutputEncoding;
    internal static VariablePath OutputEncodingVarPath;
    internal static string VerboseHelpErrors;
    internal static VariablePath VerboseHelpErrorsVarPath;
    internal static string LogEngineHealthEvent;
    internal static VariablePath LogEngineHealthEventVarPath;
    internal static string LogEngineLifecycleEvent;
    internal static VariablePath LogEngineLifecycleEventVarPath;
    internal static string LogCommandHealthEvent;
    internal static VariablePath LogCommandHealthEventVarPath;
    internal static string LogCommandLifecycleEvent;
    internal static VariablePath LogCommandLifecycleEventVarPath;
    internal static string LogProviderHealthEvent;
    internal static VariablePath LogProviderHealthEventVarPath;
    internal static string LogProviderLifecycleEvent;
    internal static VariablePath LogProviderLifecycleEventVarPath;
    internal static string LogSettingsEvent;
    internal static VariablePath LogSettingsEventVarPath;
    internal static string PSLogUserData;
    internal static VariablePath PSLogUserDataPath;
    internal static string NestedPromptLevel;
    internal static VariablePath NestedPromptCounterVarPath;
    internal static string CurrentlyExecutingCommand;
    internal static VariablePath CurrentlyExecutingCommandVarPath;
    internal static string PSBoundParameters;
    internal static VariablePath PSBoundParametersVarPath;
    internal static string Matches;
    internal static VariablePath MatchesVarPath;
    internal static string LastExitCode;
    internal static VariablePath LastExitCodeVarPath;
    internal static string PSDebugContext;
    internal static VariablePath PSDebugContextVarPath;
    internal static string StackTrace;
    internal static VariablePath StackTraceVarPath;
    internal static string FirstToken;
    internal static VariablePath FirstTokenVarPath;
    internal static string LastToken;
    internal static VariablePath LastTokenVarPath;
    internal static string PSItem;
    internal static string Underbar;
    internal static VariablePath UnderbarVarPath;
    internal static string Question;
    internal static VariablePath QuestionVarPath;
    internal static string Args;
    internal static VariablePath ArgsVarPath;
    internal static string This;
    internal static VariablePath ThisVarPath;
    internal static string Input;
    internal static VariablePath InputVarPath;
    internal static string PSCmdlet;
    internal static VariablePath PSCmdletVarPath;
    internal static string Error;
    internal static VariablePath ErrorVarPath;
    internal static string EventError;
    internal static VariablePath EventErrorVarPath;
    internal static string PathExt;
    internal static VariablePath PathExtVarPath;
    internal static string PSEmailServer;
    internal static VariablePath PSEmailServerVarPath;
    internal static string PSDefaultParameterValues;
    internal static VariablePath PSDefaultParameterValuesVarPath;
    internal static string PSScriptRoot;
    internal static VariablePath PSScriptRootVarPath;
    internal static string PSCommandPath;
    internal static VariablePath PSCommandPathVarPath;
    internal static string PSSenderInfo;
    internal static VariablePath PSSenderInfoVarPath;
    internal static string foreach;
    internal static VariablePath foreachVarPath;
    internal static string switch;
    internal static VariablePath switchVarPath;
    internal static string pwd;
    internal static VariablePath PWDVarPath;
    internal static string Null;
    internal static VariablePath NullVarPath;
    internal static string True;
    internal static VariablePath TrueVarPath;
    internal static string False;
    internal static VariablePath FalseVarPath;
    internal static string PSModuleAutoLoading;
    internal static VariablePath PSModuleAutoLoadingPreferenceVarPath;
    internal static string IsLinux;
    internal static VariablePath IsLinuxPath;
    internal static string IsMacOS;
    internal static VariablePath IsMacOSPath;
    internal static string IsWindows;
    internal static VariablePath IsWindowsPath;
    internal static string IsCoreCLR;
    internal static VariablePath IsCoreCLRPath;
    internal static string DebugPreference;
    internal static VariablePath DebugPreferenceVarPath;
    internal static string ErrorActionPreference;
    internal static VariablePath ErrorActionPreferenceVarPath;
    internal static string ProgressPreference;
    internal static VariablePath ProgressPreferenceVarPath;
    internal static string VerbosePreference;
    internal static VariablePath VerbosePreferenceVarPath;
    internal static string WarningPreference;
    internal static VariablePath WarningPreferenceVarPath;
    internal static string WhatIfPreference;
    internal static VariablePath WhatIfPreferenceVarPath;
    internal static string ConfirmPreference;
    internal static VariablePath ConfirmPreferenceVarPath;
    internal static string InformationPreference;
    internal static VariablePath InformationPreferenceVarPath;
    internal static string PSNativeCommandUseErrorActionPreference;
    internal static VariablePath PSNativeCommandUseErrorActionPreferenceVarPath;
    internal static string NativeArgumentPassing;
    internal static VariablePath NativeArgumentPassingVarPath;
    internal static string ErrorView;
    internal static VariablePath ErrorViewVarPath;
    internal static string PSSessionConfigurationName;
    internal static VariablePath PSSessionConfigurationNameVarPath;
    internal static string PSSessionApplicationName;
    internal static VariablePath PSSessionApplicationNameVarPath;
    internal static string ExecutionContext;
    internal static string Home;
    internal static string Host;
    internal static string PID;
    internal static string PSCulture;
    internal static string PSHome;
    internal static string PSUICulture;
    internal static string PSVersionTable;
    internal static string PSEdition;
    internal static string ShellId;
    internal static string EnabledExperimentalFeatures;
    internal static String[] AutomaticVariables;
    internal static Type[] AutomaticVariableTypes;
    internal static String[] PreferenceVariables;
    internal static Type[] PreferenceVariableTypes;
    internal static Dictionary`2<string, Type> AllScopeVariables;
    private static HashSet`1<string> s_classMethodsAccessibleVariables;
    private static SpecialVariables();
    internal static bool IsUnderbar(string name);
    internal static bool IsImplicitVariableAccessibleInClassMethod(VariablePath variablePath);
}
[FlagsAttribute]
public enum System.Management.Automation.SplitOptions : Enum {
    public int value__;
    public static SplitOptions SimpleMatch;
    public static SplitOptions RegexMatch;
    public static SplitOptions CultureInvariant;
    public static SplitOptions IgnorePatternWhitespace;
    public static SplitOptions Multiline;
    public static SplitOptions Singleline;
    public static SplitOptions IgnoreCase;
    public static SplitOptions ExplicitCapture;
}
internal class System.Management.Automation.StandaloneRunspaceDebugger : NestedRunspaceDebugger {
    public StandaloneRunspaceDebugger(Runspace runspace);
    protected virtual DebuggerCommandResults HandleCallStack(PSDataCollection`1<PSObject> output);
    protected virtual void HandleDebuggerStop(object sender, DebuggerStopEventArgs e);
    private object DrainAndBlockRemoteOutput();
    private static void RestoreRemoteOutput(object runningCmd);
}
internal abstract class System.Management.Automation.StartableJob : Job {
    internal StartableJob(string commandName, string jobName);
    internal abstract virtual void StartJob();
}
public class System.Management.Automation.StartRunspaceDebugProcessingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Runspace <Runspace>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseDefaultProcessing>k__BackingField;
    public Runspace Runspace { get; }
    public bool UseDefaultProcessing { get; public set; }
    public StartRunspaceDebugProcessingEventArgs(Runspace runspace);
    [CompilerGeneratedAttribute]
public Runspace get_Runspace();
    [CompilerGeneratedAttribute]
public bool get_UseDefaultProcessing();
    [CompilerGeneratedAttribute]
public void set_UseDefaultProcessing(bool value);
}
public class System.Management.Automation.SteppablePipeline : object {
    private PipelineProcessor _pipeline;
    private ExecutionContext _context;
    private bool _expectInput;
    private bool _disposed;
    internal SteppablePipeline(ExecutionContext context, PipelineProcessor pipeline);
    public void Begin(bool expectInput);
    public void Begin(bool expectInput, EngineIntrinsics contextToRedirectTo);
    public void Begin(InternalCommand command);
    private void Begin(bool expectInput, ICommandRuntime commandRuntime);
    public Array Process(object input);
    public Array Process(PSObject input);
    public Array Process();
    public Array End();
    public void Clean();
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.StopUpstreamCommandsException : FlowControlException {
    [CompilerGeneratedAttribute]
private CommandProcessorBase <RequestingCommandProcessor>k__BackingField;
    public CommandProcessorBase RequestingCommandProcessor { get; }
    public StopUpstreamCommandsException(InternalCommand requestingCommand);
    [CompilerGeneratedAttribute]
public CommandProcessorBase get_RequestingCommandProcessor();
}
internal static class System.Management.Automation.StringLiterals : object {
    internal static string ProviderPathSeparator;
    internal static char DefaultPathSeparator;
    internal static string DefaultPathSeparatorString;
    internal static char AlternatePathSeparator;
    internal static string AlternatePathSeparatorString;
    internal static string DefaultRemotePathPrefix;
    internal static string AlternateRemotePathPrefix;
    internal static string HomePath;
    internal static string Global;
    internal static string Local;
    internal static string Private;
    internal static string Script;
    internal static string SessionState;
    internal static string PowerShellScriptFileExtension;
    internal static string PowerShellModuleFileExtension;
    internal static string PowerShellMofFileExtension;
    internal static string PowerShellCmdletizationFileExtension;
    internal static string PowerShellDISCFileExtension;
    internal static string PowerShellRoleCapabilityFileExtension;
    internal static string PowerShellDataFileExtension;
    internal static string PowerShellILAssemblyExtension;
    internal static string PowerShellNgenAssemblyExtension;
    internal static string PowerShellILExecutableExtension;
    internal static string PowerShellConsoleFileExtension;
    internal static char CommandVerbNounSeparator;
    internal static string DefaultCommandVerb;
    internal static string HelpFileExtension;
    internal static string DollarNull;
    internal static string Null;
    internal static string False;
    internal static string True;
    internal static char EscapeCharacter;
    internal static string DefaultCmdletAdapter;
    private static StringLiterals();
}
internal static class System.Management.Automation.StringOps : object {
    internal static string Add(string lhs, string rhs);
    internal static string Add(string lhs, char rhs);
    internal static string Multiply(string s, int times);
    internal static string FormatOperator(string formatString, object formatArgs);
    internal static int Compare(string strA, string strB, CultureInfo culture, CompareOptions option);
    internal static bool Equals(string strA, string strB, CultureInfo culture, CompareOptions option);
}
internal static class System.Management.Automation.StringToBase64Converter : object {
    internal static string StringToBase64String(string input);
    internal static string Base64ToString(string base64);
    internal static Object[] Base64ToArgsConverter(string base64);
}
internal static class System.Management.Automation.StringToMinishellStreamConverter : object {
    internal static string OutputStream;
    internal static string ErrorStream;
    internal static string DebugStream;
    internal static string VerboseStream;
    internal static string WarningStream;
    internal static string ProgressStream;
    internal static string InformationStream;
    internal static MinishellStream ToMinishellStream(string stream);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Subsystem.DSC.ICrossPlatformDsc {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.FunctionsToDefine { get; }
    private sealed virtual override Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.get_FunctionsToDefine();
    public abstract virtual void LoadDefaultKeywords(Collection`1<Exception> errors);
    public abstract virtual void ClearCache();
    public abstract virtual string GetDSCResourceUsageString(DynamicKeyword keyword);
    public abstract virtual bool IsSystemResourceName(string name);
    public abstract virtual bool IsDefaultModuleNameForMetaConfigResource(string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Feedback.FeedbackContext : object {
    [CompilerGeneratedAttribute]
private FeedbackTrigger <Trigger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandLine>k__BackingField;
    [CompilerGeneratedAttribute]
private Ast <CommandLineAst>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <CommandLineTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private PathInfo <CurrentLocation>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ErrorRecord <LastError>k__BackingField;
    public FeedbackTrigger Trigger { get; }
    public string CommandLine { get; }
    public Ast CommandLineAst { get; }
    public IReadOnlyList`1<Token> CommandLineTokens { get; }
    public PathInfo CurrentLocation { get; }
    [NullableAttribute("2")]
public ErrorRecord LastError { get; }
    public FeedbackContext(FeedbackTrigger trigger, string commandLine, PathInfo cwd, ErrorRecord lastError);
    public FeedbackContext(FeedbackTrigger trigger, Ast commandLineAst, Token[] commandLineTokens, PathInfo cwd, ErrorRecord lastError);
    [CompilerGeneratedAttribute]
public FeedbackTrigger get_Trigger();
    [CompilerGeneratedAttribute]
public string get_CommandLine();
    [CompilerGeneratedAttribute]
public Ast get_CommandLineAst();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Token> get_CommandLineTokens();
    [CompilerGeneratedAttribute]
public PathInfo get_CurrentLocation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ErrorRecord get_LastError();
}
public enum System.Management.Automation.Subsystem.Feedback.FeedbackDisplayLayout : Enum {
    public int value__;
    public static FeedbackDisplayLayout Portrait;
    public static FeedbackDisplayLayout Landscape;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Management.Automation.Subsystem.Feedback.FeedbackHub : object {
    public static List`1<FeedbackResult> GetFeedback(Runspace runspace);
    public static List`1<FeedbackResult> GetFeedback(Runspace runspace, int millisecondsTimeout);
    private static bool CanSkip(IEnumerable`1<IFeedbackProvider> providers);
    private static FeedbackResult GetBuiltInFeedback(IFeedbackProvider builtInFeedback, LocalRunspace localRunspace, FeedbackContext feedbackContext, bool questionMarkValue);
    private static bool TryGetFeedbackContext(ExecutionContext executionContext, bool questionMarkValue, HistoryInfo lastHistory, FeedbackContext& feedbackContext);
    private static bool IsPureComment(Token[] tokens);
    private static bool TryGetLastError(ExecutionContext context, HistoryInfo lastHistory, ErrorRecord& lastError);
    private static Func`2<object, FeedbackResult> GetCallBack(FeedbackContext feedbackContext, CancellationTokenSource cancellationSource);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Feedback.FeedbackItem : object {
    [NullableAttribute("1")]
[CompilerGeneratedAttribute]
private string <Header>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Footer>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<string> <RecommendedActions>k__BackingField;
    [CompilerGeneratedAttribute]
private FeedbackDisplayLayout <Layout>k__BackingField;
    [CompilerGeneratedAttribute]
private FeedbackItem <Next>k__BackingField;
    [NullableAttribute("1")]
public string Header { get; }
    public string Footer { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<string> RecommendedActions { get; }
    public FeedbackDisplayLayout Layout { get; }
    public FeedbackItem Next { get; public set; }
    [NullableContextAttribute("1")]
public FeedbackItem(string header, List`1<string> actions);
    [NullableContextAttribute("1")]
public FeedbackItem(string header, List`1<string> actions, FeedbackDisplayLayout layout);
    [NullableContextAttribute("1")]
public FeedbackItem(string header, List`1<string> actions, string footer, FeedbackDisplayLayout layout);
    [NullableContextAttribute("1")]
[CompilerGeneratedAttribute]
public string get_Header();
    [CompilerGeneratedAttribute]
public string get_Footer();
    [CompilerGeneratedAttribute]
public List`1<string> get_RecommendedActions();
    [CompilerGeneratedAttribute]
public FeedbackDisplayLayout get_Layout();
    [CompilerGeneratedAttribute]
public FeedbackItem get_Next();
    [CompilerGeneratedAttribute]
public void set_Next(FeedbackItem value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Feedback.FeedbackResult : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private FeedbackItem <Item>k__BackingField;
    public Guid Id { get; }
    public string Name { get; }
    public FeedbackItem Item { get; }
    internal FeedbackResult(Guid id, string name, FeedbackItem item);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public FeedbackItem get_Item();
}
[FlagsAttribute]
public enum System.Management.Automation.Subsystem.Feedback.FeedbackTrigger : Enum {
    public int value__;
    public static FeedbackTrigger Success;
    public static FeedbackTrigger CommandNotFound;
    public static FeedbackTrigger Error;
    public static FeedbackTrigger All;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.Subsystem.Feedback.GeneralCommandErrorFeedback : object {
    private Guid _guid;
    public Guid Id { get; }
    public string Name { get; }
    public string Description { get; }
    public sealed virtual Guid get_Id();
    public sealed virtual string get_Name();
    public sealed virtual string get_Description();
    public sealed virtual FeedbackItem GetFeedback(FeedbackContext context, CancellationToken token);
}
public interface System.Management.Automation.Subsystem.Feedback.IFeedbackProvider {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.FunctionsToDefine { get; }
    public FeedbackTrigger Trigger { get; }
    private sealed virtual override Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.get_FunctionsToDefine();
    public virtual FeedbackTrigger get_Trigger();
    [NullableContextAttribute("1")]
public abstract virtual FeedbackItem GetFeedback(FeedbackContext context, CancellationToken token);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[ExperimentalAttribute("PSSubsystemPluginModel", "2")]
[CmdletAttribute("Get", "PSSubsystem")]
[OutputTypeAttribute("System.Management.Automation.Subsystem.SubsystemInfo")]
public class System.Management.Automation.Subsystem.GetPSSubsystemCommand : PSCmdlet {
    [NullableAttribute("1")]
private static string AllSet;
    [NullableAttribute("1")]
private static string TypeSet;
    [NullableAttribute("1")]
private static string KindSet;
    [CompilerGeneratedAttribute]
private SubsystemKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SubsystemType>k__BackingField;
    [ParameterAttribute]
public SubsystemKind Kind { get; public set; }
    [ParameterAttribute]
public Type SubsystemType { get; public set; }
    [CompilerGeneratedAttribute]
public SubsystemKind get_Kind();
    [CompilerGeneratedAttribute]
public void set_Kind(SubsystemKind value);
    [CompilerGeneratedAttribute]
public Type get_SubsystemType();
    [CompilerGeneratedAttribute]
public void set_SubsystemType(Type value);
    protected virtual void ProcessRecord();
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Subsystem.ISubsystem {
    public Guid Id { get; }
    public string Name { get; }
    public string Description { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<string, string> FunctionsToDefine { get; }
    public abstract virtual Guid get_Id();
    public abstract virtual string get_Name();
    public abstract virtual string get_Description();
    public abstract virtual Dictionary`2<string, string> get_FunctionsToDefine();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Management.Automation.Subsystem.Prediction.CommandPrediction : object {
    public static Task`1<List`1<PredictionResult>> PredictInputAsync(PredictionClient client, Ast ast, Token[] astTokens);
    [AsyncStateMachineAttribute("System.Management.Automation.Subsystem.Prediction.CommandPrediction/<PredictInputAsync>d__1")]
public static Task`1<List`1<PredictionResult>> PredictInputAsync(PredictionClient client, Ast ast, Token[] astTokens, int millisecondsTimeout);
    public static void OnCommandLineAccepted(PredictionClient client, IReadOnlyList`1<string> history);
    public static void OnCommandLineExecuted(PredictionClient client, string commandLine, bool success);
    public static void OnSuggestionDisplayed(PredictionClient client, Guid predictorId, UInt32 session, int countOrIndex);
    public static void OnSuggestionAccepted(PredictionClient client, Guid predictorId, UInt32 session, string suggestionText);
    [CompilerGeneratedAttribute]
internal static Func`2<object, PredictionResult> <PredictInputAsync>g__GetCallBack|1_0(PredictionClient client, PredictionContext context, CancellationTokenSource cancellationSource);
    [CompilerGeneratedAttribute]
internal static Action`1<ICommandPredictor> <OnCommandLineAccepted>g__GetCallBack|2_0(PredictionClient client, IReadOnlyList`1<string> history);
    [CompilerGeneratedAttribute]
internal static Action`1<ICommandPredictor> <OnCommandLineExecuted>g__GetCallBack|3_0(PredictionClient client, string commandLine, bool success);
    [CompilerGeneratedAttribute]
internal static Action`1<ICommandPredictor> <OnSuggestionDisplayed>g__GetCallBack|4_0(PredictionClient client, UInt32 session, int countOrIndex);
    [CompilerGeneratedAttribute]
internal static Action`1<ICommandPredictor> <OnSuggestionAccepted>g__GetCallBack|5_0(PredictionClient client, UInt32 session, string suggestionText);
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Subsystem.Prediction.ICommandPredictor {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.FunctionsToDefine { get; }
    private sealed virtual override Dictionary`2<string, string> System.Management.Automation.Subsystem.ISubsystem.get_FunctionsToDefine();
    public abstract virtual SuggestionPackage GetSuggestion(PredictionClient client, PredictionContext context, CancellationToken cancellationToken);
    public virtual bool CanAcceptFeedback(PredictionClient client, PredictorFeedbackKind feedback);
    public virtual void OnSuggestionDisplayed(PredictionClient client, UInt32 session, int countOrIndex);
    public virtual void OnSuggestionAccepted(PredictionClient client, UInt32 session, string acceptedSuggestion);
    public virtual void OnCommandLineAccepted(PredictionClient client, IReadOnlyList`1<string> history);
    public virtual void OnCommandLineExecuted(PredictionClient client, string commandLine, bool success);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Prediction.PredictionClient : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private PredictionClientKind <Kind>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private PathInfo <CurrentLocation>k__BackingField;
    public string Name { get; }
    public PredictionClientKind Kind { get; }
    [NullableAttribute("2")]
public PathInfo CurrentLocation { get; public set; }
    public PredictionClient(string name, PredictionClientKind kind);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public PredictionClientKind get_Kind();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public PathInfo get_CurrentLocation();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_CurrentLocation(PathInfo value);
}
public enum System.Management.Automation.Subsystem.Prediction.PredictionClientKind : Enum {
    public int value__;
    public static PredictionClientKind Terminal;
    public static PredictionClientKind Editor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Prediction.PredictionContext : object {
    [CompilerGeneratedAttribute]
private Ast <InputAst>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Token> <InputTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private IScriptPosition <CursorPosition>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private Token <TokenAtCursor>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<Ast> <RelatedAsts>k__BackingField;
    public Ast InputAst { get; }
    public IReadOnlyList`1<Token> InputTokens { get; }
    public IScriptPosition CursorPosition { get; }
    [NullableAttribute("2")]
public Token TokenAtCursor { get; }
    public IReadOnlyList`1<Ast> RelatedAsts { get; }
    public PredictionContext(Ast inputAst, Token[] inputTokens);
    [CompilerGeneratedAttribute]
public Ast get_InputAst();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Token> get_InputTokens();
    [CompilerGeneratedAttribute]
public IScriptPosition get_CursorPosition();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public Token get_TokenAtCursor();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<Ast> get_RelatedAsts();
    public static PredictionContext Create(string input);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Prediction.PredictionResult : object {
    [CompilerGeneratedAttribute]
private Guid <Id>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Session>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<PredictiveSuggestion> <Suggestions>k__BackingField;
    public Guid Id { get; }
    public string Name { get; }
    public Nullable`1<UInt32> Session { get; }
    public IReadOnlyList`1<PredictiveSuggestion> Suggestions { get; }
    internal PredictionResult(Guid id, string name, Nullable`1<UInt32> session, List`1<PredictiveSuggestion> suggestions);
    [CompilerGeneratedAttribute]
public Guid get_Id();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Session();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<PredictiveSuggestion> get_Suggestions();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Prediction.PredictiveSuggestion : object {
    [CompilerGeneratedAttribute]
private string <SuggestionText>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <ToolTip>k__BackingField;
    public string SuggestionText { get; }
    [NullableAttribute("2")]
public string ToolTip { get; }
    public PredictiveSuggestion(string suggestion);
    public PredictiveSuggestion(string suggestion, string toolTip);
    [CompilerGeneratedAttribute]
public string get_SuggestionText();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_ToolTip();
}
public enum System.Management.Automation.Subsystem.Prediction.PredictorFeedbackKind : Enum {
    public int value__;
    public static PredictorFeedbackKind SuggestionDisplayed;
    public static PredictorFeedbackKind SuggestionAccepted;
    public static PredictorFeedbackKind CommandLineAccepted;
    public static PredictorFeedbackKind CommandLineExecuted;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Management.Automation.Subsystem.Prediction.SuggestionPackage : ValueType {
    [CompilerGeneratedAttribute]
private Nullable`1<UInt32> <Session>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private List`1<PredictiveSuggestion> <SuggestionEntries>k__BackingField;
    public Nullable`1<UInt32> Session { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public List`1<PredictiveSuggestion> SuggestionEntries { get; }
    public SuggestionPackage(List`1<PredictiveSuggestion> suggestionEntries);
    public SuggestionPackage(UInt32 session, List`1<PredictiveSuggestion> suggestionEntries);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public Nullable`1<UInt32> get_Session();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public List`1<PredictiveSuggestion> get_SuggestionEntries();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class System.Management.Automation.Subsystem.SubsystemInfo : object {
    [CompilerGeneratedAttribute]
private SubsystemKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private Type <SubsystemType>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowUnregistration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AllowMultipleRegistration>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <RequiredCmdlets>k__BackingField;
    [CompilerGeneratedAttribute]
private ReadOnlyCollection`1<string> <RequiredFunctions>k__BackingField;
    private protected object _syncObj;
    private protected ReadOnlyCollection`1<ImplementationInfo> _cachedImplInfos;
    public SubsystemKind Kind { get; }
    public Type SubsystemType { get; }
    public bool AllowUnregistration { get; private set; }
    public bool AllowMultipleRegistration { get; private set; }
    public ReadOnlyCollection`1<string> RequiredCmdlets { get; private set; }
    public ReadOnlyCollection`1<string> RequiredFunctions { get; private set; }
    public bool IsRegistered { get; }
    public ReadOnlyCollection`1<ImplementationInfo> Implementations { get; }
    private protected SubsystemInfo(SubsystemKind kind, Type subsystemType);
    [CompilerGeneratedAttribute]
public SubsystemKind get_Kind();
    [CompilerGeneratedAttribute]
public Type get_SubsystemType();
    [CompilerGeneratedAttribute]
public bool get_AllowUnregistration();
    [CompilerGeneratedAttribute]
private void set_AllowUnregistration(bool value);
    [CompilerGeneratedAttribute]
public bool get_AllowMultipleRegistration();
    [CompilerGeneratedAttribute]
private void set_AllowMultipleRegistration(bool value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_RequiredCmdlets();
    [CompilerGeneratedAttribute]
private void set_RequiredCmdlets(ReadOnlyCollection`1<string> value);
    [CompilerGeneratedAttribute]
public ReadOnlyCollection`1<string> get_RequiredFunctions();
    [CompilerGeneratedAttribute]
private void set_RequiredFunctions(ReadOnlyCollection`1<string> value);
    public bool get_IsRegistered();
    public ReadOnlyCollection`1<ImplementationInfo> get_Implementations();
    private protected abstract virtual void AddImplementation(ISubsystem rawImpl);
    private protected abstract virtual ISubsystem RemoveImplementation(Guid id);
    internal void RegisterImplementation(ISubsystem impl);
    internal ISubsystem UnregisterImplementation(Guid id);
    internal static SubsystemInfo Create(SubsystemKind kind);
    internal static SubsystemInfo Create(SubsystemKind kind, bool allowUnregistration, bool allowMultipleRegistration);
    internal static SubsystemInfo Create(SubsystemKind kind, bool allowUnregistration, bool allowMultipleRegistration, ReadOnlyCollection`1<string> requiredCmdlets, ReadOnlyCollection`1<string> requiredFunctions);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class System.Management.Automation.Subsystem.SubsystemInfoImpl`1 : SubsystemInfo {
    private ReadOnlyCollection`1<TConcreteSubsystem> _registeredImpls;
    internal SubsystemInfoImpl`1(SubsystemKind kind);
    private protected virtual void AddImplementation(ISubsystem rawImpl);
    private protected virtual ISubsystem RemoveImplementation(Guid id);
    [NullableContextAttribute("2")]
internal TConcreteSubsystem GetImplementation();
    internal ReadOnlyCollection`1<TConcreteSubsystem> GetAllImplementations();
}
public enum System.Management.Automation.Subsystem.SubsystemKind : Enum {
    public UInt32 value__;
    public static SubsystemKind CommandPredictor;
    public static SubsystemKind CrossPlatformDsc;
    public static SubsystemKind FeedbackProvider;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class System.Management.Automation.Subsystem.SubsystemManager : object {
    private static ReadOnlyCollection`1<SubsystemInfo> s_subsystems;
    private static ReadOnlyDictionary`2<Type, SubsystemInfo> s_subSystemTypeMap;
    private static ReadOnlyDictionary`2<SubsystemKind, SubsystemInfo> s_subSystemKindMap;
    private static SubsystemManager();
    internal static TConcreteSubsystem GetSubsystem();
    internal static ReadOnlyCollection`1<TConcreteSubsystem> GetSubsystems();
    public static ReadOnlyCollection`1<SubsystemInfo> GetAllSubsystemInfo();
    public static SubsystemInfo GetSubsystemInfo(Type subsystemType);
    public static SubsystemInfo GetSubsystemInfo(SubsystemKind kind);
    public static void RegisterSubsystem(TImplementation proxy);
    public static void RegisterSubsystem(SubsystemKind kind, ISubsystem proxy);
    private static void RegisterSubsystem(SubsystemInfo subsystemInfo, ISubsystem proxy);
    public static void UnregisterSubsystem(Guid id);
    public static void UnregisterSubsystem(SubsystemKind kind, Guid id);
    private static void UnregisterSubsystem(SubsystemInfo subsystemInfo, Guid id);
}
internal enum System.Management.Automation.SuggestionMatchType : Enum {
    public int value__;
    public static SuggestionMatchType Command;
    public static SuggestionMatchType Error;
    public static SuggestionMatchType Dynamic;
    public static SuggestionMatchType ErrorId;
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.SupportsWildcardsAttribute : ParsingBaseAttribute {
}
internal static class System.Management.Automation.SwitchOps : object {
    internal static bool ConditionSatisfiedWildcard(bool caseSensitive, object condition, string str, ExecutionContext context);
    internal static bool ConditionSatisfiedRegex(bool caseSensitive, object condition, IScriptExtent errorPosition, string str, ExecutionContext context);
    internal static string ResolveFilePath(IScriptExtent errorExtent, object obj, ExecutionContext context);
}
[IsReadOnlyAttribute]
public class System.Management.Automation.SwitchParameter : ValueType {
    private bool _isPresent;
    public bool IsPresent { get; }
    public static SwitchParameter Present { get; }
    public SwitchParameter(bool isPresent);
    public bool get_IsPresent();
    public static bool op_Implicit(SwitchParameter switchParameter);
    public static SwitchParameter op_Implicit(bool value);
    public bool ToBool();
    public static SwitchParameter get_Present();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(SwitchParameter first, SwitchParameter second);
    public static bool op_Inequality(SwitchParameter first, SwitchParameter second);
    public static bool op_Equality(SwitchParameter first, bool second);
    public static bool op_Inequality(SwitchParameter first, bool second);
    public static bool op_Equality(bool first, SwitchParameter second);
    public static bool op_Inequality(bool first, SwitchParameter second);
    public virtual string ToString();
}
internal class System.Management.Automation.SyntaxHelpInfo : BaseCommandHelpInfo {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Synopsis>k__BackingField;
    [CompilerGeneratedAttribute]
private PSObject <FullHelp>k__BackingField;
    internal string Name { get; }
    internal string Synopsis { get; }
    internal PSObject FullHelp { get; }
    private SyntaxHelpInfo(string name, string text, HelpCategory category);
    [CompilerGeneratedAttribute]
internal virtual string get_Name();
    [CompilerGeneratedAttribute]
internal virtual string get_Synopsis();
    [CompilerGeneratedAttribute]
internal virtual PSObject get_FullHelp();
    internal static SyntaxHelpInfo GetHelpInfo(string name, string text, HelpCategory category);
}
public class System.Management.Automation.TableControl : PSControl {
    [CompilerGeneratedAttribute]
private List`1<TableControlColumnHeader> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<TableControlRow> <Rows>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HideTableHeaders>k__BackingField;
    public List`1<TableControlColumnHeader> Headers { get; public set; }
    public List`1<TableControlRow> Rows { get; public set; }
    public bool AutoSize { get; public set; }
    public bool HideTableHeaders { get; public set; }
    internal TableControl(TableControlBody tcb, ViewDefinition viewDefinition);
    public TableControl(TableControlRow tableControlRow);
    public TableControl(TableControlRow tableControlRow, IEnumerable`1<TableControlColumnHeader> tableControlColumnHeaders);
    [CompilerGeneratedAttribute]
public List`1<TableControlColumnHeader> get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(List`1<TableControlColumnHeader> value);
    [CompilerGeneratedAttribute]
public List`1<TableControlRow> get_Rows();
    [CompilerGeneratedAttribute]
public void set_Rows(List`1<TableControlRow> value);
    [CompilerGeneratedAttribute]
public bool get_AutoSize();
    [CompilerGeneratedAttribute]
public void set_AutoSize(bool value);
    [CompilerGeneratedAttribute]
public bool get_HideTableHeaders();
    [CompilerGeneratedAttribute]
public void set_HideTableHeaders(bool value);
    public static TableControlBuilder Create(bool outOfBand, bool autoSize, bool hideTableHeaders);
    internal virtual void WriteToXml(FormatXmlWriter writer);
    internal virtual bool SafeForExport();
    internal virtual bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.TableControlBuilder : object {
    internal TableControl _table;
    internal TableControlBuilder(TableControl table);
    public TableControlBuilder GroupByProperty(string property, CustomControl customControl, string label);
    public TableControlBuilder GroupByScriptBlock(string scriptBlock, CustomControl customControl, string label);
    public TableControlBuilder AddHeader(Alignment alignment, int width, string label);
    public TableRowDefinitionBuilder StartRowDefinition(bool wrap, IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    public TableControl EndTable();
}
public class System.Management.Automation.TableControlColumn : object {
    [CompilerGeneratedAttribute]
private Alignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private DisplayEntry <DisplayEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    public Alignment Alignment { get; public set; }
    public DisplayEntry DisplayEntry { get; public set; }
    public string FormatString { get; internal set; }
    internal TableControlColumn(string text, int alignment, bool isscriptblock, string formatString);
    public TableControlColumn(Alignment alignment, DisplayEntry entry);
    [CompilerGeneratedAttribute]
public Alignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(Alignment value);
    [CompilerGeneratedAttribute]
public DisplayEntry get_DisplayEntry();
    [CompilerGeneratedAttribute]
public void set_DisplayEntry(DisplayEntry value);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
internal void set_FormatString(string value);
    public virtual string ToString();
    internal bool SafeForExport();
}
public class System.Management.Automation.TableControlColumnHeader : object {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private Alignment <Alignment>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Width>k__BackingField;
    public string Label { get; public set; }
    public Alignment Alignment { get; public set; }
    public int Width { get; public set; }
    internal TableControlColumnHeader(TableColumnHeaderDefinition colheaderdefinition);
    public TableControlColumnHeader(string label, int width, Alignment alignment);
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public Alignment get_Alignment();
    [CompilerGeneratedAttribute]
public void set_Alignment(Alignment value);
    [CompilerGeneratedAttribute]
public int get_Width();
    [CompilerGeneratedAttribute]
public void set_Width(int value);
}
public class System.Management.Automation.TableControlRow : object {
    [CompilerGeneratedAttribute]
private List`1<TableControlColumn> <Columns>k__BackingField;
    [CompilerGeneratedAttribute]
private EntrySelectedBy <SelectedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Wrap>k__BackingField;
    public List`1<TableControlColumn> Columns { get; public set; }
    public EntrySelectedBy SelectedBy { get; internal set; }
    public bool Wrap { get; public set; }
    internal TableControlRow(TableRowDefinition rowdefinition);
    public TableControlRow(IEnumerable`1<TableControlColumn> columns);
    [CompilerGeneratedAttribute]
public List`1<TableControlColumn> get_Columns();
    [CompilerGeneratedAttribute]
public void set_Columns(List`1<TableControlColumn> value);
    [CompilerGeneratedAttribute]
public EntrySelectedBy get_SelectedBy();
    [CompilerGeneratedAttribute]
internal void set_SelectedBy(EntrySelectedBy value);
    [CompilerGeneratedAttribute]
public bool get_Wrap();
    [CompilerGeneratedAttribute]
public void set_Wrap(bool value);
    internal bool SafeForExport();
    internal bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.TableRowDefinitionBuilder : object {
    internal TableControlBuilder _tcb;
    internal TableControlRow _tcr;
    internal TableRowDefinitionBuilder(TableControlBuilder tcb, TableControlRow tcr);
    private TableRowDefinitionBuilder AddItem(string value, DisplayEntryValueType entryType, Alignment alignment, string format);
    public TableRowDefinitionBuilder AddScriptBlockColumn(string scriptBlock, Alignment alignment, string format);
    public TableRowDefinitionBuilder AddPropertyColumn(string propertyName, Alignment alignment, string format);
    public TableControlBuilder EndRowDefinition();
}
public class System.Management.Automation.TerminateException : FlowControlException {
}
internal class System.Management.Automation.ThirdPartyAdapter : PropertyOnlyAdapter {
    [CompilerGeneratedAttribute]
private Type <AdaptedType>k__BackingField;
    private PSPropertyAdapter _externalAdapter;
    internal Type AdaptedType { get; }
    internal Type ExternalAdapterType { get; }
    internal ThirdPartyAdapter(Type adaptedType, PSPropertyAdapter externalAdapter);
    [CompilerGeneratedAttribute]
internal Type get_AdaptedType();
    internal Type get_ExternalAdapterType();
    protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual void DoAddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(object obj, string propertyName);
    protected virtual PSProperty DoGetFirstPropertyOrDefault(object obj, MemberNamePredicate predicate);
    private void InitializeProperty(PSAdaptedProperty property, object baseObject);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
}
internal class System.Management.Automation.ThrottlingJob : Job {
    private DateTime _progressStartTime;
    private int _progressActivityId;
    private object _progressLock;
    private DateTime _progressReportLastTime;
    private bool _ownerWontSubmitNewChildJobs;
    private HashSet`1<Guid> _setOfChildJobsThatCanAddMoreChildJobs;
    private bool _cmdletMode;
    private int _countOfAllChildJobs;
    private int _countOfBlockedChildJobs;
    private int _countOfFailedChildJobs;
    private int _countOfStoppedChildJobs;
    private int _countOfSuccessfullyCompletedChildJobs;
    private object _lockObject;
    private bool _alreadyDisabledFlowControlForPendingJobsQueue;
    private bool _alreadyDisabledFlowControlForPendingCmdletActionsQueue;
    private object _alreadyWroteFlowControlBuffersHighMemoryUsageWarningLock;
    private bool _alreadyWroteFlowControlBuffersHighMemoryUsageWarning;
    private static long FlowControlBuffersHighMemoryUsageThreshold;
    [CompilerGeneratedAttribute]
private EventHandler`1<ThrottlingJobChildAddedEventArgs> ChildJobAdded;
    private int _maximumConcurrentChildJobs;
    private int _extraCapacityForRunningQueryJobs;
    private int _extraCapacityForRunningAllJobs;
    private bool _inBoostModeToPreventQueryJobDeadlock;
    private Queue`1<StartableJob> _readyToRunQueryJobs;
    private Queue`1<StartableJob> _readyToRunRegularJobs;
    private Queue`1<Action> _actionsForUnblockingChildAdditions;
    private int _maxReadyToRunJobs;
    private SemaphoreSlim _jobResultsThrottlingSemaphore;
    private long _jobResultsCurrentCount;
    private static int s_maximumReadyToRunJobs;
    private bool _isStopping;
    private CancellationTokenSource _cancellationTokenSource;
    private HashSet`1<string> _childJobLocations;
    private bool IsEndOfChildJobs { get; }
    private bool IsThrottlingJobCompleted { get; }
    private int CountOfFinishedChildJobs { get; }
    private int CountOfRunningOrReadyToRunChildJobs { get; }
    public bool HasMoreData { get; }
    public string Location { get; }
    public string StatusMessage { get; }
    internal ThrottlingJob(string command, string jobName, string jobTypeName, int maximumConcurrentChildJobs, bool cmdletMode);
    private static ThrottlingJob();
    protected virtual void Dispose(bool disposing);
    internal int GetProgressActivityId();
    private void ReportProgress(bool minimizeFrequentUpdates);
    private bool get_IsEndOfChildJobs();
    private bool get_IsThrottlingJobCompleted();
    private int get_CountOfFinishedChildJobs();
    private int get_CountOfRunningOrReadyToRunChildJobs();
    internal void AddChildJobAndPotentiallyBlock(StartableJob childJob, ChildJobFlags flags);
    internal void AddChildJobAndPotentiallyBlock(Cmdlet cmdlet, StartableJob childJob, ChildJobFlags flags);
    internal void DisableFlowControlForPendingJobsQueue();
    internal void DisableFlowControlForPendingCmdletActionsQueue();
    internal void AddChildJobWithoutBlocking(StartableJob childJob, ChildJobFlags flags, Action jobEnqueuedAction);
    private void childJob_ResultsAdded(object sender, DataAddedEventArgs e);
    private void WriteWarningAboutHighUsageOfFlowControlBuffers(long currentCount);
    [CompilerGeneratedAttribute]
internal void add_ChildJobAdded(EventHandler`1<ThrottlingJobChildAddedEventArgs> value);
    [CompilerGeneratedAttribute]
internal void remove_ChildJobAdded(EventHandler`1<ThrottlingJobChildAddedEventArgs> value);
    private void SetupThrottlingQueue(int maximumConcurrentChildJobs);
    private void StartChildJobIfPossible();
    private void EnqueueReadyToRunChildJob(StartableJob childJob);
    private void MakeRoomForRunningOtherJobs(Job completedChildJob);
    private void FigureOutIfThrottlingJobIsCompleted();
    internal void EndOfChildJobs();
    public virtual void StopJob();
    private void childJob_StateChanged(object sender, JobStateEventArgs e);
    private List`1<Job> GetChildJobsSnapshot();
    public virtual bool get_HasMoreData();
    public virtual string get_Location();
    public virtual string get_StatusMessage();
    internal virtual void ForwardAvailableResultsToCmdlet(Cmdlet cmdlet);
    internal virtual void ForwardAllResultsToCmdlet(Cmdlet cmdlet);
    private void ForwardAllResultsToCmdlet(Cmdlet cmdlet, Nullable`1<CancellationToken> cancellationToken);
}
internal class System.Management.Automation.ThrottlingJobChildAddedEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private Job <AddedChildJob>k__BackingField;
    internal Job AddedChildJob { get; }
    internal ThrottlingJobChildAddedEventArgs(Job addedChildJob);
    [CompilerGeneratedAttribute]
internal Job get_AddedChildJob();
}
[AttributeUsageAttribute("256")]
internal class System.Management.Automation.TraceSourceAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    internal string Category { get; }
    internal string Description { get; internal set; }
    internal TraceSourceAttribute(string category, string description);
    [CompilerGeneratedAttribute]
internal string get_Category();
    [CompilerGeneratedAttribute]
internal string get_Description();
    [CompilerGeneratedAttribute]
internal void set_Description(string value);
}
public abstract class System.Management.Automation.Tracing.BaseChannelWriter : object {
    private bool disposed;
    public PowerShellTraceKeywords Keywords { get; public set; }
    public virtual void Dispose();
    public virtual bool TraceError(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceWarning(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceInformational(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceVerbose(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceDebug(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceLogAlways(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceCritical(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual PowerShellTraceKeywords get_Keywords();
    public virtual void set_Keywords(PowerShellTraceKeywords value);
}
public class System.Management.Automation.Tracing.CallbackNoParameter : MulticastDelegate {
    public CallbackNoParameter(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Management.Automation.Tracing.CallbackWithState : MulticastDelegate {
    public CallbackWithState(object object, IntPtr method);
    public virtual void Invoke(object state);
    public virtual IAsyncResult BeginInvoke(object state, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class System.Management.Automation.Tracing.CallbackWithStateAndArgs : MulticastDelegate {
    public CallbackWithStateAndArgs(object object, IntPtr method);
    public virtual void Invoke(object state, ElapsedEventArgs args);
    public virtual IAsyncResult BeginInvoke(object state, ElapsedEventArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public abstract class System.Management.Automation.Tracing.EtwActivity : object {
    private static Dictionary`2<Guid, EventProvider> providers;
    private static object syncLock;
    private static EventDescriptor _WriteTransferEvent;
    private EventProvider currentProvider;
    [CompilerGeneratedAttribute]
private static EventHandler`1<EtwEventArgs> EventWritten;
    public bool IsEnabled { get; }
    protected Guid ProviderId { get; }
    protected EventDescriptor TransferEvent { get; }
    private static EtwActivity();
    [CompilerGeneratedAttribute]
public static void add_EventWritten(EventHandler`1<EtwEventArgs> value);
    [CompilerGeneratedAttribute]
public static void remove_EventWritten(EventHandler`1<EtwEventArgs> value);
    public static bool SetActivityId(Guid activityId);
    public static Guid CreateActivityId();
    public static Guid GetActivityId();
    public void CorrelateWithActivity(Guid parentActivityId);
    public bool get_IsEnabled();
    public bool IsProviderEnabled(byte levels, long keywords);
    public void Correlate();
    public CallbackNoParameter Correlate(CallbackNoParameter callback);
    public CallbackWithState Correlate(CallbackWithState callback);
    public AsyncCallback Correlate(AsyncCallback callback);
    public CallbackWithStateAndArgs Correlate(CallbackWithStateAndArgs callback);
    protected virtual Guid get_ProviderId();
    protected virtual EventDescriptor get_TransferEvent();
    protected void WriteEvent(EventDescriptor ed, Object[] payload);
    private EventProvider GetProvider();
}
internal class System.Management.Automation.Tracing.EtwActivityReverter : object {
    [NullableAttribute("1")]
private IEtwEventCorrelator _correlator;
    private Guid _oldActivityId;
    private bool _isDisposed;
    [NullableContextAttribute("1")]
public EtwActivityReverter(IEtwEventCorrelator correlator, Guid oldActivityId);
    public sealed virtual void RevertCurrentActivityId();
    public sealed virtual void Dispose();
}
internal class System.Management.Automation.Tracing.EtwActivityReverterMethodInvoker : object {
    private IEtwEventCorrelator _eventCorrelator;
    private Func`4<Guid, Delegate, Object[], object> _invoker;
    public Delegate Invoker { get; }
    public EtwActivityReverterMethodInvoker(IEtwEventCorrelator eventCorrelator);
    public sealed virtual Delegate get_Invoker();
    public sealed virtual Object[] CreateInvokerArgs(Delegate methodToInvoke, Object[] methodToInvokeArgs);
    private object DoInvoke(Guid relatedActivityId, Delegate method, Object[] methodArgs);
}
[AttributeUsageAttribute("64")]
public class System.Management.Automation.Tracing.EtwEvent : Attribute {
    [CompilerGeneratedAttribute]
private long <EventId>k__BackingField;
    public long EventId { get; }
    public EtwEvent(long eventId);
    [CompilerGeneratedAttribute]
public long get_EventId();
}
public class System.Management.Automation.Tracing.EtwEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private EventDescriptor <Descriptor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Success>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Payload>k__BackingField;
    public EventDescriptor Descriptor { get; private set; }
    public bool Success { get; }
    public Object[] Payload { get; }
    public EtwEventArgs(EventDescriptor descriptor, bool success, Object[] payload);
    [CompilerGeneratedAttribute]
public EventDescriptor get_Descriptor();
    [CompilerGeneratedAttribute]
private void set_Descriptor(EventDescriptor value);
    [CompilerGeneratedAttribute]
public bool get_Success();
    [CompilerGeneratedAttribute]
public Object[] get_Payload();
}
public class System.Management.Automation.Tracing.EtwEventCorrelator : object {
    private EventProvider _transferProvider;
    private EventDescriptor _transferEvent;
    public Guid CurrentActivityId { get; public set; }
    public EtwEventCorrelator(EventProvider transferProvider, EventDescriptor transferEvent);
    public sealed virtual Guid get_CurrentActivityId();
    public sealed virtual void set_CurrentActivityId(Guid value);
    public sealed virtual IEtwActivityReverter StartActivity(Guid relatedActivityId);
    public sealed virtual IEtwActivityReverter StartActivity();
}
public interface System.Management.Automation.Tracing.IEtwActivityReverter {
    public abstract virtual void RevertCurrentActivityId();
}
[NullableContextAttribute("1")]
public interface System.Management.Automation.Tracing.IEtwEventCorrelator {
    public Guid CurrentActivityId { get; public set; }
    public abstract virtual Guid get_CurrentActivityId();
    public abstract virtual void set_CurrentActivityId(Guid value);
    public abstract virtual IEtwActivityReverter StartActivity(Guid relatedActivityId);
    public abstract virtual IEtwActivityReverter StartActivity();
}
[NullableContextAttribute("1")]
internal interface System.Management.Automation.Tracing.IMethodInvoker {
    public Delegate Invoker { get; }
    public abstract virtual Delegate get_Invoker();
    public abstract virtual Object[] CreateInvokerArgs(Delegate methodToInvoke, Object[] methodToInvokeArgs);
}
public class System.Management.Automation.Tracing.NullWriter : BaseChannelWriter {
    [CompilerGeneratedAttribute]
private static BaseChannelWriter <Instance>k__BackingField;
    public static BaseChannelWriter Instance { get; }
    private static NullWriter();
    [CompilerGeneratedAttribute]
public static BaseChannelWriter get_Instance();
}
public class System.Management.Automation.Tracing.PowerShellChannelWriter : BaseChannelWriter {
    private PowerShellTraceChannel _traceChannel;
    private static EventProvider _provider;
    private bool disposed;
    private PowerShellTraceKeywords _keywords;
    public PowerShellTraceKeywords Keywords { get; public set; }
    internal PowerShellChannelWriter(PowerShellTraceChannel traceChannel, PowerShellTraceKeywords keywords);
    private static PowerShellChannelWriter();
    public virtual PowerShellTraceKeywords get_Keywords();
    public virtual void set_Keywords(PowerShellTraceKeywords value);
    public virtual void Dispose();
    private bool Trace(PowerShellTraceEvent traceEvent, PowerShellTraceLevel level, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceError(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceWarning(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceInformational(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceVerbose(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceDebug(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceLogAlways(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
    public virtual bool TraceCritical(PowerShellTraceEvent traceEvent, PowerShellTraceOperationCode operationCode, PowerShellTraceTask task, Object[] args);
}
public enum System.Management.Automation.Tracing.PowerShellTraceChannel : Enum {
    public int value__;
    public static PowerShellTraceChannel None;
    public static PowerShellTraceChannel Operational;
    public static PowerShellTraceChannel Analytic;
    public static PowerShellTraceChannel Debug;
}
public enum System.Management.Automation.Tracing.PowerShellTraceEvent : Enum {
    public int value__;
    public static PowerShellTraceEvent None;
    public static PowerShellTraceEvent HostNameResolve;
    public static PowerShellTraceEvent SchemeResolve;
    public static PowerShellTraceEvent ShellResolve;
    public static PowerShellTraceEvent RunspaceConstructor;
    public static PowerShellTraceEvent RunspacePoolConstructor;
    public static PowerShellTraceEvent RunspacePoolOpen;
    public static PowerShellTraceEvent OperationalTransferEventRunspacePool;
    public static PowerShellTraceEvent RunspacePort;
    public static PowerShellTraceEvent AppName;
    public static PowerShellTraceEvent ComputerName;
    public static PowerShellTraceEvent Scheme;
    public static PowerShellTraceEvent TestAnalytic;
    public static PowerShellTraceEvent WSManConnectionInfoDump;
    public static PowerShellTraceEvent AnalyticTransferEventRunspacePool;
    public static PowerShellTraceEvent TransportReceivedObject;
    public static PowerShellTraceEvent AppDomainUnhandledExceptionAnalytic;
    public static PowerShellTraceEvent TransportErrorAnalytic;
    public static PowerShellTraceEvent AppDomainUnhandledException;
    public static PowerShellTraceEvent TransportError;
    public static PowerShellTraceEvent WSManCreateShell;
    public static PowerShellTraceEvent WSManCreateShellCallbackReceived;
    public static PowerShellTraceEvent WSManCloseShell;
    public static PowerShellTraceEvent WSManCloseShellCallbackReceived;
    public static PowerShellTraceEvent WSManSendShellInputExtended;
    public static PowerShellTraceEvent WSManSendShellInputExtendedCallbackReceived;
    public static PowerShellTraceEvent WSManReceiveShellOutputExtended;
    public static PowerShellTraceEvent WSManReceiveShellOutputExtendedCallbackReceived;
    public static PowerShellTraceEvent WSManCreateCommand;
    public static PowerShellTraceEvent WSManCreateCommandCallbackReceived;
    public static PowerShellTraceEvent WSManCloseCommand;
    public static PowerShellTraceEvent WSManCloseCommandCallbackReceived;
    public static PowerShellTraceEvent WSManSignal;
    public static PowerShellTraceEvent WSManSignalCallbackReceived;
    public static PowerShellTraceEvent UriRedirection;
    public static PowerShellTraceEvent ServerSendData;
    public static PowerShellTraceEvent ServerCreateRemoteSession;
    public static PowerShellTraceEvent ReportContext;
    public static PowerShellTraceEvent ReportOperationComplete;
    public static PowerShellTraceEvent ServerCreateCommandSession;
    public static PowerShellTraceEvent ServerStopCommand;
    public static PowerShellTraceEvent ServerReceivedData;
    public static PowerShellTraceEvent ServerClientReceiveRequest;
    public static PowerShellTraceEvent ServerCloseOperation;
    public static PowerShellTraceEvent LoadingPSCustomShellAssembly;
    public static PowerShellTraceEvent LoadingPSCustomShellType;
    public static PowerShellTraceEvent ReceivedRemotingFragment;
    public static PowerShellTraceEvent SentRemotingFragment;
    public static PowerShellTraceEvent WSManPluginShutdown;
    public static PowerShellTraceEvent SerializerWorkflowLoadSuccess;
    public static PowerShellTraceEvent SerializerWorkflowLoadFailure;
    public static PowerShellTraceEvent SerializerDepthOverride;
    public static PowerShellTraceEvent SerializerModeOverride;
    public static PowerShellTraceEvent SerializerScriptPropertyWithoutRunspace;
    public static PowerShellTraceEvent SerializerPropertyGetterFailed;
    public static PowerShellTraceEvent SerializerEnumerationFailed;
    public static PowerShellTraceEvent SerializerToStringFailed;
    public static PowerShellTraceEvent SerializerMaxDepthWhenSerializing;
    public static PowerShellTraceEvent SerializerXmlExceptionWhenDeserializing;
    public static PowerShellTraceEvent SerializerSpecificPropertyMissing;
    public static PowerShellTraceEvent PerformanceTrackConsoleStartupStart;
    public static PowerShellTraceEvent PerformanceTrackConsoleStartupStop;
    public static PowerShellTraceEvent ErrorRecord;
    public static PowerShellTraceEvent Exception;
    public static PowerShellTraceEvent PowerShellObject;
    public static PowerShellTraceEvent Job;
    public static PowerShellTraceEvent TraceMessage;
    public static PowerShellTraceEvent TraceWSManConnectionInfo;
    public static PowerShellTraceEvent TraceMessage2;
    public static PowerShellTraceEvent TraceMessageGuid;
}
[FlagsAttribute]
public enum System.Management.Automation.Tracing.PowerShellTraceKeywords : Enum {
    public ulong value__;
    public static PowerShellTraceKeywords None;
    public static PowerShellTraceKeywords Runspace;
    public static PowerShellTraceKeywords Pipeline;
    public static PowerShellTraceKeywords Protocol;
    public static PowerShellTraceKeywords Transport;
    public static PowerShellTraceKeywords Host;
    public static PowerShellTraceKeywords Cmdlets;
    public static PowerShellTraceKeywords Serializer;
    public static PowerShellTraceKeywords Session;
    public static PowerShellTraceKeywords ManagedPlugIn;
    public static PowerShellTraceKeywords UseAlwaysDebug;
    public static PowerShellTraceKeywords UseAlwaysOperational;
    public static PowerShellTraceKeywords UseAlwaysAnalytic;
}
public enum System.Management.Automation.Tracing.PowerShellTraceLevel : Enum {
    public int value__;
    public static PowerShellTraceLevel LogAlways;
    public static PowerShellTraceLevel Critical;
    public static PowerShellTraceLevel Error;
    public static PowerShellTraceLevel Warning;
    public static PowerShellTraceLevel Informational;
    public static PowerShellTraceLevel Verbose;
    public static PowerShellTraceLevel Debug;
}
public enum System.Management.Automation.Tracing.PowerShellTraceOperationCode : Enum {
    public int value__;
    public static PowerShellTraceOperationCode None;
    public static PowerShellTraceOperationCode Open;
    public static PowerShellTraceOperationCode Close;
    public static PowerShellTraceOperationCode Connect;
    public static PowerShellTraceOperationCode Disconnect;
    public static PowerShellTraceOperationCode Negotiate;
    public static PowerShellTraceOperationCode Create;
    public static PowerShellTraceOperationCode Constructor;
    public static PowerShellTraceOperationCode Dispose;
    public static PowerShellTraceOperationCode EventHandler;
    public static PowerShellTraceOperationCode Exception;
    public static PowerShellTraceOperationCode Method;
    public static PowerShellTraceOperationCode Send;
    public static PowerShellTraceOperationCode Receive;
    public static PowerShellTraceOperationCode WorkflowLoad;
    public static PowerShellTraceOperationCode SerializationSettings;
    public static PowerShellTraceOperationCode WinInfo;
    public static PowerShellTraceOperationCode WinStart;
    public static PowerShellTraceOperationCode WinStop;
    public static PowerShellTraceOperationCode WinDCStart;
    public static PowerShellTraceOperationCode WinDCStop;
    public static PowerShellTraceOperationCode WinExtension;
    public static PowerShellTraceOperationCode WinReply;
    public static PowerShellTraceOperationCode WinResume;
    public static PowerShellTraceOperationCode WinSuspend;
}
public class System.Management.Automation.Tracing.PowerShellTraceSource : object {
    private bool disposed;
    [CompilerGeneratedAttribute]
private PowerShellTraceKeywords <Keywords>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShellTraceTask <Task>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseChannelWriter <DebugChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseChannelWriter <AnalyticChannel>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseChannelWriter <OperationalChannel>k__BackingField;
    public PowerShellTraceKeywords Keywords { get; }
    public PowerShellTraceTask Task { get; public set; }
    private static bool IsEtwSupported { get; }
    public BaseChannelWriter DebugChannel { get; }
    public BaseChannelWriter AnalyticChannel { get; }
    public BaseChannelWriter OperationalChannel { get; }
    internal PowerShellTraceSource(PowerShellTraceTask task, PowerShellTraceKeywords keywords);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
public PowerShellTraceKeywords get_Keywords();
    [CompilerGeneratedAttribute]
public PowerShellTraceTask get_Task();
    [CompilerGeneratedAttribute]
public void set_Task(PowerShellTraceTask value);
    private static bool get_IsEtwSupported();
    public bool TraceErrorRecord(ErrorRecord errorRecord);
    public bool TraceException(Exception exception);
    public bool TracePowerShellObject(PSObject powerShellObject);
    public bool TraceJob(Job job);
    public bool WriteMessage(string message);
    public bool WriteMessage(string message1, string message2);
    public bool WriteMessage(string message, Guid instanceId);
    public void WriteMessage(string className, string methodName, Guid workflowId, string message, String[] parameters);
    public void WriteMessage(string className, string methodName, Guid workflowId, Job job, string message, String[] parameters);
    public void WriteScheduledJobStartEvent(Object[] args);
    public void WriteScheduledJobCompleteEvent(Object[] args);
    public void WriteScheduledJobErrorEvent(Object[] args);
    public void WriteISEExecuteScriptEvent(Object[] args);
    public void WriteISEExecuteSelectionEvent(Object[] args);
    public void WriteISEStopCommandEvent(Object[] args);
    public void WriteISEResumeDebuggerEvent(Object[] args);
    public void WriteISEStopDebuggerEvent(Object[] args);
    public void WriteISEDebuggerStepIntoEvent(Object[] args);
    public void WriteISEDebuggerStepOverEvent(Object[] args);
    public void WriteISEDebuggerStepOutEvent(Object[] args);
    public void WriteISEEnableAllBreakpointsEvent(Object[] args);
    public void WriteISEDisableAllBreakpointsEvent(Object[] args);
    public void WriteISERemoveAllBreakpointsEvent(Object[] args);
    public void WriteISESetBreakpointEvent(Object[] args);
    public void WriteISERemoveBreakpointEvent(Object[] args);
    public void WriteISEEnableBreakpointEvent(Object[] args);
    public void WriteISEDisableBreakpointEvent(Object[] args);
    public void WriteISEHitBreakpointEvent(Object[] args);
    public void WriteMessage(string className, string methodName, Guid workflowId, string activityName, Guid activityId, string message, String[] parameters);
    public bool TraceWSManConnectionInfo(WSManConnectionInfo connectionInfo);
    [CompilerGeneratedAttribute]
public BaseChannelWriter get_DebugChannel();
    [CompilerGeneratedAttribute]
public BaseChannelWriter get_AnalyticChannel();
    [CompilerGeneratedAttribute]
public BaseChannelWriter get_OperationalChannel();
}
public static class System.Management.Automation.Tracing.PowerShellTraceSourceFactory : object {
    public static PowerShellTraceSource GetTraceSource();
    public static PowerShellTraceSource GetTraceSource(PowerShellTraceTask task);
    public static PowerShellTraceSource GetTraceSource(PowerShellTraceTask task, PowerShellTraceKeywords keywords);
}
public enum System.Management.Automation.Tracing.PowerShellTraceTask : Enum {
    public int value__;
    public static PowerShellTraceTask None;
    public static PowerShellTraceTask CreateRunspace;
    public static PowerShellTraceTask ExecuteCommand;
    public static PowerShellTraceTask Serialization;
    public static PowerShellTraceTask PowerShellConsoleStartup;
}
internal static class System.Management.Automation.Tracing.PSEtwLog : object {
    private static PSEtwLogProvider provider;
    private static PSEtwLog();
    internal static void LogConsoleStartup();
    internal static void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary`2<string, string> additionalInfo);
    internal static void LogEngineLifecycleEvent(LogContext logContext, EngineState newState, EngineState previousState);
    internal static void LogCommandHealthEvent(LogContext logContext, Exception exception);
    internal static void LogCommandLifecycleEvent(LogContext logContext, CommandState newState);
    internal static void LogPipelineExecutionDetailEvent(LogContext logContext, List`1<string> pipelineExecutionDetail);
    internal static void LogProviderHealthEvent(LogContext logContext, string providerName, Exception exception);
    internal static void LogProviderLifecycleEvent(LogContext logContext, string providerName, ProviderState newState);
    internal static void LogAmsiUtilStateEvent(string state, string context);
    internal static void LogWDACQueryEvent(string queryName, string fileName, int querySuccess, int queryResult);
    internal static void LogWDACAuditEvent(string title, string message, string fqid);
    internal static void LogSettingsEvent(LogContext logContext, string variableName, string value, string previousValue);
    internal static void LogOperationalInformation(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogOperationalWarning(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogOperationalVerbose(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogAnalyticError(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogAnalyticWarning(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogAnalyticVerbose(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, long objectId, long fragmentId, int isStartFragment, int isEndFragment, UInt32 fragmentLength, PSETWBinaryBlob fragmentData);
    internal static void LogAnalyticVerbose(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogAnalyticInformational(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogOperationalError(PSEventId id, PSOpcode opcode, PSTask task, PSKeyword keyword, Object[] args);
    internal static void LogOperationalError(PSEventId id, PSOpcode opcode, PSTask task, LogContext logContext, string payLoad);
    internal static void SetActivityIdForCurrentThread(Guid newActivityId);
    internal static void ReplaceActivityIdForCurrentThread(Guid newActivityId, PSEventId eventForOperationalChannel, PSEventId eventForAnalyticChannel, PSKeyword keyword, PSTask task);
    internal static void WriteTransferEvent(Guid relatedActivityId, PSEventId eventForOperationalChannel, PSEventId eventForAnalyticChannel, PSKeyword keyword, PSTask task);
    internal static void WriteTransferEvent(Guid parentActivityId);
}
internal class System.Management.Automation.Tracing.PSEtwLogProvider : LogProvider {
    private static EventProvider etwProvider;
    internal static Guid ProviderGuid;
    private static EventDescriptor _xferEventDescriptor;
    private static PSEtwLogProvider();
    internal bool IsEnabled(PSLevel level, PSKeyword keywords);
    internal virtual void LogEngineHealthEvent(LogContext logContext, int eventId, Exception exception, Dictionary`2<string, string> additionalInfo);
    internal virtual void LogEngineLifecycleEvent(LogContext logContext, EngineState newState, EngineState previousState);
    internal virtual void LogCommandHealthEvent(LogContext logContext, Exception exception);
    internal virtual void LogCommandLifecycleEvent(Func`1<LogContext> getLogContext, CommandState newState);
    internal virtual void LogPipelineExecutionDetailEvent(LogContext logContext, List`1<string> pipelineExecutionDetail);
    internal virtual void LogProviderHealthEvent(LogContext logContext, string providerName, Exception exception);
    internal virtual void LogAmsiUtilStateEvent(string state, string context);
    internal virtual void LogWDACQueryEvent(string queryName, string fileName, int querySuccess, int queryResult);
    internal virtual void LogWDACAuditEvent(string title, string message, string fqid);
    internal virtual void LogProviderLifecycleEvent(LogContext logContext, string providerName, ProviderState newState);
    internal virtual void LogSettingsEvent(LogContext logContext, string variableName, string value, string previousValue);
    internal virtual bool UseLoggingVariables();
    internal void WriteEvent(PSEventId id, PSChannel channel, PSOpcode opcode, PSTask task, LogContext logContext, string payLoad);
    internal void WriteEvent(PSEventId id, PSChannel channel, PSOpcode opcode, PSLevel level, PSTask task, PSKeyword keyword, Object[] args);
    internal void WriteTransferEvent(Guid parentActivityId);
    internal void SetActivityIdForCurrentThread(Guid newActivityId);
}
public class System.Management.Automation.Tracing.Tracer : EtwActivity {
    public static byte LevelCritical;
    public static byte LevelError;
    public static byte LevelWarning;
    public static byte LevelInformational;
    public static byte LevelVerbose;
    public static long KeywordAll;
    private static Guid providerId;
    private static EventDescriptor WriteTransferEventEvent;
    private static EventDescriptor DebugMessageEvent;
    private static EventDescriptor M3PAbortingWorkflowExecutionEvent;
    private static EventDescriptor M3PActivityExecutionFinishedEvent;
    private static EventDescriptor M3PActivityExecutionQueuedEvent;
    private static EventDescriptor M3PActivityExecutionStartedEvent;
    private static EventDescriptor M3PBeginContainerParentJobExecutionEvent;
    private static EventDescriptor M3PBeginCreateNewJobEvent;
    private static EventDescriptor M3PBeginJobLogicEvent;
    private static EventDescriptor M3PBeginProxyChildJobEventHandlerEvent;
    private static EventDescriptor M3PBeginProxyJobEventHandlerEvent;
    private static EventDescriptor M3PBeginProxyJobExecutionEvent;
    private static EventDescriptor M3PBeginRunGarbageCollectionEvent;
    private static EventDescriptor M3PBeginStartWorkflowApplicationEvent;
    private static EventDescriptor M3PBeginWorkflowExecutionEvent;
    private static EventDescriptor M3PCancellingWorkflowExecutionEvent;
    private static EventDescriptor M3PChildWorkflowJobAdditionEvent;
    private static EventDescriptor M3PEndContainerParentJobExecutionEvent;
    private static EventDescriptor M3PEndCreateNewJobEvent;
    private static EventDescriptor M3PEndJobLogicEvent;
    private static EventDescriptor M3PEndpointDisabledEvent;
    private static EventDescriptor M3PEndpointEnabledEvent;
    private static EventDescriptor M3PEndpointModifiedEvent;
    private static EventDescriptor M3PEndpointRegisteredEvent;
    private static EventDescriptor M3PEndpointUnregisteredEvent;
    private static EventDescriptor M3PEndProxyChildJobEventHandlerEvent;
    private static EventDescriptor M3PEndProxyJobEventHandlerEvent;
    private static EventDescriptor M3PEndProxyJobExecutionEvent;
    private static EventDescriptor M3PEndRunGarbageCollectionEvent;
    private static EventDescriptor M3PEndStartWorkflowApplicationEvent;
    private static EventDescriptor M3PEndWorkflowExecutionEvent;
    private static EventDescriptor M3PErrorImportingWorkflowFromXamlEvent;
    private static EventDescriptor M3PForcedWorkflowShutdownErrorEvent;
    private static EventDescriptor M3PForcedWorkflowShutdownFinishedEvent;
    private static EventDescriptor M3PForcedWorkflowShutdownStartedEvent;
    private static EventDescriptor M3PImportedWorkflowFromXamlEvent;
    private static EventDescriptor M3PImportingWorkflowFromXamlEvent;
    private static EventDescriptor M3PJobCreationCompleteEvent;
    private static EventDescriptor M3PJobErrorEvent;
    private static EventDescriptor M3PJobRemovedEvent;
    private static EventDescriptor M3PJobRemoveErrorEvent;
    private static EventDescriptor M3PJobStateChangedEvent;
    private static EventDescriptor M3PLoadingWorkflowForExecutionEvent;
    private static EventDescriptor M3POutOfProcessRunspaceStartedEvent;
    private static EventDescriptor M3PParameterSplattingWasPerformedEvent;
    private static EventDescriptor M3PParentJobCreatedEvent;
    private static EventDescriptor M3PPersistenceStoreMaxSizeReachedEvent;
    private static EventDescriptor M3PPersistingWorkflowEvent;
    private static EventDescriptor M3PProxyJobRemoteJobAssociationEvent;
    private static EventDescriptor M3PRemoveJobStartedEvent;
    private static EventDescriptor M3PRunspaceAvailabilityChangedEvent;
    private static EventDescriptor M3PRunspaceStateChangedEvent;
    private static EventDescriptor M3PTrackingGuidContainerParentJobCorrelationEvent;
    private static EventDescriptor M3PUnloadingWorkflowEvent;
    private static EventDescriptor M3PWorkflowActivityExecutionFailedEvent;
    private static EventDescriptor M3PWorkflowActivityValidatedEvent;
    private static EventDescriptor M3PWorkflowActivityValidationFailedEvent;
    private static EventDescriptor M3PWorkflowCleanupPerformedEvent;
    private static EventDescriptor M3PWorkflowDeletedFromDiskEvent;
    private static EventDescriptor M3PWorkflowEngineStartedEvent;
    private static EventDescriptor M3PWorkflowExecutionAbortedEvent;
    private static EventDescriptor M3PWorkflowExecutionCancelledEvent;
    private static EventDescriptor M3PWorkflowExecutionErrorEvent;
    private static EventDescriptor M3PWorkflowExecutionFinishedEvent;
    private static EventDescriptor M3PWorkflowExecutionStartedEvent;
    private static EventDescriptor M3PWorkflowJobCreatedEvent;
    private static EventDescriptor M3PWorkflowLoadedForExecutionEvent;
    private static EventDescriptor M3PWorkflowLoadedFromDiskEvent;
    private static EventDescriptor M3PWorkflowManagerCheckpointEvent;
    private static EventDescriptor M3PWorkflowPersistedEvent;
    private static EventDescriptor M3PWorkflowPluginRequestedToShutdownEvent;
    private static EventDescriptor M3PWorkflowPluginRestartedEvent;
    private static EventDescriptor M3PWorkflowPluginStartedEvent;
    private static EventDescriptor M3PWorkflowQuotaViolatedEvent;
    private static EventDescriptor M3PWorkflowResumedEvent;
    private static EventDescriptor M3PWorkflowResumingEvent;
    private static EventDescriptor M3PWorkflowRunspacePoolCreatedEvent;
    private static EventDescriptor M3PWorkflowStateChangedEvent;
    private static EventDescriptor M3PWorkflowUnloadedEvent;
    private static EventDescriptor M3PWorkflowValidationErrorEvent;
    private static EventDescriptor M3PWorkflowValidationFinishedEvent;
    private static EventDescriptor M3PWorkflowValidationStartedEvent;
    protected Guid ProviderId { get; }
    protected EventDescriptor TransferEvent { get; }
    private static Tracer();
    [EtwEvent("49152")]
public void DebugMessage(Exception exception);
    public static string GetExceptionString(Exception exception);
    private static bool WriteExceptionText(StringBuilder sb, Exception e);
    protected virtual Guid get_ProviderId();
    protected virtual EventDescriptor get_TransferEvent();
    [EtwEvent("7941")]
public void WriteTransferEvent(Guid currentActivityId, Guid parentActivityId);
    [EtwEvent("49152")]
public void DebugMessage(string message);
    [EtwEvent("45112")]
public void AbortingWorkflowExecution(Guid workflowId, string reason);
    [EtwEvent("45119")]
public void ActivityExecutionFinished(string activityName);
    [EtwEvent("45079")]
public void ActivityExecutionQueued(Guid workflowId, string activityName);
    [EtwEvent("45080")]
public void ActivityExecutionStarted(string activityName, string activityTypeName);
    [EtwEvent("46348")]
public void BeginContainerParentJobExecution(Guid containerParentJobInstanceId);
    [EtwEvent("46339")]
public void BeginCreateNewJob(Guid trackingId);
    [EtwEvent("46342")]
public void BeginJobLogic(Guid workflowJobJobInstanceId);
    [EtwEvent("46354")]
public void BeginProxyChildJobEventHandler(Guid proxyChildJobInstanceId);
    [EtwEvent("46352")]
public void BeginProxyJobEventHandler(Guid proxyJobInstanceId);
    [EtwEvent("46350")]
public void BeginProxyJobExecution(Guid proxyJobInstanceId);
    [EtwEvent("46356")]
public void BeginRunGarbageCollection();
    [EtwEvent("46337")]
public void BeginStartWorkflowApplication(Guid trackingId);
    [EtwEvent("46344")]
public void BeginWorkflowExecution(Guid workflowJobJobInstanceId);
    [EtwEvent("45111")]
public void CancellingWorkflowExecution(Guid workflowId);
    [EtwEvent("46346")]
public void ChildWorkflowJobAddition(Guid workflowJobInstanceId, Guid containerParentJobInstanceId);
    [EtwEvent("46349")]
public void EndContainerParentJobExecution(Guid containerParentJobInstanceId);
    [EtwEvent("46340")]
public void EndCreateNewJob(Guid trackingId);
    [EtwEvent("46343")]
public void EndJobLogic(Guid workflowJobJobInstanceId);
    [EtwEvent("45124")]
public void EndpointDisabled(string endpointName, string disabledBy);
    [EtwEvent("45125")]
public void EndpointEnabled(string endpointName, string enabledBy);
    [EtwEvent("45122")]
public void EndpointModified(string endpointName, string modifiedBy);
    [EtwEvent("45121")]
public void EndpointRegistered(string endpointName, string registeredBy);
    [EtwEvent("45123")]
public void EndpointUnregistered(string endpointName, string unregisteredBy);
    [EtwEvent("46355")]
public void EndProxyChildJobEventHandler(Guid proxyChildJobInstanceId);
    [EtwEvent("46353")]
public void EndProxyJobEventHandler(Guid proxyJobInstanceId);
    [EtwEvent("46351")]
public void EndProxyJobExecution(Guid proxyJobInstanceId);
    [EtwEvent("46357")]
public void EndRunGarbageCollection();
    [EtwEvent("46338")]
public void EndStartWorkflowApplication(Guid trackingId);
    [EtwEvent("46345")]
public void EndWorkflowExecution(Guid workflowJobJobInstanceId);
    [EtwEvent("45083")]
public void ErrorImportingWorkflowFromXaml(Guid workflowId, string errorDescription);
    [EtwEvent("45116")]
public void ForcedWorkflowShutdownError(Guid workflowId, string errorDescription);
    [EtwEvent("45115")]
public void ForcedWorkflowShutdownFinished(Guid workflowId);
    [EtwEvent("45114")]
public void ForcedWorkflowShutdownStarted(Guid workflowId);
    [EtwEvent("45082")]
public void ImportedWorkflowFromXaml(Guid workflowId, string xamlFile);
    [EtwEvent("45081")]
public void ImportingWorkflowFromXaml(Guid workflowId, string xamlFile);
    [EtwEvent("45106")]
public void JobCreationComplete(Guid jobId, Guid workflowId);
    [EtwEvent("45102")]
public void JobError(int jobId, Guid workflowId, string errorDescription);
    [EtwEvent("45107")]
public void JobRemoved(Guid parentJobId, Guid childJobId, Guid workflowId);
    [EtwEvent("45108")]
public void JobRemoveError(Guid parentJobId, Guid childJobId, Guid workflowId, string error);
    [EtwEvent("45101")]
public void JobStateChanged(int jobId, Guid workflowId, string newState, string oldState);
    [EtwEvent("45109")]
public void LoadingWorkflowForExecution(Guid workflowId);
    [EtwEvent("45126")]
public void OutOfProcessRunspaceStarted(string command);
    [EtwEvent("45127")]
public void ParameterSplattingWasPerformed(string parameters, string computers);
    [EtwEvent("45105")]
public void ParentJobCreated(Guid jobId);
    [EtwEvent("46358")]
public void PersistenceStoreMaxSizeReached();
    [EtwEvent("45117")]
public void PersistingWorkflow(Guid workflowId, string persistPath);
    [EtwEvent("46347")]
public void ProxyJobRemoteJobAssociation(Guid proxyJobInstanceId, Guid containerParentJobInstanceId);
    [EtwEvent("45100")]
public void RemoveJobStarted(Guid jobId);
    [EtwEvent("45090")]
public void RunspaceAvailabilityChanged(string runspaceId, string availability);
    [EtwEvent("45091")]
public void RunspaceStateChanged(string runspaceId, string newState, string oldState);
    [EtwEvent("46341")]
public void TrackingGuidContainerParentJobCorrelation(Guid trackingId, Guid containerParentJobInstanceId);
    [EtwEvent("45113")]
public void UnloadingWorkflow(Guid workflowId);
    [EtwEvent("45089")]
public void WorkflowActivityExecutionFailed(Guid workflowId, string activityName, string failureDescription);
    [EtwEvent("45087")]
public void WorkflowActivityValidated(Guid workflowId, string activityDisplayName, string activityType);
    [EtwEvent("45088")]
public void WorkflowActivityValidationFailed(Guid workflowId, string activityDisplayName, string activityType);
    [EtwEvent("45096")]
public void WorkflowCleanupPerformed(Guid workflowId);
    [EtwEvent("45098")]
public void WorkflowDeletedFromDisk(Guid workflowId, string path);
    [EtwEvent("45128")]
public void WorkflowEngineStarted(string endpointName);
    [EtwEvent("45095")]
public void WorkflowExecutionAborted(Guid workflowId);
    [EtwEvent("45094")]
public void WorkflowExecutionCancelled(Guid workflowId);
    [EtwEvent("45120")]
public void WorkflowExecutionError(Guid workflowId, string errorDescription);
    [EtwEvent("45110")]
public void WorkflowExecutionFinished(Guid workflowId);
    [EtwEvent("45064")]
public void WorkflowExecutionStarted(Guid workflowId, string managedNodes);
    [EtwEvent("45104")]
public void WorkflowJobCreated(Guid parentJobId, Guid childJobId, Guid childWorkflowId);
    [EtwEvent("45092")]
public void WorkflowLoadedForExecution(Guid workflowId);
    [EtwEvent("45097")]
public void WorkflowLoadedFromDisk(Guid workflowId, string path);
    [EtwEvent("45129")]
public void WorkflowManagerCheckpoint(string checkpointPath, string configProviderId, string userName, string path);
    [EtwEvent("45118")]
public void WorkflowPersisted(Guid workflowId);
    [EtwEvent("45072")]
public void WorkflowPluginRequestedToShutdown(string endpointName);
    [EtwEvent("45073")]
public void WorkflowPluginRestarted(string endpointName);
    [EtwEvent("45063")]
public void WorkflowPluginStarted(string endpointName, string user, string hostingMode, string protocol, string configuration);
    [EtwEvent("45075")]
public void WorkflowQuotaViolated(string endpointName, string configName, string allowedValue, string valueInQuestion);
    [EtwEvent("45076")]
public void WorkflowResumed(Guid workflowId);
    [EtwEvent("45074")]
public void WorkflowResuming(Guid workflowId);
    [EtwEvent("45078")]
public void WorkflowRunspacePoolCreated(Guid workflowId, string managedNode);
    [EtwEvent("45065")]
public void WorkflowStateChanged(Guid workflowId, string newState, string oldState);
    [EtwEvent("45093")]
public void WorkflowUnloaded(Guid workflowId);
    [EtwEvent("45086")]
public void WorkflowValidationError(Guid workflowId);
    [EtwEvent("45085")]
public void WorkflowValidationFinished(Guid workflowId);
    [EtwEvent("45084")]
public void WorkflowValidationStarted(Guid workflowId);
}
internal static class System.Management.Automation.TypeAccelerators : object {
    internal static Dictionary`2<string, Type> builtinTypeAccelerators;
    internal static Dictionary`2<string, Type> userTypeAccelerators;
    private static Dictionary`2<string, Type> s_allTypeAccelerators;
    public static Dictionary`2<string, Type> Get { get; }
    private static TypeAccelerators();
    internal static string FindBuiltinAccelerator(Type type, string expectedKey);
    public static void Add(string typeName, Type type);
    public static bool Remove(string typeName);
    public static Dictionary`2<string, Type> get_Get();
    internal static void FillCache(Dictionary`2<string, Type> cache);
}
internal class System.Management.Automation.TypeDeserializerDelegate : MulticastDelegate {
    public TypeDeserializerDelegate(object object, IntPtr method);
    public virtual object Invoke(InternalDeserializer deserializer);
    public virtual IAsyncResult BeginInvoke(InternalDeserializer deserializer, AsyncCallback callback, object object);
    public virtual object EndInvoke(IAsyncResult result);
}
internal class System.Management.Automation.TypeInference : object {
    [TraceSourceAttribute("ETS", "Extended Type System")]
private static PSTraceSource s_tracer;
    private HashSet`1[] _typeParameterIndexToSetOfInferenceCandidates;
    internal TypeInference(ICollection`1<Type> typeParameters);
    private static TypeInference();
    internal static MethodInformation Infer(MethodInformation genericMethod, Type[] argumentTypes);
    private static MethodInfo Infer(MethodInfo genericMethod, Type[] typesOfMethodArguments, bool hasVarArgs);
    private static MethodInfo Infer(MethodInfo genericMethod, ICollection`1<Type> typeParameters, IEnumerable`1<Type> typesOfMethodParameters, IEnumerable`1<Type> typesOfMethodArguments);
    internal Type GetInferredType(Type typeParameter);
    internal bool UnifyMultipleTerms(IEnumerable`1<Type> parameterTypes, IEnumerable`1<Type> argumentTypes);
    private bool Unify(Type parameterType, Type argumentType);
    private bool UnifyConstructedType(Type parameterType, Type argumentType);
    private static bool IsEqualGenericTypeDefinition(Type parameterType, Type argumentType);
}
internal class System.Management.Automation.TypeInferenceContext : object {
    public static PSTypeName[] EmptyPSTypeNameArray;
    private PowerShell _powerShell;
    [CompilerGeneratedAttribute]
private PSTypeName <CurrentThisType>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDefinitionAst <CurrentTypeDefinitionAst>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeInferenceRuntimePermissions <RuntimePermissions>k__BackingField;
    [CompilerGeneratedAttribute]
private PowerShellExecutionHelper <Helper>k__BackingField;
    public PSTypeName CurrentThisType { get; public set; }
    public TypeDefinitionAst CurrentTypeDefinitionAst { get; public set; }
    public TypeInferenceRuntimePermissions RuntimePermissions { get; public set; }
    internal PowerShellExecutionHelper Helper { get; }
    internal ExecutionContext ExecutionContext { get; }
    public TypeInferenceContext(PowerShell powerShell);
    private static TypeInferenceContext();
    [CompilerGeneratedAttribute]
public PSTypeName get_CurrentThisType();
    [CompilerGeneratedAttribute]
public void set_CurrentThisType(PSTypeName value);
    [CompilerGeneratedAttribute]
public TypeDefinitionAst get_CurrentTypeDefinitionAst();
    [CompilerGeneratedAttribute]
public void set_CurrentTypeDefinitionAst(TypeDefinitionAst value);
    [CompilerGeneratedAttribute]
public TypeInferenceRuntimePermissions get_RuntimePermissions();
    [CompilerGeneratedAttribute]
public void set_RuntimePermissions(TypeInferenceRuntimePermissions value);
    [CompilerGeneratedAttribute]
internal PowerShellExecutionHelper get_Helper();
    internal ExecutionContext get_ExecutionContext();
    public bool TryGetRepresentativeTypeNameFromExpressionSafeEval(ExpressionAst expression, PSTypeName& typeName);
    internal IList`1<object> GetMembersByInferredType(PSTypeName typename, bool isStatic, Func`2<object, bool> filter);
    internal void AddMembersByInferredTypesClrType(PSTypeName typename, bool isStatic, Func`2<object, bool> filter, Func`2<object, bool> filterToCall, List`1<object> results);
    internal void AddMembersByInferredTypeDefinitionAst(PSTypeName typename, bool isStatic, Func`2<object, bool> filter, Func`2<object, bool> filterToCall, List`1<object> results);
    internal void AddMembersByInferredTypeCimType(PSTypeName typename, List`1<object> results, Func`2<object, bool> filterToCall);
    internal IEnumerable`1<PSTypeName> InferType(Ast ast, TypeInferenceVisitor visitor);
    private static bool TryGetRepresentativeTypeNameFromValue(object value, PSTypeName& type);
    internal static bool ParseCimCommandsTypeName(PSTypeName typename, String& cimNamespace, String& className);
    private static bool IsMemberHidden(object member);
    private static bool IsConstructor(object member);
}
[ExtensionAttribute]
internal static class System.Management.Automation.TypeInferenceExtension : object {
    [ExtensionAttribute]
public static bool EqualsOrdinalIgnoreCase(string s, string t);
    [ExtensionAttribute]
public static IEnumerable`1<MethodInfo> GetGetterProperty(Type type, string propertyName);
    [ExtensionAttribute]
public static bool AstAssignsToSameVariable(VariableExpressionAst variableAst, Ast ast);
}
public enum System.Management.Automation.TypeInferenceRuntimePermissions : Enum {
    public int value__;
    public static TypeInferenceRuntimePermissions None;
    public static TypeInferenceRuntimePermissions AllowSafeEval;
}
internal class System.Management.Automation.TypeInferenceVisitor : object {
    private TypeInferenceContext _context;
    private static PSTypeName StringPSTypeName;
    public TypeInferenceVisitor(TypeInferenceContext context);
    private static TypeInferenceVisitor();
    private IEnumerable`1<PSTypeName> InferTypes(Ast ast);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitTypeExpression(TypeExpressionAst typeExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitMemberExpression(MemberExpressionAst memberExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitInvokeMemberExpression(InvokeMemberExpressionAst invokeMemberExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitArrayExpression(ArrayExpressionAst arrayExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitArrayLiteral(ArrayLiteralAst arrayLiteralAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitHashtable(HashtableAst hashtableAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitScriptBlockExpression(ScriptBlockExpressionAst scriptBlockExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitParenExpression(ParenExpressionAst parenExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitExpandableStringExpression(ExpandableStringExpressionAst expandableStringExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitIndexExpression(IndexExpressionAst indexExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitAttributedExpression(AttributedExpressionAst attributedExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitBlockStatement(BlockStatementAst blockStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitUsingExpression(UsingExpressionAst usingExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitVariableExpression(VariableExpressionAst ast);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitMergingRedirection(MergingRedirectionAst mergingRedirectionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitBinaryExpression(BinaryExpressionAst binaryExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitUnaryExpression(UnaryExpressionAst unaryExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitConvertExpression(ConvertExpressionAst convertExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitConstantExpression(ConstantExpressionAst constantExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitStringConstantExpression(StringConstantExpressionAst stringConstantExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitSubExpression(SubExpressionAst subExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitErrorStatement(ErrorStatementAst errorStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitErrorExpression(ErrorExpressionAst errorExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitScriptBlock(ScriptBlockAst scriptBlockAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitParamBlock(ParamBlockAst paramBlockAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitNamedBlock(NamedBlockAst namedBlockAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitTypeConstraint(TypeConstraintAst typeConstraintAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitAttribute(AttributeAst attributeAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitNamedAttributeArgument(NamedAttributeArgumentAst namedAttributeArgumentAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitParameter(ParameterAst parameterAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitFunctionDefinition(FunctionDefinitionAst functionDefinitionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitStatementBlock(StatementBlockAst statementBlockAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitIfStatement(IfStatementAst ifStmtAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitTrap(TrapStatementAst trapStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitSwitchStatement(SwitchStatementAst switchStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitDataStatement(DataStatementAst dataStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitForEachStatement(ForEachStatementAst forEachStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitDoWhileStatement(DoWhileStatementAst doWhileStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitForStatement(ForStatementAst forStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitWhileStatement(WhileStatementAst whileStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitCatchClause(CatchClauseAst catchClauseAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitTryStatement(TryStatementAst tryStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitBreakStatement(BreakStatementAst breakStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitContinueStatement(ContinueStatementAst continueStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitReturnStatement(ReturnStatementAst returnStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitExitStatement(ExitStatementAst exitStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitThrowStatement(ThrowStatementAst throwStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitDoUntilStatement(DoUntilStatementAst doUntilStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitAssignmentStatement(AssignmentStatementAst assignmentStatementAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitPipeline(PipelineAst pipelineAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitCommand(CommandAst commandAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitCommandExpression(CommandExpressionAst commandExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitCommandParameter(CommandParameterAst commandParameterAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor.VisitFileRedirection(FileRedirectionAst fileRedirectionAst);
    private void InferTypesFrom(CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private List`1<PSTypeName> InferTypesFromObjectCmdlets(CommandAst commandAst, CmdletInfo cmdletInfo, PseudoBindingInfo pseudoBinding);
    private static void InferTypesFromCimCommand(PseudoBindingInfo pseudoBinding, List`1<PSTypeName> inferredTypes);
    private void InferTypesFromForeachCommand(PseudoBindingInfo pseudoBinding, CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private void InferTypesFromGroupCommand(PseudoBindingInfo pseudoBinding, CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private void InferTypesFromWhereAndSortCommand(CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private void InferTypesFromPreviousCommand(CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private void InferTypesFromSelectCommand(PseudoBindingInfo pseudoBinding, CommandAst commandAst, List`1<PSTypeName> inferredTypes);
    private List`1<PSMemberNameAndType> GetMemberNameAndTypeFromProperties(PSTypeName t, Func`2<object, bool> isInPropertyList);
    private static bool IsProperty(object member);
    private static string GetMemberName(object member);
    private static PSTypeName InferTypesFromNewObjectCommand(PseudoBindingInfo pseudoBinding);
    private IEnumerable`1<PSTypeName> InferTypesFrom(MemberExpressionAst memberExpressionAst);
    private void GetTypesOfMembers(PSTypeName thisType, string memberName, IList`1<object> members, Boolean& maybeWantDefaultCtor, bool isInvokeMemberExpressionAst, List`1<PSTypeName> inferredTypes);
    private void AddTypesOfMembers(PSTypeName currentType, List`1<string> memberNamesToCheck, IList`1<object> members, Boolean& maybeWantDefaultCtor, bool isInvokeMemberExpressionAst, IList`1<ITypeName> genericTypeArguments, List`1<PSTypeName> result);
    private bool TryGetTypeFromMember(PSTypeName currentType, object member, string memberName, Boolean& maybeWantDefaultCtor, bool isInvokeMemberExpressionAst, IList`1<ITypeName> genericTypeArguments, List`1<PSTypeName> result, List`1<string> memberNamesToCheck);
    private static void AddTypesFromMethodCacheEntry(MethodCacheEntry methodCacheEntry, IList`1<ITypeName> genericTypeArguments, List`1<PSTypeName> result, bool isInvokeMemberExpressionAst);
    private PSTypeName[] GetExpressionType(ExpressionAst expression, bool isStatic);
    private void InferTypeFrom(VariableExpressionAst variableExpressionAst, List`1<PSTypeName> inferredTypes);
    private static PSTypeName GetArrayType(IEnumerable`1<PSTypeName> inferredTypes);
    private static Type GetMostSpecificEnumeratedItemType(Type enumerableType);
    private static Type GetGenericCollectionLikeInterface(Type interfaceType, Boolean& hasSeenNonGeneric, Boolean& hasSeenDictionaryEnumerator);
    [IteratorStateMachineAttribute("System.Management.Automation.TypeInferenceVisitor/<InferTypeFrom>d__80")]
private IEnumerable`1<PSTypeName> InferTypeFrom(IndexExpressionAst indexExpressionAst);
    [IteratorStateMachineAttribute("System.Management.Automation.TypeInferenceVisitor/<GetInferredEnumeratedTypes>d__81")]
internal static IEnumerable`1<PSTypeName> GetInferredEnumeratedTypes(IEnumerable`1<PSTypeName> enumerableTypes);
    private void GetInferredTypeFromScriptBlockParameter(AstParameterArgumentPair argument, List`1<PSTypeName> inferredTypes);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitTypeDefinition(TypeDefinitionAst typeDefinitionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitPropertyMember(PropertyMemberAst propertyMemberAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitFunctionMember(FunctionMemberAst functionMemberAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitBaseCtorInvokeMemberExpression(BaseCtorInvokeMemberExpressionAst baseCtorInvokeMemberExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitUsingStatement(UsingStatementAst usingStatement);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitConfigurationDefinition(ConfigurationDefinitionAst configurationDefinitionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitDynamicKeywordStatement(DynamicKeywordStatementAst dynamicKeywordAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitTernaryExpression(TernaryExpressionAst ternaryExpressionAst);
    private sealed virtual override object System.Management.Automation.Language.ICustomAstVisitor2.VisitPipelineChain(PipelineChainAst pipelineChainAst);
    private static CommandBaseAst GetPreviousPipelineCommand(CommandAst commandAst);
    [CompilerGeneratedAttribute]
private void <InferTypesFromSelectCommand>g__InferFromSelectProperties|65_0(AstParameterArgumentPair astParameterArgumentPair, CommandBaseAst previousPipelineElementAst, bool includeMatchedProperties, <>c__DisplayClass65_0& );
    [CompilerGeneratedAttribute]
internal static object <InferTypesFromSelectCommand>g__ToWildCardOrString|65_1(string value);
}
internal static class System.Management.Automation.TypeOps : object {
    internal static Type ResolveTypeName(ITypeName typeName, IScriptExtent errorPos);
    internal static bool IsInstance(object left, object right);
    internal static object AsOperator(object left, Type type);
    internal static String[] GetNamespacesForTypeResolutionState(IEnumerable`1<UsingStatementAst> usingAsts);
    internal static void AddPowerShellTypesToTheScope(Dictionary`2<string, TypeDefinitionAst> types, ExecutionContext context);
    internal static void InitPowerShellTypesAtRuntime(TypeDefinitionAst[] types);
    internal static void SetCurrentTypeResolutionState(TypeResolutionState trs, ExecutionContext context);
    internal static void SetAssemblyDefiningPSTypes(FunctionContext functionContext, Assembly assembly);
}
internal class System.Management.Automation.TypeSerializationInfo : object {
    [CompilerGeneratedAttribute]
private Type <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ItemTag>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PropertyTag>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeSerializerDelegate <Serializer>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDeserializerDelegate <Deserializer>k__BackingField;
    internal Type Type { get; }
    internal string ItemTag { get; }
    internal string PropertyTag { get; }
    internal TypeSerializerDelegate Serializer { get; }
    internal TypeDeserializerDelegate Deserializer { get; }
    internal TypeSerializationInfo(Type type, string itemTag, string propertyTag, TypeSerializerDelegate serializer, TypeDeserializerDelegate deserializer);
    [CompilerGeneratedAttribute]
internal Type get_Type();
    [CompilerGeneratedAttribute]
internal string get_ItemTag();
    [CompilerGeneratedAttribute]
internal string get_PropertyTag();
    [CompilerGeneratedAttribute]
internal TypeSerializerDelegate get_Serializer();
    [CompilerGeneratedAttribute]
internal TypeDeserializerDelegate get_Deserializer();
}
internal class System.Management.Automation.TypeSerializerDelegate : MulticastDelegate {
    public TypeSerializerDelegate(object object, IntPtr method);
    public virtual void Invoke(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry);
    public virtual IAsyncResult BeginInvoke(InternalSerializer serializer, string streamName, string property, object source, TypeSerializationInfo entry, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal static class System.Management.Automation.UIntOps : object {
    internal static object Add(UInt32 lhs, UInt32 rhs);
    internal static object Sub(UInt32 lhs, UInt32 rhs);
    internal static object Multiply(UInt32 lhs, UInt32 rhs);
    internal static object Divide(UInt32 lhs, UInt32 rhs);
    internal static object Remainder(UInt32 lhs, UInt32 rhs);
    internal static object CompareEq(UInt32 lhs, UInt32 rhs);
    internal static object CompareNe(UInt32 lhs, UInt32 rhs);
    internal static object CompareLt(UInt32 lhs, UInt32 rhs);
    internal static object CompareLe(UInt32 lhs, UInt32 rhs);
    internal static object CompareGt(UInt32 lhs, UInt32 rhs);
    internal static object CompareGe(UInt32 lhs, UInt32 rhs);
}
internal static class System.Management.Automation.ULongOps : object {
    internal static object Add(ulong lhs, ulong rhs);
    internal static object Sub(ulong lhs, ulong rhs);
    internal static object Multiply(ulong lhs, ulong rhs);
    internal static object Divide(ulong lhs, ulong rhs);
    internal static object Remainder(ulong lhs, ulong rhs);
    internal static object CompareEq(ulong lhs, ulong rhs);
    internal static object CompareNe(ulong lhs, ulong rhs);
    internal static object CompareLt(ulong lhs, ulong rhs);
    internal static object CompareLe(ulong lhs, ulong rhs);
    internal static object CompareGt(ulong lhs, ulong rhs);
    internal static object CompareGe(ulong lhs, ulong rhs);
}
internal class System.Management.Automation.UnboundParameter : object {
    [CompilerGeneratedAttribute]
private static object <Value>k__BackingField;
    internal static object Value { get; }
    private static UnboundParameter();
    [CompilerGeneratedAttribute]
internal static object get_Value();
}
internal enum System.Management.Automation.UnhandledBreakpointProcessingMode : Enum {
    public int value__;
    public static UnhandledBreakpointProcessingMode Ignore;
    public static UnhandledBreakpointProcessingMode Wait;
}
internal class System.Management.Automation.UserDefinedHelpData : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<string, string> <Properties>k__BackingField;
    private string _name;
    internal Dictionary`2<string, string> Properties { get; }
    internal string Name { get; }
    [CompilerGeneratedAttribute]
internal Dictionary`2<string, string> get_Properties();
    internal string get_Name();
    internal static UserDefinedHelpData Load(XmlNode dataNode);
}
internal class System.Management.Automation.UsingExpressionAstSearcher : AstSearcher {
    private UsingExpressionAstSearcher(Func`2<Ast, bool> callback, bool stopOnFirst, bool searchNestedScriptBlocks);
    internal static IEnumerable`1<Ast> FindAllUsingExpressions(Ast ast);
    public virtual AstVisitAction VisitFunctionDefinition(FunctionDefinitionAst ast);
}
[ExtensionAttribute]
internal static class System.Management.Automation.Utils : object {
    internal static String[] AllowedEditionValues;
    private static string s_pshome;
    private static string s_windowsPowerShellVersion;
    private static String[] s_productFolderDirectories;
    internal static string DefaultPowerShellShellID;
    internal static string ProductNameForDirectory;
    internal static string WslRootPath;
    internal static string ModuleDirectory;
    internal static ConfigScope[] SystemWideOnlyConfig;
    internal static ConfigScope[] CurrentUserOnlyConfig;
    internal static ConfigScope[] SystemWideThenCurrentUserConfig;
    internal static ConfigScope[] CurrentUserThenSystemWideConfig;
    private static ConcurrentDictionary`2<ConfigScope, PowerShellPolicies> s_cachedPoliciesFromConfigFile;
    private static Dictionary`2<string, string> GroupPolicyKeys;
    private static Dictionary`2<string, string> WindowsPowershellGroupPolicyKeys;
    private static string PolicySettingFallbackKey;
    private static ConcurrentDictionary`2<ConfigScope, ConcurrentDictionary`2<string, PolicyBase>> s_cachedPoliciesFromRegistry;
    private static Func`2<ConfigScope, ConcurrentDictionary`2<string, PolicyBase>> s_subCacheCreationDelegate;
    internal static string ScheduledJobModuleName;
    internal static string PowerShellAssemblyStrongNameFormat;
    internal static HashSet`1<string> PowerShellAssemblies;
    internal static Encoding BigEndianUTF32Encoding;
    internal static string DefaultPowerShellAppBase { get; }
    private static Utils();
    [ExtensionAttribute]
internal static BigInteger AsBigInt(double d);
    internal static bool TryCast(BigInteger value, Byte& b);
    internal static bool TryCast(BigInteger value, SByte& sb);
    internal static bool TryCast(BigInteger value, Int16& s);
    internal static bool TryCast(BigInteger value, UInt16& us);
    internal static bool TryCast(BigInteger value, Int32& i);
    internal static bool TryCast(BigInteger value, UInt32& u);
    internal static bool TryCast(BigInteger value, Int64& l);
    internal static bool TryCast(BigInteger value, UInt64& ul);
    internal static bool TryCast(BigInteger value, Decimal& dm);
    internal static bool TryCast(BigInteger value, Double& db);
    internal static BigInteger ParseBinary(ReadOnlySpan`1<char> digits, bool unsigned);
    internal static int CombineHashCodes(int h1, int h2);
    internal static int CombineHashCodes(int h1, int h2, int h3);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7);
    internal static int CombineHashCodes(int h1, int h2, int h3, int h4, int h5, int h6, int h7, int h8);
    internal static void CheckKeyArg(Byte[] arg, string argName);
    internal static void CheckArgForNullOrEmpty(string arg, string argName);
    internal static void CheckArgForNull(object arg, string argName);
    internal static void CheckSecureStringArg(SecureString arg, string argName);
    internal static string GetStringFromSecureString(SecureString ss);
    internal static TypeTable GetTypeTableFromExecutionContextTLS();
    internal static string GetApplicationBaseFromRegistry(string shellId);
    internal static string GetWindowsPowerShellVersionFromRegistry();
    internal static string get_DefaultPowerShellAppBase();
    internal static string GetApplicationBase(string shellId);
    private static String[] GetProductFolderDirectories();
    internal static bool IsUnderProductFolder(string filePath);
    internal static bool IsRunningFromSysWOW64();
    internal static bool IsWinPEHost();
    internal static string GetCurrentMajorVersion();
    internal static Version StringToVersion(string versionString);
    internal static bool IsPSEditionSupported(string checkEdition);
    internal static bool IsPSEditionSupported(IEnumerable`1<string> editions);
    internal static bool IsValidPSEditionValue(string editionValue);
    internal static T GetPolicySetting(ConfigScope[] preferenceOrder);
    private static T GetPolicySettingFromConfigFile(ConfigScope[] preferenceOrder);
    private static bool TrySetPolicySettingsFromRegistryKey(object instance, Type instanceType, RegistryKey gpoKey);
    private static T GetPolicySettingFromGPOImpl(ConfigScope scope);
    private static T GetPolicySettingFromGPO(ConfigScope[] preferenceOrder);
    internal static void EnsureModuleLoaded(string module, ExecutionContext context);
    internal static List`1<PSModuleInfo> GetModules(string module, ExecutionContext context);
    internal static List`1<PSModuleInfo> GetModules(ModuleSpecification fullyQualifiedName, ExecutionContext context);
    private static bool TryGetWindowsCurrentIdentity(WindowsIdentity& currentIdentity);
    internal static bool TryGetWindowsImpersonatedIdentity(WindowsIdentity& impersonatedIdentity);
    internal static bool IsAdministrator();
    internal static bool IsReservedDeviceName(string destinationPath);
    internal static bool PathIsUnc(string path, bool networkOnly);
    internal static bool PathIsDevicePath(string path);
    internal static bool IsPowerShellAssembly(string assemblyName);
    internal static string GetPowerShellAssemblyStrongName(string assemblyName);
    internal static Mutex SafeWaitMutex(Mutex mutex, MutexInitializer initializer);
    internal static bool Succeeded(int hresult);
    internal static void QueueWorkItemWithImpersonation(WindowsIdentity identityToImpersonate, WaitCallback threadProc, object state);
    private static void WorkItemCallback(object callBackArgs);
    internal static string ParseCommandName(string commandName, String& moduleName);
    internal static ReadOnlyCollection`1<T> EmptyReadOnlyCollection();
    internal static bool IsComObject(object obj);
    internal static PSLanguageMode EnforceSystemLockDownLanguageMode(ExecutionContext context);
    internal static string DisplayHumanReadableFileSize(long bytes);
    internal static bool IsSessionRestricted(ExecutionContext context);
}
[AttributeUsageAttribute("384")]
public abstract class System.Management.Automation.ValidateArgumentsAttribute : CmdletMetadataAttribute {
    protected abstract virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
    internal void InternalValidate(object o, EngineIntrinsics engineIntrinsics);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateCountAttribute : ValidateArgumentsAttribute {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; }
    public int MaxLength { get; }
    public ValidateCountAttribute(int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    protected virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateDriveAttribute : ValidateArgumentsAttribute {
    private String[] _validRootDrives;
    public IList`1<string> ValidRootDrives { get; }
    public ValidateDriveAttribute(String[] validRootDrives);
    public IList`1<string> get_ValidRootDrives();
    protected virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
    private string ValidDriveListAsString();
}
[AttributeUsageAttribute("384")]
public abstract class System.Management.Automation.ValidateEnumeratedArgumentsAttribute : ValidateArgumentsAttribute {
    private CallSite`1<Func`3<CallSite, object, IEnumerator>> _getEnumeratorSite;
    protected abstract virtual void ValidateElement(object element);
    protected sealed virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateLengthAttribute : ValidateEnumeratedArgumentsAttribute {
    [CompilerGeneratedAttribute]
private int <MinLength>k__BackingField;
    [CompilerGeneratedAttribute]
private int <MaxLength>k__BackingField;
    public int MinLength { get; }
    public int MaxLength { get; }
    public ValidateLengthAttribute(int minLength, int maxLength);
    [CompilerGeneratedAttribute]
public int get_MinLength();
    [CompilerGeneratedAttribute]
public int get_MaxLength();
    protected virtual void ValidateElement(object element);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateNotNullAttribute : NullValidationAttributeBase {
    protected virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
}
public abstract class System.Management.Automation.ValidateNotNullOrAttributeBase : NullValidationAttributeBase {
    protected bool _checkWhiteSpace;
    protected ValidateNotNullOrAttributeBase(bool checkWhiteSpace);
    protected virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateNotNullOrEmptyAttribute : ValidateNotNullOrAttributeBase {
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateNotNullOrWhiteSpaceAttribute : ValidateNotNullOrAttributeBase {
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidatePatternAttribute : ValidateEnumeratedArgumentsAttribute {
    [CompilerGeneratedAttribute]
private string <RegexPattern>k__BackingField;
    [CompilerGeneratedAttribute]
private RegexOptions <Options>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    public string RegexPattern { get; }
    public RegexOptions Options { get; public set; }
    public string ErrorMessage { get; public set; }
    public ValidatePatternAttribute(string regexPattern);
    [CompilerGeneratedAttribute]
public string get_RegexPattern();
    [CompilerGeneratedAttribute]
public RegexOptions get_Options();
    [CompilerGeneratedAttribute]
public void set_Options(RegexOptions value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    protected virtual void ValidateElement(object element);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateRangeAttribute : ValidateEnumeratedArgumentsAttribute {
    [CompilerGeneratedAttribute]
private object <MinRange>k__BackingField;
    private IComparable _minComparable;
    [CompilerGeneratedAttribute]
private object <MaxRange>k__BackingField;
    private IComparable _maxComparable;
    private Type _promotedType;
    private Nullable`1<ValidateRangeKind> _rangeKind;
    public object MinRange { get; }
    public object MaxRange { get; }
    internal Nullable`1<ValidateRangeKind> RangeKind { get; }
    public ValidateRangeAttribute(object minRange, object maxRange);
    public ValidateRangeAttribute(ValidateRangeKind kind);
    [CompilerGeneratedAttribute]
public object get_MinRange();
    [CompilerGeneratedAttribute]
public object get_MaxRange();
    internal Nullable`1<ValidateRangeKind> get_RangeKind();
    protected virtual void ValidateElement(object element);
    private static void ValidateRange(object element, ValidateRangeKind rangeKind);
    private void ValidateRange(object element);
    private static void ValidateTimeSpanRange(TimeSpan element, ValidateRangeKind rangeKind);
    private static Type GetCommonType(Type minType, Type maxType);
    [IteratorStateMachineAttribute("System.Management.Automation.ValidateRangeAttribute/<GetValidatedElements>d__19")]
internal IEnumerable GetValidatedElements(IEnumerable elementsToValidate);
}
public enum System.Management.Automation.ValidateRangeKind : Enum {
    public int value__;
    public static ValidateRangeKind Positive;
    public static ValidateRangeKind NonNegative;
    public static ValidateRangeKind Negative;
    public static ValidateRangeKind NonPositive;
}
public class System.Management.Automation.ValidateScriptAttribute : ValidateEnumeratedArgumentsAttribute {
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private ScriptBlock <ScriptBlock>k__BackingField;
    public string ErrorMessage { get; public set; }
    public ScriptBlock ScriptBlock { get; }
    public ValidateScriptAttribute(ScriptBlock scriptBlock);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public ScriptBlock get_ScriptBlock();
    protected virtual void ValidateElement(object element);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateSetAttribute : ValidateEnumeratedArgumentsAttribute {
    private String[] _validValues;
    private IValidateSetValuesGenerator validValuesGenerator;
    private static ConcurrentDictionary`2<Type, IValidateSetValuesGenerator> s_ValidValuesGeneratorCache;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreCase>k__BackingField;
    public string ErrorMessage { get; public set; }
    public bool IgnoreCase { get; public set; }
    public IList`1<string> ValidValues { get; }
    public ValidateSetAttribute(String[] validValues);
    public ValidateSetAttribute(Type valuesGeneratorType);
    private static ValidateSetAttribute();
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreCase();
    [CompilerGeneratedAttribute]
public void set_IgnoreCase(bool value);
    public IList`1<string> get_ValidValues();
    protected virtual void ValidateElement(object element);
    private string SetAsString();
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateTrustedDataAttribute : ValidateArgumentsAttribute {
    protected virtual void Validate(object arguments, EngineIntrinsics engineIntrinsics);
}
[AttributeUsageAttribute("384")]
public class System.Management.Automation.ValidateUserDriveAttribute : ValidateDriveAttribute {
}
public class System.Management.Automation.ValidationMetadataException : MetadataException {
    internal static string ValidateRangeElementType;
    internal static string ValidateRangePositiveFailure;
    internal static string ValidateRangeNonNegativeFailure;
    internal static string ValidateRangeNegativeFailure;
    internal static string ValidateRangeNonPositiveFailure;
    internal static string ValidateRangeMinRangeMaxRangeType;
    internal static string ValidateRangeNotIComparable;
    internal static string ValidateRangeMaxRangeSmallerThanMinRange;
    internal static string ValidateRangeGreaterThanMaxRangeFailure;
    internal static string ValidateRangeSmallerThanMinRangeFailure;
    internal static string ValidateFailureResult;
    internal static string ValidatePatternFailure;
    internal static string ValidateScriptFailure;
    internal static string ValidateCountNotInArray;
    internal static string ValidateCountMaxLengthSmallerThanMinLength;
    internal static string ValidateCountMinLengthFailure;
    internal static string ValidateCountMaxLengthFailure;
    internal static string ValidateLengthMaxLengthSmallerThanMinLength;
    internal static string ValidateLengthNotString;
    internal static string ValidateLengthMinLengthFailure;
    internal static string ValidateLengthMaxLengthFailure;
    internal static string ValidateSetFailure;
    internal static string ValidateVersionFailure;
    internal static string InvalidValueFailure;
    private bool _swallowException;
    internal bool SwallowException { get; }
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected ValidationMetadataException(SerializationInfo info, StreamingContext context);
    public ValidationMetadataException(string message);
    public ValidationMetadataException(string message, Exception innerException);
    internal ValidationMetadataException(string errorId, Exception innerException, string resourceStr, Object[] arguments);
    internal ValidationMetadataException(string message, bool swallowException);
    internal bool get_SwallowException();
}
public enum System.Management.Automation.VariableAccessMode : Enum {
    public int value__;
    public static VariableAccessMode Read;
    public static VariableAccessMode Write;
    public static VariableAccessMode ReadWrite;
}
public class System.Management.Automation.VariableBreakpoint : Breakpoint {
    [CompilerGeneratedAttribute]
private VariableAccessMode <AccessMode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Variable>k__BackingField;
    public VariableAccessMode AccessMode { get; }
    public string Variable { get; }
    public VariableBreakpoint(string script, string variable, VariableAccessMode accessMode);
    public VariableBreakpoint(string script, string variable, VariableAccessMode accessMode, ScriptBlock action);
    public VariableBreakpoint(string script, string variable, VariableAccessMode accessMode, int id);
    public VariableBreakpoint(string script, string variable, VariableAccessMode accessMode, ScriptBlock action, int id);
    [CompilerGeneratedAttribute]
public VariableAccessMode get_AccessMode();
    [CompilerGeneratedAttribute]
public string get_Variable();
    public virtual string ToString();
    internal bool Trigger(string currentScriptFile, bool read);
    internal virtual bool RemoveSelf(ScriptDebugger debugger);
}
internal static class System.Management.Automation.VariableOps : object {
    internal static object SetVariableValue(VariablePath variablePath, object value, ExecutionContext executionContext, AttributeBaseAst[] attributeAsts);
    private static bool ThrowStrictModeUndefinedVariable(ExecutionContext executionContext, VariableExpressionAst varAst);
    internal static object GetAutomaticVariableValue(int tupleIndex, ExecutionContext executionContext, VariableExpressionAst varAst);
    internal static object GetVariableValue(VariablePath variablePath, ExecutionContext executionContext, VariableExpressionAst varAst);
    internal static PSReference GetVariableAsRef(VariablePath variablePath, ExecutionContext executionContext, Type staticType);
    private static Collection`1<Attribute> GetAttributeCollection(AttributeBaseAst[] attributeAsts);
    private static UsingResult GetUsingValueFromTuple(MutableTuple tuple, string usingExpressionKey, int index);
    internal static object GetUsingValue(MutableTuple tuple, string usingExpressionKey, int index, ExecutionContext context);
}
public class System.Management.Automation.VariablePath : object {
    private string _userPath;
    private string _unqualifiedPath;
    private VariablePathFlags _flags;
    public string UserPath { get; }
    public bool IsGlobal { get; }
    public bool IsLocal { get; }
    public bool IsPrivate { get; }
    public bool IsScript { get; }
    public bool IsUnqualified { get; }
    public bool IsUnscopedVariable { get; }
    public bool IsVariable { get; }
    internal bool IsFunction { get; }
    public bool IsDriveQualified { get; }
    public string DriveName { get; }
    internal string UnqualifiedPath { get; }
    internal string QualifiedName { get; }
    public VariablePath(string path);
    internal VariablePath(string path, VariablePathFlags knownFlags);
    internal VariablePath CloneAndSetLocal();
    public string get_UserPath();
    public bool get_IsGlobal();
    public bool get_IsLocal();
    public bool get_IsPrivate();
    public bool get_IsScript();
    public bool get_IsUnqualified();
    public bool get_IsUnscopedVariable();
    public bool get_IsVariable();
    internal bool get_IsFunction();
    public bool get_IsDriveQualified();
    public string get_DriveName();
    internal string get_UnqualifiedPath();
    internal string get_QualifiedName();
    public virtual string ToString();
}
[FlagsAttribute]
internal enum System.Management.Automation.VariablePathFlags : Enum {
    public int value__;
    public static VariablePathFlags None;
    public static VariablePathFlags Local;
    public static VariablePathFlags Script;
    public static VariablePathFlags Global;
    public static VariablePathFlags Private;
    public static VariablePathFlags Variable;
    public static VariablePathFlags Function;
    public static VariablePathFlags DriveQualified;
    public static VariablePathFlags Unqualified;
    public static VariablePathFlags UnscopedVariableMask;
}
internal class System.Management.Automation.VariableScopeItemSearcher : ScopedItemSearcher`1<PSVariable> {
    private CommandOrigin _origin;
    public VariableScopeItemSearcher(SessionStateInternal sessionState, VariablePath lookupPath, CommandOrigin origin);
    protected virtual bool GetScopeItem(SessionStateScope scope, VariablePath name, PSVariable& variable);
}
internal static class System.Management.Automation.VerbAliasPrefixes : object {
    public static string Add;
    public static string Approve;
    public static string Assert;
    public static string Backup;
    public static string Block;
    public static string Build;
    public static string Checkpoint;
    public static string Clear;
    public static string Close;
    public static string Compare;
    public static string Complete;
    public static string Compress;
    public static string Confirm;
    public static string Connect;
    public static string Convert;
    public static string ConvertFrom;
    public static string ConvertTo;
    public static string Copy;
    public static string Debug;
    public static string Deny;
    public static string Deploy;
    public static string Disable;
    public static string Disconnect;
    public static string Dismount;
    public static string Edit;
    public static string Enable;
    public static string Enter;
    public static string Exit;
    public static string Expand;
    public static string Export;
    public static string Find;
    public static string Format;
    public static string Get;
    public static string Grant;
    public static string Group;
    public static string Hide;
    public static string Import;
    public static string Initialize;
    public static string Install;
    public static string Invoke;
    public static string Join;
    public static string Limit;
    public static string Lock;
    public static string Measure;
    public static string Merge;
    public static string Mount;
    public static string Move;
    public static string New;
    public static string Open;
    public static string Optimize;
    public static string Out;
    public static string Ping;
    public static string Pop;
    public static string Protect;
    public static string Publish;
    public static string Push;
    public static string Read;
    public static string Receive;
    public static string Redo;
    public static string Register;
    public static string Remove;
    public static string Rename;
    public static string Repair;
    public static string Request;
    public static string Reset;
    public static string Resize;
    public static string Resolve;
    public static string Restart;
    public static string Restore;
    public static string Resume;
    public static string Revoke;
    public static string Save;
    public static string Search;
    public static string Select;
    public static string Send;
    public static string Set;
    public static string Show;
    public static string Sync;
    public static string Skip;
    public static string Split;
    public static string Start;
    public static string Step;
    public static string Stop;
    public static string Submit;
    public static string Suspend;
    public static string Switch;
    public static string Test;
    public static string Trace;
    public static string Unblock;
    public static string Undo;
    public static string Uninstall;
    public static string Unlock;
    public static string Unprotect;
    public static string Unpublish;
    public static string Unregister;
    public static string Update;
    public static string Use;
    public static string Wait;
    public static string Watch;
    public static string Write;
    public static string GetVerbAliasPrefix(string verb);
}
internal static class System.Management.Automation.VerbDescriptions : object {
    public static string GetVerbDescription(string verb);
}
public class System.Management.Automation.VerbInfo : object {
    [CompilerGeneratedAttribute]
private string <Verb>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AliasPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Group>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    public string Verb { get; public set; }
    public string AliasPrefix { get; public set; }
    public string Group { get; public set; }
    public string Description { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Verb();
    [CompilerGeneratedAttribute]
public void set_Verb(string value);
    [CompilerGeneratedAttribute]
public string get_AliasPrefix();
    [CompilerGeneratedAttribute]
public void set_AliasPrefix(string value);
    [CompilerGeneratedAttribute]
public string get_Group();
    [CompilerGeneratedAttribute]
public void set_Group(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
}
[DataContractAttribute]
public class System.Management.Automation.VerboseRecord : InformationalRecord {
    public VerboseRecord(string message);
    public VerboseRecord(PSObject record);
}
internal static class System.Management.Automation.Verbs : object {
    private static Dictionary`2<string, bool> s_validVerbs;
    private static Dictionary`2<string, String[]> s_recommendedAlternateVerbs;
    private static Verbs();
    internal static bool IsStandard(string verb);
    internal static String[] SuggestedAlternates(string verb);
}
public static class System.Management.Automation.VerbsCommon : object {
    public static string Add;
    public static string Clear;
    public static string Close;
    public static string Copy;
    public static string Enter;
    public static string Exit;
    public static string Find;
    public static string Format;
    public static string Get;
    public static string Hide;
    public static string Join;
    public static string Lock;
    public static string Move;
    public static string New;
    public static string Open;
    public static string Optimize;
    public static string Push;
    public static string Pop;
    public static string Redo;
    public static string Remove;
    public static string Rename;
    public static string Reset;
    public static string Resize;
    public static string Search;
    public static string Select;
    public static string Set;
    public static string Show;
    public static string Skip;
    public static string Split;
    public static string Step;
    public static string Switch;
    public static string Undo;
    public static string Unlock;
    public static string Watch;
}
public static class System.Management.Automation.VerbsCommunications : object {
    public static string Connect;
    public static string Disconnect;
    public static string Read;
    public static string Receive;
    public static string Send;
    public static string Write;
}
public static class System.Management.Automation.VerbsData : object {
    public static string Backup;
    public static string Checkpoint;
    public static string Compare;
    public static string Compress;
    public static string Convert;
    public static string ConvertFrom;
    public static string ConvertTo;
    public static string Dismount;
    public static string Edit;
    public static string Expand;
    public static string Export;
    public static string Group;
    public static string Import;
    public static string Initialize;
    public static string Limit;
    public static string Merge;
    public static string Mount;
    public static string Out;
    public static string Publish;
    public static string Restore;
    public static string Save;
    public static string Sync;
    public static string Unpublish;
    public static string Update;
}
public static class System.Management.Automation.VerbsDiagnostic : object {
    public static string Debug;
    public static string Measure;
    public static string Ping;
    public static string Repair;
    public static string Resolve;
    public static string Test;
    public static string Trace;
}
public static class System.Management.Automation.VerbsLifecycle : object {
    public static string Approve;
    public static string Assert;
    public static string Build;
    public static string Complete;
    public static string Confirm;
    public static string Deny;
    public static string Deploy;
    public static string Disable;
    public static string Enable;
    public static string Install;
    public static string Invoke;
    public static string Register;
    public static string Request;
    public static string Restart;
    public static string Resume;
    public static string Start;
    public static string Stop;
    public static string Submit;
    public static string Suspend;
    public static string Uninstall;
    public static string Unregister;
    public static string Wait;
}
public static class System.Management.Automation.VerbsOther : object {
    public static string Use;
}
public static class System.Management.Automation.VerbsSecurity : object {
    public static string Block;
    public static string Grant;
    public static string Protect;
    public static string Revoke;
    public static string Unblock;
    public static string Unprotect;
}
internal class System.Management.Automation.VOID : object {
}
[ObsoleteAttribute("This class is deprecated. Use 'System.Management.Automation.PSStyle' instead.", "True")]
public class System.Management.Automation.VTUtility : object {
    private static Dictionary`2<ConsoleColor, string> ForegroundColorMap;
    private static Dictionary`2<VT, string> VTCodes;
    private static VTUtility();
    public static string GetEscapeSequence(ConsoleColor color);
    public static string GetEscapeSequence(VT vt);
}
[DataContractAttribute]
public class System.Management.Automation.WarningRecord : InformationalRecord {
    private string _fullyQualifiedWarningId;
    public string FullyQualifiedWarningId { get; }
    public WarningRecord(string message);
    public WarningRecord(PSObject record);
    public WarningRecord(string fullyQualifiedWarningId, string message);
    public WarningRecord(string fullyQualifiedWarningId, PSObject record);
    public string get_FullyQualifiedWarningId();
}
[DefaultMemberAttribute("Item")]
internal class System.Management.Automation.WeakReferenceDictionary`1 : object {
    private IEqualityComparer`1<WeakReference> _weakEqualityComparer;
    private Dictionary`2<WeakReference, T> _dictionary;
    private static int initialCleanupTriggerSize;
    private int _cleanupTriggerSize;
    public ICollection`1<object> Keys { get; }
    public ICollection`1<T> Values { get; }
    public T Item { get; public set; }
    private ICollection`1<KeyValuePair`2<WeakReference, T>> WeakCollection { get; }
    public int Count { get; }
    public bool IsReadOnly { get; }
    private void CleanUp();
    public sealed virtual void Add(object key, T value);
    public sealed virtual bool ContainsKey(object key);
    public sealed virtual ICollection`1<object> get_Keys();
    public sealed virtual bool Remove(object key);
    public sealed virtual bool TryGetValue(object key, T& value);
    public sealed virtual ICollection`1<T> get_Values();
    public sealed virtual T get_Item(object key);
    public sealed virtual void set_Item(object key, T value);
    private ICollection`1<KeyValuePair`2<WeakReference, T>> get_WeakCollection();
    private static KeyValuePair`2<WeakReference, T> WeakKeyValuePair(KeyValuePair`2<object, T> publicKeyValuePair);
    public sealed virtual void Add(KeyValuePair`2<object, T> item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(KeyValuePair`2<object, T> item);
    public sealed virtual void CopyTo(KeyValuePair`2[] array, int arrayIndex);
    public sealed virtual int get_Count();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual bool Remove(KeyValuePair`2<object, T> item);
    [IteratorStateMachineAttribute("System.Management.Automation.WeakReferenceDictionary`1/<GetEnumerator>d__30")]
public sealed virtual IEnumerator`1<KeyValuePair`2<object, T>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
[ExtensionAttribute]
internal static class System.Management.Automation.WeakReferenceExtensions : object {
    [ExtensionAttribute]
internal static bool TryGetTarget(WeakReference weakReference, T& target);
}
public enum System.Management.Automation.WhereOperatorSelectionMode : Enum {
    public int value__;
    public static WhereOperatorSelectionMode Default;
    public static WhereOperatorSelectionMode First;
    public static WhereOperatorSelectionMode Last;
    public static WhereOperatorSelectionMode SkipUntil;
    public static WhereOperatorSelectionMode Until;
    public static WhereOperatorSelectionMode Split;
}
public class System.Management.Automation.WideControl : PSControl {
    [CompilerGeneratedAttribute]
private List`1<WideControlEntryItem> <Entries>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AutoSize>k__BackingField;
    [CompilerGeneratedAttribute]
private UInt32 <Columns>k__BackingField;
    public List`1<WideControlEntryItem> Entries { get; internal set; }
    public bool AutoSize { get; public set; }
    public UInt32 Columns { get; internal set; }
    internal WideControl(WideControlBody widecontrolbody, ViewDefinition viewDefinition);
    public WideControl(IEnumerable`1<WideControlEntryItem> wideEntries);
    public WideControl(IEnumerable`1<WideControlEntryItem> wideEntries, UInt32 columns);
    public WideControl(UInt32 columns);
    [CompilerGeneratedAttribute]
public List`1<WideControlEntryItem> get_Entries();
    [CompilerGeneratedAttribute]
internal void set_Entries(List`1<WideControlEntryItem> value);
    [CompilerGeneratedAttribute]
public bool get_AutoSize();
    [CompilerGeneratedAttribute]
public void set_AutoSize(bool value);
    [CompilerGeneratedAttribute]
public UInt32 get_Columns();
    [CompilerGeneratedAttribute]
internal void set_Columns(UInt32 value);
    public static WideControlBuilder Create(bool outOfBand, bool autoSize, UInt32 columns);
    internal virtual void WriteToXml(FormatXmlWriter writer);
    internal virtual bool SafeForExport();
    internal virtual bool CompatibleWithOldPowerShell();
}
public class System.Management.Automation.WideControlBuilder : object {
    private WideControl _control;
    internal WideControlBuilder(WideControl control);
    public WideControlBuilder GroupByProperty(string property, CustomControl customControl, string label);
    public WideControlBuilder GroupByScriptBlock(string scriptBlock, CustomControl customControl, string label);
    public WideControlBuilder AddScriptBlockEntry(string scriptBlock, string format, IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    public WideControlBuilder AddPropertyEntry(string propertyName, string format, IEnumerable`1<string> entrySelectedByType, IEnumerable`1<DisplayEntry> entrySelectedByCondition);
    public WideControl EndWideControl();
}
public class System.Management.Automation.WideControlEntryItem : object {
    [CompilerGeneratedAttribute]
private DisplayEntry <DisplayEntry>k__BackingField;
    [CompilerGeneratedAttribute]
private EntrySelectedBy <EntrySelectedBy>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    public DisplayEntry DisplayEntry { get; internal set; }
    public List`1<string> SelectedBy { get; }
    public EntrySelectedBy EntrySelectedBy { get; internal set; }
    public string FormatString { get; internal set; }
    internal WideControlEntryItem(WideControlEntryDefinition definition);
    public WideControlEntryItem(DisplayEntry entry);
    public WideControlEntryItem(DisplayEntry entry, IEnumerable`1<string> selectedBy);
    [CompilerGeneratedAttribute]
public DisplayEntry get_DisplayEntry();
    [CompilerGeneratedAttribute]
internal void set_DisplayEntry(DisplayEntry value);
    public List`1<string> get_SelectedBy();
    [CompilerGeneratedAttribute]
public EntrySelectedBy get_EntrySelectedBy();
    [CompilerGeneratedAttribute]
internal void set_EntrySelectedBy(EntrySelectedBy value);
    [CompilerGeneratedAttribute]
public string get_FormatString();
    [CompilerGeneratedAttribute]
internal void set_FormatString(string value);
    internal bool SafeForExport();
    internal bool CompatibleWithOldPowerShell();
}
[FlagsAttribute]
public enum System.Management.Automation.WildcardOptions : Enum {
    public int value__;
    public static WildcardOptions None;
    public static WildcardOptions Compiled;
    public static WildcardOptions IgnoreCase;
    public static WildcardOptions CultureInvariant;
}
public class System.Management.Automation.WildcardPattern : object {
    private static char escapeChar;
    private static int StackAllocThreshold;
    private static string SpecialChars;
    private Predicate`1<string> _isMatch;
    private static Predicate`1<string> s_matchAll;
    [CompilerGeneratedAttribute]
private string <Pattern>k__BackingField;
    [CompilerGeneratedAttribute]
private WildcardOptions <Options>k__BackingField;
    private static WildcardPattern s_matchAllIgnoreCasePattern;
    internal string Pattern { get; }
    internal WildcardOptions Options { get; }
    internal string PatternConvertedToRegex { get; }
    public WildcardPattern(string pattern);
    public WildcardPattern(string pattern, WildcardOptions options);
    private static WildcardPattern();
    [CompilerGeneratedAttribute]
internal string get_Pattern();
    [CompilerGeneratedAttribute]
internal WildcardOptions get_Options();
    internal string get_PatternConvertedToRegex();
    public static WildcardPattern Get(string pattern, WildcardOptions options);
    private void Init();
    public bool IsMatch(string input);
    internal static string Escape(string pattern, Char[] charsNotToEscape);
    public static string Escape(string pattern);
    public static bool ContainsWildcardCharacters(string pattern);
    internal static bool ContainsRangeWildcard(string pattern);
    public static string Unescape(string pattern);
    private static bool IsWildcardChar(char ch);
    public string ToWql();
    [CompilerGeneratedAttribute]
private StringComparison <Init>g__GetStringComparison|17_0();
    [CompilerGeneratedAttribute]
private bool <Init>b__17_1(string str);
}
public class System.Management.Automation.WildcardPatternException : RuntimeException {
    private ErrorRecord _errorRecord;
    internal WildcardPatternException(ErrorRecord errorRecord);
    public WildcardPatternException(string message);
    public WildcardPatternException(string message, Exception innerException);
    [ObsoleteAttribute("Legacy serialization support is deprecated since .NET 8")]
protected WildcardPatternException(SerializationInfo info, StreamingContext context);
}
internal class System.Management.Automation.WildcardPatternMatcher : object {
    private PatternElement[] _patternElements;
    private CharacterNormalizer _characterNormalizer;
    internal WildcardPatternMatcher(WildcardPattern wildcardPattern);
    internal bool IsMatch(string str);
}
internal abstract class System.Management.Automation.WildcardPatternParser : object {
    protected virtual void BeginWildcardPattern(WildcardPattern pattern);
    protected abstract virtual void AppendLiteralCharacter(char c);
    protected abstract virtual void AppendAsterix();
    protected abstract virtual void AppendQuestionMark();
    protected virtual void EndWildcardPattern();
    protected abstract virtual void BeginBracketExpression();
    protected abstract virtual void AppendLiteralCharacterToBracketExpression(char c);
    protected abstract virtual void AppendCharacterRangeToBracketExpression(char startOfCharacterRange, char endOfCharacterRange);
    protected abstract virtual void EndBracketExpression();
    internal void AppendBracketExpression(string brackedExpressionContents, string bracketExpressionOperators, string pattern);
    public static void Parse(WildcardPattern pattern, WildcardPatternParser parser);
    internal static WildcardPatternException NewWildcardPatternException(string invalidPattern);
}
internal class System.Management.Automation.WildcardPatternToDosWildcardParser : WildcardPatternParser {
    private StringBuilder _result;
    protected virtual void AppendLiteralCharacter(char c);
    protected virtual void AppendAsterix();
    protected virtual void AppendQuestionMark();
    protected virtual void BeginBracketExpression();
    protected virtual void AppendLiteralCharacterToBracketExpression(char c);
    protected virtual void AppendCharacterRangeToBracketExpression(char startOfCharacterRange, char endOfCharacterRange);
    protected virtual void EndBracketExpression();
    internal static string Parse(WildcardPattern wildcardPattern);
}
internal class System.Management.Automation.WildcardPatternToRegexParser : WildcardPatternParser {
    private StringBuilder _regexPattern;
    private RegexOptions _regexOptions;
    private static string regexChars;
    private static bool IsRegexChar(char ch);
    internal static RegexOptions TranslateWildcardOptionsIntoRegexOptions(WildcardOptions options);
    protected virtual void BeginWildcardPattern(WildcardPattern pattern);
    internal static void AppendLiteralCharacter(StringBuilder regexPattern, char c);
    protected virtual void AppendLiteralCharacter(char c);
    protected virtual void AppendAsterix();
    protected virtual void AppendQuestionMark();
    protected virtual void EndWildcardPattern();
    protected virtual void BeginBracketExpression();
    internal static void AppendLiteralCharacterToBracketExpression(StringBuilder regexPattern, char c);
    protected virtual void AppendLiteralCharacterToBracketExpression(char c);
    internal static void AppendCharacterRangeToBracketExpression(StringBuilder regexPattern, char startOfCharacterRange, char endOfCharacterRange);
    protected virtual void AppendCharacterRangeToBracketExpression(char startOfCharacterRange, char endOfCharacterRange);
    protected virtual void EndBracketExpression();
    public static Regex Parse(WildcardPattern wildcardPattern);
}
internal static class System.Management.Automation.Win32Errors : object {
    internal static UInt32 NO_ERROR;
    internal static UInt32 E_FAIL;
    internal static UInt32 TRUST_E_NOSIGNATURE;
    internal static UInt32 TRUST_E_BAD_DIGEST;
    internal static UInt32 TRUST_E_PROVIDER_UNKNOWN;
    internal static UInt32 TRUST_E_SUBJECT_FORM_UNKNOWN;
    internal static UInt32 CERT_E_UNTRUSTEDROOT;
    internal static UInt32 TRUST_E_EXPLICIT_DISTRUST;
    internal static UInt32 CRYPT_E_BAD_MSG;
    internal static UInt32 NTE_BAD_ALGID;
}
internal class System.Management.Automation.Win32Native.SafeCATAdminHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Management.Automation.Win32Native.SafeCATCDFHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class System.Management.Automation.Win32Native.SafeCATHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
internal enum System.Management.Automation.Win32Native.WinTrustAction : Enum {
    public int value__;
    public static WinTrustAction WTD_STATEACTION_IGNORE;
    public static WinTrustAction WTD_STATEACTION_VERIFY;
    public static WinTrustAction WTD_STATEACTION_CLOSE;
    public static WinTrustAction WTD_STATEACTION_AUTO_CACHE;
    public static WinTrustAction WTD_STATEACTION_AUTO_CACHE_FLUSH;
}
internal static class System.Management.Automation.Win32Native.WinTrustMethods : object {
    private static string WinTrustDll;
    private static bool NativeCryptCATAdminAcquireContext2(SafeCATAdminHandle& phCatAdmin, IntPtr pgSubsystem, string pwszHashAlgorithm, IntPtr pStrongHashPolicy, UInt32 dwFlags);
    internal static SafeCATAdminHandle CryptCATAdminAcquireContext2(string hashAlgorithm);
    private static bool NativeCryptCATAdminCalcHashFromFileHandle2(SafeCATAdminHandle hCatAdmin, SafeHandle hFile, Int32& pcbHash, Byte* pbHash, UInt32 dwFlags);
    internal static Byte[] CryptCATAdminCalcHashFromFileHandle2(SafeCATAdminHandle catAdmin, SafeHandle file);
    internal static bool CryptCATAdminReleaseContext(IntPtr phCatAdmin, UInt32 dwFlags);
    private static SafeCATCDFHandle NativeCryptCATCDFOpen(string pwszFilePath, CryptCATCDFParseErrorCallBack pfnParseError);
    internal static SafeCATCDFHandle CryptCATCDFOpen(string filePath, CryptCATCDFParseErrorCallBack parseError);
    internal static IntPtr CryptCATCDFEnumCatAttributes(SafeCATCDFHandle pCDF, IntPtr pPrevAttr, CryptCATCDFParseErrorCallBack pfnParseError);
    internal static bool CryptCATCDFClose(IntPtr pCDF);
    internal static IntPtr CryptCATCDFEnumMembersByCDFTagEx(SafeCATCDFHandle pCDF, IntPtr pwszPrevCDFTag, CryptCATCDFParseErrorCallBack fn, IntPtr& ppMember, bool fContinueOnError, IntPtr pvReserved);
    internal static IntPtr CryptCATCDFEnumAttributesWithCDFTag(SafeCATCDFHandle pCDF, IntPtr pwszMemberTag, IntPtr pMember, IntPtr pPrevAttr, CryptCATCDFParseErrorCallBack fn);
    internal static IntPtr CryptCATEnumerateCatAttr(SafeCATHandle hCatalog, IntPtr pPrevAttr);
    internal static SafeCATHandle NativeCryptCATOpen(string pwszFilePath, UInt32 fdwOpenFlags, IntPtr hProv, UInt32 dwPublicVersion, UInt32 dwEncodingType);
    internal static SafeCATHandle CryptCATOpen(string filePath, UInt32 openFlags, IntPtr provider, UInt32 publicVersion, UInt32 encodingType);
    internal static bool CryptCATClose(IntPtr hCatalog);
    private static IntPtr NativeCryptCATStoreFromHandle(SafeCATHandle hCatalog);
    internal static CRYPTCATSTORE CryptCATStoreFromHandle(SafeCATHandle catalog);
    internal static IntPtr CryptCATEnumerateMember(SafeCATHandle hCatalog, IntPtr pPrevMember);
    internal static IntPtr CryptCATEnumerateAttr(SafeCATHandle hCatalog, IntPtr pCatMember, IntPtr pPrevAttr);
    internal static UInt32 WinVerifyTrust(IntPtr hWnd, Guid& pgActionID, WINTRUST_DATA& pWVTData);
    private static IntPtr NativeWTHelperGetProvCertFromChain(IntPtr pSgnr, UInt32 idxCert);
    internal static IntPtr WTHelperGetProvCertFromChain(IntPtr signer, UInt32 certIdx);
    private static IntPtr NativeWTHelperGetProvSignerFromChain(IntPtr pProvData, UInt32 idxSigner, bool fCounterSigner, UInt32 idxCounterSigner);
    internal static IntPtr WTHelperGetProvSignerFromChain(IntPtr providerData, UInt32 signerIdx, bool counterSigner, UInt32 counterSignerIdx);
    private static IntPtr NativeWTHelperProvDataFromStateData(IntPtr hStateData);
    internal static IntPtr WTHelperProvDataFromStateData(IntPtr stateData);
}
[FlagsAttribute]
internal enum System.Management.Automation.Win32Native.WinTrustProviderFlags : Enum {
    public int value__;
    public static WinTrustProviderFlags WTD_PROV_FLAGS_MASK;
    public static WinTrustProviderFlags WTD_USE_IE4_TRUST_FLAG;
    public static WinTrustProviderFlags WTD_NO_IE4_CHAIN_FLAG;
    public static WinTrustProviderFlags WTD_NO_POLICY_USAGE_FLAG;
    public static WinTrustProviderFlags WTD_REVOCATION_CHECK_NONE;
    public static WinTrustProviderFlags WTD_REVOCATION_CHECK_END_CERT;
    public static WinTrustProviderFlags WTD_REVOCATION_CHECK_CHAIN;
    public static WinTrustProviderFlags WTD_REVOCATION_CHECK_CHAIN_EXCLUDE_ROOT;
    public static WinTrustProviderFlags WTD_SAFER_FLAG;
    public static WinTrustProviderFlags WTD_HASH_ONLY_FLAG;
    public static WinTrustProviderFlags WTD_USE_DEFAULT_OSVER_CHECK;
    public static WinTrustProviderFlags WTD_LIFETIME_SIGNING_FLAG;
    public static WinTrustProviderFlags WTD_CACHE_ONLY_URL_RETRIEVAL;
}
[FlagsAttribute]
internal enum System.Management.Automation.Win32Native.WinTrustUIChoice : Enum {
    public int value__;
    public static WinTrustUIChoice WTD_UI_ALL;
    public static WinTrustUIChoice WTD_UI_NONE;
    public static WinTrustUIChoice WTD_UI_NOBAD;
    public static WinTrustUIChoice WTD_UI_NOGOOD;
}
[FlagsAttribute]
internal enum System.Management.Automation.Win32Native.WinTrustUnionChoice : Enum {
    public int value__;
    public static WinTrustUnionChoice WTD_CHOICE_FILE;
    public static WinTrustUnionChoice WTD_CHOICE_CATALOG;
    public static WinTrustUnionChoice WTD_CHOICE_BLOB;
    public static WinTrustUnionChoice WTD_CHOICE_SIGNER;
    public static WinTrustUnionChoice WTD_CHOICE_CERT;
}
internal static class System.Management.Automation.WinRTHelper : object {
    [NullableContextAttribute("1")]
internal static bool IsWinRTType(Type type);
}
internal enum System.Management.Automation.WriteStreamType : Enum {
    public byte value__;
    public static WriteStreamType None;
    public static WriteStreamType Output;
    public static WriteStreamType Error;
    public static WriteStreamType Warning;
    public static WriteStreamType Verbose;
    public static WriteStreamType Debug;
    public static WriteStreamType Information;
}
internal class System.Management.Automation.XmlNodeAdapter : PropertyOnlyAdapter {
    [IteratorStateMachineAttribute("System.Management.Automation.XmlNodeAdapter/<GetTypeNameHierarchy>d__0")]
protected virtual IEnumerable`1<string> GetTypeNameHierarchy(object obj);
    protected virtual void DoAddAllProperties(object obj, PSMemberInfoInternalCollection`1<T> members);
    protected virtual PSProperty DoGetProperty(object obj, string propertyName);
    protected virtual PSProperty DoGetFirstPropertyOrDefault(object obj, MemberNamePredicate predicate);
    protected virtual bool PropertyIsSettable(PSProperty property);
    protected virtual bool PropertyIsGettable(PSProperty property);
    private static object GetNodeObject(XmlNode node);
    protected virtual object PropertyGet(PSProperty property);
    protected virtual void PropertySet(PSProperty property, object setValue, bool convertIfPossible);
    protected virtual string PropertyType(PSProperty property, bool forDisplay);
    private static XmlNode[] FindNodes(object obj, string propertyName, StringComparison comparisonType);
    private static XmlNode FindNode(object obj, MemberNamePredicate predicate);
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TabCompletionStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string CannotDeserializeTabCompletionResult { get; }
    internal static string NoAccessToProperties { get; }
    internal static string bnotOperatorDescription { get; }
    internal static string notOperatorDescription { get; }
    internal static string eqOperatorDescription { get; }
    internal static string ieqOperatorDescription { get; }
    internal static string ceqOperatorDescription { get; }
    internal static string neOperatorDescription { get; }
    internal static string ineOperatorDescription { get; }
    internal static string cneOperatorDescription { get; }
    internal static string geOperatorDescription { get; }
    internal static string igeOperatorDescription { get; }
    internal static string cgeOperatorDescription { get; }
    internal static string gtOperatorDescription { get; }
    internal static string igtOperatorDescription { get; }
    internal static string cgtOperatorDescription { get; }
    internal static string ltOperatorDescription { get; }
    internal static string iltOperatorDescription { get; }
    internal static string cltOperatorDescription { get; }
    internal static string leOperatorDescription { get; }
    internal static string ileOperatorDescription { get; }
    internal static string cleOperatorDescription { get; }
    internal static string likeOperatorDescription { get; }
    internal static string ilikeOperatorDescription { get; }
    internal static string clikeOperatorDescription { get; }
    internal static string notlikeOperatorDescription { get; }
    internal static string inotlikeOperatorDescription { get; }
    internal static string cnotlikeOperatorDescription { get; }
    internal static string matchOperatorDescription { get; }
    internal static string imatchOperatorDescription { get; }
    internal static string cmatchOperatorDescription { get; }
    internal static string notmatchOperatorDescription { get; }
    internal static string inotmatchOperatorDescription { get; }
    internal static string cnotmatchOperatorDescription { get; }
    internal static string replaceOperatorDescription { get; }
    internal static string ireplaceOperatorDescription { get; }
    internal static string creplaceOperatorDescription { get; }
    internal static string containsOperatorDescription { get; }
    internal static string icontainsOperatorDescription { get; }
    internal static string ccontainsOperatorDescription { get; }
    internal static string notcontainsOperatorDescription { get; }
    internal static string inotcontainsOperatorDescription { get; }
    internal static string cnotcontainsOperatorDescription { get; }
    internal static string inOperatorDescription { get; }
    internal static string iinOperatorDescription { get; }
    internal static string cinOperatorDescription { get; }
    internal static string notinOperatorDescription { get; }
    internal static string inotinOperatorDescription { get; }
    internal static string cnotinOperatorDescription { get; }
    internal static string splitOperatorDescription { get; }
    internal static string isplitOperatorDescription { get; }
    internal static string csplitOperatorDescription { get; }
    internal static string isnotOperatorDescription { get; }
    internal static string isOperatorDescription { get; }
    internal static string asOperatorDescription { get; }
    internal static string fOperatorDescription { get; }
    internal static string andOperatorDescription { get; }
    internal static string bandOperatorDescription { get; }
    internal static string orOperatorDescription { get; }
    internal static string borOperatorDescription { get; }
    internal static string xorOperatorDescription { get; }
    internal static string bxorOperatorDescription { get; }
    internal static string joinOperatorDescription { get; }
    internal static string shlOperatorDescription { get; }
    internal static string shrOperatorDescription { get; }
    internal static string AssemblyKeywordDescription { get; }
    internal static string ModuleKeywordDescription { get; }
    internal static string NamespaceKeywordDescription { get; }
    internal static string TypeKeywordDescription { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_CannotDeserializeTabCompletionResult();
    internal static string get_NoAccessToProperties();
    internal static string get_bnotOperatorDescription();
    internal static string get_notOperatorDescription();
    internal static string get_eqOperatorDescription();
    internal static string get_ieqOperatorDescription();
    internal static string get_ceqOperatorDescription();
    internal static string get_neOperatorDescription();
    internal static string get_ineOperatorDescription();
    internal static string get_cneOperatorDescription();
    internal static string get_geOperatorDescription();
    internal static string get_igeOperatorDescription();
    internal static string get_cgeOperatorDescription();
    internal static string get_gtOperatorDescription();
    internal static string get_igtOperatorDescription();
    internal static string get_cgtOperatorDescription();
    internal static string get_ltOperatorDescription();
    internal static string get_iltOperatorDescription();
    internal static string get_cltOperatorDescription();
    internal static string get_leOperatorDescription();
    internal static string get_ileOperatorDescription();
    internal static string get_cleOperatorDescription();
    internal static string get_likeOperatorDescription();
    internal static string get_ilikeOperatorDescription();
    internal static string get_clikeOperatorDescription();
    internal static string get_notlikeOperatorDescription();
    internal static string get_inotlikeOperatorDescription();
    internal static string get_cnotlikeOperatorDescription();
    internal static string get_matchOperatorDescription();
    internal static string get_imatchOperatorDescription();
    internal static string get_cmatchOperatorDescription();
    internal static string get_notmatchOperatorDescription();
    internal static string get_inotmatchOperatorDescription();
    internal static string get_cnotmatchOperatorDescription();
    internal static string get_replaceOperatorDescription();
    internal static string get_ireplaceOperatorDescription();
    internal static string get_creplaceOperatorDescription();
    internal static string get_containsOperatorDescription();
    internal static string get_icontainsOperatorDescription();
    internal static string get_ccontainsOperatorDescription();
    internal static string get_notcontainsOperatorDescription();
    internal static string get_inotcontainsOperatorDescription();
    internal static string get_cnotcontainsOperatorDescription();
    internal static string get_inOperatorDescription();
    internal static string get_iinOperatorDescription();
    internal static string get_cinOperatorDescription();
    internal static string get_notinOperatorDescription();
    internal static string get_inotinOperatorDescription();
    internal static string get_cnotinOperatorDescription();
    internal static string get_splitOperatorDescription();
    internal static string get_isplitOperatorDescription();
    internal static string get_csplitOperatorDescription();
    internal static string get_isnotOperatorDescription();
    internal static string get_isOperatorDescription();
    internal static string get_asOperatorDescription();
    internal static string get_fOperatorDescription();
    internal static string get_andOperatorDescription();
    internal static string get_bandOperatorDescription();
    internal static string get_orOperatorDescription();
    internal static string get_borOperatorDescription();
    internal static string get_xorOperatorDescription();
    internal static string get_bxorOperatorDescription();
    internal static string get_joinOperatorDescription();
    internal static string get_shlOperatorDescription();
    internal static string get_shrOperatorDescription();
    internal static string get_AssemblyKeywordDescription();
    internal static string get_ModuleKeywordDescription();
    internal static string get_NamespaceKeywordDescription();
    internal static string get_TypeKeywordDescription();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TransactionStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string NoTransactionActive { get; }
    internal static string NoTransactionActiveForCommit { get; }
    internal static string NoTransactionActiveForRollback { get; }
    internal static string CommittedTransactionForRollback { get; }
    internal static string CommittedTransactionForCommit { get; }
    internal static string TransactionRolledBackForCommit { get; }
    internal static string TransactionRolledBackForRollback { get; }
    internal static string NoTransactionForActivation { get; }
    internal static string NoTransactionForActivationBecauseRollback { get; }
    internal static string NoTransactionAvailable { get; }
    internal static string CmdletRequiresUseTx { get; }
    internal static string NoTransactionStarted { get; }
    internal static string NoTransactionStartedFromCommit { get; }
    internal static string NoTransactionStartedFromRollback { get; }
    internal static string TransactionTimedOut { get; }
    internal static string BaseTransactionNotSet { get; }
    internal static string BaseTransactionNotActive { get; }
    internal static string BaseTransactionMustBeFirst { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_NoTransactionActive();
    internal static string get_NoTransactionActiveForCommit();
    internal static string get_NoTransactionActiveForRollback();
    internal static string get_CommittedTransactionForRollback();
    internal static string get_CommittedTransactionForCommit();
    internal static string get_TransactionRolledBackForCommit();
    internal static string get_TransactionRolledBackForRollback();
    internal static string get_NoTransactionForActivation();
    internal static string get_NoTransactionForActivationBecauseRollback();
    internal static string get_NoTransactionAvailable();
    internal static string get_CmdletRequiresUseTx();
    internal static string get_NoTransactionStarted();
    internal static string get_NoTransactionStartedFromCommit();
    internal static string get_NoTransactionStartedFromRollback();
    internal static string get_TransactionTimedOut();
    internal static string get_BaseTransactionNotSet();
    internal static string get_BaseTransactionNotActive();
    internal static string get_BaseTransactionMustBeFirst();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class TypesXmlStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string FileLineError { get; }
    internal static string FileLineTypeError { get; }
    internal static string NotMoreThanOnceOne { get; }
    internal static string UnknownNode { get; }
    internal static string NodeShouldNotHaveInnerText { get; }
    internal static string NodeShouldHaveInnerText { get; }
    internal static string NodeNotFoundOnce { get; }
    internal static string TypeNodeShouldHaveMembersOrTypeConverters { get; }
    internal static string UnableToInstantiateTypeConverter { get; }
    internal static string UnableToInstantiateTypeAdapter { get; }
    internal static string InvalidAdaptedType { get; }
    internal static string TypeConverterAlreadyPresent { get; }
    internal static string TypeAdapterAlreadyPresent { get; }
    internal static string TypeIsNotTypeConverter { get; }
    internal static string TypeIsNotTypeAdapter { get; }
    internal static string DuplicateMember { get; }
    internal static string ReservedNameMember { get; }
    internal static string Exception { get; }
    internal static string ScriptPropertyShouldHaveGetterOrSetter { get; }
    internal static string CodePropertyShouldHaveGetterOrSetter { get; }
    internal static string FileError { get; }
    internal static string ValueShouldBeTrueOrFalse { get; }
    internal static string IsHiddenNotSupported { get; }
    internal static string FileNotFound { get; }
    internal static string DuplicateFile { get; }
    internal static string CannotFindRegistryKey { get; }
    internal static string CannotFindRegistryKeyPath { get; }
    internal static string EntryShouldBeMshXml { get; }
    internal static string ValidationException { get; }
    internal static string MemberShouldBeNote { get; }
    internal static string ErrorConvertingNote { get; }
    internal static string MemberShouldNotBePresent { get; }
    internal static string MemberShouldHaveType { get; }
    internal static string MemberMustBePresent { get; }
    internal static string SerializationSettingsIgnored { get; }
    internal static string NotAStandardMember { get; }
    internal static string TypeFileNotRooted { get; }
    internal static string SharedTypeTableCannotBeUpdated { get; }
    internal static string TypeTableLoadErrors { get; }
    internal static string TypeDataTypeError { get; }
    internal static string TypeDataShouldHaveValue { get; }
    internal static string TypeDataShouldNotBeNullOrEmpty { get; }
    internal static string TypeNotFound { get; }
    internal static string TypeDataShouldNotBeEmpty { get; }
    internal static string TypeTableCannotCoExist { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_FileLineError();
    internal static string get_FileLineTypeError();
    internal static string get_NotMoreThanOnceOne();
    internal static string get_UnknownNode();
    internal static string get_NodeShouldNotHaveInnerText();
    internal static string get_NodeShouldHaveInnerText();
    internal static string get_NodeNotFoundOnce();
    internal static string get_TypeNodeShouldHaveMembersOrTypeConverters();
    internal static string get_UnableToInstantiateTypeConverter();
    internal static string get_UnableToInstantiateTypeAdapter();
    internal static string get_InvalidAdaptedType();
    internal static string get_TypeConverterAlreadyPresent();
    internal static string get_TypeAdapterAlreadyPresent();
    internal static string get_TypeIsNotTypeConverter();
    internal static string get_TypeIsNotTypeAdapter();
    internal static string get_DuplicateMember();
    internal static string get_ReservedNameMember();
    internal static string get_Exception();
    internal static string get_ScriptPropertyShouldHaveGetterOrSetter();
    internal static string get_CodePropertyShouldHaveGetterOrSetter();
    internal static string get_FileError();
    internal static string get_ValueShouldBeTrueOrFalse();
    internal static string get_IsHiddenNotSupported();
    internal static string get_FileNotFound();
    internal static string get_DuplicateFile();
    internal static string get_CannotFindRegistryKey();
    internal static string get_CannotFindRegistryKeyPath();
    internal static string get_EntryShouldBeMshXml();
    internal static string get_ValidationException();
    internal static string get_MemberShouldBeNote();
    internal static string get_ErrorConvertingNote();
    internal static string get_MemberShouldNotBePresent();
    internal static string get_MemberShouldHaveType();
    internal static string get_MemberMustBePresent();
    internal static string get_SerializationSettingsIgnored();
    internal static string get_NotAStandardMember();
    internal static string get_TypeFileNotRooted();
    internal static string get_SharedTypeTableCannotBeUpdated();
    internal static string get_TypeTableLoadErrors();
    internal static string get_TypeDataTypeError();
    internal static string get_TypeDataShouldHaveValue();
    internal static string get_TypeDataShouldNotBeNullOrEmpty();
    internal static string get_TypeNotFound();
    internal static string get_TypeDataShouldNotBeEmpty();
    internal static string get_TypeTableCannotCoExist();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class VerbDescriptionStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string Add { get; }
    internal static string Approve { get; }
    internal static string Assert { get; }
    internal static string Backup { get; }
    internal static string Block { get; }
    internal static string Build { get; }
    internal static string Checkpoint { get; }
    internal static string Clear { get; }
    internal static string Close { get; }
    internal static string Compare { get; }
    internal static string Complete { get; }
    internal static string Compress { get; }
    internal static string Confirm { get; }
    internal static string Connect { get; }
    internal static string Convert { get; }
    internal static string ConvertFrom { get; }
    internal static string ConvertTo { get; }
    internal static string Copy { get; }
    internal static string Debug { get; }
    internal static string Deny { get; }
    internal static string Deploy { get; }
    internal static string Disable { get; }
    internal static string Disconnect { get; }
    internal static string Dismount { get; }
    internal static string Edit { get; }
    internal static string Enable { get; }
    internal static string Enter { get; }
    internal static string Exit { get; }
    internal static string Expand { get; }
    internal static string Export { get; }
    internal static string Find { get; }
    internal static string Format { get; }
    internal static string Get { get; }
    internal static string Grant { get; }
    internal static string Group { get; }
    internal static string Hide { get; }
    internal static string Import { get; }
    internal static string Initialize { get; }
    internal static string Install { get; }
    internal static string Invoke { get; }
    internal static string Join { get; }
    internal static string Limit { get; }
    internal static string Lock { get; }
    internal static string Measure { get; }
    internal static string Merge { get; }
    internal static string Mount { get; }
    internal static string Move { get; }
    internal static string New { get; }
    internal static string Open { get; }
    internal static string Optimize { get; }
    internal static string Out { get; }
    internal static string Ping { get; }
    internal static string Pop { get; }
    internal static string Protect { get; }
    internal static string Publish { get; }
    internal static string Push { get; }
    internal static string Read { get; }
    internal static string Receive { get; }
    internal static string Redo { get; }
    internal static string Register { get; }
    internal static string Remove { get; }
    internal static string Rename { get; }
    internal static string Repair { get; }
    internal static string Request { get; }
    internal static string Reset { get; }
    internal static string Resize { get; }
    internal static string Resolve { get; }
    internal static string Restart { get; }
    internal static string Restore { get; }
    internal static string Resume { get; }
    internal static string Revoke { get; }
    internal static string Save { get; }
    internal static string Search { get; }
    internal static string Select { get; }
    internal static string Send { get; }
    internal static string Set { get; }
    internal static string Show { get; }
    internal static string Sync { get; }
    internal static string Skip { get; }
    internal static string Split { get; }
    internal static string Start { get; }
    internal static string Step { get; }
    internal static string Stop { get; }
    internal static string Submit { get; }
    internal static string Suspend { get; }
    internal static string Switch { get; }
    internal static string Test { get; }
    internal static string Trace { get; }
    internal static string Unblock { get; }
    internal static string Undo { get; }
    internal static string Uninstall { get; }
    internal static string Unlock { get; }
    internal static string Unprotect { get; }
    internal static string Unpublish { get; }
    internal static string Unregister { get; }
    internal static string Update { get; }
    internal static string Use { get; }
    internal static string Wait { get; }
    internal static string Watch { get; }
    internal static string Write { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_Add();
    internal static string get_Approve();
    internal static string get_Assert();
    internal static string get_Backup();
    internal static string get_Block();
    internal static string get_Build();
    internal static string get_Checkpoint();
    internal static string get_Clear();
    internal static string get_Close();
    internal static string get_Compare();
    internal static string get_Complete();
    internal static string get_Compress();
    internal static string get_Confirm();
    internal static string get_Connect();
    internal static string get_Convert();
    internal static string get_ConvertFrom();
    internal static string get_ConvertTo();
    internal static string get_Copy();
    internal static string get_Debug();
    internal static string get_Deny();
    internal static string get_Deploy();
    internal static string get_Disable();
    internal static string get_Disconnect();
    internal static string get_Dismount();
    internal static string get_Edit();
    internal static string get_Enable();
    internal static string get_Enter();
    internal static string get_Exit();
    internal static string get_Expand();
    internal static string get_Export();
    internal static string get_Find();
    internal static string get_Format();
    internal static string get_Get();
    internal static string get_Grant();
    internal static string get_Group();
    internal static string get_Hide();
    internal static string get_Import();
    internal static string get_Initialize();
    internal static string get_Install();
    internal static string get_Invoke();
    internal static string get_Join();
    internal static string get_Limit();
    internal static string get_Lock();
    internal static string get_Measure();
    internal static string get_Merge();
    internal static string get_Mount();
    internal static string get_Move();
    internal static string get_New();
    internal static string get_Open();
    internal static string get_Optimize();
    internal static string get_Out();
    internal static string get_Ping();
    internal static string get_Pop();
    internal static string get_Protect();
    internal static string get_Publish();
    internal static string get_Push();
    internal static string get_Read();
    internal static string get_Receive();
    internal static string get_Redo();
    internal static string get_Register();
    internal static string get_Remove();
    internal static string get_Rename();
    internal static string get_Repair();
    internal static string get_Request();
    internal static string get_Reset();
    internal static string get_Resize();
    internal static string get_Resolve();
    internal static string get_Restart();
    internal static string get_Restore();
    internal static string get_Resume();
    internal static string get_Revoke();
    internal static string get_Save();
    internal static string get_Search();
    internal static string get_Select();
    internal static string get_Send();
    internal static string get_Set();
    internal static string get_Show();
    internal static string get_Sync();
    internal static string get_Skip();
    internal static string get_Split();
    internal static string get_Start();
    internal static string get_Step();
    internal static string get_Stop();
    internal static string get_Submit();
    internal static string get_Suspend();
    internal static string get_Switch();
    internal static string get_Test();
    internal static string get_Trace();
    internal static string get_Unblock();
    internal static string get_Undo();
    internal static string get_Uninstall();
    internal static string get_Unlock();
    internal static string get_Unprotect();
    internal static string get_Unpublish();
    internal static string get_Unregister();
    internal static string get_Update();
    internal static string get_Use();
    internal static string get_Wait();
    internal static string get_Watch();
    internal static string get_Write();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "4.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class WildcardPatternStrings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string InvalidPattern { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_InvalidPattern();
}
