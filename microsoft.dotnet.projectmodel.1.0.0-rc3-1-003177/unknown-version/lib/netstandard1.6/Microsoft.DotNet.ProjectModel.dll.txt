public static class Microsoft.DotNet.InternalAbstractions.RuntimeEnvironmentRidExtensions : object {
    public static string GetLegacyRestoreRuntimeIdentifier();
    public static IEnumerable`1<string> GetAllCandidateRuntimeIdentifiers();
    public static IEnumerable`1<string> GetAllCandidateRuntimeIdentifiers(IEnumerable`1<string> fallbackIdentifiers);
}
public class Microsoft.DotNet.ProjectModel.AnalyzerOptions : object {
    [CompilerGeneratedAttribute]
private string <LanguageId>k__BackingField;
    public string LanguageId { get; }
    public AnalyzerOptions(string languageId);
    [CompilerGeneratedAttribute]
public string get_LanguageId();
    public sealed virtual bool Equals(AnalyzerOptions other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(AnalyzerOptions left, AnalyzerOptions right);
    public static bool op_Inequality(AnalyzerOptions left, AnalyzerOptions right);
}
public class Microsoft.DotNet.ProjectModel.BuildWorkspace : Workspace {
    public BuildWorkspace(ProjectReaderSettings settings);
    public static BuildWorkspace Create();
    public static BuildWorkspace Create(string versionSuffix);
    public ProjectContext GetRuntimeContext(ProjectContext context, IEnumerable`1<string> runtimeIdentifiers);
    protected virtual IEnumerable`1<ProjectContext> BuildProjectContexts(Project project);
}
public class Microsoft.DotNet.ProjectModel.CommonCompilerOptions : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Defines>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LanguageVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Platform>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <AllowUnsafe>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <WarningsAsErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <Optimize>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyFile>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <DelaySign>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PublicSign>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugType>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <EmitEntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <PreserveCompilationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <GenerateXmlDocumentation>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SuppressWarnings>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <AdditionalArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompilerName>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeContext <CompileInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeContext <EmbedInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeContext <CopyToOutputInclude>k__BackingField;
    public IEnumerable`1<string> Defines { get; public set; }
    public string LanguageVersion { get; public set; }
    public string Platform { get; public set; }
    public Nullable`1<bool> AllowUnsafe { get; public set; }
    public Nullable`1<bool> WarningsAsErrors { get; public set; }
    public Nullable`1<bool> Optimize { get; public set; }
    public string KeyFile { get; public set; }
    public Nullable`1<bool> DelaySign { get; public set; }
    public Nullable`1<bool> PublicSign { get; public set; }
    public string DebugType { get; public set; }
    public Nullable`1<bool> EmitEntryPoint { get; public set; }
    public Nullable`1<bool> PreserveCompilationContext { get; public set; }
    public Nullable`1<bool> GenerateXmlDocumentation { get; public set; }
    public IEnumerable`1<string> SuppressWarnings { get; public set; }
    public IEnumerable`1<string> AdditionalArguments { get; public set; }
    public string OutputName { get; public set; }
    public string CompilerName { get; public set; }
    public IncludeContext CompileInclude { get; public set; }
    public IncludeContext EmbedInclude { get; public set; }
    public IncludeContext CopyToOutputInclude { get; public set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Defines();
    [CompilerGeneratedAttribute]
public void set_Defines(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_LanguageVersion();
    [CompilerGeneratedAttribute]
public void set_LanguageVersion(string value);
    [CompilerGeneratedAttribute]
public string get_Platform();
    [CompilerGeneratedAttribute]
public void set_Platform(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_AllowUnsafe();
    [CompilerGeneratedAttribute]
public void set_AllowUnsafe(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_WarningsAsErrors();
    [CompilerGeneratedAttribute]
public void set_WarningsAsErrors(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_Optimize();
    [CompilerGeneratedAttribute]
public void set_Optimize(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_KeyFile();
    [CompilerGeneratedAttribute]
public void set_KeyFile(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_DelaySign();
    [CompilerGeneratedAttribute]
public void set_DelaySign(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PublicSign();
    [CompilerGeneratedAttribute]
public void set_PublicSign(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public string get_DebugType();
    [CompilerGeneratedAttribute]
public void set_DebugType(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_EmitEntryPoint();
    [CompilerGeneratedAttribute]
public void set_EmitEntryPoint(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_PreserveCompilationContext();
    [CompilerGeneratedAttribute]
public void set_PreserveCompilationContext(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_GenerateXmlDocumentation();
    [CompilerGeneratedAttribute]
public void set_GenerateXmlDocumentation(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SuppressWarnings();
    [CompilerGeneratedAttribute]
public void set_SuppressWarnings(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_AdditionalArguments();
    [CompilerGeneratedAttribute]
public void set_AdditionalArguments(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_OutputName();
    [CompilerGeneratedAttribute]
public void set_OutputName(string value);
    [CompilerGeneratedAttribute]
public string get_CompilerName();
    [CompilerGeneratedAttribute]
public void set_CompilerName(string value);
    [CompilerGeneratedAttribute]
public IncludeContext get_CompileInclude();
    [CompilerGeneratedAttribute]
public void set_CompileInclude(IncludeContext value);
    [CompilerGeneratedAttribute]
public IncludeContext get_EmbedInclude();
    [CompilerGeneratedAttribute]
public void set_EmbedInclude(IncludeContext value);
    [CompilerGeneratedAttribute]
public IncludeContext get_CopyToOutputInclude();
    [CompilerGeneratedAttribute]
public void set_CopyToOutputInclude(IncludeContext value);
    public virtual bool Equals(object obj);
    private static bool IsEqual(IncludeContext first, IncludeContext second);
    private static bool EnumerableEquals(IEnumerable`1<string> left, IEnumerable`1<string> right);
    public virtual int GetHashCode();
    private static IEnumerable`1<string> Combine(IEnumerable`1<string> new, IEnumerable`1<string> old);
    public static CommonCompilerOptions Combine(CommonCompilerOptions[] options);
}
public class Microsoft.DotNet.ProjectModel.Compilation.AnalyzerReference : object {
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AnalyzerLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <RequiredFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    public string AssemblyPath { get; }
    public string AnalyzerLanguage { get; }
    public NuGetFramework RequiredFramework { get; }
    public string RuntimeIdentifier { get; }
    public AnalyzerReference(string assembly, NuGetFramework framework, string language, string runtimeIdentifier);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
public string get_AnalyzerLanguage();
    [CompilerGeneratedAttribute]
public NuGetFramework get_RequiredFramework();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
}
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryAsset : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RelativePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResolvedPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`2<Stream, Stream> <Transform>k__BackingField;
    public string Name { get; }
    public string RelativePath { get; }
    public string ResolvedPath { get; }
    public string FileName { get; }
    public Action`2<Stream, Stream> Transform { get; public set; }
    public LibraryAsset(string name, string relativePath, string resolvedPath, Action`2<Stream, Stream> transform);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public string get_RelativePath();
    [CompilerGeneratedAttribute]
public string get_ResolvedPath();
    public string get_FileName();
    [CompilerGeneratedAttribute]
public Action`2<Stream, Stream> get_Transform();
    [CompilerGeneratedAttribute]
public void set_Transform(Action`2<Stream, Stream> value);
    public bool Equals(LibraryAsset other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static LibraryAsset CreateFromRelativePath(string basePath, string relativePath, Action`2<Stream, Stream> transform);
    public static LibraryAsset CreateFromAbsolutePath(string basePath, string absolutePath, Action`2<Stream, Stream> transform);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.ProjectModel.Compilation.LibraryAssetExtensions : object {
    private static string NativeImageSufix;
    [ExtensionAttribute]
public static AssemblyName GetAssemblyName(LibraryAsset asset);
    [ExtensionAttribute]
public static string GetTransformedFile(LibraryAsset asset, string tempLocation, string tempName);
    [ExtensionAttribute]
public static Stream GetTransformedStream(LibraryAsset asset);
}
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryAssetGroup : object {
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<LibraryAsset> <Assets>k__BackingField;
    public string Runtime { get; }
    public IReadOnlyList`1<LibraryAsset> Assets { get; }
    public LibraryAssetGroup(string runtime, LibraryAsset[] assets);
    public LibraryAssetGroup(LibraryAsset[] assets);
    public LibraryAssetGroup(IEnumerable`1<LibraryAsset> assets);
    public LibraryAssetGroup(string runtime, IEnumerable`1<LibraryAsset> assets);
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<LibraryAsset> get_Assets();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryExport : object {
    [CompilerGeneratedAttribute]
private LibraryDescription <Library>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAssetGroup> <RuntimeAssemblyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAsset> <RuntimeAssets>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAssetGroup> <NativeLibraryGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAsset> <CompilationAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAsset> <EmbeddedResources>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryAsset> <SourceReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<AnalyzerReference> <AnalyzerReferences>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryResourceAssembly> <ResourceAssemblies>k__BackingField;
    public LibraryDescription Library { get; }
    public IEnumerable`1<LibraryAssetGroup> RuntimeAssemblyGroups { get; }
    public IEnumerable`1<LibraryAsset> RuntimeAssets { get; }
    public IEnumerable`1<LibraryAssetGroup> NativeLibraryGroups { get; }
    public IEnumerable`1<LibraryAsset> CompilationAssemblies { get; }
    public IEnumerable`1<LibraryAsset> EmbeddedResources { get; }
    public IEnumerable`1<LibraryAsset> SourceReferences { get; }
    public IEnumerable`1<AnalyzerReference> AnalyzerReferences { get; }
    public IEnumerable`1<LibraryResourceAssembly> ResourceAssemblies { get; }
    private string DebuggerDisplay { get; }
    public LibraryExport(LibraryDescription library, IEnumerable`1<LibraryAsset> compileAssemblies, IEnumerable`1<LibraryAsset> sourceReferences, IEnumerable`1<LibraryAssetGroup> runtimeAssemblyGroups, IEnumerable`1<LibraryAsset> runtimeAssets, IEnumerable`1<LibraryAssetGroup> nativeLibraryGroups, IEnumerable`1<LibraryAsset> embeddedResources, IEnumerable`1<AnalyzerReference> analyzers, IEnumerable`1<LibraryResourceAssembly> resourceAssemblies);
    [CompilerGeneratedAttribute]
public LibraryDescription get_Library();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAssetGroup> get_RuntimeAssemblyGroups();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAsset> get_RuntimeAssets();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAssetGroup> get_NativeLibraryGroups();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAsset> get_CompilationAssemblies();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAsset> get_EmbeddedResources();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryAsset> get_SourceReferences();
    [CompilerGeneratedAttribute]
public IEnumerable`1<AnalyzerReference> get_AnalyzerReferences();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryResourceAssembly> get_ResourceAssemblies();
    private string get_DebuggerDisplay();
}
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryExportBuilder : object {
    private IList`1<LibraryAssetGroup> _runtimeAssemblyGroups;
    private IList`1<LibraryAsset> _runtimeAssets;
    private IList`1<LibraryAsset> _compilationAssemblies;
    private IList`1<LibraryAsset> _sourceReferences;
    private IList`1<LibraryAssetGroup> _nativeLibraryGroups;
    private IList`1<LibraryAsset> _embeddedResources;
    private IList`1<AnalyzerReference> _analyzerReferences;
    private IList`1<LibraryResourceAssembly> _resourceAssemblies;
    [CompilerGeneratedAttribute]
private LibraryDescription <Library>k__BackingField;
    public LibraryDescription Library { get; public set; }
    public IEnumerable`1<LibraryAssetGroup> RuntimeAssemblyGroups { get; }
    public IEnumerable`1<LibraryAsset> RuntimeAssets { get; }
    public IEnumerable`1<LibraryAsset> CompilationAssemblies { get; }
    public IEnumerable`1<LibraryAsset> SourceReferences { get; }
    public IEnumerable`1<LibraryAssetGroup> NativeLibraryGroups { get; }
    public IEnumerable`1<LibraryAsset> EmbeddedResources { get; }
    public IEnumerable`1<AnalyzerReference> AnalyzerReferences { get; }
    public IEnumerable`1<LibraryResourceAssembly> ResourceAssemblies { get; }
    [CompilerGeneratedAttribute]
public LibraryDescription get_Library();
    [CompilerGeneratedAttribute]
public void set_Library(LibraryDescription value);
    public IEnumerable`1<LibraryAssetGroup> get_RuntimeAssemblyGroups();
    public IEnumerable`1<LibraryAsset> get_RuntimeAssets();
    public IEnumerable`1<LibraryAsset> get_CompilationAssemblies();
    public IEnumerable`1<LibraryAsset> get_SourceReferences();
    public IEnumerable`1<LibraryAssetGroup> get_NativeLibraryGroups();
    public IEnumerable`1<LibraryAsset> get_EmbeddedResources();
    public IEnumerable`1<AnalyzerReference> get_AnalyzerReferences();
    public IEnumerable`1<LibraryResourceAssembly> get_ResourceAssemblies();
    public static LibraryExportBuilder Create(LibraryDescription library);
    public LibraryExport Build();
    public LibraryExportBuilder WithLibrary(LibraryDescription libraryDescription);
    public LibraryExportBuilder WithRuntimeAssemblyGroups(IEnumerable`1<LibraryAssetGroup> assets);
    public LibraryExportBuilder WithRuntimeAssets(IEnumerable`1<LibraryAsset> assets);
    public LibraryExportBuilder WithCompilationAssemblies(IEnumerable`1<LibraryAsset> assets);
    public LibraryExportBuilder WithSourceReferences(IEnumerable`1<LibraryAsset> assets);
    public LibraryExportBuilder WithNativeLibraryGroups(IEnumerable`1<LibraryAssetGroup> assets);
    public LibraryExportBuilder WithEmbedddedResources(IEnumerable`1<LibraryAsset> assets);
    public LibraryExportBuilder WithAnalyzerReference(IEnumerable`1<AnalyzerReference> assets);
    public LibraryExportBuilder WithResourceAssemblies(IEnumerable`1<LibraryResourceAssembly> assemblies);
    public LibraryExportBuilder AddRuntimeAssemblyGroup(LibraryAssetGroup asset);
    public LibraryExportBuilder AddRuntimeAsset(LibraryAsset asset);
    public LibraryExportBuilder AddCompilationAssembly(LibraryAsset asset);
    public LibraryExportBuilder AddSourceReference(LibraryAsset asset);
    public LibraryExportBuilder AddNativeLibraryGroup(LibraryAssetGroup asset);
    public LibraryExportBuilder AddEmbedddedResource(LibraryAsset asset);
    public LibraryExportBuilder AddAnalyzerReference(AnalyzerReference asset);
    public LibraryExportBuilder AddResourceAssembly(LibraryResourceAssembly assembly);
    private void Replace(IList`1& list, IEnumerable`1<T> enumerable);
    private void Add(IList`1& list, T item);
}
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter : object {
    private string _configuration;
    private string _runtime;
    private String[] _runtimeFallbacks;
    private ProjectDescription _rootProject;
    private string _buildBasePath;
    private string _solutionRootPath;
    [CompilerGeneratedAttribute]
private LibraryManager <LibraryManager>k__BackingField;
    public LibraryManager LibraryManager { get; }
    public LibraryExporter(ProjectDescription rootProject, LibraryManager manager, string configuration, string runtime, String[] runtimeFallbacks, string buildBasePath, string solutionRootPath);
    [CompilerGeneratedAttribute]
public LibraryManager get_LibraryManager();
    public IEnumerable`1<LibraryExport> GetAllExports();
    public IEnumerable`1<LibraryExport> GetDependencies();
    public IEnumerable`1<LibraryExport> GetDependencies(LibraryType type);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter/<ExportLibraries>d__13")]
private IEnumerable`1<LibraryExport> ExportLibraries(Func`2<LibraryDescription, bool> condition);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter/<TrimAssetGroups>d__14")]
private IEnumerable`1<LibraryAssetGroup> TrimAssetGroups(IEnumerable`1<LibraryAssetGroup> runtimeAssemblyGroups, String[] runtimeFallbacks);
    private LibraryExport GetExport(LibraryDescription library);
    private LibraryExport ExportPackage(TargetLibraryWithAssets library);
    private LibraryExport ExportProject(ProjectDescription project);
    private bool HasSourceFiles(ProjectDescription project, CommonCompilerOptions compilerOptions);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter/<CollectAssets>d__19")]
private IEnumerable`1<LibraryAsset> CollectAssets(CompilationOutputFiles files);
    private bool ExportsRuntime(ProjectDescription project);
    private static string ResolvePath(Project project, string configuration, string path);
    private LibraryExport ExportFrameworkLibrary(LibraryDescription library);
    private IEnumerable`1<LibraryAsset> GetSharedSources(PackageDescription package);
    private IEnumerable`1<AnalyzerReference> GetAnalyzerReferences(PackageDescription package);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter/<PopulateResources>d__25")]
private IEnumerable`1<LibraryResourceAssembly> PopulateResources(TargetLibraryWithAssets library, IEnumerable`1<LockFileItem> section);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Compilation.LibraryExporter/<PopulateAssets>d__26")]
private IEnumerable`1<LibraryAsset> PopulateAssets(TargetLibraryWithAssets library, IEnumerable`1<LockFileItem> section);
    private static bool LibraryIsOfType(LibraryType type, LibraryDescription library);
}
public class Microsoft.DotNet.ProjectModel.Compilation.LibraryResourceAssembly : object {
    [CompilerGeneratedAttribute]
private LibraryAsset <Asset>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    public LibraryAsset Asset { get; }
    public string Locale { get; }
    public LibraryResourceAssembly(LibraryAsset asset, string locale);
    [CompilerGeneratedAttribute]
public LibraryAsset get_Asset();
    [CompilerGeneratedAttribute]
public string get_Locale();
}
public class Microsoft.DotNet.ProjectModel.Compilation.Preprocessor.PPFileParameters : object {
    public static IDictionary`2<string, string> CreateForProject(Project project);
}
public class Microsoft.DotNet.ProjectModel.CompilationOutputFiles : object {
    protected Project Project;
    protected string Configuration;
    protected NuGetFramework Framework;
    [CompilerGeneratedAttribute]
private string <BasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputExtension>k__BackingField;
    public string BasePath { get; }
    public string Assembly { get; }
    public string PdbPath { get; }
    public string OutputExtension { get; }
    public CompilationOutputFiles(string basePath, Project project, string configuration, NuGetFramework framework);
    [CompilerGeneratedAttribute]
public string get_BasePath();
    public string get_Assembly();
    public string get_PdbPath();
    [CompilerGeneratedAttribute]
public string get_OutputExtension();
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.CompilationOutputFiles/<Resources>d__14")]
public virtual IEnumerable`1<ResourceFile> Resources();
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.CompilationOutputFiles/<All>d__15")]
public virtual IEnumerable`1<string> All();
    private IEnumerable`1<string> GetResourceFiles();
}
internal static class Microsoft.DotNet.ProjectModel.Constants : object {
    public static string DefaultOutputDirectory;
    public static string DefaultConfiguration;
    public static string LocaleLockFilePropertyName;
    public static Version Version50;
    private static Constants();
}
public class Microsoft.DotNet.ProjectModel.DesignTimeWorkspace : Workspace {
    private HashSet`1<string> _projects;
    private bool _needRefresh;
    public DesignTimeWorkspace(ProjectReaderSettings settings);
    public void AddProject(string path);
    public void RemoveProject(string path);
    public void Refresh();
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.DesignTimeWorkspace/<BuildProjectContexts>d__6")]
protected virtual IEnumerable`1<ProjectContext> BuildProjectContexts(Project project);
    private static List`1<string> ResolveProjectPath(string projectPath);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.DesignTimeWorkspace/<GetProjectReferences>d__8")]
private static IEnumerable`1<ProjectDescription> GetProjectReferences(ProjectContext context);
}
public class Microsoft.DotNet.ProjectModel.DiagnosticMessage : object {
    [CompilerGeneratedAttribute]
private string <ErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private DiagnosticMessageSeverity <Severity>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <StartColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <EndColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FormattedMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDescription <Source>k__BackingField;
    public string ErrorCode { get; }
    public string SourceFilePath { get; }
    public string Message { get; }
    public DiagnosticMessageSeverity Severity { get; }
    public int StartLine { get; }
    public int StartColumn { get; }
    public int EndLine { get; }
    public int EndColumn { get; }
    public string FormattedMessage { get; }
    public LibraryDescription Source { get; }
    public DiagnosticMessage(string errorCode, string message, string filePath, DiagnosticMessageSeverity severity);
    public DiagnosticMessage(string errorCode, string message, string filePath, DiagnosticMessageSeverity severity, int startLine, int startColumn);
    public DiagnosticMessage(string errorCode, string message, string filePath, DiagnosticMessageSeverity severity, int startLine, int startColumn, LibraryDescription source);
    public DiagnosticMessage(string errorCode, string message, string formattedMessage, string filePath, DiagnosticMessageSeverity severity, int startLine, int startColumn, int endLine, int endColumn);
    public DiagnosticMessage(string errorCode, string message, string formattedMessage, string filePath, DiagnosticMessageSeverity severity, int startLine, int startColumn, int endLine, int endColumn, LibraryDescription source);
    [CompilerGeneratedAttribute]
public string get_ErrorCode();
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public DiagnosticMessageSeverity get_Severity();
    [CompilerGeneratedAttribute]
public int get_StartLine();
    [CompilerGeneratedAttribute]
public int get_StartColumn();
    [CompilerGeneratedAttribute]
public int get_EndLine();
    [CompilerGeneratedAttribute]
public int get_EndColumn();
    [CompilerGeneratedAttribute]
public string get_FormattedMessage();
    [CompilerGeneratedAttribute]
public LibraryDescription get_Source();
}
public enum Microsoft.DotNet.ProjectModel.DiagnosticMessageSeverity : Enum {
    public int value__;
    public static DiagnosticMessageSeverity Info;
    public static DiagnosticMessageSeverity Warning;
    public static DiagnosticMessageSeverity Error;
}
public static class Microsoft.DotNet.ProjectModel.DirectoryNames : object {
    public static string Bin;
    public static string Obj;
}
internal static class Microsoft.DotNet.ProjectModel.EmptyArray`1 : object {
    public static T[] Value;
    private static EmptyArray`1();
}
public class Microsoft.DotNet.ProjectModel.EnvironmentNames : object {
    public static string PackagesStore;
    public static string StrongNameKeyFile;
    private static EnvironmentNames();
}
public static class Microsoft.DotNet.ProjectModel.ErrorCodes : object {
    public static string DOTNET1011;
    public static string DOTNET1012;
    public static string DOTNET1013;
    public static string DOTNET1014;
    public static string DOTNET1015;
    public static string DOTNET1016;
    public static string DOTNET1017;
    public static string NU1001;
    public static string NU1002;
    public static string NU1003;
    public static string NU1004;
    public static string NU1005;
    public static string NU1006;
    public static string NU1007;
    public static string NU1008;
    public static string NU1009;
    public static string NU1010;
    public static string NU1011;
    public static string NU1012;
    private static ErrorCodes();
}
public class Microsoft.DotNet.ProjectModel.FileFormatException : Exception {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Path { get; private set; }
    public int Line { get; private set; }
    public int Column { get; private set; }
    private FileFormatException(string message);
    private FileFormatException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
private void set_Path(string value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
private void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
private void set_Column(int value);
    public virtual string ToString();
    internal static FileFormatException Create(Exception exception, string filePath);
    internal static FileFormatException Create(Exception exception, JToken jsonValue, string filePath);
    internal static FileFormatException Create(Exception exception, JToken jsonValue);
    internal static FileFormatException Create(string message, JToken jsonValue, string filePath);
    internal static FileFormatException Create(string message, string filePath);
    internal static FileFormatException Create(string message, JToken jsonValue);
    internal FileFormatException WithFilePath(string path);
    private FileFormatException WithLineInfo(Exception exception);
    private FileFormatException WithLineInfo(JsonReaderException exception);
    private FileFormatException WithLineInfo(JToken value);
}
public static class Microsoft.DotNet.ProjectModel.FileNameSuffixes : object {
    public static string DepsJson;
    public static string RuntimeConfigJson;
    public static string RuntimeConfigDevJson;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <DotNet>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <Windows>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <OSX>k__BackingField;
    [CompilerGeneratedAttribute]
private static PlatformFileNameSuffixes <Linux>k__BackingField;
    public static PlatformFileNameSuffixes CurrentPlatform { get; }
    public static PlatformFileNameSuffixes DotNet { get; }
    public static PlatformFileNameSuffixes Windows { get; }
    public static PlatformFileNameSuffixes OSX { get; }
    public static PlatformFileNameSuffixes Linux { get; }
    private static FileNameSuffixes();
    public static PlatformFileNameSuffixes get_CurrentPlatform();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_DotNet();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_Windows();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_OSX();
    [CompilerGeneratedAttribute]
public static PlatformFileNameSuffixes get_Linux();
}
public class Microsoft.DotNet.ProjectModel.Files.IncludeContext : object {
    private static Char[] PatternSeparator;
    [CompilerGeneratedAttribute]
private string <SourceBasePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Option>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExcludePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <IncludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <ExcludeFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <BuiltInsInclude>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <BuiltInsExclude>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IncludeContext> <Mappings>k__BackingField;
    public string SourceBasePath { get; }
    public string Option { get; }
    public List`1<string> IncludePatterns { get; }
    public List`1<string> ExcludePatterns { get; }
    public List`1<string> IncludeFiles { get; }
    public List`1<string> ExcludeFiles { get; }
    public List`1<string> BuiltInsInclude { get; }
    public List`1<string> BuiltInsExclude { get; }
    public IDictionary`2<string, IncludeContext> Mappings { get; }
    public IncludeContext(string sourceBasePath, string option, JObject rawObject, String[] defaultBuiltInInclude, String[] defaultBuiltInExclude);
    private static IncludeContext();
    [CompilerGeneratedAttribute]
public string get_SourceBasePath();
    [CompilerGeneratedAttribute]
public string get_Option();
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludePatterns();
    [CompilerGeneratedAttribute]
public List`1<string> get_ExcludePatterns();
    [CompilerGeneratedAttribute]
public List`1<string> get_IncludeFiles();
    [CompilerGeneratedAttribute]
public List`1<string> get_ExcludeFiles();
    [CompilerGeneratedAttribute]
public List`1<string> get_BuiltInsInclude();
    [CompilerGeneratedAttribute]
public List`1<string> get_BuiltInsExclude();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IncludeContext> get_Mappings();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    private static bool EnumerableEquals(IEnumerable`1<T> left, IEnumerable`1<T> right);
    private static String[] ExtractValues(JToken token);
    internal static List`1<string> CreateCollection(string projectDirectory, string propertyName, IEnumerable`1<string> patternsStrings, bool literalPath);
    private static IEnumerable`1<string> GetSourcesSplit(string sourceDescription);
    private static string FolderToPattern(string candidate, string projectDir);
}
public class Microsoft.DotNet.ProjectModel.Files.IncludeEntry : object {
    [CompilerGeneratedAttribute]
private string <TargetPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourcePath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCustomTarget>k__BackingField;
    public string TargetPath { get; }
    public string SourcePath { get; }
    public bool IsCustomTarget { get; public set; }
    public IncludeEntry(string target, string source);
    [CompilerGeneratedAttribute]
public string get_TargetPath();
    [CompilerGeneratedAttribute]
public string get_SourcePath();
    [CompilerGeneratedAttribute]
public bool get_IsCustomTarget();
    [CompilerGeneratedAttribute]
public void set_IsCustomTarget(bool value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual bool Equals(IncludeEntry other);
}
public class Microsoft.DotNet.ProjectModel.Files.IncludeFilesResolver : object {
    public static IEnumerable`1<IncludeEntry> GetIncludeFiles(IncludeContext context, string targetBasePath, IList`1<DiagnosticMessage> diagnostics);
    public static IEnumerable`1<IncludeEntry> GetIncludeFiles(IncludeContext context, string targetBasePath, IList`1<DiagnosticMessage> diagnostics, bool flatten);
    private static IEnumerable`1<FilePatternMatch> GetIncludeFilesCore(string sourceBasePath, List`1<string> includePatterns, List`1<string> excludePatterns, List`1<string> includeFiles, List`1<string> builtInsInclude, List`1<string> builtInsExclude);
}
internal static class Microsoft.DotNet.ProjectModel.Files.NamedResourceReader : object {
    public static IDictionary`2<string, string> ReadNamedResources(JObject rawProject, string projectFilePath);
    public static void ApplyNamedResources(IDictionary`2<string, string> namedResources, IDictionary`2<string, string> resources);
}
public class Microsoft.DotNet.ProjectModel.Files.PackIncludeEntry : object {
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <SourceGlobs>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    public string Target { get; }
    public String[] SourceGlobs { get; }
    public int Line { get; }
    public int Column { get; }
    internal PackIncludeEntry(string target, JToken json);
    public PackIncludeEntry(string target, String[] sourceGlobs, int line, int column);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public String[] get_SourceGlobs();
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public int get_Column();
    private static String[] ExtractValues(JToken json);
}
public class Microsoft.DotNet.ProjectModel.Files.PatternGroup : object {
    private List`1<PatternGroup> _excludeGroups;
    private Matcher _matcher;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IncludeLiterals>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <IncludePatterns>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExcludePatterns>k__BackingField;
    public IEnumerable`1<string> IncludeLiterals { get; }
    public IEnumerable`1<string> IncludePatterns { get; }
    public IEnumerable`1<string> ExcludePatterns { get; }
    public IEnumerable`1<PatternGroup> ExcludePatternsGroup { get; }
    internal PatternGroup(IEnumerable`1<string> includePatterns);
    internal PatternGroup(IEnumerable`1<string> includePatterns, IEnumerable`1<string> excludePatterns, IEnumerable`1<string> includeLiterals);
    internal static PatternGroup Build(JObject rawProject, string projectDirectory, string projectFilePath, string name, IEnumerable`1<string> fallbackIncluding, IEnumerable`1<string> additionalIncluding, IEnumerable`1<string> additionalExcluding, bool includePatternsOnly, ICollection`1<DiagnosticMessage> warnings);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_IncludeLiterals();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_IncludePatterns();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExcludePatterns();
    public IEnumerable`1<PatternGroup> get_ExcludePatternsGroup();
    public PatternGroup ExcludeGroup(PatternGroup group);
    public IEnumerable`1<string> SearchFiles(string rootPath);
    public virtual string ToString();
}
internal static class Microsoft.DotNet.ProjectModel.Files.PatternsCollectionHelper : object {
    private static Char[] PatternSeparator;
    private static PatternsCollectionHelper();
    public static IEnumerable`1<string> GetPatternsCollection(JObject rawProject, string projectDirectory, string projectFilePath, string propertyName, IEnumerable`1<string> defaultPatterns, bool literalPath);
}
public class Microsoft.DotNet.ProjectModel.Files.ProjectFilesCollection : object {
    public static String[] DefaultCompileBuiltInPatterns;
    public static String[] DefaultPreprocessPatterns;
    public static String[] DefaultSharedPatterns;
    public static String[] DefaultResourcesBuiltInPatterns;
    public static String[] DefaultPublishExcludePatterns;
    public static String[] DefaultContentsBuiltInPatterns;
    public static String[] DefaultBuiltInExcludePatterns;
    public static string PackIncludePropertyName;
    private PatternGroup _sharedPatternsGroup;
    private PatternGroup _resourcePatternsGroup;
    private PatternGroup _preprocessPatternsGroup;
    private PatternGroup _compilePatternsGroup;
    private PatternGroup _contentPatternsGroup;
    private IDictionary`2<string, string> _namedResources;
    private IEnumerable`1<string> _publishExcludePatterns;
    private IEnumerable`1<PackIncludeEntry> _packInclude;
    private string _projectDirectory;
    private string _projectFilePath;
    private JObject _rawProject;
    private bool _initialized;
    public IEnumerable`1<PackIncludeEntry> PackInclude { get; }
    public IEnumerable`1<string> SourceFiles { get; }
    public IEnumerable`1<string> PreprocessSourceFiles { get; }
    public IDictionary`2<string, string> ResourceFiles { get; }
    public IEnumerable`1<string> SharedFiles { get; }
    internal PatternGroup CompilePatternsGroup { get; }
    internal PatternGroup SharedPatternsGroup { get; }
    internal PatternGroup ResourcePatternsGroup { get; }
    internal PatternGroup PreprocessPatternsGroup { get; }
    internal PatternGroup ContentPatternsGroup { get; }
    internal ProjectFilesCollection(JObject rawProject, string projectDirectory, string projectFilePath);
    private static ProjectFilesCollection();
    internal void EnsureInitialized();
    public IEnumerable`1<PackIncludeEntry> get_PackInclude();
    public IEnumerable`1<string> get_SourceFiles();
    public IEnumerable`1<string> get_PreprocessSourceFiles();
    public IDictionary`2<string, string> get_ResourceFiles();
    public IEnumerable`1<string> get_SharedFiles();
    public IEnumerable`1<string> GetContentFiles(IEnumerable`1<string> additionalExcludePatterns);
    internal PatternGroup get_CompilePatternsGroup();
    internal PatternGroup get_SharedPatternsGroup();
    internal PatternGroup get_ResourcePatternsGroup();
    internal PatternGroup get_PreprocessPatternsGroup();
    internal PatternGroup get_ContentPatternsGroup();
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.DirectoryInfoBase : FileSystemInfoBase {
    public abstract virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public abstract virtual DirectoryInfoBase GetDirectory(string path);
    public abstract virtual FileInfoBase GetFile(string path);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper : DirectoryInfoBase {
    private DirectoryInfo _directoryInfo;
    private bool _isParentPath;
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public DirectoryInfoWrapper(DirectoryInfo directoryInfo, bool isParentPath);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.DirectoryInfoWrapper/<EnumerateFileSystemInfos>d__3")]
public virtual IEnumerable`1<FileSystemInfoBase> EnumerateFileSystemInfos();
    public virtual DirectoryInfoBase GetDirectory(string name);
    public virtual FileInfoBase GetFile(string name);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual DirectoryInfoBase get_ParentDirectory();
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.FileInfoBase : FileSystemInfoBase {
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.FileInfoWrapper : FileInfoBase {
    private FileInfo _fileInfo;
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public FileInfoWrapper(FileInfo fileInfo);
    public virtual string get_Name();
    public virtual string get_FullName();
    public virtual DirectoryInfoBase get_ParentDirectory();
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Abstractions.FileSystemInfoBase : object {
    public string Name { get; }
    public string FullName { get; }
    public DirectoryInfoBase ParentDirectory { get; }
    public abstract virtual string get_Name();
    public abstract virtual string get_FullName();
    public abstract virtual DirectoryInfoBase get_ParentDirectory();
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.FilePatternMatch : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stem>k__BackingField;
    public string Path { get; }
    public string Stem { get; }
    public FilePatternMatch(string path, string stem);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Stem();
    public sealed virtual bool Equals(FilePatternMatch other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public interface Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.ILinearPattern {
    public IList`1<IPathSegment> Segments { get; }
    public abstract virtual IList`1<IPathSegment> get_Segments();
}
public interface Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.IPathSegment {
    public bool CanProduceStem { get; }
    public abstract virtual bool get_CanProduceStem();
    public abstract virtual bool Match(string value);
}
public interface Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.IPattern {
    public abstract virtual IPatternContext CreatePatternContextForInclude();
    public abstract virtual IPatternContext CreatePatternContextForExclude();
}
public interface Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.IPatternContext {
    public abstract virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public abstract virtual bool Test(DirectoryInfoBase directory);
    public abstract virtual PatternTestResult Test(FileInfoBase file);
    public abstract virtual void PushDirectory(DirectoryInfoBase directory);
    public abstract virtual void PopDirectory();
}
public interface Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.IRaggedPattern {
    public IList`1<IPathSegment> Segments { get; }
    public IList`1<IPathSegment> StartsWith { get; }
    public IList`1<IList`1<IPathSegment>> Contains { get; }
    public IList`1<IPathSegment> EndsWith { get; }
    public abstract virtual IList`1<IPathSegment> get_Segments();
    public abstract virtual IList`1<IPathSegment> get_StartsWith();
    public abstract virtual IList`1<IList`1<IPathSegment>> get_Contains();
    public abstract virtual IList`1<IPathSegment> get_EndsWith();
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.MatcherContext : object {
    private DirectoryInfoBase _root;
    private IList`1<IPatternContext> _includePatternContexts;
    private IList`1<IPatternContext> _excludePatternContexts;
    private IList`1<FilePatternMatch> _files;
    private HashSet`1<string> _declaredLiteralFolderSegmentInString;
    private HashSet`1<LiteralPathSegment> _declaredLiteralFolderSegments;
    private HashSet`1<LiteralPathSegment> _declaredLiteralFileSegments;
    private bool _declaredParentPathSegment;
    private bool _declaredWildcardPathSegment;
    private StringComparison _comparisonType;
    public MatcherContext(IEnumerable`1<IPattern> includePatterns, IEnumerable`1<IPattern> excludePatterns, DirectoryInfoBase directoryInfo, StringComparison comparison);
    public PatternMatchingResult Execute();
    private void Match(DirectoryInfoBase directory, string parentRelativePath);
    private void Declare();
    private void DeclareInclude(IPathSegment patternSegment, bool isLastSegment);
    internal static string CombinePath(string left, string right);
    private bool MatchPatternContexts(TFileInfoBase fileinfo, Func`3<IPatternContext, TFileInfoBase, bool> test);
    private PatternTestResult MatchPatternContexts(TFileInfoBase fileinfo, Func`3<IPatternContext, TFileInfoBase, PatternTestResult> test);
    private void PopDirectory();
    private void PushDirectory(DirectoryInfoBase directory);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PathSegments.CurrentPathSegment : object {
    public bool CanProduceStem { get; }
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PathSegments.LiteralPathSegment : object {
    private StringComparison _comparisonType;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public bool CanProduceStem { get; }
    public string Value { get; }
    public LiteralPathSegment(string value, StringComparison comparisonType);
    public sealed virtual bool get_CanProduceStem();
    [CompilerGeneratedAttribute]
public string get_Value();
    public sealed virtual bool Match(string value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PathSegments.ParentPathSegment : object {
    private static string LiteralParent;
    public bool CanProduceStem { get; }
    private static ParentPathSegment();
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PathSegments.RecursiveWildcardSegment : object {
    public bool CanProduceStem { get; }
    public sealed virtual bool get_CanProduceStem();
    public sealed virtual bool Match(string value);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PathSegments.WildcardPathSegment : object {
    public static WildcardPathSegment MatchAll;
    private StringComparison _comparisonType;
    [CompilerGeneratedAttribute]
private string <BeginsWith>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <Contains>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EndsWith>k__BackingField;
    public bool CanProduceStem { get; }
    public string BeginsWith { get; }
    public List`1<string> Contains { get; }
    public string EndsWith { get; }
    public WildcardPathSegment(string beginsWith, List`1<string> contains, string endsWith, StringComparison comparisonType);
    private static WildcardPathSegment();
    public sealed virtual bool get_CanProduceStem();
    [CompilerGeneratedAttribute]
public string get_BeginsWith();
    [CompilerGeneratedAttribute]
public List`1<string> get_Contains();
    [CompilerGeneratedAttribute]
public string get_EndsWith();
    public sealed virtual bool Match(string value);
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContext`1 : object {
    private Stack`1<TFrame> _stack;
    protected TFrame Frame;
    public virtual void Declare(Action`2<IPathSegment, bool> declare);
    public abstract virtual PatternTestResult Test(FileInfoBase file);
    public abstract virtual bool Test(DirectoryInfoBase directory);
    public abstract virtual void PushDirectory(DirectoryInfoBase directory);
    public virtual void PopDirectory();
    protected void PushDataFrame(TFrame frame);
    protected bool IsStackEmpty();
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinear : PatternContext`1<FrameData> {
    [CompilerGeneratedAttribute]
private ILinearPattern <Pattern>k__BackingField;
    protected ILinearPattern Pattern { get; }
    public PatternContextLinear(ILinearPattern pattern);
    public virtual PatternTestResult Test(FileInfoBase file);
    public virtual void PushDirectory(DirectoryInfoBase directory);
    [CompilerGeneratedAttribute]
protected ILinearPattern get_Pattern();
    protected bool IsLastSegment();
    protected bool TestMatchingSegment(string value);
    protected string CalculateStem(FileInfoBase matchedFile);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearExclude : PatternContextLinear {
    public PatternContextLinearExclude(ILinearPattern pattern);
    public virtual bool Test(DirectoryInfoBase directory);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextLinearInclude : PatternContextLinear {
    public PatternContextLinearInclude(ILinearPattern pattern);
    public virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public virtual bool Test(DirectoryInfoBase directory);
}
public abstract class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextRagged : PatternContext`1<FrameData> {
    [CompilerGeneratedAttribute]
private IRaggedPattern <Pattern>k__BackingField;
    protected IRaggedPattern Pattern { get; }
    public PatternContextRagged(IRaggedPattern pattern);
    public virtual PatternTestResult Test(FileInfoBase file);
    public sealed virtual void PushDirectory(DirectoryInfoBase directory);
    public virtual void PopDirectory();
    [CompilerGeneratedAttribute]
protected IRaggedPattern get_Pattern();
    protected bool IsStartingGroup();
    protected bool IsEndingGroup();
    protected bool TestMatchingSegment(string value);
    protected bool TestMatchingGroup(FileSystemInfoBase value);
    protected string CalculateStem(FileInfoBase matchedFile);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedExclude : PatternContextRagged {
    public PatternContextRaggedExclude(IRaggedPattern pattern);
    public virtual bool Test(DirectoryInfoBase directory);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternContexts.PatternContextRaggedInclude : PatternContextRagged {
    public PatternContextRaggedInclude(IRaggedPattern pattern);
    public virtual void Declare(Action`2<IPathSegment, bool> onDeclare);
    public virtual bool Test(DirectoryInfoBase directory);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.Patterns.PatternBuilder : object {
    private static Char[] _slashes;
    private static Char[] _star;
    [CompilerGeneratedAttribute]
private StringComparison <ComparisonType>k__BackingField;
    public StringComparison ComparisonType { get; }
    public PatternBuilder(StringComparison comparisonType);
    private static PatternBuilder();
    [CompilerGeneratedAttribute]
public StringComparison get_ComparisonType();
    public IPattern Build(string pattern);
    private static int NextIndex(string pattern, Char[] anyOf, int beginIndex, int endIndex);
    private static string Portion(string pattern, int beginIndex, int endIndex);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Internal.PatternTestResult : ValueType {
    public static PatternTestResult Failed;
    [CompilerGeneratedAttribute]
private bool <IsSuccessful>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Stem>k__BackingField;
    public bool IsSuccessful { get; }
    public string Stem { get; }
    private PatternTestResult(bool isSuccessful, string stem);
    private static PatternTestResult();
    [CompilerGeneratedAttribute]
public bool get_IsSuccessful();
    [CompilerGeneratedAttribute]
public string get_Stem();
    public static PatternTestResult Success(string stem);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Matcher : object {
    private IList`1<IPattern> _includePatterns;
    private IList`1<IPattern> _excludePatterns;
    private PatternBuilder _builder;
    private StringComparison _comparison;
    public Matcher(StringComparison comparisonType);
    public virtual Matcher AddInclude(string pattern);
    public virtual Matcher AddExclude(string pattern);
    public virtual PatternMatchingResult Execute(DirectoryInfoBase directoryInfo);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.MatcherExtensions : object {
    [ExtensionAttribute]
public static void AddExcludePatterns(Matcher matcher, IEnumerable`1[] excludePatternsGroups);
    [ExtensionAttribute]
public static void AddIncludePatterns(Matcher matcher, IEnumerable`1[] includePatternsGroups);
    [ExtensionAttribute]
public static IEnumerable`1<string> GetResultsInFullPath(Matcher matcher, string directoryPath);
}
public class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.PatternMatchingResult : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<FilePatternMatch> <Files>k__BackingField;
    public IEnumerable`1<FilePatternMatch> Files { get; public set; }
    public PatternMatchingResult(IEnumerable`1<FilePatternMatch> files);
    [CompilerGeneratedAttribute]
public IEnumerable`1<FilePatternMatch> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IEnumerable`1<FilePatternMatch> value);
}
internal static class Microsoft.DotNet.ProjectModel.FileSystemGlobbing.Util.StringComparisonHelper : object {
    public static StringComparer GetStringComparer(StringComparison comparisonType);
}
public class Microsoft.DotNet.ProjectModel.GlobalSettings : object {
    public static string FileName;
    [CompilerGeneratedAttribute]
private IList`1<string> <ProjectSearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FilePath>k__BackingField;
    public IList`1<string> ProjectSearchPaths { get; private set; }
    public string PackagesPath { get; private set; }
    public string FilePath { get; private set; }
    public string DirectoryPath { get; }
    [CompilerGeneratedAttribute]
public IList`1<string> get_ProjectSearchPaths();
    [CompilerGeneratedAttribute]
private void set_ProjectSearchPaths(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_PackagesPath();
    [CompilerGeneratedAttribute]
private void set_PackagesPath(string value);
    [CompilerGeneratedAttribute]
public string get_FilePath();
    [CompilerGeneratedAttribute]
private void set_FilePath(string value);
    public string get_DirectoryPath();
    public static bool TryGetGlobalSettings(string path, GlobalSettings& globalSettings);
    public static GlobalSettings GetGlobalSettings(Stream fs, string globalJsonPath);
    public static bool HasGlobalFile(string path);
}
public class Microsoft.DotNet.ProjectModel.Graph.BuildAction : ValueType {
    public static BuildAction Compile;
    public static BuildAction EmbeddedResource;
    public static BuildAction Resource;
    public static BuildAction None;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private BuildAction(string value);
    private static BuildAction();
    [CompilerGeneratedAttribute]
public string get_Value();
    public static bool TryParse(string value, BuildAction& type);
    public virtual string ToString();
    public sealed virtual bool Equals(BuildAction other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(BuildAction left, BuildAction right);
    public static bool op_Inequality(BuildAction left, BuildAction right);
    public virtual int GetHashCode();
}
public class Microsoft.DotNet.ProjectModel.Graph.ExportFile : object {
    public static string ExportFileName;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExportFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Exports>k__BackingField;
    public int Version { get; }
    public string ExportFilePath { get; }
    public IList`1<LockFileTargetLibrary> Exports { get; }
    public ExportFile(string exportFilePath, int version, IList`1<LockFileTargetLibrary> exports);
    private static ExportFile();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public string get_ExportFilePath();
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Exports();
}
public class Microsoft.DotNet.ProjectModel.Graph.LibraryDependencyType : ValueType {
    public static LibraryDependencyType Empty;
    public static LibraryDependencyType Default;
    public static LibraryDependencyType Build;
    public static LibraryDependencyType Platform;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private LibraryDependencyType(string value);
    private static LibraryDependencyType();
    [CompilerGeneratedAttribute]
public string get_Value();
    public static LibraryDependencyType Parse(string value);
    public virtual int GetHashCode();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(string other);
    public sealed virtual bool Equals(LibraryDependencyType other);
}
public class Microsoft.DotNet.ProjectModel.Graph.LibraryIdentity : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryType <Type>k__BackingField;
    public string Name { get; }
    public NuGetVersion Version { get; }
    public LibraryType Type { get; }
    public LibraryIdentity(string name, LibraryType type);
    public LibraryIdentity(string name, NuGetVersion version, LibraryType type);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public LibraryType get_Type();
    public virtual string ToString();
    public sealed virtual bool Equals(LibraryIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(LibraryIdentity left, LibraryIdentity right);
    public static bool op_Inequality(LibraryIdentity left, LibraryIdentity right);
    public LibraryRange ToLibraryRange();
    private static VersionRange CreateVersionRange(NuGetVersion version);
    public LibraryIdentity ChangeName(string name);
}
public class Microsoft.DotNet.ProjectModel.Graph.LibraryRange : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private VersionRange <VersionRange>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryType <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDependencyType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SourceFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceColumn>k__BackingField;
    public string Name { get; }
    public VersionRange VersionRange { get; }
    public LibraryType Target { get; }
    public LibraryDependencyType Type { get; }
    public string SourceFilePath { get; }
    public int SourceLine { get; }
    public int SourceColumn { get; }
    public LibraryRange(string name, LibraryType target);
    public LibraryRange(string name, LibraryType target, LibraryDependencyType type);
    public LibraryRange(string name, VersionRange versionRange, LibraryType target, LibraryDependencyType type);
    public LibraryRange(string name, VersionRange versionRange, LibraryType target, LibraryDependencyType type, string sourceFilePath, int sourceLine, int sourceColumn);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public VersionRange get_VersionRange();
    [CompilerGeneratedAttribute]
public LibraryType get_Target();
    [CompilerGeneratedAttribute]
public LibraryDependencyType get_Type();
    [CompilerGeneratedAttribute]
public string get_SourceFilePath();
    [CompilerGeneratedAttribute]
public int get_SourceLine();
    [CompilerGeneratedAttribute]
public int get_SourceColumn();
    public sealed virtual bool Equals(LibraryRange other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LibraryRange left, LibraryRange right);
    public static bool op_Inequality(LibraryRange left, LibraryRange right);
    public virtual int GetHashCode();
    public virtual string ToString();
    public string ToLockFileDependencyGroupString();
}
public class Microsoft.DotNet.ProjectModel.Graph.LibraryType : ValueType {
    public static LibraryType Package;
    public static LibraryType Project;
    public static LibraryType ReferenceAssembly;
    public static LibraryType MSBuildProject;
    public static LibraryType Unspecified;
    [CompilerGeneratedAttribute]
private string <Value>k__BackingField;
    public string Value { get; }
    private LibraryType(string value);
    private static LibraryType();
    [CompilerGeneratedAttribute]
public string get_Value();
    public static bool TryParse(string value, LibraryType& type);
    public virtual string ToString();
    public bool CanSatisfyConstraint(LibraryType constraint);
    public sealed virtual bool Equals(LibraryType other);
    public virtual bool Equals(object obj);
    public static bool op_Equality(LibraryType left, LibraryType right);
    public static bool op_Inequality(LibraryType left, LibraryType right);
    public virtual int GetHashCode();
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFile : object {
    public static int CurrentVersion;
    public static string FileName;
    [CompilerGeneratedAttribute]
private string <LockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<ProjectFileDependencyGroup> <ProjectFileDependencyGroups>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFilePackageLibrary> <PackageLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileProjectLibrary> <ProjectLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTarget> <Targets>k__BackingField;
    [CompilerGeneratedAttribute]
private ExportFile <ExportFile>k__BackingField;
    public string LockFilePath { get; }
    public int Version { get; public set; }
    public IList`1<ProjectFileDependencyGroup> ProjectFileDependencyGroups { get; public set; }
    public IList`1<LockFilePackageLibrary> PackageLibraries { get; public set; }
    public IList`1<LockFileProjectLibrary> ProjectLibraries { get; public set; }
    public IList`1<LockFileTarget> Targets { get; public set; }
    public ExportFile ExportFile { get; public set; }
    public LockFile(string lockFilePath);
    private static LockFile();
    [CompilerGeneratedAttribute]
public string get_LockFilePath();
    [CompilerGeneratedAttribute]
public int get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(int value);
    [CompilerGeneratedAttribute]
public IList`1<ProjectFileDependencyGroup> get_ProjectFileDependencyGroups();
    [CompilerGeneratedAttribute]
public void set_ProjectFileDependencyGroups(IList`1<ProjectFileDependencyGroup> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFilePackageLibrary> get_PackageLibraries();
    [CompilerGeneratedAttribute]
public void set_PackageLibraries(IList`1<LockFilePackageLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileProjectLibrary> get_ProjectLibraries();
    [CompilerGeneratedAttribute]
public void set_ProjectLibraries(IList`1<LockFileProjectLibrary> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTarget> get_Targets();
    [CompilerGeneratedAttribute]
public void set_Targets(IList`1<LockFileTarget> value);
    [CompilerGeneratedAttribute]
public ExportFile get_ExportFile();
    [CompilerGeneratedAttribute]
public void set_ExportFile(ExportFile value);
    public bool IsValidForProject(Project project);
    public bool IsValidForProject(Project project, String& message);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileContentFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PPOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private BuildAction <BuildAction>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeLanguage>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CopyToOutput>k__BackingField;
    public string Path { get; public set; }
    public string OutputPath { get; public set; }
    public string PPOutputPath { get; public set; }
    public BuildAction BuildAction { get; public set; }
    public string CodeLanguage { get; public set; }
    public bool CopyToOutput { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_OutputPath();
    [CompilerGeneratedAttribute]
public void set_OutputPath(string value);
    [CompilerGeneratedAttribute]
public string get_PPOutputPath();
    [CompilerGeneratedAttribute]
public void set_PPOutputPath(string value);
    [CompilerGeneratedAttribute]
public BuildAction get_BuildAction();
    [CompilerGeneratedAttribute]
public void set_BuildAction(BuildAction value);
    [CompilerGeneratedAttribute]
public string get_CodeLanguage();
    [CompilerGeneratedAttribute]
public void set_CodeLanguage(string value);
    [CompilerGeneratedAttribute]
public bool get_CopyToOutput();
    [CompilerGeneratedAttribute]
public void set_CopyToOutput(bool value);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileItem : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Properties>k__BackingField;
    public string Path { get; public set; }
    public IDictionary`2<string, string> Properties { get; }
    public LockFileItem(string path);
    public LockFileItem(string path, IDictionary`2<string, string> properties);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Properties();
    public static string op_Implicit(LockFileItem item);
    public static LockFileItem op_Implicit(string path);
    public virtual string ToString();
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileLookup : object {
    private Dictionary`2<Tuple`2<string, NuGetVersion>, LockFilePackageLibrary> _packages;
    private Dictionary`2<string, LockFileProjectLibrary> _projects;
    public LockFileLookup(LockFile lockFile);
    public LockFileProjectLibrary GetProject(string name);
    public LockFilePackageLibrary GetPackage(string id, NuGetVersion version);
    public void Clear();
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFilePackageLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsServiceable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Sha512>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Files>k__BackingField;
    public string Name { get; public set; }
    public NuGetVersion Version { get; public set; }
    public bool IsServiceable { get; public set; }
    public string Sha512 { get; public set; }
    public IList`1<string> Files { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public bool get_IsServiceable();
    [CompilerGeneratedAttribute]
public void set_IsServiceable(bool value);
    [CompilerGeneratedAttribute]
public string get_Sha512();
    [CompilerGeneratedAttribute]
public void set_Sha512(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(IList`1<string> value);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFilePatcher : object {
    private LockFile _lockFile;
    private Dictionary`2<string, IList`1<LockFileTargetLibrary>> _msbuildTargetLibraries;
    private LockFileReader _reader;
    public LockFilePatcher(LockFile lockFile, LockFileReader reader);
    public void Patch();
    public void ThrowIfAnyMsbuildLibrariesPresent();
    private void PatchLockWithExport(ExportFile exportFile);
    private static void Patch(LockFileTargetLibrary libraryToPatch, LockFileTargetLibrary export);
    private static IList`1<LockFileTargetLibrary> GetTargetsForLibrary(LockFile lockFile, LockFileProjectLibrary library);
    private static object TypeName(LockFileTargetLibrary library);
    private static string GetTargetLibraryKey(LockFileTargetLibrary library);
    private static string GetProjectLibraryKey(LockFileProjectLibrary library);
    private static string GetExportFilePath(string masterLockFilePath);
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <.ctor>b__3_0(LockFileProjectLibrary l);
}
internal class Microsoft.DotNet.ProjectModel.Graph.LockFilePatchingException : Exception {
    public LockFilePatchingException(string message);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileProjectLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProject>k__BackingField;
    public string Name { get; public set; }
    public NuGetVersion Version { get; public set; }
    public string Path { get; public set; }
    public string MSBuildProject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public string get_MSBuildProject();
    [CompilerGeneratedAttribute]
public void set_MSBuildProject(string value);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileReader : object {
    private LockFileSymbolTable _symbols;
    public LockFileReader(LockFileSymbolTable symbols);
    public static LockFile Read(string lockFilePath, bool designTime);
    public LockFile ReadLockFile(string lockFilePath, Stream stream, bool designTime);
    public ExportFile ReadExportFile(string fragmentLockFilePath);
    private LockFile ReadLockFile(string lockFilePath, JObject cursor);
    private void ReadLibrary(JObject json, LockFile lockFile);
    private LockFileTarget ReadTarget(string property, JToken json);
    private LockFileTargetLibrary ReadTargetLibrary(string property, JToken json);
    private LockFileRuntimeTarget ReadRuntimeTarget(string property, JToken json);
    private LockFileContentFile ReadContentFile(string property, JToken json);
    private ProjectFileDependencyGroup ReadProjectFileDependencyGroup(string property, JToken json);
    private PackageDependency ReadPackageDependency(string property, JToken json);
    private LockFileItem ReadFileItem(string property, JToken json);
    private string ReadFrameworkAssemblyReference(JToken json);
    private static IList`1<TItem> ReadArray(JToken json, Func`2<JToken, TItem> readItem);
    private IList`1<string> ReadPathArray(JToken json, Func`2<JToken, string> readItem);
    private static IList`1<TItem> ReadObject(JObject json, Func`3<string, JToken, TItem> readItem);
    private static bool ReadBool(JObject cursor, string property, bool defaultValue);
    private static int ReadInt(JObject cursor, string property, int defaultValue);
    private string ReadString(JToken json);
    [CompilerGeneratedAttribute]
private string <ReadPathArray>b__17_0(string f);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileRuntimeTarget : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Runtime>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssetType>k__BackingField;
    public string Path { get; }
    public string Runtime { get; }
    public string AssetType { get; }
    public LockFileRuntimeTarget(string path, string runtime, string assetType);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Runtime();
    [CompilerGeneratedAttribute]
public string get_AssetType();
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileSymbolTable : object {
    private ConcurrentDictionary`2<string, NuGetVersion> _versionTable;
    private ConcurrentDictionary`2<string, VersionRange> _versionRangeTable;
    private ConcurrentDictionary`2<string, NuGetFramework> _frameworksTable;
    private ConcurrentDictionary`2<string, string> _stringsTable;
    public NuGetVersion GetVersion(string versionString);
    public VersionRange GetVersionRange(string versionRangeString);
    public NuGetFramework GetFramework(string frameworkString);
    public string GetString(string frameworkString);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileTarget : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileTargetLibrary> <Libraries>k__BackingField;
    public NuGetFramework TargetFramework { get; public set; }
    public string RuntimeIdentifier { get; public set; }
    public IList`1<LockFileTargetLibrary> Libraries { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    [CompilerGeneratedAttribute]
public void set_RuntimeIdentifier(string value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileTargetLibrary> get_Libraries();
    [CompilerGeneratedAttribute]
public void set_Libraries(IList`1<LockFileTargetLibrary> value);
}
public class Microsoft.DotNet.ProjectModel.Graph.LockFileTargetLibrary : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<PackageDependency> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private ISet`1<string> <FrameworkAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <RuntimeAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <CompileTimeAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <ResourceAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileItem> <NativeLibraries>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileContentFile> <ContentFiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LockFileRuntimeTarget> <RuntimeTargets>k__BackingField;
    public string Name { get; public set; }
    public string Type { get; public set; }
    public NuGetFramework TargetFramework { get; public set; }
    public NuGetVersion Version { get; public set; }
    public IList`1<PackageDependency> Dependencies { get; public set; }
    public ISet`1<string> FrameworkAssemblies { get; public set; }
    public IList`1<LockFileItem> RuntimeAssemblies { get; public set; }
    public IList`1<LockFileItem> CompileTimeAssemblies { get; public set; }
    public IList`1<LockFileItem> ResourceAssemblies { get; public set; }
    public IList`1<LockFileItem> NativeLibraries { get; public set; }
    public IList`1<LockFileContentFile> ContentFiles { get; public set; }
    public IList`1<LockFileRuntimeTarget> RuntimeTargets { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public IList`1<PackageDependency> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<PackageDependency> value);
    [CompilerGeneratedAttribute]
public ISet`1<string> get_FrameworkAssemblies();
    [CompilerGeneratedAttribute]
public void set_FrameworkAssemblies(ISet`1<string> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_RuntimeAssemblies();
    [CompilerGeneratedAttribute]
public void set_RuntimeAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_CompileTimeAssemblies();
    [CompilerGeneratedAttribute]
public void set_CompileTimeAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_ResourceAssemblies();
    [CompilerGeneratedAttribute]
public void set_ResourceAssemblies(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileItem> get_NativeLibraries();
    [CompilerGeneratedAttribute]
public void set_NativeLibraries(IList`1<LockFileItem> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileContentFile> get_ContentFiles();
    [CompilerGeneratedAttribute]
public void set_ContentFiles(IList`1<LockFileContentFile> value);
    [CompilerGeneratedAttribute]
public IList`1<LockFileRuntimeTarget> get_RuntimeTargets();
    [CompilerGeneratedAttribute]
public void set_RuntimeTargets(IList`1<LockFileRuntimeTarget> value);
}
public class Microsoft.DotNet.ProjectModel.LibraryDescription : object {
    [CompilerGeneratedAttribute]
private LibraryIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Hash>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<LibraryRange> <RequestedRanges>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LibraryDescription> <Parents>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<LibraryRange> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Compatible>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <Framework>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Resolved>k__BackingField;
    public LibraryIdentity Identity { get; }
    public string Hash { get; }
    public HashSet`1<LibraryRange> RequestedRanges { get; }
    public List`1<LibraryDescription> Parents { get; }
    public string Path { get; }
    public IEnumerable`1<LibraryRange> Dependencies { get; }
    public bool Compatible { get; }
    public NuGetFramework Framework { get; public set; }
    public bool Resolved { get; public set; }
    public LibraryDescription(LibraryIdentity identity, string hash, string path, IEnumerable`1<LibraryRange> dependencies, NuGetFramework framework, bool resolved, bool compatible);
    [CompilerGeneratedAttribute]
public LibraryIdentity get_Identity();
    [CompilerGeneratedAttribute]
public string get_Hash();
    [CompilerGeneratedAttribute]
public HashSet`1<LibraryRange> get_RequestedRanges();
    [CompilerGeneratedAttribute]
public List`1<LibraryDescription> get_Parents();
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public IEnumerable`1<LibraryRange> get_Dependencies();
    [CompilerGeneratedAttribute]
public bool get_Compatible();
    [CompilerGeneratedAttribute]
public NuGetFramework get_Framework();
    [CompilerGeneratedAttribute]
public void set_Framework(NuGetFramework value);
    [CompilerGeneratedAttribute]
public bool get_Resolved();
    [CompilerGeneratedAttribute]
public void set_Resolved(bool value);
    public virtual string ToString();
}
public class Microsoft.DotNet.ProjectModel.MSBuildProjectDescription : TargetLibraryWithAssets {
    [CompilerGeneratedAttribute]
private LockFileProjectLibrary <ProjectLibrary>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MSBuildProjectPath>k__BackingField;
    [CompilerGeneratedAttribute]
private Project <ProjectFile>k__BackingField;
    public LockFileProjectLibrary ProjectLibrary { get; }
    public string MSBuildProjectPath { get; public set; }
    public Project ProjectFile { get; }
    public MSBuildProjectDescription(string path, string msbuildProjectPath, LockFileProjectLibrary projectLibrary, LockFileTargetLibrary lockFileLibrary, Project projectFile, IEnumerable`1<LibraryRange> dependencies, bool compatible, bool resolved);
    [CompilerGeneratedAttribute]
public LockFileProjectLibrary get_ProjectLibrary();
    [CompilerGeneratedAttribute]
public string get_MSBuildProjectPath();
    [CompilerGeneratedAttribute]
public void set_MSBuildProjectPath(string value);
    [CompilerGeneratedAttribute]
public Project get_ProjectFile();
}
public class Microsoft.DotNet.ProjectModel.OutputPaths : object {
    private string _runtimePath;
    private RuntimeOutputFiles _runtimeFiles;
    [CompilerGeneratedAttribute]
private string <CompilationOutputPath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IntermediateOutputDirectoryPath>k__BackingField;
    [CompilerGeneratedAttribute]
private CompilationOutputFiles <CompilationFiles>k__BackingField;
    public string CompilationOutputPath { get; }
    public string IntermediateOutputDirectoryPath { get; }
    public string RuntimeOutputPath { get; }
    public CompilationOutputFiles CompilationFiles { get; }
    public RuntimeOutputFiles RuntimeFiles { get; }
    public OutputPaths(string intermediateOutputDirectoryPath, string compilationOutputPath, string runtimePath, CompilationOutputFiles compilationFiles, RuntimeOutputFiles runtimeFiles);
    [CompilerGeneratedAttribute]
public string get_CompilationOutputPath();
    [CompilerGeneratedAttribute]
public string get_IntermediateOutputDirectoryPath();
    public string get_RuntimeOutputPath();
    [CompilerGeneratedAttribute]
public CompilationOutputFiles get_CompilationFiles();
    public RuntimeOutputFiles get_RuntimeFiles();
}
public class Microsoft.DotNet.ProjectModel.OutputPathsCalculator : object {
    private static string ObjDirectoryName;
    private static string BinDirectoryName;
    public static OutputPaths GetOutputPaths(Project project, NuGetFramework framework, string runtimeIdentifier, string configuration, string solutionRootPath, string buildBasePath, string outputPath);
}
public class Microsoft.DotNet.ProjectModel.PackageDescription : TargetLibraryWithAssets {
    [CompilerGeneratedAttribute]
private LockFilePackageLibrary <PackageLibrary>k__BackingField;
    public LockFilePackageLibrary PackageLibrary { get; }
    public IEnumerable`1<LockFileItem> RuntimeAssemblies { get; }
    public IEnumerable`1<LockFileItem> CompileTimeAssemblies { get; }
    public bool HasCompileTimePlaceholder { get; }
    public PackageDescription(string path, LockFilePackageLibrary package, LockFileTargetLibrary lockFileLibrary, IEnumerable`1<LibraryRange> dependencies, bool compatible, bool resolved);
    [CompilerGeneratedAttribute]
public LockFilePackageLibrary get_PackageLibrary();
    public virtual IEnumerable`1<LockFileItem> get_RuntimeAssemblies();
    public virtual IEnumerable`1<LockFileItem> get_CompileTimeAssemblies();
    public bool get_HasCompileTimePlaceholder();
    private static IEnumerable`1<LockFileItem> FilterPlaceholders(IEnumerable`1<LockFileItem> items);
}
public class Microsoft.DotNet.ProjectModel.PackOptions : object {
    [CompilerGeneratedAttribute]
private String[] <Tags>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Owners>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReleaseNotes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IconUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LicenseUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireLicenseAcceptance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RepositoryUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Summary>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeContext <PackInclude>k__BackingField;
    public String[] Tags { get; public set; }
    public String[] Owners { get; public set; }
    public string ReleaseNotes { get; public set; }
    public string IconUrl { get; public set; }
    public string ProjectUrl { get; public set; }
    public string LicenseUrl { get; public set; }
    public bool RequireLicenseAcceptance { get; public set; }
    public string RepositoryType { get; public set; }
    public string RepositoryUrl { get; public set; }
    public string Summary { get; public set; }
    public IncludeContext PackInclude { get; public set; }
    [CompilerGeneratedAttribute]
public String[] get_Tags();
    [CompilerGeneratedAttribute]
public void set_Tags(String[] value);
    [CompilerGeneratedAttribute]
public String[] get_Owners();
    [CompilerGeneratedAttribute]
public void set_Owners(String[] value);
    [CompilerGeneratedAttribute]
public string get_ReleaseNotes();
    [CompilerGeneratedAttribute]
public void set_ReleaseNotes(string value);
    [CompilerGeneratedAttribute]
public string get_IconUrl();
    [CompilerGeneratedAttribute]
public void set_IconUrl(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectUrl();
    [CompilerGeneratedAttribute]
public void set_ProjectUrl(string value);
    [CompilerGeneratedAttribute]
public string get_LicenseUrl();
    [CompilerGeneratedAttribute]
public void set_LicenseUrl(string value);
    [CompilerGeneratedAttribute]
public bool get_RequireLicenseAcceptance();
    [CompilerGeneratedAttribute]
public void set_RequireLicenseAcceptance(bool value);
    [CompilerGeneratedAttribute]
public string get_RepositoryType();
    [CompilerGeneratedAttribute]
public void set_RepositoryType(string value);
    [CompilerGeneratedAttribute]
public string get_RepositoryUrl();
    [CompilerGeneratedAttribute]
public void set_RepositoryUrl(string value);
    [CompilerGeneratedAttribute]
public string get_Summary();
    [CompilerGeneratedAttribute]
public void set_Summary(string value);
    [CompilerGeneratedAttribute]
public IncludeContext get_PackInclude();
    [CompilerGeneratedAttribute]
public void set_PackInclude(IncludeContext value);
}
public class Microsoft.DotNet.ProjectModel.Project : object {
    public static string FileName;
    internal Dictionary`2<NuGetFramework, TargetFrameworkInformation> _targetFrameworks;
    internal Dictionary`2<string, CommonCompilerOptions> _compilerOptionsByConfiguration;
    internal CommonCompilerOptions _defaultCompilerOptions;
    internal TargetFrameworkInformation _defaultTargetFrameworkConfiguration;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private AnalyzerOptions <AnalyzerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Copyright>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Language>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Authors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EmbedInteropTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetVersion <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <AssemblyFileVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LibraryRange> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LibraryRange> <Tools>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TestRunner>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectFilesCollection <Files>k__BackingField;
    [CompilerGeneratedAttribute]
private PackOptions <PackOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Serviceable>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeOptions <RuntimeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Commands>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, IEnumerable`1<string>> <Scripts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawRuntimeOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private IncludeContext <PublishOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DiagnosticMessage> <Diagnostics>k__BackingField;
    public string ProjectFilePath { get; public set; }
    public string ProjectDirectory { get; }
    public AnalyzerOptions AnalyzerOptions { get; public set; }
    public string Name { get; public set; }
    public string Title { get; public set; }
    public string Description { get; public set; }
    public string Copyright { get; public set; }
    public string Language { get; public set; }
    public String[] Authors { get; public set; }
    public bool EmbedInteropTypes { get; public set; }
    public NuGetVersion Version { get; public set; }
    public Version AssemblyFileVersion { get; public set; }
    public IList`1<LibraryRange> Dependencies { get; public set; }
    public List`1<LibraryRange> Tools { get; public set; }
    public string EntryPoint { get; public set; }
    public string TestRunner { get; public set; }
    public ProjectFilesCollection Files { get; public set; }
    public PackOptions PackOptions { get; public set; }
    public bool Serviceable { get; public set; }
    public RuntimeOptions RuntimeOptions { get; public set; }
    public IDictionary`2<string, string> Commands { get; }
    public IDictionary`2<string, IEnumerable`1<string>> Scripts { get; }
    public string RawRuntimeOptions { get; public set; }
    public IncludeContext PublishOptions { get; public set; }
    public List`1<DiagnosticMessage> Diagnostics { get; }
    public bool IsTestProject { get; }
    private static Project();
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public AnalyzerOptions get_AnalyzerOptions();
    [CompilerGeneratedAttribute]
public void set_AnalyzerOptions(AnalyzerOptions value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_Copyright();
    [CompilerGeneratedAttribute]
public void set_Copyright(string value);
    [CompilerGeneratedAttribute]
public string get_Language();
    [CompilerGeneratedAttribute]
public void set_Language(string value);
    [CompilerGeneratedAttribute]
public String[] get_Authors();
    [CompilerGeneratedAttribute]
public void set_Authors(String[] value);
    [CompilerGeneratedAttribute]
public bool get_EmbedInteropTypes();
    [CompilerGeneratedAttribute]
public void set_EmbedInteropTypes(bool value);
    [CompilerGeneratedAttribute]
public NuGetVersion get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(NuGetVersion value);
    [CompilerGeneratedAttribute]
public Version get_AssemblyFileVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyFileVersion(Version value);
    [CompilerGeneratedAttribute]
public IList`1<LibraryRange> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IList`1<LibraryRange> value);
    [CompilerGeneratedAttribute]
public List`1<LibraryRange> get_Tools();
    [CompilerGeneratedAttribute]
public void set_Tools(List`1<LibraryRange> value);
    [CompilerGeneratedAttribute]
public string get_EntryPoint();
    [CompilerGeneratedAttribute]
public void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
public string get_TestRunner();
    [CompilerGeneratedAttribute]
public void set_TestRunner(string value);
    [CompilerGeneratedAttribute]
public ProjectFilesCollection get_Files();
    [CompilerGeneratedAttribute]
public void set_Files(ProjectFilesCollection value);
    [CompilerGeneratedAttribute]
public PackOptions get_PackOptions();
    [CompilerGeneratedAttribute]
public void set_PackOptions(PackOptions value);
    [CompilerGeneratedAttribute]
public bool get_Serviceable();
    [CompilerGeneratedAttribute]
public void set_Serviceable(bool value);
    [CompilerGeneratedAttribute]
public RuntimeOptions get_RuntimeOptions();
    [CompilerGeneratedAttribute]
public void set_RuntimeOptions(RuntimeOptions value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Commands();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, IEnumerable`1<string>> get_Scripts();
    [CompilerGeneratedAttribute]
public string get_RawRuntimeOptions();
    [CompilerGeneratedAttribute]
public void set_RawRuntimeOptions(string value);
    [CompilerGeneratedAttribute]
public IncludeContext get_PublishOptions();
    [CompilerGeneratedAttribute]
public void set_PublishOptions(IncludeContext value);
    [CompilerGeneratedAttribute]
public List`1<DiagnosticMessage> get_Diagnostics();
    public bool get_IsTestProject();
    public IEnumerable`1<TargetFrameworkInformation> GetTargetFrameworks();
    public IEnumerable`1<string> GetConfigurations();
    public CommonCompilerOptions GetCompilerOptions(NuGetFramework targetFramework, string configurationName);
    public TargetFrameworkInformation GetTargetFramework(NuGetFramework targetFramework);
    public bool HasRuntimeOutput(string configuration);
    private CommonCompilerOptions GetCompilerOptions();
    private CommonCompilerOptions GetCompilerOptions(string configurationName);
    private CommonCompilerOptions GetCompilerOptions(NuGetFramework frameworkName);
}
public class Microsoft.DotNet.ProjectModel.ProjectContext : object {
    private String[] _runtimeFallbacks;
    [CompilerGeneratedAttribute]
private ProjectContextIdentity <Identity>k__BackingField;
    [CompilerGeneratedAttribute]
private GlobalSettings <GlobalSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectDescription <RootProject>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryDescription <PlatformLibrary>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RuntimeIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <LockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private LibraryManager <LibraryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DiagnosticMessage> <Diagnostics>k__BackingField;
    public ProjectContextIdentity Identity { get; }
    public GlobalSettings GlobalSettings { get; }
    public ProjectDescription RootProject { get; }
    public NuGetFramework TargetFramework { get; }
    public LibraryDescription PlatformLibrary { get; }
    public bool IsPortable { get; }
    public string RuntimeIdentifier { get; }
    public Project ProjectFile { get; }
    public LockFile LockFile { get; }
    public string RootDirectory { get; }
    public string ProjectDirectory { get; }
    public string PackagesDirectory { get; }
    public LibraryManager LibraryManager { get; }
    public List`1<DiagnosticMessage> Diagnostics { get; }
    internal ProjectContext(GlobalSettings globalSettings, ProjectDescription rootProject, LibraryDescription platformLibrary, NuGetFramework targetFramework, bool isPortable, string runtimeIdentifier, string packagesDirectory, LibraryManager libraryManager, LockFile lockfile, List`1<DiagnosticMessage> diagnostics);
    [CompilerGeneratedAttribute]
public ProjectContextIdentity get_Identity();
    [CompilerGeneratedAttribute]
public GlobalSettings get_GlobalSettings();
    [CompilerGeneratedAttribute]
public ProjectDescription get_RootProject();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
public LibraryDescription get_PlatformLibrary();
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
    [CompilerGeneratedAttribute]
public string get_RuntimeIdentifier();
    public Project get_ProjectFile();
    [CompilerGeneratedAttribute]
public LockFile get_LockFile();
    public string get_RootDirectory();
    public string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
public string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
public LibraryManager get_LibraryManager();
    [CompilerGeneratedAttribute]
public List`1<DiagnosticMessage> get_Diagnostics();
    public LibraryExporter CreateExporter(string configuration, string buildBasePath);
    public static ProjectContext Create(string projectPath, NuGetFramework framework);
    public static ProjectContext Create(string projectPath, NuGetFramework framework, IEnumerable`1<string> runtimeIdentifiers);
    public static ProjectContextBuilder CreateBuilder(string projectPath, NuGetFramework framework);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.ProjectContext/<CreateContextForEachFramework>d__45")]
public static IEnumerable`1<ProjectContext> CreateContextForEachFramework(string projectPath, ProjectReaderSettings settings, IEnumerable`1<string> runtimeIdentifiers);
    public static IEnumerable`1<ProjectContext> CreateContextForEachTarget(string projectPath, ProjectReaderSettings settings);
    public OutputPaths GetOutputPaths(string configuration, string buidBasePath, string outputPath);
}
public class Microsoft.DotNet.ProjectModel.ProjectContextBuilder : object {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private LockFile <LockFile>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <RuntimeIdentifiers>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RootDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PackagesDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ReferenceAssembliesPath>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDesignTime>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, Project> <ProjectResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<string, LockFile> <LockFileResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private ProjectReaderSettings <ProjectReaderSettings>k__BackingField;
    private Project Project { get; private set; }
    private LockFile LockFile { get; private set; }
    private NuGetFramework TargetFramework { get; private set; }
    private IEnumerable`1<string> RuntimeIdentifiers { get; private set; }
    private string RootDirectory { get; private set; }
    private string ProjectDirectory { get; private set; }
    private string PackagesDirectory { get; private set; }
    private string ReferenceAssembliesPath { get; private set; }
    private bool IsDesignTime { get; private set; }
    private Func`2<string, Project> ProjectResolver { get; private set; }
    private Func`2<string, LockFile> LockFileResolver { get; private set; }
    private ProjectReaderSettings ProjectReaderSettings { get; private set; }
    [CompilerGeneratedAttribute]
private Project get_Project();
    [CompilerGeneratedAttribute]
private void set_Project(Project value);
    [CompilerGeneratedAttribute]
private LockFile get_LockFile();
    [CompilerGeneratedAttribute]
private void set_LockFile(LockFile value);
    [CompilerGeneratedAttribute]
private NuGetFramework get_TargetFramework();
    [CompilerGeneratedAttribute]
private void set_TargetFramework(NuGetFramework value);
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> get_RuntimeIdentifiers();
    [CompilerGeneratedAttribute]
private void set_RuntimeIdentifiers(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
private string get_RootDirectory();
    [CompilerGeneratedAttribute]
private void set_RootDirectory(string value);
    [CompilerGeneratedAttribute]
private string get_ProjectDirectory();
    [CompilerGeneratedAttribute]
private void set_ProjectDirectory(string value);
    [CompilerGeneratedAttribute]
private string get_PackagesDirectory();
    [CompilerGeneratedAttribute]
private void set_PackagesDirectory(string value);
    [CompilerGeneratedAttribute]
private string get_ReferenceAssembliesPath();
    [CompilerGeneratedAttribute]
private void set_ReferenceAssembliesPath(string value);
    [CompilerGeneratedAttribute]
private bool get_IsDesignTime();
    [CompilerGeneratedAttribute]
private void set_IsDesignTime(bool value);
    [CompilerGeneratedAttribute]
private Func`2<string, Project> get_ProjectResolver();
    [CompilerGeneratedAttribute]
private void set_ProjectResolver(Func`2<string, Project> value);
    [CompilerGeneratedAttribute]
private Func`2<string, LockFile> get_LockFileResolver();
    [CompilerGeneratedAttribute]
private void set_LockFileResolver(Func`2<string, LockFile> value);
    [CompilerGeneratedAttribute]
private ProjectReaderSettings get_ProjectReaderSettings();
    [CompilerGeneratedAttribute]
private void set_ProjectReaderSettings(ProjectReaderSettings value);
    public ProjectContextBuilder Clone();
    public ProjectContextBuilder WithLockFile(LockFile lockFile);
    public ProjectContextBuilder WithProject(Project project);
    public ProjectContextBuilder WithProjectDirectory(string projectDirectory);
    public ProjectContextBuilder WithTargetFramework(NuGetFramework targetFramework);
    public ProjectContextBuilder WithTargetFramework(string targetFramework);
    public ProjectContextBuilder WithRuntimeIdentifiers(IEnumerable`1<string> runtimeIdentifiers);
    public ProjectContextBuilder WithReferenceAssembliesPath(string referenceAssembliesPath);
    public ProjectContextBuilder WithPackagesDirectory(string packagesDirectory);
    public ProjectContextBuilder WithRootDirectory(string rootDirectory);
    public ProjectContextBuilder WithProjectResolver(Func`2<string, Project> projectResolver);
    public ProjectContextBuilder WithLockFileResolver(Func`2<string, LockFile> lockFileResolver);
    public ProjectContextBuilder WithProjectReaderSettings(ProjectReaderSettings projectReaderSettings);
    public ProjectContextBuilder AsDesignTime();
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.ProjectContextBuilder/<BuildAllTargets>d__63")]
public IEnumerable`1<ProjectContext> BuildAllTargets();
    public ProjectContext Build();
    private void ReadLockFile(ICollection`1<DiagnosticMessage> diagnostics);
    private static string ComposeMessageFromInnerExceptions(Exception exception);
    private void ResolveDependencies(Dictionary`2<LibraryKey, LibraryDescription> libraries, ReferenceAssemblyDependencyResolver referenceAssemblyDependencyResolver, Boolean& requiresFrameworkAssemblies);
    private void ScanLibraries(LockFileTarget target, LockFileLookup lockFileLookup, Dictionary`2<LibraryKey, LibraryDescription> libraries, MSBuildDependencyProvider msbuildResolver, PackageDependencyProvider packageResolver, ProjectDependencyProvider projectResolver);
    private void EnsureProjectLoaded();
    private LockFileTarget SelectTarget(LockFile lockFile, bool isPortable);
    private Project ResolveProject(string projectDirectory);
    private static LockFile ResolveLockFile(string projectDir);
}
public class Microsoft.DotNet.ProjectModel.ProjectContextCollection : object {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<ProjectContext> <ProjectContexts>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<DiagnosticMessage> <ProjectDiagnostics>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LockFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ProjectFilePath>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastProjectFileWriteTimeUtc>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <LastLockFileWriteTimeUtc>k__BackingField;
    public Project Project { get; public set; }
    public List`1<ProjectContext> ProjectContexts { get; }
    public IEnumerable`1<ProjectContext> FrameworkOnlyContexts { get; }
    public List`1<DiagnosticMessage> ProjectDiagnostics { get; }
    public string LockFilePath { get; public set; }
    public string ProjectFilePath { get; public set; }
    public DateTime LastProjectFileWriteTimeUtc { get; public set; }
    public DateTime LastLockFileWriteTimeUtc { get; public set; }
    public bool HasChanged { get; }
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public void set_Project(Project value);
    [CompilerGeneratedAttribute]
public List`1<ProjectContext> get_ProjectContexts();
    public IEnumerable`1<ProjectContext> get_FrameworkOnlyContexts();
    [CompilerGeneratedAttribute]
public List`1<DiagnosticMessage> get_ProjectDiagnostics();
    [CompilerGeneratedAttribute]
public string get_LockFilePath();
    [CompilerGeneratedAttribute]
public void set_LockFilePath(string value);
    [CompilerGeneratedAttribute]
public string get_ProjectFilePath();
    [CompilerGeneratedAttribute]
public void set_ProjectFilePath(string value);
    [CompilerGeneratedAttribute]
public DateTime get_LastProjectFileWriteTimeUtc();
    [CompilerGeneratedAttribute]
public void set_LastProjectFileWriteTimeUtc(DateTime value);
    [CompilerGeneratedAttribute]
public DateTime get_LastLockFileWriteTimeUtc();
    [CompilerGeneratedAttribute]
public void set_LastLockFileWriteTimeUtc(DateTime value);
    public bool get_HasChanged();
    public ProjectContext GetTarget(NuGetFramework targetFramework);
    public ProjectContext GetTarget(NuGetFramework targetFramework, string runtimeIdentifier);
    public void Reset();
}
public class Microsoft.DotNet.ProjectModel.ProjectContextIdentity : ValueType {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private NuGetFramework <TargetFramework>k__BackingField;
    public string Path { get; }
    public NuGetFramework TargetFramework { get; }
    public ProjectContextIdentity(string path, NuGetFramework targetFramework);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public NuGetFramework get_TargetFramework();
    public bool Equals(ProjectContextIdentity other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.DotNet.ProjectModel.ProjectDescription : LibraryDescription {
    [CompilerGeneratedAttribute]
private Project <Project>k__BackingField;
    [CompilerGeneratedAttribute]
private TargetFrameworkInformation <TargetFrameworkInfo>k__BackingField;
    public Project Project { get; }
    public TargetFrameworkInformation TargetFrameworkInfo { get; }
    public ProjectDescription(string name, string path);
    public ProjectDescription(LibraryRange libraryRange, Project project, IEnumerable`1<LibraryRange> dependencies, TargetFrameworkInformation targetFrameworkInfo, bool resolved);
    [CompilerGeneratedAttribute]
public Project get_Project();
    [CompilerGeneratedAttribute]
public TargetFrameworkInformation get_TargetFrameworkInfo();
    public OutputPaths GetOutputPaths(string buildBasePath, string solutionRootPath, string configuration, string runtime);
}
[ExtensionAttribute]
public static class Microsoft.DotNet.ProjectModel.ProjectExtensions : object {
    private static KeyValuePair`2[] _compilerNameToLanguageId;
    private static ProjectExtensions();
    [ExtensionAttribute]
public static string GetSourceCodeLanguage(Project project);
}
public class Microsoft.DotNet.ProjectModel.ProjectFileDependencyGroup : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Dependencies>k__BackingField;
    public NuGetFramework FrameworkName { get; }
    public IEnumerable`1<string> Dependencies { get; }
    public ProjectFileDependencyGroup(NuGetFramework frameworkName, IEnumerable`1<string> dependencies);
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Dependencies();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.ProjectModel.ProjectModelPlatformExtensions : object {
    [ExtensionAttribute]
public static HashSet`1<string> GetPlatformExclusionList(ProjectContext context, IDictionary`2<string, LibraryExport> exports);
    private static void CollectDependencies(IDictionary`2<string, LibraryExport> exports, IEnumerable`1<LibraryRange> dependencies, HashSet`1<string> exclusionList);
    [ExtensionAttribute]
public static HashSet`1<string> GetTypeBuildExclusionList(ProjectContext context, IDictionary`2<string, LibraryExport> exports);
    [ExtensionAttribute]
public static IEnumerable`1<LibraryExport> FilterExports(IEnumerable`1<LibraryExport> exports, HashSet`1<string> exclusionList);
}
public static class Microsoft.DotNet.ProjectModel.ProjectPathHelper : object {
    public static string NormalizeProjectDirectoryPath(string path);
    public static string NormalizeProjectFilePath(string path);
    private static bool IsProjectFilePath(string path);
    private static bool IsDirectoryContainingProjectFile(string path);
}
public class Microsoft.DotNet.ProjectModel.ProjectReader : object {
    public static bool TryGetProject(string path, Project& project, ProjectReaderSettings settings);
    public static Project GetProject(string projectPath, ProjectReaderSettings settings);
    public Project ReadProject(Stream stream, string projectName, string projectPath, ProjectReaderSettings settings);
    private static NuGetVersion SpecifySnapshot(string version, string snapshotValue);
    private static void PopulateDependencies(string projectPath, IList`1<LibraryRange> results, JObject settings, string propertyName, bool isGacOrFrameworkReference);
    private void BuildTargetFrameworksAndConfigurations(Project project, JObject projectJsonObject);
    private bool BuildTargetFrameworkNode(Project project, string frameworkKey, JObject frameworkValue);
    private static CommonCompilerOptions GetCompilationOptions(JObject rawObject, Project project);
    private static IncludeContext GetIncludeContext(Project project, JObject rawOptions, string option, String[] defaultBuiltInInclude, String[] defaultBuiltInExclude);
    private static PackOptions GetPackOptions(JObject rawProject, Project project);
    private static T GetPackOptionsValue(string option, JObject rawProject, JObject rawPackOptions, Project project);
    private static RuntimeOptions GetRuntimeOptions(JObject rawProject);
    private static IncludeContext GetPublishInclude(JObject rawProject, Project project);
    private static string MakeDefaultTargetFrameworkDefine(NuGetFramework targetFramework);
    private static bool HasProjectFile(string path);
    private static void AddProjectFilesCollectionDiagnostics(JObject rawProject, Project project);
    private static void AddDiagnosticMesage(JObject rawProject, Project project, string option, string message);
}
public class Microsoft.DotNet.ProjectModel.ProjectReaderSettings : object {
    [CompilerGeneratedAttribute]
private string <VersionSuffix>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyFileVersion>k__BackingField;
    public string VersionSuffix { get; public set; }
    public string AssemblyFileVersion { get; public set; }
    [CompilerGeneratedAttribute]
public string get_VersionSuffix();
    [CompilerGeneratedAttribute]
public void set_VersionSuffix(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyFileVersion();
    [CompilerGeneratedAttribute]
public void set_AssemblyFileVersion(string value);
    public static ProjectReaderSettings ReadFromEnvironment();
}
public static class Microsoft.DotNet.ProjectModel.ProjectRootResolver : object {
    public static string GlobalFileName;
    private static ProjectRootResolver();
    public static string ResolveRootDirectory(string projectPath);
}
internal class Microsoft.DotNet.ProjectModel.Resolution.AssemblyEntry : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    public string Path { get; public set; }
    public Version Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(Version value);
}
internal class Microsoft.DotNet.ProjectModel.Resolution.FrameworkInformation : object {
    private Nullable`1<bool> _exists;
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <SearchPaths>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedistListPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, AssemblyEntry> <Assemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public bool Exists { get; public set; }
    public string Path { get; public set; }
    public IEnumerable`1<string> SearchPaths { get; public set; }
    public string RedistListPath { get; public set; }
    public IDictionary`2<string, AssemblyEntry> Assemblies { get; private set; }
    public string Name { get; public set; }
    public bool get_Exists();
    public void set_Exists(bool value);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public void set_Path(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_SearchPaths();
    [CompilerGeneratedAttribute]
public void set_SearchPaths(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_RedistListPath();
    [CompilerGeneratedAttribute]
public void set_RedistListPath(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, AssemblyEntry> get_Assemblies();
    [CompilerGeneratedAttribute]
private void set_Assemblies(IDictionary`2<string, AssemblyEntry> value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
}
public class Microsoft.DotNet.ProjectModel.Resolution.FrameworkReferenceResolver : object {
    private static NuGetFramework Dnx46;
    private static FrameworkReferenceResolver _default;
    private ConcurrentDictionary`2<NuGetFramework, FrameworkInformation> _cache;
    private static IDictionary`2<NuGetFramework, NuGetFramework[]> _aliases;
    [CompilerGeneratedAttribute]
private string <ReferenceAssembliesPath>k__BackingField;
    public string ReferenceAssembliesPath { get; }
    public static FrameworkReferenceResolver Default { get; }
    public FrameworkReferenceResolver(string referenceAssembliesPath);
    private static FrameworkReferenceResolver();
    [CompilerGeneratedAttribute]
public string get_ReferenceAssembliesPath();
    public static FrameworkReferenceResolver get_Default();
    public static string GetDefaultReferenceAssembliesPath();
    public bool TryGetAssembly(string name, NuGetFramework targetFramework, String& path, Version& version);
    public bool IsInstalled(NuGetFramework targetFramework);
    public string GetFrameworkRedistListPath(NuGetFramework targetFramework);
    public string GetFriendlyFrameworkName(NuGetFramework targetFramework);
    private FrameworkInformation GetFrameworkInformation(NuGetFramework targetFramework);
    private static FrameworkInformation GetFrameworkInformation(NuGetFramework targetFramework, string referenceAssembliesPath);
    private static FrameworkInformation GetLegacyFrameworkInformation(NuGetFramework targetFramework, string referenceAssembliesPath);
    private static string SynthesizeFrameworkFriendlyName(NuGetFramework targetFramework);
    private static FrameworkInformation GetFrameworkInformation(DirectoryInfo directory, NuGetFramework targetFramework, string referenceAssembliesPath);
    private static void PopulateFromRedistList(DirectoryInfo directory, NuGetFramework targetFramework, string referenceAssembliesPath, FrameworkInformation frameworkInfo);
    private static void PopulateAssemblies(IDictionary`2<string, AssemblyEntry> assemblies, string path);
    private static string GetAssemblyPath(IEnumerable`1<string> basePaths, string assemblyName);
    private static Version GetDisplayVersion(NuGetFramework framework);
}
public class Microsoft.DotNet.ProjectModel.Resolution.LibraryManager : object {
    private IList`1<LibraryDescription> _libraries;
    private IList`1<DiagnosticMessage> _diagnostics;
    private string _projectPath;
    public LibraryManager(IList`1<LibraryDescription> libraries, IList`1<DiagnosticMessage> diagnostics, string projectPath);
    public IList`1<LibraryDescription> GetLibraries();
    public IList`1<DiagnosticMessage> GetAllDiagnostics();
    private static string FormatLibraryRange(LibraryRange range);
    private void AddDiagnostics(List`1<DiagnosticMessage> messages, LibraryDescription library, string message, DiagnosticMessageSeverity severity, string errorCode);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Resolution.LibraryManager/<GetRangesWithSourceLocations>d__8")]
private IEnumerable`1<LibraryRange> GetRangesWithSourceLocations(LibraryDescription library);
}
public class Microsoft.DotNet.ProjectModel.Resolution.MSBuildDependencyProvider : object {
    private Project _rootProject;
    private Func`2<string, Project> _projectResolver;
    public MSBuildDependencyProvider(Project rootProject, Func`2<string, Project> projectResolver);
    public MSBuildProjectDescription GetDescription(NuGetFramework targetFramework, LockFileProjectLibrary projectLibrary, LockFileTargetLibrary targetLibrary, bool isDesignTime);
    private string GetMSBuildProjectFilePath(LockFileProjectLibrary projectLibrary);
    private void PopulateDependencies(List`1<LibraryRange> dependencies, LockFileTargetLibrary targetLibrary, NuGetFramework targetFramework);
    public static bool IsMSBuildProjectLibrary(LockFileProjectLibrary projectLibrary);
}
public class Microsoft.DotNet.ProjectModel.Resolution.PackageDependencyProvider : object {
    private VersionFolderPathResolver _packagePathResolver;
    private FrameworkReferenceResolver _frameworkReferenceResolver;
    public PackageDependencyProvider(string packagesPath, FrameworkReferenceResolver frameworkReferenceResolver);
    public PackageDescription GetDescription(NuGetFramework targetFramework, LockFilePackageLibrary package, LockFileTargetLibrary targetLibrary);
    private void PopulateLegacyPortableDependencies(NuGetFramework targetFramework, List`1<LibraryRange> dependencies, string packagePath, LockFileTargetLibrary targetLibrary);
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.Resolution.PackageDependencyProvider/<GetDependencies>d__5")]
private static IEnumerable`1<string> GetDependencies(string path);
    private void PopulateDependencies(List`1<LibraryRange> dependencies, LockFileTargetLibrary targetLibrary, NuGetFramework targetFramework);
    public static bool IsPlaceholderFile(string path);
    public static string ResolvePackagesPath(string rootDirectory, GlobalSettings settings);
}
public class Microsoft.DotNet.ProjectModel.Resolution.ProjectDependencyProvider : object {
    private Func`2<string, Project> _resolveProject;
    public ProjectDependencyProvider(Func`2<string, Project> projectCacheResolver);
    public ProjectDescription GetDescription(string name, string path, LockFileTargetLibrary targetLibrary, Func`2<string, Project> projectCacheResolver);
    public ProjectDescription GetDescription(string name, string path, LockFileTargetLibrary targetLibrary);
    public ProjectDescription GetDescription(NuGetFramework targetFramework, Project project, LockFileTargetLibrary targetLibrary);
    private static void AddIfMissing(List`1<LibraryRange> dependencies, string dependencyName);
}
public class Microsoft.DotNet.ProjectModel.Resolution.ReferenceAssemblyDependencyResolver : object {
    [CompilerGeneratedAttribute]
private FrameworkReferenceResolver <FrameworkResolver>k__BackingField;
    private FrameworkReferenceResolver FrameworkResolver { get; private set; }
    public ReferenceAssemblyDependencyResolver(FrameworkReferenceResolver frameworkReferenceResolver);
    [CompilerGeneratedAttribute]
private FrameworkReferenceResolver get_FrameworkResolver();
    [CompilerGeneratedAttribute]
private void set_FrameworkResolver(FrameworkReferenceResolver value);
    public LibraryDescription GetDescription(LibraryRange libraryRange, NuGetFramework targetFramework);
}
public static class Microsoft.DotNet.ProjectModel.Resolution.UnresolvedDependencyProvider : object {
    public static LibraryDescription GetDescription(LibraryRange libraryRange, NuGetFramework targetFramework);
}
public class Microsoft.DotNet.ProjectModel.ResourceFile : object {
    [CompilerGeneratedAttribute]
private string <Path>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Locale>k__BackingField;
    public string Path { get; }
    public string Locale { get; }
    public ResourceFile(string path, string locale);
    [CompilerGeneratedAttribute]
public string get_Path();
    [CompilerGeneratedAttribute]
public string get_Locale();
}
internal static class Microsoft.DotNet.ProjectModel.Resources.CultureInfoCache : object {
    public static HashSet`1<string> KnownCultureNames;
    private static CultureInfoCache();
}
public static class Microsoft.DotNet.ProjectModel.Resources.ResourceUtility : object {
    public static string GetResourceName(string projectFolder, string resourcePath);
    public static bool IsResourceFile(string fileName);
    public static bool IsResxFile(string fileName);
    public static IEnumerable`1<string> GetResourcesForCulture(string cultureName, IList`1<string> resources);
    public static string GetResourceCultureName(string res);
}
public class Microsoft.DotNet.ProjectModel.RuntimeConfig : object {
    [CompilerGeneratedAttribute]
private bool <IsPortable>k__BackingField;
    [CompilerGeneratedAttribute]
private RuntimeConfigFramework <Framework>k__BackingField;
    public bool IsPortable { get; }
    public RuntimeConfigFramework Framework { get; }
    public RuntimeConfig(string runtimeConfigPath);
    [CompilerGeneratedAttribute]
public bool get_IsPortable();
    [CompilerGeneratedAttribute]
public RuntimeConfigFramework get_Framework();
    public static bool IsApplicationPortable(string entryAssemblyPath);
    private JObject OpenRuntimeConfig(string runtimeConfigPath);
    private RuntimeConfigFramework ParseFramework(JObject runtimeConfigRoot);
}
public class Microsoft.DotNet.ProjectModel.RuntimeConfigFramework : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    public string Name { get; public set; }
    public string Version { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    public static RuntimeConfigFramework ParseFromFrameworkRoot(JObject framework);
}
internal class Microsoft.DotNet.ProjectModel.RuntimeGraphCollector : object {
    private static string RuntimeJsonFileName;
    public static RuntimeGraph Collect(IEnumerable`1<LibraryDescription> libraries);
}
public class Microsoft.DotNet.ProjectModel.RuntimeOptions : object {
    [CompilerGeneratedAttribute]
private bool <GcServer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GcConcurrent>k__BackingField;
    public bool GcServer { get; public set; }
    public bool GcConcurrent { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_GcServer();
    [CompilerGeneratedAttribute]
public void set_GcServer(bool value);
    [CompilerGeneratedAttribute]
public bool get_GcConcurrent();
    [CompilerGeneratedAttribute]
public void set_GcConcurrent(bool value);
}
public class Microsoft.DotNet.ProjectModel.RuntimeOutputFiles : CompilationOutputFiles {
    private string _runtimeIdentifier;
    public string Executable { get; }
    public string DepsJson { get; }
    public string RuntimeConfigJson { get; }
    public string Config { get; }
    public RuntimeOutputFiles(string basePath, Project project, string configuration, NuGetFramework framework, string runtimeIdentifier);
    public string get_Executable();
    public string get_DepsJson();
    public string get_RuntimeConfigJson();
    public string get_Config();
    [IteratorStateMachineAttribute("Microsoft.DotNet.ProjectModel.RuntimeOutputFiles/<All>d__10")]
public virtual IEnumerable`1<string> All();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<string> <>n__0();
}
public class Microsoft.DotNet.ProjectModel.TargetFrameworkInformation : object {
    [CompilerGeneratedAttribute]
private NuGetFramework <FrameworkName>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<LibraryRange> <Dependencies>k__BackingField;
    [CompilerGeneratedAttribute]
private CommonCompilerOptions <CompilerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Line>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Column>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WrappedProject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyPath>k__BackingField;
    public NuGetFramework FrameworkName { get; public set; }
    public IReadOnlyList`1<LibraryRange> Dependencies { get; public set; }
    public CommonCompilerOptions CompilerOptions { get; public set; }
    public int Line { get; public set; }
    public int Column { get; public set; }
    public string WrappedProject { get; public set; }
    public string AssemblyPath { get; public set; }
    [CompilerGeneratedAttribute]
public NuGetFramework get_FrameworkName();
    [CompilerGeneratedAttribute]
public void set_FrameworkName(NuGetFramework value);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<LibraryRange> get_Dependencies();
    [CompilerGeneratedAttribute]
public void set_Dependencies(IReadOnlyList`1<LibraryRange> value);
    [CompilerGeneratedAttribute]
public CommonCompilerOptions get_CompilerOptions();
    [CompilerGeneratedAttribute]
public void set_CompilerOptions(CommonCompilerOptions value);
    [CompilerGeneratedAttribute]
public int get_Line();
    [CompilerGeneratedAttribute]
public void set_Line(int value);
    [CompilerGeneratedAttribute]
public int get_Column();
    [CompilerGeneratedAttribute]
public void set_Column(int value);
    [CompilerGeneratedAttribute]
public string get_WrappedProject();
    [CompilerGeneratedAttribute]
public void set_WrappedProject(string value);
    [CompilerGeneratedAttribute]
public string get_AssemblyPath();
    [CompilerGeneratedAttribute]
public void set_AssemblyPath(string value);
}
public abstract class Microsoft.DotNet.ProjectModel.TargetLibraryWithAssets : LibraryDescription {
    [CompilerGeneratedAttribute]
private LockFileTargetLibrary <TargetLibrary>k__BackingField;
    private LockFileTargetLibrary TargetLibrary { get; }
    public IEnumerable`1<LockFileItem> RuntimeAssemblies { get; }
    public IEnumerable`1<LockFileItem> CompileTimeAssemblies { get; }
    public IEnumerable`1<LockFileItem> ResourceAssemblies { get; }
    public IEnumerable`1<LockFileItem> NativeLibraries { get; }
    public IEnumerable`1<LockFileContentFile> ContentFiles { get; }
    public IEnumerable`1<LockFileRuntimeTarget> RuntimeTargets { get; }
    public TargetLibraryWithAssets(LibraryIdentity libraryIdentity, string sha512, string path, LockFileTargetLibrary lockFileLibrary, IEnumerable`1<LibraryRange> dependencies, bool compatible, bool resolved, NuGetFramework framework);
    [CompilerGeneratedAttribute]
private LockFileTargetLibrary get_TargetLibrary();
    public virtual IEnumerable`1<LockFileItem> get_RuntimeAssemblies();
    public virtual IEnumerable`1<LockFileItem> get_CompileTimeAssemblies();
    public virtual IEnumerable`1<LockFileItem> get_ResourceAssemblies();
    public virtual IEnumerable`1<LockFileItem> get_NativeLibraries();
    public virtual IEnumerable`1<LockFileContentFile> get_ContentFiles();
    public virtual IEnumerable`1<LockFileRuntimeTarget> get_RuntimeTargets();
}
[ExtensionAttribute]
public static class Microsoft.DotNet.ProjectModel.Utilities.DictionaryExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<V> GetOrEmpty(IDictionary`2<K, IEnumerable`1<V>> self, K key);
    [ExtensionAttribute]
public static TValue GetOrAdd(IDictionary`2<TKey, TValue> dictionary, TKey key, Func`2<TKey, TValue> factory);
}
internal static class Microsoft.DotNet.ProjectModel.Utilities.PathUtility : object {
    public static bool IsChildOfDirectory(string dir, string candidate);
    public static string EnsureTrailingSlash(string path);
    public static string EnsureTrailingForwardSlash(string path);
    private static string EnsureTrailingCharacter(string path, char trailingCharacter);
    public static void EnsureParentDirectory(string filePath);
    public static string GetRelativePath(string path1, string path2);
    public static string GetRelativePathIgnoringDirectoryTraversals(string path1, string path2);
    public static string GetRelativePath(string path1, string path2, char separator, bool includeDirectoryTraversals);
    public static string GetAbsolutePath(string basePath, string relativePath);
    public static string GetDirectoryName(string path);
    public static string GetPathWithForwardSlashes(string path);
    public static string GetPathWithBackSlashes(string path);
    public static string GetPathWithDirectorySeparator(string path);
}
public class Microsoft.DotNet.ProjectModel.Utilities.ResilientFileStreamOpener : object {
    public static FileStream OpenFile(string filepath);
    public static FileStream OpenFile(string filepath, int retry);
}
public static class Microsoft.DotNet.ProjectModel.Utilities.VersionUtility : object {
    public static string DnxCoreFrameworkIdentifier;
    public static string DnxFrameworkIdentifier;
    public static string NetPlatformFrameworkIdentifier;
    public static string NetFrameworkIdentifier;
    private static VersionUtility();
    internal static NuGetVersion GetAssemblyVersion(string path);
    public static string RenderVersion(VersionRange range);
}
public abstract class Microsoft.DotNet.ProjectModel.Workspace : object {
    private ConcurrentDictionary`2<string, FileModelEntry`1<Project>> _projectsCache;
    private ConcurrentDictionary`2<string, FileModelEntry`1<LockFile>> _lockFileCache;
    private ConcurrentDictionary`2<string, ProjectContextCollection> _projectContextsCache;
    private ProjectReaderSettings _settings;
    private LockFileReader _lockFileReader;
    private bool _designTime;
    protected Workspace(ProjectReaderSettings settings, bool designTime);
    public ProjectContext GetProjectContext(string projectPath, NuGetFramework framework);
    public ProjectContextCollection GetProjectContextCollection(string projectPath);
    public Project GetProject(string projectDirectory);
    private LockFile GetLockFile(string projectDirectory);
    private FileModelEntry`1<Project> GetProjectCore(string projectDirectory);
    private FileModelEntry`1<Project> AddProjectEntry(string projectDirectory, FileModelEntry`1<Project> currentEntry);
    private FileModelEntry`1<LockFile> AddLockFileEntry(string projectDirectory, FileModelEntry`1<LockFile> currentEntry);
    private ProjectContextCollection AddProjectContextEntry(string projectDirectory, ProjectContextCollection currentEntry);
    protected abstract virtual IEnumerable`1<ProjectContext> BuildProjectContexts(Project project);
    protected ProjectContextBuilder CreateBaseProjectBuilder();
    protected ProjectContextBuilder CreateBaseProjectBuilder(Project root);
    [CompilerGeneratedAttribute]
private ProjectContextCollection <GetProjectContextCollection>b__8_0(string key);
    [CompilerGeneratedAttribute]
private ProjectContextCollection <GetProjectContextCollection>b__8_1(string key, ProjectContextCollection oldEntry);
    [CompilerGeneratedAttribute]
private FileModelEntry`1<LockFile> <GetLockFile>b__10_0(string key);
    [CompilerGeneratedAttribute]
private FileModelEntry`1<LockFile> <GetLockFile>b__10_1(string key, FileModelEntry`1<LockFile> oldEntry);
    [CompilerGeneratedAttribute]
private FileModelEntry`1<Project> <GetProjectCore>b__11_0(string key);
    [CompilerGeneratedAttribute]
private FileModelEntry`1<Project> <GetProjectCore>b__11_1(string key, FileModelEntry`1<Project> oldEntry);
    [CompilerGeneratedAttribute]
private Project <CreateBaseProjectBuilder>b__16_0(string path);
    [CompilerGeneratedAttribute]
private LockFile <CreateBaseProjectBuilder>b__16_1(string path);
}
public class Microsoft.DotNet.Tools.Compiler.PPFilePreprocessor : object {
    public static void Preprocess(Stream input, Stream output, IDictionary`2<string, string> parameters);
    private static string ReplaceToken(string name, IDictionary`2<string, string> parameters);
}
public class Microsoft.DotNet.Tools.Compiler.PPFileTokenizer : object {
    private string _text;
    private int _index;
    public PPFileTokenizer(string text);
    public Token Read();
    private static bool IsWordChar(char ch);
    private Token ParseTokenAfterDollarSign();
    private Token ParseText();
}
public class Microsoft.Extensions.DependencyModel.DependencyContextBuilder : object {
    private string _referenceAssembliesPath;
    public DependencyContextBuilder(string referenceAssembliesPath);
    public DependencyContext Build(CommonCompilerOptions compilerOptions, IEnumerable`1<LibraryExport> compilationExports, IEnumerable`1<LibraryExport> runtimeExports, bool portable, NuGetFramework target, string runtime);
    private static string GenerateRuntimeSignature(IEnumerable`1<LibraryExport> runtimeExports);
    private static CompilationOptions GetCompilationOptions(CommonCompilerOptions compilerOptions);
    private IEnumerable`1<Library> GetLibraries(IEnumerable`1<LibraryExport> exports, IDictionary`2<string, Dependency> dependencyLookup, bool runtime);
    private Library GetLibrary(LibraryExport export, bool runtime, IDictionary`2<string, Dependency> dependencyLookup);
    private RuntimeAssetGroup CreateRuntimeAssetGroup(LibraryAssetGroup libraryAssetGroup);
    private ResourceAssembly CreateResourceAssembly(LibraryResourceAssembly resourceAssembly);
    [IteratorStateMachineAttribute("Microsoft.Extensions.DependencyModel.DependencyContextBuilder/<ResolveReferenceAssembliesPath>d__10")]
private IEnumerable`1<string> ResolveReferenceAssembliesPath(IEnumerable`1<LibraryAsset> libraryAssets);
}
[ExtensionAttribute]
public static class NuGet.Frameworks.FrameworksExtensions : object {
    [ExtensionAttribute]
public static string GetTwoDigitShortFolderName(NuGetFramework self);
    [ExtensionAttribute]
public static string GetFrameworkString(NuGetFramework self);
}
[ExtensionAttribute]
public static class System.Collections.Generic.CollectionExtensions : object {
    [ExtensionAttribute]
public static LibraryAssetGroup GetDefaultGroup(IEnumerable`1<LibraryAssetGroup> self);
    [ExtensionAttribute]
public static LibraryAssetGroup GetRuntimeGroup(IEnumerable`1<LibraryAssetGroup> self, string runtime);
    private static LibraryAssetGroup GetGroup(IEnumerable`1<LibraryAssetGroup> groups, string runtime);
    [ExtensionAttribute]
public static IEnumerable`1<LibraryAsset> GetDefaultAssets(IEnumerable`1<LibraryAssetGroup> self);
    [ExtensionAttribute]
public static IEnumerable`1<LibraryAsset> GetRuntimeAssets(IEnumerable`1<LibraryAssetGroup> self, string runtime);
    private static IEnumerable`1<LibraryAsset> GetAssets(IEnumerable`1<LibraryAssetGroup> self, string runtime);
}
