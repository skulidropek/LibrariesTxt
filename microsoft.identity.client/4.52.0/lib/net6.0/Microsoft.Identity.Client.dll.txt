[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public enum Microsoft.Identity.Client.AadAuthorityAudience : Enum {
    public int value__;
    public static AadAuthorityAudience None;
    public static AadAuthorityAudience AzureAdMyOrg;
    public static AadAuthorityAudience AzureAdAndPersonalMicrosoftAccount;
    public static AadAuthorityAudience AzureAdMultipleOrgs;
    public static AadAuthorityAudience PersonalMicrosoftAccount;
}
public abstract class Microsoft.Identity.Client.AbstractAcquireTokenParameterBuilder`1 : BaseAbstractAcquireTokenParameterBuilder`1<T> {
    internal AbstractAcquireTokenParameterBuilder`1(IServiceBundle serviceBundle);
    protected T WithScopes(IEnumerable`1<string> scopes);
    public T WithExtraQueryParameters(Dictionary`2<string, string> extraQueryParameters);
    public T WithClaims(string claims);
    public T WithExtraQueryParameters(string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(string authorityUri, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    [EditorBrowsableAttribute("1")]
public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithTenantId(string tenantId);
    public T WithTenantIdFromAuthority(Uri authorityUri);
    public T WithAdfsAuthority(string authorityUri, bool validateAuthority);
    public T WithB2CAuthority(string authorityUri);
    internal T WithAuthenticationScheme(IAuthenticationScheme scheme);
}
public abstract class Microsoft.Identity.Client.AbstractApplicationBuilder`1 : BaseAbstractApplicationBuilder`1<T> {
    internal AbstractApplicationBuilder`1(ApplicationConfiguration configuration);
    [ObsoleteAttribute("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", "False")]
[EditorBrowsableAttribute("1")]
public T WithInstanceDicoveryMetadata(string instanceDiscoveryJson);
    public T WithInstanceDiscoveryMetadata(string instanceDiscoveryJson);
    [ObsoleteAttribute("This method name has a typo, please use WithInstanceDiscoveryMetadata instead", "False")]
[EditorBrowsableAttribute("1")]
public T WithInstanceDicoveryMetadata(Uri instanceDiscoveryUri);
    public T WithInstanceDiscoveryMetadata(Uri instanceDiscoveryUri);
    internal T WithPlatformProxy(IPlatformProxy platformProxy);
    internal T WithUserTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    public T WithLegacyCacheCompatibility(bool enableLegacyCacheCompatibility);
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
internal T WithTelemetry(TelemetryCallback telemetryCallback);
    public T WithClientId(string clientId);
    public T WithRedirectUri(string redirectUri);
    public T WithTenantId(string tenantId);
    public T WithClientName(string clientName);
    public T WithClientVersion(string clientVersion);
    protected T WithOptions(ApplicationOptions applicationOptions);
    public T WithExtraQueryParameters(IDictionary`2<string, string> extraQueryParameters);
    public T WithExtraQueryParameters(string extraQueryParameters);
    public T WithClientCapabilities(IEnumerable`1<string> clientCapabilities);
    public T WithInstanceDiscovery(bool enableInstanceDiscovery);
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public T WithTelemetry(ITelemetryConfig telemetryConfig);
    internal virtual void Validate();
    internal virtual ApplicationConfiguration BuildConfiguration();
    public T WithAuthority(Uri authorityUri, bool validateAuthority);
    public T WithAuthority(string authorityUri, bool validateAuthority);
    public T WithAuthority(string cloudInstanceUri, Guid tenantId, bool validateAuthority);
    public T WithAuthority(string cloudInstanceUri, string tenant, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    public T WithAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    public T WithAdfsAuthority(string authorityUri, bool validateAuthority);
    public T WithB2CAuthority(string authorityUri);
    private static string GetValueIfNotEmpty(string original, string value);
}
public abstract class Microsoft.Identity.Client.AbstractClientAppBaseAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IClientApplicationBaseExecutor <ClientApplicationBaseExecutor>k__BackingField;
    internal IClientApplicationBaseExecutor ClientApplicationBaseExecutor { get; }
    internal AbstractClientAppBaseAcquireTokenParameterBuilder`1(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
internal IClientApplicationBaseExecutor get_ClientApplicationBaseExecutor();
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
public abstract class Microsoft.Identity.Client.AbstractConfidentialClientAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IConfidentialClientApplicationExecutor <ConfidentialClientApplicationExecutor>k__BackingField;
    internal IConfidentialClientApplicationExecutor ConfidentialClientApplicationExecutor { get; }
    internal AbstractConfidentialClientAcquireTokenParameterBuilder`1(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    [CompilerGeneratedAttribute]
internal IConfidentialClientApplicationExecutor get_ConfidentialClientApplicationExecutor();
    public T WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration);
}
public abstract class Microsoft.Identity.Client.AbstractManagedIdentityAcquireTokenParameterBuilder`1 : BaseAbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IManagedIdentityApplicationExecutor <ManagedIdentityApplicationExecutor>k__BackingField;
    internal IManagedIdentityApplicationExecutor ManagedIdentityApplicationExecutor { get; }
    internal AbstractManagedIdentityAcquireTokenParameterBuilder`1(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor);
    [CompilerGeneratedAttribute]
internal IManagedIdentityApplicationExecutor get_ManagedIdentityApplicationExecutor();
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
public abstract class Microsoft.Identity.Client.AbstractPublicClientAcquireTokenParameterBuilder`1 : AbstractAcquireTokenParameterBuilder`1<T> {
    [CompilerGeneratedAttribute]
private IPublicClientApplicationExecutor <PublicClientApplicationExecutor>k__BackingField;
    internal IPublicClientApplicationExecutor PublicClientApplicationExecutor { get; }
    internal AbstractPublicClientAcquireTokenParameterBuilder`1(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    internal abstract virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
internal IPublicClientApplicationExecutor get_PublicClientApplicationExecutor();
}
internal class Microsoft.Identity.Client.Account : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private AccountId <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TenantProfile> <TenantProfiles>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <WamAccountIds>k__BackingField;
    public string Username { get; }
    public string Environment { get; }
    public AccountId HomeAccountId { get; }
    public IEnumerable`1<TenantProfile> TenantProfiles { get; }
    internal IDictionary`2<string, string> WamAccountIds { get; }
    public Account(string homeAccountId, string username, string environment, IDictionary`2<string, string> wamAccountIds, IEnumerable`1<TenantProfile> tenantProfiles);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Username();
    [CompilerGeneratedAttribute]
public sealed virtual string get_Environment();
    [CompilerGeneratedAttribute]
public sealed virtual AccountId get_HomeAccountId();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TenantProfile> get_TenantProfiles();
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_WamAccountIds();
    public virtual string ToString();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.AccountExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<TenantProfile> GetTenantProfiles(IAccount account);
}
public class Microsoft.Identity.Client.AccountId : object {
    [CompilerGeneratedAttribute]
private string <Identifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    public string Identifier { get; }
    public string ObjectId { get; }
    public string TenantId { get; }
    public AccountId(string identifier, string objectId, string tenantId);
    public AccountId(string adfsIdentifier);
    [CompilerGeneratedAttribute]
public string get_Identifier();
    [CompilerGeneratedAttribute]
public string get_ObjectId();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    internal static AccountId ParseFromString(string str);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public virtual string ToString();
    [ConditionalAttribute("DEBUG")]
private void ValidateId();
}
public class Microsoft.Identity.Client.AcquireTokenByAuthorizationCodeParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenByAuthorizationCodeParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByAuthorizationCodeParameters <Parameters>k__BackingField;
    private AcquireTokenByAuthorizationCodeParameters Parameters { get; }
    internal AcquireTokenByAuthorizationCodeParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByAuthorizationCodeParameters get_Parameters();
    internal static AcquireTokenByAuthorizationCodeParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, string authorizationCode);
    private AcquireTokenByAuthorizationCodeParameterBuilder WithAuthorizationCode(string authorizationCode);
    internal virtual ApiIds CalculateApiEventId();
    protected virtual void Validate();
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithSendX5C(bool withSendX5C);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithPkceCodeVerifier(string pkceCodeVerifier);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithCcsRoutingHint(string userName);
    public AcquireTokenByAuthorizationCodeParameterBuilder WithSpaAuthorizationCode(bool requestSpaAuthorizationCode);
}
public class Microsoft.Identity.Client.AcquireTokenByIntegratedWindowsAuthParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenByIntegratedWindowsAuthParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByIntegratedWindowsAuthParameters <Parameters>k__BackingField;
    private AcquireTokenByIntegratedWindowsAuthParameters Parameters { get; }
    internal AcquireTokenByIntegratedWindowsAuthParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByIntegratedWindowsAuthParameters get_Parameters();
    internal static AcquireTokenByIntegratedWindowsAuthParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes);
    public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithUsername(string username);
    public AcquireTokenByIntegratedWindowsAuthParameterBuilder WithFederationMetadata(string federationMetadata);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenByRefreshTokenParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder`1<AcquireTokenByRefreshTokenParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByRefreshTokenParameters <Parameters>k__BackingField;
    private AcquireTokenByRefreshTokenParameters Parameters { get; }
    internal AcquireTokenByRefreshTokenParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByRefreshTokenParameters get_Parameters();
    internal static AcquireTokenByRefreshTokenParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, string refreshToken);
    internal AcquireTokenByRefreshTokenParameterBuilder WithRefreshToken(string refreshToken);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
    public AcquireTokenByRefreshTokenParameterBuilder WithSendX5C(bool withSendX5C);
}
public class Microsoft.Identity.Client.AcquireTokenByUsernamePasswordParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenByUsernamePasswordParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters <Parameters>k__BackingField;
    private AcquireTokenByUsernamePasswordParameters Parameters { get; }
    internal AcquireTokenByUsernamePasswordParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenByUsernamePasswordParameters get_Parameters();
    internal static AcquireTokenByUsernamePasswordParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes, string username, string password);
    public AcquireTokenByUsernamePasswordParameterBuilder WithFederationMetadata(string federationMetadata);
    public AcquireTokenByUsernamePasswordParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
    private AcquireTokenByUsernamePasswordParameterBuilder WithUsername(string username);
    private AcquireTokenByUsernamePasswordParameterBuilder WithPassword(string password);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenForClientParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenForClientParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenForClientParameters <Parameters>k__BackingField;
    private AcquireTokenForClientParameters Parameters { get; }
    internal AcquireTokenForClientParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenForClientParameters get_Parameters();
    internal static AcquireTokenForClientParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes);
    public AcquireTokenForClientParameterBuilder WithForceRefresh(bool forceRefresh);
    public AcquireTokenForClientParameterBuilder WithSendX5C(bool withSendX5C);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", "True")]
public AcquireTokenForClientParameterBuilder WithAzureRegion(bool useAzureRegion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithAzureRegion on the ConfidentialClientApplicationBuilder object", "True")]
public AcquireTokenForClientParameterBuilder WithPreferredAzureRegion(bool useAzureRegion, string regionUsedIfAutoDetectFails, bool fallbackToGlobal);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenForManagedIdentityParameterBuilder : AbstractManagedIdentityAcquireTokenParameterBuilder`1<AcquireTokenForManagedIdentityParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenForManagedIdentityParameters <Parameters>k__BackingField;
    private AcquireTokenForManagedIdentityParameters Parameters { get; }
    internal AcquireTokenForManagedIdentityParameterBuilder(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenForManagedIdentityParameters get_Parameters();
    internal static AcquireTokenForManagedIdentityParameterBuilder Create(IManagedIdentityApplicationExecutor managedIdentityApplicationExecutor, string resource);
    private AcquireTokenForManagedIdentityParameterBuilder WithResource(string resource);
    public AcquireTokenForManagedIdentityParameterBuilder WithForceRefresh(bool forceRefresh);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenInteractiveParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenInteractiveParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenInteractiveParameters <Parameters>k__BackingField;
    private AcquireTokenInteractiveParameters Parameters { get; }
    internal AcquireTokenInteractiveParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenInteractiveParameters get_Parameters();
    internal void SetCustomWebUi(ICustomWebUi customWebUi);
    internal static AcquireTokenInteractiveParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes);
    internal AcquireTokenInteractiveParameterBuilder WithCurrentSynchronizationContext();
    internal AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindowFunc(Func`1<object> parentActivityOrWindowFunc);
    public AcquireTokenInteractiveParameterBuilder WithUseEmbeddedWebView(bool useEmbeddedWebView);
    public AcquireTokenInteractiveParameterBuilder WithSystemWebViewOptions(SystemWebViewOptions options);
    public AcquireTokenInteractiveParameterBuilder WithEmbeddedWebViewOptions(EmbeddedWebViewOptions options);
    public AcquireTokenInteractiveParameterBuilder WithLoginHint(string loginHint);
    public AcquireTokenInteractiveParameterBuilder WithAccount(IAccount account);
    public AcquireTokenInteractiveParameterBuilder WithExtraScopesToConsent(IEnumerable`1<string> extraScopesToConsent);
    public AcquireTokenInteractiveParameterBuilder WithPrompt(Prompt prompt);
    [EditorBrowsableAttribute("1")]
public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(object parent);
    private AcquireTokenInteractiveParameterBuilder WithParentObject(object parent);
    [CLSCompliantAttribute("False")]
public AcquireTokenInteractiveParameterBuilder WithParentActivityOrWindow(IntPtr window);
    public AcquireTokenInteractiveParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
    protected virtual void Validate();
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenOnBehalfOfParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<AcquireTokenOnBehalfOfParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenOnBehalfOfParameters <Parameters>k__BackingField;
    private AcquireTokenOnBehalfOfParameters Parameters { get; }
    internal AcquireTokenOnBehalfOfParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenOnBehalfOfParameters get_Parameters();
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, UserAssertion userAssertion);
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, UserAssertion userAssertion, string cacheKey);
    internal static AcquireTokenOnBehalfOfParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes, string cacheKey);
    private AcquireTokenOnBehalfOfParameterBuilder WithUserAssertion(UserAssertion userAssertion);
    private AcquireTokenOnBehalfOfParameterBuilder WithCacheKey(string cacheKey);
    public AcquireTokenOnBehalfOfParameterBuilder WithSendX5C(bool withSendX5C);
    public AcquireTokenOnBehalfOfParameterBuilder WithForceRefresh(bool forceRefresh);
    public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public AcquireTokenOnBehalfOfParameterBuilder WithCcsRoutingHint(string userName);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
}
public class Microsoft.Identity.Client.AcquireTokenSilentParameterBuilder : AbstractClientAppBaseAcquireTokenParameterBuilder`1<AcquireTokenSilentParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenSilentParameters <Parameters>k__BackingField;
    private AcquireTokenSilentParameters Parameters { get; }
    internal AcquireTokenSilentParameterBuilder(IClientApplicationBaseExecutor clientApplicationBaseExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenSilentParameters get_Parameters();
    internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, IAccount account);
    internal static AcquireTokenSilentParameterBuilder Create(IClientApplicationBaseExecutor clientApplicationBaseExecutor, IEnumerable`1<string> scopes, string loginHint);
    private AcquireTokenSilentParameterBuilder WithAccount(IAccount account);
    private AcquireTokenSilentParameterBuilder WithLoginHint(string loginHint);
    public AcquireTokenSilentParameterBuilder WithForceRefresh(bool forceRefresh);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    protected virtual void Validate();
    internal virtual ApiIds CalculateApiEventId();
    public AcquireTokenSilentParameterBuilder WithSendX5C(bool withSendX5C);
    public AcquireTokenSilentParameterBuilder WithProofOfPossession(PoPAuthenticationConfiguration popAuthenticationConfiguration);
    public AcquireTokenSilentParameterBuilder WithProofOfPossession(string nonce, HttpMethod httpMethod, Uri requestUri);
}
public class Microsoft.Identity.Client.AcquireTokenWithDeviceCodeParameterBuilder : AbstractPublicClientAcquireTokenParameterBuilder`1<AcquireTokenWithDeviceCodeParameterBuilder> {
    [CompilerGeneratedAttribute]
private AcquireTokenWithDeviceCodeParameters <Parameters>k__BackingField;
    private AcquireTokenWithDeviceCodeParameters Parameters { get; }
    internal AcquireTokenWithDeviceCodeParameterBuilder(IPublicClientApplicationExecutor publicClientApplicationExecutor);
    [CompilerGeneratedAttribute]
private AcquireTokenWithDeviceCodeParameters get_Parameters();
    internal static AcquireTokenWithDeviceCodeParameterBuilder Create(IPublicClientApplicationExecutor publicClientApplicationExecutor, IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    public AcquireTokenWithDeviceCodeParameterBuilder WithDeviceCodeResultCallback(Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    internal virtual ApiIds CalculateApiEventId();
    protected virtual void Validate();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Advanced.AcquireTokenParameterBuilderExtensions : object {
    [ExtensionAttribute]
public static T WithExtraHttpHeaders(AbstractAcquireTokenParameterBuilder`1<T> builder, IDictionary`2<string, string> extraHttpHeaders);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Executors.AbstractExecutor : object {
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    public IServiceBundle ServiceBundle { get; }
    protected AbstractExecutor(IServiceBundle serviceBundle);
    [CompilerGeneratedAttribute]
public sealed virtual IServiceBundle get_ServiceBundle();
    protected RequestContext CreateRequestContextAndLogVersionInfo(Guid correlationId, CancellationToken userCancellationToken);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor : AbstractExecutor {
    private ClientApplicationBase _clientApplicationBase;
    public ClientApplicationBaseExecutor(IServiceBundle serviceBundle, ClientApplicationBase clientApplicationBase);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ClientApplicationBaseExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters, CancellationToken cancellationToken);
}
internal static class Microsoft.Identity.Client.ApiConfig.Executors.ClientExecutorFactory : object {
    public static IPublicClientApplicationExecutor CreatePublicClientExecutor(PublicClientApplication publicClientApplication);
    public static IConfidentialClientApplicationExecutor CreateConfidentialClientExecutor(ConfidentialClientApplication confidentialClientApplication);
    public static IManagedIdentityApplicationExecutor CreateManagedIdentityExecutor(ManagedIdentityApplication managedIdentityApplication);
    public static IClientApplicationBaseExecutor CreateClientApplicationBaseExecutor(ClientApplicationBase clientApplicationBase);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor : AbstractExecutor {
    private ConfidentialClientApplication _confidentialClientApplication;
    public ConfidentialClientExecutor(IServiceBundle serviceBundle, ConfidentialClientApplication confidentialClientApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__4")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ConfidentialClientExecutor/<ExecuteAsync>d__5")]
public sealed virtual Task`1<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IClientApplicationBaseExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenSilentParameters silentParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByRefreshTokenParameters byRefreshTokenParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IConfidentialClientApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForClientParameters clientParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> ExecuteAsync(AcquireTokenCommonParameters commonParameters, GetAuthorizationRequestUrlParameters authorizationRequestUrlParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IManagedIdentityApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken);
}
internal interface Microsoft.Identity.Client.ApiConfig.Executors.IPublicClientApplicationExecutor {
    public IServiceBundle ServiceBundle { get; }
    public abstract virtual IServiceBundle get_ServiceBundle();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters withDeviceCodeParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken);
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.ManagedIdentityExecutor : AbstractExecutor {
    private ManagedIdentityApplication _managedIdentityApplication;
    public ManagedIdentityExecutor(IServiceBundle serviceBundle, ManagedIdentityApplication managedIdentityApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.ManagedIdentityExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor : AbstractExecutor {
    private PublicClientApplication _publicClientApplication;
    public PublicClientExecutor(IServiceBundle serviceBundle, PublicClientApplication publicClientApplication);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__2")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenInteractiveParameters interactiveParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__3")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__4")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApiConfig.Executors.PublicClientExecutor/<ExecuteAsync>d__5")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(AcquireTokenCommonParameters commonParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters, CancellationToken cancellationToken);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Parameters.AbstractAcquireTokenByUsernameParameters : object {
    [CompilerGeneratedAttribute]
private string <Username>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMetadata>k__BackingField;
    public string Username { get; public set; }
    public string FederationMetadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Username();
    [CompilerGeneratedAttribute]
public void set_Username(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMetadata();
    [CompilerGeneratedAttribute]
public void set_FederationMetadata(string value);
}
internal abstract class Microsoft.Identity.Client.ApiConfig.Parameters.AbstractAcquireTokenConfidentialClientParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SendX5C>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SpaCode>k__BackingField;
    public Nullable`1<bool> SendX5C { get; public set; }
    public bool SpaCode { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(Nullable`1<bool> value);
    [CompilerGeneratedAttribute]
public bool get_SpaCode();
    [CompilerGeneratedAttribute]
public void set_SpaCode(bool value);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByAuthorizationCodeParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private string <AuthorizationCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PkceCodeVerifier>k__BackingField;
    public string AuthorizationCode { get; public set; }
    public string PkceCodeVerifier { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AuthorizationCode();
    [CompilerGeneratedAttribute]
public void set_AuthorizationCode(string value);
    [CompilerGeneratedAttribute]
public string get_PkceCodeVerifier();
    [CompilerGeneratedAttribute]
public void set_PkceCodeVerifier(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByIntegratedWindowsAuthParameters : AbstractAcquireTokenByUsernameParameters {
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByRefreshTokenParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    public string RefreshToken { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenByUsernamePasswordParameters : AbstractAcquireTokenByUsernameParameters {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Password { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Password();
    [CompilerGeneratedAttribute]
public void set_Password(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenCommonParameters : object {
    [CompilerGeneratedAttribute]
private ApiIds <ApiId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <UserProvidedCorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCorrelationIdFromUser>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityInfo <AuthorityOverride>k__BackingField;
    [CompilerGeneratedAttribute]
private IAuthenticationScheme <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraHttpHeaders>k__BackingField;
    [CompilerGeneratedAttribute]
private PoPAuthenticationConfiguration <PopAuthenticationConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<OnBeforeTokenRequestData, Task> <OnBeforeTokenRequestHandler>k__BackingField;
    public ApiIds ApiId { get; public set; }
    public Guid CorrelationId { get; public set; }
    public Guid UserProvidedCorrelationId { get; public set; }
    public bool UseCorrelationIdFromUser { get; public set; }
    public IEnumerable`1<string> Scopes { get; public set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; public set; }
    public string Claims { get; public set; }
    public AuthorityInfo AuthorityOverride { get; public set; }
    public IAuthenticationScheme AuthenticationScheme { get; public set; }
    public IDictionary`2<string, string> ExtraHttpHeaders { get; public set; }
    public PoPAuthenticationConfiguration PopAuthenticationConfiguration { get; public set; }
    public Func`2<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler { get; internal set; }
    [CompilerGeneratedAttribute]
public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public void set_ApiId(ApiIds value);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public Guid get_UserProvidedCorrelationId();
    [CompilerGeneratedAttribute]
public void set_UserProvidedCorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_UseCorrelationIdFromUser();
    [CompilerGeneratedAttribute]
public void set_UseCorrelationIdFromUser(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
public void set_ExtraQueryParameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
    [CompilerGeneratedAttribute]
public AuthorityInfo get_AuthorityOverride();
    [CompilerGeneratedAttribute]
public void set_AuthorityOverride(AuthorityInfo value);
    [CompilerGeneratedAttribute]
public IAuthenticationScheme get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public void set_AuthenticationScheme(IAuthenticationScheme value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraHttpHeaders();
    [CompilerGeneratedAttribute]
public void set_ExtraHttpHeaders(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public PoPAuthenticationConfiguration get_PopAuthenticationConfiguration();
    [CompilerGeneratedAttribute]
public void set_PopAuthenticationConfiguration(PoPAuthenticationConfiguration value);
    [CompilerGeneratedAttribute]
public Func`2<OnBeforeTokenRequestData, Task> get_OnBeforeTokenRequestHandler();
    [CompilerGeneratedAttribute]
internal void set_OnBeforeTokenRequestHandler(Func`2<OnBeforeTokenRequestData, Task> value);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenForClientParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    public bool ForceRefresh { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenForManagedIdentityParameters : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public string Resource { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenInteractiveParameters : object {
    [CompilerGeneratedAttribute]
private Prompt <Prompt>k__BackingField;
    [CompilerGeneratedAttribute]
private CoreUIParent <UiParent>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtraScopesToConsent>k__BackingField;
    [CompilerGeneratedAttribute]
private WebViewPreference <UseEmbeddedWebView>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private ICustomWebUi <CustomWebUi>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeVerifier>k__BackingField;
    public Prompt Prompt { get; public set; }
    public CoreUIParent UiParent { get; }
    public IEnumerable`1<string> ExtraScopesToConsent { get; public set; }
    public WebViewPreference UseEmbeddedWebView { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public ICustomWebUi CustomWebUi { get; public set; }
    public string CodeVerifier { get; public set; }
    [CompilerGeneratedAttribute]
public Prompt get_Prompt();
    [CompilerGeneratedAttribute]
public void set_Prompt(Prompt value);
    [CompilerGeneratedAttribute]
public CoreUIParent get_UiParent();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExtraScopesToConsent();
    [CompilerGeneratedAttribute]
public void set_ExtraScopesToConsent(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public WebViewPreference get_UseEmbeddedWebView();
    [CompilerGeneratedAttribute]
public void set_UseEmbeddedWebView(WebViewPreference value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public ICustomWebUi get_CustomWebUi();
    [CompilerGeneratedAttribute]
public void set_CustomWebUi(ICustomWebUi value);
    [CompilerGeneratedAttribute]
public string get_CodeVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeVerifier(string value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenOnBehalfOfParameters : AbstractAcquireTokenConfidentialClientParameters {
    [CompilerGeneratedAttribute]
private UserAssertion <UserAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongRunningOboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    public UserAssertion UserAssertion { get; public set; }
    public string LongRunningOboCacheKey { get; public set; }
    public bool ForceRefresh { get; public set; }
    [CompilerGeneratedAttribute]
public UserAssertion get_UserAssertion();
    [CompilerGeneratedAttribute]
public void set_UserAssertion(UserAssertion value);
    [CompilerGeneratedAttribute]
public string get_LongRunningOboCacheKey();
    [CompilerGeneratedAttribute]
public void set_LongRunningOboCacheKey(string value);
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenSilentParameters : object {
    [CompilerGeneratedAttribute]
private bool <ForceRefresh>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<bool> <SendX5C>k__BackingField;
    public bool ForceRefresh { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public Nullable`1<bool> SendX5C { get; public set; }
    [CompilerGeneratedAttribute]
public bool get_ForceRefresh();
    [CompilerGeneratedAttribute]
public void set_ForceRefresh(bool value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public Nullable`1<bool> get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(Nullable`1<bool> value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.AcquireTokenWithDeviceCodeParameters : object {
    [CompilerGeneratedAttribute]
private Func`2<DeviceCodeResult, Task> <DeviceCodeResultCallback>k__BackingField;
    public Func`2<DeviceCodeResult, Task> DeviceCodeResultCallback { get; public set; }
    [CompilerGeneratedAttribute]
public Func`2<DeviceCodeResult, Task> get_DeviceCodeResultCallback();
    [CompilerGeneratedAttribute]
public void set_DeviceCodeResultCallback(Func`2<DeviceCodeResult, Task> value);
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.ApiConfig.Parameters.GetAuthorizationRequestUrlParameters : object {
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ExtraScopesToConsent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LoginHint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CodeVerifier>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyValuePair`2<string, string>> <CcsRoutingHint>k__BackingField;
    [CompilerGeneratedAttribute]
private Prompt <Prompt>k__BackingField;
    public string RedirectUri { get; public set; }
    public IAccount Account { get; public set; }
    public IEnumerable`1<string> ExtraScopesToConsent { get; public set; }
    public string LoginHint { get; public set; }
    public string CodeVerifier { get; public set; }
    public Nullable`1<KeyValuePair`2<string, string>> CcsRoutingHint { get; public set; }
    public Prompt Prompt { get; public set; }
    [CompilerGeneratedAttribute]
public string get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ExtraScopesToConsent();
    [CompilerGeneratedAttribute]
public void set_ExtraScopesToConsent(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_LoginHint();
    [CompilerGeneratedAttribute]
public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public string get_CodeVerifier();
    [CompilerGeneratedAttribute]
public void set_CodeVerifier(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyValuePair`2<string, string>> get_CcsRoutingHint();
    [CompilerGeneratedAttribute]
public void set_CcsRoutingHint(Nullable`1<KeyValuePair`2<string, string>> value);
    [CompilerGeneratedAttribute]
public Prompt get_Prompt();
    [CompilerGeneratedAttribute]
public void set_Prompt(Prompt value);
    public AcquireTokenInteractiveParameters ToInteractiveParameters();
    public sealed virtual void LogParameters(ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.ApiConfig.Parameters.IAcquireTokenParameters {
    public abstract virtual void LogParameters(ILoggerAdapter logger);
}
internal enum Microsoft.Identity.Client.ApiConfig.Parameters.WebViewPreference : Enum {
    public int value__;
    public static WebViewPreference NotSpecified;
    public static WebViewPreference Embedded;
    public static WebViewPreference System;
}
public class Microsoft.Identity.Client.AppConfig.PoPAuthenticationConfiguration : object {
    [CompilerGeneratedAttribute]
private HttpMethod <HttpMethod>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HttpPath>k__BackingField;
    [CompilerGeneratedAttribute]
private IPoPCryptoProvider <PopCryptoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SignHttpRequest>k__BackingField;
    public HttpMethod HttpMethod { get; public set; }
    public string HttpHost { get; public set; }
    public string HttpPath { get; public set; }
    public IPoPCryptoProvider PopCryptoProvider { get; public set; }
    public string Nonce { get; public set; }
    public bool SignHttpRequest { get; public set; }
    public PoPAuthenticationConfiguration(HttpRequestMessage httpRequestMessage);
    public PoPAuthenticationConfiguration(Uri requestUri);
    [CompilerGeneratedAttribute]
public HttpMethod get_HttpMethod();
    [CompilerGeneratedAttribute]
public void set_HttpMethod(HttpMethod value);
    [CompilerGeneratedAttribute]
public string get_HttpHost();
    [CompilerGeneratedAttribute]
public void set_HttpHost(string value);
    [CompilerGeneratedAttribute]
public string get_HttpPath();
    [CompilerGeneratedAttribute]
public void set_HttpPath(string value);
    [CompilerGeneratedAttribute]
public IPoPCryptoProvider get_PopCryptoProvider();
    [CompilerGeneratedAttribute]
public void set_PopCryptoProvider(IPoPCryptoProvider value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
public void set_Nonce(string value);
    [CompilerGeneratedAttribute]
public bool get_SignHttpRequest();
    [CompilerGeneratedAttribute]
public void set_SignHttpRequest(bool value);
}
public abstract class Microsoft.Identity.Client.ApplicationBase : object {
    internal static string DefaultAuthority;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    internal IServiceBundle ServiceBundle { get; }
    internal ApplicationBase(ApplicationConfiguration config);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ApplicationBase/<CreateRequestParametersAsync>d__5")]
internal virtual Task`1<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
    internal static void GuardMobileFrameworks();
}
internal class Microsoft.Identity.Client.ApplicationConfiguration : object {
    public static string DefaultClientName;
    public static string DefaultClientVersion;
    private string _clientName;
    private string _clientVersion;
    [CompilerGeneratedAttribute]
private ITelemetryClient[] <TelemetryClients>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<object> <ParentActivityOrWindowFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseCorporateNetwork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IosKeychainSecurityGroup>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsBrokerEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private WindowsBrokerOptions <UwpBrokerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private BrokerOptions <BrokerOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> <BrokerCreatorFunc>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`1<IWebUIFactory> <WebUiFactoryCreator>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosTicketContainer <TicketContainer>k__BackingField;
    [CompilerGeneratedAttribute]
private ITelemetryConfig <TelemetryConfig>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpManager <HttpManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformProxy <PlatformProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheOptions <AccessorOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Authority <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePiiLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IMsalHttpClientFactory <HttpClientFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedTokenLifetimeEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private LogCallback <LoggingCallback>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UseRecommendedDefaultRedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ExperimentalFeaturesEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendX5C>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyCacheCompatibilityEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheSynchronizationEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MultiCloudSupportEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RetryOnServerErrors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsUserAssignedManagedIdentity>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedIdentityUserAssignedClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ManagedIdentityUserAssignedResourceId>k__BackingField;
    public Func`2<AppTokenProviderParameters, Task`1<AppTokenProviderResult>> AppTokenProvider;
    [CompilerGeneratedAttribute]
private IClientCredential <ClientCredential>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceDiscoveryResponse <CustomInstanceDiscoveryMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <CustomInstanceDiscoveryMetadataUri>k__BackingField;
    [CompilerGeneratedAttribute]
private AadAuthorityAudience <AadAuthorityAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureCloudInstance <AzureCloudInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private ILegacyCachePersistence <UserTokenLegacyCachePersistenceForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <UserTokenCacheInternalForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternalForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeviceAuthManager <DeviceAuthManagerForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsConfidentialClient>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsInstanceDiscoveryEnabled>k__BackingField;
    public string ClientName { get; internal set; }
    public string ClientVersion { get; internal set; }
    public ITelemetryClient[] TelemetryClients { get; internal set; }
    public Func`1<object> ParentActivityOrWindowFunc { get; internal set; }
    public bool UseCorporateNetwork { get; internal set; }
    public string IosKeychainSecurityGroup { get; internal set; }
    public bool IsBrokerEnabled { get; internal set; }
    public WindowsBrokerOptions UwpBrokerOptions { get; public set; }
    public BrokerOptions BrokerOptions { get; public set; }
    public Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> BrokerCreatorFunc { get; public set; }
    public Func`1<IWebUIFactory> WebUiFactoryCreator { get; public set; }
    public string KerberosServicePrincipalName { get; public set; }
    public KerberosTicketContainer TicketContainer { get; public set; }
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.")]
[EditorBrowsableAttribute("1")]
public ITelemetryConfig TelemetryConfig { get; internal set; }
    public IHttpManager HttpManager { get; internal set; }
    public IPlatformProxy PlatformProxy { get; internal set; }
    public CacheOptions AccessorOptions { get; public set; }
    public Authority Authority { get; internal set; }
    public string ClientId { get; internal set; }
    public string RedirectUri { get; internal set; }
    public bool EnablePiiLogging { get; internal set; }
    public LogLevel LogLevel { get; internal set; }
    public bool IsDefaultPlatformLoggingEnabled { get; internal set; }
    public IMsalHttpClientFactory HttpClientFactory { get; internal set; }
    public bool IsExtendedTokenLifetimeEnabled { get; public set; }
    public LogCallback LoggingCallback { get; internal set; }
    public IIdentityLogger IdentityLogger { get; internal set; }
    public string Component { get; internal set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; internal set; }
    public bool UseRecommendedDefaultRedirectUri { get; internal set; }
    public bool ExperimentalFeaturesEnabled { get; public set; }
    public IEnumerable`1<string> ClientCapabilities { get; public set; }
    public bool SendX5C { get; internal set; }
    public bool LegacyCacheCompatibilityEnabled { get; internal set; }
    public bool CacheSynchronizationEnabled { get; internal set; }
    public bool MultiCloudSupportEnabled { get; public set; }
    public bool RetryOnServerErrors { get; public set; }
    public bool IsUserAssignedManagedIdentity { get; internal set; }
    public string ManagedIdentityUserAssignedClientId { get; internal set; }
    public string ManagedIdentityUserAssignedResourceId { get; internal set; }
    public IClientCredential ClientCredential { get; internal set; }
    public string ClientSecret { get; }
    public X509Certificate2 ClientCredentialCertificate { get; }
    public string AzureRegion { get; public set; }
    public string TenantId { get; internal set; }
    public InstanceDiscoveryResponse CustomInstanceDiscoveryMetadata { get; public set; }
    public Uri CustomInstanceDiscoveryMetadataUri { get; public set; }
    public AadAuthorityAudience AadAuthorityAudience { get; public set; }
    public AzureCloudInstance AzureCloudInstance { get; public set; }
    public string Instance { get; public set; }
    public bool ValidateAuthority { get; public set; }
    public ILegacyCachePersistence UserTokenLegacyCachePersistenceForTest { get; public set; }
    public ITokenCacheInternal UserTokenCacheInternalForTest { get; public set; }
    public ITokenCacheInternal AppTokenCacheInternalForTest { get; public set; }
    public IDeviceAuthManager DeviceAuthManagerForTest { get; public set; }
    public bool IsConfidentialClient { get; }
    public bool IsInstanceDiscoveryEnabled { get; internal set; }
    public ApplicationConfiguration(bool isConfidentialClient);
    public sealed virtual string get_ClientName();
    internal void set_ClientName(string value);
    public sealed virtual string get_ClientVersion();
    internal void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public ITelemetryClient[] get_TelemetryClients();
    [CompilerGeneratedAttribute]
internal void set_TelemetryClients(ITelemetryClient[] value);
    [CompilerGeneratedAttribute]
public sealed virtual Func`1<object> get_ParentActivityOrWindowFunc();
    [CompilerGeneratedAttribute]
internal void set_ParentActivityOrWindowFunc(Func`1<object> value);
    [CompilerGeneratedAttribute]
public bool get_UseCorporateNetwork();
    [CompilerGeneratedAttribute]
internal void set_UseCorporateNetwork(bool value);
    [CompilerGeneratedAttribute]
public string get_IosKeychainSecurityGroup();
    [CompilerGeneratedAttribute]
internal void set_IosKeychainSecurityGroup(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsBrokerEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsBrokerEnabled(bool value);
    [CompilerGeneratedAttribute]
public WindowsBrokerOptions get_UwpBrokerOptions();
    [CompilerGeneratedAttribute]
public void set_UwpBrokerOptions(WindowsBrokerOptions value);
    [CompilerGeneratedAttribute]
public BrokerOptions get_BrokerOptions();
    [CompilerGeneratedAttribute]
public void set_BrokerOptions(BrokerOptions value);
    [CompilerGeneratedAttribute]
public Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> get_BrokerCreatorFunc();
    [CompilerGeneratedAttribute]
public void set_BrokerCreatorFunc(Func`4<CoreUIParent, ApplicationConfiguration, ILoggerAdapter, IBroker> value);
    [CompilerGeneratedAttribute]
public Func`1<IWebUIFactory> get_WebUiFactoryCreator();
    [CompilerGeneratedAttribute]
public void set_WebUiFactoryCreator(Func`1<IWebUIFactory> value);
    [CompilerGeneratedAttribute]
public string get_KerberosServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_KerberosServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public KerberosTicketContainer get_TicketContainer();
    [CompilerGeneratedAttribute]
public void set_TicketContainer(KerberosTicketContainer value);
    [CompilerGeneratedAttribute]
public sealed virtual ITelemetryConfig get_TelemetryConfig();
    [CompilerGeneratedAttribute]
internal void set_TelemetryConfig(ITelemetryConfig value);
    [CompilerGeneratedAttribute]
public IHttpManager get_HttpManager();
    [CompilerGeneratedAttribute]
internal void set_HttpManager(IHttpManager value);
    [CompilerGeneratedAttribute]
public IPlatformProxy get_PlatformProxy();
    [CompilerGeneratedAttribute]
internal void set_PlatformProxy(IPlatformProxy value);
    [CompilerGeneratedAttribute]
public CacheOptions get_AccessorOptions();
    [CompilerGeneratedAttribute]
public void set_AccessorOptions(CacheOptions value);
    [CompilerGeneratedAttribute]
public Authority get_Authority();
    [CompilerGeneratedAttribute]
internal void set_Authority(Authority value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientId();
    [CompilerGeneratedAttribute]
internal void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RedirectUri();
    [CompilerGeneratedAttribute]
internal void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_EnablePiiLogging();
    [CompilerGeneratedAttribute]
internal void set_EnablePiiLogging(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
internal void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsDefaultPlatformLoggingEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IMsalHttpClientFactory get_HttpClientFactory();
    [CompilerGeneratedAttribute]
internal void set_HttpClientFactory(IMsalHttpClientFactory value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedTokenLifetimeEnabled();
    [CompilerGeneratedAttribute]
public void set_IsExtendedTokenLifetimeEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual LogCallback get_LoggingCallback();
    [CompilerGeneratedAttribute]
internal void set_LoggingCallback(LogCallback value);
    [CompilerGeneratedAttribute]
public IIdentityLogger get_IdentityLogger();
    [CompilerGeneratedAttribute]
internal void set_IdentityLogger(IIdentityLogger value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
internal void set_Component(string value);
    [CompilerGeneratedAttribute]
public sealed virtual IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
internal void set_ExtraQueryParameters(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public bool get_UseRecommendedDefaultRedirectUri();
    [CompilerGeneratedAttribute]
internal void set_UseRecommendedDefaultRedirectUri(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ExperimentalFeaturesEnabled();
    [CompilerGeneratedAttribute]
public void set_ExperimentalFeaturesEnabled(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual IEnumerable`1<string> get_ClientCapabilities();
    [CompilerGeneratedAttribute]
public void set_ClientCapabilities(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_SendX5C();
    [CompilerGeneratedAttribute]
internal void set_SendX5C(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_LegacyCacheCompatibilityEnabled();
    [CompilerGeneratedAttribute]
internal void set_LegacyCacheCompatibilityEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_CacheSynchronizationEnabled();
    [CompilerGeneratedAttribute]
internal void set_CacheSynchronizationEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_MultiCloudSupportEnabled();
    [CompilerGeneratedAttribute]
public void set_MultiCloudSupportEnabled(bool value);
    [CompilerGeneratedAttribute]
public bool get_RetryOnServerErrors();
    [CompilerGeneratedAttribute]
public void set_RetryOnServerErrors(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsUserAssignedManagedIdentity();
    [CompilerGeneratedAttribute]
internal void set_IsUserAssignedManagedIdentity(bool value);
    [CompilerGeneratedAttribute]
public string get_ManagedIdentityUserAssignedClientId();
    [CompilerGeneratedAttribute]
internal void set_ManagedIdentityUserAssignedClientId(string value);
    [CompilerGeneratedAttribute]
public string get_ManagedIdentityUserAssignedResourceId();
    [CompilerGeneratedAttribute]
internal void set_ManagedIdentityUserAssignedResourceId(string value);
    [CompilerGeneratedAttribute]
public IClientCredential get_ClientCredential();
    [CompilerGeneratedAttribute]
internal void set_ClientCredential(IClientCredential value);
    public sealed virtual string get_ClientSecret();
    public sealed virtual X509Certificate2 get_ClientCredentialCertificate();
    [CompilerGeneratedAttribute]
public string get_AzureRegion();
    [CompilerGeneratedAttribute]
public void set_AzureRegion(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public InstanceDiscoveryResponse get_CustomInstanceDiscoveryMetadata();
    [CompilerGeneratedAttribute]
public void set_CustomInstanceDiscoveryMetadata(InstanceDiscoveryResponse value);
    [CompilerGeneratedAttribute]
public Uri get_CustomInstanceDiscoveryMetadataUri();
    [CompilerGeneratedAttribute]
public void set_CustomInstanceDiscoveryMetadataUri(Uri value);
    [CompilerGeneratedAttribute]
public AadAuthorityAudience get_AadAuthorityAudience();
    [CompilerGeneratedAttribute]
public void set_AadAuthorityAudience(AadAuthorityAudience value);
    [CompilerGeneratedAttribute]
public AzureCloudInstance get_AzureCloudInstance();
    [CompilerGeneratedAttribute]
public void set_AzureCloudInstance(AzureCloudInstance value);
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAuthority();
    [CompilerGeneratedAttribute]
public void set_ValidateAuthority(bool value);
    [CompilerGeneratedAttribute]
public ILegacyCachePersistence get_UserTokenLegacyCachePersistenceForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenLegacyCachePersistenceForTest(ILegacyCachePersistence value);
    [CompilerGeneratedAttribute]
public ITokenCacheInternal get_UserTokenCacheInternalForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenCacheInternalForTest(ITokenCacheInternal value);
    [CompilerGeneratedAttribute]
public ITokenCacheInternal get_AppTokenCacheInternalForTest();
    [CompilerGeneratedAttribute]
public void set_AppTokenCacheInternalForTest(ITokenCacheInternal value);
    [CompilerGeneratedAttribute]
public IDeviceAuthManager get_DeviceAuthManagerForTest();
    [CompilerGeneratedAttribute]
public void set_DeviceAuthManagerForTest(IDeviceAuthManager value);
    [CompilerGeneratedAttribute]
public bool get_IsConfidentialClient();
    [CompilerGeneratedAttribute]
public bool get_IsInstanceDiscoveryEnabled();
    [CompilerGeneratedAttribute]
internal void set_IsInstanceDiscoveryEnabled(bool value);
}
public abstract class Microsoft.Identity.Client.ApplicationOptions : BaseApplicationOptions {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private AadAuthorityAudience <AadAuthorityAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
private AzureCloudInstance <AzureCloudInstance>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LegacyCacheCompatibilityEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosTicketContainer <TicketContainer>k__BackingField;
    public string ClientId { get; public set; }
    public string TenantId { get; public set; }
    public AadAuthorityAudience AadAuthorityAudience { get; public set; }
    public string Instance { get; public set; }
    public AzureCloudInstance AzureCloudInstance { get; public set; }
    public string RedirectUri { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Should use ClientName and ClientVersion properties instead of Component", "True")]
public string Component { get; public set; }
    public string ClientName { get; public set; }
    public string ClientVersion { get; public set; }
    public IEnumerable`1<string> ClientCapabilities { get; public set; }
    public bool LegacyCacheCompatibilityEnabled { get; public set; }
    public string KerberosServicePrincipalName { get; public set; }
    public KerberosTicketContainer TicketContainer { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public AadAuthorityAudience get_AadAuthorityAudience();
    [CompilerGeneratedAttribute]
public void set_AadAuthorityAudience(AadAuthorityAudience value);
    [CompilerGeneratedAttribute]
public string get_Instance();
    [CompilerGeneratedAttribute]
public void set_Instance(string value);
    [CompilerGeneratedAttribute]
public AzureCloudInstance get_AzureCloudInstance();
    [CompilerGeneratedAttribute]
public void set_AzureCloudInstance(AzureCloudInstance value);
    [CompilerGeneratedAttribute]
public string get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(string value);
    [CompilerGeneratedAttribute]
public string get_Component();
    [CompilerGeneratedAttribute]
public void set_Component(string value);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientVersion();
    [CompilerGeneratedAttribute]
public void set_ClientVersion(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ClientCapabilities();
    [CompilerGeneratedAttribute]
public void set_ClientCapabilities(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public bool get_LegacyCacheCompatibilityEnabled();
    [CompilerGeneratedAttribute]
public void set_LegacyCacheCompatibilityEnabled(bool value);
    [CompilerGeneratedAttribute]
public string get_KerberosServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_KerberosServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public KerberosTicketContainer get_TicketContainer();
    [CompilerGeneratedAttribute]
public void set_TicketContainer(KerberosTicketContainer value);
}
public class Microsoft.Identity.Client.AssertionRequestOptions : object {
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientID>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    public CancellationToken CancellationToken { get; internal set; }
    public string ClientID { get; internal set; }
    public string TokenEndpoint { get; internal set; }
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal void set_CancellationToken(CancellationToken value);
    [CompilerGeneratedAttribute]
public string get_ClientID();
    [CompilerGeneratedAttribute]
internal void set_ClientID(string value);
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
internal void set_TokenEndpoint(string value);
}
public class Microsoft.Identity.Client.AuthenticationHeaderParser : object {
    private static Lazy`1<IMsalHttpClientFactory> _httpClientFactory;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<WwwAuthenticateParameters> <WwwAuthenticateParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationInfoParameters <AuthenticationInfoParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PopNonce>k__BackingField;
    public IReadOnlyList`1<WwwAuthenticateParameters> WwwAuthenticateParameters { get; private set; }
    public AuthenticationInfoParameters AuthenticationInfoParameters { get; private set; }
    public string PopNonce { get; private set; }
    private static AuthenticationHeaderParser();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<WwwAuthenticateParameters> get_WwwAuthenticateParameters();
    [CompilerGeneratedAttribute]
private void set_WwwAuthenticateParameters(IReadOnlyList`1<WwwAuthenticateParameters> value);
    [CompilerGeneratedAttribute]
public AuthenticationInfoParameters get_AuthenticationInfoParameters();
    [CompilerGeneratedAttribute]
private void set_AuthenticationInfoParameters(AuthenticationInfoParameters value);
    [CompilerGeneratedAttribute]
public string get_PopNonce();
    [CompilerGeneratedAttribute]
private void set_PopNonce(string value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.AuthenticationHeaderParser/<ParseAuthenticationHeadersAsync>d__13")]
public static Task`1<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.AuthenticationHeaderParser/<ParseAuthenticationHeadersAsync>d__14")]
public static Task`1<AuthenticationHeaderParser> ParseAuthenticationHeadersAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken);
    public static AuthenticationHeaderParser ParseAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders);
    internal static HttpClient GetHttpClient();
    internal static KeyValuePair`2<string, string> CreateKeyValuePair(string paramValue, string authScheme);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Identity.Client.AuthenticationInfoParameters : object {
    private static string AuthenticationInfoKey;
    [CompilerGeneratedAttribute]
private string <NextNonce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RawParameters>k__BackingField;
    public string NextNonce { get; private set; }
    public string Item { get; }
    internal IDictionary`2<string, string> RawParameters { get; private set; }
    [CompilerGeneratedAttribute]
public string get_NextNonce();
    [CompilerGeneratedAttribute]
private void set_NextNonce(string value);
    public string get_Item(string key);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_RawParameters();
    [CompilerGeneratedAttribute]
private void set_RawParameters(IDictionary`2<string, string> value);
    public static AuthenticationInfoParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders);
}
public class Microsoft.Identity.Client.AuthenticationResult : object {
    private IAuthenticationScheme _authenticationScheme;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedLifeTimeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExtendedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdToken>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpaAuthCode>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyDictionary`2<string, string> <AdditionalResponseParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiEvent <ApiEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationResultMetadata <AuthenticationResultMetadata>k__BackingField;
    public string AccessToken { get; }
    [ObsoleteAttribute("This feature has been deprecated", "False")]
[EditorBrowsableAttribute("1")]
public bool IsExtendedLifeTimeToken { get; }
    public string UniqueId { get; }
    public DateTimeOffset ExpiresOn { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This feature has been deprecated", "False")]
public DateTimeOffset ExtendedExpiresOn { get; }
    public string TenantId { get; }
    public IAccount Account { get; }
    public string IdToken { get; }
    public IEnumerable`1<string> Scopes { get; }
    public Guid CorrelationId { get; }
    public string TokenType { get; }
    public string SpaAuthCode { get; }
    public IReadOnlyDictionary`2<string, string> AdditionalResponseParameters { get; }
    public ClaimsPrincipal ClaimsPrincipal { get; }
    internal ApiEvent ApiEvent { get; }
    public AuthenticationResultMetadata AuthenticationResultMetadata { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use Account instead (See https://aka.ms/msal-net-2-released)", "True")]
public IUser User { get; }
    public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable`1<string> scopes, Guid correlationId, string tokenType, AuthenticationResultMetadata authenticationResultMetadata, ClaimsPrincipal claimsPrincipal, string spaAuthCode, IReadOnlyDictionary`2<string, string> additionalResponseParameters);
    [EditorBrowsableAttribute("1")]
public AuthenticationResult(string accessToken, bool isExtendedLifeTimeToken, string uniqueId, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string tenantId, IAccount account, string idToken, IEnumerable`1<string> scopes, Guid correlationId, AuthenticationResultMetadata authenticationResultMetadata, string tokenType);
    internal AuthenticationResult(MsalAccessTokenCacheItem msalAccessTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, IAuthenticationScheme authenticationScheme, Guid correlationID, TokenSource tokenSource, ApiEvent apiEvent, Account account, string spaAuthCode, IReadOnlyDictionary`2<string, string> additionalResponseParameters);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public bool get_IsExtendedLifeTimeToken();
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExtendedExpiresOn();
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public string get_IdToken();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public string get_SpaAuthCode();
    [CompilerGeneratedAttribute]
public IReadOnlyDictionary`2<string, string> get_AdditionalResponseParameters();
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
internal ApiEvent get_ApiEvent();
    [CompilerGeneratedAttribute]
public AuthenticationResultMetadata get_AuthenticationResultMetadata();
    public string CreateAuthorizationHeader();
    public IUser get_User();
}
public class Microsoft.Identity.Client.AuthenticationResultMetadata : object {
    [CompilerGeneratedAttribute]
private TokenSource <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationTotalInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInCacheInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInHttpInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <RefreshOn>k__BackingField;
    [CompilerGeneratedAttribute]
private CacheRefreshReason <CacheRefreshReason>k__BackingField;
    [CompilerGeneratedAttribute]
private RegionDetails <RegionDetails>k__BackingField;
    public TokenSource TokenSource { get; }
    public string TokenEndpoint { get; public set; }
    public long DurationTotalInMs { get; public set; }
    public long DurationInCacheInMs { get; public set; }
    public long DurationInHttpInMs { get; public set; }
    public Nullable`1<DateTimeOffset> RefreshOn { get; public set; }
    public CacheRefreshReason CacheRefreshReason { get; public set; }
    public RegionDetails RegionDetails { get; public set; }
    public AuthenticationResultMetadata(TokenSource tokenSource);
    [CompilerGeneratedAttribute]
public TokenSource get_TokenSource();
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public long get_DurationTotalInMs();
    [CompilerGeneratedAttribute]
public void set_DurationTotalInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInCacheInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInCacheInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInHttpInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInHttpInMs(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_RefreshOn();
    [CompilerGeneratedAttribute]
public void set_RefreshOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public CacheRefreshReason get_CacheRefreshReason();
    [CompilerGeneratedAttribute]
public void set_CacheRefreshReason(CacheRefreshReason value);
    [CompilerGeneratedAttribute]
public RegionDetails get_RegionDetails();
    [CompilerGeneratedAttribute]
public void set_RegionDetails(RegionDetails value);
}
internal class Microsoft.Identity.Client.AuthorityInfo : object {
    [CompilerGeneratedAttribute]
private Uri <CanonicalAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityType <AuthorityType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserRealmUriPrefix>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    public string Host { get; }
    public Uri CanonicalAuthority { get; }
    internal AuthorityType AuthorityType { get; }
    public string UserRealmUriPrefix { get; }
    public bool ValidateAuthority { get; }
    internal bool IsInstanceDiscoverySupported { get; }
    internal bool IsUserAssertionSupported { get; }
    internal bool IsTenantOverrideSupported { get; }
    internal bool IsMultiTenantSupported { get; }
    internal bool IsClientInfoSupported { get; }
    internal bool IsDefaultAuthority { get; }
    public AuthorityInfo(AuthorityType authorityType, string authority, bool validateAuthority);
    public AuthorityInfo(AuthorityType authorityType, Uri authorityUri, bool validateAuthority);
    public AuthorityInfo(AuthorityInfo other);
    private AuthorityInfo(Uri canonicalAuthority, AuthorityType authorityType, string userRealmUriPrefix, bool validateAuthority);
    public string get_Host();
    [CompilerGeneratedAttribute]
public Uri get_CanonicalAuthority();
    [CompilerGeneratedAttribute]
internal AuthorityType get_AuthorityType();
    [CompilerGeneratedAttribute]
public string get_UserRealmUriPrefix();
    [CompilerGeneratedAttribute]
public bool get_ValidateAuthority();
    internal bool get_IsInstanceDiscoverySupported();
    internal bool get_IsUserAssertionSupported();
    internal bool get_IsTenantOverrideSupported();
    internal bool get_IsMultiTenantSupported();
    internal bool get_IsClientInfoSupported();
    internal static AuthorityInfo FromAuthorityUri(string authorityUri, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(Uri cloudInstanceUri, Guid tenantId, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(Uri cloudInstanceUri, string tenant, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, Guid tenantId, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, string tenant, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(AadAuthorityAudience authorityAudience, bool validateAuthority);
    internal static AuthorityInfo FromAadAuthority(string authorityUri, bool validateAuthority);
    internal static AuthorityInfo FromAdfsAuthority(string authorityUri, bool validateAuthority);
    internal static AuthorityInfo FromB2CAuthority(string authorityUri);
    internal static AuthorityInfo FromGenericAuthority(string authorityUri);
    internal static string GetCloudUrl(AzureCloudInstance azureCloudInstance);
    internal static string GetAadAuthorityAudienceValue(AadAuthorityAudience authorityAudience, string tenantId);
    internal static string CanonicalizeAuthorityUri(string uri);
    internal bool get_IsDefaultAuthority();
    internal Authority CreateAuthority();
    private static void ValidateAuthorityUri(string authority, Nullable`1<AuthorityType> authorityType);
    private static string GetAuthorityUri(AzureCloudInstance azureCloudInstance, AadAuthorityAudience authorityAudience, string tenantId);
    internal static string GetFirstPathSegment(string authority);
    internal static string GetFirstPathSegment(Uri authority);
    internal static string GetSecondPathSegment(string authority);
    internal static string GetSecondPathSegment(Uri authority);
    private static AuthorityType GetAuthorityType(string authority);
    private static String[] GetPathSegments(string absolutePath);
}
internal enum Microsoft.Identity.Client.AuthorityType : Enum {
    public int value__;
    public static AuthorityType Aad;
    public static AuthorityType Adfs;
    public static AuthorityType B2C;
    public static AuthorityType Dsts;
    public static AuthorityType Generic;
}
internal class Microsoft.Identity.Client.AuthScheme.AuthSchemeHelper : object {
    public static bool StoreTokenTypeInCacheKey(string tokenType);
}
internal class Microsoft.Identity.Client.AuthScheme.Bearer.BearerAuthenticationScheme : object {
    internal static string BearerTokenType;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string get_KeyId();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IDictionary`2<string, string> GetTokenRequestParams();
}
internal interface Microsoft.Identity.Client.AuthScheme.IAuthenticationScheme {
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public abstract virtual TokenType get_TelemetryTokenType();
    public abstract virtual string get_AuthorizationHeaderPrefix();
    public abstract virtual IDictionary`2<string, string> GetTokenRequestParams();
    public abstract virtual string get_KeyId();
    public abstract virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual string get_AccessTokenType();
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.InMemoryCryptoProvider : object {
    internal static int RsaKeySize;
    private RSA _signingKey;
    [CompilerGeneratedAttribute]
private string <CannonicalPublicKeyJwk>k__BackingField;
    public string CannonicalPublicKeyJwk { get; private set; }
    public string CryptographicAlgorithm { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_CannonicalPublicKeyJwk();
    [CompilerGeneratedAttribute]
private void set_CannonicalPublicKeyJwk(string value);
    public sealed virtual string get_CryptographicAlgorithm();
    private void InitializeSigningKey();
    public sealed virtual Byte[] Sign(Byte[] payload);
    private static string ComputeCanonicalJwk(RSAParameters rsaPublicKey);
    public static Byte[] Sign(RSA RsaKey, Byte[] payload);
}
public interface Microsoft.Identity.Client.AuthScheme.PoP.IPoPCryptoProvider {
    public string CannonicalPublicKeyJwk { get; }
    public string CryptographicAlgorithm { get; }
    public abstract virtual string get_CannonicalPublicKeyJwk();
    public abstract virtual string get_CryptographicAlgorithm();
    public abstract virtual Byte[] Sign(Byte[] data);
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.JsonWebAlgorithmsKeyTypes : object {
    public static string EllipticCurve;
    public static string RSA;
    public static string Octet;
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.JsonWebKeyParameterNames : object {
    public static string Alg;
    public static string Crv;
    public static string D;
    public static string DP;
    public static string DQ;
    public static string E;
    public static string K;
    public static string KeyOps;
    public static string Keys;
    public static string Kid;
    public static string Kty;
    public static string N;
    public static string Oth;
    public static string P;
    public static string Q;
    public static string R;
    public static string T;
    public static string QI;
    public static string Use;
    public static string X5c;
    public static string X5t;
    public static string X5tS256;
    public static string X5u;
    public static string X;
    public static string Y;
    public static string EC;
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.PopAuthenticationScheme : object {
    private static DateTime s_jwtBaselineTime;
    private PoPAuthenticationConfiguration _popAuthenticationConfiguration;
    private IPoPCryptoProvider _popCryptoProvider;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public PopAuthenticationScheme(PoPAuthenticationConfiguration popAuthenticationConfiguration, IServiceBundle serviceBundle);
    private static PopAuthenticationScheme();
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyId();
    public sealed virtual IDictionary`2<string, string> GetTokenRequestParams();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private JsonObject CreateBody(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private static string CreateSimpleNonce();
    private string ComputeReqCnf();
    private static Byte[] ComputeThumbprint(string canonicalJwk);
    private string CreateJWS(string payload, string header);
}
internal class Microsoft.Identity.Client.AuthScheme.PoP.PopBrokerAuthenticationScheme : object {
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_KeyId();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IDictionary`2<string, string> GetTokenRequestParams();
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.PoPClaimTypes : object {
    public static string At;
    public static string HttpMethod;
    public static string Ts;
    public static string Host;
    public static string Path;
    public static string Query;
    public static string Cnf;
    public static string JWK;
    public static string Nonce;
}
internal static class Microsoft.Identity.Client.AuthScheme.PoP.PoPProviderFactory : object {
    private static InMemoryCryptoProvider s_currentProvider;
    private static DateTime s_providerExpiration;
    [CompilerGeneratedAttribute]
private static TimeSpan <KeyRotationInterval>k__BackingField;
    private static object s_lock;
    [CompilerGeneratedAttribute]
private static ITimeService <TimeService>k__BackingField;
    public static TimeSpan KeyRotationInterval { get; }
    internal static ITimeService TimeService { get; internal set; }
    private static PoPProviderFactory();
    [CompilerGeneratedAttribute]
public static TimeSpan get_KeyRotationInterval();
    [CompilerGeneratedAttribute]
internal static ITimeService get_TimeService();
    [CompilerGeneratedAttribute]
internal static void set_TimeService(ITimeService value);
    public static InMemoryCryptoProvider GetOrCreateProvider();
    public static void Reset();
}
internal class Microsoft.Identity.Client.AuthScheme.SSHCertificates.SSHCertAuthenticationScheme : object {
    internal static string SSHCertTokenType;
    private string _jwk;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string AccessTokenType { get; }
    public string KeyId { get; }
    public SSHCertAuthenticationScheme(string keyId, string jwk);
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_AccessTokenType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_KeyId();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IDictionary`2<string, string> GetTokenRequestParams();
}
internal enum Microsoft.Identity.Client.AuthScheme.TokenType : Enum {
    public int value__;
    public static TokenType Bearer;
    public static TokenType Pop;
    public static TokenType SshCert;
    public static TokenType External;
}
public enum Microsoft.Identity.Client.AzureCloudInstance : Enum {
    public int value__;
    public static AzureCloudInstance None;
    public static AzureCloudInstance AzurePublic;
    public static AzureCloudInstance AzureChina;
    public static AzureCloudInstance AzureGermany;
    public static AzureCloudInstance AzureUsGovernment;
}
public abstract class Microsoft.Identity.Client.BaseAbstractAcquireTokenParameterBuilder`1 : object {
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private AcquireTokenCommonParameters <CommonParameters>k__BackingField;
    internal IServiceBundle ServiceBundle { get; }
    internal AcquireTokenCommonParameters CommonParameters { get; }
    internal BaseAbstractAcquireTokenParameterBuilder`1(IServiceBundle serviceBundle);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
internal AcquireTokenCommonParameters get_CommonParameters();
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    internal abstract virtual ApiIds CalculateApiEventId();
    public Task`1<AuthenticationResult> ExecuteAsync();
    public T WithCorrelationId(Guid correlationId);
    protected virtual void Validate();
    internal void ValidateAndCalculateApiId();
    internal void ValidateUseOfExperimentalFeature(string memberName);
}
public abstract class Microsoft.Identity.Client.BaseAbstractApplicationBuilder`1 : object {
    [CompilerGeneratedAttribute]
private ApplicationConfiguration <Config>k__BackingField;
    internal ApplicationConfiguration Config { get; }
    internal BaseAbstractApplicationBuilder`1(ApplicationConfiguration configuration);
    [CompilerGeneratedAttribute]
internal ApplicationConfiguration get_Config();
    public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory);
    public T WithHttpClientFactory(IMsalHttpClientFactory httpClientFactory, bool retryOnceOn5xx);
    internal T WithHttpManager(IHttpManager httpManager);
    public T WithCacheOptions(CacheOptions options);
    public T WithLogging(LogCallback loggingCallback, Nullable`1<LogLevel> logLevel, Nullable`1<bool> enablePiiLogging, Nullable`1<bool> enableDefaultPlatformLogging);
    public T WithLogging(IIdentityLogger identityLogger, bool enablePiiLogging);
    public T WithDebugLoggingCallback(LogLevel logLevel, bool enablePiiLogging, bool withDefaultPlatformLoggingEnabled);
    protected T WithOptions(BaseApplicationOptions applicationOptions);
    public T WithExperimentalFeatures(bool enableExperimentalFeatures);
    internal virtual ApplicationConfiguration BuildConfiguration();
    internal void ResolveAuthority();
    private string GetAuthorityAudience();
    private string GetAuthorityInstance();
    internal void ValidateUseOfExperimentalFeature(string memberName);
}
public abstract class Microsoft.Identity.Client.BaseApplicationOptions : object {
    [CompilerGeneratedAttribute]
private LogLevel <LogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnablePiiLogging>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    public LogLevel LogLevel { get; public set; }
    public bool EnablePiiLogging { get; public set; }
    public bool IsDefaultPlatformLoggingEnabled { get; public set; }
    [CompilerGeneratedAttribute]
public LogLevel get_LogLevel();
    [CompilerGeneratedAttribute]
public void set_LogLevel(LogLevel value);
    [CompilerGeneratedAttribute]
public bool get_EnablePiiLogging();
    [CompilerGeneratedAttribute]
public void set_EnablePiiLogging(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public void set_IsDefaultPlatformLoggingEnabled(bool value);
}
public class Microsoft.Identity.Client.BrokerOptions : object {
    [CompilerGeneratedAttribute]
private OperatingSystems <EnabledOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <MsaPassthrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ListOperatingSystemAccounts>k__BackingField;
    public OperatingSystems EnabledOn { get; }
    public string Title { get; public set; }
    [EditorBrowsableAttribute("1")]
public bool MsaPassthrough { get; public set; }
    public bool ListOperatingSystemAccounts { get; public set; }
    public BrokerOptions(OperatingSystems enabledOn);
    internal static BrokerOptions CreateFromWindowsOptions(WindowsBrokerOptions winOptions);
    [CompilerGeneratedAttribute]
public OperatingSystems get_EnabledOn();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public bool get_MsaPassthrough();
    [CompilerGeneratedAttribute]
public void set_MsaPassthrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ListOperatingSystemAccounts();
    [CompilerGeneratedAttribute]
public void set_ListOperatingSystemAccounts(bool value);
    internal bool IsBrokerEnabledOnCurrentOs();
}
internal static class Microsoft.Identity.Client.Cache.AdalCacheOperations : object {
    private static int SchemaVersion;
    private static string Delimiter;
    public static Byte[] Serialize(ILoggerAdapter logger, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> tokenCacheDictionary);
    public static IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> Deserialize(ILoggerAdapter logger, Byte[] state);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalResult : object {
    [CompilerGeneratedAttribute]
private AdalUserInfo <UserInfo>k__BackingField;
    [JsonIncludeAttribute]
public AdalUserInfo UserInfo { get; internal set; }
    [CompilerGeneratedAttribute]
public AdalUserInfo get_UserInfo();
    [CompilerGeneratedAttribute]
internal void set_UserInfo(AdalUserInfo value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalResultWrapper : object {
    [CompilerGeneratedAttribute]
private AdalResult <Result>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ResourceInResponse>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAssertionHash>k__BackingField;
    public AdalResult Result { get; public set; }
    public string RawClientInfo { get; public set; }
    public string RefreshToken { get; public set; }
    internal bool IsMultipleResourceRefreshToken { get; }
    internal string ResourceInResponse { get; internal set; }
    public string UserAssertionHash { get; public set; }
    [CompilerGeneratedAttribute]
public AdalResult get_Result();
    [CompilerGeneratedAttribute]
public void set_Result(AdalResult value);
    [CompilerGeneratedAttribute]
public string get_RawClientInfo();
    [CompilerGeneratedAttribute]
public void set_RawClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    internal bool get_IsMultipleResourceRefreshToken();
    [CompilerGeneratedAttribute]
internal string get_ResourceInResponse();
    [CompilerGeneratedAttribute]
internal void set_ResourceInResponse(string value);
    public static AdalResultWrapper Deserialize(string serializedObject);
    public string Serialize();
    [CompilerGeneratedAttribute]
public string get_UserAssertionHash();
    [CompilerGeneratedAttribute]
public void set_UserAssertionHash(string value);
    internal AdalResultWrapper Clone();
}
[DebuggerDisplayAttribute("{DebuggerDisplay,nq}")]
internal class Microsoft.Identity.Client.Cache.AdalTokenCacheKey : object {
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayableId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenSubjectType <TokenSubjectType>k__BackingField;
    public string Authority { get; }
    public string Resource { get; }
    public string ClientId { get; }
    public string UniqueId { get; }
    public string DisplayableId { get; }
    public TokenSubjectType TokenSubjectType { get; }
    private string DebuggerDisplay { get; }
    internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, AdalUserInfo adalUserInfo);
    internal AdalTokenCacheKey(string authority, string resource, string clientId, TokenSubjectType tokenSubjectType, string uniqueId, string displayableId);
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
public string get_DisplayableId();
    [CompilerGeneratedAttribute]
public TokenSubjectType get_TokenSubjectType();
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(AdalTokenCacheKey other);
    public virtual int GetHashCode();
    private bool ClientIdEquals(string otherClientId);
    private bool DisplayableIdEquals(string otherDisplayableId);
    private string get_DebuggerDisplay();
}
internal class Microsoft.Identity.Client.Cache.AdalUserForMsalEntry : object {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private AdalUserInfo <UserInfo>k__BackingField;
    public string ClientId { get; }
    public string Authority { get; }
    public string ClientInfo { get; }
    public AdalUserInfo UserInfo { get; }
    public AdalUserForMsalEntry(string clientId, string authority, string clientInfo, AdalUserInfo userInfo);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public AdalUserInfo get_UserInfo();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Cache.AdalUserInfo : object {
    [CompilerGeneratedAttribute]
private string <UniqueId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DisplayableId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <PasswordExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <PasswordChangeUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdentityProvider>k__BackingField;
    [JsonIncludeAttribute]
public string UniqueId { get; internal set; }
    [JsonIncludeAttribute]
public string DisplayableId { get; internal set; }
    [JsonIncludeAttribute]
public string GivenName { get; internal set; }
    [JsonIncludeAttribute]
public string FamilyName { get; internal set; }
    [JsonIncludeAttribute]
public Nullable`1<DateTimeOffset> PasswordExpiresOn { get; internal set; }
    [JsonIncludeAttribute]
public Uri PasswordChangeUrl { get; internal set; }
    [JsonIncludeAttribute]
public string IdentityProvider { get; internal set; }
    public AdalUserInfo(AdalUserInfo other);
    [CompilerGeneratedAttribute]
public string get_UniqueId();
    [CompilerGeneratedAttribute]
internal void set_UniqueId(string value);
    [CompilerGeneratedAttribute]
public string get_DisplayableId();
    [CompilerGeneratedAttribute]
internal void set_DisplayableId(string value);
    [CompilerGeneratedAttribute]
public string get_GivenName();
    [CompilerGeneratedAttribute]
internal void set_GivenName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
internal void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_PasswordExpiresOn();
    [CompilerGeneratedAttribute]
internal void set_PasswordExpiresOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
public Uri get_PasswordChangeUrl();
    [CompilerGeneratedAttribute]
internal void set_PasswordChangeUrl(Uri value);
    [CompilerGeneratedAttribute]
public string get_IdentityProvider();
    [CompilerGeneratedAttribute]
internal void set_IdentityProvider(string value);
}
internal class Microsoft.Identity.Client.Cache.AdalUsersForMsal : object {
    private IEnumerable`1<AdalUserForMsalEntry> _userEntries;
    public AdalUsersForMsal(IEnumerable`1<AdalUserForMsalEntry> userEntries);
    public IDictionary`2<string, AdalUserInfo> GetUsersWithClientInfo(IEnumerable`1<string> envAliases);
    public IEnumerable`1<AdalUserInfo> GetUsersWithoutClientInfo(IEnumerable`1<string> envAliases);
    public ISet`1<string> GetAdalUserEnvironments();
}
internal enum Microsoft.Identity.Client.Cache.CacheAuthorityType : Enum {
    public int value__;
    public static CacheAuthorityType AAD;
    public static CacheAuthorityType MSA;
    public static CacheAuthorityType MSSTS;
    public static CacheAuthorityType OTHER;
}
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v3 and ADAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.Cache.CacheData : object {
    [CompilerGeneratedAttribute]
private Byte[] <AdalV3State>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <UnifiedState>k__BackingField;
    public Byte[] AdalV3State { get; public set; }
    public Byte[] UnifiedState { get; public set; }
    [CompilerGeneratedAttribute]
public Byte[] get_AdalV3State();
    [CompilerGeneratedAttribute]
public void set_AdalV3State(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_UnifiedState();
    [CompilerGeneratedAttribute]
public void set_UnifiedState(Byte[] value);
}
internal static class Microsoft.Identity.Client.Cache.CacheFallbackOperations : object {
    internal static string DifferentEnvError;
    internal static string DifferentAuthorityError;
    public static void WriteAdalRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, MsalRefreshTokenCacheItem rtItem, MsalIdTokenCacheItem idItem, string authority, string uniqueId, string scope);
    public static AdalUsersForMsal GetAllAdalUsersForMsal(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId);
    public static void RemoveAdalUser(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, string clientId, string displayableId, string accountOrUserId);
    private static void RemoveEntriesWithMatchingName(ILoggerAdapter logger, string clientId, string displayableId, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> adalCache);
    private static void RemoveEntriesWithMatchingId(string clientId, string accountOrUserId, IDictionary`2<AdalTokenCacheKey, AdalResultWrapper> adalCache);
    public static MsalRefreshTokenCacheItem GetRefreshToken(ILoggerAdapter logger, ILegacyCachePersistence legacyCachePersistence, IEnumerable`1<string> environmentAliases, string clientId, IAccount account);
    private static string GetHomeAccountId(AdalResultWrapper adalResultWrapper);
}
internal interface Microsoft.Identity.Client.Cache.CacheImpl.ICacheSerializationProvider {
    public abstract virtual void Initialize(TokenCache tokenCache);
}
internal static class Microsoft.Identity.Client.Cache.CacheKeyFactory : object {
    public static string GetKeyFromRequest(AuthenticationRequestParameters requestParameters);
    public static string GetExternalCacheKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse);
    public static string GetInternalPartitionKeyFromResponse(AuthenticationRequestParameters requestParameters, string homeAccountIdFromResponse);
    private static bool GetOboOrAppKey(AuthenticationRequestParameters requestParameters, String& key);
    public static string GetClientCredentialKey(string clientId, string tenantId, string popKid);
    public static string GetOboKey(string oboCacheKey, UserAssertion userAssertion);
    public static string GetOboKey(string oboCacheKey, string homeAccountId);
    public static string GetKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem);
    public static string GetKeyFromCachedItem(MsalRefreshTokenCacheItem refreshTokenCacheItem);
    public static string GetIdTokenKeyFromCachedItem(MsalAccessTokenCacheItem accessTokenCacheItem);
    public static string GetKeyFromAccount(MsalAccountCacheItem accountCacheItem);
    public static string GetKeyFromCachedItem(MsalIdTokenCacheItem idTokenCacheItem);
    public static string GetKeyFromCachedItem(MsalAccountCacheItem accountCacheItem);
}
internal class Microsoft.Identity.Client.Cache.CacheSessionManager : object {
    private AuthenticationRequestParameters _requestParams;
    private bool _cacheRefreshedForRead;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <TokenCacheInternal>k__BackingField;
    public RequestContext RequestContext { get; }
    public ITokenCacheInternal TokenCacheInternal { get; }
    public CacheSessionManager(ITokenCacheInternal tokenCacheInternal, AuthenticationRequestParameters requestParams);
    [CompilerGeneratedAttribute]
public sealed virtual RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public sealed virtual ITokenCacheInternal get_TokenCacheInternal();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindAccessTokenAsync>d__9")]
public sealed virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<SaveTokenResponseAsync>d__10")]
public sealed virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetAccountAssociatedWithAccessTokenAsync>d__11")]
public sealed virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetIdTokenCacheItemAsync>d__12")]
public sealed virtual Task`1<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindFamilyRefreshTokenAsync>d__13")]
public sealed virtual Task`1<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<FindRefreshTokenAsync>d__14")]
public sealed virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<IsAppFociMemberAsync>d__15")]
public sealed virtual Task`1<Nullable`1<bool>> IsAppFociMemberAsync(string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<GetAccountsAsync>d__16")]
public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Cache.CacheSessionManager/<RefreshCacheForReadOperationsAsync>d__17")]
private Task RefreshCacheForReadOperationsAsync();
    [CompilerGeneratedAttribute]
private string <RefreshCacheForReadOperationsAsync>b__17_0();
}
internal interface Microsoft.Identity.Client.Cache.ICacheSessionManager {
    public RequestContext RequestContext { get; }
    public ITokenCacheInternal TokenCacheInternal { get; }
    public abstract virtual RequestContext get_RequestContext();
    public abstract virtual ITokenCacheInternal get_TokenCacheInternal();
    public abstract virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync();
    public abstract virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(MsalTokenResponse tokenResponse);
    public abstract virtual Task`1<MsalIdTokenCacheItem> GetIdTokenCacheItemAsync(MsalAccessTokenCacheItem accessTokenCacheItem);
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync();
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindFamilyRefreshTokenAsync(string familyId);
    public abstract virtual Task`1<Nullable`1<bool>> IsAppFociMemberAsync(string familyId);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    public abstract virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
}
internal interface Microsoft.Identity.Client.Cache.ILegacyCachePersistence {
    public abstract virtual Byte[] LoadCache();
    public abstract virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.Cache.Items.CacheSerializationContract : object {
    private static JsonSerializerOptions NeverIgnoreJsonOptions;
    private static IEnumerable`1<string> s_knownPropertyNames;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAccessTokenCacheItem> <AccessTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalRefreshTokenCacheItem> <RefreshTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalIdTokenCacheItem> <IdTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAccountCacheItem> <Accounts>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, MsalAppMetadataCacheItem> <AppMetadata>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, JsonNode> <UnknownNodes>k__BackingField;
    public Dictionary`2<string, MsalAccessTokenCacheItem> AccessTokens { get; public set; }
    public Dictionary`2<string, MsalRefreshTokenCacheItem> RefreshTokens { get; public set; }
    public Dictionary`2<string, MsalIdTokenCacheItem> IdTokens { get; public set; }
    public Dictionary`2<string, MsalAccountCacheItem> Accounts { get; public set; }
    public Dictionary`2<string, MsalAppMetadataCacheItem> AppMetadata { get; public set; }
    public IDictionary`2<string, JsonNode> UnknownNodes { get; }
    public CacheSerializationContract(IDictionary`2<string, JsonNode> unknownNodes);
    private static CacheSerializationContract();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAccessTokenCacheItem> get_AccessTokens();
    [CompilerGeneratedAttribute]
public void set_AccessTokens(Dictionary`2<string, MsalAccessTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalRefreshTokenCacheItem> get_RefreshTokens();
    [CompilerGeneratedAttribute]
public void set_RefreshTokens(Dictionary`2<string, MsalRefreshTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalIdTokenCacheItem> get_IdTokens();
    [CompilerGeneratedAttribute]
public void set_IdTokens(Dictionary`2<string, MsalIdTokenCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAccountCacheItem> get_Accounts();
    [CompilerGeneratedAttribute]
public void set_Accounts(Dictionary`2<string, MsalAccountCacheItem> value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, MsalAppMetadataCacheItem> get_AppMetadata();
    [CompilerGeneratedAttribute]
public void set_AppMetadata(Dictionary`2<string, MsalAppMetadataCacheItem> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, JsonNode> get_UnknownNodes();
    internal static CacheSerializationContract FromJsonString(string json);
    private static IDictionary`2<string, JsonNode> ExtractUnknownNodes(JsonObject root);
    internal string ToJsonString();
    [IteratorStateMachineAttribute("Microsoft.Identity.Client.Cache.Items.CacheSerializationContract/<<FromJsonString>g__GetElement|26_0>d")]
[CompilerGeneratedAttribute]
internal static IEnumerable`1<JsonObject> <FromJsonString>g__GetElement|26_0(JsonObject root, string key);
}
internal class Microsoft.Identity.Client.Cache.Items.MsalAccessTokenCacheItem : MsalCredentialCacheItemBase {
    private String[] _extraKeyParts;
    private string _credentialDescriptor;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <ScopeSet>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ScopeString>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExtendedExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <RefreshOn>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CachedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsExtendedLifeTimeToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; private set; }
    internal string OboCacheKey { get; internal set; }
    internal string KeyId { get; }
    internal string TokenType { get; }
    internal HashSet`1<string> ScopeSet { get; }
    internal string ScopeString { get; }
    internal DateTimeOffset ExpiresOn { get; private set; }
    internal DateTimeOffset ExtendedExpiresOn { get; private set; }
    internal Nullable`1<DateTimeOffset> RefreshOn { get; private set; }
    internal DateTimeOffset CachedAt { get; private set; }
    public bool IsExtendedLifeTimeToken { get; public set; }
    internal string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId, string keyId, string oboCacheKey);
    internal MsalAccessTokenCacheItem(string preferredCacheEnv, string clientId, string scopes, string tenantId, string secret, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, string rawClientInfo, string homeAccountId, string keyId, Nullable`1<DateTimeOffset> refreshOn, string tokenType, string oboCacheKey);
    private MsalAccessTokenCacheItem(string scopes, DateTimeOffset cachedAt, DateTimeOffset expiresOn, DateTimeOffset extendedExpiresOn, Nullable`1<DateTimeOffset> refreshOn, string tenantId, string keyId, string tokenType);
    internal MsalAccessTokenCacheItem WithExpiresOn(DateTimeOffset expiresOn);
    internal void InitCacheKey();
    internal string ToLogString(bool piiEnabled);
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal string get_OboCacheKey();
    [CompilerGeneratedAttribute]
internal void set_OboCacheKey(string value);
    [CompilerGeneratedAttribute]
internal string get_KeyId();
    [CompilerGeneratedAttribute]
internal string get_TokenType();
    [CompilerGeneratedAttribute]
internal HashSet`1<string> get_ScopeSet();
    [CompilerGeneratedAttribute]
internal string get_ScopeString();
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_ExtendedExpiresOn();
    [CompilerGeneratedAttribute]
private void set_ExtendedExpiresOn(DateTimeOffset value);
    [CompilerGeneratedAttribute]
internal Nullable`1<DateTimeOffset> get_RefreshOn();
    [CompilerGeneratedAttribute]
private void set_RefreshOn(Nullable`1<DateTimeOffset> value);
    [CompilerGeneratedAttribute]
internal DateTimeOffset get_CachedAt();
    [CompilerGeneratedAttribute]
private void set_CachedAt(DateTimeOffset value);
    [CompilerGeneratedAttribute]
public bool get_IsExtendedLifeTimeToken();
    [CompilerGeneratedAttribute]
public void set_IsExtendedLifeTimeToken(bool value);
    [CompilerGeneratedAttribute]
internal string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalAccessTokenCacheItem FromJsonString(string json);
    internal static MsalAccessTokenCacheItem FromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
    internal string ToJsonString();
    internal MsalIdTokenCacheItem GetIdTokenItem();
    internal bool IsExpiredWithBuffer();
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__6_0();
}
[DebuggerDisplayAttribute("{PreferredUsername} {base.Environment}")]
internal class Microsoft.Identity.Client.Cache.Items.MsalAccountCacheItem : MsalCacheItemBase {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LocalAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <WamAccountIds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; internal set; }
    internal string PreferredUsername { get; internal set; }
    internal string Name { get; internal set; }
    internal string GivenName { get; internal set; }
    internal string FamilyName { get; internal set; }
    internal string LocalAccountId { get; internal set; }
    internal string AuthorityType { get; internal set; }
    internal IDictionary`2<string, string> WamAccountIds { get; internal set; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalAccountCacheItem(string preferredCacheEnv, string clientInfo, string homeAccountId, IdToken idToken, string preferredUsername, string tenantId, IDictionary`2<string, string> wamAccountIds);
    internal MsalAccountCacheItem(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary`2<string, string> wamAccountIds);
    internal MsalAccountCacheItem(string environment, string tenantId, string homeAccountId, string preferredUsername);
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
internal string get_PreferredUsername();
    [CompilerGeneratedAttribute]
internal void set_PreferredUsername(string value);
    [CompilerGeneratedAttribute]
internal string get_Name();
    [CompilerGeneratedAttribute]
internal void set_Name(string value);
    [CompilerGeneratedAttribute]
internal string get_GivenName();
    [CompilerGeneratedAttribute]
internal void set_GivenName(string value);
    [CompilerGeneratedAttribute]
internal string get_FamilyName();
    [CompilerGeneratedAttribute]
internal void set_FamilyName(string value);
    [CompilerGeneratedAttribute]
internal string get_LocalAccountId();
    [CompilerGeneratedAttribute]
internal void set_LocalAccountId(string value);
    [CompilerGeneratedAttribute]
internal string get_AuthorityType();
    [CompilerGeneratedAttribute]
internal void set_AuthorityType(string value);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_WamAccountIds();
    [CompilerGeneratedAttribute]
internal void set_WamAccountIds(IDictionary`2<string, string> value);
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    private void Init(string environment, string localAccountId, string rawClientInfo, string homeAccountId, string name, string preferredUsername, string tenantId, string givenName, string familyName, IDictionary`2<string, string> wamAccountIds);
    internal void InitCacheKey();
    private IiOSKey InitiOSKey();
    internal static MsalAccountCacheItem FromJsonString(string json);
    internal static MsalAccountCacheItem FromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
    internal string ToJsonString();
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__44_0();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalAppMetadataCacheItem : MsalItemWithAdditionalFields {
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    public string ClientId { get; }
    public string Environment { get; }
    public string FamilyId { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    public MsalAppMetadataCacheItem(string clientId, string preferredCacheEnv, string familyId);
    private void InitCacheKey();
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public string get_Environment();
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalAppMetadataCacheItem FromJsonString(string json);
    internal static MsalAppMetadataCacheItem FromJObject(JsonObject j);
    internal string ToJsonString();
    internal virtual JsonObject ToJObject();
    public virtual int GetHashCode();
    public sealed virtual bool Equals(MsalAppMetadataCacheItem other);
    public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__1_0();
}
[DebuggerDisplayAttribute("env: {Environment} accountId: {HomeAccountId}")]
internal abstract class Microsoft.Identity.Client.Cache.Items.MsalCacheItemBase : MsalItemWithAdditionalFields {
    [CompilerGeneratedAttribute]
private string <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Environment>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawClientInfo>k__BackingField;
    internal string HomeAccountId { get; internal set; }
    internal string Environment { get; internal set; }
    internal string RawClientInfo { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_HomeAccountId();
    [CompilerGeneratedAttribute]
internal void set_HomeAccountId(string value);
    [CompilerGeneratedAttribute]
internal string get_Environment();
    [CompilerGeneratedAttribute]
internal void set_Environment(string value);
    [CompilerGeneratedAttribute]
internal string get_RawClientInfo();
    [CompilerGeneratedAttribute]
internal void set_RawClientInfo(string value);
    internal virtual void PopulateFieldsFromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalCredentialCacheItemBase : MsalCacheItemBase {
    [CompilerGeneratedAttribute]
private string <CredentialType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    internal string CredentialType { get; internal set; }
    public string ClientId { get; public set; }
    public string Secret { get; public set; }
    [CompilerGeneratedAttribute]
internal string get_CredentialType();
    [CompilerGeneratedAttribute]
internal void set_CredentialType(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
    [CompilerGeneratedAttribute]
public string get_Secret();
    [CompilerGeneratedAttribute]
public void set_Secret(string value);
    internal virtual void PopulateFieldsFromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
}
internal class Microsoft.Identity.Client.Cache.Items.MsalIdTokenCacheItem : MsalCredentialCacheItemBase {
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    private Lazy`1<IdToken> idTokenLazy;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    internal string TenantId { get; internal set; }
    internal IdToken IdToken { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string tenantId, string homeAccountId);
    internal MsalIdTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string homeAccountId, string tenantId);
    internal void InitCacheKey();
    private IiOSKey InitiOSKey();
    [CompilerGeneratedAttribute]
internal string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    internal IdToken get_IdToken();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalIdTokenCacheItem FromJsonString(string json);
    internal static MsalIdTokenCacheItem FromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
    internal string ToJsonString();
    internal string GetUsername();
    [CompilerGeneratedAttribute]
private IdToken <.ctor>b__0_0();
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__3_0();
}
internal abstract class Microsoft.Identity.Client.Cache.Items.MsalItemWithAdditionalFields : object {
    [CompilerGeneratedAttribute]
private string <AdditionalFieldsJson>k__BackingField;
    internal string AdditionalFieldsJson { get; internal set; }
    [CompilerGeneratedAttribute]
internal string get_AdditionalFieldsJson();
    [CompilerGeneratedAttribute]
internal void set_AdditionalFieldsJson(string value);
    internal virtual void PopulateFieldsFromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
    internal void SetItemIfValueNotNull(JsonObject json, string key, JsonNode value);
    internal void SetItemIfValueNotNullOrDefault(JsonObject json, string key, JsonNode value, string defaultValue);
    private static void SetValueIfFilterMatches(JsonObject json, string key, JsonNode value, Func`2<string, bool> filter);
}
internal class Microsoft.Identity.Client.Cache.Items.MsalRefreshTokenCacheItem : MsalCredentialCacheItemBase {
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CacheKey>k__BackingField;
    private Lazy`1<IiOSKey> iOSCacheKeyLazy;
    public string FamilyId { get; public set; }
    internal string OboCacheKey { get; internal set; }
    public bool IsFRT { get; }
    public string CacheKey { get; private set; }
    public IiOSKey iOSCacheKey { get; }
    internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, MsalTokenResponse response, string homeAccountId);
    internal MsalRefreshTokenCacheItem(string preferredCacheEnv, string clientId, string secret, string rawClientInfo, string familyId, string homeAccountId);
    internal void InitCacheKey();
    private IiOSKey InitiOSKey();
    private string GetiOSGeneric();
    public string GetiOSService();
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public void set_FamilyId(string value);
    [CompilerGeneratedAttribute]
internal string get_OboCacheKey();
    [CompilerGeneratedAttribute]
internal void set_OboCacheKey(string value);
    public bool get_IsFRT();
    [CompilerGeneratedAttribute]
public string get_CacheKey();
    [CompilerGeneratedAttribute]
private void set_CacheKey(string value);
    public IiOSKey get_iOSCacheKey();
    internal static MsalRefreshTokenCacheItem FromJsonString(string json);
    internal static MsalRefreshTokenCacheItem FromJObject(JsonObject j);
    internal virtual JsonObject ToJObject();
    internal string ToJsonString();
    [CompilerGeneratedAttribute]
private IiOSKey <InitCacheKey>b__3_0();
}
internal interface Microsoft.Identity.Client.Cache.ITokenCacheAccessor {
    public abstract virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public abstract virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public abstract virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public abstract virtual void SaveAccount(MsalAccountCacheItem item);
    public abstract virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public abstract virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public abstract virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public abstract virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public abstract virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public abstract virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public abstract virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public abstract virtual void DeleteAccount(MsalAccountCacheItem item);
    public abstract virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalAccountCacheItem> GetAllAccounts(string optionalPartitionKey, ILoggerAdapter requestlogger);
    public abstract virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public abstract virtual void Clear(ILoggerAdapter requestlogger);
    public abstract virtual bool HasAccessOrRefreshTokens();
}
internal interface Microsoft.Identity.Client.Cache.ITokenCacheSerializable {
    public abstract virtual IDictionary`2<string, JsonNode> Deserialize(Byte[] bytes, bool clearExistingCacheData);
    public abstract virtual Byte[] Serialize(IDictionary`2<string, JsonNode> additionalNodes);
}
internal interface Microsoft.Identity.Client.Cache.Keys.IiOSKey {
    public string iOSAccount { get; }
    public string iOSGeneric { get; }
    public string iOSService { get; }
    public int iOSType { get; }
    public abstract virtual string get_iOSAccount();
    public abstract virtual string get_iOSGeneric();
    public abstract virtual string get_iOSService();
    public abstract virtual int get_iOSType();
}
internal class Microsoft.Identity.Client.Cache.Keys.IosKey : ValueType {
    [CompilerGeneratedAttribute]
private string <iOSAccount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <iOSGeneric>k__BackingField;
    [CompilerGeneratedAttribute]
private string <iOSService>k__BackingField;
    [CompilerGeneratedAttribute]
private int <iOSType>k__BackingField;
    public string iOSAccount { get; }
    public string iOSGeneric { get; }
    public string iOSService { get; }
    public int iOSType { get; }
    internal IosKey(string iOSAccount, string iOSService, string iOSGeneric, int iOSType);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSAccount();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSGeneric();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual string get_iOSService();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual int get_iOSType();
}
internal class Microsoft.Identity.Client.Cache.Keys.MsalCacheKeys : object {
    public static string CacheKeyDelimiter;
    internal static Dictionary`2<string, int> iOSAuthorityTypeToAttrType;
    private static MsalCacheKeys();
    public static string GetCredentialKey(string homeAccountId, string environment, string keyDescriptor, string clientId, string tenantId, string scopes, String[] additionalKeys);
    public static string GetiOSAccountKey(string homeAccountId, string environment);
    public static string GetiOSServiceKey(string keyDescriptor, string clientId, string tenantId, string scopes, String[] extraKeyParts);
    public static string GetiOSGenericKey(string keyDescriptor, string clientId, string tenantId);
}
internal static class Microsoft.Identity.Client.Cache.StorageJsonKeys : object {
    public static string HomeAccountId;
    public static string Environment;
    public static string Realm;
    public static string LocalAccountId;
    public static string Username;
    public static string AuthorityType;
    public static string AlternativeAccountId;
    public static string GivenName;
    public static string FamilyName;
    public static string MiddleName;
    public static string Name;
    public static string AvatarUrl;
    public static string CredentialType;
    public static string ClientId;
    public static string Secret;
    public static string Target;
    public static string CachedAt;
    public static string ExpiresOn;
    public static string RefreshOn;
    public static string ExtendedExpiresOn;
    public static string ClientInfo;
    public static string FamilyId;
    public static string AppMetadata;
    public static string KeyId;
    public static string TokenType;
    public static string WamAccountIds;
    public static string UserAssertionHash;
    public static string ExtendedExpiresOn_MsalCompat;
}
internal static class Microsoft.Identity.Client.Cache.StorageJsonValues : object {
    public static string AuthorityTypeAdfs;
    public static string AuthorityTypeMsa;
    public static string AuthorityTypeMsSts;
    public static string AuthorityTypeOther;
    public static string TokenTypeBearer;
    public static string CredentialTypeRefreshToken;
    public static string CredentialTypeAccessToken;
    public static string CredentialTypeAccessTokenWithAuthScheme;
    public static string CredentialTypeIdToken;
    public static string AccountRootKey;
    public static string CredentialTypeOther;
    public static string AppMetadata;
}
internal class Microsoft.Identity.Client.Cache.TokenCacheDictionarySerializer : object {
    private static string AccessTokenKey;
    private static string RefreshTokenKey;
    private static string IdTokenKey;
    private static string AccountKey;
    private ITokenCacheAccessor _accessor;
    public TokenCacheDictionarySerializer(ITokenCacheAccessor accessor);
    public sealed virtual Byte[] Serialize(IDictionary`2<string, JsonNode> unknownNodes);
    public sealed virtual IDictionary`2<string, JsonNode> Deserialize(Byte[] bytes, bool clearExistingCacheData);
}
internal class Microsoft.Identity.Client.Cache.TokenCacheJsonSerializer : object {
    private ITokenCacheAccessor _accessor;
    public TokenCacheJsonSerializer(ITokenCacheAccessor accessor);
    public sealed virtual Byte[] Serialize(IDictionary`2<string, JsonNode> unknownNodes);
    public sealed virtual IDictionary`2<string, JsonNode> Deserialize(Byte[] bytes, bool clearExistingCacheData);
}
internal enum Microsoft.Identity.Client.Cache.TokenSubjectType : Enum {
    public int value__;
    public static TokenSubjectType User;
    public static TokenSubjectType Client;
    public static TokenSubjectType UserPlusClient;
}
public class Microsoft.Identity.Client.CacheOptions : object {
    [CompilerGeneratedAttribute]
private bool <UseSharedCache>k__BackingField;
    public static CacheOptions EnableSharedCacheOptions { get; }
    public bool UseSharedCache { get; public set; }
    public CacheOptions(bool useSharedCache);
    public static CacheOptions get_EnableSharedCacheOptions();
    [CompilerGeneratedAttribute]
public bool get_UseSharedCache();
    [CompilerGeneratedAttribute]
public void set_UseSharedCache(bool value);
}
public enum Microsoft.Identity.Client.CacheRefreshReason : Enum {
    public int value__;
    public static CacheRefreshReason NotApplicable;
    public static CacheRefreshReason ForceRefreshOrClaims;
    public static CacheRefreshReason NoCachedAccessToken;
    public static CacheRefreshReason Expired;
    public static CacheRefreshReason ProactivelyRefreshed;
}
public abstract class Microsoft.Identity.Client.ClientApplicationBase : ApplicationBase {
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <UserTokenCacheInternal>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Component>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SliceParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAuthority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RedirectUri>k__BackingField;
    public IAppConfig AppConfig { get; }
    public ITokenCache UserTokenCache { get; }
    internal ITokenCacheInternal UserTokenCacheInternal { get; }
    public string Authority { get; }
    internal AuthorityInfo AuthorityInfo { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public IEnumerable`1<IUser> Users { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string Component { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ExtraQueryParameters on each call instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string SliceParameters { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public bool ValidateAuthority { get; public set; }
    [ObsoleteAttribute("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public string RedirectUri { get; public set; }
    [ObsoleteAttribute("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public string ClientId { get; }
    internal ClientApplicationBase(ApplicationConfiguration config);
    public sealed virtual IAppConfig get_AppConfig();
    public sealed virtual ITokenCache get_UserTokenCache();
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_UserTokenCacheInternal();
    public sealed virtual string get_Authority();
    internal AuthorityInfo get_AuthorityInfo();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsAsync>d__12")]
public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsAsync>d__13")]
public Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsAsync>d__14")]
public sealed virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsAsync>d__15")]
public Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountAsync>d__16")]
public Task`1<IAccount> GetAccountAsync(string accountId, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountAsync>d__17")]
public sealed virtual Task`1<IAccount> GetAccountAsync(string accountId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<RemoveAsync>d__18")]
public sealed virtual Task RemoveAsync(IAccount account);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<RemoveAsync>d__19")]
public Task RemoveAsync(IAccount account, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsInternalAsync>d__20")]
private Task`1<IEnumerable`1<IAccount>> GetAccountsInternalAsync(ApiIds apiId, string homeAccountIdFilter, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<GetAccountsFromBrokerAsync>d__21")]
private Task`1<IEnumerable`1<IAccount>> GetAccountsFromBrokerAsync(string homeAccountIdFilter, ICacheSessionManager cacheSessionManager, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ClientApplicationBase/<FilterBrokerAccountsByEnvAsync>d__22")]
private Task`1<IEnumerable`1<IAccount>> FilterBrokerAccountsByEnvAsync(IEnumerable`1<IAccount> brokerAccounts, CancellationToken cancellationToken);
    private IEnumerable`1<IAccount> MergeAccounts(IEnumerable`1<IAccount> cacheAccounts, IEnumerable`1<IAccount> brokerAccounts);
    internal RequestContext CreateRequestContext(Guid correlationId, CancellationToken cancellationToken);
    public sealed virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, IAccount account);
    public sealed virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    public sealed virtual IEnumerable`1<IUser> get_Users();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", "True")]
public sealed virtual IUser GetUser(string identifier);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public sealed virtual void Remove(IUser user);
    [CompilerGeneratedAttribute]
public sealed virtual string get_Component();
    [CompilerGeneratedAttribute]
public sealed virtual void set_Component(string value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_SliceParameters();
    [CompilerGeneratedAttribute]
public sealed virtual void set_SliceParameters(string value);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_ValidateAuthority();
    [CompilerGeneratedAttribute]
public void set_ValidateAuthority(bool value);
    [CompilerGeneratedAttribute]
public sealed virtual string get_RedirectUri();
    [CompilerGeneratedAttribute]
public sealed virtual void set_RedirectUri(string value);
    public sealed virtual string get_ClientId();
    [ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account, string authority, bool forceRefresh);
    [ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account);
}
[ObsoleteAttribute("Use ConfidentialClientApplicationBuilder.WithCertificate instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ClientAssertionCertificate : object {
    [EditorBrowsableAttribute("1")]
public static int MinKeySizeInBits { get; }
    [EditorBrowsableAttribute("1")]
public X509Certificate2 Certificate { get; }
    [EditorBrowsableAttribute("1")]
internal string Thumbprint { get; }
    [EditorBrowsableAttribute("1")]
public ClientAssertionCertificate(X509Certificate2 certificate);
    public static int get_MinKeySizeInBits();
    public X509Certificate2 get_Certificate();
    [EditorBrowsableAttribute("1")]
internal Byte[] Sign(ICryptographyManager cryptographyManager, string message);
    internal string get_Thumbprint();
}
[ObsoleteAttribute("Use ConfidentialClientApplicationBuilder.WithCertificate or WithClientSecret instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.ClientCredential : object {
    [EditorBrowsableAttribute("1")]
internal ClientAssertionCertificate Certificate { get; }
    [EditorBrowsableAttribute("1")]
internal string Assertion { get; internal set; }
    [EditorBrowsableAttribute("1")]
internal long ValidTo { get; internal set; }
    [EditorBrowsableAttribute("1")]
internal bool ContainsX5C { get; internal set; }
    [EditorBrowsableAttribute("1")]
internal string Audience { get; internal set; }
    [EditorBrowsableAttribute("1")]
internal string Secret { get; }
    [EditorBrowsableAttribute("1")]
public ClientCredential(ClientAssertionCertificate certificate);
    [EditorBrowsableAttribute("1")]
public ClientCredential(string secret);
    internal ClientAssertionCertificate get_Certificate();
    internal string get_Assertion();
    internal void set_Assertion(string value);
    internal long get_ValidTo();
    internal void set_ValidTo(long value);
    internal bool get_ContainsX5C();
    internal void set_ContainsX5C(bool value);
    internal string get_Audience();
    internal void set_Audience(string value);
    internal string get_Secret();
}
public class Microsoft.Identity.Client.ConfidentialClientApplication : ClientApplicationBase {
    public static string AttemptRegionDiscovery;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternal>k__BackingField;
    public ITokenCache AppTokenCache { get; }
    public X509Certificate2 Certificate { get; }
    internal ITokenCacheInternal AppTokenCacheInternal { get; }
    internal ConfidentialClientApplication(ApplicationConfiguration configuration);
    [ObsoleteAttribute("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public ConfidentialClientApplication(string clientId, string redirectUri, ClientCredential clientCredential, TokenCache userTokenCache, TokenCache appTokenCache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ConfidentialClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public ConfidentialClientApplication(string clientId, string authority, string redirectUri, ClientCredential clientCredential, TokenCache userTokenCache, TokenCache appTokenCache);
    public sealed virtual AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable`1<string> scopes, string authorizationCode);
    public sealed virtual AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable`1<string> scopes);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable`1<string> scopes, string userToken, String& longRunningProcessSessionKey);
    public sealed virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable`1<string> scopes, string longRunningProcessSessionKey);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ConfidentialClientApplication/<StopLongRunningProcessInWebApiAsync>d__7")]
public Task`1<bool> StopLongRunningProcessInWebApiAsync(string longRunningProcessSessionKey, CancellationToken cancellationToken);
    public sealed virtual GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable`1<string> scopes);
    private sealed virtual override AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    public sealed virtual ITokenCache get_AppTokenCache();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_AppTokenCacheInternal();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ConfidentialClientApplication/<CreateRequestParametersAsync>d__18")]
internal virtual Task`1<AuthenticationRequestParameters> CreateRequestParametersAsync(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(string authorizationCode, IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate.AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string loginHint, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string redirectUri, string loginHint, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<AuthenticationRequestParameters> <>n__0(AcquireTokenCommonParameters commonParameters, RequestContext requestContext, ITokenCacheInternal cache);
}
public class Microsoft.Identity.Client.ConfidentialClientApplicationBuilder : AbstractApplicationBuilder`1<ConfidentialClientApplicationBuilder> {
    internal ConfidentialClientApplicationBuilder(ApplicationConfiguration configuration);
    public static ConfidentialClientApplicationBuilder CreateWithApplicationOptions(ConfidentialClientApplicationOptions options);
    public static ConfidentialClientApplicationBuilder Create(string clientId);
    public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate);
    public ConfidentialClientApplicationBuilder WithCertificate(X509Certificate2 certificate, bool sendX5C);
    public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool mergeWithDefaultClaims);
    public ConfidentialClientApplicationBuilder WithClientClaims(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool mergeWithDefaultClaims, bool sendX5C);
    public ConfidentialClientApplicationBuilder WithClientSecret(string clientSecret);
    public ConfidentialClientApplicationBuilder WithClientAssertion(string signedClientAssertion);
    [EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithClientAssertion(Func`1<string> clientAssertionDelegate);
    [EditorBrowsableAttribute("1")]
public ConfidentialClientApplicationBuilder WithClientAssertion(Func`2<CancellationToken, Task`1<string>> clientAssertionAsyncDelegate);
    public ConfidentialClientApplicationBuilder WithClientAssertion(Func`2<AssertionRequestOptions, Task`1<string>> clientAssertionAsyncDelegate);
    public ConfidentialClientApplicationBuilder WithAzureRegion(string azureRegion);
    public ConfidentialClientApplicationBuilder WithCacheSynchronization(bool enableCacheSynchronization);
    public ConfidentialClientApplicationBuilder WithGenericAuthority(string authorityUri);
    public ConfidentialClientApplicationBuilder WithTelemetryClient(ITelemetryClient[] telemetryClients);
    private void TelemetryClientLogMsalVersion();
    internal ConfidentialClientApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    internal virtual void Validate();
    public IConfidentialClientApplication Build();
    internal ConfidentialClientApplication BuildConcrete();
}
public class Microsoft.Identity.Client.ConfidentialClientApplicationOptions : ApplicationOptions {
    [CompilerGeneratedAttribute]
private string <ClientSecret>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AzureRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCacheSynchronization>k__BackingField;
    public string ClientSecret { get; public set; }
    public string AzureRegion { get; public set; }
    public bool EnableCacheSynchronization { get; public set; }
    [CompilerGeneratedAttribute]
public string get_ClientSecret();
    [CompilerGeneratedAttribute]
public void set_ClientSecret(string value);
    [CompilerGeneratedAttribute]
public string get_AzureRegion();
    [CompilerGeneratedAttribute]
public void set_AzureRegion(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableCacheSynchronization();
    [CompilerGeneratedAttribute]
public void set_EnableCacheSynchronization(bool value);
}
internal interface Microsoft.Identity.Client.Core.ILoggerAdapter {
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    public abstract virtual bool get_PiiLoggingEnabled();
    public abstract virtual bool get_IsDefaultPlatformLoggingEnabled();
    public abstract virtual string get_ClientName();
    public abstract virtual string get_ClientVersion();
    public abstract virtual IIdentityLogger get_IdentityLogger();
    public abstract virtual bool IsLoggingEnabled(LogLevel logLevel);
    public abstract virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public abstract virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public abstract virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Core.MsalLoggerExtensions : object {
    [ExtensionAttribute]
public static void Always(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void AlwaysPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void Error(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void ErrorPiiWithPrefix(ILoggerAdapter logger, Exception exWithPii, string prefix);
    [ExtensionAttribute]
public static void ErrorPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void ErrorPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void Warning(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void WarningPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void WarningPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void WarningPiiWithPrefix(ILoggerAdapter logger, Exception exWithPii, string prefix);
    [ExtensionAttribute]
public static void Info(ILoggerAdapter logger, string message);
    [ExtensionAttribute]
public static void Info(ILoggerAdapter logger, Func`1<string> messageProducer);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, string messageWithPii, string messageScrubbed);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, Func`1<string> messageWithPiiProducer, Func`1<string> messageScrubbedProducer);
    [ExtensionAttribute]
public static void InfoPii(ILoggerAdapter logger, Exception exWithPii);
    [ExtensionAttribute]
public static void Verbose(ILoggerAdapter logger, Func`1<string> messageProducer);
    [ExtensionAttribute]
public static void VerbosePii(ILoggerAdapter logger, Func`1<string> messageWithPiiProducer, Func`1<string> messageScrubbedProducer);
}
public class Microsoft.Identity.Client.DeviceCodeResult : object {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyCollection`1<string> <Scopes>k__BackingField;
    public string UserCode { get; }
    public string DeviceCode { get; }
    public string VerificationUrl { get; }
    public DateTimeOffset ExpiresOn { get; }
    public long Interval { get; }
    public string Message { get; }
    public string ClientId { get; }
    public IReadOnlyCollection`1<string> Scopes { get; }
    internal DeviceCodeResult(string userCode, string deviceCode, string verificationUrl, DateTimeOffset expiresOn, long interval, string message, string clientId, ISet`1<string> scopes);
    [CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
public string get_DeviceCode();
    [CompilerGeneratedAttribute]
public string get_VerificationUrl();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpiresOn();
    [CompilerGeneratedAttribute]
public long get_Interval();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public IReadOnlyCollection`1<string> get_Scopes();
}
public class Microsoft.Identity.Client.EmbeddedWebViewOptions : object {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WebView2BrowserExecutableFolder>k__BackingField;
    public string Title { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("In case when WebView2 is not available, MSAL.NET will fallback to legacy WebView.", "True")]
public string WebView2BrowserExecutableFolder { get; public set; }
    internal static EmbeddedWebViewOptions GetDefaultOptions();
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
    [CompilerGeneratedAttribute]
public string get_WebView2BrowserExecutableFolder();
    [CompilerGeneratedAttribute]
public void set_WebView2BrowserExecutableFolder(string value);
    internal void LogParameters(ILoggerAdapter logger);
    internal static void ValidatePlatformAvailability();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__10_0();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AbstractConfidentialClientAcquireTokenParameterBuilderExtension : object {
    [ExtensionAttribute]
public static AbstractAcquireTokenParameterBuilder`1<T> OnBeforeTokenRequest(AbstractAcquireTokenParameterBuilder`1<T> builder, Func`2<OnBeforeTokenRequestData, Task> onBeforeTokenRequestHandler);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AcquireTokenForClientBuilderExtensions : object {
    [ExtensionAttribute]
public static AcquireTokenForClientParameterBuilder WithProofOfPosessionKeyId(AcquireTokenForClientParameterBuilder builder, string keyId, string expectedTokenTypeFromAad);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.AcquireTokenInteractiveParameterBuilderExtensions : object {
    [ExtensionAttribute]
public static AcquireTokenInteractiveParameterBuilder WithCustomWebUi(AcquireTokenInteractiveParameterBuilder builder, ICustomWebUi customWebUi);
}
public class Microsoft.Identity.Client.Extensibility.AppTokenProviderParameters : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IEnumerable`1<string> Scopes { get; internal set; }
    public string CorrelationId { get; internal set; }
    public string Claims { get; internal set; }
    public string TenantId { get; internal set; }
    public CancellationToken CancellationToken { get; internal set; }
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
internal void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
internal void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
internal void set_Claims(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
internal void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
internal void set_CancellationToken(CancellationToken value);
}
public class Microsoft.Identity.Client.Extensibility.AppTokenProviderResult : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RefreshInSeconds>k__BackingField;
    public string AccessToken { get; public set; }
    public long ExpiresInSeconds { get; public set; }
    public Nullable`1<long> RefreshInSeconds { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresInSeconds();
    [CompilerGeneratedAttribute]
public void set_ExpiresInSeconds(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RefreshInSeconds();
    [CompilerGeneratedAttribute]
public void set_RefreshInSeconds(Nullable`1<long> value);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationBuilderExtensions : object {
    [ExtensionAttribute]
public static ConfidentialClientApplicationBuilder WithAppTokenProvider(ConfidentialClientApplicationBuilder builder, Func`2<AppTokenProviderParameters, Task`1<AppTokenProviderResult>> appTokenProvider);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions : object {
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Extensibility.ConfidentialClientApplicationExtensions/<StopLongRunningProcessInWebApiAsync>d__0")]
[ExtensionAttribute]
public static Task`1<bool> StopLongRunningProcessInWebApiAsync(ILongRunningWebApi clientApp, string longRunningProcessSessionKey, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Extensibility.ExternalBoundTokenScheme : object {
    private string _keyId;
    private string _tokenType;
    public TokenType TelemetryTokenType { get; }
    public string AuthorizationHeaderPrefix { get; }
    public string KeyId { get; }
    public string AccessTokenType { get; }
    public ExternalBoundTokenScheme(string keyId, string expectedTokenTypeFromEsts);
    public sealed virtual TokenType get_TelemetryTokenType();
    public sealed virtual string get_AuthorizationHeaderPrefix();
    public sealed virtual string get_KeyId();
    public sealed virtual string get_AccessTokenType();
    public sealed virtual string FormatAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public sealed virtual IDictionary`2<string, string> GetTokenRequestParams();
}
public interface Microsoft.Identity.Client.Extensibility.ICustomWebUi {
    public abstract virtual Task`1<Uri> AcquireAuthorizationCodeAsync(Uri authorizationUri, Uri redirectUri, CancellationToken cancellationToken);
}
public class Microsoft.Identity.Client.Extensibility.OnBeforeTokenRequestData : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <BodyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RequestUri>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    public IDictionary`2<string, string> BodyParameters { get; }
    public IDictionary`2<string, string> Headers { get; }
    public Uri RequestUri { get; }
    public CancellationToken CancellationToken { get; }
    public OnBeforeTokenRequestData(IDictionary`2<string, string> bodyParameters, IDictionary`2<string, string> headers, Uri requestUri, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_BodyParameters();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public Uri get_RequestUri();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
}
public class Microsoft.Identity.Client.GetAuthorizationRequestUrlParameterBuilder : AbstractConfidentialClientAcquireTokenParameterBuilder`1<GetAuthorizationRequestUrlParameterBuilder> {
    [CompilerGeneratedAttribute]
private GetAuthorizationRequestUrlParameters <Parameters>k__BackingField;
    private GetAuthorizationRequestUrlParameters Parameters { get; }
    internal GetAuthorizationRequestUrlParameterBuilder(IConfidentialClientApplicationExecutor confidentialClientApplicationexecutor);
    [CompilerGeneratedAttribute]
private GetAuthorizationRequestUrlParameters get_Parameters();
    internal static GetAuthorizationRequestUrlParameterBuilder Create(IConfidentialClientApplicationExecutor confidentialClientApplicationExecutor, IEnumerable`1<string> scopes);
    public GetAuthorizationRequestUrlParameterBuilder WithRedirectUri(string redirectUri);
    public GetAuthorizationRequestUrlParameterBuilder WithLoginHint(string loginHint);
    public GetAuthorizationRequestUrlParameterBuilder WithAccount(IAccount account);
    public GetAuthorizationRequestUrlParameterBuilder WithExtraScopesToConsent(IEnumerable`1<string> extraScopesToConsent);
    public GetAuthorizationRequestUrlParameterBuilder WithPkce(String& codeVerifier);
    public GetAuthorizationRequestUrlParameterBuilder WithCcsRoutingHint(string userObjectIdentifier, string tenantIdentifier);
    public GetAuthorizationRequestUrlParameterBuilder WithPrompt(Prompt prompt);
    internal virtual Task`1<AuthenticationResult> ExecuteInternalAsync(CancellationToken cancellationToken);
    public Task`1<Uri> ExecuteAsync(CancellationToken cancellationToken);
    public Task`1<Uri> ExecuteAsync();
    internal virtual ApiIds CalculateApiEventId();
}
internal static class Microsoft.Identity.Client.Http.HttpClientConfig : object {
    public static long MaxResponseContentBufferSizeInBytes;
    public static int MaxConnections;
    public static TimeSpan ConnectionLifeTime;
    private static HttpClientConfig();
    public static void ConfigureRequestHeadersAndSize(HttpClient httpClient);
}
internal class Microsoft.Identity.Client.Http.HttpManager : object {
    private IMsalHttpClientFactory _httpClientFactory;
    private bool _retryConfig;
    [CompilerGeneratedAttribute]
private long <LastRequestDurationInMs>k__BackingField;
    public long LastRequestDurationInMs { get; private set; }
    public HttpManager(IMsalHttpClientFactory httpClientFactory, bool retry);
    [CompilerGeneratedAttribute]
public sealed virtual long get_LastRequestDurationInMs();
    [CompilerGeneratedAttribute]
private void set_LastRequestDurationInMs(long value);
    protected virtual HttpClient GetHttpClient();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendPostAsync>d__8")]
public sealed virtual Task`1<HttpResponse> SendPostAsync(Uri endpoint, IDictionary`2<string, string> headers, IDictionary`2<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendPostAsync>d__9")]
public sealed virtual Task`1<HttpResponse> SendPostAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendGetAsync>d__10")]
public sealed virtual Task`1<HttpResponse> SendGetAsync(Uri endpoint, IDictionary`2<string, string> headers, ILoggerAdapter logger, bool retry, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendGetForceResponseAsync>d__11")]
public sealed virtual Task`1<HttpResponse> SendGetForceResponseAsync(Uri endpoint, IDictionary`2<string, string> headers, ILoggerAdapter logger, bool retry, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendPostForceResponseAsync>d__12")]
public sealed virtual Task`1<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary`2<string, string> headers, IDictionary`2<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<SendPostForceResponseAsync>d__13")]
public sealed virtual Task`1<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary`2<string, string> headers, StringContent body, ILoggerAdapter logger, CancellationToken cancellationToken);
    private HttpRequestMessage CreateRequestMessage(Uri endpoint, IDictionary`2<string, string> headers);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<ExecuteWithRetryAsync>d__15")]
private Task`1<HttpResponse> ExecuteWithRetryAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, bool doNotThrow, bool retry, CancellationToken cancellationToken);
    private static bool HasRetryAfterHeader(HttpResponse response);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<ExecuteAsync>d__17")]
private Task`1<HttpResponse> ExecuteAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, HttpMethod method, ILoggerAdapter logger, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<CreateResponseAsync>d__18")]
internal static Task`1<HttpResponse> CreateResponseAsync(HttpResponseMessage response);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Http.HttpManager/<CloneHttpContentAsync>d__19")]
private Task`1<HttpContent> CloneHttpContentAsync(HttpContent httpContent);
    private static bool IsRetryableStatusCode(int statusCode);
}
internal class Microsoft.Identity.Client.Http.HttpResponse : object {
    [CompilerGeneratedAttribute]
private HttpResponseHeaders <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpStatusCode <StatusCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UserAgent>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Body>k__BackingField;
    public HttpResponseHeaders Headers { get; public set; }
    public IDictionary`2<string, string> HeadersAsDictionary { get; }
    public HttpStatusCode StatusCode { get; public set; }
    public string UserAgent { get; public set; }
    public string Body { get; public set; }
    [CompilerGeneratedAttribute]
public HttpResponseHeaders get_Headers();
    [CompilerGeneratedAttribute]
public void set_Headers(HttpResponseHeaders value);
    public IDictionary`2<string, string> get_HeadersAsDictionary();
    [CompilerGeneratedAttribute]
public HttpStatusCode get_StatusCode();
    [CompilerGeneratedAttribute]
public void set_StatusCode(HttpStatusCode value);
    [CompilerGeneratedAttribute]
public string get_UserAgent();
    [CompilerGeneratedAttribute]
public void set_UserAgent(string value);
    [CompilerGeneratedAttribute]
public string get_Body();
    [CompilerGeneratedAttribute]
public void set_Body(string value);
}
internal interface Microsoft.Identity.Client.Http.IHttpManager {
    public long LastRequestDurationInMs { get; }
    public abstract virtual long get_LastRequestDurationInMs();
    public abstract virtual Task`1<HttpResponse> SendPostAsync(Uri endpoint, IDictionary`2<string, string> headers, IDictionary`2<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponse> SendPostAsync(Uri endpoint, IDictionary`2<string, string> headers, HttpContent body, ILoggerAdapter logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponse> SendGetAsync(Uri endpoint, IDictionary`2<string, string> headers, ILoggerAdapter logger, bool retry, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary`2<string, string> headers, StringContent body, ILoggerAdapter logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponse> SendPostForceResponseAsync(Uri uri, IDictionary`2<string, string> headers, IDictionary`2<string, string> bodyParameters, ILoggerAdapter logger, CancellationToken cancellationToken);
    public abstract virtual Task`1<HttpResponse> SendGetForceResponseAsync(Uri endpoint, IDictionary`2<string, string> headers, ILoggerAdapter logger, bool retry, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Http.RedirectUriHelper : object {
    public static void Validate(Uri redirectUri, bool usesSystemBrowser);
    public static void ValidateIosBrokerRedirectUri(Uri redirectUri, string bundleId, ILoggerAdapter logger);
}
public interface Microsoft.Identity.Client.IAccount {
    public string Username { get; }
    public string Environment { get; }
    public AccountId HomeAccountId { get; }
    public abstract virtual string get_Username();
    public abstract virtual string get_Environment();
    public abstract virtual AccountId get_HomeAccountId();
}
public interface Microsoft.Identity.Client.IAppConfig {
    public string ClientId { get; }
    public bool EnablePiiLogging { get; }
    public IMsalHttpClientFactory HttpClientFactory { get; }
    public LogLevel LogLevel { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string RedirectUri { get; }
    public string TenantId { get; }
    public LogCallback LoggingCallback { get; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; }
    public bool IsBrokerEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    [ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public ITelemetryConfig TelemetryConfig { get; }
    public bool ExperimentalFeaturesEnabled { get; }
    public IEnumerable`1<string> ClientCapabilities { get; }
    public bool LegacyCacheCompatibilityEnabled { get; }
    public string ClientSecret { get; }
    public X509Certificate2 ClientCredentialCertificate { get; }
    public Func`1<object> ParentActivityOrWindowFunc { get; }
    public abstract virtual string get_ClientId();
    public abstract virtual bool get_EnablePiiLogging();
    public abstract virtual IMsalHttpClientFactory get_HttpClientFactory();
    public abstract virtual LogLevel get_LogLevel();
    public abstract virtual bool get_IsDefaultPlatformLoggingEnabled();
    public abstract virtual string get_RedirectUri();
    public abstract virtual string get_TenantId();
    public abstract virtual LogCallback get_LoggingCallback();
    public abstract virtual IDictionary`2<string, string> get_ExtraQueryParameters();
    public abstract virtual bool get_IsBrokerEnabled();
    public abstract virtual string get_ClientName();
    public abstract virtual string get_ClientVersion();
    public abstract virtual ITelemetryConfig get_TelemetryConfig();
    public abstract virtual bool get_ExperimentalFeaturesEnabled();
    public abstract virtual IEnumerable`1<string> get_ClientCapabilities();
    public abstract virtual bool get_LegacyCacheCompatibilityEnabled();
    public abstract virtual string get_ClientSecret();
    public abstract virtual X509Certificate2 get_ClientCredentialCertificate();
    public abstract virtual Func`1<object> get_ParentActivityOrWindowFunc();
}
public interface Microsoft.Identity.Client.IApplicationBase {
}
public interface Microsoft.Identity.Client.IByRefreshToken {
    public abstract virtual AcquireTokenByRefreshTokenParameterBuilder AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
}
public interface Microsoft.Identity.Client.IClientApplicationBase {
    public IAppConfig AppConfig { get; }
    public ITokenCache UserTokenCache { get; }
    public string Authority { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use GetAccountsAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public IEnumerable`1<IUser> Users { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use WithComponent on AbstractApplicationBuilder<T> to configure this instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string Component { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ExtraQueryParameters on each call instead.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string SliceParameters { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Can be set on AbstractApplicationBuilder<T>.WithAuthority as needed.  See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public bool ValidateAuthority { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Should be set using AbstractApplicationBuilder<T>.WithRedirectUri and can be viewed with ClientApplicationBase.AppConfig.RedirectUri. See https://aka.ms/msal-net-3-breaking-changes or https://aka.ms/msal-net-application-configuration", "True")]
public string RedirectUri { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AppConfig.ClientId instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public string ClientId { get; }
    public abstract virtual IAppConfig get_AppConfig();
    public abstract virtual ITokenCache get_UserTokenCache();
    public abstract virtual string get_Authority();
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    public abstract virtual Task`1<IAccount> GetAccountAsync(string identifier);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(string userFlow);
    public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, IAccount account);
    public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    public abstract virtual Task RemoveAsync(IAccount account);
    public abstract virtual IEnumerable`1<IUser> get_Users();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAccountAsync instead and pass IAccount.HomeAccountId.Identifier (See https://aka.ms/msal-net-2-released)", "True")]
public abstract virtual IUser GetUser(string identifier);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use RemoveAccountAsync instead (See https://aka.ms/msal-net-2-released)", "True")]
public abstract virtual void Remove(IUser user);
    public abstract virtual string get_Component();
    public abstract virtual void set_Component(string value);
    public abstract virtual string get_SliceParameters();
    public abstract virtual void set_SliceParameters(string value);
    public abstract virtual bool get_ValidateAuthority();
    public abstract virtual string get_RedirectUri();
    public abstract virtual void set_RedirectUri(string value);
    [ObsoleteAttribute("Use AcquireTokenSilent instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenSilent instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenSilentAsync(IEnumerable`1<string> scopes, IAccount account, string authority, bool forceRefresh);
    public abstract virtual string get_ClientId();
}
public interface Microsoft.Identity.Client.IConfidentialClientApplication {
    public ITokenCache AppTokenCache { get; }
    public abstract virtual ITokenCache get_AppTokenCache();
    public abstract virtual AcquireTokenByAuthorizationCodeParameterBuilder AcquireTokenByAuthorizationCode(IEnumerable`1<string> scopes, string authorizationCode);
    public abstract virtual AcquireTokenForClientParameterBuilder AcquireTokenForClient(IEnumerable`1<string> scopes);
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenOnBehalfOf(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    public abstract virtual GetAuthorizationRequestUrlParameterBuilder GetAuthorizationRequestUrl(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("In confidential client apps use AcquireTokenSilent(scopes, account) instead.")]
[EditorBrowsableAttribute("1")]
public abstract virtual AcquireTokenSilentParameterBuilder AcquireTokenSilent(IEnumerable`1<string> scopes, string loginHint);
    [ObsoleteAttribute("Use GetAccountAsync(identifier) in web apps and web APIs, and use a token cache serializer for better security and performance. See https://aka.ms/msal-net-cca-token-cache-serialization.")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync();
    [ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [ObsoleteAttribute("Use AcquireTokenOnBehalfOf instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
    [ObsoleteAttribute("Use AcquireTokenByAuthorizationCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByAuthorizationCodeAsync(string authorizationCode, IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string loginHint, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use GetAuthorizationRequestUrl instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<Uri> GetAuthorizationRequestUrlAsync(IEnumerable`1<string> scopes, string redirectUri, string loginHint, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
}
public interface Microsoft.Identity.Client.IConfidentialClientApplicationWithCertificate {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenForClientWithCertificateAsync(IEnumerable`1<string> scopes, bool forceRefresh);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenForClient instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenOnBehalfOfWithCertificateAsync(IEnumerable`1<string> scopes, UserAssertion userAssertion, string authority);
}
public interface Microsoft.Identity.Client.ILongRunningWebApi {
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder InitiateLongRunningProcessInWebApi(IEnumerable`1<string> scopes, string userToken, String& longRunningProcessSessionKey);
    public abstract virtual AcquireTokenOnBehalfOfParameterBuilder AcquireTokenInLongRunningProcess(IEnumerable`1<string> scopes, string longRunningProcessSessionKey);
}
public interface Microsoft.Identity.Client.IManagedIdentityApplication {
    public ITokenCache AppTokenCache { get; }
    public abstract virtual ITokenCache get_AppTokenCache();
    public abstract virtual AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource);
}
public interface Microsoft.Identity.Client.IMsalHttpClientFactory {
    public abstract virtual HttpClient GetHttpClient();
}
internal class Microsoft.Identity.Client.Instance.AadAuthority : Authority {
    public static string DefaultTrustedHost;
    public static string AADCanonicalAuthorityTemplate;
    private static string TokenEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static ISet`1<string> s_tenantlessTenantNames;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    internal AadAuthority(AuthorityInfo authorityInfo);
    private static AadAuthority();
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
    internal bool IsWorkAndSchoolOnly();
    internal bool IsConsumers();
    internal static bool IsConsumers(string tenantId);
    internal bool IsCommonOrganizationsOrConsumersTenant();
    internal static bool IsCommonOrganizationsOrConsumersTenant(string tenantId);
    internal bool IsCommonOrOrganizationsTenant();
    internal static bool IsCommonOrOrganizationsTenant(string tenantId);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Instance.AdfsAuthority : Authority {
    private static string TokenEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    internal string TenantId { get; }
    public AdfsAuthority(AuthorityInfo authorityInfo);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceTenantless);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    internal virtual string get_TenantId();
}
[DebuggerDisplayAttribute("{AuthorityInfo.CanonicalAuthority}")]
internal abstract class Microsoft.Identity.Client.Instance.Authority : object {
    [CompilerGeneratedAttribute]
private AuthorityInfo <AuthorityInfo>k__BackingField;
    public AuthorityInfo AuthorityInfo { get; }
    internal string TenantId { get; }
    protected Authority(AuthorityInfo authorityInfo);
    [CompilerGeneratedAttribute]
public AuthorityInfo get_AuthorityInfo();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Authority/<CreateAuthorityForRequestAsync>d__4")]
public static Task`1<Authority> CreateAuthorityForRequestAsync(RequestContext requestContext, AuthorityInfo requestAuthorityInfo, IAccount account);
    public static Authority CreateAuthority(string authority, bool validateAuthority);
    public static Authority CreateAuthority(AuthorityInfo authorityInfo);
    internal static Authority CreateAuthorityWithTenant(AuthorityInfo authorityInfo, string tenantId);
    internal static Authority CreateAuthorityWithEnvironment(AuthorityInfo authorityInfo, string environment);
    internal abstract virtual string get_TenantId();
    internal abstract virtual string GetTenantedAuthority(string tenantId, bool forceTenantless);
    internal abstract virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal abstract virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal abstract virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    internal static string GetEnvironment(string authority);
}
internal class Microsoft.Identity.Client.Instance.AuthorityManager : object {
    private static ConcurrentHashSet`1<string> s_validatedEnvironments;
    private RequestContext _requestContext;
    private Authority _initialAuthority;
    private Authority _currentAuthority;
    private bool _instanceDiscoveryAndValidationExecuted;
    private InstanceDiscoveryMetadataEntry _metadata;
    public Authority OriginalAuthority { get; }
    public Authority Authority { get; }
    public AuthorityManager(RequestContext requestContext, Authority initialAuthority);
    private static AuthorityManager();
    public Authority get_OriginalAuthority();
    public Authority get_Authority();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<GetInstanceDiscoveryEntryAsync>d__11")]
public Task`1<InstanceDiscoveryMetadataEntry> GetInstanceDiscoveryEntryAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<RunInstanceDiscoveryAndValidationAsync>d__12")]
public Task RunInstanceDiscoveryAndValidationAsync();
    public static void ClearValidationCache();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.AuthorityManager/<ValidateAuthorityAsync>d__14")]
private Task ValidateAuthorityAsync(Authority authority);
}
internal class Microsoft.Identity.Client.Instance.B2CAuthority : AadAuthority {
    public static string Prefix;
    public static string B2CCanonicalAuthorityTemplate;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    internal B2CAuthority(AuthorityInfo authorityInfo);
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
    internal virtual string GetTenantedAuthority(string tenantId, bool forceTenantless);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IInstanceDiscoveryManager {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityinfo, IEnumerable`1<string> existingEnvironmentsInCache, RequestContext requestContext);
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityinfo, RequestContext requestContext, bool forceValidation);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IKnownMetadataProvider {
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable`1<string> existingEnvironmentsInCache, ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.INetworkCacheMetadataProvider {
    public abstract virtual void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry);
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger);
    public abstract virtual void Clear();
}
internal interface Microsoft.Identity.Client.Instance.Discovery.INetworkMetadataProvider {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager : object {
    private IHttpManager _httpManager;
    private IUserMetadataProvider _userMetadataProvider;
    private IKnownMetadataProvider _knownMetadataProvider;
    private INetworkCacheMetadataProvider _networkCacheMetadataProvider;
    private INetworkMetadataProvider _networkMetadataProvider;
    private IRegionDiscoveryProvider _regionDiscoveryProvider;
    public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, InstanceDiscoveryResponse userProvidedInstanceDiscoveryResponse, Uri userProvidedInstanceDiscoveryUri);
    public InstanceDiscoveryManager(IHttpManager httpManager, bool shouldClearCaches, IUserMetadataProvider userMetadataProvider, Uri userProvidedInstanceDiscoveryUri, IKnownMetadataProvider knownMetadataProvider, INetworkCacheMetadataProvider networkCacheMetadataProvider, INetworkMetadataProvider networkMetadataProvider, IRegionDiscoveryProvider regionDiscoveryProvider);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<GetMetadataEntryTryAvoidNetworkAsync>d__8")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryTryAvoidNetworkAsync(AuthorityInfo authorityInfo, IEnumerable`1<string> existingEnvironmentsInCache, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<GetMetadataEntryAsync>d__9")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataEntryAsync(AuthorityInfo authorityInfo, RequestContext requestContext, bool forceValidation);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryManager/<FetchNetworkMetadataOrFallbackAsync>d__10")]
private Task`1<InstanceDiscoveryMetadataEntry> FetchNetworkMetadataOrFallbackAsync(RequestContext requestContext, Uri authorityUri);
    internal void AddTestValueToStaticProvider(string environment, InstanceDiscoveryMetadataEntry entry);
    private static InstanceDiscoveryMetadataEntry CreateEntryForSingleAuthority(Uri authority);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryMetadataEntry : object {
    [CompilerGeneratedAttribute]
private string <PreferredNetwork>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredCache>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Aliases>k__BackingField;
    [JsonPropertyNameAttribute("preferred_network")]
public string PreferredNetwork { get; public set; }
    [JsonPropertyNameAttribute("preferred_cache")]
public string PreferredCache { get; public set; }
    [JsonPropertyNameAttribute("aliases")]
public String[] Aliases { get; public set; }
    [CompilerGeneratedAttribute]
public string get_PreferredNetwork();
    [CompilerGeneratedAttribute]
public void set_PreferredNetwork(string value);
    [CompilerGeneratedAttribute]
public string get_PreferredCache();
    [CompilerGeneratedAttribute]
public void set_PreferredCache(string value);
    [CompilerGeneratedAttribute]
public String[] get_Aliases();
    [CompilerGeneratedAttribute]
public void set_Aliases(String[] value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <TenantDiscoveryEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private InstanceDiscoveryMetadataEntry[] <Metadata>k__BackingField;
    [JsonPropertyNameAttribute("tenant_discovery_endpoint")]
public string TenantDiscoveryEndpoint { get; public set; }
    [JsonPropertyNameAttribute("metadata")]
public InstanceDiscoveryMetadataEntry[] Metadata { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TenantDiscoveryEndpoint();
    [CompilerGeneratedAttribute]
public void set_TenantDiscoveryEndpoint(string value);
    [CompilerGeneratedAttribute]
public InstanceDiscoveryMetadataEntry[] get_Metadata();
    [CompilerGeneratedAttribute]
public void set_Metadata(InstanceDiscoveryMetadataEntry[] value);
}
internal interface Microsoft.Identity.Client.Instance.Discovery.IUserMetadataProvider {
    public abstract virtual InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.Instance.Discovery.KnownMetadataProvider : object {
    private static IDictionary`2<string, InstanceDiscoveryMetadataEntry> s_knownEntries;
    private static ISet`1<string> s_knownEnvironments;
    private static ISet`1<string> s_knownPublicEnvironments;
    private static KnownMetadataProvider();
    public static bool IsPublicEnvironment(string environment);
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, IEnumerable`1<string> existingEnvironmentsInCache, ILoggerAdapter logger);
    public static bool IsKnownEnvironment(string environment);
    public static bool TryGetKnownEnviromentPreferredNetwork(string environment, String& preferredNetworkEnvironment);
    public static IDictionary`2<string, InstanceDiscoveryMetadataEntry> GetAllEntriesForTest();
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddToKnownCache|3_0(InstanceDiscoveryMetadataEntry entry);
    [CompilerGeneratedAttribute]
internal static void <.cctor>g__AddToPublicEnvironment|3_1(InstanceDiscoveryMetadataEntry entry);
}
internal class Microsoft.Identity.Client.Instance.Discovery.NetworkCacheMetadataProvider : object {
    private static ConcurrentDictionary`2<string, InstanceDiscoveryMetadataEntry> s_cache;
    private static NetworkCacheMetadataProvider();
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadata(string environment, ILoggerAdapter logger);
    public sealed virtual void AddMetadata(string environment, InstanceDiscoveryMetadataEntry entry);
    public sealed virtual void Clear();
}
internal class Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider : object {
    private IHttpManager _httpManager;
    private INetworkCacheMetadataProvider _networkCacheMetadataProvider;
    private Uri _userProvidedInstanceDiscoveryUri;
    public NetworkMetadataProvider(IHttpManager httpManager, INetworkCacheMetadataProvider networkCacheMetadataProvider, Uri userProvidedInstanceDiscoveryUri);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<GetMetadataAsync>d__4")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
    private void CacheInstanceDiscoveryMetadata(InstanceDiscoveryResponse instanceDiscoveryResponse);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<FetchAllDiscoveryMetadataAsync>d__6")]
private Task`1<InstanceDiscoveryResponse> FetchAllDiscoveryMetadataAsync(Uri authority, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Discovery.NetworkMetadataProvider/<SendInstanceDiscoveryRequestAsync>d__7")]
private Task`1<InstanceDiscoveryResponse> SendInstanceDiscoveryRequestAsync(Uri authority, RequestContext requestContext);
    private Uri ComputeHttpEndpoint(Uri authority, RequestContext requestContext);
    private static string BuildAuthorizeEndpoint(Uri authority);
    private static string GetTenant(Uri uri);
}
internal class Microsoft.Identity.Client.Instance.Discovery.UserMetadataProvider : object {
    private IDictionary`2<string, InstanceDiscoveryMetadataEntry> _entries;
    public UserMetadataProvider(InstanceDiscoveryResponse instanceDiscoveryResponse);
    public sealed virtual InstanceDiscoveryMetadataEntry GetMetadataOrThrow(string environment, ILoggerAdapter logger);
}
internal class Microsoft.Identity.Client.Instance.DstsAuthority : Authority {
    public static string DstsCanonicalAuthorityTemplate;
    private static string TokenEndpointTemplate;
    private static string AuthorizationEndpointTemplate;
    private static string DeviceCodeEndpointTemplate;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    internal string TenantId { get; }
    public DstsAuthority(AuthorityInfo authorityInfo);
    internal virtual string GetTenantedAuthority(string tenantId, bool forceSpecifiedTenant);
    internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
    [CompilerGeneratedAttribute]
internal virtual string get_TenantId();
}
internal class Microsoft.Identity.Client.Instance.GenericAuthority : Authority {
    internal string TenantId { get; }
    internal GenericAuthority(AuthorityInfo authorityInfo);
    internal virtual string get_TenantId();
    internal virtual string GetTenantedAuthority(string tenantId, bool forceTenantless);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.GenericAuthority/<GetTokenEndpointAsync>d__4")]
internal virtual Task`1<string> GetTokenEndpointAsync(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.GenericAuthority/<GetAuthorizationEndpointAsync>d__5")]
internal virtual Task`1<string> GetAuthorizationEndpointAsync(RequestContext requestContext);
    internal virtual Task`1<string> GetDeviceCodeEndpointAsync(RequestContext requestContext);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Oidc.OidcMetadata : object {
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorizationEndpoint>k__BackingField;
    [JsonPropertyNameAttribute("token_endpoint")]
public string TokenEndpoint { get; public set; }
    [JsonPropertyNameAttribute("authorization_endpoint")]
public string AuthorizationEndpoint { get; public set; }
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorizationEndpoint();
    [CompilerGeneratedAttribute]
public void set_AuthorizationEndpoint(string value);
}
internal static class Microsoft.Identity.Client.Instance.Oidc.OidcRetrieverWithCache : object {
    private static ConcurrentDictionary`2<string, OidcMetadata> s_cache;
    private static SemaphoreSlim s_lockOidcRetrieval;
    private static OidcRetrieverWithCache();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Oidc.OidcRetrieverWithCache/<GetOidcAsync>d__2")]
public static Task`1<OidcMetadata> GetOidcAsync(string authority, RequestContext requestContext);
    public static void ResetCacheForTest();
}
internal class Microsoft.Identity.Client.Instance.Validation.AadAuthorityValidator : object {
    private RequestContext _requestContext;
    public AadAuthorityValidator(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Validation.AadAuthorityValidator/<ValidateAuthorityAsync>d__2")]
public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
internal class Microsoft.Identity.Client.Instance.Validation.AdfsAuthorityValidator : object {
    private RequestContext _requestContext;
    public AdfsAuthorityValidator(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Instance.Validation.AdfsAuthorityValidator/<ValidateAuthorityAsync>d__2")]
public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Validation.AdfsWebFingerResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<LinksList> <Links>k__BackingField;
    [JsonPropertyNameAttribute("subject")]
public string Subject { get; public set; }
    [JsonPropertyNameAttribute("links")]
public List`1<LinksList> Links { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(string value);
    [CompilerGeneratedAttribute]
public List`1<LinksList> get_Links();
    [CompilerGeneratedAttribute]
public void set_Links(List`1<LinksList> value);
}
internal class Microsoft.Identity.Client.Instance.Validation.AdfsWebFingerResponseClaim : OAuth2ResponseBaseClaim {
    public static string Subject;
    public static string Links;
    public static string Rel;
    public static string Href;
}
internal interface Microsoft.Identity.Client.Instance.Validation.IAuthorityValidator {
    public abstract virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Instance.Validation.LinksList : object {
    [CompilerGeneratedAttribute]
private string <Rel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Href>k__BackingField;
    [JsonPropertyNameAttribute("rel")]
public string Rel { get; public set; }
    [JsonPropertyNameAttribute("href")]
public string Href { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Rel();
    [CompilerGeneratedAttribute]
public void set_Rel(string value);
    [CompilerGeneratedAttribute]
public string get_Href();
    [CompilerGeneratedAttribute]
public void set_Href(string value);
}
internal class Microsoft.Identity.Client.Instance.Validation.NullAuthorityValidator : object {
    public sealed virtual Task ValidateAuthorityAsync(AuthorityInfo authorityInfo);
}
internal class Microsoft.Identity.Client.Internal.AuthCodeRequestComponent : object {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private IServiceBundle _serviceBundle;
    public AuthCodeRequestComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<FetchAuthCodeAndPkceVerifierAsync>d__4")]
public sealed virtual Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<GetAuthorizationUriWithoutPkceAsync>d__5")]
public sealed virtual Task`1<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<GetAuthorizationUriWithPkceAsync>d__6")]
public Task`1<Uri> GetAuthorizationUriWithPkceAsync(string codeVerifier, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.AuthCodeRequestComponent/<FetchAuthCodeAndPkceInternalAsync>d__7")]
private Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceInternalAsync(IWebUI webUi, CancellationToken cancellationToken);
    private Tuple`2<Uri, string> CreateAuthorizationUriWithCodeChallenge(string authEndpoint, string codeVerifier);
    private Tuple`3<Uri, string, string> CreateAuthorizationUri(string authEndpoint, bool addPkceAndState);
    private UriBuilder CreateInteractiveRequestParameters(string authEndpoint, IDictionary`2<string, string> requestParameters);
    private Dictionary`2<string, string> CreateAuthorizationRequestParameters(Uri redirectUriOverride);
    private static void CheckForDuplicateQueryParameters(IDictionary`2<string, string> queryParamsDictionary, IDictionary`2<string, string> requestParameters);
    private void VerifyAuthorizationResult(AuthorizationResult authorizationResult, string originalState);
    private IWebUI CreateWebAuthenticationDialog();
}
internal class Microsoft.Identity.Client.Internal.Broker.BrokerInteractiveRequestComponent : object {
    [CompilerGeneratedAttribute]
private IBroker <Broker>k__BackingField;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private string _optionalBrokerInstallUrl;
    private AuthenticationRequestParameters _authenticationRequestParameters;
    private IServiceBundle _serviceBundle;
    private ILoggerAdapter _logger;
    internal IBroker Broker { get; }
    public BrokerInteractiveRequestComponent(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters, IBroker broker, string optionalBrokerInstallUrl);
    [CompilerGeneratedAttribute]
internal IBroker get_Broker();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Broker.BrokerInteractiveRequestComponent/<FetchTokensAsync>d__9")]
public sealed virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
    internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse);
    public static bool IsBrokerRequiredAuthCode(string authCode, String& installationUri);
    private static string ExtractAppLink(string authCode);
}
internal class Microsoft.Identity.Client.Internal.Broker.BrokerParameter : object {
    public static string Authority;
    public static string ClientId;
    public static string Scope;
    public static string ExtraOidcScopes;
    public static string OidcScopesValue;
    public static string RedirectUri;
    public static string BrokerKey;
    public static string ClientVersion;
    public static string MsgProtocolVersion;
    public static string MsgProtocolVersion3;
    public static string SkipCache;
    public static string AppLink;
    public static string IsSilentBrokerRequest;
    public static string CorrelationId;
    public static string ExtraQp;
    public static string HomeAccountId;
    public static string LocalAccountId;
    public static string Username;
    public static string IntuneEnrollmentIds;
    public static string IntuneMamResource;
    public static string ClientCapabilities;
    public static string ClientAppName;
    public static string ClientAppVersion;
    public static string Claims;
    public static string ExtraConsentScopes;
    public static string Prompt;
    public static string BrokerAccountName;
    public static string ForceRefresh;
    public static string Force;
    public static string BrokerInstallUrl;
    public static string UriSchemeBrokerV2;
    public static string UriSchemeBrokerV3;
    public static string AuthCodePrefixForEmbeddedWebviewBrokerInstallRequired;
}
internal static class Microsoft.Identity.Client.Internal.Broker.BrokerResponseConst : object {
    public static string ErrorMetadata;
    public static string BrokerErrorDomain;
    public static string BrokerErrorCode;
    public static string BrokerErrorDescription;
    public static string BrokerSubError;
    public static string BrokerHttpHeaders;
    public static string BrokerHttpBody;
    public static string BrokerHttpStatusCode;
    public static string BrokerErrorMessage;
    public static string Authority;
    public static string AccessToken;
    public static string ClientId;
    public static string RefreshToken;
    public static string IdToken;
    public static string Bearer;
    public static string CorrelationId;
    public static string Scope;
    public static string AndroidScopes;
    public static string ExpiresOn;
    public static string ExtendedExpiresOn;
    public static string ClientInfo;
    public static string Account;
    public static string HomeAccountId;
    public static string LocalAccountId;
    public static string TenantId;
    public static string UserName;
    public static string iOSBrokerNonce;
    public static string iOSBrokerTenantId;
    public static string Environment;
    public static string iOSBrokerUserCancellationErrorCode;
    public static string iOSBrokerProtectionPoliciesRequiredErrorCode;
    public static string TokenType;
    public static string AndroidNoTokenFound;
    public static string AndroidNoAccountFound;
    public static string AndroidUnauthorizedClient;
    public static string AndroidInvalidRefreshToken;
    public static string AndroidProtectionPolicyRequired;
}
internal interface Microsoft.Identity.Client.Internal.Broker.IBroker {
    public bool IsPopSupported { get; }
    public abstract virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public abstract virtual Task`1<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);
    public abstract virtual void HandleInstallUrl(string appLink);
    public abstract virtual Task`1<IReadOnlyList`1<IAccount>> GetAccountsAsync(string clientId, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);
    public abstract virtual Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account);
    public abstract virtual bool get_IsPopSupported();
}
internal interface Microsoft.Identity.Client.Internal.Broker.ITokenRequestComponent {
    public abstract virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Broker.NullBroker : object {
    private ILoggerAdapter _logger;
    public bool IsPopSupported { get; }
    public NullBroker(ILoggerAdapter logger);
    public sealed virtual bool get_IsPopSupported();
    public virtual bool IsBrokerInstalledAndInvokable(AuthorityType authorityType);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenInteractiveAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenInteractiveParameters acquireTokenInteractiveParameters);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual void HandleInstallUrl(string appLink);
    public sealed virtual Task RemoveAccountAsync(ApplicationConfiguration appConfig, IAccount account);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenSilentDefaultUserAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters acquireTokenSilentParameters);
    public sealed virtual Task`1<IReadOnlyList`1<IAccount>> GetAccountsAsync(string clientID, string redirectUri, AuthorityInfo authorityInfo, ICacheSessionManager cacheSessionManager, IInstanceDiscoveryManager instanceDiscoveryManager);
    public sealed virtual Task`1<MsalTokenResponse> AcquireTokenByUsernamePasswordAsync(AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters acquireTokenByUsernamePasswordParameters);
}
internal static class Microsoft.Identity.Client.Internal.ClaimsHelper : object {
    private static string AccessTokenClaim;
    private static string XmsClientCapability;
    internal static string GetMergedClaimsAndClientCapabilities(string claims, IEnumerable`1<string> clientCapabilities);
    internal static JsonObject MergeClaimsIntoCapabilityJson(string claims, JsonObject capabilitiesJson);
    private static JsonObject CreateClientCapabilitiesRequestJson(IEnumerable`1<string> clientCapabilities);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.CertificateAndClaimsClientCredential : object {
    private IDictionary`2<string, string> _claimsToSign;
    private bool _appendDefaultClaims;
    private string _base64EncodedThumbprint;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; }
    public CertificateAndClaimsClientCredential(X509Certificate2 certificate, IDictionary`2<string, string> claimsToSign, bool appendDefaultClaims);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.CertificateClientCredential : CertificateAndClaimsClientCredential {
    public CertificateClientCredential(X509Certificate2 certificate);
}
internal interface Microsoft.Identity.Client.Internal.ClientCredential.IClientCredential {
    public abstract virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SecretStringClientCredential : object {
    [CompilerGeneratedAttribute]
private string <Secret>k__BackingField;
    internal string Secret { get; }
    public SecretStringClientCredential(string secret);
    [CompilerGeneratedAttribute]
internal string get_Secret();
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionClientCredential : object {
    private string _signedAssertion;
    public SignedAssertionClientCredential(string signedAssertion);
    public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionDelegateClientCredential : object {
    [CompilerGeneratedAttribute]
private Func`2<CancellationToken, Task`1<string>> <_signedAssertionDelegate>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<AssertionRequestOptions, Task`1<string>> <_signedAssertionWithInfoDelegate>k__BackingField;
    internal Func`2<CancellationToken, Task`1<string>> _signedAssertionDelegate { get; }
    internal Func`2<AssertionRequestOptions, Task`1<string>> _signedAssertionWithInfoDelegate { get; }
    [EditorBrowsableAttribute("1")]
public SignedAssertionDelegateClientCredential(Func`2<CancellationToken, Task`1<string>> signedAssertionDelegate);
    public SignedAssertionDelegateClientCredential(Func`2<AssertionRequestOptions, Task`1<string>> signedAssertionDelegate);
    [CompilerGeneratedAttribute]
internal Func`2<CancellationToken, Task`1<string>> get__signedAssertionDelegate();
    [CompilerGeneratedAttribute]
internal Func`2<AssertionRequestOptions, Task`1<string>> get__signedAssertionWithInfoDelegate();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.ClientCredential.SignedAssertionDelegateClientCredential/<AddConfidentialClientParametersAsync>d__8")]
public sealed virtual Task AddConfidentialClientParametersAsync(OAuth2Client oAuth2Client, ILoggerAdapter logger, ICryptographyManager cryptographyManager, string clientId, string tokenEndpoint, bool sendX5C, CancellationToken cancellationToken);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Internal.ClientInfo : object {
    [CompilerGeneratedAttribute]
private string <UniqueObjectIdentifier>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UniqueTenantIdentifier>k__BackingField;
    [JsonPropertyNameAttribute("uid")]
public string UniqueObjectIdentifier { get; public set; }
    [JsonPropertyNameAttribute("utid")]
public string UniqueTenantIdentifier { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UniqueObjectIdentifier();
    [CompilerGeneratedAttribute]
public void set_UniqueObjectIdentifier(string value);
    [CompilerGeneratedAttribute]
public string get_UniqueTenantIdentifier();
    [CompilerGeneratedAttribute]
public void set_UniqueTenantIdentifier(string value);
    public static ClientInfo CreateFromJson(string clientInfo);
    public string ToAccountIdentifier();
}
internal static class Microsoft.Identity.Client.Internal.ClientInfoClaim : object {
    public static string UniqueIdentifier;
    public static string UniqueTenantIdentifier;
}
internal static class Microsoft.Identity.Client.Internal.Constants : object {
    public static string MsAppScheme;
    public static int ExpirationMarginInMinutes;
    public static int CodeVerifierLength;
    public static int CodeVerifierByteSize;
    public static string UapWEBRedirectUri;
    public static string DefaultRedirectUri;
    public static string NativeClientRedirectUri;
    public static string LocalHostRedirectUri;
    public static string DefaultConfidentialClientRedirectUri;
    public static string DefaultRealm;
    public static string MsaTenantId;
    public static string ConsumerTenant;
    public static string OrganizationsTenant;
    public static string CommonTenant;
    public static string UserRealmMsaDomainName;
    public static string CcsRoutingHintHeader;
    public static string AadThrottledErrorCode;
    public static int DefaultJitterRangeInSeconds;
    public static TimeSpan AccessTokenExpirationBuffer;
    public static string EnableSpaAuthCode;
    public static string PoPTokenType;
    public static string PoPAuthHeaderPrefix;
    public static string RequestConfirmation;
    public static string BearerAuthHeaderPrefix;
    public static string ManagedIdentityClientId;
    public static string ManagedIdentityResourceId;
    public static string ManagedIdentityDefaultClientId;
    public static string ManagedIdentityDefaultTenant;
    public static string WellKnownOpenIdConfigurationPath;
    public static string OpenIdConfigurationEndpoint;
    public static string Tenant;
    public static string TenantId;
    private static Constants();
    public static string FormatEnterpriseRegistrationOnPremiseUri(string domain);
    public static string FormatEnterpriseRegistrationInternetUri(string domain);
    public static string FormatAdfsWebFingerUrl(string host, string resource);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Internal.DeviceCodeResponse : OAuth2ResponseBase {
    [CompilerGeneratedAttribute]
private string <UserCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DeviceCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <VerificationUri>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <Interval>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [JsonPropertyNameAttribute("user_code")]
public string UserCode { get; public set; }
    [JsonPropertyNameAttribute("device_code")]
public string DeviceCode { get; public set; }
    [JsonPropertyNameAttribute("verification_url")]
public string VerificationUrl { get; public set; }
    [JsonPropertyNameAttribute("verification_uri")]
public string VerificationUri { get; public set; }
    [JsonPropertyNameAttribute("expires_in")]
[JsonNumberHandlingAttribute("1")]
public long ExpiresIn { get; public set; }
    [JsonPropertyNameAttribute("interval")]
[JsonNumberHandlingAttribute("1")]
public long Interval { get; public set; }
    [JsonPropertyNameAttribute("message")]
public string Message { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserCode();
    [CompilerGeneratedAttribute]
public void set_UserCode(string value);
    [CompilerGeneratedAttribute]
public string get_DeviceCode();
    [CompilerGeneratedAttribute]
public void set_DeviceCode(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUrl();
    [CompilerGeneratedAttribute]
public void set_VerificationUrl(string value);
    [CompilerGeneratedAttribute]
public string get_VerificationUri();
    [CompilerGeneratedAttribute]
public void set_VerificationUri(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(long value);
    [CompilerGeneratedAttribute]
public long get_Interval();
    [CompilerGeneratedAttribute]
public void set_Interval(long value);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    public DeviceCodeResult GetResult(string clientId, ISet`1<string> scopes);
}
internal interface Microsoft.Identity.Client.Internal.IAuthCodeRequestComponent {
    public abstract virtual Task`1<Tuple`2<AuthorizationResult, string>> FetchAuthCodeAndPkceVerifierAsync(CancellationToken cancellationToken);
    public abstract virtual Task`1<Uri> GetAuthorizationUriWithoutPkceAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.IdToken : object {
    private static string DefaultIssuser;
    [CompilerGeneratedAttribute]
private string <ObjectId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Subject>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <PreferredUsername>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <GivenName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyName>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsPrincipal <ClaimsPrincipal>k__BackingField;
    public string ObjectId { get; private set; }
    public string Subject { get; private set; }
    public string TenantId { get; private set; }
    public string PreferredUsername { get; private set; }
    public string Name { get; private set; }
    public string Upn { get; private set; }
    public string GivenName { get; private set; }
    public string FamilyName { get; private set; }
    public ClaimsPrincipal ClaimsPrincipal { get; private set; }
    [CompilerGeneratedAttribute]
public string get_ObjectId();
    [CompilerGeneratedAttribute]
private void set_ObjectId(string value);
    [CompilerGeneratedAttribute]
public string get_Subject();
    [CompilerGeneratedAttribute]
private void set_Subject(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
private void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_PreferredUsername();
    [CompilerGeneratedAttribute]
private void set_PreferredUsername(string value);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
private void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_GivenName();
    [CompilerGeneratedAttribute]
private void set_GivenName(string value);
    [CompilerGeneratedAttribute]
public string get_FamilyName();
    [CompilerGeneratedAttribute]
private void set_FamilyName(string value);
    public string GetUniqueId();
    [CompilerGeneratedAttribute]
public ClaimsPrincipal get_ClaimsPrincipal();
    [CompilerGeneratedAttribute]
private void set_ClaimsPrincipal(ClaimsPrincipal value);
    public static IdToken Parse(string idToken);
    private static List`1<Claim> GetClaimsFromRawToken(JsonDocument jsonDocument);
    private static void AddClaimsFromJToken(List`1<Claim> claims, string claimType, JsonElement jtoken, string issuer);
    private static void AddDefaultClaimFromJToken(List`1<Claim> claims, string claimType, JsonElement jtoken, string issuer);
    private static string GetClaimValueType(JsonElement obj);
}
internal static class Microsoft.Identity.Client.Internal.IdTokenClaim : object {
    public static string Issuer;
    public static string ObjectId;
    public static string Subject;
    public static string TenantId;
    public static string Version;
    public static string PreferredUsername;
    public static string Name;
    public static string HomeObjectId;
    public static string GivenName;
    public static string FamilyName;
    public static string Upn;
}
internal interface Microsoft.Identity.Client.Internal.IServiceBundle {
    public ApplicationConfiguration Config { get; }
    public ILoggerAdapter ApplicationLogger { get; }
    public IHttpManager HttpManager { get; }
    public IInstanceDiscoveryManager InstanceDiscoveryManager { get; }
    public IPlatformProxy PlatformProxy { get; }
    public IWsTrustWebRequestManager WsTrustWebRequestManager { get; }
    public IDeviceAuthManager DeviceAuthManager { get; }
    public IThrottlingProvider ThrottlingManager { get; }
    public IHttpTelemetryManager HttpTelemetryManager { get; }
    public abstract virtual ApplicationConfiguration get_Config();
    public abstract virtual ILoggerAdapter get_ApplicationLogger();
    public abstract virtual IHttpManager get_HttpManager();
    public abstract virtual IInstanceDiscoveryManager get_InstanceDiscoveryManager();
    public abstract virtual IPlatformProxy get_PlatformProxy();
    public abstract virtual IWsTrustWebRequestManager get_WsTrustWebRequestManager();
    public abstract virtual IDeviceAuthManager get_DeviceAuthManager();
    public abstract virtual IThrottlingProvider get_ThrottlingManager();
    public abstract virtual IHttpTelemetryManager get_HttpTelemetryManager();
    public abstract virtual void SetPlatformProxyForTest(IPlatformProxy platformProxy);
}
internal static class Microsoft.Identity.Client.Internal.JsonClaimValueTypes : object {
    public static string Json;
    public static string JsonArray;
    public static string JsonNull;
}
internal class Microsoft.Identity.Client.Internal.JsonWebToken : object {
    private static int MaxTokenLength;
    public JWTPayload Payload;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ClaimsToSign>k__BackingField;
    private ICryptographyManager _cryptographyManager;
    private bool _appendDefaultClaims;
    public IDictionary`2<string, string> ClaimsToSign { get; private set; }
    public long ValidTo { get; }
    public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience);
    public JsonWebToken(ICryptographyManager cryptographyManager, string clientId, string audience, IDictionary`2<string, string> claimsToSign, bool appendDefaultClaims);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ClaimsToSign();
    [CompilerGeneratedAttribute]
private void set_ClaimsToSign(IDictionary`2<string, string> value);
    public long get_ValidTo();
    public string Sign(X509Certificate2 certificate, string base64EncodedThumbprint, bool sendX5C);
    private static string EncodeSegment(string segment);
    private static string UrlEncodeSegment(Byte[] segment);
    private static string EncodeHeaderToJson(X509Certificate2 certificate, string base64EncodedThumbprint, bool sendX5C);
    internal static long ConvertToTimeT(DateTime time);
    private string Encode(X509Certificate2 certificate, string base64EncodedThumbprint, bool sendCertificate);
}
internal class Microsoft.Identity.Client.Internal.JsonWebTokenConstants : object {
    public static UInt32 JwtToAadLifetimeInSeconds;
    public static string JWTHeaderType;
}
internal class Microsoft.Identity.Client.Internal.Logger.CallbackIdentityLogger : object {
    private LogCallback _logCallback;
    private string _correlationId;
    private string _clientInformation;
    private bool _piiLoggingEnabled;
    private LogLevel _minLogLevel;
    public CallbackIdentityLogger(LogCallback logCallback, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging, LogLevel minLogLevel);
    public sealed virtual bool IsEnabled(EventLogLevel eventLevel);
    public sealed virtual void Log(LogEntry entry);
    private LogLevel GetLogLevel(EventLogLevel eventLogLevel);
}
internal class Microsoft.Identity.Client.Internal.Logger.CallbackIdentityLoggerAdapter : object {
    private string _correlationId;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    internal CallbackIdentityLoggerAdapter(Guid correlationId, string clientName, string clientVersion, LogLevel logLevel, bool enablePiiLogging, bool isDefaultPlatformLoggingEnabled, LogCallback loggingCallback);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config, bool isDefaultPlatformLoggingEnabled);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal class Microsoft.Identity.Client.Internal.Logger.DurationLogHelper : object {
    private ILoggerAdapter _logger;
    private string _measuredBlockName;
    private LogLevel _logLevel;
    private Stopwatch _stopwatch;
    public DurationLogHelper(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel);
    public sealed virtual void Dispose();
}
internal class Microsoft.Identity.Client.Internal.Logger.IdentityLogger : object {
    private IIdentityLogger _identityLogger;
    private string _correlationId;
    private string _clientInformation;
    private bool _piiLoggingEnabled;
    internal IdentityLogger(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging);
    public sealed virtual bool IsEnabled(EventLogLevel eventLevel);
    public sealed virtual void Log(LogEntry entry);
}
internal class Microsoft.Identity.Client.Internal.Logger.IdentityLoggerAdapter : object {
    private string _correlationId;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public bool PiiLoggingEnabled { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public string ClientName { get; }
    public string ClientVersion { get; }
    public IIdentityLogger IdentityLogger { get; }
    internal IdentityLoggerAdapter(IIdentityLogger identityLogger, Guid correlationId, string clientName, string clientVersion, bool enablePiiLogging);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public static ILoggerAdapter Create(Guid correlationId, ApplicationConfiguration config);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal class Microsoft.Identity.Client.Internal.Logger.LoggerHelper : object {
    private static Lazy`1<string> s_msalVersionLazy;
    private static Lazy`1<string> s_runtimeVersionLazy;
    private static Lazy`1<ILoggerAdapter> s_nullLogger;
    private static Lazy`1<string> s_osLazy;
    private static Lazy`1<string> s_skuLazy;
    public static ILoggerAdapter NullLogger { get; }
    private static LoggerHelper();
    public static string GetClientInfo(string clientName, string clientVersion);
    public static ILoggerAdapter CreateLogger(Guid correlationId, ApplicationConfiguration config);
    public static ILoggerAdapter get_NullLogger();
    public static string FormatLogMessage(string message, bool piiEnabled, string correlationId, string clientInformation);
    internal static string GetPiiScrubbedExceptionDetails(Exception ex);
    public static DurationLogHelper LogBlockDuration(ILoggerAdapter logger, string measuredBlockName, LogLevel logLevel);
    public static DurationLogHelper LogMethodDuration(ILoggerAdapter logger, LogLevel logLevel, string methodName, string filePath);
    public static EventLogLevel GetEventLogLevel(LogLevel logLevel);
    public static string GetMessageToLog(string messageWithPii, string messageScrubbed, bool piiLoggingEnabled);
}
internal class Microsoft.Identity.Client.Internal.Logger.NullLogger : object {
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsDefaultPlatformLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    public string ClientName { get; }
    public string ClientVersion { get; }
    public Guid CorrelationId { get; }
    public bool PiiLoggingEnabled { get; }
    public string ClientInformation { get; }
    public bool IsDefaultPlatformLoggingEnabled { get; }
    public IIdentityLogger IdentityLogger { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientName();
    [CompilerGeneratedAttribute]
public sealed virtual string get_ClientVersion();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public string get_ClientInformation();
    [CompilerGeneratedAttribute]
public sealed virtual bool get_IsDefaultPlatformLoggingEnabled();
    [CompilerGeneratedAttribute]
public sealed virtual IIdentityLogger get_IdentityLogger();
    public sealed virtual bool IsLoggingEnabled(LogLevel logLevel);
    public sealed virtual void Log(LogLevel logLevel, string messageWithPii, string messageScrubbed);
    public sealed virtual DurationLogHelper LogBlockDuration(string measuredBlockName, LogLevel logLevel);
    public sealed virtual DurationLogHelper LogMethodDuration(LogLevel logLevel, string methodName, string filePath);
}
internal static class Microsoft.Identity.Client.Internal.MsalIdHelper : object {
    private static Lazy`1<string> s_msalVersion;
    private static MsalIdHelper();
    public static IDictionary`2<string, string> GetMsalIdParameters(ILoggerAdapter logger);
    public static string GetMsalVersion();
}
internal static class Microsoft.Identity.Client.Internal.MsalIdParameter : object {
    public static string Product;
    public static string Version;
    public static string CpuPlatform;
    public static string OS;
    public static string DeviceModel;
}
internal class Microsoft.Identity.Client.Internal.RequestContext : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerAdapter <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiEvent <ApiEvent>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <UserCancellationToken>k__BackingField;
    public Guid CorrelationId { get; }
    public ILoggerAdapter Logger { get; }
    public IServiceBundle ServiceBundle { get; }
    public ApiEvent ApiEvent { get; public set; }
    public CancellationToken UserCancellationToken { get; }
    public RequestContext(IServiceBundle serviceBundle, Guid correlationId, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public ILoggerAdapter get_Logger();
    [CompilerGeneratedAttribute]
public IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
public ApiEvent get_ApiEvent();
    [CompilerGeneratedAttribute]
public void set_ApiEvent(ApiEvent value);
    [CompilerGeneratedAttribute]
public CancellationToken get_UserCancellationToken();
    public TelemetryHelper CreateTelemetryHelper(ApiEvent eventToStart);
}
internal class Microsoft.Identity.Client.Internal.Requests.AuthCodeExchangeComponent : object {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private string _authorizationCode;
    private string _pkceCodeVerifier;
    private TokenClient _tokenClient;
    private string _clientInfo;
    public AuthCodeExchangeComponent(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, string authorizationCode, string pkceCodeVerifier, string clientInfo);
    public sealed virtual Task`1<MsalTokenResponse> FetchTokensAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
    private void AddCcsHeadersToTokenClient();
}
internal class Microsoft.Identity.Client.Internal.Requests.AuthenticationRequestParameters : object {
    private IServiceBundle _serviceBundle;
    private AcquireTokenCommonParameters _commonParameters;
    private string _loginHint;
    [CompilerGeneratedAttribute]
private RequestContext <RequestContext>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthorityManager <AuthorityManager>k__BackingField;
    [CompilerGeneratedAttribute]
private ICacheSessionManager <CacheSessionManager>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <RedirectUri>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <ExtraQueryParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClaimsAndClientCapabilities>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SendX5C>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HomeAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private UserAssertion <UserAssertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <LongRunningOboCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<KeyValuePair`2<string, string>> <CcsRoutingHint>k__BackingField;
    public ApplicationConfiguration AppConfig { get; }
    public ApiIds ApiId { get; }
    public RequestContext RequestContext { get; }
    public AuthorityManager AuthorityManager { get; public set; }
    public Authority Authority { get; }
    public AuthorityInfo AuthorityInfo { get; }
    public AuthorityInfo AuthorityOverride { get; }
    public ICacheSessionManager CacheSessionManager { get; }
    public HashSet`1<string> Scope { get; }
    public Uri RedirectUri { get; public set; }
    public IDictionary`2<string, string> ExtraQueryParameters { get; }
    public string ClaimsAndClientCapabilities { get; private set; }
    public Guid CorrelationId { get; }
    public string Claims { get; }
    public IAuthenticationScheme AuthenticationScheme { get; }
    public bool SendX5C { get; public set; }
    public string LoginHint { get; public set; }
    public IAccount Account { get; public set; }
    public string HomeAccountId { get; }
    public Func`2<OnBeforeTokenRequestData, Task> OnBeforeTokenRequestHandler { get; }
    public IDictionary`2<string, string> ExtraHttpHeaders { get; }
    public bool IsClientCredentialRequest { get; }
    public PoPAuthenticationConfiguration PopAuthenticationConfiguration { get; }
    public UserAssertion UserAssertion { get; public set; }
    public string LongRunningOboCacheKey { get; public set; }
    public Nullable`1<KeyValuePair`2<string, string>> CcsRoutingHint { get; public set; }
    public AuthenticationRequestParameters(IServiceBundle serviceBundle, ITokenCacheInternal tokenCache, AcquireTokenCommonParameters commonParameters, RequestContext requestContext, Authority initialAuthority, string homeAccountId);
    public ApplicationConfiguration get_AppConfig();
    public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public RequestContext get_RequestContext();
    [CompilerGeneratedAttribute]
public AuthorityManager get_AuthorityManager();
    [CompilerGeneratedAttribute]
public void set_AuthorityManager(AuthorityManager value);
    public Authority get_Authority();
    public AuthorityInfo get_AuthorityInfo();
    public AuthorityInfo get_AuthorityOverride();
    [CompilerGeneratedAttribute]
public ICacheSessionManager get_CacheSessionManager();
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_Scope();
    [CompilerGeneratedAttribute]
public Uri get_RedirectUri();
    [CompilerGeneratedAttribute]
public void set_RedirectUri(Uri value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_ExtraQueryParameters();
    [CompilerGeneratedAttribute]
public string get_ClaimsAndClientCapabilities();
    [CompilerGeneratedAttribute]
private void set_ClaimsAndClientCapabilities(string value);
    public Guid get_CorrelationId();
    public string get_Claims();
    public IAuthenticationScheme get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
public bool get_SendX5C();
    [CompilerGeneratedAttribute]
public void set_SendX5C(bool value);
    public string get_LoginHint();
    public void set_LoginHint(string value);
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public void set_Account(IAccount value);
    [CompilerGeneratedAttribute]
public string get_HomeAccountId();
    public Func`2<OnBeforeTokenRequestData, Task> get_OnBeforeTokenRequestHandler();
    public IDictionary`2<string, string> get_ExtraHttpHeaders();
    public bool get_IsClientCredentialRequest();
    public PoPAuthenticationConfiguration get_PopAuthenticationConfiguration();
    [CompilerGeneratedAttribute]
public UserAssertion get_UserAssertion();
    [CompilerGeneratedAttribute]
public void set_UserAssertion(UserAssertion value);
    [CompilerGeneratedAttribute]
public string get_LongRunningOboCacheKey();
    [CompilerGeneratedAttribute]
public void set_LongRunningOboCacheKey(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<KeyValuePair`2<string, string>> get_CcsRoutingHint();
    [CompilerGeneratedAttribute]
public void set_CcsRoutingHint(Nullable`1<KeyValuePair`2<string, string>> value);
    public void LogParameters();
}
internal class Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy : object {
    internal AuthenticationRequestParameters _authenticationRequestParameters;
    protected IServiceBundle _serviceBundle;
    private AcquireTokenSilentParameters _silentParameters;
    private SilentRequest _silentRequest;
    [CompilerGeneratedAttribute]
private IBroker <Broker>k__BackingField;
    private ILoggerAdapter _logger;
    internal IBroker Broker { get; }
    public BrokerSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, IBroker broker);
    [CompilerGeneratedAttribute]
internal IBroker get_Broker();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy/<ExecuteAsync>d__9")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.BrokerSilentStrategy/<SendTokenRequestToBrokerAsync>d__10")]
private Task`1<MsalTokenResponse> SendTokenRequestToBrokerAsync();
    internal void ValidateResponseFromBroker(MsalTokenResponse msalTokenResponse);
}
internal class Microsoft.Identity.Client.Internal.Requests.ByRefreshTokenRequest : RequestBase {
    private AcquireTokenByRefreshTokenParameters _refreshTokenParameters;
    public ByRefreshTokenRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByRefreshTokenParameters refreshTokenParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ByRefreshTokenRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters(string refreshTokenSecret);
}
internal class Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest : RequestBase {
    private AcquireTokenForClientParameters _clientParameters;
    public ClientCredentialRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForClientParameters clientParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<FetchNewAccessTokenAsync>d__3")]
private Task`1<AuthenticationResult> FetchNewAccessTokenAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ClientCredentialRequest/<SendTokenRequestToProviderAsync>d__4")]
private Task`1<MsalTokenResponse> SendTokenRequestToProviderAsync(CancellationToken cancellationToken);
    protected virtual SortedSet`1<string> GetOverriddenScopes(ISet`1<string> inputScopes);
    private Dictionary`2<string, string> GetBodyParameters();
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.ConfidentialAuthCodeRequest : RequestBase {
    private AcquireTokenByAuthorizationCodeParameters _authorizationCodeParameters;
    public ConfidentialAuthCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByAuthorizationCodeParameters authorizationCodeParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ConfidentialAuthCodeRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
}
internal class Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest : RequestBase {
    private AcquireTokenWithDeviceCodeParameters _deviceCodeParameters;
    public DeviceCodeRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenWithDeviceCodeParameters deviceCodeParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.DeviceCodeRequest/<WaitForTokenResponseAsync>d__3")]
private Task`1<MsalTokenResponse> WaitForTokenResponseAsync(DeviceCodeResult deviceCodeResult, CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters(DeviceCodeResult deviceCodeResult);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest : RequestBase {
    private CommonNonInteractiveHandler _commonNonInteractiveHandler;
    private AcquireTokenByIntegratedWindowsAuthParameters _integratedWindowsAuthParameters;
    public IntegratedWindowsAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByIntegratedWindowsAuthParameters integratedWindowsAuthParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<FetchAssertionFromWsTrustAsync>d__5")]
private Task`1<UserAssertion> FetchAssertionFromWsTrustAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.IntegratedWindowsAuthRequest/<UpdateUsernameAsync>d__6")]
private Task UpdateUsernameAsync();
    private static Dictionary`2<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion);
}
internal class Microsoft.Identity.Client.Internal.Requests.InteractiveRequest : RequestBase {
    private AuthenticationRequestParameters _requestParams;
    private AcquireTokenInteractiveParameters _interactiveParameters;
    private IServiceBundle _serviceBundle;
    private ILoggerAdapter _logger;
    private static string InstanceAwareParam;
    private IAuthCodeRequestComponent _authCodeRequestComponentOverride;
    private ITokenRequestComponent _authCodeExchangeComponentOverride;
    private ITokenRequestComponent _brokerInteractiveComponent;
    public InteractiveRequest(AuthenticationRequestParameters requestParams, AcquireTokenInteractiveParameters interactiveParameters, IAuthCodeRequestComponent authCodeRequestComponentOverride, ITokenRequestComponent authCodeExchangeComponentOverride, ITokenRequestComponent brokerExchangeComponentOverride);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<ExecuteAsync>d__9")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<FetchTokensFromBrokerAsync>d__10")]
private Task`1<MsalTokenResponse> FetchTokensFromBrokerAsync(string brokerInstallUrl, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<GetTokenResponseAsync>d__11")]
private Task`1<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.InteractiveRequest/<RunBrokerWithInstallUriAsync>d__12")]
private Task`1<MsalTokenResponse> RunBrokerWithInstallUriAsync(string brokerInstallUri, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest : RequestBase {
    private AcquireTokenForManagedIdentityParameters _managedIdentityParameters;
    public ManagedIdentityAuthRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenForManagedIdentityParameters managedIdentityParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<ExecuteAsync>d__2")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.ManagedIdentityAuthRequest/<FetchNewAccessTokenAsync>d__3")]
private Task`1<AuthenticationResult> FetchNewAccessTokenAsync(CancellationToken cancellationToken);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest : RequestBase {
    private AcquireTokenOnBehalfOfParameters _onBehalfOfParameters;
    private string _ccsRoutingHint;
    public OnBehalfOfRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenOnBehalfOfParameters onBehalfOfParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<ExecuteAsync>d__3")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private bool IsLongOboInitialize();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<RefreshRtOrFetchNewAccessTokenAsync>d__5")]
private Task`1<AuthenticationResult> RefreshRtOrFetchNewAccessTokenAsync(CancellationToken cancellationToken);
    private bool AcquireTokenInLongRunningOboWasCalled();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.OnBehalfOfRequest/<FetchNewAccessTokenAsync>d__7")]
private Task`1<AuthenticationResult> FetchNewAccessTokenAsync(CancellationToken cancellationToken);
    private Dictionary`2<string, string> GetBodyParameters();
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
    private bool IsLongRunningObo();
}
internal abstract class Microsoft.Identity.Client.Internal.Requests.RequestBase : object {
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters <AuthenticationRequestParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    internal AuthenticationRequestParameters AuthenticationRequestParameters { get; }
    internal ICacheSessionManager CacheManager { get; }
    internal IServiceBundle ServiceBundle { get; }
    protected RequestBase(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, IAcquireTokenParameters acquireTokenParameters);
    [CompilerGeneratedAttribute]
internal AuthenticationRequestParameters get_AuthenticationRequestParameters();
    internal ICacheSessionManager get_CacheManager();
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    protected virtual SortedSet`1<string> GetOverriddenScopes(ISet`1<string> inputScopes);
    private void ValidateScopeInput(ISet`1<string> scopesToValidate);
    protected abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<RunAsync>d__12")]
public Task`1<AuthenticationResult> RunAsync(CancellationToken cancellationToken);
    private void LogErrorTelemetryToClient(string errorCode, MsalTelemetryEventDetails telemetryEventDetails, ITelemetryClient[] telemetryClients);
    private void LogSuccessfulTelemetryToClient(AuthenticationResult authenticationResult, MsalTelemetryEventDetails telemetryEventDetails, ITelemetryClient[] telemetryClients);
    private static void LogMetricsFromAuthResult(AuthenticationResult authenticationResult, ILoggerAdapter logger);
    private static void UpdateTelemetry(Stopwatch sw, ApiEvent apiEvent, AuthenticationResult authenticationResult);
    protected virtual void EnrichTelemetryApiEvent(ApiEvent apiEvent);
    private ApiEvent InitializeApiEvent(string accountId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<CacheTokenResponseAndCreateAuthenticationResultAsync>d__19")]
protected Task`1<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse msalTokenResponse);
    private void ValidateAccountIdentifiers(ClientInfo fromServer);
    protected Task ResolveAuthorityAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<SendTokenRequestAsync>d__22")]
internal Task`1<MsalTokenResponse> SendTokenRequestAsync(IDictionary`2<string, string> additionalBodyParameters, CancellationToken cancellationToken);
    protected Task`1<MsalTokenResponse> SendTokenRequestAsync(string tokenEndpoint, IDictionary`2<string, string> additionalBodyParameters, CancellationToken cancellationToken);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
    protected Nullable`1<KeyValuePair`2<string, string>> GetCcsUpnHeader(string upnHeader);
    private void LogRequestStarted(AuthenticationRequestParameters authenticationRequestParameters);
    private void LogReturnedToken(AuthenticationResult result);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.RequestBase/<HandleTokenRefreshErrorAsync>d__28")]
internal Task`1<AuthenticationResult> HandleTokenRefreshErrorAsync(MsalServiceException e, MsalAccessTokenCacheItem cachedAccessTokenItem);
    private static RegionDetails CreateRegionDetails(ApiEvent apiEvent);
}
internal class Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy : object {
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters <AuthenticationRequestParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    private AcquireTokenSilentParameters _silentParameters;
    private static string TheOnlyFamilyId;
    private SilentRequest _silentRequest;
    private AuthenticationRequestParameters AuthenticationRequestParameters { get; }
    private ICacheSessionManager CacheManager { get; }
    protected IServiceBundle ServiceBundle { get; }
    public CacheSilentStrategy(SilentRequest request, IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters);
    [CompilerGeneratedAttribute]
private AuthenticationRequestParameters get_AuthenticationRequestParameters();
    private ICacheSessionManager get_CacheManager();
    [CompilerGeneratedAttribute]
protected IServiceBundle get_ServiceBundle();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<ExecuteAsync>d__12")]
public sealed virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    private void ThrowIfCurrentBrokerAccount();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<RefreshRtOrFailAsync>d__14")]
private Task`1<AuthenticationResult> RefreshRtOrFailAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<CreateAuthenticationResultAsync>d__15")]
private Task`1<AuthenticationResult> CreateAuthenticationResultAsync(MsalAccessTokenCacheItem cachedAccessTokenItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<TryGetTokenUsingFociAsync>d__16")]
private Task`1<MsalTokenResponse> TryGetTokenUsingFociAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.CacheSilentStrategy/<FindRefreshTokenOrFailAsync>d__17")]
private Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenOrFailAsync();
}
internal interface Microsoft.Identity.Client.Internal.Requests.Silent.ISilentAuthRequestStrategy {
    public abstract virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest : RequestBase {
    private AcquireTokenSilentParameters _silentParameters;
    private ISilentAuthRequestStrategy _clientStrategy;
    private Lazy`1<ISilentAuthRequestStrategy> _brokerStrategyLazy;
    private ILoggerAdapter _logger;
    public SilentRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenSilentParameters silentParameters, ISilentAuthRequestStrategy clientStrategyOverride, ISilentAuthRequestStrategy brokerStrategyOverride);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<ExecuteAsync>d__5")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<CacheTokenResponseAndCreateAuthenticationResultAsync>d__6")]
internal Task`1<AuthenticationResult> CacheTokenResponseAndCreateAuthenticationResultAsync(MsalTokenResponse response);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<ExecuteTestAsync>d__7")]
internal Task`1<AuthenticationResult> ExecuteTestAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<UpdateRequestWithAccountAsync>d__8")]
private Task UpdateRequestWithAccountAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<GetSingleAccountForLoginHintAsync>d__9")]
private Task`1<IAccount> GetSingleAccountForLoginHintAsync(string loginHint);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.Silent.SilentRequest/<GetAccountFromParamsOrLoginHintAsync>d__10")]
private Task`1<IAccount> GetAccountFromParamsOrLoginHintAsync(IAccount account, string loginHint);
}
internal class Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest : RequestBase {
    private CommonNonInteractiveHandler _commonNonInteractiveHandler;
    private AcquireTokenByUsernamePasswordParameters _usernamePasswordParameters;
    private AuthenticationRequestParameters _requestParameters;
    private ILoggerAdapter _logger;
    public UsernamePasswordRequest(IServiceBundle serviceBundle, AuthenticationRequestParameters authenticationRequestParameters, AcquireTokenByUsernamePasswordParameters usernamePasswordParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<ExecuteAsync>d__5")]
protected virtual Task`1<AuthenticationResult> ExecuteAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<GetTokenResponseAsync>d__6")]
private Task`1<MsalTokenResponse> GetTokenResponseAsync(CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<FetchAssertionFromWsTrustAsync>d__7")]
private Task`1<UserAssertion> FetchAssertionFromWsTrustAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.Requests.UsernamePasswordRequest/<UpdateUsernameAsync>d__8")]
private Task UpdateUsernameAsync();
    private Dictionary`2<string, string> GetAdditionalBodyParameters(UserAssertion userAssertion);
    protected virtual Nullable`1<KeyValuePair`2<string, string>> GetCcsHeader(IDictionary`2<string, string> additionalBodyParameters);
}
internal class Microsoft.Identity.Client.Internal.ServiceBundle : object {
    [CompilerGeneratedAttribute]
private ILoggerAdapter <ApplicationLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpManager <HttpManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IInstanceDiscoveryManager <InstanceDiscoveryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IWsTrustWebRequestManager <WsTrustWebRequestManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IPlatformProxy <PlatformProxy>k__BackingField;
    [CompilerGeneratedAttribute]
private ApplicationConfiguration <Config>k__BackingField;
    [CompilerGeneratedAttribute]
private IDeviceAuthManager <DeviceAuthManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IHttpTelemetryManager <HttpTelemetryManager>k__BackingField;
    [CompilerGeneratedAttribute]
private IThrottlingProvider <ThrottlingManager>k__BackingField;
    public ILoggerAdapter ApplicationLogger { get; }
    public IHttpManager HttpManager { get; }
    public IInstanceDiscoveryManager InstanceDiscoveryManager { get; }
    public IWsTrustWebRequestManager WsTrustWebRequestManager { get; }
    public IPlatformProxy PlatformProxy { get; private set; }
    public ApplicationConfiguration Config { get; }
    public IDeviceAuthManager DeviceAuthManager { get; }
    public IHttpTelemetryManager HttpTelemetryManager { get; }
    public IThrottlingProvider ThrottlingManager { get; }
    internal ServiceBundle(ApplicationConfiguration config, bool shouldClearCaches);
    [CompilerGeneratedAttribute]
public sealed virtual ILoggerAdapter get_ApplicationLogger();
    [CompilerGeneratedAttribute]
public sealed virtual IHttpManager get_HttpManager();
    [CompilerGeneratedAttribute]
public sealed virtual IInstanceDiscoveryManager get_InstanceDiscoveryManager();
    [CompilerGeneratedAttribute]
public sealed virtual IWsTrustWebRequestManager get_WsTrustWebRequestManager();
    [CompilerGeneratedAttribute]
public sealed virtual IPlatformProxy get_PlatformProxy();
    [CompilerGeneratedAttribute]
private void set_PlatformProxy(IPlatformProxy value);
    [CompilerGeneratedAttribute]
public sealed virtual ApplicationConfiguration get_Config();
    [CompilerGeneratedAttribute]
public sealed virtual IDeviceAuthManager get_DeviceAuthManager();
    [CompilerGeneratedAttribute]
public sealed virtual IHttpTelemetryManager get_HttpTelemetryManager();
    [CompilerGeneratedAttribute]
public sealed virtual IThrottlingProvider get_ThrottlingManager();
    public static ServiceBundle Create(ApplicationConfiguration config);
    public sealed virtual void SetPlatformProxyForTest(IPlatformProxy platformProxy);
}
internal static class Microsoft.Identity.Client.Internal.SilentRequestHelper : object {
    internal static string MamEnrollmentIdKey;
    private static Random s_random;
    private static SilentRequestHelper();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Internal.SilentRequestHelper/<RefreshAccessTokenAsync>d__1")]
internal static Task`1<MsalTokenResponse> RefreshAccessTokenAsync(MsalRefreshTokenCacheItem msalRefreshTokenItem, RequestBase request, AuthenticationRequestParameters authenticationRequestParameters, CancellationToken cancellationToken);
    private static Dictionary`2<string, string> GetBodyParameters(string refreshTokenSecret);
    internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken);
    internal static bool NeedsRefresh(MsalAccessTokenCacheItem oldAccessToken, Nullable`1& refreshOnWithJitter);
    internal static void ProcessFetchInBackground(MsalAccessTokenCacheItem oldAccessToken, Func`1<Task`1<AuthenticationResult>> fetchAction, ILoggerAdapter logger);
    private static Nullable`1<DateTimeOffset> GetRefreshOnWithJitter(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
}
internal static class Microsoft.Identity.Client.Internal.XmlNamespace : object {
    public static XNamespace Wsdl;
    public static XNamespace Wsp;
    public static XNamespace Http;
    public static XNamespace Sp;
    public static XNamespace Sp2005;
    public static XNamespace Wsu;
    public static XNamespace Soap12;
    public static XNamespace Wsa10;
    public static XNamespace Trust;
    public static XNamespace Trust2005;
    public static XNamespace Issue;
    public static XNamespace Issue2005;
    public static XNamespace SoapEnvelope;
    private static XmlNamespace();
}
public class Microsoft.Identity.Client.IntuneAppProtectionPolicyRequiredException : MsalServiceException {
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityUrl>k__BackingField;
    public string Upn { get; public set; }
    public string AccountUserId { get; public set; }
    public string TenantId { get; public set; }
    public string AuthorityUrl { get; public set; }
    public IntuneAppProtectionPolicyRequiredException(string errorCode, string errorMessage);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
public void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_AccountUserId();
    [CompilerGeneratedAttribute]
public void set_AccountUserId(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorityUrl();
    [CompilerGeneratedAttribute]
public void set_AuthorityUrl(string value);
}
public interface Microsoft.Identity.Client.IPublicClientApplication {
    public bool IsSystemWebViewAvailable { get; }
    public abstract virtual bool get_IsSystemWebViewAvailable();
    public abstract virtual AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable`1<string> scopes);
    public abstract virtual AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    public abstract virtual AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, SecureString password);
    public abstract virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable`1<string> scopes, string username, SecureString securePassword);
    [ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public abstract virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes, string username);
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.ITelemetryConfig {
    public TelemetryAudienceType AudienceType { get; }
    public string SessionId { get; }
    public Action`1<ITelemetryEventPayload> DispatchAction { get; }
    public abstract virtual TelemetryAudienceType get_AudienceType();
    public abstract virtual string get_SessionId();
    public abstract virtual Action`1<ITelemetryEventPayload> get_DispatchAction();
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public interface Microsoft.Identity.Client.ITelemetryEventPayload {
    public string Name { get; }
    public IReadOnlyDictionary`2<string, bool> BoolValues { get; }
    public IReadOnlyDictionary`2<string, long> Int64Values { get; }
    public IReadOnlyDictionary`2<string, int> IntValues { get; }
    public IReadOnlyDictionary`2<string, string> StringValues { get; }
    public abstract virtual string get_Name();
    public abstract virtual IReadOnlyDictionary`2<string, bool> get_BoolValues();
    public abstract virtual IReadOnlyDictionary`2<string, long> get_Int64Values();
    public abstract virtual IReadOnlyDictionary`2<string, int> get_IntValues();
    public abstract virtual IReadOnlyDictionary`2<string, string> get_StringValues();
    public abstract virtual string ToJsonString();
}
public interface Microsoft.Identity.Client.ITokenCache {
    public abstract virtual void SetBeforeAccess(TokenCacheCallback beforeAccess);
    public abstract virtual void SetAfterAccess(TokenCacheCallback afterAccess);
    public abstract virtual void SetBeforeWrite(TokenCacheCallback beforeWrite);
    public abstract virtual void SetBeforeAccessAsync(Func`2<TokenCacheNotificationArgs, Task> beforeAccess);
    public abstract virtual void SetAfterAccessAsync(Func`2<TokenCacheNotificationArgs, Task> afterAccess);
    public abstract virtual void SetBeforeWriteAsync(Func`2<TokenCacheNotificationArgs, Task> beforeWrite);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeMsalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeMsalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeMsalV2();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeMsalV2 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeMsalV2(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.SerializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] SerializeAdalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use ITokenCacheSerializer.DeserializeAdalV3 on the TokenCacheNotificationArgs in the cache callback. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeAdalV3(Byte[] adalV3State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual Byte[] Serialize();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void Deserialize(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual CacheData SerializeUnifiedAndAdalCache();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public abstract virtual void DeserializeUnifiedAndAdalCache(CacheData cacheData);
}
internal interface Microsoft.Identity.Client.ITokenCacheInternal {
    public OptionalSemaphoreSlim Semaphore { get; }
    public ILegacyCachePersistence LegacyPersistence { get; }
    public ITokenCacheAccessor Accessor { get; }
    public bool IsApplicationCache { get; }
    public abstract virtual OptionalSemaphoreSlim get_Semaphore();
    public abstract virtual ILegacyCachePersistence get_LegacyPersistence();
    public abstract virtual ITokenCacheAccessor get_Accessor();
    public abstract virtual Task RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<bool> StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<IEnumerable`1<IAccount>> GetAccountsAsync(AuthenticationRequestParameters requestParameters);
    public abstract virtual Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
    public abstract virtual Task`1<MsalAccessTokenCacheItem> FindAccessTokenAsync(AuthenticationRequestParameters requestParams);
    public abstract virtual MsalIdTokenCacheItem GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual Task`1<MsalRefreshTokenCacheItem> FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId);
    public abstract virtual Task`1<Account> GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    public abstract virtual Task`1<Nullable`1<bool>> IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId);
    public abstract virtual void SetIosKeychainSecurityGroup(string securityGroup);
    public abstract virtual Task OnAfterAccessAsync(TokenCacheNotificationArgs args);
    public abstract virtual Task OnBeforeAccessAsync(TokenCacheNotificationArgs args);
    public abstract virtual Task OnBeforeWriteAsync(TokenCacheNotificationArgs args);
    public abstract virtual bool get_IsApplicationCache();
    public abstract virtual bool HasTokensNoLocks();
    public abstract virtual bool IsAppSubscribedToSerializationEvents();
    public abstract virtual bool IsExternalSerializationConfiguredByUser();
}
public interface Microsoft.Identity.Client.ITokenCacheSerializer {
    public abstract virtual Byte[] SerializeMsalV3();
    public abstract virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    public abstract virtual Byte[] SerializeAdalV3();
    public abstract virtual void DeserializeAdalV3(Byte[] adalV3State);
    [ObsoleteAttribute("Support for the MSAL v2 token cache format will be dropped in the next major version", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual Byte[] SerializeMsalV2();
    [ObsoleteAttribute("Support for the MSAL v2 token cache format will be dropped in the next major version", "False")]
[EditorBrowsableAttribute("1")]
public abstract virtual void DeserializeMsalV2(Byte[] msalV2State);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use IAccount instead (See https://aka.ms/msal-net-2-released)", "True")]
public interface Microsoft.Identity.Client.IUser {
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", "True")]
public string DisplayableId { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Username instead (See https://aka.ms/msal-net-2-released)", "True")]
public string Name { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.Environment instead to get the Identity Provider host (See https://aka.ms/msal-net-2-released)", "True")]
public string IdentityProvider { get; }
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use IAccount.HomeAccountId.Identifier instead to get the user identifier (See https://aka.ms/msal-net-2-released)", "True")]
public string Identifier { get; }
    public abstract virtual string get_DisplayableId();
    public abstract virtual string get_Name();
    public abstract virtual string get_IdentityProvider();
    public abstract virtual string get_Identifier();
}
public enum Microsoft.Identity.Client.Kerberos.KerberosKeyTypes : Enum {
    public int value__;
    public static KerberosKeyTypes None;
    public static KerberosKeyTypes DecCbcCrc;
    public static KerberosKeyTypes DesCbcMd5;
    public static KerberosKeyTypes Aes128CtsHmacSha196;
    public static KerberosKeyTypes Aes256CtsHmacSha196;
}
public class Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket : object {
    [CompilerGeneratedAttribute]
private string <ClientKey>k__BackingField;
    [CompilerGeneratedAttribute]
private KerberosKeyTypes <KeyType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KerberosMessageBuffer>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorMessage>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Realm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ServicePrincipalName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientName>k__BackingField;
    [JsonPropertyNameAttribute("clientKey")]
public string ClientKey { get; public set; }
    [JsonPropertyNameAttribute("keyType")]
public KerberosKeyTypes KeyType { get; public set; }
    [JsonPropertyNameAttribute("messageBuffer")]
public string KerberosMessageBuffer { get; public set; }
    [JsonPropertyNameAttribute("error")]
public string ErrorMessage { get; public set; }
    [JsonPropertyNameAttribute("realm")]
public string Realm { get; public set; }
    [JsonPropertyNameAttribute("sn")]
public string ServicePrincipalName { get; public set; }
    [JsonPropertyNameAttribute("cn")]
public string ClientName { get; public set; }
    public KerberosSupplementalTicket(string errorMessage);
    [CompilerGeneratedAttribute]
public string get_ClientKey();
    [CompilerGeneratedAttribute]
public void set_ClientKey(string value);
    [CompilerGeneratedAttribute]
public KerberosKeyTypes get_KeyType();
    [CompilerGeneratedAttribute]
public void set_KeyType(KerberosKeyTypes value);
    [CompilerGeneratedAttribute]
public string get_KerberosMessageBuffer();
    [CompilerGeneratedAttribute]
public void set_KerberosMessageBuffer(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorMessage();
    [CompilerGeneratedAttribute]
public void set_ErrorMessage(string value);
    [CompilerGeneratedAttribute]
public string get_Realm();
    [CompilerGeneratedAttribute]
public void set_Realm(string value);
    [CompilerGeneratedAttribute]
public string get_ServicePrincipalName();
    [CompilerGeneratedAttribute]
public void set_ServicePrincipalName(string value);
    [CompilerGeneratedAttribute]
public string get_ClientName();
    [CompilerGeneratedAttribute]
public void set_ClientName(string value);
    public virtual string ToString();
}
public static class Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicketManager : object {
    private static int DefaultLogonId;
    private static string KerberosClaimType;
    private static string IdTokenAsRepTemplate;
    private static string AccessTokenAsRepTemplate;
    public static KerberosSupplementalTicket FromIdToken(string idToken);
    public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket);
    public static void SaveToWindowsTicketCache(KerberosSupplementalTicket ticket, long logonId);
    public static Byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName);
    public static Byte[] GetKerberosTicketFromWindowsTicketCache(string servicePrincipalName, long logonId);
    public static Byte[] GetKrbCred(KerberosSupplementalTicket ticket);
    internal static string GetKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer);
}
public enum Microsoft.Identity.Client.Kerberos.KerberosTicketContainer : Enum {
    public int value__;
    public static KerberosTicketContainer IdToken;
    public static KerberosTicketContainer AccessToken;
}
internal static class Microsoft.Identity.Client.KeyTokens : object {
    public static string MSAL;
}
public class Microsoft.Identity.Client.LogCallback : MulticastDelegate {
    public LogCallback(object object, IntPtr method);
    public virtual void Invoke(LogLevel level, string message, bool containsPii);
    public virtual IAsyncResult BeginInvoke(LogLevel level, string message, bool containsPii, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public class Microsoft.Identity.Client.Logger : object {
    [CompilerGeneratedAttribute]
private static bool <PiiLoggingEnabled>k__BackingField;
    [CompilerGeneratedAttribute]
private static bool <DefaultLoggingEnabled>k__BackingField;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
unknown static LogCallback LogCallback {public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static LogLevel Level { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static bool PiiLoggingEnabled { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Logging is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static bool DefaultLoggingEnabled { get; public set; }
    public static void set_LogCallback(LogCallback value);
    public static LogLevel get_Level();
    public static void set_Level(LogLevel value);
    [CompilerGeneratedAttribute]
public static bool get_PiiLoggingEnabled();
    [CompilerGeneratedAttribute]
public static void set_PiiLoggingEnabled(bool value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultLoggingEnabled();
    [CompilerGeneratedAttribute]
public static void set_DefaultLoggingEnabled(bool value);
}
public enum Microsoft.Identity.Client.LogLevel : Enum {
    public int value__;
    public static LogLevel Always;
    public static LogLevel Error;
    public static LogLevel Warning;
    public static LogLevel Info;
    public static LogLevel Verbose;
}
internal static class Microsoft.Identity.Client.LogMessages : object {
    public static string BeginningAcquireByRefreshToken;
    public static string NoScopesProvidedForRefreshTokenRequest;
    public static string CustomWebUiAcquiringAuthorizationCode;
    public static string CustomWebUiRedirectUriMatched;
    public static string CustomWebUiOperationCancelled;
    public static string CustomWebUiCallingAcquireAuthorizationCodeNoPii;
    public static string ClientAssertionDoesNotExistOrNearExpiry;
    public static string ReusingTheUnexpiredClientAssertion;
    public static string ResolvingAuthorityEndpointsTrue;
    public static string ResolvingAuthorityEndpointsFalse;
    public static string CheckMsalTokenResponseReturnedFromBroker;
    public static string UnknownErrorReturnedInBrokerResponse;
    public static string BrokerInvocationRequired;
    public static string AddBrokerInstallUrlToPayload;
    public static string BrokerInvocationNotRequired;
    public static string CanInvokeBrokerAcquireTokenWithBroker;
    public static string AuthenticationWithBrokerDidNotSucceed;
    public static string UserCancelledAuthentication;
    public static string AuthorizationResultWasNotSuccessful;
    public static string WsTrustRequestFailed;
    public static string ErrorReturnedInBrokerResponse(string error);
    public static string UsingXScopesForRefreshTokenRequest(int numScopes);
    public static string CustomWebUiCallingAcquireAuthorizationCodePii(Uri authorizationUri, Uri redirectUri);
}
internal class Microsoft.Identity.Client.ManagedIdentity.AppServiceManagedIdentitySource : ManagedIdentitySource {
    private static string AppServiceMsiApiVersion;
    private static string SecretHeaderName;
    private Uri _endpoint;
    private string _secret;
    private AppServiceManagedIdentitySource(RequestContext requestContext, Uri endpoint, string secret);
    public static ManagedIdentitySource TryCreate(RequestContext requestContext);
    private static bool TryValidateEnvVars(string msiEndpoint, string secret, ILoggerAdapter logger, Uri& endpointUri);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
internal class Microsoft.Identity.Client.ManagedIdentity.AzureArcManagedIdentitySource : ManagedIdentitySource {
    private static string ArcApiVersion;
    private static string AzureArc;
    private Uri _endpoint;
    private AzureArcManagedIdentitySource(Uri endpoint, RequestContext requestContext);
    public static ManagedIdentitySource TryCreate(RequestContext requestContext);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.AzureArcManagedIdentitySource/<HandleResponseAsync>d__6")]
protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ManagedIdentityResponse> <>n__0(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ManagedIdentity.CloudShellManagedIdentitySource : ManagedIdentitySource {
    private Uri _endpoint;
    private static string CloudShell;
    private CloudShellManagedIdentitySource(Uri endpoint, RequestContext requestContext);
    public static ManagedIdentitySource TryCreate(RequestContext requestContext);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
internal class Microsoft.Identity.Client.ManagedIdentity.EnvironmentVariables : object {
    public static string IdentityEndpoint { get; }
    public static string IdentityHeader { get; }
    public static string PodIdentityEndpoint { get; }
    public static string ImdsEndpoint { get; }
    public static string MsiEndpoint { get; }
    public static string IdentityServerThumbprint { get; }
    public static string get_IdentityEndpoint();
    public static string get_IdentityHeader();
    public static string get_PodIdentityEndpoint();
    public static string get_ImdsEndpoint();
    public static string get_MsiEndpoint();
    public static string get_IdentityServerThumbprint();
}
internal class Microsoft.Identity.Client.ManagedIdentity.ImdsManagedIdentitySource : ManagedIdentitySource {
    private static Uri s_imdsEndpoint;
    private static string ImdsTokenPath;
    private static string ImdsApiVersion;
    private static string DefaultMessage;
    internal static string IdentityUnavailableError;
    internal static string GatewayError;
    private Uri _imdsEndpoint;
    internal ImdsManagedIdentitySource(RequestContext requestContext);
    private static ImdsManagedIdentitySource();
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.ImdsManagedIdentitySource/<HandleResponseAsync>d__9")]
protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    internal static string CreateRequestFailedMessage(HttpResponse response, string message);
    [CompilerGeneratedAttribute]
private string <.ctor>b__7_1();
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<ManagedIdentityResponse> <>n__0(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityClient : object {
    private ManagedIdentitySource _identitySource;
    public ManagedIdentityClient(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityClient/<SendTokenRequestForManagedIdentityAsync>d__2")]
internal Task`1<ManagedIdentityResponse> SendTokenRequestForManagedIdentityAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken);
    private static ManagedIdentitySource SelectManagedIdentitySource(RequestContext requestContext);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityErrorResponse : object {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [JsonPropertyNameAttribute("message")]
public string Message { get; public set; }
    [JsonPropertyNameAttribute("correlationId")]
public string CorrelationId { get; public set; }
    [JsonPropertyNameAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyNameAttribute("error_description")]
public string ErrorDescription { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public void set_Message(string value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
}
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityRequest : object {
    private Uri _baseEndpoint;
    [CompilerGeneratedAttribute]
private HttpMethod <Method>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <Headers>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <BodyParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <QueryParameters>k__BackingField;
    public HttpMethod Method { get; }
    public IDictionary`2<string, string> Headers { get; }
    public IDictionary`2<string, string> BodyParameters { get; }
    public IDictionary`2<string, string> QueryParameters { get; }
    public ManagedIdentityRequest(HttpMethod method, Uri endpoint);
    [CompilerGeneratedAttribute]
public HttpMethod get_Method();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_Headers();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_BodyParameters();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, string> get_QueryParameters();
    public Uri ComputeUri();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse : object {
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ExpiresOn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [JsonPropertyNameAttribute("access_token")]
public string AccessToken { get; public set; }
    [JsonPropertyNameAttribute("expires_on")]
public string ExpiresOn { get; public set; }
    [JsonPropertyNameAttribute("resource")]
public string Resource { get; public set; }
    [JsonPropertyNameAttribute("token_type")]
public string TokenType { get; public set; }
    [JsonPropertyNameAttribute("client_id")]
public string ClientId { get; public set; }
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public string get_ExpiresOn();
    [CompilerGeneratedAttribute]
public void set_ExpiresOn(string value);
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public void set_ClientId(string value);
}
internal abstract class Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource : object {
    protected RequestContext _requestContext;
    internal static string TimeoutError;
    protected ManagedIdentitySource(RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.ManagedIdentity.ManagedIdentitySource/<AuthenticateAsync>d__3")]
public virtual Task`1<ManagedIdentityResponse> AuthenticateAsync(AcquireTokenForManagedIdentityParameters parameters, CancellationToken cancellationToken);
    protected virtual Task`1<ManagedIdentityResponse> HandleResponseAsync(AcquireTokenForManagedIdentityParameters parameters, HttpResponse response, CancellationToken cancellationToken);
    protected abstract virtual ManagedIdentityRequest CreateRequest(string resource);
    protected ManagedIdentityResponse GetSuccessfulResponse(HttpResponse response);
    internal string GetMessageFromErrorResponse(HttpResponse response);
}
internal class Microsoft.Identity.Client.ManagedIdentity.ServiceFabricManagedIdentitySource : ManagedIdentitySource {
    private static string ServiceFabricMsiApiVersion;
    private Uri _endpoint;
    private string _identityHeaderValue;
    private ServiceFabricManagedIdentitySource(RequestContext requestContext, Uri endpoint, string identityHeaderValue);
    public static ManagedIdentitySource TryCreate(RequestContext requestContext);
    protected virtual ManagedIdentityRequest CreateRequest(string resource);
}
public class Microsoft.Identity.Client.ManagedIdentityApplication : ApplicationBase {
    [CompilerGeneratedAttribute]
private ITokenCacheInternal <AppTokenCacheInternal>k__BackingField;
    public ITokenCache AppTokenCache { get; }
    internal ITokenCacheInternal AppTokenCacheInternal { get; }
    internal ManagedIdentityApplication(ApplicationConfiguration configuration);
    public sealed virtual ITokenCache get_AppTokenCache();
    [CompilerGeneratedAttribute]
internal ITokenCacheInternal get_AppTokenCacheInternal();
    public sealed virtual AcquireTokenForManagedIdentityParameterBuilder AcquireTokenForManagedIdentity(string resource);
}
public class Microsoft.Identity.Client.ManagedIdentityApplicationBuilder : BaseAbstractApplicationBuilder`1<ManagedIdentityApplicationBuilder> {
    internal ManagedIdentityApplicationBuilder(ApplicationConfiguration configuration);
    public static ManagedIdentityApplicationBuilder CreateWithApplicationOptions(ManagedIdentityApplicationOptions options);
    public static ManagedIdentityApplicationBuilder Create();
    public static ManagedIdentityApplicationBuilder Create(string userAssignedId);
    private ManagedIdentityApplicationBuilder WithUserAssignedManagedIdentity(string userAssignedId);
    public ManagedIdentityApplicationBuilder WithCacheSynchronization(bool enableCacheSynchronization);
    public ManagedIdentityApplicationBuilder WithTelemetryClient(ITelemetryClient[] telemetryClients);
    private void TelemetryClientLogMsalVersion();
    internal ManagedIdentityApplicationBuilder WithAppTokenCacheInternalForTest(ITokenCacheInternal tokenCacheInternal);
    public IManagedIdentityApplication Build();
    internal ManagedIdentityApplication BuildConcrete();
    private void DefaultConfiguration();
    private void ComputeClientIdForCaching();
}
public class Microsoft.Identity.Client.ManagedIdentityApplicationOptions : BaseApplicationOptions {
    [CompilerGeneratedAttribute]
private string <UserAssignedClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableCacheSynchronization>k__BackingField;
    public string UserAssignedClientId { get; public set; }
    public bool EnableCacheSynchronization { get; public set; }
    [CompilerGeneratedAttribute]
public string get_UserAssignedClientId();
    [CompilerGeneratedAttribute]
public void set_UserAssignedClientId(string value);
    [CompilerGeneratedAttribute]
public bool get_EnableCacheSynchronization();
    [CompilerGeneratedAttribute]
public void set_EnableCacheSynchronization(bool value);
}
public class Microsoft.Identity.Client.Metrics : object {
    private static long _totalAccessTokensFromIdP;
    private static long _totalAccessTokensFromCache;
    private static long _totalAccessTokensFromBroker;
    private static long _totalDurationInMs;
    public static long TotalAccessTokensFromIdP { get; internal set; }
    public static long TotalAccessTokensFromCache { get; internal set; }
    public static long TotalAccessTokensFromBroker { get; internal set; }
    public static long TotalDurationInMs { get; internal set; }
    public static long get_TotalAccessTokensFromIdP();
    internal static void set_TotalAccessTokensFromIdP(long value);
    public static long get_TotalAccessTokensFromCache();
    internal static void set_TotalAccessTokensFromCache(long value);
    public static long get_TotalAccessTokensFromBroker();
    internal static void set_TotalAccessTokensFromBroker(long value);
    public static long get_TotalDurationInMs();
    internal static void set_TotalDurationInMs(long value);
    internal static void IncrementTotalAccessTokensFromIdP();
    internal static void IncrementTotalAccessTokensFromCache();
    internal static void IncrementTotalAccessTokensFromBroker();
    internal static void IncrementTotalDurationInMs(long requestDurationInMs);
}
internal static class Microsoft.Identity.Client.MigrationHelper : object {
    public static NotImplementedException CreateMsalNet3BreakingChangesException();
}
public class Microsoft.Identity.Client.MsalClientException : MsalException {
    public MsalClientException(string errorCode);
    public MsalClientException(string errorCode, string errorMessage);
    public MsalClientException(string errorCode, string errorMessage, Exception innerException);
}
public static class Microsoft.Identity.Client.MsalError : object {
    public static string InvalidGrantError;
    public static string InteractionRequired;
    public static string NoTokensFoundError;
    public static string UserNullError;
    public static string UserAssertionNullError;
    public static string CurrentBrokerAccount;
    public static string NoAccountForLoginHint;
    public static string MultipleAccountsForLoginHint;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This error code is not in use")]
public static string TokenCacheNullError;
    public static string NoPromptFailedError;
    public static string ServiceNotAvailable;
    public static string RequestTimeout;
    public static string RequestThrottled;
    public static string UpnRequired;
    public static string MissingPassiveAuthEndpoint;
    public static string InvalidAuthority;
    public static string InvalidAuthorityType;
    public static string UnauthorizedClient;
    public static string UnknownError;
    public static string UnknownBrokerError;
    public static string WamFailedToSignout;
    public static string AuthenticationFailed;
    public static string AuthorityValidationFailed;
    public static string InvalidOwnerWindowType;
    public static string EncodedTokenTooLong;
    public static string UserMismatch;
    public static string FailedToRefreshToken;
    public static string FailedToAcquireTokenSilentlyFromBroker;
    public static string RedirectUriValidationFailed;
    public static string AuthenticationUiFailed;
    public static string InternalError;
    public static string AccessingWsMetadataExchangeFailed;
    public static string FederatedServiceReturnedError;
    public static string UserRealmDiscoveryFailed;
    public static string RopcDoesNotSupportMsaAccounts;
    public static string MissingFederationMetadataUrl;
    public static string ParsingWsMetadataExchangeFailed;
    public static string WsTrustEndpointNotFoundInMetadataDocument;
    public static string ParsingWsTrustResponseFailed;
    public static string IntegratedWindowsAuthenticationFailed;
    public static string UnknownUserType;
    public static string UnknownUser;
    public static string GetUserNameFailed;
    public static string PasswordRequiredForManagedUserError;
    public static string InvalidRequest;
    public static string UapCannotFindDomainUser;
    public static string UapCannotFindUpn;
    public static string NonParsableOAuthError;
    public static string CodeExpired;
    public static string IntegratedWindowsAuthNotSupportedForManagedUser;
    public static string ActivityRequired;
    public static string BrokerResponseHashMismatch;
    public static string BrokerResponseReturnedError;
    public static string BrokerNonceMismatch;
    public static string CannotInvokeBroker;
    public static string NoAndroidBrokerAccountFound;
    public static string NoAndroidBrokerInstalledOnDevice;
    public static string NullIntentReturnedFromAndroidBroker;
    public static string AndroidBrokerSignatureVerificationFailed;
    public static string AndroidBrokerOperationFailed;
    public static string NoUsernameOrAccountIDProvidedForSilentAndroidBrokerAuthentication;
    public static string HttpStatusNotFound;
    public static string HttpStatusCodeNotOk;
    public static string CustomWebUiReturnedInvalidUri;
    public static string CustomWebUiRedirectUriMismatch;
    public static string AccessDenied;
    public static string CannotAccessUserInformationOrUserNotDomainJoined;
    public static string DefaultRedirectUriIsInvalid;
    public static string NoRedirectUri;
    public static string MultipleTokensMatchedError;
    public static string NonHttpsRedirectNotSupported;
    [ObsoleteAttribute("MSAL no longer throws this error - it will allow the HttpClient exceptions to propagate. App developers may write their own logic for detecting access to the network issues, for example by using Xamarin.Essentials. ")]
[EditorBrowsableAttribute("1")]
public static string NetworkNotAvailableError;
    public static string B2CAuthorityHostMismatch;
    public static string AuthorityHostMismatch;
    public static string DuplicateQueryParameterError;
    public static string AuthenticationUiFailedError;
    public static string AuthenticationCanceledError;
    public static string JsonParseError;
    public static string InvalidJwtError;
    public static string StateMismatchError;
    public static string TenantDiscoveryFailedError;
    public static string PlatformNotSupported;
    public static string InvalidAuthorizationUri;
    public static string LoopbackRedirectUri;
    public static string LoopbackResponseUriMismatch;
    public static string LinuxXdgOpen;
    public static string WebviewUnavailable;
    public static string SystemWebviewOptionsNotApplicable;
    public static string ClientCredentialAuthenticationTypesAreMutuallyExclusive;
    public static string ClientCredentialAuthenticationTypeMustBeDefined;
    internal static string BasicAction;
    internal static string AdditionalAction;
    internal static string MessageOnly;
    internal static string UserPasswordExpired;
    internal static string ConsentRequired;
    internal static string BadToken;
    internal static string TokenExpired;
    internal static string ProtectionPolicyRequired;
    internal static string ClientMismatch;
    internal static string DeviceAuthenticationFailed;
    public static string InvalidInstance;
    public static string InvalidUserInstanceMetadata;
    public static string ValidateAuthorityOrCustomMetadata;
    public static string NoClientId;
    public static string ClientIdMustBeAGuid;
    public static string TelemetryConfigOrTelemetryCallback;
    public static string InvalidClient;
    public static string SSHCertUsedAsHttpHeader;
    public static string WABError;
    public static string TokenTypeMismatch;
    public static string AccessTokenTypeMissing;
    public static string ExperimentalFeature;
    public static string BrokerApplicationRequired;
    public static string FailedToGetBrokerResponse;
    public static string InvalidJsonClaimsFormat;
    public static string AuthorityTypeMismatch;
    public static string AuthorityTenantSpecifiedTwice;
    public static string CustomMetadataInstanceOrUri;
    public static string ScopesRequired;
    public static string CertWithoutPrivateKey;
    public static string DeviceCertificateNotFound;
    public static string InvalidAdalCacheMultipleRTs;
    public static string RegionDiscoveryFailed;
    public static string RegionDiscoveryNotEnabled;
    public static string CryptoNet45;
    public static string BrokerDoesNotSupportPop;
    public static string BrokerRequiredForPop;
    public static string AdfsNotSupportedWithBroker;
    public static string NonceRequiredForPopOnPCA;
    public static string WamUiThread;
    public static string WamNoB2C;
    public static string WamInteractiveError;
    public static string WamPickerError;
    public static string WamScopesRequired;
    public static string WebView2NotInstalled;
    public static string WebView2LoaderNotFound;
    public static string RegionalAuthorityValidation;
    public static string RegionDiscoveryWithCustomInstanceMetadata;
    public static string HttpListenerError;
    public static string InitializeProcessSecurityError;
    public static string StaticCacheWithExternalSerialization;
    public static string TenantOverrideNonAad;
    public static string RegionalAndAuthorityOverride;
    public static string OboCacheKeyNotInCacheError;
    public static string InvalidTokenProviderResponseValue;
    public static string UnableToParseAuthenticationHeader;
    public static string InvalidManagedIdentityResponse;
    public static string ManagedIdentityRequestFailed;
    public static string UnknownManagedIdentityError;
    public static string InvalidManagedIdentityEndpoint;
    public static string ExactlyOneScopeExpected;
    public static string UserAssignedManagedIdentityNotSupported;
    public static string UserAssignedManagedIdentityNotConfigurableAtRuntime;
    public static string CombinedUserAppCacheNotSupported;
}
internal static class Microsoft.Identity.Client.MsalErrorMessage : object {
    public static string AccessingMetadataDocumentFailed;
    public static string AssemblyNotFoundTemplate;
    public static string AssemblyLoadFailedTemplate;
    public static string AuthenticationUiFailed;
    public static string DeprecatedAuthorityError;
    public static string CertificateKeySizeTooSmallTemplate;
    public static string EmailAddressSuffixMismatch;
    public static string EncodedTokenTooLong;
    public static string FailedToAcquireTokenSilently;
    public static string FailedToRefreshToken;
    public static string IdentityProtocolLoginUrlNull;
    public static string IdentityProtocolMismatch;
    public static string IdentityProviderRequestFailed;
    public static string InvalidArgumentLength;
    public static string InvalidAuthenticateHeaderFormat;
    public static string InvalidAuthorityTypeTemplate;
    public static string InvalidCredentialType;
    public static string InvalidFormatParameterTemplate;
    public static string InvalidTokenCacheKeyFormat;
    public static string MissingAuthenticateHeader;
    public static string MultipleTokensMatched;
    public static string NullParameterTemplate;
    public static string ParsingMetadataDocumentFailed;
    public static string ParsingWsTrustResponseFailed;
    public static string PasswordRequiredForManagedUserError;
    public static string LoginHintNullForUiOption;
    public static string ServiceReturnedError;
    public static string BrokerResponseHashMismatch;
    public static string BrokerNonceMismatch;
    public static string StsMetadataRequestFailed;
    public static string StsTokenRequestFailed;
    public static string UnauthorizedHttpStatusCodeExpected;
    internal static string iOSBrokerKeyFetchFailed;
    public static string UnauthorizedResponseExpected;
    public static string UnexpectedAuthorityValidList;
    public static string UnsupportedUserType;
    public static string UnsupportedMultiRefreshToken;
    public static string UserMismatch;
    public static string UserCredentialAssertionTypeEmpty;
    public static string NoPromptFailedErrorMessage;
    public static string StateMismatchErrorMessage;
    public static string UserRealmDiscoveryFailed;
    public static string RopcDoesNotSupportMsaAccounts;
    public static string WsTrustEndpointNotFoundInMetadataDocument;
    public static string GetUserNameFailed;
    public static string MissingFederationMetadataUrl;
    public static string SpecifyAnyUser;
    public static string IntegratedAuthFailed;
    public static string DuplicateQueryParameterTemplate;
    public static string DeviceCertificateNotFoundTemplate;
    public static string MsalUiRequiredMessage;
    public static string UserMismatchSaveToken;
    public static string IwaNotSupportedForManagedUser;
    public static string ActivityRequired;
    public static string BrokerResponseReturnedError;
    public static string BrokerResponseError;
    public static string CannotInvokeBroker;
    public static string CannotInvokeBrokerForPop;
    public static string BrokerDoesNotSupportPop;
    public static string BrokerRequiredForPop;
    public static string NonceRequiredForPop;
    public static string AdfsNotSupportedWithBroker;
    public static string NullIntentReturnedFromBroker;
    public static string NoAccountForLoginHint;
    public static string MultipleAccountsForLoginHint;
    public static string UnknownUser;
    public static string HttpRequestUnsuccessful;
    public static string AuthorityInvalidUriFormat;
    public static string AuthorityNotSupported;
    public static string AuthorityValidationFailed;
    public static string AuthorityUriInsecure;
    public static string AuthorityUriInvalidPath;
    public static string B2cAuthorityUriInvalidPath;
    public static string DstsAuthorityUriInvalidPath;
    public static string UnsupportedAuthorityValidation;
    public static string AuthenticationCanceled;
    public static string AuthenticationCanceledAndroid;
    public static string Unknown;
    public static string AuthorizationServerInvalidResponse;
    public static string NonHttpsRedirectNotSupported;
    public static string IDTokenMustHaveTwoParts;
    public static string FailedToParseIDToken;
    public static string InvalidAuthorityOpenId;
    public static string UpnRequiredForAuthroityValidation;
    public static string CannotFindTheAuthEndpoint;
    public static string UapCannotFindUpn;
    public static string UapCannotFindDomainUser;
    public static string PlatformNotSupported;
    public static string FederatedServiceReturnedErrorTemplate;
    public static string ParsingWsTrustResponseFailedErrorTemplate;
    public static string UnknownUserType;
    public static string ParsingWsTrustResponseFailedDueToConfiguration;
    public static string InternalErrorCacheEmptyUsername;
    public static string InternalErrorCacheEmptyIdentifier;
    public static string NonParsableOAuthError;
    public static string CannotAccessPublisherKeyChain;
    public static string MissingEntitlements;
    public static string AndroidActivityNotFound;
    public static string DefaultRedirectUriIsInvalid;
    public static string RedirectUriContainsFragment;
    public static string NoRedirectUri;
    public static string ClientApplicationBaseExecutorNotImplemented;
    public static string ActivityRequiredForParentObjectAndroid;
    public static string LoggingCallbackAlreadySet;
    public static string TelemetryCallbackAlreadySet;
    public static string NoClientIdWasSpecified;
    public static string AdfsNotCurrentlySupportedAuthorityType;
    public static string TenantIdAndAadAuthorityInstanceAreMutuallyExclusive;
    public static string InstanceAndAzureCloudInstanceAreMutuallyExclusive;
    public static string NoRefreshTokenProvided;
    public static string AadThrottledError;
    public static string NoTokensFoundError;
    public static string NoRefreshTokenInResponse;
    public static string ConfidentialClientDoesntImplementIConfidentialClientApplicationExecutor;
    public static string ClientCredentialAuthenticationTypesAreMutuallyExclusive;
    public static string ClientCredentialAuthenticationTypeMustBeDefined;
    public static string ClientIdMustBeAGuid;
    public static string TelemetryClassIsObsolete;
    public static string LoggingClassIsObsolete;
    public static string AuthorityDoesNotHaveTwoSegments;
    public static string DstsAuthorityDoesNotHaveThreeSegments;
    public static string AzureAdMyOrgRequiresSpecifyingATenant;
    public static string CustomWebUiReturnedInvalidUri;
    public static string InteractiveAuthNotSupported;
    public static string CustomWebUiAuthorizationCodeFailed;
    public static string TokenCacheJsonSerializerFailedParse;
    public static string TokenCacheDictionarySerializerFailedParse;
    public static string BrokerNotSupportedOnThisPlatform;
    public static string MsalExceptionFailedToParse;
    public static string AdfsDeviceFlowNotSupported;
    public static string MatsAndTelemetryCallbackCannotBeConfiguredSimultaneously;
    public static string AkaMsmsalnet3BreakingChanges;
    public static string B2CAuthorityHostMisMatch;
    public static string TokenCacheSetCallbackFunctionalityNotAvailableFromWithinCallback;
    public static string EmbeddedWebviewDefaultBrowser;
    public static string AuthorizeEndpointWasNotFoundInTheOpenIdConfiguration;
    public static string TokenEndpointWasNotFoundInTheOpenIdConfiguration;
    public static string IssuerWasNotFoundInTheOpenIdConfiguration;
    public static string InvalidUserInstanceMetadata;
    public static string UIViewControllerIsRequiredToInvokeiOSBroker;
    public static string WritingApplicationTokenToKeychainFailed;
    public static string ReadingApplicationTokenFromKeychainFailed;
    public static string ValidateAuthorityOrCustomMetadata;
    public static string InvalidClient;
    public static string SSHCertUsedAsHttpHeader;
    public static string BrokerApplicationRequired;
    public static string RegionDiscoveryFailed;
    public static string RegionDiscoveryFailedWithTimeout;
    public static string RegionDiscoveryNotAvailable;
    public static string RegionDiscoveryWithCustomInstanceMetadata;
    public static string NoAndroidBrokerAccountFound;
    public static string AndroidBrokerCannotBeInvoked;
    public static string CustomMetadataInstanceOrUri;
    public static string ScopesRequired;
    public static string InvalidAdalCacheMultipleRTs;
    public static string CryptoNet45;
    public static string AccessTokenTypeMissing;
    public static string LinuxOpenToolFailed;
    public static string LinuxOpenAsSudoNotSupported;
    public static string WebView2LoaderNotFound;
    public static string AuthenticationFailedWamElevatedProcess;
    public static string CcsRoutingHintMissing;
    public static string StaticCacheWithExternalSerialization;
    public static string ClientCredentialWrongAuthority;
    public static string TenantOverrideNonAad;
    public static string RegionalAndAuthorityOverride;
    public static string OboCacheKeyNotInCache;
    public static string MultiCloudSupportUnavailable;
    public static string RequestFailureErrorMessage;
    public static string RequestFailureErrorMessagePii;
    public static string UnableToParseAuthenticationHeader;
    public static string ManagedIdentityNoResponseReceived;
    public static string ManagedIdentityInvalidResponse;
    public static string ManagedIdentityUnexpectedResponse;
    public static string ManagedIdentityExactlyOneScopeExpected;
    public static string ManagedIdentityEndpointInvalidUriError;
    public static string ManagedIdentityNoChallengeError;
    public static string ManagedIdentityInvalidChallenge;
    public static string ManagedIdentityUserAssignedNotSupported;
    public static string ManagedIdentityUserAssignedNotConfigurableAtRuntime;
    public static string CombinedUserAppCacheNotSupported;
    public static string JsonParseErrorMessage;
    public static string iOSBrokerKeySaveFailed(string keyChainResult);
    public static string InvalidRedirectUriReceived(string invalidRedirectUri);
    public static string RedirectUriMismatch(string expectedUri, string actualUri);
    public static string AuthorityTypeMismatch(AuthorityType appAuthorityType, AuthorityType requestAuthorityType);
    public static string ExperimentalFeature(string methodName);
    public static string NoUserInstanceMetadataEntry(string environment);
    public static string WABError(string status, string errorDetail, string responseData);
    public static string TokenTypeMismatch(string requestTokenType, string responseTokenType);
    public static string InvalidJsonClaimsFormat(string claims);
    public static string CertMustHavePrivateKey(string certificateName);
    public static string InitializeProcessSecurityError(string errorCode);
    public static string InvalidTokenProviderResponseValue(string invalidValueName);
}
public class Microsoft.Identity.Client.MsalException : Exception {
    private string _errorCode;
    [CompilerGeneratedAttribute]
private bool <IsRetryable>k__BackingField;
    private static string ExceptionTypeKey;
    private static string ErrorCodeKey;
    private static string ErrorDescriptionKey;
    public bool IsRetryable { get; public set; }
    public string ErrorCode { get; private set; }
    public MsalException(string errorCode);
    public MsalException(string errorCode, string errorMessage);
    public MsalException(string errorCode, string errorMessage, Exception innerException);
    [CompilerGeneratedAttribute]
public bool get_IsRetryable();
    [CompilerGeneratedAttribute]
public void set_IsRetryable(bool value);
    public string get_ErrorCode();
    private void set_ErrorCode(string value);
    public virtual string ToString();
    internal virtual void PopulateJson(JsonObject jobj);
    internal virtual void PopulateObjectFromJson(JsonObject jobj);
    public string ToJsonString();
    public static MsalException FromJsonString(string json);
}
public class Microsoft.Identity.Client.MsalServiceException : MsalException {
    private static string ClaimsKey;
    private static string ResponseBodyKey;
    private static string CorrelationIdKey;
    private static string SubErrorKey;
    private int _statusCode;
    private string _responseBody;
    private HttpResponseHeaders _headers;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubError>k__BackingField;
    public int StatusCode { get; internal set; }
    [JsonIncludeAttribute]
public string Claims { get; internal set; }
    public string ResponseBody { get; public set; }
    public HttpResponseHeaders Headers { get; public set; }
    public string CorrelationId { get; public set; }
    internal string SubError { get; internal set; }
    public MsalServiceException(string errorCode, string errorMessage);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode);
    public MsalServiceException(string errorCode, string errorMessage, Exception innerException);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode, Exception innerException);
    public MsalServiceException(string errorCode, string errorMessage, int statusCode, string claims, Exception innerException);
    public int get_StatusCode();
    internal void set_StatusCode(int value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
internal void set_Claims(string value);
    public string get_ResponseBody();
    public void set_ResponseBody(string value);
    public HttpResponseHeaders get_Headers();
    public void set_Headers(HttpResponseHeaders value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
internal string get_SubError();
    [CompilerGeneratedAttribute]
internal void set_SubError(string value);
    private void UpdateIsRetryable();
    public virtual string ToString();
    internal virtual void PopulateJson(JsonObject jobj);
    internal virtual void PopulateObjectFromJson(JsonObject jobj);
}
internal class Microsoft.Identity.Client.MsalServiceExceptionFactory : object {
    private static ISet`1<string> s_nonUiSubErrors;
    private static MsalServiceExceptionFactory();
    internal static MsalServiceException FromHttpResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException);
    private static bool IsThrottled(OAuth2ResponseBase oAuth2Response);
    internal static MsalServiceException FromBrokerResponse(MsalTokenResponse msalTokenResponse, string errorMessage);
    internal static MsalServiceException FromImdsResponse(string errorCode, string errorMessage, HttpResponse httpResponse, Exception innerException);
    internal static MsalServiceException FromManagedIdentityResponse(string errorCode, HttpResponse httpResponse);
    internal static MsalThrottledServiceException FromThrottledAuthenticationResponse(HttpResponse httpResponse);
    private static void SetHttpExceptionData(MsalServiceException ex, HttpResponse httpResponse);
    private static bool IsInteractionRequired(string errorCode);
    private static bool IsInvalidGrant(string errorCode, string subErrorCode);
    private static bool IsAppProtectionPolicyRequired(string errorCode, string subErrorCode);
    private static bool IsInvalidGrantSubError(string subError);
}
public class Microsoft.Identity.Client.MsalThrottledServiceException : MsalServiceException {
    [CompilerGeneratedAttribute]
private MsalServiceException <OriginalServiceException>k__BackingField;
    public MsalServiceException OriginalServiceException { get; }
    public MsalThrottledServiceException(MsalServiceException originalException);
    [CompilerGeneratedAttribute]
public MsalServiceException get_OriginalServiceException();
}
public class Microsoft.Identity.Client.MsalThrottledUiRequiredException : MsalUiRequiredException {
    [CompilerGeneratedAttribute]
private MsalUiRequiredException <OriginalServiceException>k__BackingField;
    public MsalUiRequiredException OriginalServiceException { get; }
    public MsalThrottledUiRequiredException(MsalUiRequiredException originalException);
    [CompilerGeneratedAttribute]
public MsalUiRequiredException get_OriginalServiceException();
}
public class Microsoft.Identity.Client.MsalUiRequiredException : MsalServiceException {
    private UiRequiredExceptionClassification _classification;
    public UiRequiredExceptionClassification Classification { get; }
    public MsalUiRequiredException(string errorCode, string errorMessage);
    public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException);
    public MsalUiRequiredException(string errorCode, string errorMessage, Exception innerException, UiRequiredExceptionClassification classification);
    public UiRequiredExceptionClassification get_Classification();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthHeader : object {
    [CompilerGeneratedAttribute]
private IList`1<string> <X5c>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alg>k__BackingField;
    [JsonPropertyNameAttribute("x5c")]
public IList`1<string> X5c { get; public set; }
    [JsonPropertyNameAttribute("typ")]
public string Type { get; public set; }
    [JsonPropertyNameAttribute("alg")]
public string Alg { get; private set; }
    public DeviceAuthHeader(string base64EncodedCertificate);
    [CompilerGeneratedAttribute]
public IList`1<string> get_X5c();
    [CompilerGeneratedAttribute]
public void set_X5c(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Type();
    [CompilerGeneratedAttribute]
public void set_Type(string value);
    [CompilerGeneratedAttribute]
public string get_Alg();
    [CompilerGeneratedAttribute]
private void set_Alg(string value);
}
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthJWTResponse : object {
    private DeviceAuthHeader _header;
    private DeviceAuthPayload _payload;
    public DeviceAuthJWTResponse(string audience, string nonce, string base64EncodedCertificate);
    public string GetResponseToSign();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.DeviceAuthPayload : object {
    private Lazy`1<long> _defaultDeviceAuthJWTTimeSpan;
    [CompilerGeneratedAttribute]
private long <Iat>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [JsonPropertyNameAttribute("iat")]
[JsonNumberHandlingAttribute("1")]
public long Iat { get; public set; }
    [JsonPropertyNameAttribute("aud")]
public string Audience { get; public set; }
    [JsonPropertyNameAttribute("nonce")]
public string Nonce { get; private set; }
    public DeviceAuthPayload(string audience, string nonce);
    [CompilerGeneratedAttribute]
public long get_Iat();
    [CompilerGeneratedAttribute]
public void set_Iat(long value);
    [CompilerGeneratedAttribute]
public string get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(string value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
private void set_Nonce(string value);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.MsalTokenResponse : OAuth2ResponseBase {
    private static string iOSBrokerErrorMetadata;
    private static string iOSBrokerHomeAccountId;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, JsonElement> <ExtensionData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccessToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RefreshToken>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <IdToken>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private long <ExtendedExpiresIn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<long> <RefreshIn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FamilyId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SpaAuthCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthorityUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Upn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountUserId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <WamAccountId>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenSource <TokenSource>k__BackingField;
    [CompilerGeneratedAttribute]
private HttpResponse <HttpResponse>k__BackingField;
    [JsonExtensionDataAttribute]
public Dictionary`2<string, JsonElement> ExtensionData { get; public set; }
    [JsonPropertyNameAttribute("token_type")]
public string TokenType { get; public set; }
    [JsonPropertyNameAttribute("access_token")]
public string AccessToken { get; public set; }
    [JsonPropertyNameAttribute("refresh_token")]
public string RefreshToken { get; public set; }
    [JsonPropertyNameAttribute("scope")]
public string Scope { get; public set; }
    [JsonPropertyNameAttribute("client_info")]
public string ClientInfo { get; public set; }
    [JsonPropertyNameAttribute("id_token")]
public string IdToken { get; public set; }
    [JsonPropertyNameAttribute("expires_in")]
[JsonNumberHandlingAttribute("1")]
public long ExpiresIn { get; public set; }
    [JsonNumberHandlingAttribute("1")]
[JsonPropertyNameAttribute("ext_expires_in")]
public long ExtendedExpiresIn { get; public set; }
    [JsonNumberHandlingAttribute("1")]
[JsonPropertyNameAttribute("refresh_in")]
public Nullable`1<long> RefreshIn { get; public set; }
    [JsonPropertyNameAttribute("foci")]
public string FamilyId { get; public set; }
    [JsonPropertyNameAttribute("spa_code")]
public string SpaAuthCode { get; public set; }
    [JsonPropertyNameAttribute("authority")]
public string AuthorityUrl { get; public set; }
    public string TenantId { get; public set; }
    public string Upn { get; public set; }
    public string AccountUserId { get; public set; }
    public string WamAccountId { get; public set; }
    public TokenSource TokenSource { get; public set; }
    public HttpResponse HttpResponse { get; public set; }
    [CompilerGeneratedAttribute]
public Dictionary`2<string, JsonElement> get_ExtensionData();
    [CompilerGeneratedAttribute]
public void set_ExtensionData(Dictionary`2<string, JsonElement> value);
    public Dictionary`2<string, string> CreateExtensionDataStringMap();
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    [CompilerGeneratedAttribute]
public string get_AccessToken();
    [CompilerGeneratedAttribute]
public void set_AccessToken(string value);
    [CompilerGeneratedAttribute]
public string get_RefreshToken();
    [CompilerGeneratedAttribute]
public void set_RefreshToken(string value);
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public void set_ClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_IdToken();
    [CompilerGeneratedAttribute]
public void set_IdToken(string value);
    [CompilerGeneratedAttribute]
public long get_ExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExpiresIn(long value);
    [CompilerGeneratedAttribute]
public long get_ExtendedExpiresIn();
    [CompilerGeneratedAttribute]
public void set_ExtendedExpiresIn(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<long> get_RefreshIn();
    [CompilerGeneratedAttribute]
public void set_RefreshIn(Nullable`1<long> value);
    [CompilerGeneratedAttribute]
public string get_FamilyId();
    [CompilerGeneratedAttribute]
public void set_FamilyId(string value);
    [CompilerGeneratedAttribute]
public string get_SpaAuthCode();
    [CompilerGeneratedAttribute]
public void set_SpaAuthCode(string value);
    [CompilerGeneratedAttribute]
public string get_AuthorityUrl();
    [CompilerGeneratedAttribute]
public void set_AuthorityUrl(string value);
    [CompilerGeneratedAttribute]
public string get_TenantId();
    [CompilerGeneratedAttribute]
public void set_TenantId(string value);
    [CompilerGeneratedAttribute]
public string get_Upn();
    [CompilerGeneratedAttribute]
public void set_Upn(string value);
    [CompilerGeneratedAttribute]
public string get_AccountUserId();
    [CompilerGeneratedAttribute]
public void set_AccountUserId(string value);
    [CompilerGeneratedAttribute]
public string get_WamAccountId();
    [CompilerGeneratedAttribute]
public void set_WamAccountId(string value);
    [CompilerGeneratedAttribute]
public TokenSource get_TokenSource();
    [CompilerGeneratedAttribute]
public void set_TokenSource(TokenSource value);
    [CompilerGeneratedAttribute]
public HttpResponse get_HttpResponse();
    [CompilerGeneratedAttribute]
public void set_HttpResponse(HttpResponse value);
    internal static MsalTokenResponse CreateFromiOSBrokerResponse(Dictionary`2<string, string> responseDictionary);
    internal static MsalTokenResponse CreateFromManagedIdentityResponse(ManagedIdentityResponse managedIdentityResponse);
    private static void ValidateManagedIdentityResult(ManagedIdentityResponse response);
    internal static MsalTokenResponse CreateFromAppProviderResponse(AppTokenProviderResult tokenProviderResponse);
    private static void ValidateTokenProviderResult(AppTokenProviderResult TokenProviderResult);
    private static void HandleInvalidExternalValueError(string nameOfValue);
    internal static MsalTokenResponse CreateFromAndroidBrokerResponse(string jsonResponse, string correlationId);
    public void Log(ILoggerAdapter logger, LogLevel logLevel);
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2AssertionType : object {
    public static string JwtBearer;
}
internal class Microsoft.Identity.Client.OAuth2.OAuth2Client : object {
    private Dictionary`2<string, string> _headers;
    private Dictionary`2<string, string> _queryParameters;
    private IDictionary`2<string, string> _bodyParameters;
    private IHttpManager _httpManager;
    public OAuth2Client(ILoggerAdapter logger, IHttpManager httpManager);
    public void AddQueryParameter(string key, string value);
    public void AddBodyParameter(string key, string value);
    internal void AddHeader(string key, string value);
    internal IReadOnlyDictionary`2<string, string> GetBodyParameters();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.OAuth2Client/<DiscoverAadInstanceAsync>d__9")]
public Task`1<InstanceDiscoveryResponse> DiscoverAadInstanceAsync(Uri endpoint, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.OAuth2Client/<DiscoverOidcMetadataAsync>d__10")]
public Task`1<OidcMetadata> DiscoverOidcMetadataAsync(Uri endpoint, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.OAuth2Client/<GetTokenAsync>d__11")]
internal Task`1<MsalTokenResponse> GetTokenAsync(Uri endPoint, RequestContext requestContext, bool addCommonHeaders, Func`2<OnBeforeTokenRequestData, Task> onBeforePostRequestHandler);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.OAuth2Client/<ExecuteRequestAsync>d__12`1")]
internal Task`1<T> ExecuteRequestAsync(Uri endPoint, HttpMethod method, RequestContext requestContext, bool expectErrorsOn200OK, bool addCommonHeaders, Func`2<OnBeforeTokenRequestData, Task> onBeforePostRequestData);
    internal void AddBodyParameter(KeyValuePair`2<string, string> kvp);
    private void AddCommonHeaders(RequestContext requestContext);
    public static T CreateResponse(HttpResponse response, RequestContext requestContext);
    private static void ThrowServerException(HttpResponse response, RequestContext requestContext);
    private static MsalServiceException ExtractErrorsFromTheResponse(HttpResponse response, Boolean& shouldLogAsError);
    private Uri AddExtraQueryParams(Uri endPoint);
    private static void VerifyCorrelationIdHeaderInResponse(IDictionary`2<string, string> headers, RequestContext requestContext);
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Error : object {
    public static string LoginRequired;
    public static string AuthorizationPending;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2GrantType : object {
    public static string AuthorizationCode;
    public static string RefreshToken;
    public static string ClientCredentials;
    public static string Saml11Bearer;
    public static string Saml20Bearer;
    public static string JwtBearer;
    public static string Password;
    public static string DeviceCode;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Header : object {
    public static string CorrelationId;
    public static string RequestCorrelationIdInResponse;
    public static string AppName;
    public static string AppVer;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Parameter : object {
    public static string ResponseType;
    public static string GrantType;
    public static string ClientId;
    public static string ClientSecret;
    public static string ClientAssertion;
    public static string ClientAssertionType;
    public static string RefreshToken;
    public static string RedirectUri;
    public static string Resource;
    public static string Code;
    public static string DeviceCode;
    public static string Scope;
    public static string Assertion;
    public static string RequestedTokenUse;
    public static string Username;
    public static string Password;
    public static string LoginHint;
    public static string CorrelationId;
    public static string State;
    public static string CodeChallengeMethod;
    public static string CodeChallenge;
    public static string PkceCodeVerifier;
    public static string LoginReq;
    public static string DomainReq;
    public static string Prompt;
    public static string ClientInfo;
    public static string Claims;
    public static string TokenType;
    public static string RequestConfirmation;
    public static string SpaCode;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2RequestedTokenUse : object {
    public static string OnBehalfOf;
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.OAuth2.OAuth2ResponseBase : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubError>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <ErrorCodes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [JsonPropertyNameAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyNameAttribute("suberror")]
public string SubError { get; public set; }
    [JsonPropertyNameAttribute("error_description")]
public string ErrorDescription { get; public set; }
    [JsonPropertyNameAttribute("error_codes")]
public String[] ErrorCodes { get; public set; }
    [JsonPropertyNameAttribute("correlation_id")]
public string CorrelationId { get; public set; }
    [JsonPropertyNameAttribute("claims")]
public string Claims { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_SubError();
    [CompilerGeneratedAttribute]
public void set_SubError(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
    [CompilerGeneratedAttribute]
public String[] get_ErrorCodes();
    [CompilerGeneratedAttribute]
public void set_ErrorCodes(String[] value);
    [CompilerGeneratedAttribute]
public string get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
}
internal class Microsoft.Identity.Client.OAuth2.OAuth2ResponseBaseClaim : object {
    public static string Claims;
    public static string Error;
    public static string SubError;
    public static string ErrorDescription;
    public static string ErrorCodes;
    public static string CorrelationId;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2ResponseType : object {
    public static string Code;
}
internal static class Microsoft.Identity.Client.OAuth2.OAuth2Value : object {
    public static string CodeChallengeMethodValue;
    public static string ScopeOpenId;
    public static string ScopeOfflineAccess;
    public static string ScopeProfile;
    public static HashSet`1<string> ReservedScopes;
    private static OAuth2Value();
}
internal class Microsoft.Identity.Client.OAuth2.PromptValue : object {
    public static string Login;
    public static string RefreshSession;
    public static string AttemptNone;
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.HttpStatusProvider : object {
    internal static TimeSpan s_throttleDuration;
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal ThrottlingCache ThrottlingCache { get; }
    private static HttpStatusProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    private static bool IsRequestSupported(AuthenticationRequestParameters requestParameters);
}
internal interface Microsoft.Identity.Client.OAuth2.Throttling.IThrottlingProvider {
    public abstract virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public abstract virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public abstract virtual void ResetCache();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.RetryAfterProvider : object {
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal static TimeSpan MaxRetryAfter;
    internal ThrottlingCache ThrottlingCache { get; }
    private static RetryAfterProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public static bool TryGetRetryAfterValue(HttpResponseHeaders headers, TimeSpan& retryAfterTimespan);
    private static TimeSpan GetSafeValue(TimeSpan headerValue);
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.SingletonThrottlingManager : object {
    [CompilerGeneratedAttribute]
private IEnumerable`1<IThrottlingProvider> <ThrottlingProviders>k__BackingField;
    private static Lazy`1<SingletonThrottlingManager> lazyPrivateCtor;
    public IEnumerable`1<IThrottlingProvider> ThrottlingProviders { get; }
    private static SingletonThrottlingManager();
    [CompilerGeneratedAttribute]
public IEnumerable`1<IThrottlingProvider> get_ThrottlingProviders();
    public static SingletonThrottlingManager GetInstance();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    public sealed virtual void ResetCache();
}
internal static class Microsoft.Identity.Client.OAuth2.Throttling.ThrottleCommon : object {
    public static string ThrottleRetryAfterHeaderName;
    public static string ThrottleRetryAfterHeaderValue;
    internal static string KeyDelimiter;
    public static string GetRequestStrictThumbprint(IReadOnlyDictionary`2<string, string> bodyParams, string authority, string homeAccountId);
    public static void TryThrowServiceException(string thumbprint, ThrottlingCache cache, ILoggerAdapter logger, string providerName);
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.ThrottlingCache : object {
    internal static int DefaultCleanupIntervalMs;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanupInProgress;
    private static object _padlock;
    private TimeSpan s_cleanupCacheInterval;
    private DateTimeOffset _lastCleanupTime;
    private ConcurrentDictionary`2<string, ThrottlingCacheEntry> _cache;
    internal ConcurrentDictionary`2<string, ThrottlingCacheEntry> CacheForTest { get; }
    public ThrottlingCache(Nullable`1<int> customCleanupIntervalMs);
    private static ThrottlingCache();
    public void AddAndCleanup(string key, ThrottlingCacheEntry entry, ILoggerAdapter logger);
    public bool TryGetOrRemoveExpired(string key, ILoggerAdapter logger, MsalServiceException& ex);
    public void Clear();
    public bool IsEmpty();
    internal ConcurrentDictionary`2<string, ThrottlingCacheEntry> get_CacheForTest();
    private void CleanCache(ILoggerAdapter logger);
    private void CleanupCacheNoLocks();
    [CompilerGeneratedAttribute]
private string <CleanCache>b__13_1();
    [CompilerGeneratedAttribute]
private string <CleanCache>b__13_2();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.ThrottlingCacheEntry : object {
    [CompilerGeneratedAttribute]
private MsalServiceException <Exception>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <CreationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTimeOffset <ExpirationTime>k__BackingField;
    public MsalServiceException Exception { get; }
    public DateTimeOffset CreationTime { get; }
    public DateTimeOffset ExpirationTime { get; }
    public bool IsExpired { get; }
    public ThrottlingCacheEntry(MsalServiceException exception, TimeSpan lifetime);
    public ThrottlingCacheEntry(MsalServiceException exception, DateTimeOffset creationTime, DateTimeOffset expirationTime);
    [CompilerGeneratedAttribute]
public MsalServiceException get_Exception();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_CreationTime();
    [CompilerGeneratedAttribute]
public DateTimeOffset get_ExpirationTime();
    public bool get_IsExpired();
}
internal class Microsoft.Identity.Client.OAuth2.Throttling.UiRequiredProvider : object {
    internal static TimeSpan s_uiRequiredExpiration;
    [CompilerGeneratedAttribute]
private ThrottlingCache <ThrottlingCache>k__BackingField;
    internal ThrottlingCache ThrottlingCache { get; }
    private static UiRequiredProvider();
    [CompilerGeneratedAttribute]
internal ThrottlingCache get_ThrottlingCache();
    public sealed virtual void RecordException(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams, MsalServiceException ex);
    public sealed virtual void ResetCache();
    public sealed virtual void TryThrottle(AuthenticationRequestParameters requestParams, IReadOnlyDictionary`2<string, string> bodyParams);
    private void TryThrowException(string thumbprint, ILoggerAdapter logger);
    private static bool IsRequestSupported(AuthenticationRequestParameters requestParams);
    private static string GetRequestStrictThumbprint(IReadOnlyDictionary`2<string, string> bodyParams, string authority, ICryptographyManager crypto);
}
internal class Microsoft.Identity.Client.OAuth2.TokenClient : object {
    private AuthenticationRequestParameters _requestParams;
    private IServiceBundle _serviceBundle;
    private OAuth2Client _oAuth2Client;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _requestInProgress;
    public TokenClient(AuthenticationRequestParameters requestParams);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<SendTokenRequestAsync>d__5")]
public Task`1<MsalTokenResponse> SendTokenRequestAsync(IDictionary`2<string, string> additionalBodyParameters, string scopeOverride, string tokenEndpointOverride, CancellationToken cancellationToken);
    private void AddThrottlingHeader();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<AddBodyParamsAndHeadersAsync>d__7")]
private Task AddBodyParamsAndHeadersAsync(IDictionary`2<string, string> additionalBodyParameters, string scopes, CancellationToken cancellationToken);
    private void AddClaims();
    private void AddExtraHttpHeaders();
    public void AddHeaderToClient(string name, string value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.OAuth2.TokenClient/<SendHttpAndClearTelemetryAsync>d__11")]
private Task`1<MsalTokenResponse> SendHttpAndClearTelemetryAsync(string tokenEndpoint, ILoggerAdapter logger);
    private static string GetDefaultScopes(ISet`1<string> inputScope);
}
internal class Microsoft.Identity.Client.OAuth2.TokenResponseClaim : OAuth2ResponseBaseClaim {
    public static string Code;
    public static string TokenType;
    public static string AccessToken;
    public static string RefreshToken;
    public static string IdToken;
    public static string Scope;
    public static string ClientInfo;
    public static string ExpiresIn;
    public static string CloudInstanceHost;
    public static string CreatedOn;
    public static string ExtendedExpiresIn;
    public static string Authority;
    public static string FamilyId;
    public static string RefreshIn;
    public static string ErrorSubcode;
    public static string ErrorSubcodeCancel;
    public static string TenantId;
    public static string Upn;
    public static string LocalAccountId;
    public static string SpaCode;
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.OsCapabilitiesExtensions : object {
    [ExtensionAttribute]
public static bool IsSystemWebViewAvailable(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static bool IsEmbeddedWebViewAvailable(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static bool IsUserInteractive(IPublicClientApplication publicClientApplication);
    [ExtensionAttribute]
public static X509Certificate2 GetCertificate(IConfidentialClientApplication confidentialClientApplication);
}
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.CssmDbAttributeFormat : Enum {
    public UInt32 value__;
    public static CssmDbAttributeFormat String;
    public static CssmDbAttributeFormat SInt32;
    public static CssmDbAttributeFormat UInt32;
    public static CssmDbAttributeFormat BigNum;
    public static CssmDbAttributeFormat Real;
    public static CssmDbAttributeFormat TimeDate;
    public static CssmDbAttributeFormat Blob;
    public static CssmDbAttributeFormat MultiUInt32;
    public static CssmDbAttributeFormat Complex;
}
[FlagsAttribute]
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.AcceptContextFlag : Enum {
    public int value__;
    public static AcceptContextFlag Zero;
    public static AcceptContextFlag Delegate;
    public static AcceptContextFlag MutualAuth;
    public static AcceptContextFlag ReplayDetect;
    public static AcceptContextFlag SequenceDetect;
    public static AcceptContextFlag Confidentiality;
    public static AcceptContextFlag UseSessionKey;
    public static AcceptContextFlag AllocateMemory;
    public static AcceptContextFlag Connection;
    public static AcceptContextFlag AcceptExtendedError;
    public static AcceptContextFlag AcceptStream;
    public static AcceptContextFlag AcceptIntegrity;
    public static AcceptContextFlag AcceptIdentify;
    public static AcceptContextFlag ProxyBindings;
    public static AcceptContextFlag AllowMissingBindings;
    public static AcceptContextFlag UnverifiedTargetName;
}
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.ContextStatus : Enum {
    public int value__;
    public static ContextStatus RequiresContinuation;
    public static ContextStatus Accepted;
    public static ContextStatus Error;
}
public abstract class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.Credential : object {
    internal abstract virtual CredentialHandle Structify();
    public static Credential Current();
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.CredentialHandle : SafeHandle {
    public bool IsInvalid { get; }
    public CredentialHandle(Void* cred);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
[FlagsAttribute]
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.InitContextFlag : Enum {
    public int value__;
    public static InitContextFlag Zero;
    public static InitContextFlag Delegate;
    public static InitContextFlag MutualAuth;
    public static InitContextFlag ReplayDetect;
    public static InitContextFlag SequenceDetect;
    public static InitContextFlag Confidentiality;
    public static InitContextFlag UseSessionKey;
    public static InitContextFlag AllocateMemory;
    public static InitContextFlag Connection;
    public static InitContextFlag InitExtendedError;
    public static InitContextFlag InitStream;
    public static InitContextFlag InitIntegrity;
    public static InitContextFlag InitManualCredValidation;
    public static InitContextFlag InitUseSuppliedCreds;
    public static InitContextFlag InitIdentify;
    public static InitContextFlag ProxyBindings;
    public static InitContextFlag AllowMissingBindings;
    public static InitContextFlag UnverifiedTargetName;
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.LsaBufferSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.LsaSafeHandle : SafeHandle {
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.LsaTokenSafeHandle : SafeHandle {
    [CompilerGeneratedAttribute]
private bool <Impersonating>k__BackingField;
    public bool Impersonating { get; private set; }
    public bool IsInvalid { get; }
    [CompilerGeneratedAttribute]
public bool get_Impersonating();
    [CompilerGeneratedAttribute]
private void set_Impersonating(bool value);
    public virtual bool get_IsInvalid();
    protected virtual bool ReleaseHandle();
    private void Revert();
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.NativeMethods : object {
    private static string SECUR32;
    private static string ADVAPI32;
    private static string KERNEL32;
    internal static SecStatus InitializeSecurityContext_0(SECURITY_HANDLE& phCredential, IntPtr phContext, string pszTargetName, InitContextFlag fContextReq, int Reserved1, int TargetDataRep, IntPtr pInput, int Reserved2, SECURITY_HANDLE& phNewContext, SecBufferDesc& pOutput, InitContextFlag& pfContextAttr, IntPtr ptsExpiry);
    internal static SecStatus AcquireCredentialsHandle(string pszPrincipal, string pszPackage, int fCredentialUse, IntPtr PAuthenticationID, Void* pAuthData, IntPtr pGetKeyFn, IntPtr pvGetKeyArgument, SECURITY_HANDLE& phCredential, IntPtr ptsExpiry);
    internal static UInt32 FreeCredentialsHandle(SECURITY_HANDLE* handle);
    public static SecStatus DeleteSecurityContext(SECURITY_HANDLE* context);
    public static int LsaDeregisterLogonProcess(IntPtr LsaHandle);
    public static int LsaLookupAuthenticationPackage(LsaSafeHandle LsaHandle, LSA_STRING& PackageName, Int32& AuthenticationPackage);
    public static int LsaConnectUntrusted(LsaSafeHandle& LsaHandle);
    public static int LsaCallAuthenticationPackage(LsaSafeHandle LsaHandle, int AuthenticationPackage, Void* ProtocolSubmitBuffer, int SubmitBufferLength, LsaBufferSafeHandle& ProtocolReturnBuffer, Int32& ReturnBufferLength, Int32& ProtocolStatus);
    public static int LsaFreeReturnBuffer(IntPtr Buffer);
    public static int LsaNtStatusToWinError(int Status);
    public static bool CloseHandle(IntPtr hObject);
    public static bool ImpersonateLoggedOnUser(LsaTokenSafeHandle hToken);
    public static bool RevertToSelf();
    public static void LsaThrowIfError(int result);
}
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.SecStatus : Enum {
    public UInt32 value__;
    public static SecStatus SEC_E_OK;
    public static SecStatus SEC_E_ERROR;
    public static SecStatus SEC_E_INSUFFICIENT_MEMORY;
    public static SecStatus SEC_E_INVALID_HANDLE;
    public static SecStatus SEC_E_TARGET_UNKNOWN;
    public static SecStatus SEC_E_UNSUPPORTED_FUNCTION;
    public static SecStatus SEC_E_INTERNAL_ERROR;
    public static SecStatus SEC_E_SECPKG_NOT_FOUND;
    public static SecStatus SEC_E_INVALID_TOKEN;
    public static SecStatus SEC_E_QOP_NOT_SUPPORTED;
    public static SecStatus SEC_E_LOGON_DENIED;
    public static SecStatus SEC_E_UNKNOWN_CREDENTIALS;
    public static SecStatus SEC_E_NO_CREDENTIALS;
    public static SecStatus SEC_E_MESSAGE_ALTERED;
    public static SecStatus SEC_E_OUT_OF_SEQUENCE;
    public static SecStatus SEC_E_NO_AUTHENTICATING_AUTHORITY;
    public static SecStatus SEC_E_CONTEXT_EXPIRED;
    public static SecStatus SEC_E_INCOMPLETE_MESSAGE;
    public static SecStatus SEC_E_BUFFER_TOO_SMALL;
    public static SecStatus SEC_E_WRONG_PRINCIPAL;
    public static SecStatus SEC_E_CRYPTO_SYSTEM_INVALID;
    public static SecStatus SEC_I_CONTINUE_NEEDED;
    public static SecStatus SEC_I_CONTEXT_EXPIRED;
    public static SecStatus SEC_I_INCOMPLETE_CREDENTIALS;
    public static SecStatus SEC_I_RENEGOTIATE;
}
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.SecurityContextAttribute : Enum {
    public int value__;
    public static SecurityContextAttribute SECPKG_ATTR_SIZES;
    public static SecurityContextAttribute SECPKG_ATTR_NAMES;
    public static SecurityContextAttribute SECPKG_ATTR_LIFESPAN;
    public static SecurityContextAttribute SECPKG_ATTR_DCE_INFO;
    public static SecurityContextAttribute SECPKG_ATTR_STREAM_SIZES;
    public static SecurityContextAttribute SECPKG_ATTR_AUTHORITY;
    public static SecurityContextAttribute SECPKG_ATTR_PACKAGE_INFO;
    public static SecurityContextAttribute SECPKG_ATTR_NEGOTIATION_INFO;
    public static SecurityContextAttribute SECPKG_ATTR_UNIQUE_BINDINGS;
    public static SecurityContextAttribute SECPKG_ATTR_ENDPOINT_BINDINGS;
    public static SecurityContextAttribute SECPKG_ATTR_CLIENT_SPECIFIED_TARGET;
    public static SecurityContextAttribute SECPKG_ATTR_APPLICATION_PROTOCOL;
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.SspiSecurityContext : object {
    private static int SECPKG_CRED_BOTH;
    private static int SECURITY_NETWORK_DREP;
    private static int _maxTokenSize;
    private static InitContextFlag _defaultRequiredFlags;
    private HashSet`1<object> _disposable;
    private Credential _credential;
    private InitContextFlag _clientFlags;
    private SECURITY_HANDLE _credentialsHandle;
    private SECURITY_HANDLE _securityContext;
    private long _logonId;
    [CompilerGeneratedAttribute]
private string <Package>k__BackingField;
    public string Package { get; private set; }
    public SspiSecurityContext(Credential credential, string package, long logonId, InitContextFlag clientFlags);
    [CompilerGeneratedAttribute]
public string get_Package();
    [CompilerGeneratedAttribute]
private void set_Package(string value);
    private static void ThrowIfError(UInt32 result);
    public ContextStatus InitializeSecurityContext(string targetName, Byte[]& clientRequest);
    private void TrackUnmanaged(object thing);
    private void AcquireCredentials();
    public sealed virtual void Dispose();
}
public class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.TicketCacheReader : object {
    private string _spn;
    private SspiSecurityContext _context;
    private bool _disposedValue;
    public TicketCacheReader(string spn, long logonId, string package);
    public Byte[] RequestToken();
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Microsoft.Identity.Client.Platforms.Features.DesktopOs.Kerberos.TicketCacheWriter : object {
    private static string _kerberosPackageName;
    private static string _negotiatePackageName;
    private LsaSafeHandle _lsaHandle;
    private int _selectedAuthPackage;
    private int _negotiateAuthPackage;
    private bool _disposedValue;
    internal TicketCacheWriter(LsaSafeHandle lsaHandle, string packageName);
    public static TicketCacheWriter Connect(string package);
    public void ImportCredential(Byte[] ticketBytes, long luid);
    private void LsaCallAuthenticationPackage(Void* pBuffer, int bufferSize);
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    public sealed virtual void Dispose();
}
internal static class Microsoft.Identity.Client.Platforms.Features.DesktopOs.LibSystem : object {
    private static string LibSystemLib;
    public static IntPtr dlopen(string name, int flags);
    public static IntPtr dlsym(IntPtr handle, string symbol);
    public static IntPtr GetGlobal(IntPtr handle, string symbol);
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.SecKeychainAttribute : ValueType {
    public SecKeychainAttrType Tag;
    public UInt32 Length;
    public IntPtr Data;
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.SecKeychainAttributeInfo : ValueType {
    public UInt32 Count;
    public IntPtr Tag;
    public IntPtr Format;
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.SecKeychainAttributeList : ValueType {
    public UInt32 Count;
    public IntPtr Attributes;
}
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.SecKeychainAttrType : Enum {
    public UInt32 value__;
    public static SecKeychainAttrType AccountItem;
}
internal static class Microsoft.Identity.Client.Platforms.Features.DesktopOs.SecurityFramework : object {
    private static string SecurityFrameworkLib;
    public static IntPtr Handle;
    public static IntPtr kSecClass;
    public static IntPtr kSecMatchLimit;
    public static IntPtr kSecReturnAttributes;
    public static IntPtr kSecReturnRef;
    public static IntPtr kSecReturnPersistentRef;
    public static IntPtr kSecClassGenericPassword;
    public static IntPtr kSecMatchLimitOne;
    public static IntPtr kSecMatchItemList;
    public static IntPtr kSecAttrLabel;
    public static IntPtr kSecAttrAccount;
    public static IntPtr kSecAttrService;
    public static IntPtr kSecValueRef;
    public static IntPtr kSecValueData;
    public static IntPtr kSecReturnData;
    public static int CallerSecuritySession;
    public static int OK;
    public static int ErrorSecNoSuchKeychain;
    public static int ErrorSecInvalidKeychain;
    public static int ErrorSecAuthFailed;
    public static int ErrorSecDuplicateItem;
    public static int ErrorSecItemNotFound;
    public static int ErrorSecInteractionNotAllowed;
    public static int ErrorSecInteractionRequired;
    public static int ErrorSecNoSuchAttr;
    private static SecurityFramework();
    public static int SessionGetInfo(int session, Int32& sessionId, SessionAttributeBits& attributes);
    public static int SecAccessCreate(IntPtr descriptor, IntPtr trustedList, IntPtr& accessRef);
    public static int SecKeychainItemCreateFromContent(IntPtr itemClass, IntPtr attrList, UInt32 length, IntPtr data, IntPtr keychainRef, IntPtr initialAccess, IntPtr& itemRef);
    public static int SecKeychainAddGenericPassword(IntPtr keychain, UInt32 serviceNameLength, string serviceName, UInt32 accountNameLength, string accountName, UInt32 passwordLength, Byte[] passwordData, IntPtr& itemRef);
    public static int SecKeychainFindGenericPassword(IntPtr keychainOrArray, UInt32 serviceNameLength, string serviceName, UInt32 accountNameLength, string accountName, UInt32& passwordLength, IntPtr& passwordData, IntPtr& itemRef);
    public static int SecKeychainItemCopyAttributesAndData(IntPtr itemRef, IntPtr info, IntPtr itemClass, SecKeychainAttributeList** attrList, UInt32* dataLength, Void** data);
    public static int SecKeychainItemModifyAttributesAndData(IntPtr itemRef, IntPtr attrList, UInt32 length, Byte[] data);
    public static int SecKeychainItemDelete(IntPtr itemRef);
    public static int SecKeychainItemFreeContent(IntPtr attrList, IntPtr data);
    public static int SecKeychainItemFreeAttributesAndData(IntPtr attrList, IntPtr data);
    public static int SecItemCopyMatching(IntPtr query, IntPtr& result);
    public static int SecKeychainItemCopyFromPersistentReference(IntPtr persistentItemRef, IntPtr& itemRef);
    public static int SecKeychainItemCopyContent(IntPtr itemRef, IntPtr itemClass, IntPtr attrList, UInt32& length, IntPtr& outData);
}
[FlagsAttribute]
internal enum Microsoft.Identity.Client.Platforms.Features.DesktopOs.SessionAttributeBits : Enum {
    public int value__;
    public static SessionAttributeBits SessionIsRoot;
    public static SessionAttributeBits SessionHasGraphicAccess;
    public static SessionAttributeBits SessionHasTty;
    public static SessionAttributeBits SessionIsRemote;
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.StaTaskScheduler : TaskScheduler {
    private List`1<Thread> _threads;
    private BlockingCollection`1<Task> _tasks;
    public int MaximumConcurrencyLevel { get; }
    public StaTaskScheduler(int numberOfThreads);
    public virtual int get_MaximumConcurrencyLevel();
    public sealed virtual void Dispose();
    protected virtual void QueueTask(Task task);
    protected virtual IEnumerable`1<Task> GetScheduledTasks();
    protected virtual bool TryExecuteTaskInline(Task task, bool taskWasPreviouslyQueued);
    [CompilerGeneratedAttribute]
private Thread <.ctor>b__2_0(int i);
    [CompilerGeneratedAttribute]
private void <.ctor>b__2_2();
}
internal static class Microsoft.Identity.Client.Platforms.Features.DesktopOs.User32 : object {
    private static string LibraryName;
    public static int UOI_FLAGS;
    public static int WSF_VISIBLE;
    public static IntPtr GetProcessWindowStation();
    public static bool GetUserObjectInformation(IntPtr hObj, int nIndex, Void* pvBuffer, UInt32 nLength, UInt32& lpnLengthNeeded);
}
internal class Microsoft.Identity.Client.Platforms.Features.DesktopOs.USEROBJECTFLAGS : ValueType {
    public int fInherit;
    public int fReserved;
    public int dwFlags;
}
internal static class Microsoft.Identity.Client.Platforms.Features.DesktopOs.WindowsDpiHelper : object {
    [CompilerGeneratedAttribute]
private static int <ZoomPercent>k__BackingField;
    public static int ZoomPercent { get; }
    private static WindowsDpiHelper();
    [CompilerGeneratedAttribute]
public static int get_ZoomPercent();
    internal static IntPtr GetDC(IntPtr hWnd);
    internal static int ReleaseDC(IntPtr hWnd, IntPtr hDC);
    internal static int GetDeviceCaps(IntPtr hdc, int nIndex);
    internal static bool IsProcessDPIAware();
}
internal static class Microsoft.Identity.Client.Platforms.Features.DesktopOs.WindowsNativeMethods : object {
    private static int PROCESSOR_ARCHITECTURE_AMD64;
    private static int PROCESSOR_ARCHITECTURE_ARM;
    private static int PROCESSOR_ARCHITECTURE_IA64;
    private static int PROCESSOR_ARCHITECTURE_INTEL;
    public static int ErrorSuccess;
    public static UInt32 GetCurrentProcessId();
    public static UInt32 GetWindowThreadProcessId(IntPtr hWnd, UInt32& lpdwProcessId);
    private static void GetNativeSystemInfo(SYSTEM_INFO& lpSystemInfo);
    public static string GetProcessorArchitecture();
    public static bool GetUserNameEx(int nameFormat, StringBuilder userName, UInt32& userNameSize);
    public static int NetGetJoinInformation(string server, IntPtr& domain, NetJoinStatus& status);
    public static int NetApiBufferFree(IntPtr Buffer);
    public static IntPtr GetDesktopWindow();
    public static IntPtr GetConsoleWindow();
}
[AttributeUsageAttribute("1036")]
internal class Microsoft.Identity.Client.Platforms.net6.JsonObjectAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Title>k__BackingField;
    public string Title { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Title();
    [CompilerGeneratedAttribute]
public void set_Title(string value);
}
internal class Microsoft.Identity.Client.Platforms.net6.JsonStringConverter : JsonConverter`1<string> {
    public virtual string Read(Utf8JsonReader& reader, Type typeToConvert, JsonSerializerOptions options);
    public virtual void Write(Utf8JsonWriter writer, string value, JsonSerializerOptions options);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Kerberos.KerberosSupplementalTicket")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Instance.Discovery.InstanceDiscoveryResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Region.LocalImdsErrorResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Cache.AdalResultWrapper")]
[JsonSerializableAttribute("System.Collections.Generic.List`1<System.Collections.Generic.KeyValuePair`2<System.String,System.Collections.Generic.IEnumerable`1<System.String>>>")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Internal.ClientInfo")]
[JsonSerializableAttribute("Microsoft.Identity.Client.OAuth2.OAuth2ResponseBase")]
[JsonSerializableAttribute("Microsoft.Identity.Client.OAuth2.MsalTokenResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.WsTrust.UserRealmDiscoveryResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Internal.DeviceCodeResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Instance.Validation.AdfsWebFingerResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Internal.JsonWebToken/JWTHeaderWithCertificate")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Internal.JsonWebToken/JWTPayload")]
[JsonSerializableAttribute("Microsoft.Identity.Client.OAuth2.DeviceAuthHeader")]
[JsonSerializableAttribute("Microsoft.Identity.Client.OAuth2.DeviceAuthPayload")]
[JsonSerializableAttribute("Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.ManagedIdentity.ManagedIdentityErrorResponse")]
[JsonSerializableAttribute("Microsoft.Identity.Client.Instance.Oidc.OidcMetadata")]
[JsonSourceGenerationOptionsAttribute]
[GeneratedCodeAttribute("System.Text.Json.SourceGeneration", "6.0.8.11507")]
internal class Microsoft.Identity.Client.Platforms.net6.MsalJsonSerializerContext : JsonSerializerContext {
    [NullableAttribute("0")]
private static MsalJsonSerializerContext s_customContext;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<string> _String;
    [NullableAttribute("2")]
private JsonTypeInfo`1<KerberosKeyTypes> _KerberosKeyTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<KerberosSupplementalTicket> _KerberosSupplementalTicket;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<String[]> _StringArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<InstanceDiscoveryMetadataEntry> _InstanceDiscoveryMetadataEntry;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<InstanceDiscoveryMetadataEntry[]> _InstanceDiscoveryMetadataEntryArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<InstanceDiscoveryResponse> _InstanceDiscoveryResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<List`1<string>> _ListString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<LocalImdsErrorResponse> _LocalImdsErrorResponse;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTimeOffset> _DateTimeOffset;
    [NullableAttribute("2")]
private JsonTypeInfo`1<Nullable`1<DateTimeOffset>> _NullableDateTimeOffset;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Uri> _Uri;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdalUserInfo> _AdalUserInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdalResult> _AdalResult;
    [NullableAttribute("2")]
private JsonTypeInfo`1<bool> _Boolean;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdalResultWrapper> _AdalResultWrapper;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IEnumerable`1<string>> _IEnumerableString;
    [NullableAttribute("2")]
private JsonTypeInfo`1<int> _Int32;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<KeyValuePair`2<string, IEnumerable`1<string>>> _KeyValuePairStringIEnumerableString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<List`1<KeyValuePair`2<string, IEnumerable`1<string>>>> _ListKeyValuePairStringIEnumerableString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ClientInfo> _ClientInfo;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<OAuth2ResponseBase> _OAuth2ResponseBase;
    [NullableAttribute("2")]
private JsonTypeInfo`1<JsonElement> _JsonElement;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Dictionary`2<string, JsonElement>> _DictionaryStringJsonElement;
    [NullableAttribute("2")]
private JsonTypeInfo`1<long> _Int64;
    [NullableAttribute("2")]
private JsonTypeInfo`1<Nullable`1<long>> _NullableInt64;
    [NullableAttribute("2")]
private JsonTypeInfo`1<TokenSource> _TokenSource;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<HttpResponseHeaders> _HttpResponseHeaders;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IDictionary`2<string, string>> _IDictionaryStringString;
    [NullableAttribute("2")]
private JsonTypeInfo`1<HttpStatusCode> _HttpStatusCode;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<HttpResponse> _HttpResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<MsalTokenResponse> _MsalTokenResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<UserRealmDiscoveryResponse> _UserRealmDiscoveryResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DeviceCodeResponse> _DeviceCodeResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<LinksList> _LinksList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<List`1<LinksList>> _ListLinksList;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AdfsWebFingerResponse> _AdfsWebFingerResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Oid> _Oid;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Byte[]> _ByteArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<X509Extension> _X509Extension;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<X509ExtensionCollection> _X509ExtensionCollection;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<X500DistinguishedName> _X500DistinguishedName;
    [NullableAttribute("2")]
private JsonTypeInfo`1<DateTime> _DateTime;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<KeySizes> _KeySizes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<KeySizes[]> _KeySizesArray;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AsymmetricAlgorithm> _AsymmetricAlgorithm;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<AsnEncodedData> _AsnEncodedData;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<PublicKey> _PublicKey;
    [NullableAttribute("2")]
private JsonTypeInfo`1<IntPtr> _IntPtr;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<X509Certificate2> _X509Certificate2;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JWTHeaderWithCertificate> _JWTHeaderWithCertificate;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<JWTPayload> _JWTPayload;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<IList`1<string>> _IListString;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DeviceAuthHeader> _DeviceAuthHeader;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<Lazy`1<long>> _LazyInt64;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<DeviceAuthPayload> _DeviceAuthPayload;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ManagedIdentityResponse> _ManagedIdentityResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<ManagedIdentityErrorResponse> _ManagedIdentityErrorResponse;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private JsonTypeInfo`1<OidcMetadata> _OidcMetadata;
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions <s_defaultOptions>k__BackingField;
    [NullableAttribute("2")]
private static MsalJsonSerializerContext s_defaultContext;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private JsonSerializerOptions <GeneratedSerializerOptions>k__BackingField;
    private static JsonEncodedText PropName_clientKey;
    private static JsonEncodedText PropName_keyType;
    private static JsonEncodedText PropName_messageBuffer;
    private static JsonEncodedText PropName_error;
    private static JsonEncodedText PropName_realm;
    private static JsonEncodedText PropName_sn;
    private static JsonEncodedText PropName_cn;
    private static JsonEncodedText PropName_tenant_discovery_endpoint;
    private static JsonEncodedText PropName_metadata;
    private static JsonEncodedText PropName_suberror;
    private static JsonEncodedText PropName_error_description;
    private static JsonEncodedText PropName_error_codes;
    private static JsonEncodedText PropName_correlation_id;
    private static JsonEncodedText PropName_claims;
    private static JsonEncodedText PropName_preferred_network;
    private static JsonEncodedText PropName_preferred_cache;
    private static JsonEncodedText PropName_aliases;
    private static JsonEncodedText EncodedPropName_6E65776573742D76657273696F6E73;
    private static JsonEncodedText PropName_Result;
    private static JsonEncodedText PropName_RawClientInfo;
    private static JsonEncodedText PropName_RefreshToken;
    private static JsonEncodedText PropName_UserAssertionHash;
    private static JsonEncodedText PropName_UserInfo;
    private static JsonEncodedText PropName_UniqueId;
    private static JsonEncodedText PropName_DisplayableId;
    private static JsonEncodedText PropName_GivenName;
    private static JsonEncodedText PropName_FamilyName;
    private static JsonEncodedText PropName_PasswordExpiresOn;
    private static JsonEncodedText PropName_PasswordChangeUrl;
    private static JsonEncodedText PropName_IdentityProvider;
    private static JsonEncodedText PropName_Key;
    private static JsonEncodedText PropName_Value;
    private static JsonEncodedText PropName_uid;
    private static JsonEncodedText PropName_utid;
    private static JsonEncodedText PropName_Headers;
    private static JsonEncodedText PropName_HeadersAsDictionary;
    private static JsonEncodedText PropName_StatusCode;
    private static JsonEncodedText PropName_UserAgent;
    private static JsonEncodedText PropName_Body;
    private static JsonEncodedText PropName_ver;
    private static JsonEncodedText PropName_account_type;
    private static JsonEncodedText PropName_federation_protocol;
    private static JsonEncodedText PropName_federation_metadata_url;
    private static JsonEncodedText PropName_federation_active_auth_url;
    private static JsonEncodedText PropName_cloud_audience_urn;
    private static JsonEncodedText PropName_domain_name;
    private static JsonEncodedText PropName_IsFederated;
    private static JsonEncodedText PropName_IsManaged;
    private static JsonEncodedText PropName_user_code;
    private static JsonEncodedText PropName_device_code;
    private static JsonEncodedText PropName_verification_url;
    private static JsonEncodedText PropName_verification_uri;
    private static JsonEncodedText PropName_expires_in;
    private static JsonEncodedText PropName_interval;
    private static JsonEncodedText PropName_message;
    private static JsonEncodedText PropName_subject;
    private static JsonEncodedText PropName_links;
    private static JsonEncodedText PropName_rel;
    private static JsonEncodedText PropName_href;
    private static JsonEncodedText PropName_x5t;
    private static JsonEncodedText PropName_kid;
    private static JsonEncodedText PropName_x5c;
    private static JsonEncodedText PropName_typ;
    private static JsonEncodedText PropName_alg;
    private static JsonEncodedText PropName_Archived;
    private static JsonEncodedText PropName_Extensions;
    private static JsonEncodedText PropName_FriendlyName;
    private static JsonEncodedText PropName_HasPrivateKey;
    private static JsonEncodedText PropName_IssuerName;
    private static JsonEncodedText PropName_NotAfter;
    private static JsonEncodedText PropName_NotBefore;
    private static JsonEncodedText PropName_PrivateKey;
    private static JsonEncodedText PropName_PublicKey;
    private static JsonEncodedText PropName_RawData;
    private static JsonEncodedText PropName_SerialNumber;
    private static JsonEncodedText PropName_SignatureAlgorithm;
    private static JsonEncodedText PropName_SubjectName;
    private static JsonEncodedText PropName_Thumbprint;
    private static JsonEncodedText PropName_Version;
    private static JsonEncodedText PropName_Handle;
    private static JsonEncodedText PropName_Issuer;
    private static JsonEncodedText PropName_Subject;
    private static JsonEncodedText PropName_Critical;
    private static JsonEncodedText PropName_Oid;
    private static JsonEncodedText PropName_Name;
    private static JsonEncodedText PropName_KeyExchangeAlgorithm;
    private static JsonEncodedText PropName_KeySize;
    private static JsonEncodedText PropName_LegalKeySizes;
    private static JsonEncodedText PropName_MaxSize;
    private static JsonEncodedText PropName_MinSize;
    private static JsonEncodedText PropName_SkipSize;
    private static JsonEncodedText PropName_EncodedKeyValue;
    private static JsonEncodedText PropName_EncodedParameters;
    private static JsonEncodedText PropName_aud;
    private static JsonEncodedText PropName_iss;
    private static JsonEncodedText PropName_nbf;
    private static JsonEncodedText PropName_exp;
    private static JsonEncodedText PropName_sub;
    private static JsonEncodedText PropName_jti;
    private static JsonEncodedText PropName_iat;
    private static JsonEncodedText PropName_nonce;
    private static JsonEncodedText PropName_IsValueCreated;
    private static JsonEncodedText PropName_access_token;
    private static JsonEncodedText PropName_expires_on;
    private static JsonEncodedText PropName_resource;
    private static JsonEncodedText PropName_token_type;
    private static JsonEncodedText PropName_client_id;
    private static JsonEncodedText PropName_correlationId;
    private static JsonEncodedText PropName_token_endpoint;
    private static JsonEncodedText PropName_authorization_endpoint;
    [NullableAttribute("0")]
public static MsalJsonSerializerContext Custom { get; }
    public JsonTypeInfo`1<string> String { get; }
    public JsonTypeInfo`1<KerberosKeyTypes> KerberosKeyTypes { get; }
    public JsonTypeInfo`1<KerberosSupplementalTicket> KerberosSupplementalTicket { get; }
    public JsonTypeInfo`1<String[]> StringArray { get; }
    public JsonTypeInfo`1<InstanceDiscoveryMetadataEntry> InstanceDiscoveryMetadataEntry { get; }
    public JsonTypeInfo`1<InstanceDiscoveryMetadataEntry[]> InstanceDiscoveryMetadataEntryArray { get; }
    public JsonTypeInfo`1<InstanceDiscoveryResponse> InstanceDiscoveryResponse { get; }
    public JsonTypeInfo`1<List`1<string>> ListString { get; }
    public JsonTypeInfo`1<LocalImdsErrorResponse> LocalImdsErrorResponse { get; }
    public JsonTypeInfo`1<DateTimeOffset> DateTimeOffset { get; }
    public JsonTypeInfo`1<Nullable`1<DateTimeOffset>> NullableDateTimeOffset { get; }
    public JsonTypeInfo`1<Uri> Uri { get; }
    public JsonTypeInfo`1<AdalUserInfo> AdalUserInfo { get; }
    public JsonTypeInfo`1<AdalResult> AdalResult { get; }
    public JsonTypeInfo`1<bool> Boolean { get; }
    public JsonTypeInfo`1<AdalResultWrapper> AdalResultWrapper { get; }
    public JsonTypeInfo`1<IEnumerable`1<string>> IEnumerableString { get; }
    public JsonTypeInfo`1<int> Int32 { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonTypeInfo`1<KeyValuePair`2<string, IEnumerable`1<string>>> KeyValuePairStringIEnumerableString { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public JsonTypeInfo`1<List`1<KeyValuePair`2<string, IEnumerable`1<string>>>> ListKeyValuePairStringIEnumerableString { get; }
    public JsonTypeInfo`1<ClientInfo> ClientInfo { get; }
    public JsonTypeInfo`1<OAuth2ResponseBase> OAuth2ResponseBase { get; }
    public JsonTypeInfo`1<JsonElement> JsonElement { get; }
    public JsonTypeInfo`1<Dictionary`2<string, JsonElement>> DictionaryStringJsonElement { get; }
    public JsonTypeInfo`1<long> Int64 { get; }
    public JsonTypeInfo`1<Nullable`1<long>> NullableInt64 { get; }
    public JsonTypeInfo`1<TokenSource> TokenSource { get; }
    public JsonTypeInfo`1<HttpResponseHeaders> HttpResponseHeaders { get; }
    public JsonTypeInfo`1<IDictionary`2<string, string>> IDictionaryStringString { get; }
    public JsonTypeInfo`1<HttpStatusCode> HttpStatusCode { get; }
    public JsonTypeInfo`1<HttpResponse> HttpResponse { get; }
    public JsonTypeInfo`1<MsalTokenResponse> MsalTokenResponse { get; }
    public JsonTypeInfo`1<UserRealmDiscoveryResponse> UserRealmDiscoveryResponse { get; }
    public JsonTypeInfo`1<DeviceCodeResponse> DeviceCodeResponse { get; }
    public JsonTypeInfo`1<LinksList> LinksList { get; }
    public JsonTypeInfo`1<List`1<LinksList>> ListLinksList { get; }
    public JsonTypeInfo`1<AdfsWebFingerResponse> AdfsWebFingerResponse { get; }
    public JsonTypeInfo`1<Oid> Oid { get; }
    public JsonTypeInfo`1<Byte[]> ByteArray { get; }
    public JsonTypeInfo`1<X509Extension> X509Extension { get; }
    public JsonTypeInfo`1<X509ExtensionCollection> X509ExtensionCollection { get; }
    public JsonTypeInfo`1<X500DistinguishedName> X500DistinguishedName { get; }
    public JsonTypeInfo`1<DateTime> DateTime { get; }
    public JsonTypeInfo`1<KeySizes> KeySizes { get; }
    public JsonTypeInfo`1<KeySizes[]> KeySizesArray { get; }
    public JsonTypeInfo`1<AsymmetricAlgorithm> AsymmetricAlgorithm { get; }
    public JsonTypeInfo`1<AsnEncodedData> AsnEncodedData { get; }
    public JsonTypeInfo`1<PublicKey> PublicKey { get; }
    public JsonTypeInfo`1<IntPtr> IntPtr { get; }
    public JsonTypeInfo`1<X509Certificate2> X509Certificate2 { get; }
    public JsonTypeInfo`1<JWTHeaderWithCertificate> JWTHeaderWithCertificate { get; }
    public JsonTypeInfo`1<JWTPayload> JWTPayload { get; }
    public JsonTypeInfo`1<IList`1<string>> IListString { get; }
    public JsonTypeInfo`1<DeviceAuthHeader> DeviceAuthHeader { get; }
    public JsonTypeInfo`1<Lazy`1<long>> LazyInt64 { get; }
    public JsonTypeInfo`1<DeviceAuthPayload> DeviceAuthPayload { get; }
    public JsonTypeInfo`1<ManagedIdentityResponse> ManagedIdentityResponse { get; }
    public JsonTypeInfo`1<ManagedIdentityErrorResponse> ManagedIdentityErrorResponse { get; }
    public JsonTypeInfo`1<OidcMetadata> OidcMetadata { get; }
    private static JsonSerializerOptions s_defaultOptions { get; }
    public static MsalJsonSerializerContext Default { get; }
    [NullableAttribute("2")]
protected JsonSerializerOptions GeneratedSerializerOptions { get; }
    public MsalJsonSerializerContext(JsonSerializerOptions options);
    private static MsalJsonSerializerContext();
    [NullableContextAttribute("0")]
public static MsalJsonSerializerContext get_Custom();
    public JsonTypeInfo`1<string> get_String();
    public JsonTypeInfo`1<KerberosKeyTypes> get_KerberosKeyTypes();
    public JsonTypeInfo`1<KerberosSupplementalTicket> get_KerberosSupplementalTicket();
    private static JsonPropertyInfo[] KerberosSupplementalTicketPropInit(JsonSerializerContext context);
    private static void KerberosSupplementalTicketSerializeHandler(Utf8JsonWriter writer, KerberosSupplementalTicket value);
    public JsonTypeInfo`1<String[]> get_StringArray();
    private static void StringArraySerializeHandler(Utf8JsonWriter writer, String[] value);
    public JsonTypeInfo`1<InstanceDiscoveryMetadataEntry> get_InstanceDiscoveryMetadataEntry();
    private static JsonPropertyInfo[] InstanceDiscoveryMetadataEntryPropInit(JsonSerializerContext context);
    private static void InstanceDiscoveryMetadataEntrySerializeHandler(Utf8JsonWriter writer, InstanceDiscoveryMetadataEntry value);
    public JsonTypeInfo`1<InstanceDiscoveryMetadataEntry[]> get_InstanceDiscoveryMetadataEntryArray();
    private static void InstanceDiscoveryMetadataEntryArraySerializeHandler(Utf8JsonWriter writer, InstanceDiscoveryMetadataEntry[] value);
    public JsonTypeInfo`1<InstanceDiscoveryResponse> get_InstanceDiscoveryResponse();
    private static JsonPropertyInfo[] InstanceDiscoveryResponsePropInit(JsonSerializerContext context);
    private static void InstanceDiscoveryResponseSerializeHandler(Utf8JsonWriter writer, InstanceDiscoveryResponse value);
    public JsonTypeInfo`1<List`1<string>> get_ListString();
    private static void ListStringSerializeHandler(Utf8JsonWriter writer, List`1<string> value);
    public JsonTypeInfo`1<LocalImdsErrorResponse> get_LocalImdsErrorResponse();
    private static JsonPropertyInfo[] LocalImdsErrorResponsePropInit(JsonSerializerContext context);
    private static void LocalImdsErrorResponseSerializeHandler(Utf8JsonWriter writer, LocalImdsErrorResponse value);
    public JsonTypeInfo`1<DateTimeOffset> get_DateTimeOffset();
    public JsonTypeInfo`1<Nullable`1<DateTimeOffset>> get_NullableDateTimeOffset();
    public JsonTypeInfo`1<Uri> get_Uri();
    public JsonTypeInfo`1<AdalUserInfo> get_AdalUserInfo();
    private static JsonPropertyInfo[] AdalUserInfoPropInit(JsonSerializerContext context);
    private static void AdalUserInfoSerializeHandler(Utf8JsonWriter writer, AdalUserInfo value);
    public JsonTypeInfo`1<AdalResult> get_AdalResult();
    private static JsonPropertyInfo[] AdalResultPropInit(JsonSerializerContext context);
    private static void AdalResultSerializeHandler(Utf8JsonWriter writer, AdalResult value);
    public JsonTypeInfo`1<bool> get_Boolean();
    public JsonTypeInfo`1<AdalResultWrapper> get_AdalResultWrapper();
    private static JsonPropertyInfo[] AdalResultWrapperPropInit(JsonSerializerContext context);
    private static void AdalResultWrapperSerializeHandler(Utf8JsonWriter writer, AdalResultWrapper value);
    public JsonTypeInfo`1<IEnumerable`1<string>> get_IEnumerableString();
    private static void IEnumerableStringSerializeHandler(Utf8JsonWriter writer, IEnumerable`1<string> value);
    public JsonTypeInfo`1<int> get_Int32();
    public JsonTypeInfo`1<KeyValuePair`2<string, IEnumerable`1<string>>> get_KeyValuePairStringIEnumerableString();
    private static JsonPropertyInfo[] KeyValuePairStringIEnumerableStringPropInit(JsonSerializerContext context);
    private static void KeyValuePairStringIEnumerableStringSerializeHandler(Utf8JsonWriter writer, KeyValuePair`2<string, IEnumerable`1<string>> value);
    private static JsonParameterInfoValues[] KeyValuePairStringIEnumerableStringCtorParamInit();
    public JsonTypeInfo`1<List`1<KeyValuePair`2<string, IEnumerable`1<string>>>> get_ListKeyValuePairStringIEnumerableString();
    private static void ListKeyValuePairStringIEnumerableStringSerializeHandler(Utf8JsonWriter writer, List`1<KeyValuePair`2<string, IEnumerable`1<string>>> value);
    public JsonTypeInfo`1<ClientInfo> get_ClientInfo();
    private static JsonPropertyInfo[] ClientInfoPropInit(JsonSerializerContext context);
    private static void ClientInfoSerializeHandler(Utf8JsonWriter writer, ClientInfo value);
    public JsonTypeInfo`1<OAuth2ResponseBase> get_OAuth2ResponseBase();
    private static JsonPropertyInfo[] OAuth2ResponseBasePropInit(JsonSerializerContext context);
    private static void OAuth2ResponseBaseSerializeHandler(Utf8JsonWriter writer, OAuth2ResponseBase value);
    public JsonTypeInfo`1<JsonElement> get_JsonElement();
    public JsonTypeInfo`1<Dictionary`2<string, JsonElement>> get_DictionaryStringJsonElement();
    private static void DictionaryStringJsonElementSerializeHandler(Utf8JsonWriter writer, Dictionary`2<string, JsonElement> value);
    public JsonTypeInfo`1<long> get_Int64();
    public JsonTypeInfo`1<Nullable`1<long>> get_NullableInt64();
    public JsonTypeInfo`1<TokenSource> get_TokenSource();
    public JsonTypeInfo`1<HttpResponseHeaders> get_HttpResponseHeaders();
    private static void HttpResponseHeadersSerializeHandler(Utf8JsonWriter writer, HttpResponseHeaders value);
    public JsonTypeInfo`1<IDictionary`2<string, string>> get_IDictionaryStringString();
    private static void IDictionaryStringStringSerializeHandler(Utf8JsonWriter writer, IDictionary`2<string, string> value);
    public JsonTypeInfo`1<HttpStatusCode> get_HttpStatusCode();
    public JsonTypeInfo`1<HttpResponse> get_HttpResponse();
    private static JsonPropertyInfo[] HttpResponsePropInit(JsonSerializerContext context);
    private static void HttpResponseSerializeHandler(Utf8JsonWriter writer, HttpResponse value);
    public JsonTypeInfo`1<MsalTokenResponse> get_MsalTokenResponse();
    private static JsonPropertyInfo[] MsalTokenResponsePropInit(JsonSerializerContext context);
    public JsonTypeInfo`1<UserRealmDiscoveryResponse> get_UserRealmDiscoveryResponse();
    private static JsonPropertyInfo[] UserRealmDiscoveryResponsePropInit(JsonSerializerContext context);
    private static void UserRealmDiscoveryResponseSerializeHandler(Utf8JsonWriter writer, UserRealmDiscoveryResponse value);
    public JsonTypeInfo`1<DeviceCodeResponse> get_DeviceCodeResponse();
    private static JsonPropertyInfo[] DeviceCodeResponsePropInit(JsonSerializerContext context);
    private static void DeviceCodeResponseSerializeHandler(Utf8JsonWriter writer, DeviceCodeResponse value);
    public JsonTypeInfo`1<LinksList> get_LinksList();
    private static JsonPropertyInfo[] LinksListPropInit(JsonSerializerContext context);
    private static void LinksListSerializeHandler(Utf8JsonWriter writer, LinksList value);
    public JsonTypeInfo`1<List`1<LinksList>> get_ListLinksList();
    private static void ListLinksListSerializeHandler(Utf8JsonWriter writer, List`1<LinksList> value);
    public JsonTypeInfo`1<AdfsWebFingerResponse> get_AdfsWebFingerResponse();
    private static JsonPropertyInfo[] AdfsWebFingerResponsePropInit(JsonSerializerContext context);
    private static void AdfsWebFingerResponseSerializeHandler(Utf8JsonWriter writer, AdfsWebFingerResponse value);
    public JsonTypeInfo`1<Oid> get_Oid();
    private static JsonPropertyInfo[] OidPropInit(JsonSerializerContext context);
    private static void OidSerializeHandler(Utf8JsonWriter writer, Oid value);
    public JsonTypeInfo`1<Byte[]> get_ByteArray();
    public JsonTypeInfo`1<X509Extension> get_X509Extension();
    private static JsonPropertyInfo[] X509ExtensionPropInit(JsonSerializerContext context);
    private static void X509ExtensionSerializeHandler(Utf8JsonWriter writer, X509Extension value);
    public JsonTypeInfo`1<X509ExtensionCollection> get_X509ExtensionCollection();
    private static void X509ExtensionCollectionSerializeHandler(Utf8JsonWriter writer, X509ExtensionCollection value);
    public JsonTypeInfo`1<X500DistinguishedName> get_X500DistinguishedName();
    private static JsonPropertyInfo[] X500DistinguishedNamePropInit(JsonSerializerContext context);
    private static void X500DistinguishedNameSerializeHandler(Utf8JsonWriter writer, X500DistinguishedName value);
    public JsonTypeInfo`1<DateTime> get_DateTime();
    public JsonTypeInfo`1<KeySizes> get_KeySizes();
    private static JsonPropertyInfo[] KeySizesPropInit(JsonSerializerContext context);
    private static void KeySizesSerializeHandler(Utf8JsonWriter writer, KeySizes value);
    private static JsonParameterInfoValues[] KeySizesCtorParamInit();
    public JsonTypeInfo`1<KeySizes[]> get_KeySizesArray();
    private static void KeySizesArraySerializeHandler(Utf8JsonWriter writer, KeySizes[] value);
    public JsonTypeInfo`1<AsymmetricAlgorithm> get_AsymmetricAlgorithm();
    private static JsonPropertyInfo[] AsymmetricAlgorithmPropInit(JsonSerializerContext context);
    private static void AsymmetricAlgorithmSerializeHandler(Utf8JsonWriter writer, AsymmetricAlgorithm value);
    public JsonTypeInfo`1<AsnEncodedData> get_AsnEncodedData();
    private static JsonPropertyInfo[] AsnEncodedDataPropInit(JsonSerializerContext context);
    private static void AsnEncodedDataSerializeHandler(Utf8JsonWriter writer, AsnEncodedData value);
    public JsonTypeInfo`1<PublicKey> get_PublicKey();
    private static JsonPropertyInfo[] PublicKeyPropInit(JsonSerializerContext context);
    private static void PublicKeySerializeHandler(Utf8JsonWriter writer, PublicKey value);
    public JsonTypeInfo`1<IntPtr> get_IntPtr();
    public JsonTypeInfo`1<X509Certificate2> get_X509Certificate2();
    private static JsonPropertyInfo[] X509Certificate2PropInit(JsonSerializerContext context);
    private static void X509Certificate2SerializeHandler(Utf8JsonWriter writer, X509Certificate2 value);
    public JsonTypeInfo`1<JWTHeaderWithCertificate> get_JWTHeaderWithCertificate();
    private static JsonPropertyInfo[] JWTHeaderWithCertificatePropInit(JsonSerializerContext context);
    private static void JWTHeaderWithCertificateSerializeHandler(Utf8JsonWriter writer, JWTHeaderWithCertificate value);
    private static JsonParameterInfoValues[] JWTHeaderWithCertificateCtorParamInit();
    public JsonTypeInfo`1<JWTPayload> get_JWTPayload();
    private static JsonPropertyInfo[] JWTPayloadPropInit(JsonSerializerContext context);
    private static void JWTPayloadSerializeHandler(Utf8JsonWriter writer, JWTPayload value);
    public JsonTypeInfo`1<IList`1<string>> get_IListString();
    private static void IListStringSerializeHandler(Utf8JsonWriter writer, IList`1<string> value);
    public JsonTypeInfo`1<DeviceAuthHeader> get_DeviceAuthHeader();
    private static JsonPropertyInfo[] DeviceAuthHeaderPropInit(JsonSerializerContext context);
    private static void DeviceAuthHeaderSerializeHandler(Utf8JsonWriter writer, DeviceAuthHeader value);
    private static JsonParameterInfoValues[] DeviceAuthHeaderCtorParamInit();
    public JsonTypeInfo`1<Lazy`1<long>> get_LazyInt64();
    private static JsonPropertyInfo[] LazyInt64PropInit(JsonSerializerContext context);
    private static void LazyInt64SerializeHandler(Utf8JsonWriter writer, Lazy`1<long> value);
    public JsonTypeInfo`1<DeviceAuthPayload> get_DeviceAuthPayload();
    private static JsonPropertyInfo[] DeviceAuthPayloadPropInit(JsonSerializerContext context);
    private static void DeviceAuthPayloadSerializeHandler(Utf8JsonWriter writer, DeviceAuthPayload value);
    private static JsonParameterInfoValues[] DeviceAuthPayloadCtorParamInit();
    public JsonTypeInfo`1<ManagedIdentityResponse> get_ManagedIdentityResponse();
    private static JsonPropertyInfo[] ManagedIdentityResponsePropInit(JsonSerializerContext context);
    private static void ManagedIdentityResponseSerializeHandler(Utf8JsonWriter writer, ManagedIdentityResponse value);
    public JsonTypeInfo`1<ManagedIdentityErrorResponse> get_ManagedIdentityErrorResponse();
    private static JsonPropertyInfo[] ManagedIdentityErrorResponsePropInit(JsonSerializerContext context);
    private static void ManagedIdentityErrorResponseSerializeHandler(Utf8JsonWriter writer, ManagedIdentityErrorResponse value);
    public JsonTypeInfo`1<OidcMetadata> get_OidcMetadata();
    private static JsonPropertyInfo[] OidcMetadataPropInit(JsonSerializerContext context);
    private static void OidcMetadataSerializeHandler(Utf8JsonWriter writer, OidcMetadata value);
    [CompilerGeneratedAttribute]
private static JsonSerializerOptions get_s_defaultOptions();
    public static MsalJsonSerializerContext get_Default();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
protected virtual JsonSerializerOptions get_GeneratedSerializerOptions();
    private JsonConverter GetRuntimeProvidedCustomConverter(Type type);
    public virtual JsonTypeInfo GetTypeInfo(Type type);
}
internal class Microsoft.Identity.Client.Platforms.netcore.NetCoreDeviceAuthManager : DeviceAuthManager {
    protected virtual DeviceAuthJWTResponse GetDeviceAuthJwtResponse(string submitUrl, string nonce, X509Certificate2 certificate);
    protected virtual Byte[] SignWithCertificate(DeviceAuthJWTResponse responseJwt, X509Certificate2 certificate);
}
internal class Microsoft.Identity.Client.Platforms.netcore.NetCoreFeatureFlags : object {
    public bool IsFociEnabled { get; }
    public sealed virtual bool get_IsFociEnabled();
}
internal class Microsoft.Identity.Client.Platforms.netcore.NetCorePlatformProxy : AbstractPlatformProxy {
    public bool BrokerSupportsWamAccounts { get; }
    public NetCorePlatformProxy(ILoggerAdapter logger);
    public virtual Task`1<string> GetUserPrincipalNameAsync();
    private string GetUserPrincipalName(int nameFormat);
    protected virtual string InternalGetProcessorArchitecture();
    protected virtual string InternalGetOperatingSystem();
    protected virtual string InternalGetDeviceModel();
    public virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    protected virtual string InternalGetProductName();
    protected virtual string InternalGetCallingApplicationName();
    protected virtual string InternalGetCallingApplicationVersion();
    protected virtual string InternalGetDeviceId();
    public virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    protected virtual IWebUIFactory CreateWebUiFactory();
    protected virtual ICryptographyManager InternalGetCryptographyManager();
    protected virtual IPlatformLogger InternalGetPlatformLogger();
    protected virtual IFeatureFlags CreateFeatureFlags();
    public virtual Task StartDefaultOsBrowserAsync(string url, bool isBrokerConfigured);
    private void OpenLinuxBrowser(string openToolPath, string url);
    private String[] GetOpenToolsLinux(bool isBrokerConfigured);
    public virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider();
    public virtual bool get_BrokerSupportsWamAccounts();
    private bool TryGetExecutablePath(string executable, String& path);
    public virtual IDeviceAuthManager CreateDeviceAuthManager();
}
internal class Microsoft.Identity.Client.Platforms.Shared.DefaultOSBrowser.HttpListenerInterceptor : object {
    private ILoggerAdapter _logger;
    [CompilerGeneratedAttribute]
private Action <TestBeforeTopLevelCall>k__BackingField;
    [CompilerGeneratedAttribute]
private Action`1<string> <TestBeforeStart>k__BackingField;
    [CompilerGeneratedAttribute]
private Action <TestBeforeGetContext>k__BackingField;
    public Action TestBeforeTopLevelCall { get; public set; }
    public Action`1<string> TestBeforeStart { get; public set; }
    public Action TestBeforeGetContext { get; public set; }
    public HttpListenerInterceptor(ILoggerAdapter logger);
    [CompilerGeneratedAttribute]
public Action get_TestBeforeTopLevelCall();
    [CompilerGeneratedAttribute]
public void set_TestBeforeTopLevelCall(Action value);
    [CompilerGeneratedAttribute]
public Action`1<string> get_TestBeforeStart();
    [CompilerGeneratedAttribute]
public void set_TestBeforeStart(Action`1<string> value);
    [CompilerGeneratedAttribute]
public Action get_TestBeforeGetContext();
    [CompilerGeneratedAttribute]
public void set_TestBeforeGetContext(Action value);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.Shared.DefaultOSBrowser.HttpListenerInterceptor/<ListenToSingleRequestAndRespondAsync>d__14")]
public sealed virtual Task`1<Uri> ListenToSingleRequestAndRespondAsync(int port, string path, Func`2<Uri, MessageAndHttpCode> responseProducer, CancellationToken cancellationToken);
    private static void TryStopListening(HttpListener httpListener);
    private void Respond(Func`2<Uri, MessageAndHttpCode> responseProducer, HttpListenerContext context);
}
internal class Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser.DefaultOsBrowserWebUi : object {
    internal static string DefaultSuccessHtml;
    internal static string DefaultFailureHtml;
    private IUriInterceptor _uriInterceptor;
    private ILoggerAdapter _logger;
    private SystemWebViewOptions _webViewOptions;
    private IPlatformProxy _platformProxy;
    public DefaultOsBrowserWebUi(IPlatformProxy proxy, ILoggerAdapter logger, SystemWebViewOptions webViewOptions, IUriInterceptor uriInterceptor);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser.DefaultOsBrowserWebUi/<AcquireAuthorizationAsync>d__7")]
public sealed virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public sealed virtual Uri UpdateRedirectUri(Uri redirectUri);
    private static Uri FindFreeLocalhostRedirectUri(Uri redirectUri);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser.DefaultOsBrowserWebUi/<InterceptAuthorizationUriAsync>d__10")]
private Task`1<Uri> InterceptAuthorizationUriAsync(Uri authorizationUri, Uri redirectUri, bool isBrokerConfigured, CancellationToken cancellationToken);
    internal MessageAndHttpCode GetResponseMessage(Uri authCodeUri);
    private MessageAndHttpCode GetMessage(Uri redirectUri, string message);
}
internal interface Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser.IUriInterceptor {
    public abstract virtual Task`1<Uri> ListenToSingleRequestAndRespondAsync(int port, string path, Func`2<Uri, MessageAndHttpCode> responseProducer, CancellationToken cancellationToken);
}
internal class Microsoft.Identity.Client.Platforms.Shared.Desktop.OsBrowser.MessageAndHttpCode : object {
    [CompilerGeneratedAttribute]
private HttpStatusCode <HttpCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    public HttpStatusCode HttpCode { get; }
    public string Message { get; }
    public MessageAndHttpCode(HttpStatusCode httpCode, string message);
    [CompilerGeneratedAttribute]
public HttpStatusCode get_HttpCode();
    [CompilerGeneratedAttribute]
public string get_Message();
}
internal class Microsoft.Identity.Client.Platforms.Shared.NetStdCore.NetCoreWebUIFactory : object {
    public bool IsSystemWebViewAvailable { get; }
    public bool IsUserInteractive { get; }
    public bool IsEmbeddedWebViewAvailable { get; }
    public sealed virtual bool get_IsSystemWebViewAvailable();
    public sealed virtual bool get_IsUserInteractive();
    public sealed virtual bool get_IsEmbeddedWebViewAvailable();
    public sealed virtual IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference webViewPreference, RequestContext requestContext);
}
internal static class Microsoft.Identity.Client.PlatformsCommon.Factories.PlatformProxyFactory : object {
    public static IPlatformProxy CreatePlatformProxy(ILoggerAdapter logger);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.ICryptographyManager {
    public abstract virtual string CreateBase64UrlEncodedSha256Hash(string input);
    public abstract virtual string GenerateCodeVerifier();
    public abstract virtual string CreateSha256Hash(string input);
    public abstract virtual Byte[] CreateSha256HashBytes(string input);
    public abstract virtual Byte[] SignWithCertificate(string message, X509Certificate2 certificate);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IDeviceAuthManager {
    public abstract virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, String& responseHeader);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IFeatureFlags {
    public bool IsFociEnabled { get; }
    public abstract virtual bool get_IsFociEnabled();
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IPlatformLogger {
    public abstract virtual void Always(string message);
    public abstract virtual void Error(string message);
    public abstract virtual void Warning(string message);
    public abstract virtual void Verbose(string message);
    public abstract virtual void Information(string message);
}
internal interface Microsoft.Identity.Client.PlatformsCommon.Interfaces.IPlatformProxy {
    public bool LegacyCacheRequiresSerialization { get; }
    public ICryptographyManager CryptographyManager { get; }
    public IPlatformLogger PlatformLogger { get; }
    public bool BrokerSupportsWamAccounts { get; }
    public abstract virtual string GetDeviceModel();
    public abstract virtual string GetOperatingSystem();
    public abstract virtual string GetProcessorArchitecture();
    public abstract virtual Task`1<string> GetUserPrincipalNameAsync();
    public abstract virtual string GetCallingApplicationName();
    public abstract virtual string GetCallingApplicationVersion();
    public abstract virtual string GetDeviceId();
    public abstract virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    public abstract virtual string GetProductName();
    public abstract virtual string GetRuntimeVersion();
    public abstract virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    public abstract virtual bool get_LegacyCacheRequiresSerialization();
    public abstract virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions accessorOptions, bool isApplicationTokenCache);
    public abstract virtual ICacheSerializationProvider CreateTokenCacheBlobStorage();
    public abstract virtual ICryptographyManager get_CryptographyManager();
    public abstract virtual IPlatformLogger get_PlatformLogger();
    public abstract virtual IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig);
    public abstract virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider();
    public abstract virtual IFeatureFlags GetFeatureFlags();
    public abstract virtual void SetFeatureFlags(IFeatureFlags featureFlags);
    public abstract virtual Task StartDefaultOsBrowserAsync(string url, bool isBrokerConfigured);
    public abstract virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);
    public abstract virtual IDeviceAuthManager CreateDeviceAuthManager();
    public abstract virtual bool CanBrokerSupportSilentAuth();
    public abstract virtual bool get_BrokerSupportsWamAccounts();
    public abstract virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory();
}
internal abstract class Microsoft.Identity.Client.PlatformsCommon.Shared.AbstractPlatformProxy : object {
    private Lazy`1<string> _callingApplicationName;
    private Lazy`1<string> _callingApplicationVersion;
    private Lazy`1<ICryptographyManager> _cryptographyManager;
    private Lazy`1<string> _deviceId;
    private Lazy`1<string> _deviceModel;
    private Lazy`1<string> _operatingSystem;
    private Lazy`1<IPlatformLogger> _platformLogger;
    private Lazy`1<string> _processorArchitecture;
    private Lazy`1<string> _productName;
    private Lazy`1<string> _runtimeVersion;
    [CompilerGeneratedAttribute]
private IFeatureFlags <OverloadFeatureFlags>k__BackingField;
    [CompilerGeneratedAttribute]
private ILoggerAdapter <Logger>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <UserTokenCacheAccessorForTest>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <AppTokenCacheAccessorForTest>k__BackingField;
    protected IFeatureFlags OverloadFeatureFlags { get; protected set; }
    protected ILoggerAdapter Logger { get; }
    public ITokenCacheAccessor UserTokenCacheAccessorForTest { get; public set; }
    public ITokenCacheAccessor AppTokenCacheAccessorForTest { get; public set; }
    public ICryptographyManager CryptographyManager { get; }
    public IPlatformLogger PlatformLogger { get; }
    public bool BrokerSupportsWamAccounts { get; }
    public bool LegacyCacheRequiresSerialization { get; }
    protected AbstractPlatformProxy(ILoggerAdapter logger);
    [CompilerGeneratedAttribute]
protected IFeatureFlags get_OverloadFeatureFlags();
    [CompilerGeneratedAttribute]
protected void set_OverloadFeatureFlags(IFeatureFlags value);
    [CompilerGeneratedAttribute]
protected ILoggerAdapter get_Logger();
    public sealed virtual IWebUIFactory GetWebUiFactory(ApplicationConfiguration appConfig);
    public sealed virtual string GetDeviceModel();
    public sealed virtual string GetOperatingSystem();
    public sealed virtual string GetProcessorArchitecture();
    public abstract virtual Task`1<string> GetUserPrincipalNameAsync();
    public sealed virtual string GetCallingApplicationName();
    public sealed virtual string GetCallingApplicationVersion();
    public sealed virtual string GetDeviceId();
    public abstract virtual string GetDefaultRedirectUri(string clientId, bool useRecommendedRedirectUri);
    public sealed virtual string GetProductName();
    public sealed virtual string GetRuntimeVersion();
    public abstract virtual ILegacyCachePersistence CreateLegacyCachePersistence();
    [CompilerGeneratedAttribute]
public ITokenCacheAccessor get_UserTokenCacheAccessorForTest();
    [CompilerGeneratedAttribute]
public void set_UserTokenCacheAccessorForTest(ITokenCacheAccessor value);
    [CompilerGeneratedAttribute]
public ITokenCacheAccessor get_AppTokenCacheAccessorForTest();
    [CompilerGeneratedAttribute]
public void set_AppTokenCacheAccessorForTest(ITokenCacheAccessor value);
    public virtual ITokenCacheAccessor CreateTokenCacheAccessor(CacheOptions tokenCacheAccessorOptions, bool isApplicationTokenCache);
    public sealed virtual ICryptographyManager get_CryptographyManager();
    public sealed virtual IPlatformLogger get_PlatformLogger();
    protected abstract virtual IWebUIFactory CreateWebUiFactory();
    protected abstract virtual IFeatureFlags CreateFeatureFlags();
    protected abstract virtual string InternalGetDeviceModel();
    protected abstract virtual string InternalGetOperatingSystem();
    protected abstract virtual string InternalGetProcessorArchitecture();
    protected abstract virtual string InternalGetCallingApplicationName();
    protected abstract virtual string InternalGetCallingApplicationVersion();
    protected abstract virtual string InternalGetDeviceId();
    protected abstract virtual string InternalGetProductName();
    protected abstract virtual ICryptographyManager InternalGetCryptographyManager();
    protected abstract virtual IPlatformLogger InternalGetPlatformLogger();
    protected virtual string InternalGetRuntimeVersion();
    public virtual ICacheSerializationProvider CreateTokenCacheBlobStorage();
    public virtual IFeatureFlags GetFeatureFlags();
    public sealed virtual void SetFeatureFlags(IFeatureFlags featureFlags);
    public virtual Task StartDefaultOsBrowserAsync(string url, bool IBrokerConfigured);
    public virtual IBroker CreateBroker(ApplicationConfiguration appConfig, CoreUIParent uiParent);
    public virtual bool CanBrokerSupportSilentAuth();
    public virtual bool get_BrokerSupportsWamAccounts();
    public virtual IPoPCryptoProvider GetDefaultPoPCryptoProvider();
    public virtual IDeviceAuthManager CreateDeviceAuthManager();
    public virtual IMsalHttpClientFactory CreateDefaultHttpClientFactory();
    public virtual bool get_LegacyCacheRequiresSerialization();
}
[PreserveAttribute]
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.CommonCryptographyManager : object {
    private static ConcurrentDictionary`2<string, RSA> s_certificateToRsaMap;
    private static int s_maximumMapSize;
    private static CommonCryptographyManager();
    public sealed virtual string CreateBase64UrlEncodedSha256Hash(string input);
    public sealed virtual string GenerateCodeVerifier();
    public sealed virtual string CreateSha256Hash(string input);
    public sealed virtual Byte[] CreateSha256HashBytes(string input);
    public virtual Byte[] SignWithCertificate(string message, X509Certificate2 certificate);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.ConsolePlatformLogger : object {
    public sealed virtual void Always(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Warning(string message);
    public sealed virtual void Verbose(string message);
    public sealed virtual void Information(string message);
}
internal static class Microsoft.Identity.Client.PlatformsCommon.Shared.DesktopOsHelper : object {
    private static Lazy`1<bool> s_wamSupportedOSLazy;
    private static Lazy`1<string> s_winVersionLazy;
    private static DesktopOsHelper();
    public static bool IsWindows();
    public static bool IsWin32();
    public static bool IsXamarinOrUwp();
    public static bool IsLinux();
    public static bool IsMac();
    private static bool IsWamSupportedOSInternal();
    private static string GetWindowsVersionStringInternal();
    public static string GetWindowsVersionString();
    public static bool IsWin10OrServerEquivalent();
    public static bool IsUserInteractive();
    private static bool IsInteractiveSessionWindows();
    private static bool IsInteractiveSessionMac();
    private static bool IsInteractiveSessionLinux();
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.DeviceAuthHelper : object {
    public static IDictionary`2<string, string> ParseChallengeData(HttpResponseHeaders responseHeaders);
    public static bool IsDeviceAuthChallenge(HttpResponseHeaders responseHeaders);
    public static string GetBypassChallengeResponse(HttpResponseHeaders responseHeaders);
    public static string GetBypassChallengeResponse(Dictionary`2<string, string> response);
    public static bool CanOSPerformPKeyAuth();
}
internal abstract class Microsoft.Identity.Client.PlatformsCommon.Shared.DeviceAuthManager : object {
    protected abstract virtual DeviceAuthJWTResponse GetDeviceAuthJwtResponse(string submitUrl, string nonce, X509Certificate2 certificate);
    protected abstract virtual Byte[] SignWithCertificate(DeviceAuthJWTResponse responseJwt, X509Certificate2 certificate);
    public sealed virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders responseHeaders, Uri endpointUri, String& responseHeader);
    private void FormatResponseHeader(DeviceAuthJWTResponse responseJWT, Byte[] signedResponse, IDictionary`2<string, string> challengeData, String& responseHeader);
    private X509Certificate2 FindCertificate(IDictionary`2<string, string> challengeData);
    private X509Certificate2 FindCertificateByCertAuthorities(IDictionary`2<string, string> challengeData, X509Certificate2Collection certCollection);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.EventSourcePlatformLogger : object {
    [CompilerGeneratedAttribute]
private static MsalEventSource <MsalEventSource>k__BackingField;
    internal static MsalEventSource MsalEventSource { get; }
    private static EventSourcePlatformLogger();
    [CompilerGeneratedAttribute]
internal static MsalEventSource get_MsalEventSource();
    public sealed virtual void Always(string message);
    public sealed virtual void Error(string message);
    public sealed virtual void Warning(string message);
    public sealed virtual void Verbose(string message);
    public sealed virtual void Information(string message);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryLegacyCachePersistance : object {
    private Byte[] data;
    public sealed virtual Byte[] LoadCache();
    public sealed virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryPartitionedAppTokenCacheAccessor : object {
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> AppMetadataDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> s_appMetadataDictionary;
    protected ILoggerAdapter _logger;
    private CacheOptions _tokenCacheAccessorOptions;
    public InMemoryPartitionedAppTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions);
    private static InMemoryPartitionedAppTokenCacheAccessor();
    public sealed virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void SaveAccount(MsalAccountCacheItem item);
    public sealed virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public sealed virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public sealed virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public sealed virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public sealed virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void DeleteAccount(MsalAccountCacheItem item);
    public virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAccountCacheItem> GetAllAccounts(string partitionKey, ILoggerAdapter requestlogger);
    public sealed virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    public virtual void Clear(ILoggerAdapter requestlogger);
    public virtual bool HasAccessOrRefreshTokens();
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.InMemoryPartitionedUserTokenCacheAccessor : object {
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> AccessTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalRefreshTokenCacheItem>> RefreshTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalIdTokenCacheItem>> IdTokenCacheDictionary;
    internal ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccountCacheItem>> AccountCacheDictionary;
    internal ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> AppMetadataDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccessTokenCacheItem>> s_accessTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalRefreshTokenCacheItem>> s_refreshTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalIdTokenCacheItem>> s_idTokenCacheDictionary;
    private static ConcurrentDictionary`2<string, ConcurrentDictionary`2<string, MsalAccountCacheItem>> s_accountCacheDictionary;
    private static ConcurrentDictionary`2<string, MsalAppMetadataCacheItem> s_appMetadataDictionary;
    protected ILoggerAdapter _logger;
    private CacheOptions _tokenCacheAccessorOptions;
    public InMemoryPartitionedUserTokenCacheAccessor(ILoggerAdapter logger, CacheOptions tokenCacheAccessorOptions);
    private static InMemoryPartitionedUserTokenCacheAccessor();
    public sealed virtual void SaveAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void SaveRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void SaveIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void SaveAccount(MsalAccountCacheItem item);
    public sealed virtual void SaveAppMetadata(MsalAppMetadataCacheItem item);
    public sealed virtual MsalIdTokenCacheItem GetIdToken(MsalAccessTokenCacheItem accessTokenCacheItem);
    public sealed virtual MsalAccountCacheItem GetAccount(MsalAccountCacheItem accountCacheItem);
    public sealed virtual MsalAppMetadataCacheItem GetAppMetadata(MsalAppMetadataCacheItem appMetadataItem);
    public sealed virtual void DeleteAccessToken(MsalAccessTokenCacheItem item);
    public sealed virtual void DeleteRefreshToken(MsalRefreshTokenCacheItem item);
    public sealed virtual void DeleteIdToken(MsalIdTokenCacheItem item);
    public sealed virtual void DeleteAccount(MsalAccountCacheItem item);
    public virtual List`1<MsalAccessTokenCacheItem> GetAllAccessTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalRefreshTokenCacheItem> GetAllRefreshTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalIdTokenCacheItem> GetAllIdTokens(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAccountCacheItem> GetAllAccounts(string partitionKey, ILoggerAdapter requestlogger);
    public virtual List`1<MsalAppMetadataCacheItem> GetAllAppMetadata();
    public void SetiOSKeychainSecurityGroup(string keychainSecurityGroup);
    public virtual void Clear(ILoggerAdapter requestlogger);
    public virtual bool HasAccessOrRefreshTokens();
}
[EventSourceAttribute]
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.MsalEventSource : EventSource {
    [EventAttribute("1")]
internal void Verbose(string message);
    [EventAttribute("2")]
internal void Information(string message);
    [EventAttribute("3")]
internal void Warning(string message);
    [EventAttribute("4")]
internal void Error(string message);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.NullDeviceAuthManager : object {
    public sealed virtual bool TryCreateDeviceAuthChallengeResponse(HttpResponseHeaders headers, Uri endpointUri, String& responseHeader);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.NullLegacyCachePersistence : object {
    public sealed virtual Byte[] LoadCache();
    public sealed virtual void WriteCache(Byte[] serializedCache);
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.PKeyAuthConstants : object {
    public static string DeviceAuthHeaderName;
    public static string DeviceAuthHeaderValue;
    public static string WwwAuthenticateHeader;
    public static string PKeyAuthName;
    public static string ChallengeResponseContext;
    public static string ChallengeResponseVersion;
    public static string PKeyAuthBypassReponseFormat;
}
internal class Microsoft.Identity.Client.PlatformsCommon.Shared.SimpleHttpClientFactory : object {
    private static Lazy`1<HttpClient> s_httpClient;
    private static SimpleHttpClientFactory();
    private static HttpClient InitializeClient();
    public sealed virtual HttpClient GetHttpClient();
}
internal static class Microsoft.Identity.Client.PlatformsCommon.Shared.Win32VersionApi : object {
    private static byte VER_NT_WORKSTATION;
    private static byte VER_NT_DOMAIN_CONTROLLER;
    private static byte VER_NT_SERVER;
    private static byte NT_STATUS_SUCCESS;
    private static int WamSupportedWindows10BuildNumber;
    private static int Windows2019BuildNumber;
    private static int RtlGetVersion(OSVERSIONINFOEXW& versionInformation);
    public static bool IsWamSupportedOs();
}
[AttributeUsageAttribute("32767")]
internal class Microsoft.Identity.Client.PreserveAttribute : Attribute {
    public bool Conditional;
    public bool AllMembers;
}
public class Microsoft.Identity.Client.Prompt : ValueType {
    public static Prompt SelectAccount;
    public static Prompt ForceLogin;
    public static Prompt Consent;
    public static Prompt NoPrompt;
    public static Prompt Create;
    internal static Prompt NotSpecified;
    [CompilerGeneratedAttribute]
private string <PromptValue>k__BackingField;
    internal string PromptValue { get; }
    private Prompt(string promptValue);
    private static Prompt();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
internal string get_PromptValue();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Prompt x, Prompt y);
    public static bool op_Inequality(Prompt x, Prompt y);
}
public class Microsoft.Identity.Client.PublicClientApplication : ClientApplicationBase {
    private static string CurrentOSAccountDescriptor;
    private static IAccount s_currentOsAccount;
    public static IAccount OperatingSystemAccount { get; }
    public bool IsSystemWebViewAvailable { get; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use PublicClientApplicationBuilder instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public PublicClientApplication(string clientId, string authority, TokenCache userTokenCache);
    internal PublicClientApplication(ApplicationConfiguration configuration);
    private static PublicClientApplication();
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, string loginHint, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenInteractive instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenAsync(IEnumerable`1<string> scopes, IAccount account, Prompt prompt, string extraQueryParameters, IEnumerable`1<string> extraScopesToConsent, string authority, UIParent parent);
    [ObsoleteAttribute("Use AcquireTokenByUsernamePassword instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByUsernamePasswordAsync(IEnumerable`1<string> scopes, string username, SecureString securePassword);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenWithDeviceCode instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenWithDeviceCodeAsync(IEnumerable`1<string> scopes, string extraQueryParameters, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByRefreshToken instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
private sealed virtual override Task`1<AuthenticationResult> Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshTokenAsync(IEnumerable`1<string> scopes, string refreshToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Use AcquireTokenByIntegratedWindowsAuth instead. See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public sealed virtual Task`1<AuthenticationResult> AcquireTokenByIntegratedWindowsAuthAsync(IEnumerable`1<string> scopes, string username);
    public static IAccount get_OperatingSystemAccount();
    internal static bool IsOperatingSystemAccount(IAccount account);
    public sealed virtual bool get_IsSystemWebViewAvailable();
    public bool IsEmbeddedWebViewAvailable();
    public bool IsUserInteractive();
    public bool IsBrokerAvailable();
    [CLSCompliantAttribute("False")]
public sealed virtual AcquireTokenInteractiveParameterBuilder AcquireTokenInteractive(IEnumerable`1<string> scopes);
    public sealed virtual AcquireTokenWithDeviceCodeParameterBuilder AcquireTokenWithDeviceCode(IEnumerable`1<string> scopes, Func`2<DeviceCodeResult, Task> deviceCodeResultCallback);
    private sealed virtual override AcquireTokenByRefreshTokenParameterBuilder Microsoft.Identity.Client.IByRefreshToken.AcquireTokenByRefreshToken(IEnumerable`1<string> scopes, string refreshToken);
    public sealed virtual AcquireTokenByIntegratedWindowsAuthParameterBuilder AcquireTokenByIntegratedWindowsAuth(IEnumerable`1<string> scopes);
    [ObsoleteAttribute("Using SecureString is not recommended. Use AcquireTokenByUsernamePassword(IEnumerable<string> scopes, string username, string password) instead.", "False")]
[EditorBrowsableAttribute("1")]
public sealed virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, SecureString password);
    public sealed virtual AcquireTokenByUsernamePasswordParameterBuilder AcquireTokenByUsernamePassword(IEnumerable`1<string> scopes, string username, string password);
    public bool IsProofOfPossessionSupportedByClient();
}
public class Microsoft.Identity.Client.PublicClientApplicationBuilder : AbstractApplicationBuilder`1<PublicClientApplicationBuilder> {
    internal PublicClientApplicationBuilder(ApplicationConfiguration configuration);
    public static PublicClientApplicationBuilder CreateWithApplicationOptions(PublicClientApplicationOptions options);
    public static PublicClientApplicationBuilder Create(string clientId);
    internal PublicClientApplicationBuilder WithUserTokenLegacyCachePersistenceForTest(ILegacyCachePersistence legacyCachePersistence);
    public PublicClientApplicationBuilder WithDefaultRedirectUri();
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithMultiCloudSupport(bool enableMultiCloudSupport);
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithIosKeychainSecurityGroup(string keychainSecurityGroup);
    public PublicClientApplicationBuilder WithBroker(bool enableBroker);
    [ObsoleteAttribute("This API has been replaced with WithBroker(BrokerOptions), which can be found in Microsoft.Identity.Client.Broker package. See https://aka.ms/msal-net-wam for details.", "False")]
public PublicClientApplicationBuilder WithWindowsBrokerOptions(WindowsBrokerOptions options);
    [EditorBrowsableAttribute("1")]
public PublicClientApplicationBuilder WithParentActivityOrWindow(Func`1<object> parentActivityOrWindowFunc);
    private PublicClientApplicationBuilder WithParentFunc(Func`1<object> parentFunc);
    [CLSCompliantAttribute("False")]
public PublicClientApplicationBuilder WithParentActivityOrWindow(Func`1<IntPtr> windowFunc);
    public PublicClientApplicationBuilder WithKerberosTicketClaim(string servicePrincipalName, KerberosTicketContainer ticketContainer);
    public bool IsBrokerAvailable();
    public IPublicClientApplication Build();
    internal PublicClientApplication BuildConcrete();
    internal virtual void Validate();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.PublicClientApplicationExtensions : object {
    [ExtensionAttribute]
public static bool IsProofOfPossessionSupportedByClient(IPublicClientApplication app);
}
public class Microsoft.Identity.Client.PublicClientApplicationOptions : ApplicationOptions {
}
internal interface Microsoft.Identity.Client.Region.IRegionDiscoveryProvider {
    public abstract virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
}
internal interface Microsoft.Identity.Client.Region.IRegionManager {
    public abstract virtual Task`1<string> GetAzureRegionAsync(RequestContext requestContext);
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.Region.LocalImdsErrorResponse : object {
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<string> <NewestVersions>k__BackingField;
    [JsonPropertyNameAttribute("error")]
public string Error { get; public set; }
    [JsonPropertyNameAttribute("newest-versions")]
public List`1<string> NewestVersions { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public List`1<string> get_NewestVersions();
    [CompilerGeneratedAttribute]
public void set_NewestVersions(List`1<string> value);
}
internal enum Microsoft.Identity.Client.Region.RegionAutodetectionSource : Enum {
    public int value__;
    public static RegionAutodetectionSource None;
    public static RegionAutodetectionSource FailedAutoDiscovery;
    public static RegionAutodetectionSource Cache;
    public static RegionAutodetectionSource EnvVariable;
    public static RegionAutodetectionSource Imds;
}
internal class Microsoft.Identity.Client.Region.RegionDiscoveryProvider : object {
    private IRegionManager _regionManager;
    public static string PublicEnvForRegional;
    public RegionDiscoveryProvider(IHttpManager httpManager, bool clearCache);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionDiscoveryProvider/<GetMetadataAsync>d__3")]
public sealed virtual Task`1<InstanceDiscoveryMetadataEntry> GetMetadataAsync(Uri authority, RequestContext requestContext);
    private static InstanceDiscoveryMetadataEntry CreateEntry(string originalEnv, string regionalEnv);
    private string GetRegionalizedEnvironment(Uri authority, string region, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.Region.RegionManager : object {
    private static string ImdsEndpoint;
    private static string DefaultApiVersion;
    private IHttpManager _httpManager;
    private int _imdsCallTimeoutMs;
    private static SemaphoreSlim _lockDiscover;
    private static string s_autoDiscoveredRegion;
    private static bool s_failedAutoDiscovery;
    private static string s_regionDiscoveryDetails;
    public RegionManager(IHttpManager httpManager, int imdsCallTimeout, bool shouldClearStaticCache);
    private static RegionManager();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<GetAzureRegionAsync>d__10")]
public sealed virtual Task`1<string> GetAzureRegionAsync(RequestContext requestContext);
    private static bool IsAutoDiscoveryRequested(string azureRegionConfig);
    private void RecordTelemetry(ApiEvent apiEvent, string azureRegionConfig, RegionInfo discoveredRegion);
    private bool IsTelemetryRecorded(ApiEvent apiEvent);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<DiscoverAndCacheAsync>d__14")]
private Task`1<RegionInfo> DiscoverAndCacheAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<DiscoverAsync>d__15")]
private Task`1<RegionInfo> DiscoverAsync(ILoggerAdapter logger, CancellationToken requestCancellationToken);
    private RegionInfo GetCachedRegion(ILoggerAdapter logger);
    private static bool ValidateRegion(string region, string source, ILoggerAdapter logger);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Region.RegionManager/<GetImdsUriApiVersionAsync>d__18")]
private Task`1<string> GetImdsUriApiVersionAsync(ILoggerAdapter logger, Dictionary`2<string, string> headers, CancellationToken userCancellationToken);
    private Uri BuildImdsUri(string apiVersion);
    private CancellationToken GetCancellationToken(CancellationToken userCancellationToken);
}
public enum Microsoft.Identity.Client.Region.RegionOutcome : Enum {
    public int value__;
    public static RegionOutcome None;
    public static RegionOutcome UserProvidedValid;
    public static RegionOutcome UserProvidedAutodetectionFailed;
    public static RegionOutcome UserProvidedInvalid;
    public static RegionOutcome AutodetectSuccess;
    public static RegionOutcome FallbackToGlobal;
}
public class Microsoft.Identity.Client.RegionDetails : object {
    [CompilerGeneratedAttribute]
private RegionOutcome <RegionOutcome>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionUsed>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AutoDetectionError>k__BackingField;
    public RegionOutcome RegionOutcome { get; }
    public string RegionUsed { get; }
    public string AutoDetectionError { get; }
    public RegionDetails(RegionOutcome regionOutcome, string regionUsed, string autoDetectionError);
    [CompilerGeneratedAttribute]
public RegionOutcome get_RegionOutcome();
    [CompilerGeneratedAttribute]
public string get_RegionUsed();
    [CompilerGeneratedAttribute]
public string get_AutoDetectionError();
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.SSHCertificates.SSHExtensions : object {
    [ExtensionAttribute]
public static AcquireTokenInteractiveParameterBuilder WithSSHCertificateAuthenticationScheme(AcquireTokenInteractiveParameterBuilder builder, string publicKeyJwk, string keyId);
    [ExtensionAttribute]
public static AcquireTokenSilentParameterBuilder WithSSHCertificateAuthenticationScheme(AcquireTokenSilentParameterBuilder builder, string publicKeyJwk, string keyId);
}
public class Microsoft.Identity.Client.SystemWebViewOptions : object {
    [CompilerGeneratedAttribute]
private string <HtmlMessageSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HtmlMessageError>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BrowserRedirectSuccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Uri <BrowserRedirectError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <iOSHidePrivacyPrompt>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<Uri, Task> <OpenBrowserAsync>k__BackingField;
    public string HtmlMessageSuccess { get; public set; }
    public string HtmlMessageError { get; public set; }
    public Uri BrowserRedirectSuccess { get; public set; }
    public Uri BrowserRedirectError { get; public set; }
    public bool iOSHidePrivacyPrompt { get; public set; }
    public Func`2<Uri, Task> OpenBrowserAsync { get; public set; }
    [CompilerGeneratedAttribute]
public string get_HtmlMessageSuccess();
    [CompilerGeneratedAttribute]
public void set_HtmlMessageSuccess(string value);
    [CompilerGeneratedAttribute]
public string get_HtmlMessageError();
    [CompilerGeneratedAttribute]
public void set_HtmlMessageError(string value);
    [CompilerGeneratedAttribute]
public Uri get_BrowserRedirectSuccess();
    [CompilerGeneratedAttribute]
public void set_BrowserRedirectSuccess(Uri value);
    [CompilerGeneratedAttribute]
public Uri get_BrowserRedirectError();
    [CompilerGeneratedAttribute]
public void set_BrowserRedirectError(Uri value);
    [CompilerGeneratedAttribute]
public bool get_iOSHidePrivacyPrompt();
    [CompilerGeneratedAttribute]
public void set_iOSHidePrivacyPrompt(bool value);
    [CompilerGeneratedAttribute]
public Func`2<Uri, Task> get_OpenBrowserAsync();
    [CompilerGeneratedAttribute]
public void set_OpenBrowserAsync(Func`2<Uri, Task> value);
    internal void LogParameters(ILoggerAdapter logger);
    internal static void ValidatePlatformAvailability();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.SystemWebViewOptions/<OpenWithEdgeBrowserAsync>d__27")]
public static Task OpenWithEdgeBrowserAsync(Uri uri);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.SystemWebViewOptions/<OpenWithChromeEdgeBrowserAsync>d__28")]
public static Task OpenWithChromeEdgeBrowserAsync(Uri uri);
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_0();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_1();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_2();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_3();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_4();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_5();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_6();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_7();
    [CompilerGeneratedAttribute]
private string <LogParameters>b__25_8();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public class Microsoft.Identity.Client.Telemetry : object {
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public bool TelemetryOnFailureOnly { get; public set; }
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public static Telemetry GetInstance();
    public bool get_TelemetryOnFailureOnly();
    public void set_TelemetryOnFailureOnly(bool value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public void RegisterReceiver(Receiver r);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
public bool HasRegisteredReceiver();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Telemetry is now specified per ClientApplication.  See https://aka.ms/msal-net-3-breaking-changes and https://aka.ms/msal-net-application-configuration. ", "True")]
private sealed virtual override void Microsoft.Identity.Client.TelemetryCore.ITelemetryReceiver.HandleTelemetryEvents(List`1<Dictionary`2<string, string>> events);
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public enum Microsoft.Identity.Client.TelemetryAudienceType : Enum {
    public int value__;
    public static TelemetryAudienceType PreProduction;
    public static TelemetryAudienceType Production;
}
internal class Microsoft.Identity.Client.TelemetryCallback : MulticastDelegate {
    public TelemetryCallback(object object, IntPtr method);
    public virtual void Invoke(List`1<Dictionary`2<string, string>> events);
    public virtual IAsyncResult BeginInvoke(List`1<Dictionary`2<string, string>> events, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.Identity.Client.TelemetryCore.Http.HttpHeaderSanitizer : object {
    private static String[] s_headerEncodingTable;
    private static HttpHeaderSanitizer();
    public static string SanitizeHeader(string value);
    private static bool HeaderValueNeedsEncoding(string value);
}
internal class Microsoft.Identity.Client.TelemetryCore.Http.HttpTelemetryManager : object {
    private int _successfullSilentCallCount;
    private ConcurrentQueue`1<ApiEvent> _failedEvents;
    public sealed virtual void ResetPreviousUnsentData();
    public sealed virtual void RecordStoppedEvent(ApiEvent stoppedEvent);
    public sealed virtual string GetLastRequestHeader();
    public sealed virtual string GetCurrentRequestHeader(ApiEvent eventInProgress);
}
internal interface Microsoft.Identity.Client.TelemetryCore.IHttpTelemetryManager {
    public abstract virtual void RecordStoppedEvent(ApiEvent apiEvent);
    public abstract virtual string GetCurrentRequestHeader(ApiEvent currentApiEvent);
    public abstract virtual string GetLastRequestHeader();
    public abstract virtual void ResetPreviousUnsentData();
}
internal class Microsoft.Identity.Client.TelemetryCore.Internal.Events.ApiEvent : object {
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private ApiIds <ApiId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAccessTokenCacheHit>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ApiErrorCode>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionUsed>k__BackingField;
    private Nullable`1<RegionAutodetectionSource> _regionAutodetectionSource;
    private Nullable`1<RegionOutcome> _regionOutcome;
    [CompilerGeneratedAttribute]
private string <AutoDetectedRegion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RegionDiscoveryFailureReason>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsTokenCacheSerialized>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsLegacyCacheEnabled>k__BackingField;
    private Nullable`1<CacheRefreshReason> _cacheInfo;
    [CompilerGeneratedAttribute]
private long <DurationInHttpInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private long <DurationInCacheInMs>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<TokenType> <TokenType>k__BackingField;
    public Guid CorrelationId { get; public set; }
    public ApiIds ApiId { get; public set; }
    public string ApiIdString { get; }
    public string TokenEndpoint { get; public set; }
    public bool IsAccessTokenCacheHit { get; public set; }
    public string ApiErrorCode { get; public set; }
    public string RegionUsed { get; public set; }
    public RegionAutodetectionSource RegionAutodetectionSource { get; public set; }
    public string RegionAutodetectionSourceString { get; }
    public RegionOutcome RegionOutcome { get; public set; }
    public string RegionOutcomeString { get; }
    public string AutoDetectedRegion { get; internal set; }
    public string RegionDiscoveryFailureReason { get; public set; }
    public bool IsTokenCacheSerialized { get; public set; }
    public string IsTokenCacheSerializedString { get; }
    public bool IsLegacyCacheEnabled { get; public set; }
    public string IsLegacyCacheEnabledString { get; }
    public CacheRefreshReason CacheInfo { get; public set; }
    public string CacheInfoString { get; }
    public long DurationInHttpInMs { get; public set; }
    public long DurationInCacheInMs { get; public set; }
    public Nullable`1<TokenType> TokenType { get; public set; }
    public string TokenTypeString { get; }
    public ApiEvent(Guid correlationId);
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public void set_CorrelationId(Guid value);
    [CompilerGeneratedAttribute]
public ApiIds get_ApiId();
    [CompilerGeneratedAttribute]
public void set_ApiId(ApiIds value);
    public string get_ApiIdString();
    [CompilerGeneratedAttribute]
public string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public bool get_IsAccessTokenCacheHit();
    [CompilerGeneratedAttribute]
public void set_IsAccessTokenCacheHit(bool value);
    [CompilerGeneratedAttribute]
public string get_ApiErrorCode();
    [CompilerGeneratedAttribute]
public void set_ApiErrorCode(string value);
    [CompilerGeneratedAttribute]
public string get_RegionUsed();
    [CompilerGeneratedAttribute]
public void set_RegionUsed(string value);
    public RegionAutodetectionSource get_RegionAutodetectionSource();
    public void set_RegionAutodetectionSource(RegionAutodetectionSource value);
    public string get_RegionAutodetectionSourceString();
    public RegionOutcome get_RegionOutcome();
    public void set_RegionOutcome(RegionOutcome value);
    public string get_RegionOutcomeString();
    [CompilerGeneratedAttribute]
public string get_AutoDetectedRegion();
    [CompilerGeneratedAttribute]
internal void set_AutoDetectedRegion(string value);
    [CompilerGeneratedAttribute]
public string get_RegionDiscoveryFailureReason();
    [CompilerGeneratedAttribute]
public void set_RegionDiscoveryFailureReason(string value);
    [CompilerGeneratedAttribute]
public bool get_IsTokenCacheSerialized();
    [CompilerGeneratedAttribute]
public void set_IsTokenCacheSerialized(bool value);
    public string get_IsTokenCacheSerializedString();
    [CompilerGeneratedAttribute]
public bool get_IsLegacyCacheEnabled();
    [CompilerGeneratedAttribute]
public void set_IsLegacyCacheEnabled(bool value);
    public string get_IsLegacyCacheEnabledString();
    public CacheRefreshReason get_CacheInfo();
    public void set_CacheInfo(CacheRefreshReason value);
    public string get_CacheInfoString();
    [CompilerGeneratedAttribute]
public long get_DurationInHttpInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInHttpInMs(long value);
    [CompilerGeneratedAttribute]
public long get_DurationInCacheInMs();
    [CompilerGeneratedAttribute]
public void set_DurationInCacheInMs(long value);
    [CompilerGeneratedAttribute]
public Nullable`1<TokenType> get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(Nullable`1<TokenType> value);
    public string get_TokenTypeString();
}
internal interface Microsoft.Identity.Client.TelemetryCore.ITelemetryReceiver {
    public abstract virtual void HandleTelemetryEvents(List`1<Dictionary`2<string, string>> events);
}
internal class Microsoft.Identity.Client.TelemetryCore.TelemetryClient.MsalTelemetryEventDetails : TelemetryEventDetails {
    public MsalTelemetryEventDetails(string eventName);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.TelemetryCore.TelemetryClient.TelemetryClientExtensions : object {
    [ExtensionAttribute]
internal static bool HasEnabledClients(ITelemetryClient[] clients, string eventName);
    [ExtensionAttribute]
internal static void TrackEvent(ITelemetryClient[] clients, TelemetryEventDetails eventDetails);
}
internal static class Microsoft.Identity.Client.TelemetryCore.TelemetryConstants : object {
    public static string HttpTelemetrySchemaVersion;
    public static string HttpTelemetryPipe;
    public static string XClientCurrentTelemetry;
    public static string XClientLastTelemetry;
    public static string False;
    public static string True;
    public static string One;
    public static string Zero;
    public static string CommaDelimiter;
    public static string PlatformFields;
    public static string AcquireTokenEventName;
    public static string ConfigurationUpdateEventName;
    public static string MsalVersion;
    public static string RemainingLifetime;
    public static string PopToken;
    public static string TokenSource;
    public static string CacheInfoTelemetry;
    public static string ErrorCode;
    public static string Duration;
    public static string Succeeded;
    public static string DurationInCache;
    public static string DurationInHttp;
    public static string ActivityId;
    public static string Resource;
}
internal class Microsoft.Identity.Client.TelemetryCore.TelemetryHelper : object {
    private ApiEvent _eventToEnd;
    private IHttpTelemetryManager _httpTelemetryManager;
    private bool _disposedValue;
    public TelemetryHelper(IHttpTelemetryManager httpTelemetryManager, ApiEvent eventBase);
    private void Dispose(bool disposing);
    public sealed virtual void Dispose();
}
public class Microsoft.Identity.Client.TenantProfile : object {
    private MsalIdTokenCacheItem _msalIdTokenCacheItem;
    public string Oid { get; }
    public string TenantId { get; }
    public ClaimsPrincipal ClaimsPrincipal { get; }
    public bool IsHomeTenant { get; }
    internal TenantProfile(MsalIdTokenCacheItem msalIdTokenCacheItem);
    public string get_Oid();
    public string get_TenantId();
    public ClaimsPrincipal get_ClaimsPrincipal();
    public bool get_IsHomeTenant();
}
public class Microsoft.Identity.Client.TokenCache : object {
    internal static int ExpirationTooLongInDays;
    private IFeatureFlags _featureFlags;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _hasStateChanged;
    [CompilerGeneratedAttribute]
private ITokenCacheAccessor <Accessor>k__BackingField;
    [CompilerGeneratedAttribute]
private IServiceBundle <ServiceBundle>k__BackingField;
    [CompilerGeneratedAttribute]
private ILegacyCachePersistence <LegacyCachePersistence>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <UsesDefaultSerialization>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsAppTokenCache>k__BackingField;
    private OptionalSemaphoreSlim _semaphoreSlim;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <BeforeAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <BeforeWrite>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenCacheCallback <AfterAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncBeforeAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncAfterAccess>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`2<TokenCacheNotificationArgs, Task> <AsyncBeforeWrite>k__BackingField;
    private IDictionary`2<string, JsonNode> _unknownNodes;
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("Please use the equivalent flag TokenCacheNotificationArgs.HasStateChanged, which indicates if the operation triggering the notification is modifying the cache or not. Setting the flag is not required.")]
public bool HasStateChanged { get; public set; }
    internal ITokenCacheAccessor Accessor { get; internal set; }
    internal IServiceBundle ServiceBundle { get; }
    internal ILegacyCachePersistence LegacyCachePersistence { get; internal set; }
    internal bool UsesDefaultSerialization { get; internal set; }
    internal string ClientId { get; }
    private ITokenCacheAccessor Microsoft.Identity.Client.ITokenCacheInternal.Accessor { get; }
    private ILegacyCachePersistence Microsoft.Identity.Client.ITokenCacheInternal.LegacyPersistence { get; }
    internal bool IsAppTokenCache { get; }
    private bool Microsoft.Identity.Client.ITokenCacheInternal.IsApplicationCache { get; }
    private OptionalSemaphoreSlim Microsoft.Identity.Client.ITokenCacheInternal.Semaphore { get; }
    internal TokenCacheCallback BeforeAccess { get; internal set; }
    internal TokenCacheCallback BeforeWrite { get; internal set; }
    internal TokenCacheCallback AfterAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncBeforeAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncAfterAccess { get; internal set; }
    internal Func`2<TokenCacheNotificationArgs, Task> AsyncBeforeWrite { get; internal set; }
    internal TokenCache(IServiceBundle serviceBundle, bool isApplicationTokenCache, ICacheSerializationProvider optionalDefaultSerializer);
    internal TokenCache(IServiceBundle serviceBundle, ILegacyCachePersistence legacyCachePersistenceForTest, bool isApplicationTokenCache, ICacheSerializationProvider optionalDefaultCacheSerializer);
    public bool get_HasStateChanged();
    public void set_HasStateChanged(bool value);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual CacheData SerializeUnifiedAndAdalCache();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual void DeserializeUnifiedAndAdalCache(CacheData cacheData);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual Byte[] Serialize();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is expected to be removed in MSAL.NET v5. We recommend using SerializeMsalV3/DeserializeMsalV3. Read more: https://aka.ms/msal-net-3x-cache-breaking-change", "False")]
public sealed virtual void Deserialize(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeAdalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeAdalV3(Byte[] adalV3State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeMsalV2();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeMsalV2(Byte[] msalV2State);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual Byte[] SerializeMsalV3();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This is removed in MSAL.NET v4. Read more: https://aka.ms/msal-net-4x-cache-breaking-change", "False")]
public sealed virtual void DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [CompilerGeneratedAttribute]
internal ITokenCacheAccessor get_Accessor();
    [CompilerGeneratedAttribute]
internal void set_Accessor(ITokenCacheAccessor value);
    [CompilerGeneratedAttribute]
internal IServiceBundle get_ServiceBundle();
    [CompilerGeneratedAttribute]
internal ILegacyCachePersistence get_LegacyCachePersistence();
    [CompilerGeneratedAttribute]
internal void set_LegacyCachePersistence(ILegacyCachePersistence value);
    [CompilerGeneratedAttribute]
internal bool get_UsesDefaultSerialization();
    [CompilerGeneratedAttribute]
internal void set_UsesDefaultSerialization(bool value);
    internal string get_ClientId();
    private sealed virtual override ITokenCacheAccessor Microsoft.Identity.Client.ITokenCacheInternal.get_Accessor();
    private sealed virtual override ILegacyCachePersistence Microsoft.Identity.Client.ITokenCacheInternal.get_LegacyPersistence();
    [CompilerGeneratedAttribute]
internal bool get_IsAppTokenCache();
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.get_IsApplicationCache();
    private sealed virtual override OptionalSemaphoreSlim Microsoft.Identity.Client.ITokenCacheInternal.get_Semaphore();
    public sealed virtual void SetIosKeychainSecurityGroup(string securityGroup);
    private void UpdateAppMetadata(string clientId, string environment, string familyId);
    private void DeleteAccessTokensWithIntersectingScopes(AuthenticationRequestParameters requestParams, IEnumerable`1<string> environmentAliases, string tenantId, HashSet`1<string> scopeSet, string homeAccountId, string tokenType);
    private string GetAccessTokenExpireLogMessageContent(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    private bool RtMatchesAccount(MsalRefreshTokenCacheItem rtItem, MsalAccountCacheItem account);
    private static bool FrtExists(IEnumerable`1<MsalRefreshTokenCacheItem> refreshTokens);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-SaveTokenResponseAsync>d__55")]
private sealed virtual override Task`1<Tuple`3<MsalAccessTokenCacheItem, MsalIdTokenCacheItem, Account>> Microsoft.Identity.Client.ITokenCacheInternal.SaveTokenResponseAsync(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
    private bool ShouldCacheAccessToken(MsalAccessTokenCacheItem msalAccessTokenCacheItem, TokenSource tokenSource);
    private void DumpCacheToLogs(AuthenticationRequestParameters requestParameters);
    private bool IsLegacyAdalCacheEnabled(AuthenticationRequestParameters requestParams);
    private void SaveToLegacyAdalCache(AuthenticationRequestParameters requestParams, MsalTokenResponse response, MsalRefreshTokenCacheItem msalRefreshTokenCacheItem, MsalIdTokenCacheItem msalIdTokenCacheItem, string tenantId, InstanceDiscoveryMetadataEntry instanceDiscoveryMetadata);
    internal static Nullable`1<DateTimeOffset> CalculateSuggestedCacheExpiry(ITokenCacheAccessor accessor, ILoggerAdapter logger);
    private void MergeWamAccountIds(MsalAccountCacheItem msalAccountCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-FindAccessTokenAsync>d__62")]
private sealed virtual override Task`1<MsalAccessTokenCacheItem> Microsoft.Identity.Client.ITokenCacheInternal.FindAccessTokenAsync(AuthenticationRequestParameters requestParams);
    private static void FilterTokensByScopes(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private static void FilterTokensByTokenType(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private static void FilterTokensByHomeAccountTenantOrAssertion(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private MsalAccessTokenCacheItem FilterTokensByExpiry(MsalAccessTokenCacheItem msalAccessTokenCacheItem, AuthenticationRequestParameters requestParams);
    private static MsalAccessTokenCacheItem GetSingleToken(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<FilterTokensByEnvironmentAsync>d__68")]
private Task`1<List`1<MsalAccessTokenCacheItem>> FilterTokensByEnvironmentAsync(List`1<MsalAccessTokenCacheItem> tokenCacheItems, AuthenticationRequestParameters requestParams);
    private MsalAccessTokenCacheItem FilterTokensByPopKeyId(MsalAccessTokenCacheItem item, AuthenticationRequestParameters authenticationRequest);
    private void FilterTokensByClientId(List`1<T> tokenCacheItems);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<ExpireAllAccessTokensForTestAsync>d__71")]
internal Task ExpireAllAccessTokensForTestAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-FindRefreshTokenAsync>d__72")]
private sealed virtual override Task`1<MsalRefreshTokenCacheItem> Microsoft.Identity.Client.ITokenCacheInternal.FindRefreshTokenAsync(AuthenticationRequestParameters requestParams, string familyId);
    private static void FilterRefreshTokensByHomeAccountIdOrAssertion(List`1<MsalRefreshTokenCacheItem> cacheItems, AuthenticationRequestParameters requestParams, string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-IsFociMemberAsync>d__74")]
private sealed virtual override Task`1<Nullable`1<bool>> Microsoft.Identity.Client.ITokenCacheInternal.IsFociMemberAsync(AuthenticationRequestParameters requestParams, string familyId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-GetAccountsAsync>d__75")]
private sealed virtual override Task`1<IEnumerable`1<IAccount>> Microsoft.Identity.Client.ITokenCacheInternal.GetAccountsAsync(AuthenticationRequestParameters requestParameters);
    private static void UpdateMapWithAdalAccountsWithClientInfo(string envFromRequest, IEnumerable`1<string> envAliases, AdalUsersForMsal adalUsers, IDictionary`2<string, Account> clientInfoToAccountMap);
    private void UpdateWithAdalAccountsWithoutClientInfo(string envFromRequest, IEnumerable`1<string> envAliases, AdalUsersForMsal adalUsers, List`1<IAccount> accounts);
    private sealed virtual override MsalIdTokenCacheItem Microsoft.Identity.Client.ITokenCacheInternal.GetIdTokenCacheItem(MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<GetTenantProfilesAsync>d__79")]
private Task`1<IDictionary`2<string, TenantProfile>> GetTenantProfilesAsync(AuthenticationRequestParameters requestParameters, string homeAccountId);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-GetAccountAssociatedWithAccessTokenAsync>d__80")]
private sealed virtual override Task`1<Account> Microsoft.Identity.Client.ITokenCacheInternal.GetAccountAssociatedWithAccessTokenAsync(AuthenticationRequestParameters requestParameters, MsalAccessTokenCacheItem msalAccessTokenCacheItem);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-StopLongRunningOboProcessAsync>d__81")]
private sealed virtual override Task`1<bool> Microsoft.Identity.Client.ITokenCacheInternal.StopLongRunningOboProcessAsync(string longRunningOboCacheKey, AuthenticationRequestParameters requestParameters);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-RemoveAccountAsync>d__82")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.RemoveAccountAsync(IAccount account, AuthenticationRequestParameters requestParameters);
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.HasTokensNoLocks();
    private bool RemoveOboTokensInternal(string oboPartitionKey, RequestContext requestContext);
    internal void RemoveAccountInternal(IAccount account, RequestContext requestContext);
    private int RemoveRefreshTokens(List`1<MsalRefreshTokenCacheItem> refreshTokens, ILoggerAdapter logger, Boolean& filterByClientId);
    private int RemoveAccessTokens(List`1<MsalAccessTokenCacheItem> accessTokens, ILoggerAdapter logger, bool filterByClientId);
    private int RemoveIdTokens(string partitionKey, ILoggerAdapter logger, bool filterByClientId);
    private void RemoveAccounts(IAccount account, ILoggerAdapter logger, bool filterByClientId);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_BeforeAccess();
    [CompilerGeneratedAttribute]
internal void set_BeforeAccess(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_BeforeWrite();
    [CompilerGeneratedAttribute]
internal void set_BeforeWrite(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal TokenCacheCallback get_AfterAccess();
    [CompilerGeneratedAttribute]
internal void set_AfterAccess(TokenCacheCallback value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncBeforeAccess();
    [CompilerGeneratedAttribute]
internal void set_AsyncBeforeAccess(Func`2<TokenCacheNotificationArgs, Task> value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncAfterAccess();
    [CompilerGeneratedAttribute]
internal void set_AsyncAfterAccess(Func`2<TokenCacheNotificationArgs, Task> value);
    [CompilerGeneratedAttribute]
internal Func`2<TokenCacheNotificationArgs, Task> get_AsyncBeforeWrite();
    [CompilerGeneratedAttribute]
internal void set_AsyncBeforeWrite(Func`2<TokenCacheNotificationArgs, Task> value);
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.IsAppSubscribedToSerializationEvents();
    private sealed virtual override bool Microsoft.Identity.Client.ITokenCacheInternal.IsExternalSerializationConfiguredByUser();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnAfterAccessAsync>d__116")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnAfterAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnBeforeAccessAsync>d__117")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnBeforeAccessAsync(TokenCacheNotificationArgs args);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.TokenCache/<Microsoft-Identity-Client-ITokenCacheInternal-OnBeforeWriteAsync>d__118")]
private sealed virtual override Task Microsoft.Identity.Client.ITokenCacheInternal.OnBeforeWriteAsync(TokenCacheNotificationArgs args);
    public sealed virtual void SetBeforeAccess(TokenCacheCallback beforeAccess);
    public sealed virtual void SetAfterAccess(TokenCacheCallback afterAccess);
    public sealed virtual void SetBeforeWrite(TokenCacheCallback beforeWrite);
    public sealed virtual void SetBeforeAccessAsync(Func`2<TokenCacheNotificationArgs, Task> beforeAccess);
    public sealed virtual void SetAfterAccessAsync(Func`2<TokenCacheNotificationArgs, Task> afterAccess);
    public sealed virtual void SetBeforeWriteAsync(Func`2<TokenCacheNotificationArgs, Task> beforeWrite);
    private void Validate();
    private void ResetDefaultDelegates();
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeAdalV3();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeAdalV3(Byte[] adalV3State);
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV2();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV2(Byte[] msalV2State);
    private sealed virtual override Byte[] Microsoft.Identity.Client.ITokenCacheSerializer.SerializeMsalV3();
    private sealed virtual override void Microsoft.Identity.Client.ITokenCacheSerializer.DeserializeMsalV3(Byte[] msalV3State, bool shouldClearExistingCache);
    [CompilerGeneratedAttribute]
private string <SerializeUnifiedAndAdalCache>b__3_0();
    [CompilerGeneratedAttribute]
private string <Microsoft.Identity.Client.ITokenCacheInternal.SaveTokenResponseAsync>b__55_0();
    [CompilerGeneratedAttribute]
private bool <FilterTokensByClientId>b__70_0(T x);
    [CompilerGeneratedAttribute]
private MsalAppMetadataCacheItem <Microsoft.Identity.Client.ITokenCacheInternal.IsFociMemberAsync>b__74_0(string env);
    [CompilerGeneratedAttribute]
private string <Microsoft.Identity.Client.ITokenCacheInternal.StopLongRunningOboProcessAsync>b__81_0();
    [CompilerGeneratedAttribute]
private string <Microsoft.Identity.Client.ITokenCacheInternal.RemoveAccountAsync>b__82_0();
}
public class Microsoft.Identity.Client.TokenCacheCallback : MulticastDelegate {
    public TokenCacheCallback(object object, IntPtr method);
    public virtual void Invoke(TokenCacheNotificationArgs args);
    public virtual IAsyncResult BeginInvoke(TokenCacheNotificationArgs args, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[ExtensionAttribute]
public static class Microsoft.Identity.Client.TokenCacheExtensions : object {
    [ExtensionAttribute]
public static void SetCacheOptions(ITokenCache tokenCache, CacheOptions options);
    private static void ValidatePlatform();
}
public class Microsoft.Identity.Client.TokenCacheNotificationArgs : object {
    [CompilerGeneratedAttribute]
private ITokenCacheSerializer <TokenCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientId>k__BackingField;
    [CompilerGeneratedAttribute]
private IAccount <Account>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasStateChanged>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsApplicationCache>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuggestedCacheKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private CancellationToken <CancellationToken>k__BackingField;
    [CompilerGeneratedAttribute]
private Guid <CorrelationId>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <RequestScopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RequestTenantId>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTimeOffset> <SuggestedCacheExpiry>k__BackingField;
    [CompilerGeneratedAttribute]
private IIdentityLogger <IdentityLogger>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <PiiLoggingEnabled>k__BackingField;
    [EditorBrowsableAttribute("1")]
[DebuggerBrowsableAttribute("0")]
[ObsoleteAttribute("Use Account instead (See https://aka.ms/msal-net-2-released)", "True")]
public IUser User { get; }
    public ITokenCacheSerializer TokenCache { get; }
    public string ClientId { get; }
    public IAccount Account { get; }
    public bool HasStateChanged { get; internal set; }
    public bool IsApplicationCache { get; }
    public string SuggestedCacheKey { get; }
    public bool HasTokens { get; }
    public CancellationToken CancellationToken { get; }
    public Guid CorrelationId { get; }
    public IEnumerable`1<string> RequestScopes { get; }
    public string RequestTenantId { get; }
    public Nullable`1<DateTimeOffset> SuggestedCacheExpiry { get; }
    public IIdentityLogger IdentityLogger { get; }
    public bool PiiLoggingEnabled { get; }
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable`1<string> requestScopes, string requestTenantId);
    public TokenCacheNotificationArgs(ITokenCacheSerializer tokenCache, string clientId, IAccount account, bool hasStateChanged, bool isApplicationCache, string suggestedCacheKey, bool hasTokens, Nullable`1<DateTimeOffset> suggestedCacheExpiry, CancellationToken cancellationToken, Guid correlationId, IEnumerable`1<string> requestScopes, string requestTenantId, IIdentityLogger identityLogger, bool piiLoggingEnabled);
    public IUser get_User();
    [CompilerGeneratedAttribute]
public ITokenCacheSerializer get_TokenCache();
    [CompilerGeneratedAttribute]
public string get_ClientId();
    [CompilerGeneratedAttribute]
public IAccount get_Account();
    [CompilerGeneratedAttribute]
public bool get_HasStateChanged();
    [CompilerGeneratedAttribute]
internal void set_HasStateChanged(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsApplicationCache();
    [CompilerGeneratedAttribute]
public string get_SuggestedCacheKey();
    [CompilerGeneratedAttribute]
public bool get_HasTokens();
    [CompilerGeneratedAttribute]
public CancellationToken get_CancellationToken();
    [CompilerGeneratedAttribute]
public Guid get_CorrelationId();
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_RequestScopes();
    [CompilerGeneratedAttribute]
public string get_RequestTenantId();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTimeOffset> get_SuggestedCacheExpiry();
    [CompilerGeneratedAttribute]
public IIdentityLogger get_IdentityLogger();
    [CompilerGeneratedAttribute]
public bool get_PiiLoggingEnabled();
}
internal static class Microsoft.Identity.Client.TokenResponseHelper : object {
    internal static string NullPreferredUsernameDisplayLabel;
    public static string GetTenantId(IdToken idToken, AuthenticationRequestParameters requestParams);
    public static string GetUsernameFromIdToken(IdToken idToken);
    public static string GetHomeAccountId(AuthenticationRequestParameters requestParams, MsalTokenResponse response, IdToken idToken);
    public static Dictionary`2<string, string> GetWamAccountIds(AuthenticationRequestParameters requestParams, MsalTokenResponse response);
}
public enum Microsoft.Identity.Client.TokenSource : Enum {
    public int value__;
    public static TokenSource IdentityProvider;
    public static TokenSource Cache;
    public static TokenSource Broker;
}
[ObsoleteAttribute("Telemetry is sent automatically by MSAL.NET. See https://aka.ms/msal-net-telemetry.", "False")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.TraceTelemetryConfig : object {
    [CompilerGeneratedAttribute]
private string <SessionId>k__BackingField;
    public TelemetryAudienceType AudienceType { get; }
    public string SessionId { get; }
    public Action`1<ITelemetryEventPayload> DispatchAction { get; }
    public IEnumerable`1<string> AllowedScopes { get; }
    public sealed virtual TelemetryAudienceType get_AudienceType();
    [CompilerGeneratedAttribute]
public sealed virtual string get_SessionId();
    public sealed virtual Action`1<ITelemetryEventPayload> get_DispatchAction();
    public IEnumerable`1<string> get_AllowedScopes();
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.UI.AuthorizationResult : object {
    [CompilerGeneratedAttribute]
private AuthorizationStatus <Status>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ErrorDescription>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudInstanceHost>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ClientInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <State>k__BackingField;
    public AuthorizationStatus Status { get; private set; }
    public string Code { get; public set; }
    public string Error { get; public set; }
    public string ErrorDescription { get; public set; }
    public string CloudInstanceHost { get; public set; }
    public string ClientInfo { get; public set; }
    public string State { get; public set; }
    public static AuthorizationResult FromUri(string webAuthenticationResult);
    public static AuthorizationResult FromPostData(Byte[] postData);
    private static AuthorizationResult FromParsedValues(Dictionary`2<string, string> parameters, string url);
    internal static AuthorizationResult FromStatus(AuthorizationStatus status);
    public static AuthorizationResult FromStatus(AuthorizationStatus status, string error, string errorDescription);
    [CompilerGeneratedAttribute]
public AuthorizationStatus get_Status();
    [CompilerGeneratedAttribute]
private void set_Status(AuthorizationStatus value);
    [CompilerGeneratedAttribute]
public string get_Code();
    [CompilerGeneratedAttribute]
public void set_Code(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_ErrorDescription();
    [CompilerGeneratedAttribute]
public void set_ErrorDescription(string value);
    [CompilerGeneratedAttribute]
public string get_CloudInstanceHost();
    [CompilerGeneratedAttribute]
public void set_CloudInstanceHost(string value);
    [CompilerGeneratedAttribute]
public string get_ClientInfo();
    [CompilerGeneratedAttribute]
public void set_ClientInfo(string value);
    [CompilerGeneratedAttribute]
public string get_State();
    [CompilerGeneratedAttribute]
public void set_State(string value);
}
internal enum Microsoft.Identity.Client.UI.AuthorizationStatus : Enum {
    public int value__;
    public static AuthorizationStatus Success;
    public static AuthorizationStatus ErrorHttp;
    public static AuthorizationStatus ProtocolError;
    public static AuthorizationStatus UserCancel;
    public static AuthorizationStatus UnknownError;
}
internal class Microsoft.Identity.Client.UI.CoreUIParent : object {
    [CompilerGeneratedAttribute]
private SynchronizationContext <SynchronizationContext>k__BackingField;
    [CompilerGeneratedAttribute]
private SystemWebViewOptions <SystemWebViewOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private EmbeddedWebViewOptions <EmbeddedWebviewOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private object <OwnerWindow>k__BackingField;
    internal SynchronizationContext SynchronizationContext { get; internal set; }
    internal SystemWebViewOptions SystemWebViewOptions { get; internal set; }
    internal EmbeddedWebViewOptions EmbeddedWebviewOptions { get; internal set; }
    internal object OwnerWindow { get; internal set; }
    [CompilerGeneratedAttribute]
internal SynchronizationContext get_SynchronizationContext();
    [CompilerGeneratedAttribute]
internal void set_SynchronizationContext(SynchronizationContext value);
    [CompilerGeneratedAttribute]
internal SystemWebViewOptions get_SystemWebViewOptions();
    [CompilerGeneratedAttribute]
internal void set_SystemWebViewOptions(SystemWebViewOptions value);
    [CompilerGeneratedAttribute]
internal EmbeddedWebViewOptions get_EmbeddedWebviewOptions();
    [CompilerGeneratedAttribute]
internal void set_EmbeddedWebviewOptions(EmbeddedWebViewOptions value);
    [CompilerGeneratedAttribute]
internal object get_OwnerWindow();
    [CompilerGeneratedAttribute]
internal void set_OwnerWindow(object value);
}
internal class Microsoft.Identity.Client.UI.CustomWebUiHandler : object {
    private ICustomWebUi _customWebUi;
    public CustomWebUiHandler(ICustomWebUi customWebUi);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.UI.CustomWebUiHandler/<AcquireAuthorizationAsync>d__2")]
public sealed virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public sealed virtual Uri UpdateRedirectUri(Uri redirectUri);
}
internal static class Microsoft.Identity.Client.UI.EmbeddedUiCommon : object {
    public static bool IsAllowedIeOrEdgeAuthorizationRedirect(Uri uri);
}
internal interface Microsoft.Identity.Client.UI.IWebUI {
    public abstract virtual Task`1<AuthorizationResult> AcquireAuthorizationAsync(Uri authorizationUri, Uri redirectUri, RequestContext requestContext, CancellationToken cancellationToken);
    public abstract virtual Uri UpdateRedirectUri(Uri redirectUri);
}
internal interface Microsoft.Identity.Client.UI.IWebUIFactory {
    public bool IsSystemWebViewAvailable { get; }
    public bool IsUserInteractive { get; }
    public bool IsEmbeddedWebViewAvailable { get; }
    public abstract virtual IWebUI CreateAuthenticationDialog(CoreUIParent coreUIParent, WebViewPreference webViewPreference, RequestContext requestContext);
    public abstract virtual bool get_IsSystemWebViewAvailable();
    public abstract virtual bool get_IsUserInteractive();
    public abstract virtual bool get_IsEmbeddedWebViewAvailable();
}
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("UIBehavior struct is now obsolete.  Please use Prompt struct instead.See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
public class Microsoft.Identity.Client.UIBehavior : ValueType {
}
[ObsoleteAttribute("In MSAL.NET 3.x, you should directly pass the Activity (on Xamarin.Android), or Window (on .NET Framework and UWP) using AcquireTokenInteractiveParameterBuilder.WithParentActivityOrWindowSee https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public class Microsoft.Identity.Client.UIParent : object {
    [ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public UIParent(object parent, bool useEmbeddedWebView);
    [ObsoleteAttribute("See https://aka.ms/msal-net-3-breaking-changes. ", "True")]
[EditorBrowsableAttribute("1")]
public static bool IsSystemWebviewAvailable();
}
public enum Microsoft.Identity.Client.UiRequiredExceptionClassification : Enum {
    public int value__;
    public static UiRequiredExceptionClassification None;
    public static UiRequiredExceptionClassification MessageOnly;
    public static UiRequiredExceptionClassification BasicAction;
    public static UiRequiredExceptionClassification AdditionalAction;
    public static UiRequiredExceptionClassification ConsentRequired;
    public static UiRequiredExceptionClassification UserPasswordExpired;
    public static UiRequiredExceptionClassification PromptNeverFailed;
    public static UiRequiredExceptionClassification AcquireTokenSilentFailed;
}
public class Microsoft.Identity.Client.UserAssertion : object {
    [CompilerGeneratedAttribute]
private string <Assertion>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssertionType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssertionHash>k__BackingField;
    public string Assertion { get; private set; }
    public string AssertionType { get; private set; }
    internal string AssertionHash { get; internal set; }
    public UserAssertion(string jwtBearerToken);
    public UserAssertion(string assertion, string assertionType);
    [CompilerGeneratedAttribute]
public string get_Assertion();
    [CompilerGeneratedAttribute]
private void set_Assertion(string value);
    [CompilerGeneratedAttribute]
public string get_AssertionType();
    [CompilerGeneratedAttribute]
private void set_AssertionType(string value);
    [CompilerGeneratedAttribute]
internal string get_AssertionHash();
    [CompilerGeneratedAttribute]
internal void set_AssertionHash(string value);
}
internal static class Microsoft.Identity.Client.Utils.AuthorityHelpers : object {
    public static string GetTenantId(Uri authorityUri);
}
internal static class Microsoft.Identity.Client.Utils.Base64UrlHelpers : object {
    private static char base64PadCharacter;
    private static char base64Character62;
    private static char base64Character63;
    private static char base64UrlCharacter62;
    private static char base64UrlCharacter63;
    internal static Char[] s_base64Table;
    private static Base64UrlHelpers();
    public static string Encode(string arg);
    private static string Encode(Byte[] inArray, int offset, int length);
    public static string Encode(Byte[] inArray);
    internal static string EncodeString(string str);
    public static Byte[] DecodeBytes(string str);
    private static Byte[] UnsafeDecode(string str);
    public static string Decode(string arg);
}
internal static class Microsoft.Identity.Client.Utils.CollectionHelpers : object {
    public static IReadOnlyList`1<T> GetEmptyReadOnlyList();
    public static List`1<T> GetEmptyList();
    public static IDictionary`2<TKey, TValue> GetEmptyDictionary();
}
[DebuggerDisplayAttribute("Count = {Count}")]
internal class Microsoft.Identity.Client.Utils.ConcurrentHashSet`1 : object {
    private static int DefaultCapacity;
    private static int MaxLockNumber;
    private IEqualityComparer`1<T> _comparer;
    private bool _growLockArray;
    private int _budget;
    private Tables modreq(System.Runtime.CompilerServices.IsVolatile) _tables;
    private static int DefaultConcurrencyLevel { get; }
    public int Count { get; }
    public bool IsEmpty { get; }
    private bool System.Collections.Generic.ICollection<T>.IsReadOnly { get; }
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection);
    public ConcurrentHashSet`1(IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, IEnumerable`1<T> collection, IEqualityComparer`1<T> comparer);
    public ConcurrentHashSet`1(int concurrencyLevel, int capacity, IEqualityComparer`1<T> comparer);
    private ConcurrentHashSet`1(int concurrencyLevel, int capacity, bool growLockArray, IEqualityComparer`1<T> comparer);
    private static int get_DefaultConcurrencyLevel();
    public sealed virtual int get_Count();
    public bool get_IsEmpty();
    public bool Add(T item);
    public sealed virtual void Clear();
    public sealed virtual bool Contains(T item);
    public bool TryRemove(T item);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    [IteratorStateMachineAttribute("Microsoft.Identity.Client.Utils.ConcurrentHashSet`1/<GetEnumerator>d__25")]
public sealed virtual IEnumerator`1<T> GetEnumerator();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.Add(T item);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.get_IsReadOnly();
    private sealed virtual override void System.Collections.Generic.ICollection<T>.CopyTo(T[] array, int arrayIndex);
    private sealed virtual override bool System.Collections.Generic.ICollection<T>.Remove(T item);
    private void InitializeFromCollection(IEnumerable`1<T> collection);
    private bool AddInternal(T item, int hashcode, bool acquireLock);
    private static int GetBucket(int hashcode, int bucketCount);
    private static void GetBucketAndLockNo(int hashcode, Int32& bucketNo, Int32& lockNo, int bucketCount, int lockCount);
    private void GrowTable(Tables<T> tables);
    private void AcquireAllLocks(Int32& locksAcquired);
    private void AcquireLocks(int fromInclusive, int toExclusive, Int32& locksAcquired);
    private void ReleaseLocks(int fromInclusive, int toExclusive);
    private void CopyToItems(T[] array, int index);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.CoreHelpers : object {
    internal static string ByteArrayToString(Byte[] input);
    public static string UrlEncode(string message);
    public static string UrlDecode(string message);
    public static void AddKeyValueString(StringBuilder messageBuilder, string key, string value);
    [ExtensionAttribute]
public static string ToQueryParameter(IDictionary`2<string, string> input);
    public static Dictionary`2<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, bool lowercaseKeys, RequestContext requestContext);
    public static Dictionary`2<string, string> ParseKeyValueList(string input, char delimiter, bool urlDecode, RequestContext requestContext);
    internal static List`1<string> SplitWithQuotes(string input, char delimiter);
    private static void AddKeyValueString(StringBuilder messageBuilder, string key, Char[] value);
    internal static string GetCcsClientInfoHint(string userObjectId, string userTenantID);
    internal static string GetCcsUpnHint(string upn);
}
internal static class Microsoft.Identity.Client.Utils.DateTimeHelpers : object {
    public static DateTimeOffset UnixTimestampToDateTime(double unixTimestamp);
    public static Nullable`1<DateTimeOffset> UnixTimestampToDateTimeOrNull(double unixTimestamp);
    public static string DateTimeToUnixTimestamp(DateTimeOffset dateTimeOffset);
    public static long CurrDateTimeInUnixTimestamp();
    public static long DateTimeToUnixTimestampMilliseconds(DateTimeOffset dateTimeOffset);
    public static long GetDurationFromWindowsTimestamp(string windowsTimestampInFuture, ILoggerAdapter logger);
    public static long GetDurationFromNowInSeconds(string unixTimestampInFuture);
    public static Nullable`1<DateTimeOffset> DateTimeOffsetFromDuration(Nullable`1<long> duration);
    public static DateTimeOffset DateTimeOffsetFromDuration(long duration);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.EnumerableExtensions : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(IEnumerable`1<T> input);
    [ExtensionAttribute]
internal static string AsSingleString(IEnumerable`1<string> input);
    [ExtensionAttribute]
internal static bool ContainsOrdinalIgnoreCase(IEnumerable`1<string> set, string toLookFor);
    [ExtensionAttribute]
internal static List`1<T> FilterWithLogging(List`1<T> list, Func`2<T, bool> predicate, ILoggerAdapter logger, string logPrefix, bool updateOriginalCollection);
    [ExtensionAttribute]
internal static void MergeDifferentEntries(IDictionary`2<TKey, TValue> source, IDictionary`2<TKey, TValue> other);
}
internal class Microsoft.Identity.Client.Utils.GuidFactory : object {
    public sealed virtual Guid NewGuid();
}
internal interface Microsoft.Identity.Client.Utils.IGuidFactory {
    public abstract virtual Guid NewGuid();
}
internal interface Microsoft.Identity.Client.Utils.ITimeService {
    public abstract virtual DateTime GetUtcNow();
}
internal static class Microsoft.Identity.Client.Utils.JsonHelper : object {
    internal static string SerializeToJson(T toEncode);
    internal static T DeserializeFromJson(string json);
    internal static T TryToDeserializeFromJson(string json, RequestContext requestContext);
    internal static T DeserializeFromJson(Byte[] jsonByteArray);
    internal static string GetExistingOrEmptyString(JsonObject json, string key);
    internal static string ExtractExistingOrEmptyString(JsonObject json, string key);
    internal static IDictionary`2<string, string> ExtractInnerJsonAsDictionary(JsonObject json, string key);
    internal static T ExtractExistingOrDefault(JsonObject json, string key);
    internal static long ExtractParsedIntOrZero(JsonObject json, string key);
    internal static string JsonObjectToString(JsonObject jsonObject);
    internal static JsonObject ParseIntoJsonObject(string json);
    internal static JsonObject ToJsonObject(JsonNode jsonNode);
    internal static bool TryGetValue(JsonObject json, string propertyName, JsonNode& value);
    internal static T GetValue(JsonNode json);
}
internal class Microsoft.Identity.Client.Utils.OptionalSemaphoreSlim : object {
    private bool _useRealSemaphore;
    private int _noLockCurrentCount;
    private SemaphoreSlim _semaphoreSlim;
    public int CurrentCount { get; }
    public OptionalSemaphoreSlim(bool useRealSemaphore);
    public int get_CurrentCount();
    public string GetCurrentCountLogMessage();
    public void Release();
    public Task WaitAsync(CancellationToken cancellationToken);
    public void Wait();
}
internal static class Microsoft.Identity.Client.Utils.ProcessorCounter : object {
    private static int ProcessorCountRefreshIntervalMs;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _processorCount;
    private static Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lastProcessorCountRefreshTicks;
    internal static int ProcessorCount { get; }
    internal static int get_ProcessorCount();
}
internal static class Microsoft.Identity.Client.Utils.RetryOperationHelper : object {
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.RetryOperationHelper/<ExecuteWithRetryAsync>d__0`1")]
public static Task`1<T> ExecuteWithRetryAsync(Func`1<Task`1<T>> func, int maxAttempts, Nullable`1<TimeSpan> retryInterval, Action`2<int, Exception> onAttemptFailed, ISet`1<Type> allowedExceptions);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.Utils.RetryOperationHelper/<ExecuteWithRetryAsync>d__1")]
public static Task ExecuteWithRetryAsync(Func`1<Task> func, int maxAttempts, Nullable`1<TimeSpan> retryInterval, Action`2<int, Exception> onAttemptFailed, ISet`1<Type> allowedExceptions);
}
internal static class Microsoft.Identity.Client.Utils.ScopeHelper : object {
    private static string DefaultSuffix;
    public static bool ScopeContains(ISet`1<string> outerSet, IEnumerable`1<string> possibleContainedSet);
    public static HashSet`1<string> GetMsalScopes(HashSet`1<string> userScopes);
    public static string GetMsalRuntimeScopes();
    public static bool HasNonMsalScopes(HashSet`1<string> userScopes);
    public static HashSet`1<string> ConvertStringToScopeSet(string singleString);
    public static HashSet`1<string> CreateScopeSet(IEnumerable`1<string> input);
    public static string ScopesToResource(String[] scopes);
    public static string RemoveDefaultSuffixIfPresent(string resource);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.StringExtensions : object {
    [ExtensionAttribute]
public static Byte[] ToByteArray(string stringInput);
    [ExtensionAttribute]
public static string NullIfEmpty(string s);
    [ExtensionAttribute]
public static string NullIfWhiteSpace(string s);
    [ExtensionAttribute]
public static string Replace(string src, string oldValue, string newValue, StringComparison comparison);
}
internal class Microsoft.Identity.Client.Utils.StringWriterWithEncoding : StringWriter {
    [CompilerGeneratedAttribute]
private Encoding <Encoding>k__BackingField;
    public Encoding Encoding { get; }
    public StringWriterWithEncoding(Encoding encoding);
    [CompilerGeneratedAttribute]
public virtual Encoding get_Encoding();
}
internal static class Microsoft.Identity.Client.Utils.TaskUtil : object {
    public static Task CompletedTask { get; }
    public static Task get_CompletedTask();
}
internal class Microsoft.Identity.Client.Utils.TimeService : object {
    public sealed virtual DateTime GetUtcNow();
}
internal class Microsoft.Identity.Client.Utils.TraceWrapper : object {
    public static void WriteLine(string message);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.Utils.UriBuilderExtensions : object {
    private static int DefaultHttpsPort;
    [ExtensionAttribute]
public static void AppendQueryParameters(UriBuilder builder, string queryParams);
    [ExtensionAttribute]
public static void AppendQueryParameters(UriBuilder builder, IDictionary`2<string, string> queryParams);
    [ExtensionAttribute]
public static void AppendOrReplaceQueryParameter(UriBuilder builder, string key, string value);
    public static string GetHttpsUriWithOptionalPort(string host, string tenant, string path, int port);
    public static string GetHttpsUriWithOptionalPort(string uri, int port);
}
[ObsoleteAttribute("This workaround for previous WAM broker implementation is not necessary with the improved broker.", "True")]
[EditorBrowsableAttribute("1")]
public static class Microsoft.Identity.Client.Utils.Windows.WindowsNativeUtils : object {
    public static bool IsElevatedUser();
    public static void InitializeProcessSecurity();
    private static bool IsUserAnAdmin();
    private static int CoInitializeSecurity(IntPtr pVoid, int cAuthSvc, IntPtr asAuthSvc, IntPtr pReserved1, RpcAuthnLevel level, RpcImpLevel impers, IntPtr pAuthList, EoAuthnCap dwCapabilities, IntPtr pReserved3);
}
public class Microsoft.Identity.Client.WindowsBrokerOptions : object {
    [CompilerGeneratedAttribute]
private bool <MsaPassthrough>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ListWindowsWorkAndSchoolAccounts>k__BackingField;
    [CompilerGeneratedAttribute]
private string <HeaderText>k__BackingField;
    [EditorBrowsableAttribute("1")]
public bool MsaPassthrough { get; public set; }
    public bool ListWindowsWorkAndSchoolAccounts { get; public set; }
    public string HeaderText { get; public set; }
    internal static WindowsBrokerOptions CreateDefault();
    [CompilerGeneratedAttribute]
public bool get_MsaPassthrough();
    [CompilerGeneratedAttribute]
public void set_MsaPassthrough(bool value);
    [CompilerGeneratedAttribute]
public bool get_ListWindowsWorkAndSchoolAccounts();
    [CompilerGeneratedAttribute]
public void set_ListWindowsWorkAndSchoolAccounts(bool value);
    [CompilerGeneratedAttribute]
public string get_HeaderText();
    [CompilerGeneratedAttribute]
public void set_HeaderText(string value);
    internal static void ValidatePlatformAvailability();
}
internal class Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler : object {
    private RequestContext _requestContext;
    private IServiceBundle _serviceBundle;
    public CommonNonInteractiveHandler(RequestContext requestContext, IServiceBundle serviceBundle);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<GetPlatformUserAsync>d__3")]
public Task`1<string> GetPlatformUserAsync();
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<QueryUserRealmDataAsync>d__4")]
public Task`1<UserRealmDiscoveryResponse> QueryUserRealmDataAsync(string userRealmUriPrefix, string username);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<PerformWsTrustMexExchangeAsync>d__5")]
public Task`1<WsTrustResponse> PerformWsTrustMexExchangeAsync(string federationMetadataUrl, string cloudAudienceUrn, UserAuthType userAuthType, string username, string password, string federationMetadataFilename);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.CommonNonInteractiveHandler/<GetWsTrustResponseAsync>d__6")]
internal Task`1<WsTrustResponse> GetWsTrustResponseAsync(UserAuthType userAuthType, string cloudAudienceUrn, WsTrustEndpoint endpoint, string username, string password);
}
internal interface Microsoft.Identity.Client.WsTrust.IWsTrustWebRequestManager {
    public abstract virtual Task`1<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata);
    public abstract virtual Task`1<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext);
    public abstract virtual Task`1<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext);
}
internal class Microsoft.Identity.Client.WsTrust.MexDocument : object {
    private static string WsTrustSoapTransport;
    private Dictionary`2<string, MexPolicy> _policies;
    private Dictionary`2<string, MexPolicy> _bindings;
    public MexDocument(string responseBody);
    public WsTrustEndpoint GetWsTrustUsernamePasswordEndpoint();
    public WsTrustEndpoint GetWsTrustWindowsTransportEndpoint();
    private WsTrustEndpoint GetWsTrustEndpoint(UserAuthType userAuthType);
    private MexPolicy SelectPolicy(UserAuthType userAuthType);
    private void ReadPolicies(XContainer mexDocument);
    private void ReadPolicyBindings(XContainer mexDocument);
    private void SetPolicyEndpointAddresses(XContainer mexDocument);
    private IEnumerable`1<XElement> FindElements(XContainer mexDocument, XNamespace xNamespace, string element);
    private void AddPolicy(XElement policy, UserAuthType policyAuthType);
}
[ExtensionAttribute]
internal static class Microsoft.Identity.Client.WsTrust.SecureStringExtensions : object {
    [ExtensionAttribute]
public static Char[] PasswordToCharArray(SecureString secureString);
}
internal enum Microsoft.Identity.Client.WsTrust.UserAuthType : Enum {
    public int value__;
    public static UserAuthType IntegratedAuth;
    public static UserAuthType UsernamePassword;
}
[JsonObjectAttribute]
[PreserveAttribute]
internal class Microsoft.Identity.Client.WsTrust.UserRealmDiscoveryResponse : object {
    [CompilerGeneratedAttribute]
private string <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AccountType>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationProtocol>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationMetadataUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FederationActiveAuthUrl>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CloudAudienceUrn>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DomainName>k__BackingField;
    [JsonPropertyNameAttribute("ver")]
public string Version { get; public set; }
    [JsonPropertyNameAttribute("account_type")]
public string AccountType { get; public set; }
    [JsonPropertyNameAttribute("federation_protocol")]
public string FederationProtocol { get; public set; }
    [JsonPropertyNameAttribute("federation_metadata_url")]
public string FederationMetadataUrl { get; public set; }
    [JsonPropertyNameAttribute("federation_active_auth_url")]
public string FederationActiveAuthUrl { get; public set; }
    [JsonPropertyNameAttribute("cloud_audience_urn")]
public string CloudAudienceUrn { get; public set; }
    [JsonPropertyNameAttribute("domain_name")]
public string DomainName { get; public set; }
    public bool IsFederated { get; }
    public bool IsManaged { get; }
    [CompilerGeneratedAttribute]
public string get_Version();
    [CompilerGeneratedAttribute]
public void set_Version(string value);
    [CompilerGeneratedAttribute]
public string get_AccountType();
    [CompilerGeneratedAttribute]
public void set_AccountType(string value);
    [CompilerGeneratedAttribute]
public string get_FederationProtocol();
    [CompilerGeneratedAttribute]
public void set_FederationProtocol(string value);
    [CompilerGeneratedAttribute]
public string get_FederationMetadataUrl();
    [CompilerGeneratedAttribute]
public void set_FederationMetadataUrl(string value);
    [CompilerGeneratedAttribute]
public string get_FederationActiveAuthUrl();
    [CompilerGeneratedAttribute]
public void set_FederationActiveAuthUrl(string value);
    [CompilerGeneratedAttribute]
public string get_CloudAudienceUrn();
    [CompilerGeneratedAttribute]
public void set_CloudAudienceUrn(string value);
    [CompilerGeneratedAttribute]
public string get_DomainName();
    [CompilerGeneratedAttribute]
public void set_DomainName(string value);
    public bool get_IsFederated();
    public bool get_IsManaged();
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustEndpoint : object {
    private static string EnvelopeNamespaceValue;
    private static string WsuNamespaceValue;
    private ITimeService _timeService;
    private IGuidFactory _guidFactory;
    [CompilerGeneratedAttribute]
private Uri <Uri>k__BackingField;
    [CompilerGeneratedAttribute]
private WsTrustVersion <Version>k__BackingField;
    public Uri Uri { get; }
    public WsTrustVersion Version { get; }
    public WsTrustEndpoint(Uri uri, WsTrustVersion version, ITimeService timeService, IGuidFactory guidFactory);
    [CompilerGeneratedAttribute]
public Uri get_Uri();
    [CompilerGeneratedAttribute]
public WsTrustVersion get_Version();
    public string BuildTokenRequestMessageWindowsIntegratedAuth(string cloudAudienceUri);
    public string BuildTokenRequestMessageUsernamePassword(string cloudAudienceUri, string username, string password);
    private string BuildTokenRequestMessage(UserAuthType authType, string cloudAudienceUri, string username, string password);
    private void AppendSecurityHeader(XmlWriter writer, string username, string password);
    private static string BuildTimeString(DateTime utcTime);
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustResponse : object {
    public static string Saml1Assertion;
    [CompilerGeneratedAttribute]
private string <Token>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    public string Token { get; private set; }
    public string TokenType { get; private set; }
    [CompilerGeneratedAttribute]
public string get_Token();
    [CompilerGeneratedAttribute]
private void set_Token(string value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
private void set_TokenType(string value);
    public static WsTrustResponse CreateFromResponse(string response, WsTrustVersion version);
    public static string ReadErrorResponse(XDocument responseDocument, RequestContext requestContext);
    private static string GetFaultMessage(XElement fault);
    internal static WsTrustResponse CreateFromResponseDocument(XDocument responseDocument, WsTrustVersion version);
}
internal enum Microsoft.Identity.Client.WsTrust.WsTrustVersion : Enum {
    public int value__;
    public static WsTrustVersion WsTrust13;
    public static WsTrustVersion WsTrust2005;
}
internal class Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager : object {
    private IHttpManager _httpManager;
    public WsTrustWebRequestManager(IHttpManager httpManager);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetMexDocumentAsync>d__2")]
public sealed virtual Task`1<MexDocument> GetMexDocumentAsync(string federationMetadataUrl, RequestContext requestContext, string federationMetadata);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetWsTrustResponseAsync>d__3")]
public sealed virtual Task`1<WsTrustResponse> GetWsTrustResponseAsync(WsTrustEndpoint wsTrustEndpoint, string wsTrustRequest, RequestContext requestContext);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WsTrust.WsTrustWebRequestManager/<GetUserRealmAsync>d__4")]
public sealed virtual Task`1<UserRealmDiscoveryResponse> GetUserRealmAsync(string userRealmUriPrefix, string userName, RequestContext requestContext);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.Identity.Client.WwwAuthenticateParameters : object {
    private static ISet`1<string> s_knownAuthenticationSchemes;
    [CompilerGeneratedAttribute]
private string <Resource>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <Scopes>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Authority>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Error>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AuthenticationScheme>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Nonce>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, string> <RawParameters>k__BackingField;
    [ObsoleteAttribute("The client apps should know which App ID URI it requests scopes for.", "True")]
public string Resource { get; public set; }
    [ObsoleteAttribute("The client apps should know which scopes to request for.", "True")]
public IEnumerable`1<string> Scopes { get; public set; }
    public string Authority { get; public set; }
    public string Claims { get; public set; }
    public string Error { get; public set; }
    public string AuthenticationScheme { get; private set; }
    public string Nonce { get; private set; }
    public string Item { get; }
    internal IDictionary`2<string, string> RawParameters { get; private set; }
    private static WwwAuthenticateParameters();
    [CompilerGeneratedAttribute]
public string get_Resource();
    [CompilerGeneratedAttribute]
public void set_Resource(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_Scopes();
    [CompilerGeneratedAttribute]
public void set_Scopes(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_Authority();
    [CompilerGeneratedAttribute]
public void set_Authority(string value);
    [CompilerGeneratedAttribute]
public string get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(string value);
    [CompilerGeneratedAttribute]
public string get_Error();
    [CompilerGeneratedAttribute]
public void set_Error(string value);
    [CompilerGeneratedAttribute]
public string get_AuthenticationScheme();
    [CompilerGeneratedAttribute]
private void set_AuthenticationScheme(string value);
    [CompilerGeneratedAttribute]
public string get_Nonce();
    [CompilerGeneratedAttribute]
private void set_Nonce(string value);
    public string get_Item(string key);
    [CompilerGeneratedAttribute]
internal IDictionary`2<string, string> get_RawParameters();
    [CompilerGeneratedAttribute]
private void set_RawParameters(IDictionary`2<string, string> value);
    public string GetTenantId();
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationResponseAsync(...)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromResourceResponseAsync>d__38")]
[EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with replaced with CreateFromAuthenticationResponseAsync(HttpResponseHeaders, string)")]
public static Task`1<WwwAuthenticateParameters> CreateFromResourceResponseAsync(HttpClient httpClient, string resourceUri, CancellationToken cancellationToken);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and has been replaced with CreateFromAuthenticationHeaders(...)")]
public static WwwAuthenticateParameters CreateFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    [EditorBrowsableAttribute("1")]
[ObsoleteAttribute("This api is now obsolete and should not be used.")]
public static WwwAuthenticateParameters CreateFromWwwAuthenticateHeaderValue(string wwwAuthenticateValue);
    public static Task`1<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromAuthenticationResponseAsync>d__42")]
public static Task`1<WwwAuthenticateParameters> CreateFromAuthenticationResponseAsync(string resourceUri, string scheme, HttpClient httpClient, CancellationToken cancellationToken);
    public static WwwAuthenticateParameters CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    public static Task`1<IReadOnlyList`1<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("Microsoft.Identity.Client.WwwAuthenticateParameters/<CreateFromAuthenticationResponseAsync>d__45")]
public static Task`1<IReadOnlyList`1<WwwAuthenticateParameters>> CreateFromAuthenticationResponseAsync(string resourceUri, HttpClient httpClient, CancellationToken cancellationToken);
    public static IReadOnlyList`1<WwwAuthenticateParameters> CreateFromAuthenticationHeaders(HttpResponseHeaders httpResponseHeaders);
    public static string GetClaimChallengeFromResponseHeaders(HttpResponseHeaders httpResponseHeaders, string scheme);
    private static WwwAuthenticateParameters CreateFromWwwAuthenticationHeaderValue(string wwwAuthenticateValue, string scheme);
    private static String[] GetParsedAuthValueElements(string wwwAuthenticateValue);
    internal static WwwAuthenticateParameters CreateWwwAuthenticateParameters(IDictionary`2<string, string> values, string scheme);
    private static string GetJsonFragment(string inputString);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
