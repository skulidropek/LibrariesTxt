internal class Microsoft.IdentityModel.Tokens.AsymmetricAdapter : object {
    private RSAEncryptionPadding _rsaEncryptionPadding;
    private bool _disposeCryptoOperators;
    private bool _disposed;
    private SignDelegate SignatureFunction;
    private VerifyDelegate VerifyFunction;
    private object _signRsaLock;
    private object _signEcdsaLock;
    private object _verifyRsaLock;
    private object _verifyEcdsaLock;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private ECDsa <ECDsa>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithm <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithmName>k__BackingField;
    [CompilerGeneratedAttribute]
private RSASignaturePadding <RSASignaturePadding>k__BackingField;
    [CompilerGeneratedAttribute]
private RSA <RSA>k__BackingField;
    private string Algorithm { get; private set; }
    private ECDsa ECDsa { get; private set; }
    private HashAlgorithm HashAlgorithm { get; private set; }
    private HashAlgorithmName HashAlgorithmName { get; private set; }
    private RSASignaturePadding RSASignaturePadding { get; private set; }
    private RSA RSA { get; private set; }
    internal AsymmetricAdapter(SecurityKey key, string algorithm, HashAlgorithm hashAlgorithm, HashAlgorithmName hashAlgorithmName, bool requirePrivateKey);
    internal AsymmetricAdapter(SecurityKey key, string algorithm, bool requirePrivateKey);
    internal AsymmetricAdapter(SecurityKey key, string algorithm, HashAlgorithm hashAlgorithm, bool requirePrivateKey);
    [CompilerGeneratedAttribute]
private string get_Algorithm();
    [CompilerGeneratedAttribute]
private void set_Algorithm(string value);
    internal Byte[] Decrypt(Byte[] data);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private ECDsa get_ECDsa();
    [CompilerGeneratedAttribute]
private void set_ECDsa(ECDsa value);
    internal Byte[] Encrypt(Byte[] data);
    [CompilerGeneratedAttribute]
private HashAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithm(HashAlgorithm value);
    [CompilerGeneratedAttribute]
private HashAlgorithmName get_HashAlgorithmName();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithmName(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
private RSASignaturePadding get_RSASignaturePadding();
    [CompilerGeneratedAttribute]
private void set_RSASignaturePadding(RSASignaturePadding value);
    private void Initialize(RSA rsa, string algorithm);
    [CompilerGeneratedAttribute]
private RSA get_RSA();
    [CompilerGeneratedAttribute]
private void set_RSA(RSA value);
    internal Byte[] Sign(Byte[] bytes);
    private Byte[] SignWithECDsa(Byte[] bytes);
    private Byte[] SignWithRsa(Byte[] bytes);
    internal bool Verify(Byte[] bytes, Byte[] signature);
    private bool VerifyWithECDsa(Byte[] bytes, Byte[] signature);
    private bool VerifyWithRsa(Byte[] bytes, Byte[] signature);
}
public abstract class Microsoft.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    internal AsymmetricSecurityKey(SecurityKey key);
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual PrivateKeyStatus get_PrivateKeyStatus();
}
public class Microsoft.IdentityModel.Tokens.AsymmetricSignatureProvider : SignatureProvider {
    private bool _disposed;
    private AsymmetricAdapter _asymmetricAdapter;
    private CryptoProviderFactory _cryptoProviderFactory;
    private IReadOnlyDictionary`2<string, int> _minimumAsymmetricKeySizeInBitsForSigningMap;
    private IReadOnlyDictionary`2<string, int> _minimumAsymmetricKeySizeInBitsForVerifyingMap;
    public static Dictionary`2<string, int> DefaultMinimumAsymmetricKeySizeInBitsForSigningMap;
    public static Dictionary`2<string, int> DefaultMinimumAsymmetricKeySizeInBitsForVerifyingMap;
    public IReadOnlyDictionary`2<string, int> MinimumAsymmetricKeySizeInBitsForSigningMap { get; }
    public IReadOnlyDictionary`2<string, int> MinimumAsymmetricKeySizeInBitsForVerifyingMap { get; }
    internal AsymmetricSignatureProvider(SecurityKey key, string algorithm, CryptoProviderFactory cryptoProviderFactory);
    internal AsymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures, CryptoProviderFactory cryptoProviderFactory);
    public AsymmetricSignatureProvider(SecurityKey key, string algorithm);
    public AsymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures);
    private static AsymmetricSignatureProvider();
    public IReadOnlyDictionary`2<string, int> get_MinimumAsymmetricKeySizeInBitsForSigningMap();
    public IReadOnlyDictionary`2<string, int> get_MinimumAsymmetricKeySizeInBitsForVerifyingMap();
    private PrivateKeyStatus FoundPrivateKey(SecurityKey key);
    protected virtual HashAlgorithmName GetHashAlgorithmName(string algorithm);
    private AsymmetricAdapter ResolveAsymmetricAdapter(SecurityKey key, string algorithm, bool requirePrivateKey);
    public virtual Byte[] Sign(Byte[] input);
    public virtual void ValidateAsymmetricSecurityKeySize(SecurityKey key, string algorithm, bool willCreateSignatures);
    public virtual bool Verify(Byte[] input, Byte[] signature);
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.IdentityModel.Tokens.AudienceValidator : MulticastDelegate {
    public AudienceValidator(object object, IntPtr method);
    public virtual bool Invoke(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.AuthenticatedEncryptionProvider : object {
    private AuthenticatedKeys _authenticatedkeys;
    private string _hmacAlgorithm;
    private SymmetricSignatureProvider _symmetricSignatureProvider;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; private set; }
    public string Context { get; public set; }
    public SecurityKey Key { get; private set; }
    public AuthenticatedEncryptionProvider(SecurityKey key, string algorithm);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
private void set_Algorithm(string value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(SecurityKey value);
    public virtual AuthenticatedEncryptionResult Encrypt(Byte[] plaintext, Byte[] authenticatedData);
    public virtual AuthenticatedEncryptionResult Encrypt(Byte[] plaintext, Byte[] authenticatedData, Byte[] iv);
    public virtual Byte[] Decrypt(Byte[] ciphertext, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    private AuthenticatedKeys GetAlgorithmParameters(SecurityKey key, string algorithm);
    private static string GetHmacAlgorithm(string algorithm);
    protected virtual Byte[] GetKeyBytes(SecurityKey key);
    internal static Byte[] Transform(ICryptoTransform transform, Byte[] input, int inputOffset, int inputLength);
    protected virtual void ValidateKeySize(SecurityKey key, string algorithm);
}
public class Microsoft.IdentityModel.Tokens.AuthenticatedEncryptionResult : object {
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Ciphertext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AuthenticationTag>k__BackingField;
    public SecurityKey Key { get; private set; }
    public Byte[] Ciphertext { get; private set; }
    public Byte[] IV { get; private set; }
    public Byte[] AuthenticationTag { get; private set; }
    public AuthenticatedEncryptionResult(SecurityKey key, Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(SecurityKey value);
    [CompilerGeneratedAttribute]
public Byte[] get_Ciphertext();
    [CompilerGeneratedAttribute]
private void set_Ciphertext(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AuthenticationTag();
    [CompilerGeneratedAttribute]
private void set_AuthenticationTag(Byte[] value);
}
public static class Microsoft.IdentityModel.Tokens.Base64UrlEncoder : object {
    private static char base64PadCharacter;
    private static string doubleBase64PadCharacter;
    private static char base64Character62;
    private static char base64Character63;
    private static char base64UrlCharacter62;
    private static char _base64UrlCharacter63;
    private static Base64UrlEncoder();
    public static string Encode(string arg);
    public static string Encode(Byte[] inArray, int offset, int length);
    public static string Encode(Byte[] inArray);
    public static Byte[] DecodeBytes(string str);
    public static string Decode(string arg);
}
public class Microsoft.IdentityModel.Tokens.CompressionAlgorithms : object {
    public static string Deflate;
}
public class Microsoft.IdentityModel.Tokens.CompressionProviderFactory : object {
    private static CompressionProviderFactory _default;
    [CompilerGeneratedAttribute]
private ICompressionProvider <CustomCompressionProvider>k__BackingField;
    public static CompressionProviderFactory Default { get; public set; }
    public ICompressionProvider CustomCompressionProvider { get; public set; }
    private static CompressionProviderFactory();
    public CompressionProviderFactory(CompressionProviderFactory other);
    public static CompressionProviderFactory get_Default();
    public static void set_Default(CompressionProviderFactory value);
    [CompilerGeneratedAttribute]
public ICompressionProvider get_CustomCompressionProvider();
    [CompilerGeneratedAttribute]
public void set_CustomCompressionProvider(ICompressionProvider value);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    private bool IsSupportedCompressionAlgorithm(string algorithm);
    public ICompressionProvider CreateCompressionProvider(string algorithm);
}
internal class Microsoft.IdentityModel.Tokens.CreateECDsaDelegate : MulticastDelegate {
    public CreateECDsaDelegate(object object, IntPtr method);
    public virtual ECDsa Invoke(JsonWebKey jsonWebKey, bool usePrivateKey);
    public virtual IAsyncResult BeginInvoke(JsonWebKey jsonWebKey, bool usePrivateKey, AsyncCallback callback, object object);
    public virtual ECDsa EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.IdentityModel.Tokens.CryptoProviderCache : object {
    protected abstract virtual string GetCacheKey(SignatureProvider signatureProvider);
    protected abstract virtual string GetCacheKey(SecurityKey securityKey, string algorithm, string typeofProvider);
    public abstract virtual bool TryAdd(SignatureProvider signatureProvider);
    public abstract virtual bool TryGetSignatureProvider(SecurityKey securityKey, string algorithm, string typeofProvider, bool willCreateSignatures, SignatureProvider& signatureProvider);
    public abstract virtual bool TryRemove(SignatureProvider signatureProvider);
}
public class Microsoft.IdentityModel.Tokens.CryptoProviderFactory : object {
    private static CryptoProviderFactory _default;
    private static ConcurrentDictionary`2<string, string> _typeToAlgorithmMap;
    private static object _cacheLock;
    [CompilerGeneratedAttribute]
private static bool <DefaultCacheSignatureProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderCache <CryptoProviderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICryptoProvider <CustomCryptoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheSignatureProviders>k__BackingField;
    public static CryptoProviderFactory Default { get; public set; }
    [DefaultValueAttribute("True")]
public static bool DefaultCacheSignatureProviders { get; public set; }
    public CryptoProviderCache CryptoProviderCache { get; }
    public ICryptoProvider CustomCryptoProvider { get; public set; }
    [DefaultValueAttribute("True")]
public bool CacheSignatureProviders { get; public set; }
    private static CryptoProviderFactory();
    public CryptoProviderFactory(CryptoProviderFactory other);
    public static CryptoProviderFactory get_Default();
    public static void set_Default(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultCacheSignatureProviders();
    [CompilerGeneratedAttribute]
public static void set_DefaultCacheSignatureProviders(bool value);
    [CompilerGeneratedAttribute]
public CryptoProviderCache get_CryptoProviderCache();
    [CompilerGeneratedAttribute]
public ICryptoProvider get_CustomCryptoProvider();
    [CompilerGeneratedAttribute]
public void set_CustomCryptoProvider(ICryptoProvider value);
    [CompilerGeneratedAttribute]
public bool get_CacheSignatureProviders();
    [CompilerGeneratedAttribute]
public void set_CacheSignatureProviders(bool value);
    public virtual AuthenticatedEncryptionProvider CreateAuthenticatedEncryptionProvider(SecurityKey key, string algorithm);
    public virtual KeyWrapProvider CreateKeyWrapProvider(SecurityKey key, string algorithm);
    private KeyWrapProvider CreateKeyWrapProvider(SecurityKey key, string algorithm, bool willUnwrap);
    public virtual KeyWrapProvider CreateKeyWrapProviderForUnwrap(SecurityKey key, string algorithm);
    public virtual SignatureProvider CreateForSigning(SecurityKey key, string algorithm);
    public virtual SignatureProvider CreateForVerifying(SecurityKey key, string algorithm);
    public virtual HashAlgorithm CreateHashAlgorithm(HashAlgorithmName algorithm);
    public virtual HashAlgorithm CreateHashAlgorithm(string algorithm);
    public virtual KeyedHashAlgorithm CreateKeyedHashAlgorithm(Byte[] keyBytes, string algorithm);
    private SignatureProvider CreateSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm, SecurityKey key);
    public virtual void ReleaseHashAlgorithm(HashAlgorithm hashAlgorithm);
    public virtual void ReleaseKeyWrapProvider(KeyWrapProvider provider);
    public virtual void ReleaseRsaKeyWrapProvider(RsaKeyWrapProvider provider);
    public virtual void ReleaseSignatureProvider(SignatureProvider signatureProvider);
}
public static class Microsoft.IdentityModel.Tokens.DateTimeUtil : object {
    public static DateTime Add(DateTime time, TimeSpan timespan);
    public static DateTime GetMaxValue(DateTimeKind kind);
    public static DateTime GetMinValue(DateTimeKind kind);
    public static Nullable`1<DateTime> ToUniversalTime(Nullable`1<DateTime> value);
    public static DateTime ToUniversalTime(DateTime value);
}
public class Microsoft.IdentityModel.Tokens.DeflateCompressionProvider : object {
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    public string Algorithm { get; }
    public CompressionLevel CompressionLevel { get; private set; }
    public DeflateCompressionProvider(CompressionLevel compressionLevel);
    public sealed virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
private void set_CompressionLevel(CompressionLevel value);
    public sealed virtual Byte[] Decompress(Byte[] value);
    public sealed virtual Byte[] Compress(Byte[] value);
    public sealed virtual bool IsSupportedAlgorithm(string algorithm);
}
internal class Microsoft.IdentityModel.Tokens.ECDsaAdapter : object {
    internal CreateECDsaDelegate CreateECDsaFunction;
    internal static ECDsaAdapter Instance;
    private static ECDsaAdapter();
    internal ECDsa CreateECDsa(JsonWebKey jsonWebKey, bool usePrivateKey);
    private ECDsa CreateECDsaUsingCNGKey(JsonWebKey jsonWebKey, bool usePrivateKey);
    private UInt32 GetKeyByteCount(string curveId);
    private int GetKeySize(string curveId);
    private UInt32 GetMagicValue(string curveId, bool willCreateSignatures);
    private bool SupportsCNGKey();
}
public class Microsoft.IdentityModel.Tokens.ECDsaSecurityKey : AsymmetricSecurityKey {
    private Nullable`1<bool> _hasPrivateKey;
    [CompilerGeneratedAttribute]
private ECDsa <ECDsa>k__BackingField;
    public ECDsa ECDsa { get; private set; }
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public int KeySize { get; }
    internal ECDsaSecurityKey(JsonWebKey webKey, bool usePrivateKey);
    public ECDsaSecurityKey(ECDsa ecdsa);
    [CompilerGeneratedAttribute]
public ECDsa get_ECDsa();
    [CompilerGeneratedAttribute]
private void set_ECDsa(ECDsa value);
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    public virtual int get_KeySize();
}
public class Microsoft.IdentityModel.Tokens.EncryptingCredentials : object {
    private string _alg;
    private string _enc;
    private SecurityKey _key;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    public string Alg { get; private set; }
    public string Enc { get; private set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public SecurityKey Key { get; private set; }
    protected EncryptingCredentials(X509Certificate2 certificate, string alg, string enc);
    public EncryptingCredentials(SecurityKey key, string alg, string enc);
    public EncryptingCredentials(SymmetricSecurityKey key, string enc);
    public string get_Alg();
    private void set_Alg(string value);
    public string get_Enc();
    private void set_Enc(string value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    public SecurityKey get_Key();
    private void set_Key(SecurityKey value);
}
public static class Microsoft.IdentityModel.Tokens.EpochTime : object {
    public static DateTime UnixEpoch;
    private static EpochTime();
    public static long GetIntDate(DateTime datetime);
    public static DateTime DateTime(long secondsSinceUnixEpoch);
}
public interface Microsoft.IdentityModel.Tokens.ICompressionProvider {
    public string Algorithm { get; }
    public abstract virtual string get_Algorithm();
    public abstract virtual bool IsSupportedAlgorithm(string algorithm);
    public abstract virtual Byte[] Decompress(Byte[] value);
    public abstract virtual Byte[] Compress(Byte[] value);
}
public interface Microsoft.IdentityModel.Tokens.ICryptoProvider {
    public abstract virtual bool IsSupportedAlgorithm(string algorithm, Object[] args);
    public abstract virtual object Create(string algorithm, Object[] args);
    public abstract virtual void Release(object cryptoInstance);
}
public class Microsoft.IdentityModel.Tokens.InMemoryCryptoProviderCache : CryptoProviderCache {
    private ConcurrentDictionary`2<string, SignatureProvider> _signingSignatureProviders;
    private ConcurrentDictionary`2<string, SignatureProvider> _verifyingSignatureProviders;
    protected virtual string GetCacheKey(SignatureProvider signatureProvider);
    protected virtual string GetCacheKey(SecurityKey securityKey, string algorithm, string typeofProvider);
    private string GetCacheKeyPrivate(SecurityKey securityKey, string algorithm, string typeofProvider);
    public virtual bool TryAdd(SignatureProvider signatureProvider);
    public virtual bool TryGetSignatureProvider(SecurityKey securityKey, string algorithm, string typeofProvider, bool willCreateSignatures, SignatureProvider& signatureProvider);
    public virtual bool TryRemove(SignatureProvider signatureProvider);
}
public interface Microsoft.IdentityModel.Tokens.ISecurityTokenValidator {
    public bool CanValidateToken { get; }
    public int MaximumTokenSizeInBytes { get; public set; }
    public abstract virtual bool CanReadToken(string securityToken);
    public abstract virtual bool get_CanValidateToken();
    public abstract virtual int get_MaximumTokenSizeInBytes();
    public abstract virtual void set_MaximumTokenSizeInBytes(int value);
    public abstract virtual ClaimsPrincipal ValidateToken(string securityToken, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyResolver : MulticastDelegate {
    public IssuerSigningKeyResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SecurityKey> EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyValidator : MulticastDelegate {
    public IssuerSigningKeyValidator(object object, IntPtr method);
    public virtual bool Invoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerValidator : MulticastDelegate {
    public IssuerValidator(object object, IntPtr method);
    public virtual string Invoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public interface Microsoft.IdentityModel.Tokens.ITokenReplayCache {
    public abstract virtual bool TryAdd(string securityToken, DateTime expiresOn);
    public abstract virtual bool TryFind(string securityToken);
}
public static class Microsoft.IdentityModel.Tokens.JsonWebAlgorithmsKeyTypes : object {
    public static string EllipticCurve;
    public static string RSA;
    public static string Octet;
}
[JsonObjectAttribute]
public class Microsoft.IdentityModel.Tokens.JsonWebKey : SecurityKey {
    private string _kid;
    [CompilerGeneratedAttribute]
private SecurityKey <ConvertedSecurityKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alg>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Crv>k__BackingField;
    [CompilerGeneratedAttribute]
private string <D>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DP>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DQ>k__BackingField;
    [CompilerGeneratedAttribute]
private string <E>k__BackingField;
    [CompilerGeneratedAttribute]
private string <K>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <KeyOps>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <N>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <Oth>k__BackingField;
    [CompilerGeneratedAttribute]
private string <P>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Use>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <X5c>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5t>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5tS256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5u>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Y>k__BackingField;
    [JsonIgnoreAttribute]
internal SecurityKey ConvertedSecurityKey { get; internal set; }
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> AdditionalData { get; }
    [JsonPropertyAttribute]
public string Alg { get; public set; }
    [JsonPropertyAttribute]
public string Crv { get; public set; }
    [JsonPropertyAttribute]
public string D { get; public set; }
    [JsonPropertyAttribute]
public string DP { get; public set; }
    [JsonPropertyAttribute]
public string DQ { get; public set; }
    [JsonPropertyAttribute]
public string E { get; public set; }
    [JsonPropertyAttribute]
public string K { get; public set; }
    [JsonIgnoreAttribute]
public string KeyId { get; public set; }
    [JsonPropertyAttribute]
public IList`1<string> KeyOps { get; private set; }
    [JsonPropertyAttribute]
public string Kid { get; public set; }
    [JsonPropertyAttribute]
public string Kty { get; public set; }
    [JsonPropertyAttribute]
public string N { get; public set; }
    [JsonPropertyAttribute]
public IList`1<string> Oth { get; public set; }
    [JsonPropertyAttribute]
public string P { get; public set; }
    [JsonPropertyAttribute]
public string Q { get; public set; }
    [JsonPropertyAttribute]
public string QI { get; public set; }
    [JsonPropertyAttribute]
public string Use { get; public set; }
    [JsonPropertyAttribute]
public string X { get; public set; }
    [JsonPropertyAttribute]
public IList`1<string> X5c { get; private set; }
    [JsonPropertyAttribute]
public string X5t { get; public set; }
    [JsonPropertyAttribute]
public string X5tS256 { get; public set; }
    [JsonPropertyAttribute]
public string X5u { get; public set; }
    [JsonPropertyAttribute]
public string Y { get; public set; }
    [JsonIgnoreAttribute]
public int KeySize { get; }
    [JsonIgnoreAttribute]
public bool HasPrivateKey { get; }
    public JsonWebKey(string json);
    public static JsonWebKey Create(string json);
    [CompilerGeneratedAttribute]
internal SecurityKey get_ConvertedSecurityKey();
    [CompilerGeneratedAttribute]
internal void set_ConvertedSecurityKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_AdditionalData();
    [CompilerGeneratedAttribute]
public string get_Alg();
    [CompilerGeneratedAttribute]
public void set_Alg(string value);
    [CompilerGeneratedAttribute]
public string get_Crv();
    [CompilerGeneratedAttribute]
public void set_Crv(string value);
    [CompilerGeneratedAttribute]
public string get_D();
    [CompilerGeneratedAttribute]
public void set_D(string value);
    [CompilerGeneratedAttribute]
public string get_DP();
    [CompilerGeneratedAttribute]
public void set_DP(string value);
    [CompilerGeneratedAttribute]
public string get_DQ();
    [CompilerGeneratedAttribute]
public void set_DQ(string value);
    [CompilerGeneratedAttribute]
public string get_E();
    [CompilerGeneratedAttribute]
public void set_E(string value);
    [CompilerGeneratedAttribute]
public string get_K();
    [CompilerGeneratedAttribute]
public void set_K(string value);
    public virtual string get_KeyId();
    public virtual void set_KeyId(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_KeyOps();
    [CompilerGeneratedAttribute]
private void set_KeyOps(IList`1<string> value);
    public string get_Kid();
    public void set_Kid(string value);
    [CompilerGeneratedAttribute]
public string get_Kty();
    [CompilerGeneratedAttribute]
public void set_Kty(string value);
    [CompilerGeneratedAttribute]
public string get_N();
    [CompilerGeneratedAttribute]
public void set_N(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_Oth();
    [CompilerGeneratedAttribute]
public void set_Oth(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_P();
    [CompilerGeneratedAttribute]
public void set_P(string value);
    [CompilerGeneratedAttribute]
public string get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(string value);
    [CompilerGeneratedAttribute]
public string get_QI();
    [CompilerGeneratedAttribute]
public void set_QI(string value);
    [CompilerGeneratedAttribute]
public string get_Use();
    [CompilerGeneratedAttribute]
public void set_Use(string value);
    [CompilerGeneratedAttribute]
public string get_X();
    [CompilerGeneratedAttribute]
public void set_X(string value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_X5c();
    [CompilerGeneratedAttribute]
private void set_X5c(IList`1<string> value);
    [CompilerGeneratedAttribute]
public string get_X5t();
    [CompilerGeneratedAttribute]
public void set_X5t(string value);
    [CompilerGeneratedAttribute]
public string get_X5tS256();
    [CompilerGeneratedAttribute]
public void set_X5tS256(string value);
    [CompilerGeneratedAttribute]
public string get_X5u();
    [CompilerGeneratedAttribute]
public void set_X5u(string value);
    [CompilerGeneratedAttribute]
public string get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(string value);
    public virtual int get_KeySize();
    public bool get_HasPrivateKey();
    public bool ShouldSerializeKeyOps();
    public bool ShouldSerializeX5c();
    internal RSAParameters CreateRsaParameters();
    public virtual string ToString();
}
public class Microsoft.IdentityModel.Tokens.JsonWebKeyConverter : object {
    public static JsonWebKey ConvertFromSecurityKey(SecurityKey key);
    public static JsonWebKey ConvertFromRSASecurityKey(RsaSecurityKey key);
    public static JsonWebKey ConvertFromX509SecurityKey(X509SecurityKey key);
    public static JsonWebKey ConvertFromSymmetricSecurityKey(SymmetricSecurityKey key);
    internal static bool TryConvertToSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToSymmetricSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToX509SecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryCreateToRsaSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToECDsaSecurityKey(JsonWebKey webKey, SecurityKey& key);
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyECTypes : object {
    public static string P256;
    public static string P384;
    public static string P512;
    public static string P521;
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyParameterNames : object {
    public static string Alg;
    public static string Crv;
    public static string D;
    public static string DP;
    public static string DQ;
    public static string E;
    public static string K;
    public static string KeyOps;
    public static string Keys;
    public static string Kid;
    public static string Kty;
    public static string N;
    public static string Oth;
    public static string P;
    public static string Q;
    public static string R;
    public static string T;
    public static string QI;
    public static string Use;
    public static string X5c;
    public static string X5t;
    public static string X5tS256;
    public static string X5u;
    public static string X;
    public static string Y;
}
[JsonObjectAttribute]
public class Microsoft.IdentityModel.Tokens.JsonWebKeySet : object {
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalData>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<JsonWebKey> <Keys>k__BackingField;
    [DefaultValueAttribute("True")]
public static bool DefaultSkipUnresolvedJsonWebKeys;
    [CompilerGeneratedAttribute]
private bool <SkipUnresolvedJsonWebKeys>k__BackingField;
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> AdditionalData { get; }
    [JsonPropertyAttribute]
public IList`1<JsonWebKey> Keys { get; private set; }
    [DefaultValueAttribute("True")]
public bool SkipUnresolvedJsonWebKeys { get; public set; }
    public JsonWebKeySet(string json);
    public JsonWebKeySet(string json, JsonSerializerSettings jsonSerializerSettings);
    private static JsonWebKeySet();
    public static JsonWebKeySet Create(string json);
    [CompilerGeneratedAttribute]
public virtual IDictionary`2<string, object> get_AdditionalData();
    [CompilerGeneratedAttribute]
public IList`1<JsonWebKey> get_Keys();
    [CompilerGeneratedAttribute]
private void set_Keys(IList`1<JsonWebKey> value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnresolvedJsonWebKeys();
    [CompilerGeneratedAttribute]
public void set_SkipUnresolvedJsonWebKeys(bool value);
    public IList`1<SecurityKey> GetSigningKeys();
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeySetParameterNames : object {
    public static string Keys;
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyUseNames : object {
    public static string Sig;
    public static string Enc;
}
public abstract class Microsoft.IdentityModel.Tokens.KeyWrapProvider : object {
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public abstract virtual string get_Algorithm();
    public abstract virtual string get_Context();
    public abstract virtual void set_Context(string value);
    public abstract virtual SecurityKey get_Key();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual Byte[] UnwrapKey(Byte[] keyBytes);
    public abstract virtual Byte[] WrapKey(Byte[] keyBytes);
}
public class Microsoft.IdentityModel.Tokens.LifetimeValidator : MulticastDelegate {
    public LifetimeValidator(object object, IntPtr method);
    public virtual bool Invoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal static class Microsoft.IdentityModel.Tokens.LogMessages : object {
    public static string IDX10000;
    public static string IDX10101;
    public static string IDX10100;
    public static string IDX10102;
    public static string IDX10103;
    public static string IDX10104;
    public static string IDX10204;
    public static string IDX10205;
    public static string IDX10207;
    public static string IDX10208;
    public static string IDX10209;
    public static string IDX10211;
    public static string IDX10214;
    public static string IDX10222;
    public static string IDX10223;
    public static string IDX10224;
    public static string IDX10225;
    public static string IDX10227;
    public static string IDX10228;
    public static string IDX10229;
    public static string IDX10230;
    public static string IDX10231;
    public static string IDX10232;
    public static string IDX10233;
    public static string IDX10234;
    public static string IDX10235;
    public static string IDX10236;
    public static string IDX10237;
    public static string IDX10238;
    public static string IDX10239;
    public static string IDX10240;
    public static string IDX10241;
    public static string IDX10242;
    public static string IDX10243;
    public static string IDX10244;
    public static string IDX10245;
    public static string IDX10246;
    public static string IDX10247;
    public static string IDX10248;
    public static string IDX10249;
    public static string IDX10250;
    public static string IDX10251;
    public static string IDX10252;
    public static string IDX10253;
    public static string IDX10254;
    public static string IDX10500;
    public static string IDX10501;
    public static string IDX10503;
    public static string IDX10504;
    public static string IDX10505;
    public static string IDX10506;
    public static string IDX10507;
    public static string IDX10508;
    public static string IDX10509;
    public static string IDX10510;
    public static string IDX10511;
    public static string IDX10600;
    public static string IDX10601;
    public static string IDX10603;
    public static string IDX10604;
    public static string IDX10605;
    public static string IDX10606;
    public static string IDX10607;
    public static string IDX10608;
    public static string IDX10609;
    public static string IDX10610;
    public static string IDX10611;
    public static string IDX10612;
    public static string IDX10614;
    public static string IDX10615;
    public static string IDX10616;
    public static string IDX10617;
    public static string IDX10400;
    public static string IDX10401;
    public static string IDX10621;
    public static string IDX10622;
    public static string IDX10623;
    public static string IDX10624;
    public static string IDX10627;
    public static string IDX10628;
    public static string IDX10630;
    public static string IDX10631;
    public static string IDX10634;
    public static string IDX10635;
    public static string IDX10636;
    public static string IDX10638;
    public static string IDX10640;
    public static string IDX10641;
    public static string IDX10642;
    public static string IDX10643;
    public static string IDX10644;
    public static string IDX10645;
    public static string IDX10646;
    public static string IDX10647;
    public static string IDX10648;
    public static string IDX10649;
    public static string IDX10650;
    public static string IDX10651;
    public static string IDX10652;
    public static string IDX10653;
    public static string IDX10654;
    public static string IDX10655;
    public static string IDX10656;
    public static string IDX10657;
    public static string IDX10658;
    public static string IDX10659;
    public static string IDX10660;
    public static string IDX10661;
    public static string IDX10662;
    public static string IDX10663;
    public static string IDX10664;
    public static string IDX10665;
    public static string IDX10666;
    public static string IDX10667;
    public static string IDX10668;
    public static string IDX10669;
    public static string IDX10670;
    public static string IDX10671;
    public static string IDX10672;
    public static string IDX10673;
    public static string IDX10674;
    public static string IDX10675;
    public static string IDX10677;
    public static string IDX10678;
    public static string IDX10679;
    public static string IDX10680;
    public static string IDX10681;
    public static string IDX10682;
    public static string IDX10683;
    public static string IDX10684;
    public static string IDX10685;
    public static string IDX10686;
    public static string IDX10687;
    public static string IDX10689;
    public static string IDX10690;
    public static string IDX10692;
    public static string IDX10693;
    public static string IDX10700;
    public static string IDX10703;
    public static string IDX10805;
    public static string IDX10806;
    public static string IDX10808;
    public static string IDX10810;
    public static string IDX10812;
    public static string IDX10813;
}
public enum Microsoft.IdentityModel.Tokens.PrivateKeyStatus : Enum {
    public int value__;
    public static PrivateKeyStatus Exists;
    public static PrivateKeyStatus DoesNotExist;
    public static PrivateKeyStatus Unknown;
}
public class Microsoft.IdentityModel.Tokens.RsaKeyWrapProvider : KeyWrapProvider {
    private AsymmetricAdapter _asymmetricAdapter;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public RsaKeyWrapProvider(SecurityKey key, string algorithm, bool willUnwrap);
    [CompilerGeneratedAttribute]
public virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public virtual string get_Context();
    [CompilerGeneratedAttribute]
public virtual void set_Context(string value);
    [CompilerGeneratedAttribute]
public virtual SecurityKey get_Key();
    protected virtual void Dispose(bool disposing);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    public virtual Byte[] UnwrapKey(Byte[] keyBytes);
    public virtual Byte[] WrapKey(Byte[] keyBytes);
}
public class Microsoft.IdentityModel.Tokens.RsaSecurityKey : AsymmetricSecurityKey {
    private Nullable`1<bool> _hasPrivateKey;
    private bool _foundPrivateKeyDetermined;
    private PrivateKeyStatus _foundPrivateKey;
    [CompilerGeneratedAttribute]
private RSAParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private RSA <Rsa>k__BackingField;
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public int KeySize { get; }
    public RSAParameters Parameters { get; private set; }
    public RSA Rsa { get; private set; }
    internal RsaSecurityKey(JsonWebKey webKey);
    public RsaSecurityKey(RSAParameters rsaParameters);
    public RsaSecurityKey(RSA rsa);
    internal void IntializeWithRsaParameters(RSAParameters rsaParameters);
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    public virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public RSAParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(RSAParameters value);
    [CompilerGeneratedAttribute]
public RSA get_Rsa();
    [CompilerGeneratedAttribute]
private void set_Rsa(RSA value);
}
public static class Microsoft.IdentityModel.Tokens.SecurityAlgorithms : object {
    public static string Aes128Encryption;
    public static string Aes192Encryption;
    public static string Aes256Encryption;
    public static string DesEncryption;
    public static string Aes128KeyWrap;
    public static string Aes192KeyWrap;
    public static string Aes256KeyWrap;
    public static string RsaV15KeyWrap;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string Aes128KW;
    public static string Aes256KW;
    public static string RsaPKCS1;
    public static string RsaOAEP;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string EnvelopedSignature;
    public static string Sha256Digest;
    public static string Sha384Digest;
    public static string Sha512Digest;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string EcdsaSha256Signature;
    public static string EcdsaSha384Signature;
    public static string EcdsaSha512Signature;
    public static string HmacSha256Signature;
    public static string HmacSha384Signature;
    public static string HmacSha512Signature;
    public static string RsaSha256Signature;
    public static string RsaSha384Signature;
    public static string RsaSha512Signature;
    public static string RsaSsaPssSha256Signature;
    public static string RsaSsaPssSha384Signature;
    public static string RsaSsaPssSha512Signature;
    public static string EcdsaSha256;
    public static string EcdsaSha384;
    public static string EcdsaSha512;
    public static string HmacSha256;
    public static string HmacSha384;
    public static string HmacSha512;
    public static string None;
    public static string RsaSha256;
    public static string RsaSha384;
    public static string RsaSha512;
    public static string RsaSsaPssSha256;
    public static string RsaSsaPssSha384;
    public static string RsaSsaPssSha512;
    public static string Aes128CbcHmacSha256;
    public static string Aes192CbcHmacSha384;
    public static string Aes256CbcHmacSha512;
    internal static string DefaultAsymmetricKeyWrapAlgorithm;
    internal static string DefaultSymmetricEncryptionAlgorithm;
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityKey : object {
    private CryptoProviderFactory _cryptoProviderFactory;
    [CompilerGeneratedAttribute]
private string <InternalId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [JsonIgnoreAttribute]
internal string InternalId { get; }
    public int KeySize { get; }
    [JsonIgnoreAttribute]
public string KeyId { get; public set; }
    [JsonIgnoreAttribute]
public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    internal SecurityKey(SecurityKey key);
    [CompilerGeneratedAttribute]
internal string get_InternalId();
    public abstract virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public virtual string get_KeyId();
    [CompilerGeneratedAttribute]
public virtual void set_KeyId(string value);
    public CryptoProviderFactory get_CryptoProviderFactory();
    public void set_CryptoProviderFactory(CryptoProviderFactory value);
    public virtual string ToString();
}
public class Microsoft.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityToken : object {
    public string Id { get; }
    public string Issuer { get; }
    public SecurityKey SecurityKey { get; }
    public SecurityKey SigningKey { get; public set; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    public abstract virtual string get_Id();
    public abstract virtual string get_Issuer();
    public abstract virtual SecurityKey get_SecurityKey();
    public abstract virtual SecurityKey get_SigningKey();
    public abstract virtual void set_SigningKey(SecurityKey value);
    public abstract virtual DateTime get_ValidFrom();
    public abstract virtual DateTime get_ValidTo();
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenCompressionFailedException : SecurityTokenException {
    public SecurityTokenCompressionFailedException(string message);
    public SecurityTokenCompressionFailedException(string message, Exception inner);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDecompressionFailedException : SecurityTokenException {
    public SecurityTokenDecompressionFailedException(string message);
    public SecurityTokenDecompressionFailedException(string message, Exception inner);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDecryptionFailedException : SecurityTokenException {
    public SecurityTokenDecryptionFailedException(string message);
    public SecurityTokenDecryptionFailedException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor : object {
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptingCredentials <EncryptingCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <IssuedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private SigningCredentials <SigningCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsIdentity <Subject>k__BackingField;
    public string Audience { get; public set; }
    public string CompressionAlgorithm { get; public set; }
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public string Issuer { get; public set; }
    public Nullable`1<DateTime> IssuedAt { get; public set; }
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public IDictionary`2<string, object> Claims { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public ClaimsIdentity Subject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(string value);
    [CompilerGeneratedAttribute]
public string get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CompressionAlgorithm(string value);
    [CompilerGeneratedAttribute]
public EncryptingCredentials get_EncryptingCredentials();
    [CompilerGeneratedAttribute]
public void set_EncryptingCredentials(EncryptingCredentials value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
public void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_IssuedAt();
    [CompilerGeneratedAttribute]
public void set_IssuedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public SigningCredentials get_SigningCredentials();
    [CompilerGeneratedAttribute]
public void set_SigningCredentials(SigningCredentials value);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(ClaimsIdentity value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenEncryptionFailedException : SecurityTokenException {
    public SecurityTokenEncryptionFailedException(string message);
    public SecurityTokenEncryptionFailedException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenEncryptionKeyNotFoundException : SecurityTokenDecryptionFailedException {
    public SecurityTokenEncryptionKeyNotFoundException(string message);
    public SecurityTokenEncryptionKeyNotFoundException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenException : Exception {
    public SecurityTokenException(string message);
    public SecurityTokenException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenExpiredException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private DateTime <Expires>k__BackingField;
    public DateTime Expires { get; public set; }
    public SecurityTokenExpiredException(string message);
    public SecurityTokenExpiredException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public DateTime get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(DateTime value);
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityTokenHandler : TokenHandler {
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public Type TokenType { get; }
    public virtual SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached);
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public abstract virtual Type get_TokenType();
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool CanReadToken(string tokenString);
    public virtual SecurityToken ReadToken(string tokenString);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual string WriteToken(SecurityToken token);
    public abstract virtual void WriteToken(XmlWriter writer, SecurityToken token);
    public abstract virtual SecurityToken ReadToken(XmlReader reader, TokenValidationParameters validationParameters);
    public virtual ClaimsPrincipal ValidateToken(string securityToken, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
    public virtual ClaimsPrincipal ValidateToken(XmlReader reader, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidAudienceException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private string <InvalidAudience>k__BackingField;
    public string InvalidAudience { get; public set; }
    public SecurityTokenInvalidAudienceException(string message);
    public SecurityTokenInvalidAudienceException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_InvalidAudience();
    [CompilerGeneratedAttribute]
public void set_InvalidAudience(string value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidIssuerException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private string <InvalidIssuer>k__BackingField;
    public string InvalidIssuer { get; public set; }
    public SecurityTokenInvalidIssuerException(string message);
    public SecurityTokenInvalidIssuerException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public string get_InvalidIssuer();
    [CompilerGeneratedAttribute]
public void set_InvalidIssuer(string value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidLifetimeException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public SecurityTokenInvalidLifetimeException(string message);
    public SecurityTokenInvalidLifetimeException(string message, Exception innerException);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTime> value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidSignatureException : SecurityTokenValidationException {
    public SecurityTokenInvalidSignatureException(string message);
    public SecurityTokenInvalidSignatureException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidSigningKeyException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private SecurityKey <SigningKey>k__BackingField;
    public SecurityKey SigningKey { get; public set; }
    public SecurityTokenInvalidSigningKeyException(string message);
    public SecurityTokenInvalidSigningKeyException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public SecurityKey get_SigningKey();
    [CompilerGeneratedAttribute]
public void set_SigningKey(SecurityKey value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenKeyWrapException : SecurityTokenException {
    public SecurityTokenKeyWrapException(string message);
    public SecurityTokenKeyWrapException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenNoExpirationException : SecurityTokenValidationException {
    public SecurityTokenNoExpirationException(string message);
    public SecurityTokenNoExpirationException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenNotYetValidException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private DateTime <NotBefore>k__BackingField;
    public DateTime NotBefore { get; public set; }
    public SecurityTokenNotYetValidException(string message);
    public SecurityTokenNotYetValidException(string message, Exception inner);
    [CompilerGeneratedAttribute]
public DateTime get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(DateTime value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenReplayAddFailedException : SecurityTokenValidationException {
    public SecurityTokenReplayAddFailedException(string message);
    public SecurityTokenReplayAddFailedException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenReplayDetectedException : SecurityTokenValidationException {
    public SecurityTokenReplayDetectedException(string message);
    public SecurityTokenReplayDetectedException(string message, Exception inner);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenSignatureKeyNotFoundException : SecurityTokenInvalidSignatureException {
    public SecurityTokenSignatureKeyNotFoundException(string message);
    public SecurityTokenSignatureKeyNotFoundException(string message, Exception innerException);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
    public SecurityTokenValidationException(string message);
    public SecurityTokenValidationException(string message, Exception innerException);
}
public abstract class Microsoft.IdentityModel.Tokens.SignatureProvider : object {
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderCache <CryptoProviderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WillCreateSignatures>k__BackingField;
    public string Algorithm { get; private set; }
    public string Context { get; public set; }
    public CryptoProviderCache CryptoProviderCache { get; public set; }
    public SecurityKey Key { get; private set; }
    public bool WillCreateSignatures { get; protected set; }
    protected SignatureProvider(SecurityKey key, string algorithm);
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
private void set_Algorithm(string value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public CryptoProviderCache get_CryptoProviderCache();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderCache(CryptoProviderCache value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(SecurityKey value);
    public abstract virtual Byte[] Sign(Byte[] input);
    public abstract virtual bool Verify(Byte[] input, Byte[] signature);
    [CompilerGeneratedAttribute]
public bool get_WillCreateSignatures();
    [CompilerGeneratedAttribute]
protected void set_WillCreateSignatures(bool value);
}
public class Microsoft.IdentityModel.Tokens.SignatureValidator : MulticastDelegate {
    public SignatureValidator(object object, IntPtr method);
    public virtual SecurityToken Invoke(string token, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.SignDelegate : MulticastDelegate {
    public SignDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] bytes);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.SigningCredentials : object {
    private string _algorithm;
    private string _digest;
    private SecurityKey _key;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    public string Algorithm { get; private set; }
    public string Digest { get; private set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public SecurityKey Key { get; private set; }
    public string Kid { get; }
    protected SigningCredentials(X509Certificate2 certificate);
    protected SigningCredentials(X509Certificate2 certificate, string algorithm);
    public SigningCredentials(SecurityKey key, string algorithm);
    public SigningCredentials(SecurityKey key, string algorithm, string digest);
    public string get_Algorithm();
    private void set_Algorithm(string value);
    public string get_Digest();
    private void set_Digest(string value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    public SecurityKey get_Key();
    private void set_Key(SecurityKey value);
    public string get_Kid();
}
internal static class Microsoft.IdentityModel.Tokens.SupportedAlgorithms : object {
    public static bool IsSupportedAlgorithm(string algorithm, SecurityKey key);
    internal static bool IsSupportedAuthenticatedEncryptionAlgorithm(string algorithm, SecurityKey key);
    private static bool IsSupportedEcdsaAlgorithm(string algorithm);
    internal static bool IsSupportedHashAlgorithm(string algorithm);
    internal static bool IsSupportedKeyWrapAlgorithm(string algorithm, SecurityKey key);
    internal static bool IsSupportedRsaAlgorithm(string algorithm, SecurityKey key);
    private static bool IsSupportedRsaPss(SecurityKey key);
    internal static bool IsSupportedSymmetricAlgorithm(string algorithm);
}
public class Microsoft.IdentityModel.Tokens.SymmetricKeyWrapProvider : KeyWrapProvider {
    private static Byte[] _defaultIV;
    private static int _blockSizeInBits;
    private static int _blockSizeInBytes;
    private static object _encryptorLock;
    private static object _decryptorLock;
    private SymmetricAlgorithm _symmetricAlgorithm;
    private ICryptoTransform _symmetricAlgorithmEncryptor;
    private ICryptoTransform _symmetricAlgorithmDecryptor;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public SymmetricKeyWrapProvider(SecurityKey key, string algorithm);
    private static SymmetricKeyWrapProvider();
    [CompilerGeneratedAttribute]
public virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public virtual string get_Context();
    [CompilerGeneratedAttribute]
public virtual void set_Context(string value);
    [CompilerGeneratedAttribute]
public virtual SecurityKey get_Key();
    protected virtual void Dispose(bool disposing);
    private static Byte[] GetBytes(ulong i);
    protected virtual SymmetricAlgorithm GetSymmetricAlgorithm(SecurityKey key, string algorithm);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    public virtual Byte[] UnwrapKey(Byte[] keyBytes);
    private Byte[] UnwrapKeyPrivate(Byte[] inputBuffer, int inputOffset, int inputCount);
    private void ValidateKeySize(Byte[] key, string algorithm);
    public virtual Byte[] WrapKey(Byte[] keyBytes);
    private Byte[] WrapKeyPrivate(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public class Microsoft.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
    private int _keySize;
    private Byte[] _key;
    public int KeySize { get; }
    public Byte[] Key { get; }
    internal SymmetricSecurityKey(JsonWebKey webKey);
    public SymmetricSecurityKey(Byte[] key);
    public virtual int get_KeySize();
    public virtual Byte[] get_Key();
}
public class Microsoft.IdentityModel.Tokens.SymmetricSignatureProvider : SignatureProvider {
    private bool _disposed;
    private KeyedHashAlgorithm _keyedHash;
    private object _signLock;
    private object _verifyLock;
    public static int DefaultMinimumSymmetricKeySizeInBits;
    private int _minimumSymmetricKeySizeInBits;
    public int MinimumSymmetricKeySizeInBits { get; public set; }
    private KeyedHashAlgorithm KeyedHashAlgorithm { get; }
    public SymmetricSignatureProvider(SecurityKey key, string algorithm);
    public SymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures);
    private static SymmetricSignatureProvider();
    public int get_MinimumSymmetricKeySizeInBits();
    public void set_MinimumSymmetricKeySizeInBits(int value);
    protected virtual Byte[] GetKeyBytes(SecurityKey key);
    protected virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(Byte[] keyBytes, string algorithm);
    private KeyedHashAlgorithm get_KeyedHashAlgorithm();
    public virtual Byte[] Sign(Byte[] input);
    public virtual bool Verify(Byte[] input, Byte[] signature);
    public bool Verify(Byte[] input, Byte[] signature, int length);
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.IdentityModel.Tokens.TokenContext : object {
    [CompilerGeneratedAttribute]
private Guid <ActivityId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CaptureLogs>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<string> <Logs>k__BackingField;
    public Guid ActivityId { get; public set; }
    public bool CaptureLogs { get; public set; }
    public ICollection`1<string> Logs { get; private set; }
    public TokenContext(Guid activityId);
    [CompilerGeneratedAttribute]
public Guid get_ActivityId();
    [CompilerGeneratedAttribute]
public void set_ActivityId(Guid value);
    [CompilerGeneratedAttribute]
public bool get_CaptureLogs();
    [CompilerGeneratedAttribute]
public void set_CaptureLogs(bool value);
    [CompilerGeneratedAttribute]
public ICollection`1<string> get_Logs();
    [CompilerGeneratedAttribute]
private void set_Logs(ICollection`1<string> value);
}
public class Microsoft.IdentityModel.Tokens.TokenDecryptionKeyResolver : MulticastDelegate {
    public TokenDecryptionKeyResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SecurityKey> EndInvoke(IAsyncResult result);
}
public abstract class Microsoft.IdentityModel.Tokens.TokenHandler : object {
    private int _defaultTokenLifetimeInMinutes;
    private int _maximumTokenSizeInBytes;
    public static int DefaultTokenLifetimeInMinutes;
    [CompilerGeneratedAttribute]
private bool <SetDefaultTimesOnTokenCreation>k__BackingField;
    public int MaximumTokenSizeInBytes { get; public set; }
    [DefaultValueAttribute("True")]
public bool SetDefaultTimesOnTokenCreation { get; public set; }
    public int TokenLifetimeInMinutes { get; public set; }
    private static TokenHandler();
    public virtual int get_MaximumTokenSizeInBytes();
    public virtual void set_MaximumTokenSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public bool get_SetDefaultTimesOnTokenCreation();
    [CompilerGeneratedAttribute]
public void set_SetDefaultTimesOnTokenCreation(bool value);
    public int get_TokenLifetimeInMinutes();
    public void set_TokenLifetimeInMinutes(int value);
}
public class Microsoft.IdentityModel.Tokens.TokenReader : MulticastDelegate {
    public TokenReader(object object, IntPtr method);
    public virtual SecurityToken Invoke(string token, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.TokenReplayValidator : MulticastDelegate {
    public TokenReplayValidator(object object, IntPtr method);
    public virtual bool Invoke(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.TokenValidationParameters : object {
    private string _authenticationType;
    private TimeSpan _clockSkew;
    private string _nameClaimType;
    private string _roleClaimType;
    public static string DefaultAuthenticationType;
    public static TimeSpan DefaultClockSkew;
    public static int DefaultMaximumTokenSizeInBytes;
    [CompilerGeneratedAttribute]
private TokenValidationParameters <ActorValidationParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private AudienceValidator <AudienceValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenReader <TokenReader>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <TokenDecryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenDecryptionKeyResolver <TokenDecryptionKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyValidator <IssuerSigningKeyValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <IssuerSigningKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyResolver <IssuerSigningKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SecurityKey> <IssuerSigningKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerValidator <IssuerValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private LifetimeValidator <LifetimeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenReplayValidator <TokenReplayValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <NameClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <PropertyBag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireSignedTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <RoleClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveSigninToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureValidator <SignatureValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SecurityKey> <TokenDecryptionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenReplayCache <TokenReplayCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateActor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateIssuer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateLifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateIssuerSigningKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateTokenReplay>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidAudiences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidIssuer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidIssuers>k__BackingField;
    public TokenValidationParameters ActorValidationParameters { get; public set; }
    public AudienceValidator AudienceValidator { get; public set; }
    public TokenReader TokenReader { get; public set; }
    public string AuthenticationType { get; public set; }
    [DefaultValueAttribute("300")]
public TimeSpan ClockSkew { get; public set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public SecurityKey TokenDecryptionKey { get; public set; }
    public TokenDecryptionKeyResolver TokenDecryptionKeyResolver { get; public set; }
    public IssuerSigningKeyValidator IssuerSigningKeyValidator { get; public set; }
    public SecurityKey IssuerSigningKey { get; public set; }
    public IssuerSigningKeyResolver IssuerSigningKeyResolver { get; public set; }
    public IEnumerable`1<SecurityKey> IssuerSigningKeys { get; public set; }
    public IssuerValidator IssuerValidator { get; public set; }
    public LifetimeValidator LifetimeValidator { get; public set; }
    public TokenReplayValidator TokenReplayValidator { get; public set; }
    public string NameClaimType { get; public set; }
    public string RoleClaimType { get; public set; }
    public Func`3<SecurityToken, string, string> NameClaimTypeRetriever { get; public set; }
    public IDictionary`2<string, object> PropertyBag { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireAudience { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireExpirationTime { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireSignedTokens { get; public set; }
    public Func`3<SecurityToken, string, string> RoleClaimTypeRetriever { get; public set; }
    [DefaultValueAttribute("False")]
public bool SaveSigninToken { get; public set; }
    public SignatureValidator SignatureValidator { get; public set; }
    public IEnumerable`1<SecurityKey> TokenDecryptionKeys { get; public set; }
    public ITokenReplayCache TokenReplayCache { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateActor { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateAudience { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateIssuer { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateLifetime { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateIssuerSigningKey { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateTokenReplay { get; public set; }
    public string ValidAudience { get; public set; }
    public IEnumerable`1<string> ValidAudiences { get; public set; }
    public string ValidIssuer { get; public set; }
    public IEnumerable`1<string> ValidIssuers { get; public set; }
    protected TokenValidationParameters(TokenValidationParameters other);
    private static TokenValidationParameters();
    [CompilerGeneratedAttribute]
public TokenValidationParameters get_ActorValidationParameters();
    [CompilerGeneratedAttribute]
public void set_ActorValidationParameters(TokenValidationParameters value);
    [CompilerGeneratedAttribute]
public AudienceValidator get_AudienceValidator();
    [CompilerGeneratedAttribute]
public void set_AudienceValidator(AudienceValidator value);
    [CompilerGeneratedAttribute]
public TokenReader get_TokenReader();
    [CompilerGeneratedAttribute]
public void set_TokenReader(TokenReader value);
    public string get_AuthenticationType();
    public void set_AuthenticationType(string value);
    public TimeSpan get_ClockSkew();
    public void set_ClockSkew(TimeSpan value);
    public virtual TokenValidationParameters Clone();
    public virtual ClaimsIdentity CreateClaimsIdentity(SecurityToken securityToken, string issuer);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public SecurityKey get_TokenDecryptionKey();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public TokenDecryptionKeyResolver get_TokenDecryptionKeyResolver();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKeyResolver(TokenDecryptionKeyResolver value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyValidator get_IssuerSigningKeyValidator();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyValidator(IssuerSigningKeyValidator value);
    [CompilerGeneratedAttribute]
public SecurityKey get_IssuerSigningKey();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyResolver get_IssuerSigningKeyResolver();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyResolver(IssuerSigningKeyResolver value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SecurityKey> get_IssuerSigningKeys();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeys(IEnumerable`1<SecurityKey> value);
    [CompilerGeneratedAttribute]
public IssuerValidator get_IssuerValidator();
    [CompilerGeneratedAttribute]
public void set_IssuerValidator(IssuerValidator value);
    [CompilerGeneratedAttribute]
public LifetimeValidator get_LifetimeValidator();
    [CompilerGeneratedAttribute]
public void set_LifetimeValidator(LifetimeValidator value);
    [CompilerGeneratedAttribute]
public TokenReplayValidator get_TokenReplayValidator();
    [CompilerGeneratedAttribute]
public void set_TokenReplayValidator(TokenReplayValidator value);
    public string get_NameClaimType();
    public void set_NameClaimType(string value);
    public string get_RoleClaimType();
    public void set_RoleClaimType(string value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_NameClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_NameClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_PropertyBag();
    [CompilerGeneratedAttribute]
public void set_PropertyBag(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public bool get_RequireAudience();
    [CompilerGeneratedAttribute]
public void set_RequireAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireExpirationTime();
    [CompilerGeneratedAttribute]
public void set_RequireExpirationTime(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireSignedTokens();
    [CompilerGeneratedAttribute]
public void set_RequireSignedTokens(bool value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_RoleClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_RoleClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_SaveSigninToken();
    [CompilerGeneratedAttribute]
public void set_SaveSigninToken(bool value);
    [CompilerGeneratedAttribute]
public SignatureValidator get_SignatureValidator();
    [CompilerGeneratedAttribute]
public void set_SignatureValidator(SignatureValidator value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SecurityKey> get_TokenDecryptionKeys();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKeys(IEnumerable`1<SecurityKey> value);
    [CompilerGeneratedAttribute]
public ITokenReplayCache get_TokenReplayCache();
    [CompilerGeneratedAttribute]
public void set_TokenReplayCache(ITokenReplayCache value);
    [CompilerGeneratedAttribute]
public bool get_ValidateActor();
    [CompilerGeneratedAttribute]
public void set_ValidateActor(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAudience();
    [CompilerGeneratedAttribute]
public void set_ValidateAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateIssuer();
    [CompilerGeneratedAttribute]
public void set_ValidateIssuer(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateLifetime();
    [CompilerGeneratedAttribute]
public void set_ValidateLifetime(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateIssuerSigningKey();
    [CompilerGeneratedAttribute]
public void set_ValidateIssuerSigningKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateTokenReplay();
    [CompilerGeneratedAttribute]
public void set_ValidateTokenReplay(bool value);
    [CompilerGeneratedAttribute]
public string get_ValidAudience();
    [CompilerGeneratedAttribute]
public void set_ValidAudience(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidAudiences();
    [CompilerGeneratedAttribute]
public void set_ValidAudiences(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ValidIssuer();
    [CompilerGeneratedAttribute]
public void set_ValidIssuer(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidIssuers();
    [CompilerGeneratedAttribute]
public void set_ValidIssuers(IEnumerable`1<string> value);
}
public static class Microsoft.IdentityModel.Tokens.UniqueId : object {
    private static int RandomSaltSize;
    private static string NcNamePrefix;
    private static string UuidUriPrefix;
    private static string reusableUuid;
    private static string optimizedNcNamePrefix;
    private static UniqueId();
    public static string CreateUniqueId();
    public static string CreateUniqueId(string prefix);
    public static string CreateRandomId();
    public static string CreateRandomId(string prefix);
    public static Uri CreateRandomUri();
    private static string GetNextId();
    private static string GetRandomUuid();
}
[ExtensionAttribute]
public static class Microsoft.IdentityModel.Tokens.Utility : object {
    public static string Empty;
    public static string Null;
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    internal static string SerializeAsSingleCommaDelimitedString(IEnumerable`1<string> strings);
    public static bool IsHttps(string address);
    public static bool IsHttps(Uri uri);
    public static bool AreEqual(Byte[] a, Byte[] b);
    internal static bool AreEqual(Byte[] a, Byte[] b, int length);
    internal static Byte[] ConvertToBigEndian(long i);
    internal static Byte[] Xor(Byte[] a, Byte[] b, int offset, bool inPlace);
    internal static void Zero(Byte[] byteArray);
}
public static class Microsoft.IdentityModel.Tokens.Validators : object {
    public static void ValidateAudience(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static string ValidateIssuer(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static void ValidateIssuerSecurityKey(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static void ValidateLifetime(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static void ValidateTokenReplay(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters);
    public static void ValidateTokenReplay(string securityToken, Nullable`1<DateTime> expirationTime, TokenValidationParameters validationParameters);
}
internal class Microsoft.IdentityModel.Tokens.VerifyDelegate : MulticastDelegate {
    public VerifyDelegate(object object, IntPtr method);
    public virtual bool Invoke(Byte[] bytes, Byte[] signature);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, Byte[] signature, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.X509EncryptingCredentials : EncryptingCredentials {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509EncryptingCredentials(X509Certificate2 certificate);
    public X509EncryptingCredentials(X509Certificate2 certificate, string keyWrapAlgorithm, string dataEncryptionAlgorithm);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
}
public class Microsoft.IdentityModel.Tokens.X509SecurityKey : AsymmetricSecurityKey {
    private AsymmetricAlgorithm _privateKey;
    private bool _privateKeyAvailabilityDetermined;
    private AsymmetricAlgorithm _publicKey;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private string <X5t>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public int KeySize { get; }
    public string X5t { get; }
    public AsymmetricAlgorithm PrivateKey { get; }
    public AsymmetricAlgorithm PublicKey { get; }
    private object ThisLock { get; }
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public X509Certificate2 Certificate { get; private set; }
    internal X509SecurityKey(JsonWebKey webKey);
    public X509SecurityKey(X509Certificate2 certificate);
    public X509SecurityKey(X509Certificate2 certificate, string keyId);
    public virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public string get_X5t();
    public AsymmetricAlgorithm get_PrivateKey();
    public AsymmetricAlgorithm get_PublicKey();
    private object get_ThisLock();
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.IdentityModel.Tokens.X509SigningCredentials : SigningCredentials {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509SigningCredentials(X509Certificate2 certificate);
    public X509SigningCredentials(X509Certificate2 certificate, string algorithm);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
}
