[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.JsonWebTokens.Results.SignatureValidationResult : ValidationResult {
    [NullableAttribute("2")]
private Exception _exception;
    [NullableAttribute("2")]
public Exception Exception { get; }
    public SignatureValidationResult(bool isValid, ValidationFailureType validationFailureType);
    public SignatureValidationResult(ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    internal static SignatureValidationResult Success();
    internal static SignatureValidationResult NullParameterFailure(string parameterName);
    [NullableContextAttribute("2")]
public virtual Exception get_Exception();
}
internal static class Microsoft.IdentityModel.Tokens.AesAead : object {
    public static void CheckArgumentsForNull(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag);
    public static void Decrypt(SafeKeyHandle keyHandle, Byte[] nonce, Byte[] associatedData, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, bool clearPlaintextOnFailure);
    internal static void Encrypt(SafeKeyHandle keyHandle, Byte[] nonce, Byte[] associatedData, Byte[] plaintext, Byte[] ciphertext, Byte[] tag);
}
internal static class Microsoft.IdentityModel.Tokens.AesBCryptModes : object {
    internal static Lazy`1<SafeAlgorithmHandle> OpenAesAlgorithm(string cipherMode);
}
internal class Microsoft.IdentityModel.Tokens.AesGcm : object {
    public static int NonceSize;
    public static int TagSize;
    private static SafeAlgorithmHandle s_aesGcm;
    private SafeKeyHandle _keyHandle;
    private bool _disposed;
    public AesGcm(Byte[] key);
    private static AesGcm();
    private void ImportKey(Byte[] key);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    public void Decrypt(Byte[] nonce, Byte[] ciphertext, Byte[] tag, Byte[] plaintext, Byte[] associatedData);
    internal void Encrypt(Byte[] nonce, Byte[] plaintext, Byte[] ciphertext, Byte[] tag, Byte[] associatedData);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.AlgorithmValidationResult : ValidationResult {
    private Exception _exception;
    [NullableAttribute("1")]
private static string TokenSource;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    public Exception Exception { get; }
    public string Algorithm { get; }
    public AlgorithmValidationResult(string algorithm);
    [NullableContextAttribute("1")]
public AlgorithmValidationResult(string algorithm, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Algorithm();
}
public class Microsoft.IdentityModel.Tokens.AlgorithmValidator : MulticastDelegate {
    public AlgorithmValidator(object object, IntPtr method);
    public virtual bool Invoke(string algorithm, SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string algorithm, SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.AlgorithmValidatorDelegate : MulticastDelegate {
    public AlgorithmValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual AlgorithmValidationResult Invoke(string algorithm, SecurityKey securityKey, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(string algorithm, SecurityKey securityKey, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual AlgorithmValidationResult EndInvoke(IAsyncResult result);
}
public static class Microsoft.IdentityModel.Tokens.AppCompatSwitches : object {
    public static string UseRfcDefinitionOfEpkAndKid;
}
internal static class Microsoft.IdentityModel.Tokens.AppContextSwitches : object {
    internal static string UseClaimsIdentityTypeSwitch;
    private static Nullable`1<bool> _useClaimsIdentityType;
    internal static string DoNotFailOnMissingTidSwitch;
    private static Nullable`1<bool> _doNotFailOnMissingTid;
    internal static string TryAllStringClaimsAsDateTimeSwitch;
    private static Nullable`1<bool> _tryAllStringClaimsAsDateTime;
    internal static string UseRfcDefinitionOfEpkAndKidSwitch;
    private static Nullable`1<bool> _useRfcDefinitionOfEpkAndKid;
    internal static bool UseClaimsIdentityType { get; }
    internal static bool DontFailOnMissingTid { get; }
    internal static bool DoNotFailOnMissingTid { get; }
    internal static bool TryAllStringClaimsAsDateTime { get; }
    internal static bool UseRfcDefinitionOfEpkAndKid { get; }
    internal static bool get_UseClaimsIdentityType();
    internal static bool get_DontFailOnMissingTid();
    internal static bool get_DoNotFailOnMissingTid();
    internal static bool get_TryAllStringClaimsAsDateTime();
    internal static bool get_UseRfcDefinitionOfEpkAndKid();
    internal static void ResetAllSwitches();
}
internal class Microsoft.IdentityModel.Tokens.AsymmetricAdapter : object {
    private bool _useRSAOeapPadding;
    private bool _disposeCryptoOperators;
    private bool _disposed;
    private DecryptDelegate _decryptFunction;
    private EncryptDelegate _encryptFunction;
    private SignDelegate _signFunction;
    private SignUsingOffsetDelegate _signUsingOffsetFunction;
    private VerifyDelegate _verifyFunction;
    private VerifyUsingOffsetDelegate _verifyUsingOffsetFunction;
    [CompilerGeneratedAttribute]
private ECDsa <ECDsa>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithm <HashAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private RSA <RSA>k__BackingField;
    [CompilerGeneratedAttribute]
private HashAlgorithmName <HashAlgorithmName>k__BackingField;
    [CompilerGeneratedAttribute]
private RSAEncryptionPadding <RSAEncryptionPadding>k__BackingField;
    [CompilerGeneratedAttribute]
private RSASignaturePadding <RSASignaturePadding>k__BackingField;
    [CompilerGeneratedAttribute]
private RSACryptoServiceProviderProxy <RsaCryptoServiceProviderProxy>k__BackingField;
    private ECDsa ECDsa { get; private set; }
    private HashAlgorithm HashAlgorithm { get; private set; }
    private RSA RSA { get; private set; }
    private HashAlgorithmName HashAlgorithmName { get; private set; }
    private RSAEncryptionPadding RSAEncryptionPadding { get; private set; }
    private RSASignaturePadding RSASignaturePadding { get; private set; }
    private RSACryptoServiceProviderProxy RsaCryptoServiceProviderProxy { get; private set; }
    internal AsymmetricAdapter(SecurityKey key, string algorithm, bool requirePrivateKey);
    internal AsymmetricAdapter(SecurityKey key, string algorithm, HashAlgorithm hashAlgorithm, HashAlgorithmName hashAlgorithmName, bool requirePrivateKey);
    internal AsymmetricAdapter(SecurityKey key, string algorithm, HashAlgorithm hashAlgorithm, bool requirePrivateKey);
    internal Byte[] Decrypt(Byte[] data);
    internal static Byte[] DecryptFunctionNotFound(Byte[] _);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
private ECDsa get_ECDsa();
    [CompilerGeneratedAttribute]
private void set_ECDsa(ECDsa value);
    internal Byte[] Encrypt(Byte[] data);
    internal static Byte[] EncryptFunctionNotFound(Byte[] _);
    [CompilerGeneratedAttribute]
private HashAlgorithm get_HashAlgorithm();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithm(HashAlgorithm value);
    private void InitializeUsingEcdsaSecurityKey(ECDsaSecurityKey ecdsaSecurityKey);
    private void InitializeUsingRsa(RSA rsa, string algorithm);
    private void InitializeUsingRsaSecurityKey(RsaSecurityKey rsaSecurityKey, string algorithm);
    private void InitializeUsingX509SecurityKey(X509SecurityKey x509SecurityKey, string algorithm, bool requirePrivateKey);
    [CompilerGeneratedAttribute]
private RSA get_RSA();
    [CompilerGeneratedAttribute]
private void set_RSA(RSA value);
    internal Byte[] Sign(Byte[] bytes);
    internal Byte[] SignUsingOffset(Byte[] bytes, int offset, int count);
    private static Byte[] SignFunctionNotFound(Byte[] _);
    private static Byte[] SignUsingOffsetNotFound(Byte[] b, int c, int d);
    private Byte[] SignECDsa(Byte[] bytes);
    private Byte[] SignUsingOffsetECDsa(Byte[] bytes, int offset, int count);
    internal bool Verify(Byte[] bytes, Byte[] signature);
    internal bool VerifyUsingOffset(Byte[] bytes, int offset, int count, Byte[] signature);
    private static bool VerifyNotFound(Byte[] bytes, Byte[] signature);
    private static bool VerifyUsingOffsetNotFound(Byte[] bytes, int offset, int count, Byte[] signature);
    private bool VerifyECDsa(Byte[] bytes, Byte[] signature);
    private bool VerifyUsingOffsetECDsa(Byte[] bytes, int offset, int count, Byte[] signature);
    private Byte[] DecryptWithRsa(Byte[] bytes);
    private Byte[] EncryptWithRsa(Byte[] bytes);
    [CompilerGeneratedAttribute]
private HashAlgorithmName get_HashAlgorithmName();
    [CompilerGeneratedAttribute]
private void set_HashAlgorithmName(HashAlgorithmName value);
    [CompilerGeneratedAttribute]
private RSAEncryptionPadding get_RSAEncryptionPadding();
    [CompilerGeneratedAttribute]
private void set_RSAEncryptionPadding(RSAEncryptionPadding value);
    [CompilerGeneratedAttribute]
private RSASignaturePadding get_RSASignaturePadding();
    [CompilerGeneratedAttribute]
private void set_RSASignaturePadding(RSASignaturePadding value);
    private Byte[] SignRsa(Byte[] bytes);
    private Byte[] SignUsingOffsetRsa(Byte[] bytes, int offset, int count);
    private bool VerifyRsa(Byte[] bytes, Byte[] signature);
    private bool VerifyUsingOffsetRsa(Byte[] bytes, int offset, int count, Byte[] signature);
    internal Byte[] DecryptWithRsaCryptoServiceProviderProxy(Byte[] bytes);
    internal Byte[] EncryptWithRsaCryptoServiceProviderProxy(Byte[] bytes);
    [CompilerGeneratedAttribute]
private RSACryptoServiceProviderProxy get_RsaCryptoServiceProviderProxy();
    [CompilerGeneratedAttribute]
private void set_RsaCryptoServiceProviderProxy(RSACryptoServiceProviderProxy value);
    internal Byte[] SignWithRsaCryptoServiceProviderProxy(Byte[] bytes);
    internal Byte[] SignWithRsaCryptoServiceProviderProxyUsingOffset(Byte[] bytes, int offset, int length);
    private bool VerifyWithRsaCryptoServiceProviderProxy(Byte[] bytes, Byte[] signature);
    private bool VerifyWithRsaCryptoServiceProviderProxyUsingOffset(Byte[] bytes, int offset, int length, Byte[] signature);
}
public abstract class Microsoft.IdentityModel.Tokens.AsymmetricSecurityKey : SecurityKey {
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus instead.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    internal AsymmetricSecurityKey(SecurityKey key);
    public abstract virtual bool get_HasPrivateKey();
    public abstract virtual PrivateKeyStatus get_PrivateKeyStatus();
}
public class Microsoft.IdentityModel.Tokens.AsymmetricSignatureProvider : SignatureProvider {
    private DisposableObjectPool`1<AsymmetricAdapter> _asymmetricAdapterObjectPool;
    private CryptoProviderFactory _cryptoProviderFactory;
    private bool _disposed;
    private Dictionary`2<string, int> _minimumAsymmetricKeySizeInBitsForSigningMap;
    private Dictionary`2<string, int> _minimumAsymmetricKeySizeInBitsForVerifyingMap;
    public static Dictionary`2<string, int> DefaultMinimumAsymmetricKeySizeInBitsForSigningMap;
    public static Dictionary`2<string, int> DefaultMinimumAsymmetricKeySizeInBitsForVerifyingMap;
    public IReadOnlyDictionary`2<string, int> MinimumAsymmetricKeySizeInBitsForSigningMap { get; }
    public IReadOnlyDictionary`2<string, int> MinimumAsymmetricKeySizeInBitsForVerifyingMap { get; }
    internal int ObjectPoolSize { get; }
    internal AsymmetricSignatureProvider(SecurityKey key, string algorithm, CryptoProviderFactory cryptoProviderFactory);
    internal AsymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures, CryptoProviderFactory cryptoProviderFactory);
    public AsymmetricSignatureProvider(SecurityKey key, string algorithm);
    public AsymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures);
    private static AsymmetricSignatureProvider();
    public IReadOnlyDictionary`2<string, int> get_MinimumAsymmetricKeySizeInBitsForSigningMap();
    public IReadOnlyDictionary`2<string, int> get_MinimumAsymmetricKeySizeInBitsForVerifyingMap();
    private static PrivateKeyStatus FoundPrivateKey(SecurityKey key);
    protected virtual HashAlgorithmName GetHashAlgorithmName(string algorithm);
    private AsymmetricAdapter CreateAsymmetricAdapter();
    internal bool ValidKeySize();
    internal virtual int get_ObjectPoolSize();
    public virtual Byte[] Sign(Byte[] input);
    public virtual Byte[] Sign(Byte[] input, int offset, int count);
    public virtual void ValidateAsymmetricSecurityKeySize(SecurityKey key, string algorithm, bool willCreateSignatures);
    public virtual bool Verify(Byte[] input, Byte[] signature);
    public virtual bool Verify(Byte[] input, int inputOffset, int inputLength, Byte[] signature, int signatureOffset, int signatureLength);
    protected virtual void Dispose(bool disposing);
}
internal class Microsoft.IdentityModel.Tokens.AudienceValidationResult : ValidationResult {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    public Exception Exception { get; }
    public string Audience { get; }
    public AudienceValidationResult(string audience);
    public AudienceValidationResult(string audience, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Audience();
}
public class Microsoft.IdentityModel.Tokens.AudienceValidator : MulticastDelegate {
    public AudienceValidator(object object, IntPtr method);
    public virtual bool Invoke(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.AudienceValidatorDelegate : MulticastDelegate {
    public AudienceValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual AudienceValidationResult Invoke(IList`1<string> audiences, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(IList`1<string> audiences, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual AudienceValidationResult EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.AuthenticatedEncryptionProvider : object {
    private Lazy`1<AuthenticatedKeys> _authenticatedkeys;
    private DisposableObjectPool`1<AesGcm> _aesGcmObjectPool;
    private CryptoProviderFactory _cryptoProviderFactory;
    private bool _disposed;
    private Lazy`1<bool> _keySizeIsValid;
    private Lazy`1<SymmetricSignatureProvider> _symmetricSignatureProvider;
    private DecryptionDelegate DecryptFunction;
    private EncryptionDelegate EncryptFunction;
    private static string _className;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public AuthenticatedEncryptionProvider(SecurityKey key, string algorithm);
    private void InitializeUsingAesGcm();
    private void InitializeUsingAesCbc();
    internal bool ValidKeySize();
    private AuthenticatedEncryptionResult EncryptWithAesGcm(Byte[] plaintext, Byte[] authenticatedData, Byte[] iv);
    private AesGcm CreateAesGcmInstance();
    private Byte[] DecryptWithAesGcm(Byte[] ciphertext, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag);
    private AuthenticatedEncryptionResult EncryptWithAesCbc(Byte[] plaintext, Byte[] authenticatedData, Byte[] iv);
    private Byte[] DecryptWithAesCbc(Byte[] ciphertext, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag);
    private AuthenticatedKeys CreateAuthenticatedKeys();
    internal SymmetricSignatureProvider CreateSymmetricSignatureProvider();
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    public virtual AuthenticatedEncryptionResult Encrypt(Byte[] plaintext, Byte[] authenticatedData);
    public virtual AuthenticatedEncryptionResult Encrypt(Byte[] plaintext, Byte[] authenticatedData, Byte[] iv);
    public virtual Byte[] Decrypt(Byte[] ciphertext, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    private AuthenticatedKeys GetAlgorithmParameters(SecurityKey key, string algorithm);
    private static string GetHmacAlgorithm(string algorithm);
    protected virtual Byte[] GetKeyBytes(SecurityKey key);
    internal static Byte[] Transform(ICryptoTransform transform, Byte[] input, int inputOffset, int inputLength);
    protected virtual void ValidateKeySize(SecurityKey key, string algorithm);
}
public class Microsoft.IdentityModel.Tokens.AuthenticatedEncryptionResult : object {
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <Ciphertext>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <AuthenticationTag>k__BackingField;
    public SecurityKey Key { get; private set; }
    public Byte[] Ciphertext { get; private set; }
    public Byte[] IV { get; private set; }
    public Byte[] AuthenticationTag { get; private set; }
    public AuthenticatedEncryptionResult(SecurityKey key, Byte[] ciphertext, Byte[] iv, Byte[] authenticationTag);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(SecurityKey value);
    [CompilerGeneratedAttribute]
public Byte[] get_Ciphertext();
    [CompilerGeneratedAttribute]
private void set_Ciphertext(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
    [CompilerGeneratedAttribute]
public Byte[] get_AuthenticationTag();
    [CompilerGeneratedAttribute]
private void set_AuthenticationTag(Byte[] value);
}
public static class Microsoft.IdentityModel.Tokens.Base64UrlEncoder : object {
    private static char base64PadCharacter;
    private static char base64Character62;
    private static char base64Character63;
    private static char base64UrlCharacter62;
    private static char base64UrlCharacter63;
    public static string Encode(string arg);
    public static string Encode(Byte[] inArray);
    public static string Encode(Byte[] inArray, int offset, int length);
    public static int Encode(ReadOnlySpan`1<byte> inArray, Span`1<char> output);
    public static Byte[] DecodeBytes(string str);
    internal static Byte[] Decode(ReadOnlySpan`1<char> strSpan);
    internal static void Decode(ReadOnlySpan`1<char> strSpan, Span`1<byte> output);
    private static Byte[] UnsafeDecode(ReadOnlySpan`1<char> strSpan, bool needReplace, int decodedLength);
    private static void Decode(ReadOnlySpan`1<char> strSpan, Span`1<byte> output, bool needReplace, int decodedLength);
    public static string Decode(string arg);
}
internal static class Microsoft.IdentityModel.Tokens.Base64UrlEncoding : object {
    private static UInt32 IntA;
    private static UInt32 IntZ;
    private static UInt32 Inta;
    private static UInt32 Intz;
    private static UInt32 Int0;
    private static UInt32 Int9;
    private static UInt32 IntEq;
    private static UInt32 IntPlus;
    private static UInt32 IntMinus;
    private static UInt32 IntSlash;
    private static UInt32 IntUnderscore;
    private static Char[] Base64Table;
    private static Base64UrlEncoding();
    public static Byte[] Decode(string inputString);
    public static Byte[] Decode(string input, int offset, int length);
    public static T Decode(string input, int offset, int length, TX argx, Func`4<Byte[], int, TX, T> action);
    public static T Decode(string input, int offset, int length, Func`3<Byte[], int, T> action);
    public static T Decode(string input, int offset, int length, TX argx, TY argy, TZ argz, Func`6<Byte[], int, TX, TY, TZ, T> action);
    internal static void Decode(ReadOnlySpan`1<char> input, int offset, int length, Byte[] output);
    public static string Encode(Byte[] bytes);
    public static string Encode(Byte[] input, int offset, int length);
    internal static int ValidateAndGetOutputSize(ReadOnlySpan`1<char> strSpan, int offset, int length);
    private static void WriteEncodedOutput(Byte[] inputBytes, int offset, int length, Span`1<char> output);
}
public abstract class Microsoft.IdentityModel.Tokens.BaseConfiguration : object {
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<SecurityKey> <SigningKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ActiveTokenEndpoint>k__BackingField;
    [CompilerGeneratedAttribute]
private ICollection`1<SecurityKey> <TokenDecryptionKeys>k__BackingField;
    public string Issuer { get; public set; }
    public ICollection`1<SecurityKey> SigningKeys { get; }
    public string TokenEndpoint { get; public set; }
    public string ActiveTokenEndpoint { get; public set; }
    [JsonIgnoreAttribute]
public ICollection`1<SecurityKey> TokenDecryptionKeys { get; }
    [CompilerGeneratedAttribute]
public virtual string get_Issuer();
    [CompilerGeneratedAttribute]
public virtual void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public virtual ICollection`1<SecurityKey> get_SigningKeys();
    [CompilerGeneratedAttribute]
public virtual string get_TokenEndpoint();
    [CompilerGeneratedAttribute]
public virtual void set_TokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public virtual string get_ActiveTokenEndpoint();
    [CompilerGeneratedAttribute]
public virtual void set_ActiveTokenEndpoint(string value);
    [CompilerGeneratedAttribute]
public virtual ICollection`1<SecurityKey> get_TokenDecryptionKeys();
}
internal class Microsoft.IdentityModel.Tokens.BaseConfigurationComparer : object {
    public sealed virtual bool Equals(BaseConfiguration config1, BaseConfiguration config2);
    private static bool ContainsKeyWithInternalId(BaseConfiguration config, string internalId);
    public sealed virtual int GetHashCode(BaseConfiguration config);
}
public abstract class Microsoft.IdentityModel.Tokens.BaseConfigurationManager : object {
    private TimeSpan _automaticRefreshInterval;
    private TimeSpan _refreshInterval;
    private TimeSpan _lastKnownGoodLifetime;
    private BaseConfiguration _lastKnownGoodConfiguration;
    private Nullable`1<DateTime> _lastKnownGoodConfigFirstUse;
    internal EventBasedLRUCache`2<BaseConfiguration, DateTime> _lastKnownGoodConfigurationCache;
    public static TimeSpan DefaultAutomaticRefreshInterval;
    public static TimeSpan DefaultLastKnownGoodConfigurationLifetime;
    public static TimeSpan DefaultRefreshInterval;
    [CompilerGeneratedAttribute]
private string <MetadataAddress>k__BackingField;
    public static TimeSpan MinimumAutomaticRefreshInterval;
    public static TimeSpan MinimumRefreshInterval;
    [CompilerGeneratedAttribute]
private bool <UseLastKnownGoodConfiguration>k__BackingField;
    public TimeSpan AutomaticRefreshInterval { get; public set; }
    public BaseConfiguration LastKnownGoodConfiguration { get; public set; }
    public TimeSpan LastKnownGoodLifetime { get; public set; }
    public string MetadataAddress { get; public set; }
    public TimeSpan RefreshInterval { get; public set; }
    public bool UseLastKnownGoodConfiguration { get; public set; }
    public bool IsLastKnownGoodValid { get; }
    public BaseConfigurationManager(LKGConfigurationCacheOptions options);
    private static BaseConfigurationManager();
    public TimeSpan get_AutomaticRefreshInterval();
    public void set_AutomaticRefreshInterval(TimeSpan value);
    public virtual Task`1<BaseConfiguration> GetBaseConfigurationAsync(CancellationToken cancel);
    internal BaseConfiguration[] GetValidLkgConfigurations();
    public BaseConfiguration get_LastKnownGoodConfiguration();
    public void set_LastKnownGoodConfiguration(BaseConfiguration value);
    public TimeSpan get_LastKnownGoodLifetime();
    public void set_LastKnownGoodLifetime(TimeSpan value);
    [CompilerGeneratedAttribute]
public string get_MetadataAddress();
    [CompilerGeneratedAttribute]
public void set_MetadataAddress(string value);
    public TimeSpan get_RefreshInterval();
    public void set_RefreshInterval(TimeSpan value);
    [CompilerGeneratedAttribute]
public bool get_UseLastKnownGoodConfiguration();
    [CompilerGeneratedAttribute]
public void set_UseLastKnownGoodConfiguration(bool value);
    public bool get_IsLastKnownGoodValid();
    public abstract virtual void RequestRefresh();
}
public class Microsoft.IdentityModel.Tokens.CallContext : LoggerContext {
    public CallContext(Guid activityId);
}
public class Microsoft.IdentityModel.Tokens.CaseSensitiveClaimsIdentity : ClaimsIdentity {
    [CompilerGeneratedAttribute]
private SecurityToken <SecurityToken>k__BackingField;
    public SecurityToken SecurityToken { get; internal set; }
    public CaseSensitiveClaimsIdentity(string authenticationType);
    public CaseSensitiveClaimsIdentity(ClaimsIdentity claimsIdentity);
    public CaseSensitiveClaimsIdentity(IEnumerable`1<Claim> claims);
    public CaseSensitiveClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType);
    public CaseSensitiveClaimsIdentity(IEnumerable`1<Claim> claims, string authenticationType, string nameType, string roleType);
    public CaseSensitiveClaimsIdentity(string authenticationType, string nameType, string roleType);
    [CompilerGeneratedAttribute]
public SecurityToken get_SecurityToken();
    [CompilerGeneratedAttribute]
internal void set_SecurityToken(SecurityToken value);
    public virtual IEnumerable`1<Claim> FindAll(string type);
    public virtual Claim FindFirst(string type);
    public virtual bool HasClaim(string type, string value);
}
internal static class Microsoft.IdentityModel.Tokens.ClaimsIdentityFactory : object {
    internal static ClaimsIdentity Create(IEnumerable`1<Claim> claims);
    internal static ClaimsIdentity Create(IEnumerable`1<Claim> claims, string authenticationType);
    internal static ClaimsIdentity Create(string authenticationType, string nameType, string roleType, SecurityToken securityToken);
}
[ExtensionAttribute]
internal static class Microsoft.IdentityModel.Tokens.Cng : object {
    public static string BCRYPT_AES_ALGORITHM;
    public static string BCRYPT_CHAIN_MODE_GCM;
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
[ExtensionAttribute]
internal static class Microsoft.IdentityModel.Tokens.CollectionUtilities : object {
    [ExtensionAttribute]
internal static bool IsNullOrEmpty(IEnumerable`1<T> enumerable);
}
public class Microsoft.IdentityModel.Tokens.CompressionAlgorithms : object {
    public static string Deflate;
}
public class Microsoft.IdentityModel.Tokens.CompressionProviderFactory : object {
    private static CompressionProviderFactory _default;
    [CompilerGeneratedAttribute]
private ICompressionProvider <CustomCompressionProvider>k__BackingField;
    public static CompressionProviderFactory Default { get; public set; }
    public ICompressionProvider CustomCompressionProvider { get; public set; }
    private static CompressionProviderFactory();
    public CompressionProviderFactory(CompressionProviderFactory other);
    public static CompressionProviderFactory get_Default();
    public static void set_Default(CompressionProviderFactory value);
    [CompilerGeneratedAttribute]
public ICompressionProvider get_CustomCompressionProvider();
    [CompilerGeneratedAttribute]
public void set_CustomCompressionProvider(ICompressionProvider value);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    private static bool IsSupportedCompressionAlgorithm(string algorithm);
    public ICompressionProvider CreateCompressionProvider(string algorithm);
    public ICompressionProvider CreateCompressionProvider(string algorithm, int maximumDeflateSize);
}
public class Microsoft.IdentityModel.Tokens.Configuration.LKGConfigurationCacheOptions : object {
    private IEqualityComparer`1<BaseConfiguration> _baseConfigurationComparer;
    private int _lastKnownGoodConfigurationSizeLimit;
    public static int DefaultLKGConfigurationSizeLimit;
    [CompilerGeneratedAttribute]
private TaskCreationOptions <TaskCreationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RemoveExpiredValues>k__BackingField;
    public IEqualityComparer`1<BaseConfiguration> BaseConfigurationComparer { get; public set; }
    public int LastKnownGoodConfigurationSizeLimit { get; public set; }
    public TaskCreationOptions TaskCreationOptions { get; public set; }
    public bool RemoveExpiredValues { get; public set; }
    private static LKGConfigurationCacheOptions();
    public IEqualityComparer`1<BaseConfiguration> get_BaseConfigurationComparer();
    public void set_BaseConfigurationComparer(IEqualityComparer`1<BaseConfiguration> value);
    public int get_LastKnownGoodConfigurationSizeLimit();
    public void set_LastKnownGoodConfigurationSizeLimit(int value);
    [CompilerGeneratedAttribute]
public TaskCreationOptions get_TaskCreationOptions();
    [CompilerGeneratedAttribute]
public void set_TaskCreationOptions(TaskCreationOptions value);
    [CompilerGeneratedAttribute]
public bool get_RemoveExpiredValues();
    [CompilerGeneratedAttribute]
public void set_RemoveExpiredValues(bool value);
}
internal class Microsoft.IdentityModel.Tokens.CreateECDsaDelegate : MulticastDelegate {
    public CreateECDsaDelegate(object object, IntPtr method);
    public virtual ECDsa Invoke(JsonWebKey jsonWebKey, bool usePrivateKey);
    public virtual IAsyncResult BeginInvoke(JsonWebKey jsonWebKey, bool usePrivateKey, AsyncCallback callback, object object);
    public virtual ECDsa EndInvoke(IAsyncResult result);
}
internal static class Microsoft.IdentityModel.Tokens.CryptographicOperations : object {
    public static void ZeroMemory(Byte[] buffer);
}
public abstract class Microsoft.IdentityModel.Tokens.CryptoProviderCache : object {
    protected abstract virtual string GetCacheKey(SignatureProvider signatureProvider);
    protected abstract virtual string GetCacheKey(SecurityKey securityKey, string algorithm, string typeofProvider);
    public abstract virtual bool TryAdd(SignatureProvider signatureProvider);
    public abstract virtual bool TryGetSignatureProvider(SecurityKey securityKey, string algorithm, string typeofProvider, bool willCreateSignatures, SignatureProvider& signatureProvider);
    public abstract virtual bool TryRemove(SignatureProvider signatureProvider);
}
public class Microsoft.IdentityModel.Tokens.CryptoProviderCacheOptions : object {
    private int _sizeLimit;
    public static int DefaultSizeLimit;
    public int SizeLimit { get; public set; }
    private static CryptoProviderCacheOptions();
    public int get_SizeLimit();
    public void set_SizeLimit(int value);
}
public class Microsoft.IdentityModel.Tokens.CryptoProviderFactory : object {
    private static CryptoProviderFactory _default;
    private static ConcurrentDictionary`2<string, string> _typeToAlgorithmMap;
    private static int _defaultSignatureProviderObjectPoolCacheSize;
    private static string _typeofAsymmetricSignatureProvider;
    private static string _typeofSymmetricSignatureProvider;
    private int _signatureProviderObjectPoolCacheSize;
    [CompilerGeneratedAttribute]
private static bool <DefaultCacheSignatureProviders>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderCache <CryptoProviderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private ICryptoProvider <CustomCryptoProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <CacheSignatureProviders>k__BackingField;
    public static CryptoProviderFactory Default { get; public set; }
    [DefaultValueAttribute("True")]
public static bool DefaultCacheSignatureProviders { get; public set; }
    public static int DefaultSignatureProviderObjectPoolCacheSize { get; public set; }
    public CryptoProviderCache CryptoProviderCache { get; internal set; }
    public ICryptoProvider CustomCryptoProvider { get; public set; }
    [DefaultValueAttribute("True")]
public bool CacheSignatureProviders { get; public set; }
    public int SignatureProviderObjectPoolCacheSize { get; public set; }
    private static CryptoProviderFactory();
    public CryptoProviderFactory(CryptoProviderCache cache);
    public CryptoProviderFactory(CryptoProviderFactory other);
    public static CryptoProviderFactory get_Default();
    public static void set_Default(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public static bool get_DefaultCacheSignatureProviders();
    [CompilerGeneratedAttribute]
public static void set_DefaultCacheSignatureProviders(bool value);
    public static int get_DefaultSignatureProviderObjectPoolCacheSize();
    public static void set_DefaultSignatureProviderObjectPoolCacheSize(int value);
    [CompilerGeneratedAttribute]
public CryptoProviderCache get_CryptoProviderCache();
    [CompilerGeneratedAttribute]
internal void set_CryptoProviderCache(CryptoProviderCache value);
    [CompilerGeneratedAttribute]
public ICryptoProvider get_CustomCryptoProvider();
    [CompilerGeneratedAttribute]
public void set_CustomCryptoProvider(ICryptoProvider value);
    [CompilerGeneratedAttribute]
public bool get_CacheSignatureProviders();
    [CompilerGeneratedAttribute]
public void set_CacheSignatureProviders(bool value);
    public int get_SignatureProviderObjectPoolCacheSize();
    public void set_SignatureProviderObjectPoolCacheSize(int value);
    public virtual AuthenticatedEncryptionProvider CreateAuthenticatedEncryptionProvider(SecurityKey key, string algorithm);
    public virtual KeyWrapProvider CreateKeyWrapProvider(SecurityKey key, string algorithm);
    public virtual KeyWrapProvider CreateKeyWrapProviderForUnwrap(SecurityKey key, string algorithm);
    private KeyWrapProvider CreateKeyWrapProvider(SecurityKey key, string algorithm, bool willUnwrap);
    public virtual SignatureProvider CreateForSigning(SecurityKey key, string algorithm);
    public virtual SignatureProvider CreateForSigning(SecurityKey key, string algorithm, bool cacheProvider);
    public virtual SignatureProvider CreateForVerifying(SecurityKey key, string algorithm);
    public virtual SignatureProvider CreateForVerifying(SecurityKey key, string algorithm, bool cacheProvider);
    public virtual HashAlgorithm CreateHashAlgorithm(HashAlgorithmName algorithm);
    public virtual HashAlgorithm CreateHashAlgorithm(string algorithm);
    public virtual KeyedHashAlgorithm CreateKeyedHashAlgorithm(Byte[] keyBytes, string algorithm);
    private static void ValidateKeySize(Byte[] keyBytes, string algorithm, int expectedNumberOfBytes);
    private SignatureProvider CreateSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures, bool cacheProvider);
    internal static bool ShouldCacheSignatureProvider(SignatureProvider signatureProvider);
    public virtual bool IsSupportedAlgorithm(string algorithm);
    public virtual bool IsSupportedAlgorithm(string algorithm, SecurityKey key);
    public virtual void ReleaseHashAlgorithm(HashAlgorithm hashAlgorithm);
    public virtual void ReleaseKeyWrapProvider(KeyWrapProvider provider);
    public virtual void ReleaseRsaKeyWrapProvider(RsaKeyWrapProvider provider);
    public virtual void ReleaseSignatureProvider(SignatureProvider signatureProvider);
}
[ExtensionAttribute]
internal static class Microsoft.IdentityModel.Tokens.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
public static class Microsoft.IdentityModel.Tokens.DateTimeUtil : object {
    public static DateTime Add(DateTime time, TimeSpan timespan);
    public static DateTime GetMaxValue(DateTimeKind kind);
    public static DateTime GetMinValue(DateTimeKind kind);
    public static Nullable`1<DateTime> ToUniversalTime(Nullable`1<DateTime> value);
    public static DateTime ToUniversalTime(DateTime value);
}
internal class Microsoft.IdentityModel.Tokens.DecryptDelegate : MulticastDelegate {
    public DecryptDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] bytes);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.DecryptionDelegate : MulticastDelegate {
    public DecryptionDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] cipherText, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag);
    public virtual IAsyncResult BeginInvoke(Byte[] cipherText, Byte[] authenticatedData, Byte[] iv, Byte[] authenticationTag, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.DeflateCompressionProvider : object {
    private int _maximumTokenSizeInBytes;
    [CompilerGeneratedAttribute]
private CompressionLevel <CompressionLevel>k__BackingField;
    public string Algorithm { get; }
    public CompressionLevel CompressionLevel { get; private set; }
    public int MaximumDeflateSize { get; public set; }
    public DeflateCompressionProvider(CompressionLevel compressionLevel);
    public sealed virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public CompressionLevel get_CompressionLevel();
    [CompilerGeneratedAttribute]
private void set_CompressionLevel(CompressionLevel value);
    public int get_MaximumDeflateSize();
    public void set_MaximumDeflateSize(int value);
    public sealed virtual Byte[] Decompress(Byte[] value);
    public sealed virtual Byte[] Compress(Byte[] value);
    public sealed virtual bool IsSupportedAlgorithm(string algorithm);
}
internal class Microsoft.IdentityModel.Tokens.DisposableObjectPool`1 : object {
    private Func`1<T> _factory;
    [CompilerGeneratedAttribute]
private Element[] <Items>k__BackingField;
    [CompilerGeneratedAttribute]
private int <Size>k__BackingField;
    internal Element[] Items { get; }
    internal int Size { get; }
    internal DisposableObjectPool`1(Func`1<T> factory);
    internal DisposableObjectPool`1(Func`1<T> factory, int size);
    [CompilerGeneratedAttribute]
internal Element[] get_Items();
    [CompilerGeneratedAttribute]
internal int get_Size();
    private T CreateInstance();
    internal T Allocate();
    internal void Free(T obj);
}
internal class Microsoft.IdentityModel.Tokens.ECDsaAdapter : object {
    internal CreateECDsaDelegate CreateECDsaFunction;
    internal static ECDsaAdapter Instance;
    private static ECDsaAdapter();
    internal ECDsa CreateECDsa(JsonWebKey jsonWebKey, bool usePrivateKey);
    private ECDsa CreateECDsaUsingCNGKey(JsonWebKey jsonWebKey, bool usePrivateKey);
    internal static ECDsa ECDsaNotSupported(JsonWebKey jsonWebKey, bool usePrivateKey);
    private static UInt32 GetKeyByteCount(string curveId);
    private static UInt32 GetMagicValue(string curveId, bool willCreateSignatures);
}
public class Microsoft.IdentityModel.Tokens.ECDsaSecurityKey : AsymmetricSecurityKey {
    private Nullable`1<bool> _hasPrivateKey;
    [CompilerGeneratedAttribute]
private ECDsa <ECDsa>k__BackingField;
    public ECDsa ECDsa { get; private set; }
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use FoundPrivateKey instead.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public int KeySize { get; }
    internal ECDsaSecurityKey(JsonWebKey webKey, bool usePrivateKey);
    public ECDsaSecurityKey(ECDsa ecdsa);
    [CompilerGeneratedAttribute]
public ECDsa get_ECDsa();
    [CompilerGeneratedAttribute]
private void set_ECDsa(ECDsa value);
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    public virtual int get_KeySize();
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
}
internal static class Microsoft.IdentityModel.Tokens.EncodingUtils : object {
    internal static T PerformEncodingDependentOperation(string input, Encoding encoding, Func`3<Byte[], int, T> action);
    internal static T PerformEncodingDependentOperation(string input, int offset, int length, Encoding encoding, Func`3<Byte[], int, T> action);
    internal static T PerformEncodingDependentOperation(string input, int offset, int length, Encoding encoding, TX argx, TY argy, TZ argz, Func`6<Byte[], int, TX, TY, TZ, T> action);
    internal static T PerformEncodingDependentOperation(string input, Encoding encoding, TX parameter, Func`4<Byte[], int, TX, T> action);
    internal static T PerformEncodingDependentOperation(string input, int offset, int length, Encoding encoding, TX parameter, Func`4<Byte[], int, TX, T> action);
}
internal class Microsoft.IdentityModel.Tokens.EncryptDelegate : MulticastDelegate {
    public EncryptDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] bytes);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.EncryptingCredentials : object {
    private string _alg;
    private string _enc;
    private SecurityKey _key;
    [CompilerGeneratedAttribute]
private SecurityKey <KeyExchangePublicKey>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SetDefaultCtyClaim>k__BackingField;
    public string Alg { get; private set; }
    public string Enc { get; private set; }
    public SecurityKey KeyExchangePublicKey { get; public set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public bool SetDefaultCtyClaim { get; public set; }
    public SecurityKey Key { get; private set; }
    protected EncryptingCredentials(X509Certificate2 certificate, string alg, string enc);
    public EncryptingCredentials(SecurityKey key, string alg, string enc);
    public EncryptingCredentials(SymmetricSecurityKey key, string enc);
    public string get_Alg();
    private void set_Alg(string value);
    public string get_Enc();
    private void set_Enc(string value);
    [CompilerGeneratedAttribute]
public SecurityKey get_KeyExchangePublicKey();
    [CompilerGeneratedAttribute]
public void set_KeyExchangePublicKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public bool get_SetDefaultCtyClaim();
    [CompilerGeneratedAttribute]
public void set_SetDefaultCtyClaim(bool value);
    public SecurityKey get_Key();
    private void set_Key(SecurityKey value);
}
internal class Microsoft.IdentityModel.Tokens.EncryptionDelegate : MulticastDelegate {
    public EncryptionDelegate(object object, IntPtr method);
    public virtual AuthenticatedEncryptionResult Invoke(Byte[] plaintText, Byte[] authenticatedData, Byte[] iv);
    public virtual IAsyncResult BeginInvoke(Byte[] plaintText, Byte[] authenticatedData, Byte[] iv, AsyncCallback callback, object object);
    public virtual AuthenticatedEncryptionResult EndInvoke(IAsyncResult result);
}
public static class Microsoft.IdentityModel.Tokens.EpochTime : object {
    public static DateTime UnixEpoch;
    private static EpochTime();
    public static long GetIntDate(DateTime datetime);
    public static DateTime DateTime(long secondsSinceUnixEpoch);
}
internal class Microsoft.IdentityModel.Tokens.EventBasedLRUCache`2 : object {
    private int _capacity;
    private List`1<LRUCacheItem`2<TKey, TValue>> _compactedItems;
    private double _compactionPercentage;
    private LinkedList`1<LRUCacheItem`2<TKey, TValue>> _doubleLinkedList;
    private ConcurrentQueue`1<Action> _eventQueue;
    private TaskCreationOptions _options;
    private bool _maintainLRU;
    private ConcurrentDictionary`2<TKey, LRUCacheItem`2<TKey, TValue>> _map;
    private double _maxCapacityPercentage;
    private int _compactIntervalInSeconds;
    private bool _removeExpiredValues;
    private int _removeExpiredValuesIntervalInSeconds;
    private int _taskCount;
    private DateTime _timeForNextExpiredValuesRemoval;
    private DateTime _timeForNextCompaction;
    private int _eventQueuePollingInterval;
    private long _eventQueueTaskIdleTimeoutInSeconds;
    private DateTime _eventQueueTaskStopTime;
    private static int EventQueueTaskStopped;
    private static int EventQueueTaskRunning;
    private static int EventQueueTaskDoNotStop;
    private int _eventQueueTaskState;
    private static int ActionNotQueued;
    private static int ActionQueuedOrRunning;
    private int _compactValuesState;
    private int _removeExpiredValuesState;
    private int _processCompactedValuesState;
    private bool _shouldStopImmediately;
    [CompilerGeneratedAttribute]
private ItemExpired<TKey, TValue> <OnItemExpired>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemCompacted<TKey, TValue> <OnItemMovedToCompactedList>k__BackingField;
    [CompilerGeneratedAttribute]
private ItemRemoved<TKey, TValue> <OnItemRemovedFromCompactedList>k__BackingField;
    [CompilerGeneratedAttribute]
private ShouldRemove<TKey, TValue> <OnShouldRemoveFromCompactedList>k__BackingField;
    internal ItemExpired<TKey, TValue> OnItemExpired { get; internal set; }
    internal ItemExpired<TKey, TValue> OnItemRemoved { get; internal set; }
    internal ItemCompacted<TKey, TValue> OnItemMovedToCompactedList { get; internal set; }
    internal ItemRemoved<TKey, TValue> OnItemRemovedFromCompactedList { get; internal set; }
    internal ShouldRemove<TKey, TValue> OnShouldRemoveFromCompactedList { get; internal set; }
    internal long EventQueueTaskIdleTimeoutInSeconds { get; internal set; }
    internal LinkedList`1<LRUCacheItem`2<TKey, TValue>> LinkedList { get; }
    internal long LinkedListCount { get; }
    internal long MapCount { get; }
    internal ICollection`1<LRUCacheItem`2<TKey, TValue>> MapValues { get; }
    internal long EventQueueCount { get; }
    internal int TaskCount { get; }
    internal EventBasedLRUCache`2(int capacity, TaskCreationOptions options, IEqualityComparer`1<TKey> comparer, bool removeExpiredValues, int removeExpiredValuesIntervalInSeconds, bool maintainLRU, int compactIntervalInSeconds);
    [CompilerGeneratedAttribute]
internal ItemExpired<TKey, TValue> get_OnItemExpired();
    [CompilerGeneratedAttribute]
internal void set_OnItemExpired(ItemExpired<TKey, TValue> value);
    internal ItemExpired<TKey, TValue> get_OnItemRemoved();
    internal void set_OnItemRemoved(ItemExpired<TKey, TValue> value);
    [CompilerGeneratedAttribute]
internal ItemCompacted<TKey, TValue> get_OnItemMovedToCompactedList();
    [CompilerGeneratedAttribute]
internal void set_OnItemMovedToCompactedList(ItemCompacted<TKey, TValue> value);
    [CompilerGeneratedAttribute]
internal ItemRemoved<TKey, TValue> get_OnItemRemovedFromCompactedList();
    [CompilerGeneratedAttribute]
internal void set_OnItemRemovedFromCompactedList(ItemRemoved<TKey, TValue> value);
    [CompilerGeneratedAttribute]
internal ShouldRemove<TKey, TValue> get_OnShouldRemoveFromCompactedList();
    [CompilerGeneratedAttribute]
internal void set_OnShouldRemoveFromCompactedList(ShouldRemove<TKey, TValue> value);
    internal long get_EventQueueTaskIdleTimeoutInSeconds();
    internal void set_EventQueueTaskIdleTimeoutInSeconds(long value);
    private void DomainProcessExit(object sender, EventArgs e);
    private void DomainUnload(object sender, EventArgs e);
    internal void StopEventQueueTask();
    private void StopEventQueueTaskImmediately();
    private void AddActionToEventQueue(Action action);
    public bool Contains(TKey key);
    private void EventQueueTaskAction();
    internal void RemoveExpiredValuesLRU();
    internal void RemoveExpiredValues();
    internal void ProcessCompactedValues();
    private void CompactLRU();
    private void Compact();
    protected int CalculateNewCacheSize();
    private DateTime SetTaskEndTime();
    public void SetValue(TKey key, TValue value);
    public bool SetValue(TKey key, TValue value, DateTime expirationTime);
    private void StartEventQueueTaskIfNotRunning();
    internal KeyValuePair`2[] ToArray();
    public bool TryGetValue(TKey key, TValue& value);
    public bool TryRemove(TKey key);
    public bool TryRemove(TKey key, TValue& value);
    internal LinkedList`1<LRUCacheItem`2<TKey, TValue>> get_LinkedList();
    internal long get_LinkedListCount();
    internal long get_MapCount();
    internal ICollection`1<LRUCacheItem`2<TKey, TValue>> get_MapValues();
    internal long get_EventQueueCount();
    internal int get_TaskCount();
    internal void WaitForProcessing();
}
internal class Microsoft.IdentityModel.Tokens.ExceptionDetail : object {
    [CompilerGeneratedAttribute]
private ExceptionType <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private Exception <InnerException>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDetail <MessageDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<StackFrame> <StackFrames>k__BackingField;
    public ExceptionType Type { get; }
    public Exception InnerException { get; }
    public MessageDetail MessageDetail { get; }
    public IList`1<StackFrame> StackFrames { get; }
    public ExceptionDetail(MessageDetail messageDetail, ExceptionType exceptionType, StackFrame stackFrame);
    public ExceptionDetail(MessageDetail messageDetail, ExceptionType exceptionType, StackFrame stackFrame, Exception innerException);
    public Exception GetException();
    internal static ExceptionDetail NullParameter(string parameterName);
    [CompilerGeneratedAttribute]
public ExceptionType get_Type();
    [CompilerGeneratedAttribute]
public Exception get_InnerException();
    [CompilerGeneratedAttribute]
public MessageDetail get_MessageDetail();
    [CompilerGeneratedAttribute]
public IList`1<StackFrame> get_StackFrames();
    private Exception ExceptionFromType(ExceptionType exceptionType, Exception innerException);
}
public interface Microsoft.IdentityModel.Tokens.ICompressionProvider {
    public string Algorithm { get; }
    public abstract virtual string get_Algorithm();
    public abstract virtual bool IsSupportedAlgorithm(string algorithm);
    public abstract virtual Byte[] Decompress(Byte[] value);
    public abstract virtual Byte[] Compress(Byte[] value);
}
public interface Microsoft.IdentityModel.Tokens.ICryptoProvider {
    public abstract virtual bool IsSupportedAlgorithm(string algorithm, Object[] args);
    public abstract virtual object Create(string algorithm, Object[] args);
    public abstract virtual void Release(object cryptoInstance);
}
public class Microsoft.IdentityModel.Tokens.InMemoryCryptoProviderCache : CryptoProviderCache {
    internal CryptoProviderCacheOptions _cryptoProviderCacheOptions;
    private bool _disposed;
    private EventBasedLRUCache`2<string, SignatureProvider> _signingSignatureProviders;
    private EventBasedLRUCache`2<string, SignatureProvider> _verifyingSignatureProviders;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    internal CryptoProviderFactory CryptoProviderFactory { get; internal set; }
    internal long TaskCount { get; }
    public InMemoryCryptoProviderCache(CryptoProviderCacheOptions cryptoProviderCacheOptions);
    internal InMemoryCryptoProviderCache(CryptoProviderCacheOptions cryptoProviderCacheOptions, TaskCreationOptions options, int tryTakeTimeout);
    [CompilerGeneratedAttribute]
internal CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
internal void set_CryptoProviderFactory(CryptoProviderFactory value);
    private static void DisposeSignatureProvider(SignatureProvider signatureProvider);
    private void SetCryptoProviderCacheToNull(SignatureProvider signatureProvider);
    private static bool IsCacheNullAndRefCountZero(SignatureProvider signatureProvider);
    protected virtual string GetCacheKey(SignatureProvider signatureProvider);
    protected virtual string GetCacheKey(SecurityKey securityKey, string algorithm, string typeofProvider);
    private static string GetCacheKeyPrivate(SecurityKey securityKey, string algorithm, string typeofProvider);
    public virtual bool TryAdd(SignatureProvider signatureProvider);
    public virtual bool TryGetSignatureProvider(SecurityKey securityKey, string algorithm, string typeofProvider, bool willCreateSignatures, SignatureProvider& signatureProvider);
    public virtual bool TryRemove(SignatureProvider signatureProvider);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal long LinkedListCountSigning();
    internal long LinkedListCountVerifying();
    internal long MapCountSigning();
    internal long MapCountVerifying();
    internal long EventQueueCountSigning();
    internal long EventQueueCountVerifying();
    internal long get_TaskCount();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.InternalTokenValidationResult : object {
    private bool _isValid;
    [NullableAttribute("2")]
private SecurityToken _securityToken;
    private TokenHandler _tokenHandler;
    private List`1<ValidationResult> _validationResults;
    [NullableAttribute("2")]
public ExceptionDetail ExceptionDetail { get; }
    public bool IsValid { get; }
    [NullableAttribute("2")]
public SecurityToken SecurityToken { get; }
    public IList`1<ValidationResult> ValidationResults { get; }
    public InternalTokenValidationResult(SecurityToken securityToken, TokenHandler tokenHandler);
    public bool AddResult(ValidationResult validationResult);
    public bool AddResults(IList`1<ValidationResult> validationResults);
    [NullableContextAttribute("2")]
public ExceptionDetail get_ExceptionDetail();
    public bool get_IsValid();
    public bool Merge(InternalTokenValidationResult other);
    [NullableContextAttribute("2")]
public SecurityToken get_SecurityToken();
    public TokenValidationResult ToTokenValidationResult();
    public IList`1<ValidationResult> get_ValidationResults();
}
internal static class Microsoft.IdentityModel.Tokens.InternalValidators : object {
    internal static void ValidateAfterSignatureFailed(SecurityToken securityToken, Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, IEnumerable`1<string> audiences, TokenValidationParameters validationParameters, BaseConfiguration configuration);
}
internal class Microsoft.IdentityModel.Tokens.Interop : object {
}
public interface Microsoft.IdentityModel.Tokens.ISecurityTokenValidator {
    public bool CanValidateToken { get; }
    public int MaximumTokenSizeInBytes { get; public set; }
    public abstract virtual bool CanReadToken(string securityToken);
    public abstract virtual bool get_CanValidateToken();
    public abstract virtual int get_MaximumTokenSizeInBytes();
    public abstract virtual void set_MaximumTokenSizeInBytes(int value);
    public abstract virtual ClaimsPrincipal ValidateToken(string securityToken, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyResolver : MulticastDelegate {
    public IssuerSigningKeyResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SecurityKey> EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.IssuerSigningKeyResolverDelegate : MulticastDelegate {
    public IssuerSigningKeyResolverDelegate(object object, IntPtr method);
    [NullableContextAttribute("2")]
public virtual SecurityKey Invoke(string token, SecurityToken securityToken, string kid, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext);
    [NullableContextAttribute("2")]
public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext, AsyncCallback callback, object object);
    public virtual SecurityKey EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyResolverUsingConfiguration : MulticastDelegate {
    public IssuerSigningKeyResolverUsingConfiguration(object object, IntPtr method);
    public virtual IEnumerable`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, BaseConfiguration configuration, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SecurityKey> EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyValidator : MulticastDelegate {
    public IssuerSigningKeyValidator(object object, IntPtr method);
    public virtual bool Invoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.IssuerSigningKeyValidatorDelegate : MulticastDelegate {
    public IssuerSigningKeyValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual SigningKeyValidationResult Invoke(SecurityKey signingKey, SecurityToken securityToken, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(SecurityKey signingKey, SecurityToken securityToken, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext, AsyncCallback callback, object object);
    public virtual SigningKeyValidationResult EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerSigningKeyValidatorUsingConfiguration : MulticastDelegate {
    public IssuerSigningKeyValidatorUsingConfiguration(object object, IntPtr method);
    public virtual bool Invoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    public virtual IAsyncResult BeginInvoke(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.IssuerValidationDelegateAsync : MulticastDelegate {
    public IssuerValidationDelegateAsync(object object, IntPtr method);
    public virtual Task`1<IssuerValidationResult> Invoke(string issuer, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, Nullable`1<CancellationToken> cancellationToken);
    public virtual IAsyncResult BeginInvoke(string issuer, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, Nullable`1<CancellationToken> cancellationToken, AsyncCallback callback, object object);
    public virtual Task`1<IssuerValidationResult> EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.IssuerValidationResult : ValidationResult {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationSource <Source>k__BackingField;
    public Exception Exception { get; }
    public string Issuer { get; }
    public ValidationSource Source { get; }
    public IssuerValidationResult(string issuer, ValidationSource source);
    public IssuerValidationResult(string issuer, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail, ValidationSource source);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
public ValidationSource get_Source();
}
public class Microsoft.IdentityModel.Tokens.IssuerValidator : MulticastDelegate {
    public IssuerValidator(object object, IntPtr method);
    public virtual string Invoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.IssuerValidatorAsync : MulticastDelegate {
    public IssuerValidatorAsync(object object, IntPtr method);
    public virtual ValueTask`1<string> Invoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual ValueTask`1<string> EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.IssuerValidatorUsingConfiguration : MulticastDelegate {
    public IssuerValidatorUsingConfiguration(object object, IntPtr method);
    public virtual string Invoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    public virtual IAsyncResult BeginInvoke(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
public interface Microsoft.IdentityModel.Tokens.ITokenReplayCache {
    public abstract virtual bool TryAdd(string securityToken, DateTime expiresOn);
    public abstract virtual bool TryFind(string securityToken);
}
internal static class Microsoft.IdentityModel.Tokens.Json.JsonSerializerPrimitives : object {
    private static int MaxDepth;
    internal static string True;
    internal static string False;
    private static HashSet`1<string> s_knownNonDateTimeClaimTypes;
    private static JsonSerializerPrimitives();
    public static JsonException CreateJsonReaderException(Utf8JsonReader& reader, string expectedType, string className, string propertyName, Exception innerException);
    public static Exception CreateJsonReaderExceptionInvalidType(Utf8JsonReader& reader, string expectedType, string className, string propertyName);
    public static JsonElement CreateJsonElement(IList`1<string> strings);
    public static JsonElement CreateJsonElement(string json);
    internal static object CreateObjectFromJsonElement(JsonElement jsonElement, int currentDepth);
    internal static object CreateObjectFromJsonElement(JsonElement jsonElement, int currentDepth, string claimType);
    public static bool TryCreateTypeFromJsonElement(JsonElement jsonElement, T& t);
    internal static bool IsReaderAtTokenType(Utf8JsonReader& reader, JsonTokenType tokenType, bool advanceReader);
    internal static bool ReadBoolean(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static long ReadLong(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static JsonElement ReadJsonElement(Utf8JsonReader& reader);
    internal static List`1<object> ReadArrayOfObjects(Utf8JsonReader& reader, string propertyName, string className);
    internal static string ReadPropertyName(Utf8JsonReader& reader, string className, bool advanceReader);
    internal static string ReadString(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static string ReadStringAsBool(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static string ReadStringOrNumberAsString(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static bool IsKnownToNotBeDateTime(string claimType);
    internal static object ReadStringAsObject(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static ICollection`1<string> ReadStrings(Utf8JsonReader& reader, ICollection`1<string> strings, string propertyName, string className, bool read);
    internal static IList`1<string> ReadStrings(Utf8JsonReader& reader, IList`1<string> strings, string propertyName, string className, bool read);
    internal static void ReadStringsSkipNulls(Utf8JsonReader& reader, List`1<string> strings, string propertyName, string className);
    internal static object ReadPropertyValueAsObject(Utf8JsonReader& reader, string propertyName, string className, bool read);
    internal static object ReadNumber(Utf8JsonReader& reader);
    private static bool IsReaderPositionedOnNull(Utf8JsonReader& reader, bool read, bool advanceReader);
    public static void WriteAsJsonElement(Utf8JsonWriter& writer, string json);
    public static void WriteObjects(Utf8JsonWriter& writer, IDictionary`2<string, object> dictionary);
    public static void WriteObject(Utf8JsonWriter& writer, string key, object obj);
    public static void WriteObjectValue(Utf8JsonWriter& writer, object obj);
    public static void WriteStrings(Utf8JsonWriter& writer, ReadOnlySpan`1<byte> propertyName, IList`1<string> strings);
    public static void WriteStrings(Utf8JsonWriter& writer, ReadOnlySpan`1<byte> propertyName, ICollection`1<string> strings);
    public static void WriteStrings(Utf8JsonWriter& writer, ReadOnlySpan`1<byte> propertyName, IList`1<string> strings, string extraString);
}
internal static class Microsoft.IdentityModel.Tokens.Json.JsonWebKeySerializer : object {
    public static HashSet`1<string> JsonWebKeyParameterNamesUpperCase;
    private static JsonWebKeySerializer();
    public static JsonWebKey Read(string json);
    public static JsonWebKey Read(string json, JsonWebKey jsonWebKey);
    public static JsonWebKey Read(Utf8JsonReader& reader, JsonWebKey jsonWebKey);
    public static string Write(JsonWebKey jsonWebKey);
    public static void Write(Utf8JsonWriter& writer, JsonWebKey jsonWebKey);
}
internal static class Microsoft.IdentityModel.Tokens.Json.JsonWebKeySetSerializer : object {
    private static Byte[] _keysUtf8;
    private static JsonWebKeySetSerializer();
    public static JsonWebKeySet Read(string json, JsonWebKeySet jsonWebKeySet);
    public static JsonWebKeySet Read(Utf8JsonReader& reader, JsonWebKeySet jsonWebKeySet);
    public static void ReadKeys(Utf8JsonReader& reader, JsonWebKeySet jsonWebKeySet);
    public static string Write(JsonWebKeySet jsonWebKeySet);
    public static void Write(Utf8JsonWriter& writer, JsonWebKeySet jsonWebKeySet);
}
public static class Microsoft.IdentityModel.Tokens.JsonWebAlgorithmsKeyTypes : object {
    public static string EllipticCurve;
    public static string RSA;
    public static string Octet;
}
public class Microsoft.IdentityModel.Tokens.JsonWebKey : SecurityKey {
    internal static string ClassName;
    private Dictionary`2<string, object> _additionalData;
    private List`1<string> _keyOps;
    private List`1<string> _oth;
    private List`1<string> _x5c;
    private string _kid;
    [CompilerGeneratedAttribute]
private SecurityKey <ConvertedSecurityKey>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConvertKeyInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Alg>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Crv>k__BackingField;
    [CompilerGeneratedAttribute]
private string <D>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DP>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DQ>k__BackingField;
    [CompilerGeneratedAttribute]
private string <E>k__BackingField;
    [CompilerGeneratedAttribute]
private string <K>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Kty>k__BackingField;
    [CompilerGeneratedAttribute]
private string <N>k__BackingField;
    [CompilerGeneratedAttribute]
private string <P>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Q>k__BackingField;
    [CompilerGeneratedAttribute]
private string <QI>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Use>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5t>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5tS256>k__BackingField;
    [CompilerGeneratedAttribute]
private string <X5u>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Y>k__BackingField;
    [JsonIgnoreAttribute]
internal SecurityKey ConvertedSecurityKey { get; internal set; }
    [JsonIgnoreAttribute]
internal string ConvertKeyInfo { get; internal set; }
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> AdditionalData { get; }
    [JsonPropertyNameAttribute("alg")]
public string Alg { get; public set; }
    [JsonPropertyNameAttribute("crv")]
public string Crv { get; public set; }
    [JsonPropertyNameAttribute("d")]
public string D { get; public set; }
    [JsonPropertyNameAttribute("dp")]
public string DP { get; public set; }
    [JsonPropertyNameAttribute("dq")]
public string DQ { get; public set; }
    [JsonPropertyNameAttribute("e")]
public string E { get; public set; }
    [JsonPropertyNameAttribute("k")]
public string K { get; public set; }
    [JsonIgnoreAttribute]
public string KeyId { get; public set; }
    [JsonPropertyNameAttribute("key_ops")]
public IList`1<string> KeyOps { get; }
    [JsonPropertyNameAttribute("kid")]
public string Kid { get; public set; }
    [JsonPropertyNameAttribute("kty")]
public string Kty { get; public set; }
    [JsonPropertyNameAttribute("n")]
public string N { get; public set; }
    [JsonPropertyNameAttribute("oth")]
public IList`1<string> Oth { get; }
    [JsonPropertyNameAttribute("p")]
public string P { get; public set; }
    [JsonPropertyNameAttribute("q")]
public string Q { get; public set; }
    [JsonPropertyNameAttribute("qi")]
public string QI { get; public set; }
    [JsonPropertyNameAttribute("use")]
public string Use { get; public set; }
    [JsonPropertyNameAttribute("x")]
public string X { get; public set; }
    [JsonPropertyNameAttribute("x5c")]
public IList`1<string> X5c { get; }
    [JsonPropertyNameAttribute("x5t")]
public string X5t { get; public set; }
    [JsonPropertyNameAttribute("x5t#S256")]
public string X5tS256 { get; public set; }
    [JsonPropertyNameAttribute("x5u")]
public string X5u { get; public set; }
    [JsonPropertyNameAttribute("y")]
public string Y { get; public set; }
    [JsonIgnoreAttribute]
public int KeySize { get; }
    [JsonIgnoreAttribute]
public bool HasPrivateKey { get; }
    public JsonWebKey(string json);
    public static JsonWebKey Create(string json);
    [CompilerGeneratedAttribute]
internal SecurityKey get_ConvertedSecurityKey();
    [CompilerGeneratedAttribute]
internal void set_ConvertedSecurityKey(SecurityKey value);
    [CompilerGeneratedAttribute]
internal string get_ConvertKeyInfo();
    [CompilerGeneratedAttribute]
internal void set_ConvertKeyInfo(string value);
    public IDictionary`2<string, object> get_AdditionalData();
    [CompilerGeneratedAttribute]
public string get_Alg();
    [CompilerGeneratedAttribute]
public void set_Alg(string value);
    [CompilerGeneratedAttribute]
public string get_Crv();
    [CompilerGeneratedAttribute]
public void set_Crv(string value);
    [CompilerGeneratedAttribute]
public string get_D();
    [CompilerGeneratedAttribute]
public void set_D(string value);
    [CompilerGeneratedAttribute]
public string get_DP();
    [CompilerGeneratedAttribute]
public void set_DP(string value);
    [CompilerGeneratedAttribute]
public string get_DQ();
    [CompilerGeneratedAttribute]
public void set_DQ(string value);
    [CompilerGeneratedAttribute]
public string get_E();
    [CompilerGeneratedAttribute]
public void set_E(string value);
    [CompilerGeneratedAttribute]
public string get_K();
    [CompilerGeneratedAttribute]
public void set_K(string value);
    public virtual string get_KeyId();
    public virtual void set_KeyId(string value);
    public IList`1<string> get_KeyOps();
    public string get_Kid();
    public void set_Kid(string value);
    [CompilerGeneratedAttribute]
public string get_Kty();
    [CompilerGeneratedAttribute]
public void set_Kty(string value);
    [CompilerGeneratedAttribute]
public string get_N();
    [CompilerGeneratedAttribute]
public void set_N(string value);
    public IList`1<string> get_Oth();
    [CompilerGeneratedAttribute]
public string get_P();
    [CompilerGeneratedAttribute]
public void set_P(string value);
    [CompilerGeneratedAttribute]
public string get_Q();
    [CompilerGeneratedAttribute]
public void set_Q(string value);
    [CompilerGeneratedAttribute]
public string get_QI();
    [CompilerGeneratedAttribute]
public void set_QI(string value);
    [CompilerGeneratedAttribute]
public string get_Use();
    [CompilerGeneratedAttribute]
public void set_Use(string value);
    [CompilerGeneratedAttribute]
public string get_X();
    [CompilerGeneratedAttribute]
public void set_X(string value);
    public IList`1<string> get_X5c();
    [CompilerGeneratedAttribute]
public string get_X5t();
    [CompilerGeneratedAttribute]
public void set_X5t(string value);
    [CompilerGeneratedAttribute]
public string get_X5tS256();
    [CompilerGeneratedAttribute]
public void set_X5tS256(string value);
    [CompilerGeneratedAttribute]
public string get_X5u();
    [CompilerGeneratedAttribute]
public void set_X5u(string value);
    [CompilerGeneratedAttribute]
public string get_Y();
    [CompilerGeneratedAttribute]
public void set_Y(string value);
    public virtual int get_KeySize();
    public bool get_HasPrivateKey();
    internal RSAParameters CreateRsaParameters();
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
    private bool CanComputeOctThumbprint();
    private Byte[] ComputeOctThumbprint();
    private bool CanComputeRsaThumbprint();
    private Byte[] ComputeRsaThumbprint();
    private bool CanComputeECThumbprint();
    private Byte[] ComputeECThumbprint();
    internal string RepresentAsAsymmetricPublicJwk();
    public virtual string ToString();
}
public class Microsoft.IdentityModel.Tokens.JsonWebKeyConverter : object {
    public static JsonWebKey ConvertFromSecurityKey(SecurityKey key);
    public static JsonWebKey ConvertFromRSASecurityKey(RsaSecurityKey key);
    public static JsonWebKey ConvertFromX509SecurityKey(X509SecurityKey key);
    public static JsonWebKey ConvertFromX509SecurityKey(X509SecurityKey key, bool representAsRsaKey);
    public static JsonWebKey ConvertFromSymmetricSecurityKey(SymmetricSecurityKey key);
    internal static bool TryConvertToSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToSymmetricSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToX509SecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryCreateToRsaSecurityKey(JsonWebKey webKey, SecurityKey& key);
    internal static bool TryConvertToECDsaSecurityKey(JsonWebKey webKey, SecurityKey& key);
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyECTypes : object {
    public static string P256;
    public static string P384;
    public static string P512;
    public static string P521;
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyParameterNames : object {
    public static string Alg;
    public static string Crv;
    public static string D;
    public static string DP;
    public static string DQ;
    public static string E;
    public static string K;
    public static string KeyOps;
    public static string Keys;
    public static string Kid;
    public static string Kty;
    public static string N;
    public static string Oth;
    public static string P;
    public static string Q;
    public static string QI;
    public static string Use;
    public static string X;
    public static string X5c;
    public static string X5t;
    public static string X5tS256;
    public static string X5u;
    public static string Y;
}
[IsReadOnlyAttribute]
internal class Microsoft.IdentityModel.Tokens.JsonWebKeyParameterUtf8Bytes : ValueType {
    public static ReadOnlySpan`1<byte> Alg { get; }
    public static ReadOnlySpan`1<byte> Crv { get; }
    public static ReadOnlySpan`1<byte> D { get; }
    public static ReadOnlySpan`1<byte> DP { get; }
    public static ReadOnlySpan`1<byte> DQ { get; }
    public static ReadOnlySpan`1<byte> E { get; }
    public static ReadOnlySpan`1<byte> K { get; }
    public static ReadOnlySpan`1<byte> KeyOps { get; }
    public static ReadOnlySpan`1<byte> Keys { get; }
    public static ReadOnlySpan`1<byte> Kid { get; }
    public static ReadOnlySpan`1<byte> Kty { get; }
    public static ReadOnlySpan`1<byte> N { get; }
    public static ReadOnlySpan`1<byte> Oth { get; }
    public static ReadOnlySpan`1<byte> P { get; }
    public static ReadOnlySpan`1<byte> Q { get; }
    public static ReadOnlySpan`1<byte> QI { get; }
    public static ReadOnlySpan`1<byte> Use { get; }
    public static ReadOnlySpan`1<byte> X5c { get; }
    public static ReadOnlySpan`1<byte> X5t { get; }
    public static ReadOnlySpan`1<byte> X5tS256 { get; }
    public static ReadOnlySpan`1<byte> X5u { get; }
    public static ReadOnlySpan`1<byte> X { get; }
    public static ReadOnlySpan`1<byte> Y { get; }
    public static ReadOnlySpan`1<byte> get_Alg();
    public static ReadOnlySpan`1<byte> get_Crv();
    public static ReadOnlySpan`1<byte> get_D();
    public static ReadOnlySpan`1<byte> get_DP();
    public static ReadOnlySpan`1<byte> get_DQ();
    public static ReadOnlySpan`1<byte> get_E();
    public static ReadOnlySpan`1<byte> get_K();
    public static ReadOnlySpan`1<byte> get_KeyOps();
    public static ReadOnlySpan`1<byte> get_Keys();
    public static ReadOnlySpan`1<byte> get_Kid();
    public static ReadOnlySpan`1<byte> get_Kty();
    public static ReadOnlySpan`1<byte> get_N();
    public static ReadOnlySpan`1<byte> get_Oth();
    public static ReadOnlySpan`1<byte> get_P();
    public static ReadOnlySpan`1<byte> get_Q();
    public static ReadOnlySpan`1<byte> get_QI();
    public static ReadOnlySpan`1<byte> get_Use();
    public static ReadOnlySpan`1<byte> get_X5c();
    public static ReadOnlySpan`1<byte> get_X5t();
    public static ReadOnlySpan`1<byte> get_X5tS256();
    public static ReadOnlySpan`1<byte> get_X5u();
    public static ReadOnlySpan`1<byte> get_X();
    public static ReadOnlySpan`1<byte> get_Y();
}
public class Microsoft.IdentityModel.Tokens.JsonWebKeySet : object {
    internal static string ClassName;
    private Dictionary`2<string, object> _additionalData;
    private string _jsonData;
    [CompilerGeneratedAttribute]
private IList`1<JsonWebKey> <Keys>k__BackingField;
    [DefaultValueAttribute("True")]
public static bool DefaultSkipUnresolvedJsonWebKeys;
    [CompilerGeneratedAttribute]
private bool <SkipUnresolvedJsonWebKeys>k__BackingField;
    [JsonExtensionDataAttribute]
public IDictionary`2<string, object> AdditionalData { get; }
    [JsonPropertyNameAttribute("keys")]
public IList`1<JsonWebKey> Keys { get; internal set; }
    [DefaultValueAttribute("True")]
[JsonIgnoreAttribute]
public bool SkipUnresolvedJsonWebKeys { get; public set; }
    [JsonIgnoreAttribute]
internal string JsonData { get; internal set; }
    public JsonWebKeySet(string json);
    private static JsonWebKeySet();
    public static JsonWebKeySet Create(string json);
    public IDictionary`2<string, object> get_AdditionalData();
    [CompilerGeneratedAttribute]
public IList`1<JsonWebKey> get_Keys();
    [CompilerGeneratedAttribute]
internal void set_Keys(IList`1<JsonWebKey> value);
    [CompilerGeneratedAttribute]
public bool get_SkipUnresolvedJsonWebKeys();
    [CompilerGeneratedAttribute]
public void set_SkipUnresolvedJsonWebKeys(bool value);
    internal string get_JsonData();
    internal void set_JsonData(string value);
    public IList`1<SecurityKey> GetSigningKeys();
    private static bool IsValidX509SecurityKey(JsonWebKey webKey);
    private static bool IsValidRsaSecurityKey(JsonWebKey webKey);
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeySetParameterNames : object {
    public static string Keys;
}
public static class Microsoft.IdentityModel.Tokens.JsonWebKeyUseNames : object {
    public static string Sig;
    public static string Enc;
}
public abstract class Microsoft.IdentityModel.Tokens.KeyWrapProvider : object {
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public abstract virtual string get_Algorithm();
    public abstract virtual string get_Context();
    public abstract virtual void set_Context(string value);
    public abstract virtual SecurityKey get_Key();
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    public abstract virtual Byte[] UnwrapKey(Byte[] keyBytes);
    public abstract virtual Byte[] WrapKey(Byte[] keyBytes);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.LifetimeValidationResult : ValidationResult {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    public Exception Exception { get; }
    public Nullable`1<DateTime> NotBefore { get; }
    public Nullable`1<DateTime> Expires { get; }
    public LifetimeValidationResult(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires);
    [NullableContextAttribute("1")]
public LifetimeValidationResult(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotBefore();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
}
public class Microsoft.IdentityModel.Tokens.LifetimeValidator : MulticastDelegate {
    public LifetimeValidator(object object, IntPtr method);
    public virtual bool Invoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.LifetimeValidatorDelegate : MulticastDelegate {
    public LifetimeValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual LifetimeValidationResult Invoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual LifetimeValidationResult EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.LogDetail : object {
    [CompilerGeneratedAttribute]
private EventLogLevel <EventLogLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageDetail <MessageDetail>k__BackingField;
    public EventLogLevel EventLogLevel { get; }
    public MessageDetail MessageDetail { get; }
    public LogDetail(MessageDetail messageDetail, EventLogLevel eventLogLevel);
    [CompilerGeneratedAttribute]
public EventLogLevel get_EventLogLevel();
    [CompilerGeneratedAttribute]
public MessageDetail get_MessageDetail();
}
internal static class Microsoft.IdentityModel.Tokens.LogMessages : object {
    public static string IDX10000;
    public static string IDX10101;
    public static string IDX10100;
    public static string IDX10102;
    public static string IDX10103;
    public static string IDX10104;
    public static string IDX10105;
    public static string IDX10107;
    public static string IDX10108;
    public static string IDX10109;
    public static string IDX10110;
    public static string IDX10204;
    public static string IDX10205;
    public static string IDX10206;
    public static string IDX10207;
    public static string IDX10208;
    public static string IDX10209;
    public static string IDX10211;
    public static string IDX10212;
    public static string IDX10214;
    public static string IDX10215;
    public static string IDX10222;
    public static string IDX10223;
    public static string IDX10224;
    public static string IDX10225;
    public static string IDX10227;
    public static string IDX10228;
    public static string IDX10229;
    public static string IDX10230;
    public static string IDX10231;
    public static string IDX10232;
    public static string IDX10233;
    public static string IDX10234;
    public static string IDX10235;
    public static string IDX10236;
    public static string IDX10237;
    public static string IDX10238;
    public static string IDX10239;
    public static string IDX10240;
    public static string IDX10241;
    public static string IDX10242;
    public static string IDX10243;
    public static string IDX10244;
    public static string IDX10245;
    public static string IDX10246;
    public static string IDX10248;
    public static string IDX10249;
    public static string IDX10250;
    public static string IDX10251;
    public static string IDX10252;
    public static string IDX10253;
    public static string IDX10254;
    public static string IDX10255;
    public static string IDX10256;
    public static string IDX10257;
    public static string IDX10258;
    public static string IDX10261;
    public static string IDX10262;
    public static string IDX10264;
    public static string IDX10265;
    public static string IDX10267;
    public static string IDX10500;
    public static string IDX10503;
    public static string IDX10504;
    public static string IDX10505;
    public static string IDX10506;
    public static string IDX10508;
    public static string IDX10509;
    public static string IDX10510;
    public static string IDX10511;
    public static string IDX10512;
    public static string IDX10514;
    public static string IDX10517;
    public static string IDX10603;
    public static string IDX10607;
    public static string IDX10609;
    public static string IDX10610;
    public static string IDX10611;
    public static string IDX10612;
    public static string IDX10615;
    public static string IDX10616;
    public static string IDX10617;
    public static string IDX10618;
    public static string IDX10619;
    public static string IDX10620;
    public static string IDX10904;
    public static string IDX10905;
    public static string IDX10400;
    public static string IDX10401;
    public static string IDX10621;
    public static string IDX10625;
    public static string IDX10628;
    public static string IDX10630;
    public static string IDX10631;
    public static string IDX10634;
    public static string IDX10636;
    public static string IDX10637;
    public static string IDX10638;
    public static string IDX10640;
    public static string IDX10642;
    public static string IDX10645;
    public static string IDX10646;
    public static string IDX10647;
    public static string IDX10649;
    public static string IDX10650;
    public static string IDX10652;
    public static string IDX10653;
    public static string IDX10654;
    public static string IDX10655;
    public static string IDX10657;
    public static string IDX10658;
    public static string IDX10659;
    public static string IDX10661;
    public static string IDX10662;
    public static string IDX10663;
    public static string IDX10664;
    public static string IDX10665;
    public static string IDX10666;
    public static string IDX10667;
    public static string IDX10668;
    public static string IDX10669;
    public static string IDX10674;
    public static string IDX10675;
    public static string IDX10679;
    public static string IDX10680;
    public static string IDX10682;
    public static string IDX10684;
    public static string IDX10685;
    public static string IDX10686;
    public static string IDX10689;
    public static string IDX10690;
    public static string IDX10693;
    public static string IDX10694;
    public static string IDX10695;
    public static string IDX10696;
    public static string IDX10697;
    public static string IDX10698;
    public static string IDX10699;
    public static string IDX10700;
    public static string IDX10703;
    public static string IDX10704;
    public static string IDX10705;
    public static string IDX10706;
    public static string IDX10707;
    public static string IDX10708;
    public static string IDX10709;
    public static string IDX10710;
    public static string IDX10711;
    public static string IDX10712;
    public static string IDX10713;
    public static string IDX10714;
    public static string IDX10715;
    public static string IDX10716;
    public static string IDX10717;
    public static string IDX10718;
    public static string IDX10719;
    public static string IDX10720;
    public static string IDX10805;
    public static string IDX10806;
    public static string IDX10808;
    public static string IDX10810;
    public static string IDX10812;
    public static string IDX10813;
    public static string IDX10814;
    public static string IDX10815;
    public static string IDX10816;
    public static string IDX10820;
    public static string IDX10821;
    public static string IDX10900;
    public static string IDX10901;
    public static string IDX10902;
    public static string IDX10906;
    public static string IDX11000;
    public static string IDX11001;
    public static string IDX11002;
    public static string IDX11020;
    public static string IDX11022;
    public static string IDX11023;
    public static string IDX11025;
    public static string IDX11026;
}
internal class Microsoft.IdentityModel.Tokens.LRUCacheItem`2 : object {
    [CompilerGeneratedAttribute]
private TKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private TValue <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private DateTime <ExpirationTime>k__BackingField;
    internal TKey Key { get; }
    internal TValue Value { get; internal set; }
    internal DateTime ExpirationTime { get; internal set; }
    internal LRUCacheItem`2(TKey key, TValue value);
    internal LRUCacheItem`2(TKey key, TValue value, DateTime expirationTime);
    [CompilerGeneratedAttribute]
internal TKey get_Key();
    [CompilerGeneratedAttribute]
internal TValue get_Value();
    [CompilerGeneratedAttribute]
internal void set_Value(TValue value);
    [CompilerGeneratedAttribute]
internal DateTime get_ExpirationTime();
    [CompilerGeneratedAttribute]
internal void set_ExpirationTime(DateTime value);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.IdentityModel.Tokens.MessageDetail : object {
    private string _message;
    [CompilerGeneratedAttribute]
private string <FormatString>k__BackingField;
    [CompilerGeneratedAttribute]
private Object[] <Parameters>k__BackingField;
    public string Message { get; }
    private string FormatString { get; }
    private Object[] Parameters { get; }
    public MessageDetail(string formatString, Object[] parameters);
    public string get_Message();
    [CompilerGeneratedAttribute]
private string get_FormatString();
    [CompilerGeneratedAttribute]
private Object[] get_Parameters();
}
public enum Microsoft.IdentityModel.Tokens.PrivateKeyStatus : Enum {
    public int value__;
    public static PrivateKeyStatus Exists;
    public static PrivateKeyStatus DoesNotExist;
    public static PrivateKeyStatus Unknown;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.ReplayValidationResult : ValidationResult {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <ExpirationTime>k__BackingField;
    public Exception Exception { get; }
    public Nullable`1<DateTime> ExpirationTime { get; }
    public ReplayValidationResult(Nullable`1<DateTime> expirationTime);
    [NullableContextAttribute("1")]
public ReplayValidationResult(Nullable`1<DateTime> expirationTime, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_ExpirationTime();
}
internal class Microsoft.IdentityModel.Tokens.ResolveTokenDecryptionKeyDelegate : MulticastDelegate {
    public ResolveTokenDecryptionKeyDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual IList`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual IList`1<SecurityKey> EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.RSACryptoServiceProviderProxy : RSA {
    private static int PROV_RSA_AES;
    private static int PROV_RSA_FULL;
    private static int PROV_RSA_SCHANNEL;
    private bool _disposed;
    private bool _disposeRsa;
    private RSACryptoServiceProvider _rsa;
    public string SignatureAlgorithm { get; }
    public string KeyExchangeAlgorithm { get; }
    public RSACryptoServiceProviderProxy(RSACryptoServiceProvider rsa);
    public virtual string get_SignatureAlgorithm();
    public virtual string get_KeyExchangeAlgorithm();
    public Byte[] Decrypt(Byte[] input, bool fOAEP);
    public virtual Byte[] DecryptValue(Byte[] input);
    public Byte[] Encrypt(Byte[] input, bool fOAEP);
    public virtual Byte[] EncryptValue(Byte[] input);
    public Byte[] SignData(Byte[] input, object hash);
    internal Byte[] SignData(Byte[] input, int offset, int length, object hash);
    public bool VerifyData(Byte[] input, object hash, Byte[] signature);
    public bool VerifyDataWithLength(Byte[] input, int offset, int length, object hash, HashAlgorithmName hashAlgorithmName, Byte[] signature);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportParameters(RSAParameters parameters);
    protected virtual void Dispose(bool disposing);
}
public class Microsoft.IdentityModel.Tokens.RsaKeyWrapProvider : KeyWrapProvider {
    private Lazy`1<AsymmetricAdapter> _asymmetricAdapter;
    private bool _disposed;
    private bool _willUnwrap;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public RsaKeyWrapProvider(SecurityKey key, string algorithm, bool willUnwrap);
    internal AsymmetricAdapter CreateAsymmetricAdapter();
    [CompilerGeneratedAttribute]
public virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public virtual string get_Context();
    [CompilerGeneratedAttribute]
public virtual void set_Context(string value);
    [CompilerGeneratedAttribute]
public virtual SecurityKey get_Key();
    protected virtual void Dispose(bool disposing);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    public virtual Byte[] UnwrapKey(Byte[] keyBytes);
    public virtual Byte[] WrapKey(Byte[] keyBytes);
}
public class Microsoft.IdentityModel.Tokens.RsaSecurityKey : AsymmetricSecurityKey {
    private Nullable`1<bool> _hasPrivateKey;
    private bool _foundPrivateKeyDetermined;
    private PrivateKeyStatus _foundPrivateKey;
    private static string _className;
    [CompilerGeneratedAttribute]
private RSAParameters <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private RSA <Rsa>k__BackingField;
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use FoundPrivateKey instead.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public int KeySize { get; }
    public RSAParameters Parameters { get; private set; }
    public RSA Rsa { get; private set; }
    internal RsaSecurityKey(JsonWebKey webKey);
    public RsaSecurityKey(RSAParameters rsaParameters);
    public RsaSecurityKey(RSA rsa);
    internal void IntializeWithRsaParameters(RSAParameters rsaParameters);
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    public virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public RSAParameters get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(RSAParameters value);
    [CompilerGeneratedAttribute]
public RSA get_Rsa();
    [CompilerGeneratedAttribute]
private void set_Rsa(RSA value);
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
}
internal class Microsoft.IdentityModel.Tokens.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal abstract class Microsoft.IdentityModel.Tokens.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.IdentityModel.Tokens.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
public static class Microsoft.IdentityModel.Tokens.SecurityAlgorithms : object {
    public static string Aes128Encryption;
    public static string Aes192Encryption;
    public static string Aes256Encryption;
    public static string DesEncryption;
    public static string Aes128KeyWrap;
    public static string Aes192KeyWrap;
    public static string Aes256KeyWrap;
    public static string RsaV15KeyWrap;
    public static string Ripemd160Digest;
    public static string RsaOaepKeyWrap;
    public static string Aes128KW;
    public static string Aes192KW;
    public static string Aes256KW;
    public static string RsaPKCS1;
    public static string RsaOAEP;
    public static string ExclusiveC14n;
    public static string ExclusiveC14nWithComments;
    public static string EnvelopedSignature;
    public static string Sha256Digest;
    public static string Sha384Digest;
    public static string Sha512Digest;
    public static string Sha256;
    public static string Sha384;
    public static string Sha512;
    public static string EcdsaSha256Signature;
    public static string EcdsaSha384Signature;
    public static string EcdsaSha512Signature;
    public static string HmacSha256Signature;
    public static string HmacSha384Signature;
    public static string HmacSha512Signature;
    public static string RsaSha256Signature;
    public static string RsaSha384Signature;
    public static string RsaSha512Signature;
    public static string RsaSsaPssSha256Signature;
    public static string RsaSsaPssSha384Signature;
    public static string RsaSsaPssSha512Signature;
    public static string EcdsaSha256;
    public static string EcdsaSha384;
    public static string EcdsaSha512;
    public static string HmacSha256;
    public static string HmacSha384;
    public static string HmacSha512;
    public static string None;
    public static string RsaSha256;
    public static string RsaSha384;
    public static string RsaSha512;
    public static string RsaSsaPssSha256;
    public static string RsaSsaPssSha384;
    public static string RsaSsaPssSha512;
    public static string Aes128CbcHmacSha256;
    public static string Aes192CbcHmacSha384;
    public static string Aes256CbcHmacSha512;
    public static string Aes128Gcm;
    public static string Aes192Gcm;
    public static string Aes256Gcm;
    internal static string DefaultAsymmetricKeyWrapAlgorithm;
    internal static string DefaultSymmetricEncryptionAlgorithm;
    public static string EcdhEsA128kw;
    public static string EcdhEsA192kw;
    public static string EcdhEsA256kw;
    public static string EcdhEs;
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityKey : object {
    private CryptoProviderFactory _cryptoProviderFactory;
    private object _internalIdLock;
    private string _internalId;
    [CompilerGeneratedAttribute]
private string <KeyId>k__BackingField;
    [JsonIgnoreAttribute]
internal string InternalId { get; }
    public int KeySize { get; }
    [JsonIgnoreAttribute]
public string KeyId { get; public set; }
    [JsonIgnoreAttribute]
public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    internal SecurityKey(SecurityKey key);
    internal virtual string get_InternalId();
    public abstract virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public virtual string get_KeyId();
    [CompilerGeneratedAttribute]
public virtual void set_KeyId(string value);
    public CryptoProviderFactory get_CryptoProviderFactory();
    public void set_CryptoProviderFactory(CryptoProviderFactory value);
    public virtual string ToString();
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
    public virtual bool IsSupportedAlgorithm(string algorithm);
}
public class Microsoft.IdentityModel.Tokens.SecurityKeyIdentifierClause : object {
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityToken : object {
    public string Id { get; }
    public string Issuer { get; }
    public SecurityKey SecurityKey { get; }
    public SecurityKey SigningKey { get; public set; }
    public DateTime ValidFrom { get; }
    public DateTime ValidTo { get; }
    internal virtual IEnumerable`1<Claim> CreateClaims(string issuer);
    public virtual string UnsafeToString();
    public abstract virtual string get_Id();
    public abstract virtual string get_Issuer();
    public abstract virtual SecurityKey get_SecurityKey();
    public abstract virtual SecurityKey get_SigningKey();
    public abstract virtual void set_SigningKey(SecurityKey value);
    public abstract virtual DateTime get_ValidFrom();
    public abstract virtual DateTime get_ValidTo();
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenArgumentException : ArgumentException {
    public SecurityTokenArgumentException(string message);
    public SecurityTokenArgumentException(string message, Exception innerException);
    protected SecurityTokenArgumentException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenCompressionFailedException : SecurityTokenException {
    public SecurityTokenCompressionFailedException(string message);
    public SecurityTokenCompressionFailedException(string message, Exception inner);
    protected SecurityTokenCompressionFailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDecompressionFailedException : SecurityTokenException {
    public SecurityTokenDecompressionFailedException(string message);
    public SecurityTokenDecompressionFailedException(string message, Exception inner);
    protected SecurityTokenDecompressionFailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDecryptionFailedException : SecurityTokenException {
    public SecurityTokenDecryptionFailedException(string message);
    public SecurityTokenDecryptionFailedException(string message, Exception innerException);
    protected SecurityTokenDecryptionFailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenDescriptor : object {
    private List`1<string> _audiences;
    [CompilerGeneratedAttribute]
private string <Audience>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CompressionAlgorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private EncryptingCredentials <EncryptingCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <IssuedAt>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <Claims>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalHeaderClaims>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <AdditionalInnerHeaderClaims>k__BackingField;
    [CompilerGeneratedAttribute]
private SigningCredentials <SigningCredentials>k__BackingField;
    [CompilerGeneratedAttribute]
private ClaimsIdentity <Subject>k__BackingField;
    public string Audience { get; public set; }
    public IList`1<string> Audiences { get; }
    public string CompressionAlgorithm { get; public set; }
    public EncryptingCredentials EncryptingCredentials { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public string Issuer { get; public set; }
    public Nullable`1<DateTime> IssuedAt { get; public set; }
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public string TokenType { get; public set; }
    public IDictionary`2<string, object> Claims { get; public set; }
    public IDictionary`2<string, object> AdditionalHeaderClaims { get; public set; }
    public IDictionary`2<string, object> AdditionalInnerHeaderClaims { get; public set; }
    public SigningCredentials SigningCredentials { get; public set; }
    public ClaimsIdentity Subject { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Audience();
    [CompilerGeneratedAttribute]
public void set_Audience(string value);
    public IList`1<string> get_Audiences();
    [CompilerGeneratedAttribute]
public string get_CompressionAlgorithm();
    [CompilerGeneratedAttribute]
public void set_CompressionAlgorithm(string value);
    [CompilerGeneratedAttribute]
public EncryptingCredentials get_EncryptingCredentials();
    [CompilerGeneratedAttribute]
public void set_EncryptingCredentials(EncryptingCredentials value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
public void set_Issuer(string value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_IssuedAt();
    [CompilerGeneratedAttribute]
public void set_IssuedAt(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_Claims();
    [CompilerGeneratedAttribute]
public void set_Claims(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_AdditionalHeaderClaims();
    [CompilerGeneratedAttribute]
public void set_AdditionalHeaderClaims(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_AdditionalInnerHeaderClaims();
    [CompilerGeneratedAttribute]
public void set_AdditionalInnerHeaderClaims(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public SigningCredentials get_SigningCredentials();
    [CompilerGeneratedAttribute]
public void set_SigningCredentials(SigningCredentials value);
    [CompilerGeneratedAttribute]
public ClaimsIdentity get_Subject();
    [CompilerGeneratedAttribute]
public void set_Subject(ClaimsIdentity value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenEncryptionFailedException : SecurityTokenException {
    public SecurityTokenEncryptionFailedException(string message);
    public SecurityTokenEncryptionFailedException(string message, Exception innerException);
    protected SecurityTokenEncryptionFailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenEncryptionKeyNotFoundException : SecurityTokenDecryptionFailedException {
    public SecurityTokenEncryptionKeyNotFoundException(string message);
    public SecurityTokenEncryptionKeyNotFoundException(string message, Exception innerException);
    protected SecurityTokenEncryptionKeyNotFoundException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenException : Exception {
    private string _stackTrace;
    [CompilerGeneratedAttribute]
private ExceptionDetail <ExceptionDetail>k__BackingField;
    public string StackTrace { get; }
    public string Source { get; public set; }
    internal ExceptionDetail ExceptionDetail { get; internal set; }
    public SecurityTokenException(string message);
    public SecurityTokenException(string message, Exception innerException);
    protected SecurityTokenException(SerializationInfo info, StreamingContext context);
    public virtual string get_StackTrace();
    public virtual string get_Source();
    public virtual void set_Source(string value);
    [CompilerGeneratedAttribute]
internal ExceptionDetail get_ExceptionDetail();
    [CompilerGeneratedAttribute]
internal void set_ExceptionDetail(ExceptionDetail value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenExpiredException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _ExpiresKey;
    [CompilerGeneratedAttribute]
private DateTime <Expires>k__BackingField;
    public DateTime Expires { get; public set; }
    public SecurityTokenExpiredException(string message);
    public SecurityTokenExpiredException(string message, Exception inner);
    protected SecurityTokenExpiredException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public DateTime get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(DateTime value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.IdentityModel.Tokens.SecurityTokenHandler : TokenHandler {
    public bool CanValidateToken { get; }
    public bool CanWriteToken { get; }
    public Type TokenType { get; }
    public virtual SecurityKeyIdentifierClause CreateSecurityTokenReference(SecurityToken token, bool attached);
    public virtual SecurityToken CreateToken(SecurityTokenDescriptor tokenDescriptor);
    public virtual bool get_CanValidateToken();
    public virtual bool get_CanWriteToken();
    public abstract virtual Type get_TokenType();
    public virtual bool CanReadToken(XmlReader reader);
    public virtual bool CanReadToken(string tokenString);
    public virtual SecurityToken ReadToken(XmlReader reader);
    public virtual string WriteToken(SecurityToken token);
    public abstract virtual void WriteToken(XmlWriter writer, SecurityToken token);
    public abstract virtual SecurityToken ReadToken(XmlReader reader, TokenValidationParameters validationParameters);
    public virtual ClaimsPrincipal ValidateToken(string securityToken, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
    public virtual ClaimsPrincipal ValidateToken(XmlReader reader, TokenValidationParameters validationParameters, SecurityToken& validatedToken);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidAlgorithmException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _InvalidAlgorithmKey;
    [CompilerGeneratedAttribute]
private string <InvalidAlgorithm>k__BackingField;
    public string InvalidAlgorithm { get; public set; }
    public SecurityTokenInvalidAlgorithmException(string message);
    public SecurityTokenInvalidAlgorithmException(string message, Exception innerException);
    protected SecurityTokenInvalidAlgorithmException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_InvalidAlgorithm();
    [CompilerGeneratedAttribute]
public void set_InvalidAlgorithm(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidAudienceException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _InvalidAudienceKey;
    [CompilerGeneratedAttribute]
private string <InvalidAudience>k__BackingField;
    public string InvalidAudience { get; public set; }
    public SecurityTokenInvalidAudienceException(string message);
    public SecurityTokenInvalidAudienceException(string message, Exception innerException);
    protected SecurityTokenInvalidAudienceException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_InvalidAudience();
    [CompilerGeneratedAttribute]
public void set_InvalidAudience(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidIssuerException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _InvalidIssuerKey;
    [CompilerGeneratedAttribute]
private string <InvalidIssuer>k__BackingField;
    public string InvalidIssuer { get; public set; }
    public SecurityTokenInvalidIssuerException(string message);
    public SecurityTokenInvalidIssuerException(string message, Exception innerException);
    protected SecurityTokenInvalidIssuerException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_InvalidIssuer();
    [CompilerGeneratedAttribute]
public void set_InvalidIssuer(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidLifetimeException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _NotBeforeKey;
    private static string _ExpiresKey;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <NotBefore>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<DateTime> <Expires>k__BackingField;
    public Nullable`1<DateTime> NotBefore { get; public set; }
    public Nullable`1<DateTime> Expires { get; public set; }
    public SecurityTokenInvalidLifetimeException(string message);
    public SecurityTokenInvalidLifetimeException(string message, Exception innerException);
    protected SecurityTokenInvalidLifetimeException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(Nullable`1<DateTime> value);
    [CompilerGeneratedAttribute]
public Nullable`1<DateTime> get_Expires();
    [CompilerGeneratedAttribute]
public void set_Expires(Nullable`1<DateTime> value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidSignatureException : SecurityTokenValidationException {
    public SecurityTokenInvalidSignatureException(string message);
    public SecurityTokenInvalidSignatureException(string message, Exception innerException);
    protected SecurityTokenInvalidSignatureException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidSigningKeyException : SecurityTokenValidationException {
    [CompilerGeneratedAttribute]
private SecurityKey <SigningKey>k__BackingField;
    public SecurityKey SigningKey { get; public set; }
    public SecurityTokenInvalidSigningKeyException(string message);
    public SecurityTokenInvalidSigningKeyException(string message, Exception inner);
    protected SecurityTokenInvalidSigningKeyException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public SecurityKey get_SigningKey();
    [CompilerGeneratedAttribute]
public void set_SigningKey(SecurityKey value);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenInvalidTypeException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _InvalidTypeKey;
    [CompilerGeneratedAttribute]
private string <InvalidType>k__BackingField;
    public string InvalidType { get; public set; }
    public SecurityTokenInvalidTypeException(string message);
    public SecurityTokenInvalidTypeException(string message, Exception innerException);
    protected SecurityTokenInvalidTypeException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public string get_InvalidType();
    [CompilerGeneratedAttribute]
public void set_InvalidType(string value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenKeyWrapException : SecurityTokenException {
    public SecurityTokenKeyWrapException(string message);
    public SecurityTokenKeyWrapException(string message, Exception innerException);
    protected SecurityTokenKeyWrapException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenMalformedException : SecurityTokenArgumentException {
    public SecurityTokenMalformedException(string message);
    public SecurityTokenMalformedException(string message, Exception innerException);
    protected SecurityTokenMalformedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenNoExpirationException : SecurityTokenValidationException {
    public SecurityTokenNoExpirationException(string message);
    public SecurityTokenNoExpirationException(string message, Exception innerException);
    protected SecurityTokenNoExpirationException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenNotYetValidException : SecurityTokenValidationException {
    private static string _Prefix;
    private static string _NotBeforeKey;
    [CompilerGeneratedAttribute]
private DateTime <NotBefore>k__BackingField;
    public DateTime NotBefore { get; public set; }
    public SecurityTokenNotYetValidException(string message);
    public SecurityTokenNotYetValidException(string message, Exception inner);
    protected SecurityTokenNotYetValidException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public DateTime get_NotBefore();
    [CompilerGeneratedAttribute]
public void set_NotBefore(DateTime value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenReplayAddFailedException : SecurityTokenValidationException {
    public SecurityTokenReplayAddFailedException(string message);
    public SecurityTokenReplayAddFailedException(string message, Exception innerException);
    protected SecurityTokenReplayAddFailedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenReplayDetectedException : SecurityTokenValidationException {
    public SecurityTokenReplayDetectedException(string message);
    public SecurityTokenReplayDetectedException(string message, Exception inner);
    protected SecurityTokenReplayDetectedException(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenSignatureKeyNotFoundException : SecurityTokenInvalidSignatureException {
    public SecurityTokenSignatureKeyNotFoundException(string message);
    public SecurityTokenSignatureKeyNotFoundException(string message, Exception innerException);
    protected SecurityTokenSignatureKeyNotFoundException(SerializationInfo info, StreamingContext context);
}
[ObsoleteAttribute("This expception is no longer being thrown by Microsoft.IdentityModel and will be removed in the next major version see: https://aka.ms/SecurityTokenUnableToValidateException", "False")]
[EditorBrowsableAttribute("1")]
public class Microsoft.IdentityModel.Tokens.SecurityTokenUnableToValidateException : SecurityTokenInvalidSignatureException {
    private static string _Prefix;
    private static string _ValidationFailureKey;
    [CompilerGeneratedAttribute]
private ValidationFailure <ValidationFailure>k__BackingField;
    public ValidationFailure ValidationFailure { get; public set; }
    public SecurityTokenUnableToValidateException(ValidationFailure validationFailure, string message);
    public SecurityTokenUnableToValidateException(string message);
    public SecurityTokenUnableToValidateException(string message, Exception innerException);
    protected SecurityTokenUnableToValidateException(SerializationInfo info, StreamingContext context);
    [CompilerGeneratedAttribute]
public ValidationFailure get_ValidationFailure();
    [CompilerGeneratedAttribute]
public void set_ValidationFailure(ValidationFailure value);
    public virtual void GetObjectData(SerializationInfo info, StreamingContext context);
}
public class Microsoft.IdentityModel.Tokens.SecurityTokenValidationException : SecurityTokenException {
    public SecurityTokenValidationException(string message);
    public SecurityTokenValidationException(string message, Exception innerException);
    protected SecurityTokenValidationException(SerializationInfo info, StreamingContext context);
}
public abstract class Microsoft.IdentityModel.Tokens.SignatureProvider : object {
    private int _referenceCount;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderCache <CryptoProviderCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsCached>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <WillCreateSignatures>k__BackingField;
    public string Algorithm { get; private set; }
    public string Context { get; public set; }
    public CryptoProviderCache CryptoProviderCache { get; public set; }
    internal bool IsCached { get; internal set; }
    public SecurityKey Key { get; private set; }
    internal int ObjectPoolSize { get; }
    internal int RefCount { get; }
    public bool WillCreateSignatures { get; protected set; }
    protected SignatureProvider(SecurityKey key, string algorithm);
    internal int AddRef();
    [CompilerGeneratedAttribute]
public string get_Algorithm();
    [CompilerGeneratedAttribute]
private void set_Algorithm(string value);
    [CompilerGeneratedAttribute]
public string get_Context();
    [CompilerGeneratedAttribute]
public void set_Context(string value);
    [CompilerGeneratedAttribute]
public CryptoProviderCache get_CryptoProviderCache();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderCache(CryptoProviderCache value);
    public sealed virtual void Dispose();
    protected abstract virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
internal bool get_IsCached();
    [CompilerGeneratedAttribute]
internal void set_IsCached(bool value);
    [CompilerGeneratedAttribute]
public SecurityKey get_Key();
    [CompilerGeneratedAttribute]
private void set_Key(SecurityKey value);
    internal virtual int get_ObjectPoolSize();
    internal int get_RefCount();
    internal int Release();
    public abstract virtual Byte[] Sign(Byte[] input);
    public virtual Byte[] Sign(Byte[] input, int offset, int count);
    public abstract virtual bool Verify(Byte[] input, Byte[] signature);
    public virtual bool Verify(Byte[] input, int inputOffset, int inputLength, Byte[] signature, int signatureOffset, int signatureLength);
    [CompilerGeneratedAttribute]
public bool get_WillCreateSignatures();
    [CompilerGeneratedAttribute]
protected void set_WillCreateSignatures(bool value);
}
public class Microsoft.IdentityModel.Tokens.SignatureValidator : MulticastDelegate {
    public SignatureValidator(object object, IntPtr method);
    public virtual SecurityToken Invoke(string token, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.SignatureValidatorDelegate : MulticastDelegate {
    public SignatureValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual SignatureValidationResult Invoke(SecurityToken token, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(SecurityToken token, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext, AsyncCallback callback, object object);
    public virtual SignatureValidationResult EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.SignatureValidatorUsingConfiguration : MulticastDelegate {
    public SignatureValidatorUsingConfiguration(object object, IntPtr method);
    public virtual SecurityToken Invoke(string token, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    public virtual IAsyncResult BeginInvoke(string token, TokenValidationParameters validationParameters, BaseConfiguration configuration, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.SignDelegate : MulticastDelegate {
    public SignDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] bytes);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.SigningCredentials : object {
    private string _algorithm;
    private string _digest;
    private SecurityKey _key;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    public string Algorithm { get; private set; }
    public string Digest { get; private set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public SecurityKey Key { get; private set; }
    public string Kid { get; }
    protected SigningCredentials(X509Certificate2 certificate);
    protected SigningCredentials(X509Certificate2 certificate, string algorithm);
    public SigningCredentials(SecurityKey key, string algorithm);
    public SigningCredentials(SecurityKey key, string algorithm, string digest);
    public string get_Algorithm();
    private void set_Algorithm(string value);
    public string get_Digest();
    private void set_Digest(string value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    public SecurityKey get_Key();
    private void set_Key(SecurityKey value);
    public string get_Kid();
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.SigningKeyValidationResult : ValidationResult {
    private Exception _exception;
    [CompilerGeneratedAttribute]
private SecurityKey <SigningKey>k__BackingField;
    public Exception Exception { get; }
    public SecurityKey SigningKey { get; }
    public SigningKeyValidationResult(SecurityKey signingKey);
    [NullableContextAttribute("1")]
public SigningKeyValidationResult(SecurityKey signingKey, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public SecurityKey get_SigningKey();
}
internal class Microsoft.IdentityModel.Tokens.SignUsingOffsetDelegate : MulticastDelegate {
    public SignUsingOffsetDelegate(object object, IntPtr method);
    public virtual Byte[] Invoke(Byte[] bytes, int offset, int count);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, int offset, int count, AsyncCallback callback, object object);
    public virtual Byte[] EndInvoke(IAsyncResult result);
}
internal static class Microsoft.IdentityModel.Tokens.SupportedAlgorithms : object {
    private static int RsaMinKeySize;
    internal static ICollection`1<string> EcdsaSigningAlgorithms;
    internal static ICollection`1<string> HashAlgorithms;
    internal static ICollection`1<string> RsaEncryptionAlgorithms;
    internal static ICollection`1<string> RsaSigningAlgorithms;
    internal static ICollection`1<string> RsaPssSigningAlgorithms;
    internal static ICollection`1<string> SymmetricEncryptionAlgorithms;
    internal static ICollection`1<string> SymmetricKeyWrapAlgorithms;
    internal static ICollection`1<string> SymmetricSigningAlgorithms;
    internal static ICollection`1<string> EcdsaWrapAlgorithms;
    private static SupportedAlgorithms();
    internal static HashAlgorithmName GetHashAlgorithmName(string algorithm);
    internal static string GetDigestFromSignatureAlgorithm(string algorithm);
    public static bool IsSupportedAlgorithm(string algorithm, SecurityKey key);
    internal static bool IsSupportedEncryptionAlgorithm(string algorithm, SecurityKey key);
    internal static bool IsAesGcm(string algorithm);
    internal static bool IsAesCbc(string algorithm);
    private static bool IsSupportedEcdsaAlgorithm(string algorithm);
    internal static bool IsSupportedHashAlgorithm(string algorithm);
    internal static bool IsSupportedRsaKeyWrap(string algorithm, SecurityKey key);
    internal static bool IsSupportedSymmetricKeyWrap(string algorithm, SecurityKey key);
    internal static bool IsSupportedRsaAlgorithm(string algorithm, SecurityKey key);
    private static bool IsSupportedRsaPss(SecurityKey key);
    internal static bool IsSupportedSymmetricAlgorithm(string algorithm);
    internal static int GetMaxByteCount(string algorithm);
}
public class Microsoft.IdentityModel.Tokens.SymmetricKeyWrapProvider : KeyWrapProvider {
    private static Byte[] _defaultIV;
    private static int _blockSizeInBits;
    private static int _blockSizeInBytes;
    private static object _encryptorLock;
    private static object _decryptorLock;
    private Lazy`1<SymmetricAlgorithm> _symmetricAlgorithm;
    private ICryptoTransform _symmetricAlgorithmEncryptor;
    private ICryptoTransform _symmetricAlgorithmDecryptor;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private string <Algorithm>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Context>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <Key>k__BackingField;
    public string Algorithm { get; }
    public string Context { get; public set; }
    public SecurityKey Key { get; }
    public SymmetricKeyWrapProvider(SecurityKey key, string algorithm);
    private static SymmetricKeyWrapProvider();
    [CompilerGeneratedAttribute]
public virtual string get_Algorithm();
    [CompilerGeneratedAttribute]
public virtual string get_Context();
    [CompilerGeneratedAttribute]
public virtual void set_Context(string value);
    [CompilerGeneratedAttribute]
public virtual SecurityKey get_Key();
    private SymmetricAlgorithm CreateSymmetricAlgorithm();
    protected virtual void Dispose(bool disposing);
    private static Byte[] GetBytes(ulong i);
    protected virtual SymmetricAlgorithm GetSymmetricAlgorithm(SecurityKey key, string algorithm);
    protected virtual bool IsSupportedAlgorithm(SecurityKey key, string algorithm);
    public virtual Byte[] UnwrapKey(Byte[] keyBytes);
    private Byte[] UnwrapKeyPrivate(Byte[] inputBuffer, int inputOffset, int inputCount);
    private void ValidateKeySize(Byte[] key, string algorithm);
    public virtual Byte[] WrapKey(Byte[] keyBytes);
    private Byte[] WrapKeyPrivate(Byte[] inputBuffer, int inputOffset, int inputCount);
}
public class Microsoft.IdentityModel.Tokens.SymmetricSecurityKey : SecurityKey {
    private int _keySize;
    private Byte[] _key;
    public int KeySize { get; }
    public Byte[] Key { get; }
    internal SymmetricSecurityKey(JsonWebKey webKey);
    public SymmetricSecurityKey(Byte[] key);
    public virtual int get_KeySize();
    public virtual Byte[] get_Key();
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
}
public class Microsoft.IdentityModel.Tokens.SymmetricSignatureProvider : SignatureProvider {
    private bool _disposed;
    private DisposableObjectPool`1<KeyedHashAlgorithm> _keyedHashObjectPool;
    internal static Dictionary`2<string, int> ExpectedSignatureSizeInBytes;
    public static int DefaultMinimumSymmetricKeySizeInBits;
    private int _minimumSymmetricKeySizeInBits;
    public int MinimumSymmetricKeySizeInBits { get; public set; }
    internal int ObjectPoolSize { get; }
    public SymmetricSignatureProvider(SecurityKey key, string algorithm);
    public SymmetricSignatureProvider(SecurityKey key, string algorithm, bool willCreateSignatures);
    private static SymmetricSignatureProvider();
    public int get_MinimumSymmetricKeySizeInBits();
    public void set_MinimumSymmetricKeySizeInBits(int value);
    protected virtual Byte[] GetKeyBytes(SecurityKey key);
    protected virtual KeyedHashAlgorithm GetKeyedHashAlgorithm(Byte[] keyBytes, string algorithm);
    private KeyedHashAlgorithm CreateKeyedHashAlgorithm();
    internal virtual int get_ObjectPoolSize();
    protected virtual void ReleaseKeyedHashAlgorithm(KeyedHashAlgorithm keyedHashAlgorithm);
    public virtual Byte[] Sign(Byte[] input);
    public virtual Byte[] Sign(Byte[] input, int offset, int count);
    public virtual bool Verify(Byte[] input, Byte[] signature);
    public bool Verify(Byte[] input, Byte[] signature, int length);
    public virtual bool Verify(Byte[] input, int inputOffset, int inputLength, Byte[] signature, int signatureOffset, int signatureLength);
    internal bool Verify(Byte[] input, int inputOffset, int inputLength, Byte[] signature, int signatureOffset, int signatureLength, string algorithm);
    protected virtual void Dispose(bool disposing);
}
[ObsoleteAttribute("The 'TokenContext' property is obsolete. Please use 'CallContext' instead.")]
public class Microsoft.IdentityModel.Tokens.TokenContext : CallContext {
    public TokenContext(Guid activityId);
}
public class Microsoft.IdentityModel.Tokens.TokenDecryptionKeyResolver : MulticastDelegate {
    public TokenDecryptionKeyResolver(object object, IntPtr method);
    public virtual IEnumerable`1<SecurityKey> Invoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, SecurityToken securityToken, string kid, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual IEnumerable`1<SecurityKey> EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.TokenDecryptionResult : ValidationResult {
    private Exception _exception;
    private string _decryptedToken;
    [CompilerGeneratedAttribute]
private SecurityToken <SecurityToken>k__BackingField;
    public Exception Exception { get; }
    public SecurityToken SecurityToken { get; }
    [NullableContextAttribute("1")]
public TokenDecryptionResult(string decryptedToken, SecurityToken securityToken);
    [NullableContextAttribute("1")]
public TokenDecryptionResult(SecurityToken securityToken, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    [NullableContextAttribute("1")]
internal static TokenDecryptionResult NullParameterFailure(SecurityToken securityToken, string parameterName);
    [NullableContextAttribute("1")]
public string DecryptedToken();
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public SecurityToken get_SecurityToken();
}
public abstract class Microsoft.IdentityModel.Tokens.TokenHandler : object {
    private int _defaultTokenLifetimeInMinutes;
    private int _maximumTokenSizeInBytes;
    public static int DefaultTokenLifetimeInMinutes;
    [CompilerGeneratedAttribute]
private bool <SetDefaultTimesOnTokenCreation>k__BackingField;
    public int MaximumTokenSizeInBytes { get; public set; }
    [DefaultValueAttribute("True")]
public bool SetDefaultTimesOnTokenCreation { get; public set; }
    public int TokenLifetimeInMinutes { get; public set; }
    private static TokenHandler();
    public virtual int get_MaximumTokenSizeInBytes();
    public virtual void set_MaximumTokenSizeInBytes(int value);
    [CompilerGeneratedAttribute]
public bool get_SetDefaultTimesOnTokenCreation();
    [CompilerGeneratedAttribute]
public void set_SetDefaultTimesOnTokenCreation(bool value);
    public int get_TokenLifetimeInMinutes();
    public void set_TokenLifetimeInMinutes(int value);
    public virtual Task`1<TokenValidationResult> ValidateTokenAsync(string token, TokenValidationParameters validationParameters);
    public virtual Task`1<TokenValidationResult> ValidateTokenAsync(SecurityToken token, TokenValidationParameters validationParameters);
    public virtual SecurityToken ReadToken(string token);
    internal virtual ClaimsIdentity CreateClaimsIdentityInternal(SecurityToken securityToken, TokenValidationParameters tokenValidationParameters, string issuer);
    internal virtual ClaimsIdentity CreateClaimsIdentityInternal(SecurityToken securityToken, ValidationParameters validationParameters, string issuer);
}
public class Microsoft.IdentityModel.Tokens.TokenReader : MulticastDelegate {
    public TokenReader(object object, IntPtr method);
    public virtual SecurityToken Invoke(string token, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string token, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.TokenReadingResult : ValidationResult {
    private Exception _exception;
    private SecurityToken _securityToken;
    [CompilerGeneratedAttribute]
private string <TokenInput>k__BackingField;
    public Exception Exception { get; }
    public string TokenInput { get; }
    [NullableContextAttribute("1")]
public TokenReadingResult(SecurityToken securityToken, string tokenInput);
    [NullableContextAttribute("1")]
public TokenReadingResult(string tokenInput, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    [NullableContextAttribute("1")]
public SecurityToken SecurityToken();
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_TokenInput();
}
public class Microsoft.IdentityModel.Tokens.TokenReplayValidator : MulticastDelegate {
    public TokenReplayValidator(object object, IntPtr method);
    public virtual bool Invoke(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.TokenReplayValidatorDelegate : MulticastDelegate {
    public TokenReplayValidatorDelegate(object object, IntPtr method);
    public virtual ReplayValidationResult Invoke(Nullable`1<DateTime> expirationTime, string securityToken, ValidationParameters validationParameters, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(Nullable`1<DateTime> expirationTime, string securityToken, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual ReplayValidationResult EndInvoke(IAsyncResult result);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
internal class Microsoft.IdentityModel.Tokens.TokenTypeValidationResult : ValidationResult {
    private Exception _exception;
    [NullableAttribute("1")]
private static string TokenSource;
    [CompilerGeneratedAttribute]
private string <Type>k__BackingField;
    public Exception Exception { get; }
    public string Type { get; }
    public TokenTypeValidationResult(string type);
    [NullableContextAttribute("1")]
public TokenTypeValidationResult(string type, ValidationFailureType validationFailure, ExceptionDetail exceptionDetail);
    public virtual Exception get_Exception();
    [CompilerGeneratedAttribute]
public string get_Type();
}
internal class Microsoft.IdentityModel.Tokens.TokenUtilities : object {
    internal static string Json;
    internal static string JsonArray;
    internal static string JsonNull;
    internal static Dictionary`2<string, object> CreateDictionaryFromClaims(IEnumerable`1<Claim> claims);
    internal static Dictionary`2<string, object> CreateDictionaryFromClaims(IEnumerable`1<Claim> claims, SecurityTokenDescriptor tokenDescriptor, bool audienceSet, bool issuerSet);
    internal static object GetClaimValueUsingValueType(Claim claim);
    [IteratorStateMachineAttribute("Microsoft.IdentityModel.Tokens.TokenUtilities/<GetAllSigningKeys>d__6")]
internal static IEnumerable`1<SecurityKey> GetAllSigningKeys(BaseConfiguration configuration, TokenValidationParameters validationParameters);
    internal static IEnumerable`1<Claim> MergeClaims(IEnumerable`1<Claim> claims, IEnumerable`1<Claim> subjectClaims);
    internal static bool IsRecoverableException(Exception exception);
    internal static bool IsRecoverableExceptionType(ExceptionType exceptionType);
    internal static bool IsRecoverableConfiguration(string kid, BaseConfiguration currentConfiguration, BaseConfiguration lkgConfiguration, Exception currentException);
    internal static bool IsRecoverableConfigurationAndExceptionType(string kid, BaseConfiguration currentConfiguration, BaseConfiguration lkgConfiguration, ExceptionType currentExceptionType);
    private static ExceptionType ExceptionTypeForException(Exception exception);
}
public class Microsoft.IdentityModel.Tokens.TokenValidationParameters : object {
    private string _authenticationType;
    private TimeSpan _clockSkew;
    private string _nameClaimType;
    private string _roleClaimType;
    private Dictionary`2<string, object> _instancePropertyBag;
    public static string DefaultAuthenticationType;
    public static TimeSpan DefaultClockSkew;
    public static int DefaultMaximumTokenSizeInBytes;
    [CompilerGeneratedAttribute]
private TokenValidationParameters <ActorValidationParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private AlgorithmValidator <AlgorithmValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private AudienceValidator <AudienceValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseConfigurationManager <ConfigurationManager>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreTrailingSlashWhenValidatingAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTokenOnFailedValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyValidator <IssuerSigningKeyValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyValidatorUsingConfiguration <IssuerSigningKeyValidatorUsingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClone>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <IssuerSigningKey>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyResolver <IssuerSigningKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyResolverUsingConfiguration <IssuerSigningKeyResolverUsingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SecurityKey> <IssuerSigningKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerValidator <IssuerValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerValidatorAsync <IssuerValidatorAsync>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerValidatorUsingConfiguration <IssuerValidatorUsingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformBeforeSignatureValidation <TransformBeforeSignatureValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private LifetimeValidator <LifetimeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogTokenId>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogValidationExceptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <NameClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <PropertyBag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshBeforeValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireExpirationTime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RequireSignedTokens>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <RoleClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveSigninToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureValidator <SignatureValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private SignatureValidatorUsingConfiguration <SignatureValidatorUsingConfiguration>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <TokenDecryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenDecryptionKeyResolver <TokenDecryptionKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<SecurityKey> <TokenDecryptionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenReader <TokenReader>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenReplayCache <TokenReplayCache>k__BackingField;
    [CompilerGeneratedAttribute]
private TokenReplayValidator <TokenReplayValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryAllIssuerSigningKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeValidator <TypeValidator>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateActor>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateIssuer>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateWithLKG>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateIssuerSigningKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateLifetime>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateSignatureLast>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateTokenReplay>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidAlgorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidAudiences>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ValidIssuer>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidIssuers>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<string> <ValidTypes>k__BackingField;
    public TokenValidationParameters ActorValidationParameters { get; public set; }
    public AlgorithmValidator AlgorithmValidator { get; public set; }
    public AudienceValidator AudienceValidator { get; public set; }
    public string AuthenticationType { get; public set; }
    [DefaultValueAttribute("300")]
public TimeSpan ClockSkew { get; public set; }
    public BaseConfigurationManager ConfigurationManager { get; public set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public string DebugId { get; public set; }
    [DefaultValueAttribute("True")]
public bool IgnoreTrailingSlashWhenValidatingAudience { get; public set; }
    public bool IncludeTokenOnFailedValidation { get; public set; }
    public IssuerSigningKeyValidator IssuerSigningKeyValidator { get; public set; }
    public IssuerSigningKeyValidatorUsingConfiguration IssuerSigningKeyValidatorUsingConfiguration { get; public set; }
    public IDictionary`2<string, object> InstancePropertyBag { get; }
    public bool IsClone { get; protected set; }
    public SecurityKey IssuerSigningKey { get; public set; }
    public IssuerSigningKeyResolver IssuerSigningKeyResolver { get; public set; }
    public IssuerSigningKeyResolverUsingConfiguration IssuerSigningKeyResolverUsingConfiguration { get; public set; }
    public IEnumerable`1<SecurityKey> IssuerSigningKeys { get; public set; }
    public IssuerValidator IssuerValidator { get; public set; }
    internal IssuerValidatorAsync IssuerValidatorAsync { get; internal set; }
    public IssuerValidatorUsingConfiguration IssuerValidatorUsingConfiguration { get; public set; }
    public TransformBeforeSignatureValidation TransformBeforeSignatureValidation { get; public set; }
    public LifetimeValidator LifetimeValidator { get; public set; }
    [DefaultValueAttribute("True")]
public bool LogTokenId { get; public set; }
    [DefaultValueAttribute("True")]
public bool LogValidationExceptions { get; public set; }
    public string NameClaimType { get; public set; }
    public Func`3<SecurityToken, string, string> NameClaimTypeRetriever { get; public set; }
    public IDictionary`2<string, object> PropertyBag { get; public set; }
    [DefaultValueAttribute("False")]
public bool RefreshBeforeValidation { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireAudience { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireExpirationTime { get; public set; }
    [DefaultValueAttribute("True")]
public bool RequireSignedTokens { get; public set; }
    public string RoleClaimType { get; public set; }
    public Func`3<SecurityToken, string, string> RoleClaimTypeRetriever { get; public set; }
    [DefaultValueAttribute("False")]
public bool SaveSigninToken { get; public set; }
    public SignatureValidator SignatureValidator { get; public set; }
    public SignatureValidatorUsingConfiguration SignatureValidatorUsingConfiguration { get; public set; }
    public SecurityKey TokenDecryptionKey { get; public set; }
    public TokenDecryptionKeyResolver TokenDecryptionKeyResolver { get; public set; }
    public IEnumerable`1<SecurityKey> TokenDecryptionKeys { get; public set; }
    public TokenReader TokenReader { get; public set; }
    public ITokenReplayCache TokenReplayCache { get; public set; }
    public TokenReplayValidator TokenReplayValidator { get; public set; }
    [DefaultValueAttribute("True")]
public bool TryAllIssuerSigningKeys { get; public set; }
    public TypeValidator TypeValidator { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateActor { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateAudience { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateIssuer { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateWithLKG { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateIssuerSigningKey { get; public set; }
    [DefaultValueAttribute("True")]
public bool ValidateLifetime { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateSignatureLast { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateTokenReplay { get; public set; }
    public IEnumerable`1<string> ValidAlgorithms { get; public set; }
    public string ValidAudience { get; public set; }
    public IEnumerable`1<string> ValidAudiences { get; public set; }
    public string ValidIssuer { get; public set; }
    public IEnumerable`1<string> ValidIssuers { get; public set; }
    public IEnumerable`1<string> ValidTypes { get; public set; }
    protected TokenValidationParameters(TokenValidationParameters other);
    private static TokenValidationParameters();
    [CompilerGeneratedAttribute]
public TokenValidationParameters get_ActorValidationParameters();
    [CompilerGeneratedAttribute]
public void set_ActorValidationParameters(TokenValidationParameters value);
    [CompilerGeneratedAttribute]
public AlgorithmValidator get_AlgorithmValidator();
    [CompilerGeneratedAttribute]
public void set_AlgorithmValidator(AlgorithmValidator value);
    [CompilerGeneratedAttribute]
public AudienceValidator get_AudienceValidator();
    [CompilerGeneratedAttribute]
public void set_AudienceValidator(AudienceValidator value);
    public string get_AuthenticationType();
    public void set_AuthenticationType(string value);
    public TimeSpan get_ClockSkew();
    public void set_ClockSkew(TimeSpan value);
    public virtual TokenValidationParameters Clone();
    public virtual ClaimsIdentity CreateClaimsIdentity(SecurityToken securityToken, string issuer);
    [CompilerGeneratedAttribute]
public BaseConfigurationManager get_ConfigurationManager();
    [CompilerGeneratedAttribute]
public void set_ConfigurationManager(BaseConfigurationManager value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public string get_DebugId();
    [CompilerGeneratedAttribute]
public void set_DebugId(string value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreTrailingSlashWhenValidatingAudience();
    [CompilerGeneratedAttribute]
public void set_IgnoreTrailingSlashWhenValidatingAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTokenOnFailedValidation();
    [CompilerGeneratedAttribute]
public void set_IncludeTokenOnFailedValidation(bool value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyValidator get_IssuerSigningKeyValidator();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyValidator(IssuerSigningKeyValidator value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyValidatorUsingConfiguration get_IssuerSigningKeyValidatorUsingConfiguration();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyValidatorUsingConfiguration(IssuerSigningKeyValidatorUsingConfiguration value);
    public IDictionary`2<string, object> get_InstancePropertyBag();
    [CompilerGeneratedAttribute]
public bool get_IsClone();
    [CompilerGeneratedAttribute]
protected void set_IsClone(bool value);
    [CompilerGeneratedAttribute]
public SecurityKey get_IssuerSigningKey();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyResolver get_IssuerSigningKeyResolver();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyResolver(IssuerSigningKeyResolver value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyResolverUsingConfiguration get_IssuerSigningKeyResolverUsingConfiguration();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyResolverUsingConfiguration(IssuerSigningKeyResolverUsingConfiguration value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SecurityKey> get_IssuerSigningKeys();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeys(IEnumerable`1<SecurityKey> value);
    [CompilerGeneratedAttribute]
public IssuerValidator get_IssuerValidator();
    [CompilerGeneratedAttribute]
public void set_IssuerValidator(IssuerValidator value);
    [CompilerGeneratedAttribute]
internal IssuerValidatorAsync get_IssuerValidatorAsync();
    [CompilerGeneratedAttribute]
internal void set_IssuerValidatorAsync(IssuerValidatorAsync value);
    [CompilerGeneratedAttribute]
public IssuerValidatorUsingConfiguration get_IssuerValidatorUsingConfiguration();
    [CompilerGeneratedAttribute]
public void set_IssuerValidatorUsingConfiguration(IssuerValidatorUsingConfiguration value);
    [CompilerGeneratedAttribute]
public TransformBeforeSignatureValidation get_TransformBeforeSignatureValidation();
    [CompilerGeneratedAttribute]
public void set_TransformBeforeSignatureValidation(TransformBeforeSignatureValidation value);
    [CompilerGeneratedAttribute]
public LifetimeValidator get_LifetimeValidator();
    [CompilerGeneratedAttribute]
public void set_LifetimeValidator(LifetimeValidator value);
    [CompilerGeneratedAttribute]
public bool get_LogTokenId();
    [CompilerGeneratedAttribute]
public void set_LogTokenId(bool value);
    [CompilerGeneratedAttribute]
public bool get_LogValidationExceptions();
    [CompilerGeneratedAttribute]
public void set_LogValidationExceptions(bool value);
    public string get_NameClaimType();
    public void set_NameClaimType(string value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_NameClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_NameClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_PropertyBag();
    [CompilerGeneratedAttribute]
public void set_PropertyBag(IDictionary`2<string, object> value);
    [CompilerGeneratedAttribute]
public bool get_RefreshBeforeValidation();
    [CompilerGeneratedAttribute]
public void set_RefreshBeforeValidation(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireAudience();
    [CompilerGeneratedAttribute]
public void set_RequireAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireExpirationTime();
    [CompilerGeneratedAttribute]
public void set_RequireExpirationTime(bool value);
    [CompilerGeneratedAttribute]
public bool get_RequireSignedTokens();
    [CompilerGeneratedAttribute]
public void set_RequireSignedTokens(bool value);
    public string get_RoleClaimType();
    public void set_RoleClaimType(string value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_RoleClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_RoleClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_SaveSigninToken();
    [CompilerGeneratedAttribute]
public void set_SaveSigninToken(bool value);
    [CompilerGeneratedAttribute]
public SignatureValidator get_SignatureValidator();
    [CompilerGeneratedAttribute]
public void set_SignatureValidator(SignatureValidator value);
    [CompilerGeneratedAttribute]
public SignatureValidatorUsingConfiguration get_SignatureValidatorUsingConfiguration();
    [CompilerGeneratedAttribute]
public void set_SignatureValidatorUsingConfiguration(SignatureValidatorUsingConfiguration value);
    [CompilerGeneratedAttribute]
public SecurityKey get_TokenDecryptionKey();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public TokenDecryptionKeyResolver get_TokenDecryptionKeyResolver();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKeyResolver(TokenDecryptionKeyResolver value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<SecurityKey> get_TokenDecryptionKeys();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKeys(IEnumerable`1<SecurityKey> value);
    [CompilerGeneratedAttribute]
public TokenReader get_TokenReader();
    [CompilerGeneratedAttribute]
public void set_TokenReader(TokenReader value);
    [CompilerGeneratedAttribute]
public ITokenReplayCache get_TokenReplayCache();
    [CompilerGeneratedAttribute]
public void set_TokenReplayCache(ITokenReplayCache value);
    [CompilerGeneratedAttribute]
public TokenReplayValidator get_TokenReplayValidator();
    [CompilerGeneratedAttribute]
public void set_TokenReplayValidator(TokenReplayValidator value);
    [CompilerGeneratedAttribute]
public bool get_TryAllIssuerSigningKeys();
    [CompilerGeneratedAttribute]
public void set_TryAllIssuerSigningKeys(bool value);
    [CompilerGeneratedAttribute]
public TypeValidator get_TypeValidator();
    [CompilerGeneratedAttribute]
public void set_TypeValidator(TypeValidator value);
    [CompilerGeneratedAttribute]
public bool get_ValidateActor();
    [CompilerGeneratedAttribute]
public void set_ValidateActor(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateAudience();
    [CompilerGeneratedAttribute]
public void set_ValidateAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateIssuer();
    [CompilerGeneratedAttribute]
public void set_ValidateIssuer(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateWithLKG();
    [CompilerGeneratedAttribute]
public void set_ValidateWithLKG(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateIssuerSigningKey();
    [CompilerGeneratedAttribute]
public void set_ValidateIssuerSigningKey(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateLifetime();
    [CompilerGeneratedAttribute]
public void set_ValidateLifetime(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateSignatureLast();
    [CompilerGeneratedAttribute]
public void set_ValidateSignatureLast(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateTokenReplay();
    [CompilerGeneratedAttribute]
public void set_ValidateTokenReplay(bool value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidAlgorithms();
    [CompilerGeneratedAttribute]
public void set_ValidAlgorithms(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ValidAudience();
    [CompilerGeneratedAttribute]
public void set_ValidAudience(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidAudiences();
    [CompilerGeneratedAttribute]
public void set_ValidAudiences(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public string get_ValidIssuer();
    [CompilerGeneratedAttribute]
public void set_ValidIssuer(string value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidIssuers();
    [CompilerGeneratedAttribute]
public void set_ValidIssuers(IEnumerable`1<string> value);
    [CompilerGeneratedAttribute]
public IEnumerable`1<string> get_ValidTypes();
    [CompilerGeneratedAttribute]
public void set_ValidTypes(IEnumerable`1<string> value);
}
public class Microsoft.IdentityModel.Tokens.TokenValidationResult : object {
    private TokenValidationParameters _tokenValidationParameters;
    private ValidationParameters _validationParameters;
    private TokenHandler _tokenHandler;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _claimsIdentityInitialized;
    private object _claimsIdentitySyncObj;
    private ClaimsIdentity _claimsIdentity;
    private Dictionary`2<string, object> _claims;
    private Dictionary`2<string, object> _propertyBag;
    private List`1<ValidationResult> _validationResults;
    private Exception _exception;
    private bool _isValid;
    [CompilerGeneratedAttribute]
private bool <HasValidOrExceptionWasRead>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Issuer>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityToken <SecurityToken>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityToken <TokenOnFailedValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private CallContext <TokenContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TokenType>k__BackingField;
    public IDictionary`2<string, object> Claims { get; }
    public ClaimsIdentity ClaimsIdentity { get; public set; }
    internal ClaimsIdentity ClaimsIdentityNoLocking { get; internal set; }
    private object ClaimsIdentitySyncObj { get; }
    public Exception Exception { get; public set; }
    private ExceptionDetail ExceptionDetail { get; }
    internal bool HasValidOrExceptionWasRead { get; internal set; }
    public string Issuer { get; public set; }
    public bool IsValid { get; public set; }
    public IDictionary`2<string, object> PropertyBag { get; }
    public SecurityToken SecurityToken { get; public set; }
    public SecurityToken TokenOnFailedValidation { get; internal set; }
    public CallContext TokenContext { get; public set; }
    public string TokenType { get; public set; }
    internal IReadOnlyList`1<ValidationResult> ValidationResults { get; }
    internal TokenValidationResult(SecurityToken securityToken, TokenHandler tokenHandler, TokenValidationParameters tokenValidationParameters, string issuer, List`1<ValidationResult> validationResults);
    internal TokenValidationResult(SecurityToken securityToken, TokenHandler tokenHandler, ValidationParameters validationParameters, string issuer, List`1<ValidationResult> validationResults);
    internal void AddValidationResult(ValidationResult validationResult);
    public IDictionary`2<string, object> get_Claims();
    public ClaimsIdentity get_ClaimsIdentity();
    public void set_ClaimsIdentity(ClaimsIdentity value);
    internal ClaimsIdentity get_ClaimsIdentityNoLocking();
    internal void set_ClaimsIdentityNoLocking(ClaimsIdentity value);
    private object get_ClaimsIdentitySyncObj();
    public Exception get_Exception();
    public void set_Exception(Exception value);
    private ExceptionDetail get_ExceptionDetail();
    [CompilerGeneratedAttribute]
internal bool get_HasValidOrExceptionWasRead();
    [CompilerGeneratedAttribute]
internal void set_HasValidOrExceptionWasRead(bool value);
    [CompilerGeneratedAttribute]
public string get_Issuer();
    [CompilerGeneratedAttribute]
public void set_Issuer(string value);
    public bool get_IsValid();
    public void set_IsValid(bool value);
    public IDictionary`2<string, object> get_PropertyBag();
    [CompilerGeneratedAttribute]
public SecurityToken get_SecurityToken();
    [CompilerGeneratedAttribute]
public void set_SecurityToken(SecurityToken value);
    [CompilerGeneratedAttribute]
public SecurityToken get_TokenOnFailedValidation();
    [CompilerGeneratedAttribute]
internal void set_TokenOnFailedValidation(SecurityToken value);
    [CompilerGeneratedAttribute]
public CallContext get_TokenContext();
    [CompilerGeneratedAttribute]
public void set_TokenContext(CallContext value);
    [CompilerGeneratedAttribute]
public string get_TokenType();
    [CompilerGeneratedAttribute]
public void set_TokenType(string value);
    internal IReadOnlyList`1<ValidationResult> get_ValidationResults();
}
public class Microsoft.IdentityModel.Tokens.TransformBeforeSignatureValidation : MulticastDelegate {
    public TransformBeforeSignatureValidation(object object, IntPtr method);
    public virtual SecurityToken Invoke(SecurityToken token, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(SecurityToken token, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.TransformBeforeSignatureValidationDelegate : MulticastDelegate {
    public TransformBeforeSignatureValidationDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual SecurityToken Invoke(SecurityToken token, ValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(SecurityToken token, ValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual SecurityToken EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.TypeValidator : MulticastDelegate {
    public TypeValidator(object object, IntPtr method);
    public virtual string Invoke(string type, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public virtual IAsyncResult BeginInvoke(string type, SecurityToken securityToken, TokenValidationParameters validationParameters, AsyncCallback callback, object object);
    public virtual string EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.TypeValidatorDelegate : MulticastDelegate {
    public TypeValidatorDelegate(object object, IntPtr method);
    [NullableContextAttribute("1")]
public virtual TokenTypeValidationResult Invoke(string type, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    public virtual IAsyncResult BeginInvoke(string type, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, AsyncCallback callback, object object);
    public virtual TokenTypeValidationResult EndInvoke(IAsyncResult result);
}
public static class Microsoft.IdentityModel.Tokens.UniqueId : object {
    private static int RandomSaltSize;
    private static string NcNamePrefix;
    private static string UuidUriPrefix;
    private static string reusableUuid;
    private static string optimizedNcNamePrefix;
    private static UniqueId();
    public static string CreateUniqueId();
    public static string CreateUniqueId(string prefix);
    public static string CreateRandomId();
    public static string CreateRandomId(string prefix);
    public static Uri CreateRandomUri();
    private static string GetNextId();
    private static string GetRandomUuid();
}
[ExtensionAttribute]
public static class Microsoft.IdentityModel.Tokens.Utility : object {
    public static string Empty;
    public static string Null;
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
    internal static string SerializeAsSingleCommaDelimitedString(IEnumerable`1<string> strings);
    public static bool IsHttps(string address);
    public static bool IsHttps(Uri uri);
    public static bool AreEqual(Byte[] a, Byte[] b);
    internal static bool AreEqual(ReadOnlySpan`1<byte> a, ReadOnlySpan`1<byte> b, int length);
    internal static Byte[] ConvertToBigEndian(long i);
    internal static Byte[] Xor(Byte[] a, Byte[] b, int offset, bool inPlace);
    internal static void Zero(Byte[] byteArray);
    internal static Byte[] GenerateSha256Hash(string input);
}
public enum Microsoft.IdentityModel.Tokens.ValidationFailure : Enum {
    public int value__;
    public static ValidationFailure None;
    public static ValidationFailure InvalidLifetime;
    public static ValidationFailure InvalidIssuer;
}
internal abstract class Microsoft.IdentityModel.Tokens.ValidationFailureType : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    public static ValidationFailureType NullArgument;
    public static ValidationFailureType IssuerValidationFailed;
    public static ValidationFailureType AlgorithmValidationFailed;
    public static ValidationFailureType AudienceValidationFailed;
    public static ValidationFailureType TokenTypeValidationFailed;
    public static ValidationFailureType SignatureValidationFailed;
    public static ValidationFailureType SigningKeyValidationFailed;
    public static ValidationFailureType LifetimeValidationFailed;
    public static ValidationFailureType TokenReplayValidationFailed;
    public static ValidationFailureType TokenReadingFailed;
    public static ValidationFailureType TokenDecryptionFailed;
    public static ValidationFailureType ValidationNotEvaluated;
    public static ValidationFailureType ValidationSucceeded;
    public string Name { get; }
    protected ValidationFailureType(string name);
    private static ValidationFailureType();
    [CompilerGeneratedAttribute]
public string get_Name();
}
internal class Microsoft.IdentityModel.Tokens.ValidationParameters : object {
    private string _authenticationType;
    private TimeSpan _clockSkew;
    private string _nameClaimType;
    private string _roleClaimType;
    private Dictionary`2<string, object> _instancePropertyBag;
    private IList`1<SecurityKey> _issuerSigningKeys;
    private IList`1<string> _validIssuers;
    private IList`1<string> _validTokenTypes;
    private IList`1<string> _validAudiences;
    private AlgorithmValidatorDelegate _algorithmValidator;
    private AudienceValidatorDelegate _audienceValidator;
    private IssuerValidationDelegateAsync _issuerValidatorAsync;
    private LifetimeValidatorDelegate _lifetimeValidator;
    private SignatureValidatorDelegate _signatureValidator;
    private TokenReplayValidatorDelegate _tokenReplayValidator;
    private TypeValidatorDelegate _typeValidator;
    private IssuerSigningKeyValidatorDelegate _issuerSigningKeyValidator;
    public static string DefaultAuthenticationType;
    public static TimeSpan DefaultClockSkew;
    public static int DefaultMaximumTokenSizeInBytes;
    [CompilerGeneratedAttribute]
private ValidationParameters <ActorValidationParameters>k__BackingField;
    [CompilerGeneratedAttribute]
private BaseConfigurationManager <ConfigurationManager>k__BackingField;
    [CompilerGeneratedAttribute]
private CryptoProviderFactory <CryptoProviderFactory>k__BackingField;
    [CompilerGeneratedAttribute]
private string <DebugId>k__BackingField;
    [CompilerGeneratedAttribute]
private SecurityKey <EphemeralDecryptionKey>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreTrailingSlashWhenValidatingAudience>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IncludeTokenOnFailedValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsClone>k__BackingField;
    [CompilerGeneratedAttribute]
private IssuerSigningKeyResolverDelegate <IssuerSigningKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformBeforeSignatureValidationDelegate <TransformBeforeSignatureValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogTokenId>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <NameClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, object> <PropertyBag>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RefreshBeforeValidation>k__BackingField;
    [CompilerGeneratedAttribute]
private Func`3<SecurityToken, string, string> <RoleClaimTypeRetriever>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <SaveSigninToken>k__BackingField;
    [CompilerGeneratedAttribute]
private ResolveTokenDecryptionKeyDelegate <TokenDecryptionKeyResolver>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<SecurityKey> <TokenDecryptionKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private ITokenReplayCache <TokenReplayCache>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <TryAllIssuerSigningKeys>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateWithLKG>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateSignatureLast>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<string> <ValidAlgorithms>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ValidateActor>k__BackingField;
    public ValidationParameters ActorValidationParameters { get; public set; }
    public AlgorithmValidatorDelegate AlgorithmValidator { get; public set; }
    public AudienceValidatorDelegate AudienceValidator { get; public set; }
    public string AuthenticationType { get; public set; }
    [DefaultValueAttribute("300")]
public TimeSpan ClockSkew { get; public set; }
    public BaseConfigurationManager ConfigurationManager { get; public set; }
    public CryptoProviderFactory CryptoProviderFactory { get; public set; }
    public string DebugId { get; public set; }
    public SecurityKey EphemeralDecryptionKey { get; public set; }
    [DefaultValueAttribute("True")]
public bool IgnoreTrailingSlashWhenValidatingAudience { get; public set; }
    public bool IncludeTokenOnFailedValidation { get; public set; }
    public IssuerSigningKeyValidatorDelegate IssuerSigningKeyValidator { get; public set; }
    public IDictionary`2<string, object> InstancePropertyBag { get; }
    public bool IsClone { get; protected set; }
    public IssuerSigningKeyResolverDelegate IssuerSigningKeyResolver { get; public set; }
    public IList`1<SecurityKey> IssuerSigningKeys { get; }
    public IssuerValidationDelegateAsync IssuerValidatorAsync { get; public set; }
    public TransformBeforeSignatureValidationDelegate TransformBeforeSignatureValidation { get; public set; }
    public LifetimeValidatorDelegate LifetimeValidator { get; public set; }
    [DefaultValueAttribute("True")]
public bool LogTokenId { get; public set; }
    public string NameClaimType { get; public set; }
    public Func`3<SecurityToken, string, string> NameClaimTypeRetriever { get; public set; }
    public IDictionary`2<string, object> PropertyBag { get; }
    [DefaultValueAttribute("False")]
public bool RefreshBeforeValidation { get; public set; }
    public string RoleClaimType { get; public set; }
    public Func`3<SecurityToken, string, string> RoleClaimTypeRetriever { get; public set; }
    [DefaultValueAttribute("False")]
public bool SaveSigninToken { get; public set; }
    public SignatureValidatorDelegate SignatureValidator { get; public set; }
    public ResolveTokenDecryptionKeyDelegate TokenDecryptionKeyResolver { get; public set; }
    public IList`1<SecurityKey> TokenDecryptionKeys { get; internal set; }
    public ITokenReplayCache TokenReplayCache { get; public set; }
    public TokenReplayValidatorDelegate TokenReplayValidator { get; public set; }
    public bool TryAllIssuerSigningKeys { get; public set; }
    public TypeValidatorDelegate TypeValidator { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateWithLKG { get; public set; }
    [DefaultValueAttribute("False")]
public bool ValidateSignatureLast { get; public set; }
    public IList`1<string> ValidAlgorithms { get; public set; }
    public IList`1<string> ValidAudiences { get; }
    public IList`1<string> ValidIssuers { get; }
    public IList`1<string> ValidTypes { get; }
    public bool ValidateActor { get; public set; }
    protected ValidationParameters(ValidationParameters other);
    private static ValidationParameters();
    [CompilerGeneratedAttribute]
public ValidationParameters get_ActorValidationParameters();
    [CompilerGeneratedAttribute]
public void set_ActorValidationParameters(ValidationParameters value);
    public AlgorithmValidatorDelegate get_AlgorithmValidator();
    public void set_AlgorithmValidator(AlgorithmValidatorDelegate value);
    public AudienceValidatorDelegate get_AudienceValidator();
    public void set_AudienceValidator(AudienceValidatorDelegate value);
    public string get_AuthenticationType();
    public void set_AuthenticationType(string value);
    public TimeSpan get_ClockSkew();
    public void set_ClockSkew(TimeSpan value);
    public virtual ValidationParameters Clone();
    public virtual ClaimsIdentity CreateClaimsIdentity(SecurityToken securityToken, string issuer);
    [CompilerGeneratedAttribute]
public BaseConfigurationManager get_ConfigurationManager();
    [CompilerGeneratedAttribute]
public void set_ConfigurationManager(BaseConfigurationManager value);
    [CompilerGeneratedAttribute]
public CryptoProviderFactory get_CryptoProviderFactory();
    [CompilerGeneratedAttribute]
public void set_CryptoProviderFactory(CryptoProviderFactory value);
    [CompilerGeneratedAttribute]
public string get_DebugId();
    [CompilerGeneratedAttribute]
public void set_DebugId(string value);
    [CompilerGeneratedAttribute]
public SecurityKey get_EphemeralDecryptionKey();
    [CompilerGeneratedAttribute]
public void set_EphemeralDecryptionKey(SecurityKey value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreTrailingSlashWhenValidatingAudience();
    [CompilerGeneratedAttribute]
public void set_IgnoreTrailingSlashWhenValidatingAudience(bool value);
    [CompilerGeneratedAttribute]
public bool get_IncludeTokenOnFailedValidation();
    [CompilerGeneratedAttribute]
public void set_IncludeTokenOnFailedValidation(bool value);
    public IssuerSigningKeyValidatorDelegate get_IssuerSigningKeyValidator();
    public void set_IssuerSigningKeyValidator(IssuerSigningKeyValidatorDelegate value);
    public IDictionary`2<string, object> get_InstancePropertyBag();
    [CompilerGeneratedAttribute]
public bool get_IsClone();
    [CompilerGeneratedAttribute]
protected void set_IsClone(bool value);
    [CompilerGeneratedAttribute]
public IssuerSigningKeyResolverDelegate get_IssuerSigningKeyResolver();
    [CompilerGeneratedAttribute]
public void set_IssuerSigningKeyResolver(IssuerSigningKeyResolverDelegate value);
    public IList`1<SecurityKey> get_IssuerSigningKeys();
    public IssuerValidationDelegateAsync get_IssuerValidatorAsync();
    public void set_IssuerValidatorAsync(IssuerValidationDelegateAsync value);
    [CompilerGeneratedAttribute]
public TransformBeforeSignatureValidationDelegate get_TransformBeforeSignatureValidation();
    [CompilerGeneratedAttribute]
public void set_TransformBeforeSignatureValidation(TransformBeforeSignatureValidationDelegate value);
    public LifetimeValidatorDelegate get_LifetimeValidator();
    public void set_LifetimeValidator(LifetimeValidatorDelegate value);
    [CompilerGeneratedAttribute]
public bool get_LogTokenId();
    [CompilerGeneratedAttribute]
public void set_LogTokenId(bool value);
    public string get_NameClaimType();
    public void set_NameClaimType(string value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_NameClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_NameClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public IDictionary`2<string, object> get_PropertyBag();
    [CompilerGeneratedAttribute]
public bool get_RefreshBeforeValidation();
    [CompilerGeneratedAttribute]
public void set_RefreshBeforeValidation(bool value);
    public string get_RoleClaimType();
    public void set_RoleClaimType(string value);
    [CompilerGeneratedAttribute]
public Func`3<SecurityToken, string, string> get_RoleClaimTypeRetriever();
    [CompilerGeneratedAttribute]
public void set_RoleClaimTypeRetriever(Func`3<SecurityToken, string, string> value);
    [CompilerGeneratedAttribute]
public bool get_SaveSigninToken();
    [CompilerGeneratedAttribute]
public void set_SaveSigninToken(bool value);
    public SignatureValidatorDelegate get_SignatureValidator();
    public void set_SignatureValidator(SignatureValidatorDelegate value);
    [CompilerGeneratedAttribute]
public ResolveTokenDecryptionKeyDelegate get_TokenDecryptionKeyResolver();
    [CompilerGeneratedAttribute]
public void set_TokenDecryptionKeyResolver(ResolveTokenDecryptionKeyDelegate value);
    [CompilerGeneratedAttribute]
public IList`1<SecurityKey> get_TokenDecryptionKeys();
    [CompilerGeneratedAttribute]
internal void set_TokenDecryptionKeys(IList`1<SecurityKey> value);
    [CompilerGeneratedAttribute]
public ITokenReplayCache get_TokenReplayCache();
    [CompilerGeneratedAttribute]
public void set_TokenReplayCache(ITokenReplayCache value);
    public TokenReplayValidatorDelegate get_TokenReplayValidator();
    public void set_TokenReplayValidator(TokenReplayValidatorDelegate value);
    [CompilerGeneratedAttribute]
public bool get_TryAllIssuerSigningKeys();
    [CompilerGeneratedAttribute]
public void set_TryAllIssuerSigningKeys(bool value);
    public TypeValidatorDelegate get_TypeValidator();
    public void set_TypeValidator(TypeValidatorDelegate value);
    [CompilerGeneratedAttribute]
public bool get_ValidateWithLKG();
    [CompilerGeneratedAttribute]
public void set_ValidateWithLKG(bool value);
    [CompilerGeneratedAttribute]
public bool get_ValidateSignatureLast();
    [CompilerGeneratedAttribute]
public void set_ValidateSignatureLast(bool value);
    [CompilerGeneratedAttribute]
public IList`1<string> get_ValidAlgorithms();
    [CompilerGeneratedAttribute]
public void set_ValidAlgorithms(IList`1<string> value);
    public IList`1<string> get_ValidAudiences();
    public IList`1<string> get_ValidIssuers();
    public IList`1<string> get_ValidTypes();
    [CompilerGeneratedAttribute]
public bool get_ValidateActor();
    [CompilerGeneratedAttribute]
public void set_ValidateActor(bool value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Microsoft.IdentityModel.Tokens.ValidationResult : object {
    private bool _isValid;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private ExceptionDetail <ExceptionDetail>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasValidOrExceptionWasRead>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<LogDetail> <LogDetails>k__BackingField;
    [CompilerGeneratedAttribute]
private ValidationFailureType <ValidationFailureType>k__BackingField;
    [NullableAttribute("2")]
public Exception Exception { get; }
    [NullableAttribute("2")]
public ExceptionDetail ExceptionDetail { get; }
    public bool IsValid { get; public set; }
    protected bool HasValidOrExceptionWasRead { get; protected set; }
    public IList`1<LogDetail> LogDetails { get; }
    public ValidationFailureType ValidationFailureType { get; }
    protected ValidationResult(ValidationFailureType validationFailureType);
    protected ValidationResult(ValidationFailureType validationFailureType, ExceptionDetail exceptionDetail);
    public void AddStackFrame(StackFrame stackFrame);
    [NullableContextAttribute("2")]
public abstract virtual Exception get_Exception();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public ExceptionDetail get_ExceptionDetail();
    public bool get_IsValid();
    public void set_IsValid(bool value);
    [CompilerGeneratedAttribute]
protected bool get_HasValidOrExceptionWasRead();
    [CompilerGeneratedAttribute]
protected void set_HasValidOrExceptionWasRead(bool value);
    public void Log();
    [CompilerGeneratedAttribute]
public IList`1<LogDetail> get_LogDetails();
    [CompilerGeneratedAttribute]
public ValidationFailureType get_ValidationFailureType();
}
public static class Microsoft.IdentityModel.Tokens.Validators : object {
    [NullableContextAttribute("1")]
internal static AlgorithmValidationResult ValidateAlgorithm(string algorithm, SecurityKey securityKey, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
internal static AudienceValidationResult ValidateAudience(IList`1<string> tokenAudiences, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
private static string ValidTokenAudience(IList`1<string> tokenAudiences, IList`1<string> validAudiences, bool ignoreTrailingSlashWhenValidatingAudience);
    [NullableContextAttribute("1")]
private static bool AudienceMatches(bool ignoreTrailingSlashWhenValidatingAudience, string tokenAudience, string validAudience);
    [NullableContextAttribute("1")]
private static bool AudienceMatchesIgnoringTrailingSlash(string tokenAudience, string validAudience);
    [AsyncStateMachineAttribute("Microsoft.IdentityModel.Tokens.Validators/<ValidateIssuerAsync>d__5")]
internal static Task`1<IssuerValidationResult> ValidateIssuerAsync(string issuer, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext, Nullable`1<CancellationToken> cancellationToken);
    [NullableContextAttribute("1")]
internal static SigningKeyValidationResult ValidateIssuerSigningKey(SecurityKey securityKey, SecurityToken securityToken, ValidationParameters validationParameters, BaseConfiguration configuration, CallContext callContext);
    [NullableContextAttribute("1")]
internal static SigningKeyValidationResult ValidateIssuerSigningKeyLifeTime(SecurityKey securityKey, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
internal static LifetimeValidationResult ValidateLifetime(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    internal static ReplayValidationResult ValidateTokenReplay(Nullable`1<DateTime> expirationTime, string securityToken, ValidationParameters validationParameters, CallContext callContext);
    [NullableContextAttribute("1")]
internal static TokenTypeValidationResult ValidateTokenType(string type, SecurityToken securityToken, ValidationParameters validationParameters, CallContext callContext);
    public static void ValidateAlgorithm(string algorithm, SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static void ValidateAudience(IEnumerable`1<string> audiences, SecurityToken securityToken, TokenValidationParameters validationParameters);
    private static bool AudienceIsValid(IEnumerable`1<string> audiences, TokenValidationParameters validationParameters, IEnumerable`1<string> validationParametersAudiences);
    private static bool AudiencesMatch(TokenValidationParameters validationParameters, string tokenAudience, string validAudience);
    private static bool AudiencesMatchIgnoringTrailingSlash(string tokenAudience, string validAudience);
    public static string ValidateIssuer(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters);
    internal static string ValidateIssuer(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    [AsyncStateMachineAttribute("Microsoft.IdentityModel.Tokens.Validators/<ValidateIssuerAsync>d__18")]
internal static ValueTask`1<string> ValidateIssuerAsync(string issuer, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    public static void ValidateIssuerSecurityKey(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters);
    internal static void ValidateIssuerSecurityKey(SecurityKey securityKey, SecurityToken securityToken, TokenValidationParameters validationParameters, BaseConfiguration configuration);
    internal static void ValidateIssuerSigningKeyLifeTime(SecurityKey securityKey, TokenValidationParameters validationParameters);
    public static void ValidateLifetime(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters);
    public static void ValidateTokenReplay(Nullable`1<DateTime> expirationTime, string securityToken, TokenValidationParameters validationParameters);
    public static void ValidateTokenReplay(string securityToken, Nullable`1<DateTime> expirationTime, TokenValidationParameters validationParameters);
    public static string ValidateTokenType(string type, SecurityToken securityToken, TokenValidationParameters validationParameters);
}
internal static class Microsoft.IdentityModel.Tokens.ValidatorUtilities : object {
    internal static void ValidateLifetime(Nullable`1<DateTime> notBefore, Nullable`1<DateTime> expires, SecurityToken securityToken, TokenValidationParameters validationParameters);
}
internal class Microsoft.IdentityModel.Tokens.VerifyDelegate : MulticastDelegate {
    public VerifyDelegate(object object, IntPtr method);
    public virtual bool Invoke(Byte[] bytes, Byte[] signature);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, Byte[] signature, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
internal class Microsoft.IdentityModel.Tokens.VerifyUsingOffsetDelegate : MulticastDelegate {
    public VerifyUsingOffsetDelegate(object object, IntPtr method);
    public virtual bool Invoke(Byte[] bytes, int offset, int count, Byte[] signature);
    public virtual IAsyncResult BeginInvoke(Byte[] bytes, int offset, int count, Byte[] signature, AsyncCallback callback, object object);
    public virtual bool EndInvoke(IAsyncResult result);
}
public class Microsoft.IdentityModel.Tokens.X509EncryptingCredentials : EncryptingCredentials {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509EncryptingCredentials(X509Certificate2 certificate);
    public X509EncryptingCredentials(X509Certificate2 certificate, string keyWrapAlgorithm, string dataEncryptionAlgorithm);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
}
public class Microsoft.IdentityModel.Tokens.X509SecurityKey : AsymmetricSecurityKey {
    private AsymmetricAlgorithm _privateKey;
    private bool _privateKeyAvailabilityDetermined;
    private AsymmetricAlgorithm _publicKey;
    private object _thisLock;
    [CompilerGeneratedAttribute]
private string <X5t>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public int KeySize { get; }
    public string X5t { get; }
    public AsymmetricAlgorithm PrivateKey { get; }
    public AsymmetricAlgorithm PublicKey { get; }
    private object ThisLock { get; }
    [ObsoleteAttribute("HasPrivateKey method is deprecated, please use PrivateKeyStatus.")]
public bool HasPrivateKey { get; }
    public PrivateKeyStatus PrivateKeyStatus { get; }
    public X509Certificate2 Certificate { get; private set; }
    internal string InternalId { get; }
    internal X509SecurityKey(JsonWebKey webKey);
    public X509SecurityKey(X509Certificate2 certificate);
    public X509SecurityKey(X509Certificate2 certificate, string keyId);
    public virtual int get_KeySize();
    [CompilerGeneratedAttribute]
public string get_X5t();
    public AsymmetricAlgorithm get_PrivateKey();
    public AsymmetricAlgorithm get_PublicKey();
    private object get_ThisLock();
    public virtual bool get_HasPrivateKey();
    public virtual PrivateKeyStatus get_PrivateKeyStatus();
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
    internal virtual string get_InternalId();
    public virtual bool CanComputeJwkThumbprint();
    public virtual Byte[] ComputeJwkThumbprint();
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
public class Microsoft.IdentityModel.Tokens.X509SigningCredentials : SigningCredentials {
    [CompilerGeneratedAttribute]
private X509Certificate2 <Certificate>k__BackingField;
    public X509Certificate2 Certificate { get; private set; }
    public X509SigningCredentials(X509Certificate2 certificate);
    public X509SigningCredentials(X509Certificate2 certificate, string algorithm);
    [CompilerGeneratedAttribute]
public X509Certificate2 get_Certificate();
    [CompilerGeneratedAttribute]
private void set_Certificate(X509Certificate2 value);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
