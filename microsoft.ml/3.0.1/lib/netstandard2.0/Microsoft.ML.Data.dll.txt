[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
public class Microsoft.ML.AnomalyDetectionCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private AnomalyDetectionTrainers <Trainers>k__BackingField;
    public AnomalyDetectionTrainers Trainers { get; }
    internal AnomalyDetectionCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public AnomalyDetectionTrainers get_Trainers();
    public AnomalyDetectionMetrics Evaluate(IDataView data, string labelColumnName, string scoreColumnName, string predictedLabelColumnName, int falsePositiveCount);
    public AnomalyPredictionTransformer`1<TModel> ChangeModelThreshold(AnomalyPredictionTransformer`1<TModel> model, float threshold);
}
internal static class Microsoft.ML.ApiUtils : object {
    private static FuncStaticMethodInfo3`3<FieldInfo, OpCode, Delegate> _generatePeekFieldMethodInfo;
    private static FuncStaticMethodInfo3`3<PropertyInfo, OpCode, Delegate> _generatePeekPropertyMethodInfo;
    private static FuncStaticMethodInfo3`3<FieldInfo, OpCode, Delegate> _generatePokeFieldMethodInfo;
    private static FuncStaticMethodInfo3`2<PropertyInfo, Delegate> _generatePokePropertyMethodInfo;
    private static ApiUtils();
    private static OpCode GetAssignmentOpCode(Type t, IEnumerable`1<Attribute> attributes);
    internal static Delegate GeneratePeek(Column column);
    private static Delegate GeneratePeek(FieldInfo fieldInfo, OpCode assignmentOpCode);
    private static Delegate GeneratePeek(PropertyInfo propertyInfo, OpCode assignmentOpCode);
    internal static Delegate GeneratePoke(Column column);
    private static Delegate GeneratePoke(FieldInfo fieldInfo, OpCode assignmentOpCode);
    private static Delegate GeneratePoke(PropertyInfo propertyInfo);
}
public class Microsoft.ML.BinaryClassificationCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private BinaryClassificationTrainers <Trainers>k__BackingField;
    [CompilerGeneratedAttribute]
private CalibratorsCatalog <Calibrators>k__BackingField;
    public BinaryClassificationTrainers Trainers { get; }
    public CalibratorsCatalog Calibrators { get; }
    internal BinaryClassificationCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public BinaryClassificationTrainers get_Trainers();
    public CalibratedBinaryClassificationMetrics Evaluate(IDataView data, string labelColumnName, string scoreColumnName, string probabilityColumnName, string predictedLabelColumnName);
    public BinaryClassificationMetrics EvaluateNonCalibrated(IDataView data, string labelColumnName, string scoreColumnName, string predictedLabelColumnName);
    public IReadOnlyList`1<CrossValidationResult`1<BinaryClassificationMetrics>> CrossValidateNonCalibrated(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string samplingKeyColumnName, Nullable`1<int> seed);
    public IReadOnlyList`1<CrossValidationResult`1<CalibratedBinaryClassificationMetrics>> CrossValidate(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string samplingKeyColumnName, Nullable`1<int> seed);
    public BinaryPredictionTransformer`1<TModel> ChangeModelThreshold(BinaryPredictionTransformer`1<TModel> model, float threshold);
    [CompilerGeneratedAttribute]
public CalibratorsCatalog get_Calibrators();
}
[ExtensionAttribute]
public static class Microsoft.ML.BinaryLoaderSaverCatalog : object {
    [ExtensionAttribute]
public static IDataView LoadFromBinary(DataOperationsCatalog catalog, IMultiStreamSource fileSource);
    [ExtensionAttribute]
public static IDataView LoadFromBinary(DataOperationsCatalog catalog, string path);
    [ExtensionAttribute]
public static void SaveAsBinary(DataOperationsCatalog catalog, IDataView data, Stream stream, bool keepHidden);
}
internal static class Microsoft.ML.Calibrators.Calibrate : object {
    [EntryPointAttribute]
public static CalibratorOutput Platt(IHostEnvironment env, NoArgumentsInput input);
    [EntryPointAttribute]
public static CalibratorOutput Naive(IHostEnvironment env, NoArgumentsInput input);
    [EntryPointAttribute]
public static CalibratorOutput Pav(IHostEnvironment env, NoArgumentsInput input);
    [EntryPointAttribute]
public static CalibratorOutput FixedPlatt(IHostEnvironment env, FixedPlattInput input);
    internal static TOut CalibratePredictor(IHost host, CalibrateInputBase input, ICalibratorTrainer calibratorTrainer);
}
public abstract class Microsoft.ML.Calibrators.CalibratedModelParametersBase : object {
    [CompilerGeneratedAttribute]
private object <SubModel>k__BackingField;
    [CompilerGeneratedAttribute]
private ICalibrator <Calibrator>k__BackingField;
    public object SubModel { get; }
    public ICalibrator Calibrator { get; }
    private protected CalibratedModelParametersBase(object subModel, ICalibrator calibrator);
    [CompilerGeneratedAttribute]
public object get_SubModel();
    [CompilerGeneratedAttribute]
public ICalibrator get_Calibrator();
}
public abstract class Microsoft.ML.Calibrators.CalibratedModelParametersBase`2 : CalibratedModelParametersBase {
    private protected IHost Host;
    [CompilerGeneratedAttribute]
private TSubModel <SubModel>k__BackingField;
    [CompilerGeneratedAttribute]
private TCalibrator <Calibrator>k__BackingField;
    public TSubModel SubModel { get; }
    public TCalibrator Calibrator { get; }
    private IPredictorProducing`1<float> Microsoft.ML.Calibrators.IWeaklyTypedCalibratedModelParameters.WeaklyTypedSubModel { get; }
    private ICalibrator Microsoft.ML.Calibrators.IWeaklyTypedCalibratedModelParameters.WeaklyTypedCalibrator { get; }
    private PredictionKind Microsoft.ML.IPredictor.PredictionKind { get; }
    private protected CalibratedModelParametersBase`2(IHostEnvironment env, string name, TSubModel predictor, TCalibrator calibrator);
    [CompilerGeneratedAttribute]
public TSubModel get_SubModel();
    [CompilerGeneratedAttribute]
public TCalibrator get_Calibrator();
    private sealed virtual override IPredictorProducing`1<float> Microsoft.ML.Calibrators.IWeaklyTypedCalibratedModelParameters.get_WeaklyTypedSubModel();
    private sealed virtual override ICalibrator Microsoft.ML.Calibrators.IWeaklyTypedCalibratedModelParameters.get_WeaklyTypedCalibrator();
    private sealed virtual override PredictionKind Microsoft.ML.IPredictor.get_PredictionKind();
    private sealed virtual override void Microsoft.ML.Model.ICanSaveInIniFormat.SaveAsIni(TextWriter writer, RoleMappedSchema schema, ICalibrator calibrator);
    private sealed virtual override void Microsoft.ML.Model.ICanSaveInTextFormat.SaveAsText(TextWriter writer, RoleMappedSchema schema);
    private sealed virtual override void Microsoft.ML.Model.ICanSaveInSourceCode.SaveAsCode(TextWriter writer, RoleMappedSchema schema);
    private sealed virtual override void Microsoft.ML.Model.ICanSaveSummary.SaveSummary(TextWriter writer, RoleMappedSchema schema);
    private sealed virtual override IList`1<KeyValuePair`2<string, object>> Microsoft.ML.Model.ICanGetSummaryInKeyValuePairs.GetSummaryInKeyValuePairs(RoleMappedSchema schema);
    private protected void SaveCore(ModelSaveContext ctx);
    private protected static TSubModel GetPredictor(IHostEnvironment env, ModelLoadContext ctx);
    private protected static TCalibrator GetCalibrator(IHostEnvironment env, ModelLoadContext ctx);
}
public abstract class Microsoft.ML.Calibrators.CalibratorEstimatorBase`1 : object {
    [BestFriendAttribute]
private protected IHostEnvironment Host;
    private ICalibratorTrainer _calibratorTrainer;
    [BestFriendAttribute]
private protected Column ScoreColumn;
    [BestFriendAttribute]
private protected Column LabelColumn;
    [BestFriendAttribute]
private protected Column WeightColumn;
    [BestFriendAttribute]
private protected Column PredictedLabel;
    private ICalibratorTrainer Microsoft.ML.Calibrators.IHaveCalibratorTrainer.CalibratorTrainer { get; }
    [BestFriendAttribute]
private protected CalibratorEstimatorBase`1(IHostEnvironment env, ICalibratorTrainer calibratorTrainer, string labelColumn, string scoreColumn, string weightColumn);
    private sealed virtual override ICalibratorTrainer Microsoft.ML.Calibrators.IHaveCalibratorTrainer.get_CalibratorTrainer();
    private sealed virtual override SchemaShape Microsoft.ML.IEstimator<Microsoft.ML.Calibrators.CalibratorTransformer<TICalibrator>>.GetOutputSchema(SchemaShape inputSchema);
    public sealed virtual CalibratorTransformer`1<TICalibrator> Fit(IDataView input);
    [BestFriendAttribute]
private protected abstract virtual CalibratorTransformer`1<TICalibrator> Create(IHostEnvironment env, TICalibrator calibrator, string scoreColumnName);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Calibrators.CalibratorTrainerBase : object {
    protected IHost Host;
    protected DataStore Data;
    protected static int DefaultMaxNumSamples;
    protected int MaxNumSamples;
    private bool Microsoft.ML.Calibrators.ICalibratorTrainer.NeedsTraining { get; }
    protected CalibratorTrainerBase(IHostEnvironment env, string name);
    private sealed virtual override bool Microsoft.ML.Calibrators.ICalibratorTrainer.get_NeedsTraining();
    private sealed virtual override bool Microsoft.ML.Calibrators.ICalibratorTrainer.ProcessTrainingExample(float output, bool labelIs1, float weight);
    private sealed virtual override ICalibrator Microsoft.ML.Calibrators.ICalibratorTrainer.FinishTraining(IChannel ch);
    public abstract virtual ICalibrator CreateCalibrator(IChannel ch);
}
public abstract class Microsoft.ML.Calibrators.CalibratorTransformer`1 : RowToRowTransformerBase {
    private TICalibrator _calibrator;
    private string _loaderSignature;
    private string _scoreColumnName;
    private string Microsoft.ML.ISingleFeaturePredictionTransformer<TICalibrator>.FeatureColumnName { get; }
    private string Microsoft.ML.ISingleFeaturePredictionTransformer.FeatureColumnName { get; }
    private DataViewType Microsoft.ML.ISingleFeaturePredictionTransformer<TICalibrator>.FeatureColumnType { get; }
    private TICalibrator Microsoft.ML.IPredictionTransformer<TICalibrator>.Model { get; }
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    private protected CalibratorTransformer`1(IHostEnvironment env, TICalibrator calibrator, string loaderSignature, string scoreColumnName);
    private protected CalibratorTransformer`1(IHostEnvironment env, ModelLoadContext ctx, string loaderSignature);
    private sealed virtual override string Microsoft.ML.ISingleFeaturePredictionTransformer<TICalibrator>.get_FeatureColumnName();
    private sealed virtual override string Microsoft.ML.ISingleFeaturePredictionTransformer.get_FeatureColumnName();
    private sealed virtual override DataViewType Microsoft.ML.ISingleFeaturePredictionTransformer<TICalibrator>.get_FeatureColumnType();
    private sealed virtual override TICalibrator Microsoft.ML.IPredictionTransformer<TICalibrator>.get_Model();
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private protected VersionInfo GetVersionInfo();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Calibrators.CalibratorUtils : object {
    private static int _maxCalibrationExamples;
    private static bool NeedCalibration(IHostEnvironment env, IChannel ch, ICalibratorTrainer calibrator, ITrainer trainer, IPredictor predictor, RoleMappedSchema schema);
    public static IPredictor TrainCalibratorIfNeeded(IHostEnvironment env, IChannel ch, ICalibratorTrainer calibrator, int maxRows, ITrainer trainer, IPredictor predictor, RoleMappedData data);
    public static IPredictor GetCalibratedPredictor(IHostEnvironment env, IChannel ch, ICalibratorTrainer caliTrainer, IPredictor predictor, RoleMappedData data, int maxRows);
    public static ICalibrator TrainCalibrator(IHostEnvironment env, IChannel ch, ICalibratorTrainer caliTrainer, IDataView scored, string labelColumn, string scoreColumn, string weightColumn, int maxRows);
    public static ICalibrator TrainCalibrator(IHostEnvironment env, IChannel ch, ICalibratorTrainer caliTrainer, IPredictor predictor, RoleMappedData data, int maxRows);
    public static IPredictorProducing`1<float> CreateCalibratedPredictor(IHostEnvironment env, TSubPredictor predictor, TCalibrator cali);
}
internal static class Microsoft.ML.Calibrators.CreateCalibratedModelParameters : object {
    internal static object Create(IHostEnvironment env, ModelLoadContext ctx, object predictor, ICalibrator calibrator, Type calibratedModelParametersType);
}
[BestFriendAttribute]
[PredictionTransformerLoadTypeAttribute("Microsoft.ML.Calibrators.CalibratedModelParametersBase`2")]
internal class Microsoft.ML.Calibrators.FeatureWeightsCalibratedModelParameters`2 : ValueMapperCalibratedModelParametersBase`2<TSubModel, TCalibrator> {
    private IPredictorWithFeatureWeights`1<float> _featureWeights;
    internal static string LoaderSignature;
    internal static string RegistrationName;
    internal FeatureWeightsCalibratedModelParameters`2(IHostEnvironment env, TSubModel predictor, TCalibrator calibrator);
    private FeatureWeightsCalibratedModelParameters`2(IHostEnvironment env, ModelLoadContext ctx, TSubModel predictor, TCalibrator calibrator);
    private static VersionInfo GetVersionInfo();
    private static CalibratedModelParametersBase Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual void GetFeatureWeights(VBuffer`1& weights);
}
public class Microsoft.ML.Calibrators.FixedPlattCalibratorEstimator : CalibratorEstimatorBase`1<PlattCalibrator> {
    internal FixedPlattCalibratorEstimator(IHostEnvironment env, double slope, double offset, string scoreColumn);
    [BestFriendAttribute]
private protected virtual CalibratorTransformer`1<PlattCalibrator> Create(IHostEnvironment env, PlattCalibrator calibrator, string scoreColumnName);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.FixedPlattCalibratorTrainer : object {
    internal static string UserName;
    internal static string LoadName;
    internal static string Summary;
    private IHost _host;
    private double _slope;
    private double _offset;
    private bool Microsoft.ML.Calibrators.ICalibratorTrainer.NeedsTraining { get; }
    internal FixedPlattCalibratorTrainer(IHostEnvironment env, Arguments args);
    private sealed virtual override bool Microsoft.ML.Calibrators.ICalibratorTrainer.get_NeedsTraining();
    private sealed virtual override bool Microsoft.ML.Calibrators.ICalibratorTrainer.ProcessTrainingExample(float output, bool labelIs1, float weight);
    private sealed virtual override ICalibrator Microsoft.ML.Calibrators.ICalibratorTrainer.FinishTraining(IChannel ch);
}
public interface Microsoft.ML.Calibrators.ICalibrator {
    public abstract virtual float PredictProbability(float output);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Calibrators.ICalibratorTrainer {
    public bool NeedsTraining { get; }
    public abstract virtual bool get_NeedsTraining();
    public abstract virtual bool ProcessTrainingExample(float output, bool labelIs1, float weight);
    public abstract virtual ICalibrator FinishTraining(IChannel ch);
}
[BestFriendAttribute]
[ComponentKindAttribute("CalibratorTrainer")]
internal interface Microsoft.ML.Calibrators.ICalibratorTrainerFactory {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Calibrators.IHaveCalibratorTrainer {
    public ICalibratorTrainer CalibratorTrainer { get; }
    public abstract virtual ICalibratorTrainer get_CalibratorTrainer();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Calibrators.ISelfCalibratingPredictor {
    public abstract virtual IPredictor Calibrate(IChannel ch, IDataView data, ICalibratorTrainer caliTrainer, int maxRows);
}
public class Microsoft.ML.Calibrators.IsotonicCalibrator : object {
    internal static string LoaderSignature;
    internal static string RegistrationName;
    private static float Epsilon;
    private static float MinToReturn;
    private static float MaxToReturn;
    private IHost _host;
    public ImmutableArray`1<float> Mins;
    public ImmutableArray`1<float> Maxes;
    public ImmutableArray`1<float> Values;
    internal IsotonicCalibrator(IHostEnvironment env, ImmutableArray`1<float> mins, ImmutableArray`1<float> maxes, ImmutableArray`1<float> values);
    private IsotonicCalibrator(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal static IsotonicCalibrator Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveInBinaryFormat.SaveAsBinary(BinaryWriter writer);
    private void SaveCore(ModelSaveContext ctx);
    public sealed virtual float PredictProbability(float output);
    private float FindValue(float score);
}
public class Microsoft.ML.Calibrators.IsotonicCalibratorEstimator : CalibratorEstimatorBase`1<IsotonicCalibrator> {
    internal IsotonicCalibratorEstimator(IHostEnvironment env, string labelColumn, string scoreColumn, string weightColumn);
    [BestFriendAttribute]
private protected virtual CalibratorTransformer`1<IsotonicCalibrator> Create(IHostEnvironment env, IsotonicCalibrator calibrator, string scoreColumnName);
}
public class Microsoft.ML.Calibrators.IsotonicCalibratorTransformer : CalibratorTransformer`1<IsotonicCalibrator> {
    internal static string LoadName;
    internal IsotonicCalibratorTransformer(IHostEnvironment env, IsotonicCalibrator calibrator, string scoreColumnName);
    private IsotonicCalibratorTransformer(IHostEnvironment env, ModelLoadContext ctx);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Calibrators.IWeaklyTypedCalibratedModelParameters {
    public IPredictorProducing`1<float> WeaklyTypedSubModel { get; }
    public ICalibrator WeaklyTypedCalibrator { get; }
    public abstract virtual IPredictorProducing`1<float> get_WeaklyTypedSubModel();
    public abstract virtual ICalibrator get_WeaklyTypedCalibrator();
}
public class Microsoft.ML.Calibrators.NaiveCalibrator : object {
    internal static string LoaderSignature;
    internal static string RegistrationName;
    private IHost _host;
    public float BinSize;
    public float Min;
    private Single[] _binProbs;
    public IReadOnlyList`1<float> BinProbs { get; }
    internal NaiveCalibrator(IHostEnvironment env, float min, float binSize, Single[] binProbs);
    private NaiveCalibrator(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    public IReadOnlyList`1<float> get_BinProbs();
    internal static NaiveCalibrator Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveInBinaryFormat.SaveAsBinary(BinaryWriter writer);
    private void SaveCore(ModelSaveContext ctx);
    public sealed virtual float PredictProbability(float output);
    internal static int GetBinIdx(float output, float min, float binSize, int numBins);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ISingleCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, String[] outputNames, string featureColumn);
}
public class Microsoft.ML.Calibrators.NaiveCalibratorEstimator : CalibratorEstimatorBase`1<NaiveCalibrator> {
    internal NaiveCalibratorEstimator(IHostEnvironment env, string labelColumn, string scoreColumn, string weightColumn);
    [BestFriendAttribute]
private protected virtual CalibratorTransformer`1<NaiveCalibrator> Create(IHostEnvironment env, NaiveCalibrator calibrator, string scoreColumnName);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.NaiveCalibratorTrainer : object {
    private IHost _host;
    private List`1<float> _cMargins;
    private List`1<float> _ncMargins;
    public int NumBins;
    public float BinSize;
    public float Min;
    public float Max;
    public Single[] BinProbs;
    internal static string UserName;
    internal static string LoadName;
    internal static string Summary;
    private bool Microsoft.ML.Calibrators.ICalibratorTrainer.NeedsTraining { get; }
    public NaiveCalibratorTrainer(IHostEnvironment env);
    private sealed virtual override bool Microsoft.ML.Calibrators.ICalibratorTrainer.get_NeedsTraining();
    public sealed virtual bool ProcessTrainingExample(float output, bool labelIs1, float weight);
    private sealed virtual override ICalibrator Microsoft.ML.Calibrators.ICalibratorTrainer.FinishTraining(IChannel ch);
}
[ComponentAttribute]
internal class Microsoft.ML.Calibrators.NaiveCalibratorTrainerFactory : object {
    public sealed virtual ICalibratorTrainer CreateComponent(IHostEnvironment env);
}
public class Microsoft.ML.Calibrators.NaiveCalibratorTransformer : CalibratorTransformer`1<NaiveCalibrator> {
    internal static string LoadName;
    internal NaiveCalibratorTransformer(IHostEnvironment env, NaiveCalibrator calibrator, string scoreColumnName);
    internal NaiveCalibratorTransformer(IHostEnvironment env, ModelLoadContext ctx);
}
[PredictionTransformerLoadTypeAttribute("Microsoft.ML.Calibrators.CalibratedModelParametersBase`2")]
internal class Microsoft.ML.Calibrators.ParameterMixingCalibratedModelParameters`2 : ValueMapperCalibratedModelParametersBase`2<TSubModel, TCalibrator> {
    private IPredictorWithFeatureWeights`1<float> _featureWeights;
    internal static string LoaderSignature;
    internal static string RegistrationName;
    internal ParameterMixingCalibratedModelParameters`2(IHostEnvironment env, TSubModel predictor, TCalibrator calibrator);
    private ParameterMixingCalibratedModelParameters`2(IHostEnvironment env, ModelLoadContext ctx, TSubModel predictor, TCalibrator calibrator);
    private static VersionInfo GetVersionInfo();
    private static CalibratedModelParametersBase Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual void GetFeatureWeights(VBuffer`1& weights);
    private sealed virtual override IParameterMixer`1<float> Microsoft.ML.Model.IParameterMixer<System.Single>.CombineParameters(IList`1<IParameterMixer`1<float>> models);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.PavCalibratorTrainer : CalibratorTrainerBase {
    internal static string UserName;
    internal static string LoadName;
    internal static string Summary;
    public PavCalibratorTrainer(IHostEnvironment env);
    public virtual ICalibrator CreateCalibrator(IChannel ch);
}
[ComponentAttribute]
internal class Microsoft.ML.Calibrators.PavCalibratorTrainerFactory : object {
    public sealed virtual ICalibratorTrainer CreateComponent(IHostEnvironment env);
}
public class Microsoft.ML.Calibrators.PlattCalibrator : object {
    internal static string LoaderSignature;
    internal static string RegistrationName;
    private IHost _host;
    [CompilerGeneratedAttribute]
private double <Slope>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Offset>k__BackingField;
    public double Slope { get; }
    public double Offset { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    internal PlattCalibrator(IHostEnvironment env, double slope, double offset);
    private PlattCalibrator(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    [CompilerGeneratedAttribute]
public double get_Slope();
    [CompilerGeneratedAttribute]
public double get_Offset();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    internal static PlattCalibrator Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private void SaveCore(ModelSaveContext ctx);
    public sealed virtual float PredictProbability(float output);
    internal static float PredictProbability(float output, double a, double b);
    private sealed virtual override JToken Microsoft.ML.Model.Pfa.ISingleCanSavePfa.SaveAsPfa(BoundPfaContext ctx, JToken input);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ISingleCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, String[] scoreProbablityColumnNames, string featureColumnName);
    private sealed virtual override IParameterMixer Microsoft.ML.Model.IParameterMixer.CombineParameters(IList`1<IParameterMixer> calibrators);
    [CompilerGeneratedAttribute]
private void <SaveCore>b__17_0(TextWriter writer);
}
public class Microsoft.ML.Calibrators.PlattCalibratorEstimator : CalibratorEstimatorBase`1<PlattCalibrator> {
    internal PlattCalibratorEstimator(IHostEnvironment env, string labelColumnName, string scoreColumnName, string exampleWeightColumnName);
    [BestFriendAttribute]
private protected virtual CalibratorTransformer`1<PlattCalibrator> Create(IHostEnvironment env, PlattCalibrator calibrator, string scoreColumnName);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.PlattCalibratorTrainer : CalibratorTrainerBase {
    internal static string UserName;
    internal static string LoadName;
    internal static string Summary;
    public PlattCalibratorTrainer(IHostEnvironment env);
    public virtual ICalibrator CreateCalibrator(IChannel ch);
}
[ComponentAttribute]
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.PlattCalibratorTrainerFactory : object {
    public sealed virtual ICalibratorTrainer CreateComponent(IHostEnvironment env);
}
public class Microsoft.ML.Calibrators.PlattCalibratorTransformer : CalibratorTransformer`1<PlattCalibrator> {
    internal static string LoadName;
    internal PlattCalibratorTransformer(IHostEnvironment env, PlattCalibrator calibrator, string scoreColumnName);
    internal PlattCalibratorTransformer(IHostEnvironment env, ModelLoadContext ctx);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.SchemaBindableCalibratedModelParameters`2 : CalibratedModelParametersBase`2<TSubModel, TCalibrator> {
    private ISchemaBindableMapper _bindable;
    private IFeatureContributionMapper _featureContribution;
    internal static string LoaderSignature;
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    internal SchemaBindableCalibratedModelParameters`2(IHostEnvironment env, TSubModel predictor, TCalibrator calibrator);
    private SchemaBindableCalibratedModelParameters`2(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    internal static CalibratedModelParametersBase Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.IBindableCanSavePfa.SaveAsPfa(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputs);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.IBindableCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, RoleMappedSchema schema, String[] outputs);
    public sealed virtual ISchemaBoundMapper Bind(IHostEnvironment env, RoleMappedSchema schema);
    private sealed virtual override ValueMapper`2<TSrc, VBuffer`1<float>> Microsoft.ML.Trainers.IFeatureContributionMapper.GetFeatureContributionMapper(int top, int bottom, bool normalize);
}
[BestFriendAttribute]
internal class Microsoft.ML.Calibrators.SignatureCalibrator : MulticastDelegate {
    public SignatureCalibrator(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
[PredictionTransformerLoadTypeAttribute("Microsoft.ML.Calibrators.CalibratedModelParametersBase`2")]
internal class Microsoft.ML.Calibrators.ValueMapperCalibratedModelParameters`2 : ValueMapperCalibratedModelParametersBase`2<TSubModel, TCalibrator> {
    internal static string LoaderSignature;
    internal static string RegistrationName;
    internal ValueMapperCalibratedModelParameters`2(IHostEnvironment env, TSubModel predictor, TCalibrator calibrator);
    private ValueMapperCalibratedModelParameters`2(IHostEnvironment env, ModelLoadContext ctx, TSubModel predictor, TCalibrator calibrator);
    private static VersionInfo GetVersionInfo();
    private static VersionInfo GetVersionInfoBulk();
    private static CalibratedModelParametersBase Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
}
internal abstract class Microsoft.ML.Calibrators.ValueMapperCalibratedModelParametersBase`2 : CalibratedModelParametersBase`2<TSubModel, TCalibrator> {
    private IValueMapper _mapper;
    private IFeatureContributionMapper _featureContribution;
    private DataViewType Microsoft.ML.Data.IValueMapper.InputType { get; }
    private DataViewType Microsoft.ML.Data.IValueMapper.OutputType { get; }
    private DataViewType Microsoft.ML.Data.IValueMapperDist.DistType { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    private FeatureContributionCalculator Microsoft.ML.Trainers.ICalculateFeatureContribution.FeatureContributionCalculator { get; }
    private protected ValueMapperCalibratedModelParametersBase`2(IHostEnvironment env, string name, TSubModel predictor, TCalibrator calibrator);
    private sealed virtual override DataViewType Microsoft.ML.Data.IValueMapper.get_InputType();
    private sealed virtual override DataViewType Microsoft.ML.Data.IValueMapper.get_OutputType();
    private sealed virtual override DataViewType Microsoft.ML.Data.IValueMapperDist.get_DistType();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override FeatureContributionCalculator Microsoft.ML.Trainers.ICalculateFeatureContribution.get_FeatureContributionCalculator();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    private sealed virtual override ValueMapper`2<TIn, TOut> Microsoft.ML.Data.IValueMapper.GetMapper();
    private sealed virtual override ValueMapper`3<TIn, TOut, TDist> Microsoft.ML.Data.IValueMapperDist.GetMapper();
    private sealed virtual override ValueMapper`2<TSrc, VBuffer`1<float>> Microsoft.ML.Trainers.IFeatureContributionMapper.GetFeatureContributionMapper(int top, int bottom, bool normalize);
    private sealed virtual override JToken Microsoft.ML.Model.Pfa.ISingleCanSavePfa.SaveAsPfa(BoundPfaContext ctx, JToken input);
    private sealed virtual override void Microsoft.ML.Model.Pfa.IDistCanSavePfa.SaveAsPfa(BoundPfaContext ctx, JToken input, string score, JToken& scoreToken, string prob, JToken& probToken);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.IDistCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, String[] outputNames, string featureColumnName);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ISingleCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, String[] outputNames, string featureColumnName);
}
public class Microsoft.ML.ClusteringCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private ClusteringTrainers <Trainers>k__BackingField;
    public ClusteringTrainers Trainers { get; }
    internal ClusteringCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public ClusteringTrainers get_Trainers();
    public ClusteringMetrics Evaluate(IDataView data, string labelColumnName, string scoreColumnName, string featureColumnName);
    public IReadOnlyList`1<CrossValidationResult`1<ClusteringMetrics>> CrossValidate(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string featuresColumnName, string samplingKeyColumnName, Nullable`1<int> seed);
}
[ExtensionAttribute]
public static class Microsoft.ML.ConversionsExtensionsCatalog : object {
    [ExtensionAttribute]
public static HashingEstimator Hash(ConversionTransforms catalog, string outputColumnName, string inputColumnName, int numberOfBits, int maximumNumberOfInverts);
    [ExtensionAttribute]
public static HashingEstimator Hash(ConversionTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static TypeConvertingEstimator ConvertType(ConversionTransforms catalog, string outputColumnName, string inputColumnName, DataKind outputKind);
    [ExtensionAttribute]
public static TypeConvertingEstimator ConvertType(ConversionTransforms catalog, InputOutputColumnPair[] columns, DataKind outputKind);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static TypeConvertingEstimator ConvertType(ConversionTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static KeyToValueMappingEstimator MapKeyToValue(ConversionTransforms catalog, string outputColumnName, string inputColumnName);
    [ExtensionAttribute]
public static KeyToValueMappingEstimator MapKeyToValue(ConversionTransforms catalog, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static KeyToVectorMappingEstimator MapKeyToVector(ConversionTransforms catalog, ColumnOptions[] columns);
    [ExtensionAttribute]
public static KeyToVectorMappingEstimator MapKeyToVector(ConversionTransforms catalog, string outputColumnName, string inputColumnName, bool outputCountVector);
    [ExtensionAttribute]
public static KeyToVectorMappingEstimator MapKeyToVector(ConversionTransforms catalog, InputOutputColumnPair[] columns, bool outputCountVector);
    [ExtensionAttribute]
public static ValueToKeyMappingEstimator MapValueToKey(ConversionTransforms catalog, string outputColumnName, string inputColumnName, int maximumNumberOfKeys, KeyOrdinality keyOrdinality, bool addKeyValueAnnotationsAsText, IDataView keyData);
    [ExtensionAttribute]
public static ValueToKeyMappingEstimator MapValueToKey(ConversionTransforms catalog, InputOutputColumnPair[] columns, int maximumNumberOfKeys, KeyOrdinality keyOrdinality, bool addKeyValueAnnotationsAsText, IDataView keyData);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ValueToKeyMappingEstimator MapValueToKey(ConversionTransforms catalog, ColumnOptions[] columns, IDataView keyData);
    [ExtensionAttribute]
public static ValueMappingEstimator`2<TInputType, TOutputType> MapValue(ConversionTransforms catalog, string outputColumnName, IEnumerable`1<KeyValuePair`2<TInputType, TOutputType>> keyValuePairs, string inputColumnName, bool treatValuesAsKeyType);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ValueMappingEstimator`2<TInputType, TOutputType> MapValue(ConversionTransforms catalog, IEnumerable`1<KeyValuePair`2<TInputType, TOutputType>> keyValuePairs, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ValueMappingEstimator`2<TInputType, TOutputType> MapValue(ConversionTransforms catalog, IEnumerable`1<KeyValuePair`2<TInputType, TOutputType>> keyValuePairs, bool treatValuesAsKeyType, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static ValueMappingEstimator`2<TInputType, TOutputType> MapValue(ConversionTransforms catalog, string outputColumnName, IEnumerable`1<KeyValuePair`2<TInputType, TOutputType[]>> keyValuePairs, string inputColumnName);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ValueMappingEstimator`2<TInputType, TOutputType> MapValue(ConversionTransforms catalog, IEnumerable`1<KeyValuePair`2<TInputType, TOutputType[]>> keyValuePairs, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static ValueMappingEstimator MapValue(ConversionTransforms catalog, string outputColumnName, IDataView lookupMap, Column keyColumn, Column valueColumn, string inputColumnName);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ValueMappingEstimator MapValue(ConversionTransforms catalog, IDataView lookupMap, Column keyColumn, Column valueColumn, InputOutputColumnPair[] columns);
}
internal abstract class Microsoft.ML.Data.AnnotationInfo : object {
    public DataViewType AnnotationType;
    public string Kind;
    private protected AnnotationInfo(string kind, DataViewType annotationType);
    public abstract virtual ValueGetter`1<TDst> GetGetter();
    internal abstract virtual Delegate GetGetterDelegate();
}
internal class Microsoft.ML.Data.AnnotationInfo`1 : AnnotationInfo {
    private static FuncInstanceMethodInfo1`2<AnnotationInfo`1<T>, Delegate> _getArrayGetterMethodInfo;
    private static FuncInstanceMethodInfo1`2<AnnotationInfo`1<T>, Delegate> _getGetterCoreMethodInfo;
    private static FuncInstanceMethodInfo1`2<AnnotationInfo`1<T>, Delegate> _getVBufferGetterMethodInfo;
    public T Value;
    public AnnotationInfo`1(string kind, T value, DataViewType annotationType);
    private static AnnotationInfo`1();
    public virtual ValueGetter`1<TDst> GetGetter();
    private Delegate GetGetterCore();
    internal virtual Delegate GetGetterDelegate();
    private void GetStringArray(VBuffer`1& dst);
    private ValueGetter`1<VBuffer`1<TDst>> GetArrayGetter();
    private ValueGetter`1<VBuffer`1<TDst>> GetVBufferGetter();
    private void GetString(ReadOnlyMemory`1& dst);
    private void GetDirectValue(TDst& dst);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.AnomalyDetectionEvaluator : EvaluatorBase`1<Aggregator> {
    public static string LoadName;
    public static string TopKResults;
    private int _k;
    private double _p;
    private int _numTopResults;
    private bool _streaming;
    private int _aucCount;
    public AnomalyDetectionEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    internal virtual IDataTransform GetPerInstanceMetricsCore(RoleMappedData data);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.AnomalyDetectionEvaluator/<GetOverallMetricColumns>d__14")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
    internal AnomalyDetectionMetrics Evaluate(IDataView data, string label, string score, string predictedLabel);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.AnomalyDetectionMamlEvaluator : MamlEvaluatorBase {
    private static string FoldDrAtKFormat;
    private static string FoldDrAtPFormat;
    private static string FoldDrAtNumAnomaliesFormat;
    private AnomalyDetectionEvaluator _evaluator;
    private int _topScored;
    private int _k;
    private double _p;
    private protected IEvaluator Evaluator { get; }
    public AnomalyDetectionMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
    private protected virtual IDataView GetOverallResultsCore(IDataView overall);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.AnomalyDetectionMamlEvaluator/<GetPerInstanceColumnsToSave>d__13")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.AnomalyDetectionMamlEvaluator/<GetOverallMetricColumns>d__14")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
}
public class Microsoft.ML.Data.AnomalyDetectionMetrics : object {
    [CompilerGeneratedAttribute]
private double <AreaUnderRocCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DetectionRateAtFalsePositiveCount>k__BackingField;
    public double AreaUnderRocCurve { get; }
    public double DetectionRateAtFalsePositiveCount { get; }
    internal AnomalyDetectionMetrics(IExceptionContext ectx, DataViewRow overallResult);
    [CompilerGeneratedAttribute]
public double get_AreaUnderRocCurve();
    [CompilerGeneratedAttribute]
public double get_DetectionRateAtFalsePositiveCount();
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__FetchDouble|6_0(string name, <>c__DisplayClass6_0& );
}
internal static class Microsoft.ML.Data.AnomalyPredictionTransformer : object {
    public static string LoaderSignature;
    public static AnomalyPredictionTransformer`1<IPredictorProducing`1<float>> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.AnomalyPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    internal string ThresholdColumn;
    internal float Threshold;
    [BestFriendAttribute]
internal AnomalyPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn, float threshold, string thresholdColumn);
    internal AnomalyPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    private void SetScorer();
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.AppendRowsDataView : object {
    public static string RegistrationName;
    private IDataView[] _sources;
    private Int32[] _counts;
    private IHost _host;
    [CompilerGeneratedAttribute]
private bool <CanShuffle>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    private AppendRowsDataView(IHostEnvironment env, DataViewSchema schema, IDataView[] sources);
    [CompilerGeneratedAttribute]
public sealed virtual bool get_CanShuffle();
    [CompilerGeneratedAttribute]
public sealed virtual DataViewSchema get_Schema();
    public static IDataView Create(IHostEnvironment env, DataViewSchema schema, IDataView[] sources);
    private void CheckSchemaConsistency();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ApplyTransformUtils : object {
    public static IDataTransform ApplyTransformToData(IHostEnvironment env, IDataTransform transform, IDataView newSource);
    public static IDataView ApplyAllTransformsToData(IHostEnvironment env, IDataView chain, IDataView newSource, IDataView oldSource);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ArrayDataViewBuilder : object {
    private IHost _host;
    private List`1<Column> _columns;
    private List`1<string> _names;
    private Dictionary`2<string, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>>> _getSlotNames;
    private Dictionary`2<string, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>>> _getKeyValues;
    private Nullable`1<int> RowCount { get; }
    public ArrayDataViewBuilder(IHostEnvironment env);
    private Nullable`1<int> get_RowCount();
    private void CheckLength(string name, T[] values);
    public void AddColumn(string name, PrimitiveDataViewType type, T[] values);
    public void AddColumn(string name, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> getKeyValues, ulong keyCount, T1[] values);
    public void AddColumn(string name, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> getNames, PrimitiveDataViewType itemType, T[][] values);
    public void AddColumn(string name, PrimitiveDataViewType itemType, T[][] values);
    public void AddColumn(string name, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> getNames, PrimitiveDataViewType itemType, Combiner`1<T> combiner, T[][] values);
    public void AddColumn(string name, PrimitiveDataViewType itemType, Combiner`1<T> combiner, T[][] values);
    public void AddColumn(string name, PrimitiveDataViewType itemType, VBuffer`1[] values);
    public void AddColumn(string name, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> getNames, PrimitiveDataViewType itemType, VBuffer`1[] values);
    public void AddColumn(string name, String[] values);
    public IDataView GetDataView(Nullable`1<int> rowCount);
}
public class Microsoft.ML.Data.BinaryClassificationMetrics : object {
    [CompilerGeneratedAttribute]
private double <AreaUnderRocCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Accuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PositivePrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private double <PositiveRecall>k__BackingField;
    [CompilerGeneratedAttribute]
private double <NegativePrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private double <NegativeRecall>k__BackingField;
    [CompilerGeneratedAttribute]
private double <F1Score>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AreaUnderPrecisionRecallCurve>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfusionMatrix <ConfusionMatrix>k__BackingField;
    public double AreaUnderRocCurve { get; }
    public double Accuracy { get; }
    public double PositivePrecision { get; }
    public double PositiveRecall { get; private set; }
    public double NegativePrecision { get; }
    public double NegativeRecall { get; }
    public double F1Score { get; }
    public double AreaUnderPrecisionRecallCurve { get; }
    public ConfusionMatrix ConfusionMatrix { get; }
    internal BinaryClassificationMetrics(IHost host, DataViewRow overallResult, IDataView confusionMatrix);
    [BestFriendAttribute]
internal BinaryClassificationMetrics(double auc, double accuracy, double positivePrecision, double positiveRecall, double negativePrecision, double negativeRecall, double f1Score, double auprc);
    internal BinaryClassificationMetrics(double auc, double accuracy, double positivePrecision, double positiveRecall, double negativePrecision, double negativeRecall, double f1Score, double auprc, ConfusionMatrix confusionMatrix);
    [CompilerGeneratedAttribute]
public double get_AreaUnderRocCurve();
    [CompilerGeneratedAttribute]
public double get_Accuracy();
    [CompilerGeneratedAttribute]
public double get_PositivePrecision();
    [CompilerGeneratedAttribute]
public double get_PositiveRecall();
    [CompilerGeneratedAttribute]
private void set_PositiveRecall(double value);
    [CompilerGeneratedAttribute]
public double get_NegativePrecision();
    [CompilerGeneratedAttribute]
public double get_NegativeRecall();
    [CompilerGeneratedAttribute]
public double get_F1Score();
    [CompilerGeneratedAttribute]
public double get_AreaUnderPrecisionRecallCurve();
    [CompilerGeneratedAttribute]
public ConfusionMatrix get_ConfusionMatrix();
    private protected static T Fetch(IExceptionContext ectx, DataViewRow row, string name);
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__Fetch|29_0(string name, <>c__DisplayClass29_0& );
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.BinaryClassifierEvaluator : RowToRowEvaluatorBase`1<Aggregator> {
    public static string LoadName;
    public static string Accuracy;
    public static string PosPrecName;
    public static string PosRecallName;
    public static string NegPrecName;
    public static string NegRecallName;
    public static string Auc;
    public static string LogLoss;
    public static string LogLossReduction;
    public static string Entropy;
    public static string F1;
    public static string AuPrc;
    public static string PrCurve;
    public static string Precision;
    public static string Recall;
    public static string FalsePositiveRate;
    public static string Threshold;
    private float _threshold;
    private bool _useRaw;
    private int _prCount;
    private int _aucCount;
    private int _auPrcCount;
    public BinaryClassifierEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual void CheckCustomColumnTypesCore(RoleMappedSchema schema);
    private protected virtual Func`2<int, bool> GetActiveColsCore(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    private ReadOnlyMemory`1[] GetClassNames(RoleMappedSchema schema);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.BinaryClassifierEvaluator/<GetOverallMetricColumns>d__31")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
    public CalibratedBinaryClassificationMetrics Evaluate(IDataView data, string label, string score, string probability, string predictedLabel);
    public CalibratedBinaryClassificationMetrics EvaluateWithPRCurve(IDataView data, string label, string score, string probability, string predictedLabel, List`1& prCurve);
    private void GetPrecisionRecallDataPointGetters(IDataView prCurveView, DataViewRowCursor cursor, ValueGetter`1& thresholdGetter, ValueGetter`1& precisionGetter, ValueGetter`1& recallGetter, ValueGetter`1& fprGetter);
    public BinaryClassificationMetrics Evaluate(IDataView data, string label, string score, string predictedLabel);
    public BinaryClassificationMetrics EvaluateWithPRCurve(IDataView data, string label, string score, string predictedLabel, List`1& prCurve);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.BinaryClassifierMamlEvaluator : MamlEvaluatorBase {
    private static string FoldAccuracy;
    private static string FoldLogLoss;
    private static string FoldLogLosRed;
    private BinaryClassifierEvaluator _evaluator;
    private string _prFileName;
    private string _probCol;
    private protected IEvaluator Evaluator { get; }
    public BinaryClassifierMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    private protected virtual IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRolesCore(RoleMappedSchema schema);
    private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
    private protected virtual IDataView GetOverallResultsCore(IDataView overall);
    private protected virtual void PrintAdditionalMetricsCore(IChannel ch, Dictionary`2[] metrics);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.BinaryClassifierMamlEvaluator/<GetOverallMetricColumns>d__14")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private bool TryGetPrMetrics(Dictionary`2[] metrics, IDataView& pr);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.BinaryClassifierMamlEvaluator/<GetPerInstanceColumnsToSave>d__16")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.BinaryClassifierScorer : PredictedLabelScorerBase {
    public static string LoaderSignature;
    private static string RegistrationName;
    private float _threshold;
    [BestFriendAttribute]
internal BinaryClassifierScorer(IHostEnvironment env, Arguments args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private BinaryClassifierScorer(IHostEnvironment env, BinaryClassifierScorer transform, IDataView newSource);
    private BinaryClassifierScorer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    private static ISchemaBoundMapper WrapIfNeeded(IHostEnvironment env, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private static bool CanWrap(ISchemaBoundMapper mapper, DataViewType labelNameType);
    private static ISchemaBoundMapper WrapCore(IHostEnvironment env, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    public static BinaryClassifierScorer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private protected virtual void SaveAsOnnxCore(OnnxContext ctx);
    private protected virtual IDataTransform ApplyToDataCore(IHostEnvironment env, IDataView newSource);
    protected virtual Delegate GetPredictedLabelGetter(DataViewRow output, Delegate& scoreGetter);
    private void GetPredictedLabelCore(float score, Boolean& value);
    private void GetPredictedLabelCoreAsKey(float score, UInt32& value);
    private protected virtual JToken PredictedLabelPfa(String[] mapperOutputs);
    private static DataViewType GetPredColType(DataViewType scoreType, ISchemaBoundRowMapper mapper);
    private static bool OutputTypeMatches(DataViewType scoreType);
}
internal class Microsoft.ML.Data.BinaryPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int AssignedCol;
    private static int LogLossCol;
    public static string LogLoss;
    public static string Assigned;
    private string _probCol;
    private int _probIndex;
    private float _threshold;
    private bool _useRaw;
    private DataViewType[] _types;
    public BinaryPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, string scoreCol, string probCol, string labelCol, float threshold, bool useRaw);
    private BinaryPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static BinaryPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private double GetLogLoss(float prob, float label);
    private bool GetPredictedLabel(float val);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private void CheckInputColumnTypes(DataViewSchema schema);
}
public class Microsoft.ML.Data.BinaryPrecisionRecallDataPoint : object {
    [CompilerGeneratedAttribute]
private double <Threshold>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Precision>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Recall>k__BackingField;
    [CompilerGeneratedAttribute]
private double <FalsePositiveRate>k__BackingField;
    public double Threshold { get; }
    public double Precision { get; }
    public double Recall { get; }
    public double TruePositiveRate { get; }
    public double FalsePositiveRate { get; }
    internal BinaryPrecisionRecallDataPoint(ValueGetter`1<float> thresholdGetter, ValueGetter`1<double> precisionGetter, ValueGetter`1<double> recallGetter, ValueGetter`1<double> fprGetter);
    [CompilerGeneratedAttribute]
public double get_Threshold();
    [CompilerGeneratedAttribute]
public double get_Precision();
    [CompilerGeneratedAttribute]
public double get_Recall();
    public double get_TruePositiveRate();
    [CompilerGeneratedAttribute]
public double get_FalsePositiveRate();
}
internal static class Microsoft.ML.Data.BinaryPredictionTransformer : object {
    public static string LoaderSignature;
    private static string DirModel;
    public static ISingleFeaturePredictionTransformer`1<object> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.BinaryPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    internal string ThresholdColumn;
    internal float Threshold;
    internal string LabelColumnName;
    [BestFriendAttribute]
internal BinaryPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn, float threshold, string thresholdColumn);
    internal BinaryPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn, string labelColumn, float threshold, string thresholdColumn);
    internal BinaryPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    internal BinaryPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx, IHost host, TModel model);
    private void InitializationLogic(ModelLoadContext ctx, Single& threshold, String& thresholdcolumn);
    private void SetScorer();
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
internal class Microsoft.ML.Data.BindingsWrappedRowCursor : SynchronizedCursorBase {
    private ColumnBindingsBase _bindings;
    public DataViewSchema Schema { get; }
    public BindingsWrappedRowCursor(IChannelProvider provider, DataViewRowCursor input, ColumnBindingsBase bindings);
    public virtual DataViewSchema get_Schema();
    public virtual bool IsColumnActive(Column column);
    public virtual ValueGetter`1<TValue> GetGetter(Column column);
}
internal class Microsoft.ML.Data.BlockingQueue`1 : object {
    private ConcurrentQueue`1<T> _queue;
    private CompletableSemaphore<T> _itemsAvailable;
    private CompletableSemaphore<T> _spaceAvailable;
    public BlockingQueue`1(int boundedCapacity);
    public sealed virtual void Dispose();
    public bool TryAdd(T item, int millisecondsTimeout);
    public bool TryTake(T& item, int millisecondsTimeout);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.BlockingQueue`1/<GetConsumingEnumerable>d__7")]
public IEnumerable`1<T> GetConsumingEnumerable();
    public void CompleteAdding();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.BufferBuilder`1 : object {
    private static int InsertThreshold;
    private Combiner`1<T> _comb;
    private int _length;
    private bool _dense;
    private bool _sorted;
    private int _count;
    private Int32[] _indices;
    private T[] _values;
    private int _ifeatCur;
    private int _cfeatCur;
    public bool IsEmpty { get; }
    public int Length { get; }
    public BufferBuilder`1(Combiner`1<T> comb);
    public bool get_IsEmpty();
    public int get_Length();
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    public static BufferBuilder`1<T> CreateDefault();
    private void ResetImpl(int length, bool dense);
    private void SetActiveRangeImpl(int ifeat, int cfeat);
    public void AddFeature(int index, T value);
    private void SortAndSumDups();
    private void MakeDense();
    public bool TryGetFeature(int index, T& v);
    public void Reset(int length, bool dense);
    public void AddFeatures(int index, VBuffer`1& buffer);
    public void GetResult(VBuffer`1& buffer);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.CacheDataView : object {
    private IHost _host;
    private IDataView _subsetInput;
    private long _rowCount;
    private Int32[] _inputToSubsetColIndex;
    private static int _batchShift;
    private static int _batchSize;
    private static int _batchMask;
    private object _cacheLock;
    private ConcurrentBag`1<Task> _cacheFillerThreads;
    private ColumnCache[] _caches;
    private OrderedWaiter modreq(System.Runtime.CompilerServices.IsVolatile) _cacheDefaultWaiter;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    public CacheDataView(IHostEnvironment env, IDataView input, Int32[] prefetch);
    private static IDataView SelectCachableColumns(IDataView data, IHostEnvironment env, Int32[]& prefetch, Int32[]& inputToSubset);
    public int MapInputToCacheColumnIndex(int inputIndex);
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    private Int32[] GetPermutationOrNull(Random rand);
    private DataViewRowCursor GetRowCursorWaiterCore(TWaiter waiter, Func`2<int, bool> predicate, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private DataViewRowCursor[] GetRowCursorSetWaiterCore(TWaiter waiter, Func`2<int, bool> predicate, int n, Random rand);
    private DataViewRowCursor CreateCursor(Func`2<int, bool> predicate, TIndex index);
    public sealed virtual RowSeeker GetSeeker(Func`2<int, bool> predicate);
    private RowSeeker GetSeeker(Func`2<int, bool> predicate, TWaiter waiter);
    private void KickoffFiller(Int32[] columns);
    private void Filler(DataViewRowCursor cursor, ColumnCache[] caches, OrderedWaiter waiter);
    internal void Wait();
}
public class Microsoft.ML.Data.CalibratedBinaryClassificationMetrics : BinaryClassificationMetrics {
    [CompilerGeneratedAttribute]
private double <LogLoss>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LogLossReduction>k__BackingField;
    [CompilerGeneratedAttribute]
private double <Entropy>k__BackingField;
    public double LogLoss { get; }
    public double LogLossReduction { get; }
    public double Entropy { get; }
    internal CalibratedBinaryClassificationMetrics(IHost host, DataViewRow overallResult, IDataView confusionMatrix);
    [CompilerGeneratedAttribute]
public double get_LogLoss();
    [CompilerGeneratedAttribute]
public double get_LogLossReduction();
    [CompilerGeneratedAttribute]
public double get_Entropy();
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__Fetch|9_0(string name, <>c__DisplayClass9_0& );
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.CatalogUtils : object {
    [ExtensionAttribute]
public static IHostEnvironment GetEnvironment(IInternalCatalog catalog);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ChooseColumnsByIndexTransform : RowToRowTransformBase {
    public static string LoaderSignature;
    internal static string LoaderSignatureOld;
    private Bindings _bindings;
    private static string RegistrationName;
    public DataViewSchema OutputSchema { get; }
    public ChooseColumnsByIndexTransform(IHostEnvironment env, Options options, IDataView input);
    private ChooseColumnsByIndexTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static ChooseColumnsByIndexTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual DataViewSchema get_OutputSchema();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ClusteringEvaluator : RowToRowEvaluatorBase`1<Aggregator> {
    public static string LoadName;
    public static string Nmi;
    public static string AvgMinScore;
    public static string Dbi;
    private bool _calculateDbi;
    public ClusteringEvaluator(IHostEnvironment env, Arguments args);
    public ClusteringMetrics Evaluate(IDataView data, string score, string label, string features);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual void CheckCustomColumnTypesCore(RoleMappedSchema schema);
    private protected virtual Func`2<int, bool> GetActiveColsCore(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ClusteringEvaluator/<GetOverallMetricColumns>d__13")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ClusteringMamlEvaluator : MamlEvaluatorBase {
    private ClusteringEvaluator _evaluator;
    private int _numTopClusters;
    private string _featureCol;
    private bool _calculateDbi;
    private protected IEvaluator Evaluator { get; }
    public ClusteringMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ClusteringMamlEvaluator/<GetInputColumnRolesCore>d__8")]
private protected virtual IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRolesCore(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ClusteringMamlEvaluator/<GetPerInstanceColumnsToSave>d__9")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
    private protected virtual IDataView GetPerInstanceMetricsCore(IDataView perInst, RoleMappedSchema schema);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private IEnumerable`1<KeyValuePair`2<ColumnRole, string>> <>n__0(RoleMappedSchema schema);
}
public class Microsoft.ML.Data.ClusteringMetrics : object {
    [CompilerGeneratedAttribute]
private double <NormalizedMutualInformation>k__BackingField;
    [CompilerGeneratedAttribute]
private double <AverageDistance>k__BackingField;
    [CompilerGeneratedAttribute]
private double <DaviesBouldinIndex>k__BackingField;
    public double NormalizedMutualInformation { get; }
    public double AverageDistance { get; }
    public double DaviesBouldinIndex { get; }
    internal ClusteringMetrics(IExceptionContext ectx, DataViewRow overallResult, bool calculateDbi);
    internal ClusteringMetrics(double nmi, double avgMinScore, double dbi);
    [CompilerGeneratedAttribute]
public double get_NormalizedMutualInformation();
    [CompilerGeneratedAttribute]
public double get_AverageDistance();
    [CompilerGeneratedAttribute]
public double get_DaviesBouldinIndex();
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__Fetch|9_0(string name, <>c__DisplayClass9_0& );
}
internal class Microsoft.ML.Data.ClusteringPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int ClusterIdCol;
    private static int SortedClusterCol;
    private static int SortedClusterScoreCol;
    public static string ClusterId;
    public static string SortedClusters;
    public static string SortedClusterScores;
    private int _numClusters;
    private DataViewType[] _types;
    public ClusteringPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, string scoreCol, int numClusters);
    private ClusteringPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static ClusteringPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> CreateSlotNamesGetter(int numTopClusters, string suffix);
    private void CheckInputColumnTypes(DataViewSchema schema);
}
internal static class Microsoft.ML.Data.ClusteringPredictionTransformer : object {
    public static string LoaderSignature;
    public static ClusteringPredictionTransformer`1<IPredictorProducing`1<VBuffer`1<float>>> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.ClusteringPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    [BestFriendAttribute]
internal ClusteringPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn, float threshold, string thresholdColumn);
    internal ClusteringPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
internal class Microsoft.ML.Data.ClusteringScorer : PredictedLabelScorerBase {
    public static string LoaderSignature;
    private static string RegistrationName;
    [BestFriendAttribute]
internal ClusteringScorer(IHostEnvironment env, Arguments args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private ClusteringScorer(IHostEnvironment env, ClusteringScorer transform, IDataView newSource);
    private ClusteringScorer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static ClusteringScorer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private protected virtual IDataTransform ApplyToDataCore(IHostEnvironment env, IDataView newSource);
    protected virtual Delegate GetPredictedLabelGetter(DataViewRow output, Delegate& scoreGetter);
    private protected virtual JToken PredictedLabelPfa(String[] mapperOutputs);
    private static DataViewType GetPredColType(DataViewType scoreType, ISchemaBoundRowMapper mapper);
    private static bool OutputTypeMatches(DataViewType scoreType);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ColumnBindings : object {
    private Int32[] _colMap;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<int> <AddedColumnIndices>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewSchema <InputSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    public IReadOnlyList`1<int> AddedColumnIndices { get; }
    public DataViewSchema InputSchema { get; }
    public DataViewSchema Schema { get; }
    public ColumnBindings(DataViewSchema input, DetachedColumn[] addedColumns);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<int> get_AddedColumnIndices();
    [CompilerGeneratedAttribute]
public DataViewSchema get_InputSchema();
    [CompilerGeneratedAttribute]
public DataViewSchema get_Schema();
    public int MapColumnIndex(Boolean& isSrcColumn, int col);
    public Boolean[] GetActiveInput(Func`2<int, bool> predicate);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.ColumnBindingsBase : object {
    public DataViewSchema Input;
    private Dictionary`2<string, int> _nameToInfoIndex;
    private String[] _names;
    private Int32[] _mapIinfoToCol;
    private Int32[] _colMap;
    private Lazy`1<DataViewSchema> _convertedSchema;
    public DataViewSchema AsSchema { get; }
    public int ColumnCount { get; }
    public int InfoCount { get; }
    protected ColumnBindingsBase(DataViewSchema input, bool user, String[] names);
    public DataViewSchema get_AsSchema();
    private static DataViewSchema CreateSchema(ColumnBindingsBase inputBindings);
    private static Delegate GetAnnotationGetterDelegate(ColumnBindingsBase bindings, int col, string kind);
    private static void ComputeColumnMapping(DataViewSchema input, String[] names, Int32[]& colMap, Int32[]& mapIinfoToCol);
    public int get_ColumnCount();
    public int get_InfoCount();
    public int MapColumnIndex(Boolean& isSrcColumn, int col);
    public int MapIinfoToCol(int iinfo);
    public bool TryGetColumnIndex(string name, Int32& col);
    public string GetColumnName(int col);
    public DataViewType GetColumnType(int col);
    public IEnumerable`1<KeyValuePair`2<string, DataViewType>> GetAnnotationTypes(int col);
    public DataViewType GetAnnotationTypeOrNull(string kind, int col);
    public void GetAnnotation(string kind, int col, TValue& value);
    protected bool TryGetColumnIndexCore(string name, Int32& iinfo);
    protected string GetColumnNameCore(int iinfo);
    protected abstract virtual DataViewType GetColumnTypeCore(int iinfo);
    protected virtual IEnumerable`1<KeyValuePair`2<string, DataViewType>> GetAnnotationTypesCore(int iinfo);
    protected virtual DataViewType GetAnnotationTypeCore(string kind, int iinfo);
    protected virtual void GetAnnotationCore(string kind, int iinfo, TValue& value);
    public Boolean[] GetActive(Func`2<int, bool> predicate);
    public Boolean[] GetActive(IEnumerable`1<Column> columns);
    public Boolean[] GetActiveInput(Func`2<int, bool> predicate);
    public Boolean[] GetActiveInput(IEnumerable`1<Column> inputColumns);
    public bool AnyNewColumnsActive(Func`2<int, bool> predicate);
    [CompilerGeneratedAttribute]
private DataViewSchema <.ctor>b__10_0();
}
public class Microsoft.ML.Data.ColumnConcatenatingTransformer : RowToRowTransformerBase {
    internal static string Summary;
    internal static string UserName;
    internal static string LoadName;
    internal static string LoaderSignature;
    internal static string LoaderSignatureOld;
    private ColumnOptions[] _columns;
    private static int VersionAddedAliases;
    private static int VersionTransformer;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, String[]>> Columns { get; }
    internal ColumnConcatenatingTransformer(IHostEnvironment env, string outputColumnName, String[] inputColumnNames);
    internal ColumnConcatenatingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private ColumnConcatenatingTransformer(IHostEnvironment env, ModelLoadContext ctx);
    internal IReadOnlyCollection`1<ValueTuple`2<string, String[]>> get_Columns();
    private static VersionInfo GetVersionInfo();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private ColumnOptions[] LoadLegacy(ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    [BestFriendAttribute]
internal static IDataTransform Create(IHostEnvironment env, TaggedOptions options, IDataView input);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema inputSchema);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
}
[ExtensionAttribute]
public static class Microsoft.ML.Data.ColumnCursorExtensions : object {
    [ExtensionAttribute]
public static IEnumerable`1<T> GetColumn(IDataView data, string columnName);
    [ExtensionAttribute]
public static IEnumerable`1<T> GetColumn(IDataView data, Column column);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ColumnCursorExtensions/<GetColumnDirect>d__2`1")]
private static IEnumerable`1<T> GetColumnDirect(IDataView data, int col);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ColumnCursorExtensions/<GetColumnConvert>d__3`2")]
private static IEnumerable`1<TOut> GetColumnConvert(IDataView data, int col, Func`2<TData, TOut> convert);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ColumnCursorExtensions/<GetColumnArrayDirect>d__4`1")]
private static IEnumerable`1<T[]> GetColumnArrayDirect(IDataView data, int col);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ColumnCursorExtensions/<GetColumnArrayConvert>d__5`2")]
private static IEnumerable`1<TOut[]> GetColumnArrayConvert(IDataView data, int col, Func`2<TData, TOut> convert);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.ColumnNameAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    internal string Name { get; }
    public ColumnNameAttribute(string name);
    [CompilerGeneratedAttribute]
internal string get_Name();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ColumnParsingUtils : object {
    public static bool TryParse(string str, String& name, String& source);
    public static bool TryParse(string str, String& name, String& source, String& extra);
}
internal abstract class Microsoft.ML.Data.Combiner`1 : object {
    public abstract virtual bool IsDefault(T value);
    public abstract virtual void Combine(T& dst, T src);
}
internal class Microsoft.ML.Data.Commands.TypeInfoCommand : object {
    private static FuncInstanceMethodInfo1`4<TypeInfoCommand, IChannel, PrimitiveDataViewType, TypeNaInfo> _kindReportMethodInfo;
    internal static string LoadName;
    internal static string Summary;
    private IHost _host;
    public TypeInfoCommand(IHostEnvironment env, Arguments args);
    private static TypeInfoCommand();
    public sealed virtual void Run();
    private TypeNaInfo KindReport(IChannel ch, PrimitiveDataViewType type);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ComponentCreation : object {
    [ExtensionAttribute]
public static IDataView Zip(IHostEnvironment env, IEnumerable`1<IDataView> sources);
    [ExtensionAttribute]
public static RoleMappedData CreateExamples(IHostEnvironment env, IDataView data, string features, string label, string group, string weight, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> custom);
    [ExtensionAttribute]
public static IDataView LoadTransforms(IHostEnvironment env, Stream modelStream, IDataView data);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ILegacyDataLoader CreateLoader(IHostEnvironment env, TArgs arguments, IMultiStreamSource files);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ILegacyDataLoader CreateLoader(IHostEnvironment env, string settings, IMultiStreamSource files);
    [ExtensionAttribute]
public static IDataSaver CreateSaver(IHostEnvironment env, TArgs arguments);
    [ExtensionAttribute]
public static IDataSaver CreateSaver(IHostEnvironment env, string settings);
    [ExtensionAttribute]
public static IDataTransform CreateTransform(IHostEnvironment env, TArgs arguments, IDataView source);
    [ExtensionAttribute]
public static IDataTransform CreateTransform(IHostEnvironment env, string settings, IDataView source);
    [ExtensionAttribute]
public static IDataScorerTransform CreateScorer(IHostEnvironment env, string settings, RoleMappedData data, IPredictor predictor, RoleMappedSchema trainSchema);
    [ExtensionAttribute]
public static IDataScorerTransform CreateDefaultScorer(IHostEnvironment env, RoleMappedData data, IPredictor predictor, RoleMappedSchema trainSchema);
    [ExtensionAttribute]
public static IEvaluator CreateEvaluator(IHostEnvironment env, string settings);
    [ExtensionAttribute]
public static IPredictor LoadPredictorOrNull(IHostEnvironment env, Stream modelStream);
    [ExtensionAttribute]
public static ITrainer CreateTrainer(IHostEnvironment env, TArgs arguments, String& loadName);
    [ExtensionAttribute]
public static ITrainer CreateTrainer(IHostEnvironment env, string settings, String& loadName);
    private static TRes CreateCore(IHostEnvironment env, Type signatureType, string settings, Object[] extraArgs);
    private static TRes CreateCore(IHostEnvironment env, Type signatureType, string settings, String& loadName, Object[] extraArgs);
    private static TRes CreateCore(IHostEnvironment env, Type factoryType, Type signatureType, string settings, Object[] extraArgs);
    private static TRes CreateCore(IHostEnvironment env, TArgs args, Object[] extraArgs);
    private static TRes CreateCore(IHostEnvironment env, Type factoryType, Type signatureType, string settings, String& loadName, Object[] extraArgs);
    private static TRes CreateCore(IHostEnvironment env, TArgs args, String& loadName, Object[] extraArgs);
}
public class Microsoft.ML.Data.CompositeDataLoader`2 : object {
    internal static string TransformerDirectory;
    private static string LoaderDirectory;
    private static string LegacyLoaderDirectory;
    public IDataLoader`1<TSource> Loader;
    public TransformerChain`1<TLastTransformer> Transformer;
    internal static string Summary;
    internal static string LoaderSignature;
    private bool _disposed;
    public CompositeDataLoader`2(IDataLoader`1<TSource> loader, TransformerChain`1<TLastTransformer> transformerChain);
    private CompositeDataLoader`2(IHost host, ModelLoadContext ctx);
    private static CompositeDataLoader`2<TSource, TLastTransformer> Create(IHostEnvironment env, ModelLoadContext ctx);
    public sealed virtual IDataView Load(TSource input);
    public sealed virtual DataViewSchema GetOutputSchema();
    public CompositeDataLoader`2<TSource, TNewLast> AppendTransformer(TNewLast transformer);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
    public sealed virtual void Dispose();
}
public class Microsoft.ML.Data.CompositeLoaderEstimator`2 : object {
    private IDataLoaderEstimator`2<TSource, IDataLoader`1<TSource>> _start;
    private EstimatorChain`1<TLastTransformer> _estimatorChain;
    public CompositeLoaderEstimator`2(IDataLoaderEstimator`2<TSource, IDataLoader`1<TSource>> start, EstimatorChain`1<TLastTransformer> estimatorChain);
    public sealed virtual CompositeDataLoader`2<TSource, TLastTransformer> Fit(TSource input);
    public sealed virtual SchemaShape GetOutputSchema();
    public CompositeLoaderEstimator`2<TSource, TNewTrans> Append(IEstimator`1<TNewTrans> estimator);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.CompositeRowToRowMapper : object {
    [CompilerGeneratedAttribute]
private IRowToRowMapper[] <InnerMappers>k__BackingField;
    private static IRowToRowMapper[] _empty;
    [CompilerGeneratedAttribute]
private DataViewSchema <InputSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewSchema <OutputSchema>k__BackingField;
    private bool _disposed;
    [BestFriendAttribute]
internal IRowToRowMapper[] InnerMappers { get; }
    public DataViewSchema InputSchema { get; }
    public DataViewSchema OutputSchema { get; }
    public CompositeRowToRowMapper(DataViewSchema inputSchema, IRowToRowMapper[] mappers);
    private static CompositeRowToRowMapper();
    [CompilerGeneratedAttribute]
internal IRowToRowMapper[] get_InnerMappers();
    [CompilerGeneratedAttribute]
public sealed virtual DataViewSchema get_InputSchema();
    [CompilerGeneratedAttribute]
public sealed virtual DataViewSchema get_OutputSchema();
    private sealed virtual override IEnumerable`1<Column> Microsoft.ML.Data.IRowToRowMapper.GetDependencies(IEnumerable`1<Column> columnsNeeded);
    private sealed virtual override DataViewRow Microsoft.ML.Data.IRowToRowMapper.GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
    public sealed virtual void Dispose();
}
public class Microsoft.ML.Data.ConfusionMatrix : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <PerClassPrecision>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <PerClassRecall>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<IReadOnlyList`1<double>> <Counts>k__BackingField;
    [CompilerGeneratedAttribute]
private int <NumberOfClasses>k__BackingField;
    internal IReadOnlyList`1<ReadOnlyMemory`1<char>> PredictedClassesIndicators;
    internal bool IsSampled;
    internal bool IsBinary;
    private IHost _host;
    private string _formattedConfusionMatrix;
    public IReadOnlyList`1<double> PerClassPrecision { get; }
    public IReadOnlyList`1<double> PerClassRecall { get; }
    public IReadOnlyList`1<IReadOnlyList`1<double>> Counts { get; }
    public int NumberOfClasses { get; }
    internal ConfusionMatrix(IHost host, Double[] precision, Double[] recall, Double[][] confusionTableCounts, List`1<ReadOnlyMemory`1<char>> labelNames, bool isSampled, bool isBinary);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_PerClassPrecision();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_PerClassRecall();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<IReadOnlyList`1<double>> get_Counts();
    [CompilerGeneratedAttribute]
public int get_NumberOfClasses();
    public string GetFormattedConfusionTable();
    public double GetCountForClassPair(int predictedClassIndicatorIndex, int actualClassIndicatorIndex);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.Conversion.Conversions : object {
    private static FuncInstanceMethodInfo1`3<Conversions, KeyDataViewType, Delegate> _getKeyParseMethodInfo;
    private static Conversions modreq(System.Runtime.CompilerServices.IsVolatile) _defaultInstance;
    private OptionFlags _doubleParserOptionFlags;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, Type>, Delegate> _delegatesStd;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<Type, Type>, Delegate> _delegatesAll;
    private Dictionary`2<Type, Delegate> _isNADelegates;
    private Dictionary`2<Type, Delegate> _hasNADelegates;
    private Dictionary`2<Type, Delegate> _isDefaultDelegates;
    private Dictionary`2<Type, Delegate> _hasZeroDelegates;
    private Dictionary`2<Type, Delegate> _getNADelegates;
    private Dictionary`2<Type, Delegate> _tryParseDelegates;
    public static Conversions DefaultInstance { get; }
    private Conversions(OptionFlags doubleParserOptionFlags);
    private static Conversions();
    public static Conversions get_DefaultInstance();
    public static Conversions CreateInstanceWithDoubleParserOptions(OptionFlags doubleParserOptionFlags);
    private void AddStd(ValueMapper`2<TSrc, TDst> fn);
    private void AddAux(ValueMapper`2<TSrc, TDst> fn);
    private void AddIsNA(InPredicate`1<T> fn);
    private void AddGetNA(ValueGetter`1<T> fn);
    private void AddHasNA(InPredicate`1<VBuffer`1<T>> fn);
    private void AddIsDef(InPredicate`1<T> fn);
    private void AddHasZero(InPredicate`1<VBuffer`1<T>> fn);
    private void AddTryParse(TryParseMapper`1<T> fn);
    public ValueMapper`2<TSrc, TDst> GetStandardConversion(DataViewType typeSrc, DataViewType typeDst, Boolean& identity);
    public bool TryGetStandardConversion(DataViewType typeSrc, DataViewType typeDst, ValueMapper`2& conv, Boolean& identity);
    public Delegate GetStandardConversion(DataViewType typeSrc, DataViewType typeDst);
    public bool TryGetStandardConversion(DataViewType typeSrc, DataViewType typeDst, Delegate& conv, Boolean& identity);
    public ValueMapper`2<TSrc, StringBuilder> GetStringConversion(DataViewType type);
    public ValueMapper`2<TSrc, StringBuilder> GetStringConversion();
    public bool TryGetStringConversion(DataViewType type, ValueMapper`2& conv);
    private bool TryGetStringConversion(ValueMapper`2& conv);
    public ValueMapper`2<TSrc, StringBuilder> GetKeyStringConversion(KeyDataViewType key);
    public TryParseMapper`1<TDst> GetTryParseConversion(DataViewType typeDst);
    private TryParseMapper`1<TDst> GetKeyTryParse(KeyDataViewType key);
    private Delegate GetKeyParse(KeyDataViewType key);
    private ValueMapper`2<ReadOnlyMemory`1<char>, TDst> GetKeyParse(KeyDataViewType key);
    private ValueMapper`2<ulong, TDst> GetKeyStandardConversion();
    private static StringBuilder ClearDst(StringBuilder& dst);
    public InPredicate`1<T> GetIsDefaultPredicate(DataViewType type);
    public InPredicate`1<T> GetIsNAPredicate(DataViewType type);
    public bool TryGetIsNAPredicate(DataViewType type, InPredicate`1& pred);
    public bool TryGetIsNAPredicate(DataViewType type, Delegate& del);
    public InPredicate`1<VBuffer`1<T>> GetHasMissingPredicate(VectorDataViewType type);
    public T GetNAOrDefault(DataViewType type);
    public T GetNAOrDefault(DataViewType type, Boolean& isDefault);
    public ValueGetter`1<T> GetNAOrDefaultGetter(DataViewType type);
    private bool IsNA(Single& src);
    private bool IsNA(Double& src);
    private bool HasNA(VBuffer`1& src);
    private bool HasNA(VBuffer`1& src);
    private bool IsDefault(SByte& src);
    private bool IsDefault(Int16& src);
    private bool IsDefault(Int32& src);
    private bool IsDefault(Int64& src);
    private bool IsDefault(Single& src);
    private bool IsDefault(Double& src);
    private bool IsDefault(ReadOnlyMemory`1& src);
    private bool IsDefault(Boolean& src);
    private bool IsDefault(Byte& src);
    private bool IsDefault(UInt16& src);
    private bool IsDefault(UInt32& src);
    private bool IsDefault(UInt64& src);
    private bool IsDefault(DataViewRowId& src);
    private bool IsDefault(TimeSpan& src);
    private bool IsDefault(DateTime& src);
    private bool IsDefault(DateTimeOffset& src);
    private bool HasZero(VBuffer`1& src);
    private bool HasZero(VBuffer`1& src);
    private bool HasZero(VBuffer`1& src);
    private bool HasZero(VBuffer`1& src);
    private void GetNA(Single& value);
    private void GetNA(Double& value);
    public void Convert(SByte& src, SByte& dst);
    public void Convert(Int16& src, SByte& dst);
    public void Convert(Int32& src, SByte& dst);
    public void Convert(Int64& src, SByte& dst);
    public void Convert(SByte& src, Int16& dst);
    public void Convert(Int16& src, Int16& dst);
    public void Convert(Int32& src, Int16& dst);
    public void Convert(Int64& src, Int16& dst);
    public void Convert(SByte& src, Int32& dst);
    public void Convert(Int16& src, Int32& dst);
    public void Convert(Int32& src, Int32& dst);
    public void Convert(Int64& src, Int32& dst);
    public void Convert(SByte& src, Int64& dst);
    public void Convert(Int16& src, Int64& dst);
    public void Convert(Int32& src, Int64& dst);
    public void Convert(Int64& src, Int64& dst);
    public void Convert(TimeSpan& src, Int64& dst);
    public void Convert(DateTime& src, Int64& dst);
    public void Convert(DateTimeOffset& src, Int64& dst);
    public void Convert(Byte& src, Byte& dst);
    public void Convert(UInt16& src, Byte& dst);
    public void Convert(UInt32& src, Byte& dst);
    public void Convert(UInt64& src, Byte& dst);
    public void Convert(DataViewRowId& src, Byte& dst);
    public void Convert(Byte& src, UInt16& dst);
    public void Convert(UInt16& src, UInt16& dst);
    public void Convert(UInt32& src, UInt16& dst);
    public void Convert(UInt64& src, UInt16& dst);
    public void Convert(DataViewRowId& src, UInt16& dst);
    public void Convert(Byte& src, UInt32& dst);
    public void Convert(UInt16& src, UInt32& dst);
    public void Convert(UInt32& src, UInt32& dst);
    public void Convert(UInt64& src, UInt32& dst);
    public void Convert(DataViewRowId& src, UInt32& dst);
    public void Convert(Byte& src, UInt64& dst);
    public void Convert(UInt16& src, UInt64& dst);
    public void Convert(UInt32& src, UInt64& dst);
    public void Convert(UInt64& src, UInt64& dst);
    public void Convert(DataViewRowId& src, UInt64& dst);
    public void Convert(Byte& src, DataViewRowId& dst);
    public void Convert(UInt16& src, DataViewRowId& dst);
    public void Convert(UInt32& src, DataViewRowId& dst);
    public void Convert(UInt64& src, DataViewRowId& dst);
    public void Convert(DataViewRowId& src, DataViewRowId& dst);
    public void Convert(SByte& src, Single& dst);
    public void Convert(Int16& src, Single& dst);
    public void Convert(Int32& src, Single& dst);
    public void Convert(Int64& src, Single& dst);
    public void Convert(Byte& src, Single& dst);
    public void Convert(UInt16& src, Single& dst);
    public void Convert(UInt32& src, Single& dst);
    public void Convert(UInt64& src, Single& dst);
    public void Convert(TimeSpan& src, Single& dst);
    public void Convert(DateTime& src, Single& dst);
    public void Convert(DateTimeOffset& src, Single& dst);
    public void Convert(SByte& src, Double& dst);
    public void Convert(Int16& src, Double& dst);
    public void Convert(Int32& src, Double& dst);
    public void Convert(Int64& src, Double& dst);
    public void Convert(Byte& src, Double& dst);
    public void Convert(UInt16& src, Double& dst);
    public void Convert(UInt32& src, Double& dst);
    public void Convert(UInt64& src, Double& dst);
    public void Convert(TimeSpan& src, Double& dst);
    public void Convert(DateTime& src, Double& dst);
    public void Convert(DateTimeOffset& src, Double& dst);
    public void Convert(SByte& src, StringBuilder& dst);
    public void Convert(Int16& src, StringBuilder& dst);
    public void Convert(Int32& src, StringBuilder& dst);
    public void Convert(Int64& src, StringBuilder& dst);
    public void Convert(Byte& src, StringBuilder& dst);
    public void Convert(UInt16& src, StringBuilder& dst);
    public void Convert(UInt32& src, StringBuilder& dst);
    public void Convert(UInt64& src, StringBuilder& dst);
    public void Convert(DataViewRowId& src, StringBuilder& dst);
    public void Convert(Single& src, StringBuilder& dst);
    public void Convert(Double& src, StringBuilder& dst);
    public void Convert(Boolean& src, StringBuilder& dst);
    public void Convert(TimeSpan& src, StringBuilder& dst);
    public void Convert(DateTime& src, StringBuilder& dst);
    public void Convert(DateTimeOffset& src, StringBuilder& dst);
    public void Convert(SByte& src, ReadOnlyMemory`1& dst);
    public void Convert(Int16& src, ReadOnlyMemory`1& dst);
    public void Convert(Int32& src, ReadOnlyMemory`1& dst);
    public void Convert(Int64& src, ReadOnlyMemory`1& dst);
    public void Convert(Byte& src, ReadOnlyMemory`1& dst);
    public void Convert(UInt16& src, ReadOnlyMemory`1& dst);
    public void Convert(UInt32& src, ReadOnlyMemory`1& dst);
    public void Convert(UInt64& src, ReadOnlyMemory`1& dst);
    public void Convert(DataViewRowId& src, ReadOnlyMemory`1& dst);
    public void Convert(Single& src, ReadOnlyMemory`1& dst);
    public void Convert(Double& src, ReadOnlyMemory`1& dst);
    public void Convert(Boolean& src, ReadOnlyMemory`1& dst);
    public void Convert(TimeSpan& src, ReadOnlyMemory`1& dst);
    public void Convert(DateTime& src, ReadOnlyMemory`1& dst);
    public void Convert(DateTimeOffset& src, ReadOnlyMemory`1& dst);
    public void Convert(Double& src, Boolean& dst);
    public void Convert(Single& src, Boolean& dst);
    public void Convert(SByte& src, Boolean& dst);
    public void Convert(Int16& src, Boolean& dst);
    public void Convert(Int32& src, Boolean& dst);
    public void Convert(Int64& src, Boolean& dst);
    public void Convert(Byte& src, Boolean& dst);
    public void Convert(UInt16& src, Boolean& dst);
    public void Convert(UInt32& src, Boolean& dst);
    public void Convert(UInt64& src, Boolean& dst);
    public void Convert(Single& src, Single& dst);
    public void Convert(Single& src, Double& dst);
    public void Convert(Double& src, Single& dst);
    public void Convert(Double& src, Double& dst);
    public bool TryParse(ReadOnlyMemory`1& src, Byte& dst);
    public bool TryParse(ReadOnlyMemory`1& src, UInt16& dst);
    public bool TryParse(ReadOnlyMemory`1& src, UInt32& dst);
    public bool TryParse(ReadOnlyMemory`1& src, UInt64& dst);
    public bool TryParse(ReadOnlyMemory`1& src, DataViewRowId& dst);
    private bool IsStdMissing(ReadOnlySpan`1& span);
    public bool TryParseKey(ReadOnlyMemory`1& src, ulong max, UInt64& dst);
    private bool TryParseCore(ReadOnlySpan`1<char> span, UInt64& dst);
    public bool TryParse(ReadOnlyMemory`1& src, SByte& dst);
    public bool TryParse(ReadOnlyMemory`1& src, Int16& dst);
    public bool TryParse(ReadOnlyMemory`1& src, Int32& dst);
    public bool TryParse(ReadOnlyMemory`1& src, Int64& dst);
    private bool TryParseNonNegative(ReadOnlySpan`1<char> span, Int64& result);
    private void TryParseSigned(long max, ReadOnlyMemory`1& text, Nullable`1& result);
    public bool TryParse(ReadOnlyMemory`1& src, Single& dst);
    public bool TryParse(ReadOnlyMemory`1& src, Double& dst);
    public bool TryParse(ReadOnlyMemory`1& src, TimeSpan& dst);
    public bool TryParse(ReadOnlyMemory`1& src, DateTime& dst);
    public bool TryParse(ReadOnlyMemory`1& src, DateTimeOffset& dst);
    private sbyte ParseI1(ReadOnlyMemory`1& src);
    private short ParseI2(ReadOnlyMemory`1& src);
    private int ParseI4(ReadOnlyMemory`1& src);
    private long ParseI8(ReadOnlyMemory`1& src);
    private byte ParseU1(ReadOnlyMemory`1& span);
    private ushort ParseU2(ReadOnlyMemory`1& span);
    private UInt32 ParseU4(ReadOnlyMemory`1& span);
    private ulong ParseU8(ReadOnlyMemory`1& span);
    public bool TryParse(ReadOnlyMemory`1& src, Boolean& dst);
    private bool TryParse(ReadOnlyMemory`1& src, ReadOnlyMemory`1& dst);
    public void Convert(ReadOnlyMemory`1& span, SByte& value);
    public void Convert(ReadOnlyMemory`1& span, Byte& value);
    public void Convert(ReadOnlyMemory`1& span, Int16& value);
    public void Convert(ReadOnlyMemory`1& span, UInt16& value);
    public void Convert(ReadOnlyMemory`1& span, Int32& value);
    public void Convert(ReadOnlyMemory`1& span, UInt32& value);
    public void Convert(ReadOnlyMemory`1& span, Int64& value);
    public void Convert(ReadOnlyMemory`1& span, UInt64& value);
    public void Convert(ReadOnlyMemory`1& span, DataViewRowId& value);
    public void Convert(ReadOnlyMemory`1& src, Single& value);
    public void Convert(ReadOnlyMemory`1& src, Double& value);
    public void Convert(ReadOnlyMemory`1& span, ReadOnlyMemory`1& value);
    public void Convert(ReadOnlyMemory`1& src, Boolean& value);
    public void Convert(ReadOnlyMemory`1& src, StringBuilder& dst);
    public void Convert(ReadOnlyMemory`1& span, TimeSpan& value);
    public void Convert(ReadOnlyMemory`1& span, DateTime& value);
    public void Convert(ReadOnlyMemory`1& span, DateTimeOffset& value);
    public void Convert(Boolean& src, SByte& dst);
    public void Convert(Boolean& src, Int16& dst);
    public void Convert(Boolean& src, Int32& dst);
    public void Convert(Boolean& src, Int64& dst);
    public void Convert(Boolean& src, Single& dst);
    public void Convert(Boolean& src, Double& dst);
    public void Convert(Boolean& src, Boolean& dst);
    public void Convert(DateTime& src, DateTime& dst);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.Conversion.TryParseMapper`1 : MulticastDelegate {
    public TryParseMapper`1(object object, IntPtr method);
    public virtual bool Invoke(ReadOnlyMemory`1& modreq(System.Runtime.InteropServices.InAttribute) src, T& dst);
    public virtual IAsyncResult BeginInvoke(ReadOnlyMemory`1& modreq(System.Runtime.InteropServices.InAttribute) src, T& dst, AsyncCallback callback, object object);
    public virtual bool EndInvoke(ReadOnlyMemory`1& modreq(System.Runtime.InteropServices.InAttribute) src, T& dst, IAsyncResult result);
}
internal static class Microsoft.ML.Data.CreatePredictionTransformer : object {
    internal static object Create(IHostEnvironment env, ModelLoadContext ctx, IHost host, IPredictorProducing`1<float> model, Type predictionTransformerType);
    internal static object Create(IHostEnvironment env, ModelLoadContext ctx, IHost host, IPredictorProducing`1<VBuffer`1<float>> model, Type predictionTransformerType);
    private static ConstructorInfo CreateConstructor(Type modelType, Type predictionTransformerType);
    private static Type GetLoadType(Type modelType);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.CrossValidationCommand : ImplBase`1<Arguments> {
    private static string RegistrationName;
    public static string LoadName;
    public CrossValidationCommand(IHostEnvironment env, Arguments args);
    private CrossValidationCommand(CrossValidationCommand impl);
    public virtual void Run();
    protected virtual void SendTelemetryCore(IPipe`1<TelemetryMessage> pipe);
    private void RunCore(IChannel ch, string cmd);
    private RoleMappedData ApplyAllTransformsToData(IHostEnvironment env, IChannel ch, IDataView dstData, RoleMappedData srcData, IDataView marker);
    private RoleMappedData CreateRoleMappedData(IHostEnvironment env, IChannel ch, IDataView data, ITrainer trainer);
    private string GetSplitColumn(IChannel ch, IDataView input, IDataView& output);
    private bool TryGetOverallMetrics(Dictionary`2[] metrics, List`1& overallList);
    public static string ConstructPerFoldName(string outputModelFile, int fold);
    [CompilerGeneratedAttribute]
private IDataView <RunCore>b__7_0();
}
[AttributeUsageAttribute("384")]
[BestFriendAttribute]
internal class Microsoft.ML.Data.CursorChannelAttribute : Attribute {
    public static bool TrySetCursorChannel(IExceptionContext ectx, T obj, IChannel channel);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.CursoringUtils : object {
    [ExtensionAttribute]
public static ICursorable`1<TRow> AsCursorable(IHostEnvironment env, IDataView data, bool ignoreMissingColumns, SchemaDefinition schemaDefinition);
}
public class Microsoft.ML.Data.DatabaseLoader : object {
    internal static string Summary;
    internal static string LoaderSignature;
    private Bindings _bindings;
    private IHost _host;
    private static string RegistrationName;
    internal DatabaseLoader(IHostEnvironment env, Options options);
    private DatabaseLoader(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal static DatabaseLoader Create(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual DataViewSchema GetOutputSchema();
    public sealed virtual IDataView Load(DatabaseSource source);
    internal static DatabaseLoader CreateDatabaseLoader(IHostEnvironment host);
}
public class Microsoft.ML.Data.DatabaseSource : object {
    private static int DefaultCommandTimeoutInSeconds;
    [CompilerGeneratedAttribute]
private int <CommandTimeoutInSeconds>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CommandText>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ConnectionString>k__BackingField;
    [CompilerGeneratedAttribute]
private DbProviderFactory <ProviderFactory>k__BackingField;
    public int CommandTimeoutInSeconds { get; }
    public string CommandText { get; }
    public string ConnectionString { get; }
    public DbProviderFactory ProviderFactory { get; }
    public DatabaseSource(DbProviderFactory providerFactory, string connectionString, string commandText);
    public DatabaseSource(DbProviderFactory providerFactory, string connectionString, string commandText, int commandTimeoutInSeconds);
    [CompilerGeneratedAttribute]
public int get_CommandTimeoutInSeconds();
    [CompilerGeneratedAttribute]
public string get_CommandText();
    [CompilerGeneratedAttribute]
public string get_ConnectionString();
    [CompilerGeneratedAttribute]
public DbProviderFactory get_ProviderFactory();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataCommand : object {
}
public class Microsoft.ML.Data.DataDebuggerPreview : object {
    private static FuncInstanceMethodInfo1`4<DataDebuggerPreview, DataViewRow, int, Action`2<RowInfo, List`1<object>>> _makeSetterMethodInfo;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<ColumnInfo> <ColumnView>k__BackingField;
    [CompilerGeneratedAttribute]
private ImmutableArray`1<RowInfo> <RowView>k__BackingField;
    public DataViewSchema Schema { get; }
    public ImmutableArray`1<ColumnInfo> ColumnView { get; }
    public ImmutableArray`1<RowInfo> RowView { get; }
    internal DataDebuggerPreview(IDataView data, int maxRows);
    private static DataDebuggerPreview();
    [CompilerGeneratedAttribute]
public DataViewSchema get_Schema();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<ColumnInfo> get_ColumnView();
    [CompilerGeneratedAttribute]
public ImmutableArray`1<RowInfo> get_RowView();
    public virtual string ToString();
    private Action`2<RowInfo, List`1<object>> MakeSetter(DataViewRow row, int col);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataLoadSave.FakeSchemaFactory : object {
    private static FuncStaticMethodInfo1`1<Delegate> _getDefaultVectorGetterMethodInfo;
    private static FuncStaticMethodInfo1`1<Delegate> _getDefaultGetterMethodInfo;
    private static int AllVectorSizes;
    private static int AllKeySizes;
    private static FakeSchemaFactory();
    public static DataViewSchema Create(SchemaShape shape);
    private static DataViewType MakeColumnType(Column column);
    private static Delegate GetDefaultVectorGetter();
    private static Delegate GetDefaultGetter();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataSaverUtils : object {
    public static void SaveDataView(IChannel ch, IDataSaver saver, IDataView view, IFileHandle file, bool keepHidden);
    public static void SaveDataView(IChannel ch, IDataSaver saver, IDataView view, Stream stream, bool keepHidden);
}
internal abstract class Microsoft.ML.Data.DataView.BatchDataViewMapperBase`2 : object {
    private IDataView _source;
    protected IHost Host;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    protected ColumnBindingsBase SchemaBindings { get; }
    protected BatchDataViewMapperBase`2(IHostEnvironment env, string registrationName, IDataView input);
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    protected abstract virtual ColumnBindingsBase get_SchemaBindings();
    protected abstract virtual TBatch CreateBatch(DataViewRowCursor input);
    protected abstract virtual void ProcessBatch(TBatch currentBatch);
    protected abstract virtual void ProcessExample(TBatch currentBatch, TInput currentInput);
    protected abstract virtual Func`1<bool> GetLastInBatchDelegate(DataViewRowCursor lookAheadCursor);
    protected abstract virtual Func`1<bool> GetIsNewBatchDelegate(DataViewRowCursor lookAheadCursor);
    protected abstract virtual ValueGetter`1<TInput> GetLookAheadGetter(DataViewRowCursor lookAheadCursor);
    protected abstract virtual Delegate[] CreateGetters(DataViewRowCursor input, TBatch currentBatch, Boolean[] active);
    protected abstract virtual Func`2<int, bool> GetSchemaBindingDependencies(Func`2<int, bool> predicate);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataViewConstructionUtils : object {
    private static FuncStaticMethodInfo1`3<string, Annotations, AnnotationInfo> _getAnnotationInfoMethodInfo;
    private static DataViewConstructionUtils();
    public static IDataView CreateFromList(IHostEnvironment env, IList`1<TRow> data, SchemaDefinition schemaDefinition);
    public static StreamingDataView`1<TRow> CreateFromEnumerable(IHostEnvironment env, IEnumerable`1<TRow> data, SchemaDefinition schemaDefinition);
    public static StreamingDataView`1<TRow> CreateFromEnumerable(IHostEnvironment env, IEnumerable`1<TRow> data, DataViewSchema schema);
    internal static SchemaDefinition GetSchemaDefinition(IHostEnvironment env, DataViewSchema schema);
    private static InternalSchemaDefinition GetInternalSchemaDefinition(IHostEnvironment env, DataViewSchema schema);
    private static AnnotationInfo GetAnnotationInfo(string kind, Annotations annotations);
    public static InputRow`1<TRow> CreateInputRow(IHostEnvironment env, SchemaDefinition schemaDefinition);
    public static IDataView LoadPipeWithPredictor(IHostEnvironment env, Stream modelStream, IDataView view);
    [BestFriendAttribute]
internal static DetachedColumn[] GetSchemaColumns(InternalSchemaDefinition schemaDefn);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataViewExtensions : object {
    [ExtensionAttribute]
public static DataViewRowCursor GetRowCursor(IDataView dv, Column[] columnsNeeded);
    [ExtensionAttribute]
public static DataViewRowCursor GetRowCursor(IDataView dv, Column columnNeeded);
    [ExtensionAttribute]
public static DataViewRowCursor GetRowCursor(IDataView dv);
    [ExtensionAttribute]
public static DataViewRowCursor GetRowCursorForAllColumns(IDataView dv);
    [ExtensionAttribute]
public static DataViewRow GetRow(IRowToRowMapper rowMapper, DataViewRow input, Column[] activeColumns);
}
public static class Microsoft.ML.Data.DataViewTypeManager : object {
    private static HashSet`1<Type> _bannedRawTypes;
    private static Dictionary`2<TypeWithAttributes, DataViewType> _rawTypeToDataViewTypeMap;
    private static Dictionary`2<DataViewType, TypeWithAttributes> _dataViewTypeToRawTypeMap;
    private static object _lock;
    private static DataViewTypeManager();
    internal static DataViewType GetDataViewType(Type type, IEnumerable`1<Attribute> typeAttributes);
    internal static bool Knows(Type type, IEnumerable`1<Attribute> typeAttributes);
    internal static bool Knows(DataViewType dataViewType);
    [ObsoleteAttribute("This API is deprecated, please use the new form of Register which takes in a single DataViewTypeAttribute instead.", "False")]
public static void Register(DataViewType dataViewType, Type type, IEnumerable`1<Attribute> typeAttributes);
    public static void Register(DataViewType dataViewType, Type type, DataViewTypeAttribute typeAttribute);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DataViewUtils : object {
    [ExtensionAttribute]
public static string GetTempColumnName(DataViewSchema schema, string tag);
    [ExtensionAttribute]
public static String[] GetTempColumnNames(DataViewSchema schema, int n, string tag);
    public static long ComputeRowCount(IDataView view);
    public static int GetThreadCount(int num, bool preferOne);
    public static bool TryCreateConsolidatingCursor(DataViewRowCursor& curs, IDataView view, IEnumerable`1<Column> columnsNeeded, IHost host, Random rand);
    public static DataViewRowCursor[] CreateSplitCursors(IChannelProvider provider, DataViewRowCursor input, int num);
    public static bool AllCacheable(DataViewSchema schema, Func`2<Column, bool> predicate);
    public static bool AllCacheable(IEnumerable`1<Column> columnsNeeded);
    [ExtensionAttribute]
public static bool IsCacheable(DataViewType type);
    public static bool SameSchemaAndActivity(DataViewRowCursor[] cursors);
    public static DataViewRowCursor ConsolidateGeneric(IChannelProvider provider, DataViewRowCursor[] inputs, int batchSize);
    public static ValueGetter`1[] PopulateGetterArray(DataViewRowCursor cursor, List`1<int> colIndices);
    public static ValueGetter`1<ReadOnlyMemory`1<char>> GetSingleValueGetter(DataViewRow cursor, int i, DataViewType colType);
    public static ValueGetter`1<ReadOnlyMemory`1<char>> GetVectorFlatteningGetter(DataViewRow cursor, int colIndex, DataViewType colType);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Data.DbExtensions : object {
    [ExtensionAttribute]
public static Type ToType(DbType dbType);
    [ExtensionAttribute]
public static DbType ToDbType(InternalDataKind dataKind);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.DefaultColumnNames : object {
    public static string Features;
    public static string Label;
    public static string GroupId;
    public static string Name;
    public static string Weight;
    public static string Score;
    public static string Probability;
    public static string PredictedLabel;
    public static string RecommendedItems;
    public static string User;
    public static string Item;
    public static string Date;
    public static string FeatureContributions;
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.EmptyDataView : object {
    private IHost _host;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    public EmptyDataView(IHostEnvironment env, DataViewSchema schema);
    public sealed virtual bool get_CanShuffle();
    [CompilerGeneratedAttribute]
public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
public class Microsoft.ML.Data.EstimatorChain`1 : object {
    private IHost _host;
    private TransformerScope[] _scopes;
    private IEstimator`1[] _estimators;
    private Boolean[] _needCacheAfter;
    public IEstimator`1<TLastTransformer> LastEstimator;
    private EstimatorChain`1(IHostEnvironment env, IEstimator`1[] estimators, TransformerScope[] scopes, Boolean[] needCacheAfter);
    public sealed virtual TransformerChain`1<TLastTransformer> Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    public EstimatorChain`1<TNewTrans> Append(IEstimator`1<TNewTrans> estimator, TransformerScope scope);
    public EstimatorChain`1<TLastTransformer> AppendCacheCheckpoint(IHostEnvironment env);
}
internal static class Microsoft.ML.Data.Evaluate : object {
    [EntryPointAttribute]
public static CommonEvaluateOutput AnomalyDetection(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static ClassificationEvaluateOutput Binary(IHostEnvironment env, Arguments input);
    private static void MatchColumns(IHost host, ArgumentsBase input, String& label, String& weight, String& name);
    private static IDataView ExtractWarnings(IHost host, Dictionary`2<string, IDataView> metrics);
    private static IDataView ExtractOverallMetrics(IHost host, Dictionary`2<string, IDataView> metrics, IMamlEvaluator evaluator);
    private static IDataView ExtractConfusionMatrix(IHost host, Dictionary`2<string, IDataView> metrics);
    [EntryPointAttribute]
public static CommonEvaluateOutput Clustering(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static ClassificationEvaluateOutput Multiclass(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static CommonEvaluateOutput MultiOutputRegression(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static CommonEvaluateOutput QuantileRegression(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static CommonEvaluateOutput Ranking(IHostEnvironment env, Arguments input);
    [EntryPointAttribute]
public static CommonEvaluateOutput Regression(IHostEnvironment env, Arguments input);
}
internal class Microsoft.ML.Data.EvaluateCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public EvaluateCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
}
internal static class Microsoft.ML.Data.EvaluateTransform : object {
    internal static string Summary;
    private static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Data.EvaluateUtils : object {
    public static IMamlEvaluator GetEvaluator(IHostEnvironment env, DataViewSchema schema);
    private static bool CheckScoreColumnKindIsKnown(DataViewSchema schema, int col);
    private static bool CheckScoreColumnKind(DataViewSchema schema, int col);
    public static Column GetScoreColumn(IExceptionContext ectx, DataViewSchema schema, string name, string argName, string kind, string valueKind, string defName);
    public static Nullable`1<Column> GetOptAuxScoreColumn(IExceptionContext ectx, DataViewSchema schema, string name, string argName, int colScore, string valueKind, Func`2<DataViewType, bool> testType);
    private static bool IsScoreColumnKind(IExceptionContext ectx, DataViewSchema schema, int col, string kind);
    public static string GetColName(string str, Nullable`1<Column> info, string def);
    public static void CheckWeightType(IExceptionContext ectx, DataViewType type);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.EvaluateUtils/<GetMetrics>d__10")]
public static IEnumerable`1<KeyValuePair`2<string, double>> GetMetrics(IDataView metricsView, bool getVectorMetrics);
    private static IDataView AddTextColumn(IHostEnvironment env, IDataView input, string inputColName, string outputColName, DataViewType typeSrc, string value, string registrationName);
    public static IDataView AddFoldIndex(IHostEnvironment env, IDataView input, int curFold);
    private static IDataView AddKeyColumn(IHostEnvironment env, IDataView input, string inputColName, string outputColName, DataViewType typeSrc, int keyCount, int value, string registrationName, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> keyValueGetter);
    public static IDataView AddFoldIndex(IHostEnvironment env, IDataView input, int curFold, int numFolds);
    public static void ReconcileSlotNames(IHostEnvironment env, IDataView[] views, string columnName, PrimitiveDataViewType itemType, T def);
    private static Int32[][] MapKeys(DataViewSchema[] schemas, string columnName, bool isVec, Int32[] indices, Dictionary`2<ReadOnlyMemory`1<char>, int> reconciledKeyNames);
    public static void ReconcileKeyValues(IHostEnvironment env, IDataView[] views, string columnName, DataViewType keyValueType);
    public static void ReconcileKeyValuesWithNoNames(IHostEnvironment env, IDataView[] views, string columnName, ulong keyCount);
    public static void ReconcileVectorKeyValues(IHostEnvironment env, IDataView[] views, string columnName, DataViewType keyValueType);
    public static IDataView[] ConcatenatePerInstanceDataViews(IHostEnvironment env, IMamlEvaluator eval, bool collate, bool outputFoldIndex, RoleMappedData[] perInstance, String[]& variableSizeVectorColumnNames);
    public static IDataView ConcatenateOverallMetrics(IHostEnvironment env, IDataView[] metrics);
    private static IDataView AppendPerInstanceDataViews(IHostEnvironment env, string labelColName, IEnumerable`1<IDataView> foldDataViews, String[]& variableSizeVectorColumnNames);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.EvaluateUtils/<FindHiddenColumns>d__23")]
private static IEnumerable`1<int> FindHiddenColumns(DataViewSchema schema, string colName);
    private static bool VerifyVectorColumnsMatch(int cachedSize, int col, IDataView dv, VectorDataViewType type, VBuffer`1& firstDvSlotNames);
    private static IDataView AddVarLengthColumn(IHostEnvironment env, IDataView idv, string variableSizeVectorColumnName, VectorDataViewType typeSrc);
    private static List`1<string> GetMetricNames(IChannel ch, DataViewSchema schema, DataViewRow row, Func`2<int, bool> ignoreCol, ValueGetter`1[] getters, ValueGetter`1[] vBufferGetters);
    internal static IDataView GetOverallMetricsData(IHostEnvironment env, IDataView data, int numFolds, AggregatedMetric[]& agg, AggregatedMetric[]& weightedAgg);
    internal static AggregatedMetric[] ComputeMetricsSum(IHostEnvironment env, IDataView data, int numFolds, Int32& isWeightedCol, Int32& stratCol, Int32& stratVal, Int32& foldCol, AggregatedMetric[]& weightedAgg);
    private static void UpdateSums(int isWeightedCol, int stratCol, int stratVal, AggregatedMetric[] aggregated, bool hasStdev, List`1<string> metricNames, bool hasWeighted, bool hasStrats, int colCount, ValueGetter`1[] getters, ValueGetter`1[] vBufferGetters, Double& metricVal, VBuffer`1& metricVals);
    internal static IDataView GetAverageToDataView(IHostEnvironment env, DataViewSchema schema, AggregatedMetric[] agg, AggregatedMetric[] weightedAgg, int numFolds, int stratCol, int stratVal, int isWeightedCol, int foldCol, bool hasStdev, List`1<string> nonAveragedCols);
    [ExtensionAttribute]
private static void AddVectorColumn(ArrayDataViewBuilder dvBldr, IHostEnvironment env, DataViewSchema schema, AggregatedMetric[] agg, bool hasStdev, int numFolds, int iMetric, int i, VectorDataViewType type, string columnName);
    [ExtensionAttribute]
private static void AddScalarColumn(ArrayDataViewBuilder dvBldr, DataViewSchema schema, AggregatedMetric[] agg, bool hasStdev, int numFolds, int iMetric);
    public static IDataView CombineFoldMetricsDataViews(IHostEnvironment env, IDataView data, int numFolds);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.EvaluatorBase`1 : object {
    protected IHost Host;
    [BestFriendAttribute]
private protected EvaluatorBase`1(IHostEnvironment env, string registrationName);
    private sealed virtual override Dictionary`2<string, IDataView> Microsoft.ML.Data.IEvaluator.Evaluate(RoleMappedData data);
    [BestFriendAttribute]
private protected void CheckColumnTypes(RoleMappedSchema schema);
    [BestFriendAttribute]
private protected abstract virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    [BestFriendAttribute]
private protected virtual void CheckCustomColumnTypesCore(RoleMappedSchema schema);
    private Func`2<int, bool> GetActiveCols(RoleMappedSchema schema);
    [BestFriendAttribute]
private protected virtual Func`2<int, bool> GetActiveColsCore(RoleMappedSchema schema);
    private TAgg GetAggregator(RoleMappedSchema schema);
    private AggregatorDictionaryBase[] GetAggregatorDictionaries(RoleMappedSchema schema);
    [BestFriendAttribute]
private protected abstract virtual TAgg GetAggregatorCore(RoleMappedSchema schema, string stratName);
    private Dictionary`2<string, IDataView> ProcessData(IDataView data, RoleMappedSchema schema, Func`2<int, bool> activeColsIndices, TAgg aggregator, AggregatorDictionaryBase[] dictionaries);
    [BestFriendAttribute]
private protected abstract virtual void GetAggregatorConsolidationFuncs(TAgg aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
    [BestFriendAttribute]
private protected ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> GetKeyValueGetter(AggregatorDictionaryBase[] dictionaries);
    private sealed virtual override IDataTransform Microsoft.ML.Data.IEvaluator.GetPerInstanceMetrics(RoleMappedData data);
    [BestFriendAttribute]
internal abstract virtual IDataTransform GetPerInstanceMetricsCore(RoleMappedData data);
    public abstract virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
}
internal class Microsoft.ML.Data.FeatureContributionScorer : object {
    internal static string MapperLoaderSignature;
    private static IDataScorerTransform Create(IHostEnvironment env, Arguments args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private static ISchemaBindableMapper Create(IHostEnvironment env, Arguments args, IPredictor predictor);
    private static ISchemaBindableMapper Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.FileHandleSource : object {
    private IFileHandle _file;
    public int Count { get; }
    public FileHandleSource(IFileHandle file);
    public sealed virtual int get_Count();
    public sealed virtual string GetPathOrNull(int index);
    public sealed virtual Stream Open(int index);
    public sealed virtual TextReader OpenTextReader(int index);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.FilterBase : TransformBase {
    public DataViewSchema OutputSchema { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    [BestFriendAttribute]
private protected FilterBase(IHostEnvironment env, string name, IDataView input);
    [BestFriendAttribute]
private protected FilterBase(IHost host, IDataView input);
    public virtual Nullable`1<long> GetRowCount();
    public virtual DataViewSchema get_OutputSchema();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override void Microsoft.ML.Model.Pfa.ISaveAsPfa.SaveAsPfa(BoundPfaContext ctx);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.FloatAdder : Combiner`1<float> {
    private static FloatAdder modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static FloatAdder Instance { get; }
    public static FloatAdder get_Instance();
    public virtual bool IsDefault(float value);
    public virtual void Combine(Single& dst, float src);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.GenericScorer : RowToRowScorerBase {
    public static string LoadName;
    public static string LoaderSignature;
    private static string RegistrationName;
    private Bindings _bindings;
    [CompilerGeneratedAttribute]
private DataViewSchema <OutputSchema>k__BackingField;
    public DataViewSchema OutputSchema { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    [BestFriendAttribute]
internal GenericScorer(IHostEnvironment env, ScorerArgumentsBase args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private GenericScorer(IHostEnvironment env, GenericScorer transform, IDataView data);
    private GenericScorer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    private protected virtual BindingsBase GetBindings();
    [CompilerGeneratedAttribute]
public virtual DataViewSchema get_OutputSchema();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    public static GenericScorer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.ISaveAsPfa.SaveAsPfa(BoundPfaContext ctx);
    private sealed virtual override void Microsoft.ML.Model.OnnxConverter.ISaveAsOnnx.SaveAsOnnx(OnnxContext ctx);
    protected virtual bool WantParallelCursors(Func`2<int, bool> predicate);
    private protected virtual IDataTransform ApplyToDataCore(IHostEnvironment env, IDataView newSource);
    protected virtual Delegate[] GetGetters(DataViewRow output, Func`2<int, bool> predicate);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IColumnAggregator`1 {
    public abstract virtual void ProcessValue(T& modreq(System.Runtime.InteropServices.InAttribute) val);
    public abstract virtual void Finish();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IColumnFunction {
    public abstract virtual Delegate GetGetter(DataViewRow input, int icol);
    public abstract virtual void AttachMetadata(Builder bldr, DataViewType typeSrc);
    public abstract virtual JToken PfaInfo(BoundPfaContext ctx, JToken srcToken);
    public abstract virtual bool CanSaveOnnx(OnnxContext ctx);
    public abstract virtual bool OnnxInfo(OnnxContext ctx, OnnxNode nodeProtoWrapper, int featureCount);
    public abstract virtual NormalizerModelParametersBase GetNormalizerModelParams();
}
internal interface Microsoft.ML.Data.IColumnFunctionBuilder {
    public abstract virtual bool ProcessValue();
    public abstract virtual IColumnFunction CreateColumnFunction();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ICursorable`1 {
    public abstract virtual RowCursor`1<TRow> GetCursor();
    public abstract virtual RowCursor`1<TRow> GetRandomizedCursor(int randomSeed);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IDataSaver {
    public abstract virtual bool IsColumnSavable(DataViewType type);
    public abstract virtual void SaveData(Stream stream, IDataView data, Int32[] cols);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IDataScorerTransform {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IDataTransform {
    public IDataView Source { get; }
    public abstract virtual IDataView get_Source();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IEvaluator {
    public abstract virtual Dictionary`2<string, IDataView> Evaluate(RoleMappedData data);
    public abstract virtual IDataTransform GetPerInstanceMetrics(RoleMappedData data);
    public abstract virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IInternalCatalog {
    public IHostEnvironment Environment { get; }
    public abstract virtual IHostEnvironment get_Environment();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ILegacyDataLoader {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IMamlEvaluator {
    public abstract virtual void PrintFoldResults(IChannel ch, Dictionary`2<string, IDataView> metrics);
    public abstract virtual IDataView GetOverallResults(IDataView[] metrics);
    public abstract virtual void PrintAdditionalMetrics(IChannel ch, Dictionary`2[] metrics);
    public abstract virtual IDataView GetPerInstanceDataViewToSave(RoleMappedData perInstance);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IModelCombiner {
    public abstract virtual IPredictor CombineModels(IEnumerable`1<IPredictor> models);
}
public interface Microsoft.ML.Data.IMultiStreamSource {
    public int Count { get; }
    public abstract virtual int get_Count();
    public abstract virtual string GetPathOrNull(int index);
    public abstract virtual Stream Open(int index);
    public abstract virtual TextReader OpenTextReader(int index);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.InternalSchemaDefinition : object {
    public Column[] Columns;
    private InternalSchemaDefinition(Column[] columns);
    public static void GetVectorAndItemType(MemberInfo memberInfo, Boolean& isVector, Type& itemType);
    public static void GetMappedType(Type rawType, Type& itemType, Boolean& isVector);
    public static void GetVectorAndItemType(string name, Type rawType, IEnumerable`1<Attribute> attributes, Boolean& isVector, Type& itemType);
    public static InternalSchemaDefinition Create(Type userType, Direction direction);
    public static InternalSchemaDefinition Create(Type userType, SchemaDefinition userSchemaDefinition);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.InvertHashCollector`1 : object {
    private int _maxCount;
    private int _slots;
    private ValueMapper`2<T, StringBuilder> _stringifyMapper;
    private Dictionary`2<int, HashSet`1<Pair<T>>> _slotToValueSet;
    private IEqualityComparer`1<Pair<T>> _comparer;
    private ValueMapper`2<T, T> _copier;
    public InvertHashCollector`1(int slots, int maxCount, ValueMapper`2<T, StringBuilder> mapper, IEqualityComparer`1<T> comparer, ValueMapper`2<T, T> copier);
    private ReadOnlyMemory`1<char> Textify(StringBuilder& sb, StringBuilder& temp, Char[]& cbuffer, Pair[]& buffer, HashSet`1<Pair<T>> pairs);
    public VBuffer`1<ReadOnlyMemory`1<char>> GetMetadata();
    public void Add(int dstSlot, ValueGetter`1<T> getter, T& key);
    public void Add(int dstSlot, T key);
    public void Add(UInt32 hash, ValueGetter`1<T> getter, T& key);
    public void Add(UInt32 hash, T key);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.InvertHashUtils : object {
    private static void ClearDst(StringBuilder& dst);
    public static ValueMapper`2<T, StringBuilder> GetSimpleMapper(DataViewSchema schema, int col);
    public static ValueMapper`2<KeyValuePair`2<int, T>, StringBuilder> GetPairMapper(ValueMapper`2<T, StringBuilder> submap);
    public static void AppendToEnd(StringBuilder src, StringBuilder dst, Char[]& buffer);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.IO.BinaryLoader : object {
    private Stream _stream;
    private BinaryReader _reader;
    private CodecFactory _factory;
    private Header _header;
    private DataViewSchema _outputSchema;
    private bool _autodeterminedThreads;
    private int _threads;
    private bool _disposed;
    private TableOfContentsEntry[] _aliveColumns;
    private TableOfContentsEntry[] _deadColumns;
    private int _rowsPerBlock;
    private long _tocEndLim;
    private MemoryStreamCollection _bufferCollection;
    private IHost _host;
    private double _shuffleBlocks;
    private int _randomShufflePoolRows;
    private static double _defaultShuffleBlocks;
    private static ulong ReaderVersion;
    private static ulong StandardDataTypesVersion;
    private static ulong MissingTextVersion;
    private static ulong MetadataVersion;
    private static ulong SlotNamesVersion;
    private static ulong ReaderFirstVersion;
    internal static string Summary;
    internal static string LoadName;
    internal static string LoaderSignature;
    public DataViewSchema Schema { get; }
    private long RowCount { get; }
    public bool CanShuffle { get; }
    private BinaryLoader(Arguments args, IHost host, Stream stream, bool leaveOpen);
    internal BinaryLoader(IHostEnvironment env, Arguments args, Stream stream, bool leaveOpen);
    public BinaryLoader(IHostEnvironment env, Arguments args, string filename);
    public BinaryLoader(IHostEnvironment env, Arguments args, IMultiStreamSource file);
    private BinaryLoader(IHost host, ModelLoadContext ctx, Stream stream);
    private DataViewSchema ComputeOutputSchema();
    public sealed virtual DataViewSchema get_Schema();
    private long get_RowCount();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual bool get_CanShuffle();
    private static VersionInfo GetVersionInfo();
    private static BinaryLoader Create(IHostEnvironment env, ModelLoadContext ctx, IMultiStreamSource files);
    private static BinaryLoader Create(IHostEnvironment env, ModelLoadContext ctx, Stream stream);
    private static Stream OpenStream(IMultiStreamSource files);
    private static Stream OpenStream(string filename);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private static void SaveParameters(ModelSaveContext ctx, int threads, double shuffleBlocks);
    private static void SaveSchema(IHostEnvironment env, ModelSaveContext ctx, DataViewSchema schema, Int32[]& unsavableColIndices);
    public static void SaveInstance(IHostEnvironment env, ModelSaveContext ctx, DataViewSchema schema);
    private Header InitHeader();
    private void InitToc(IChannel ch, TableOfContentsEntry[]& aliveColumns, TableOfContentsEntry[]& deadColumns, Int32& allRowsPerBlock, Int64& tocEndOffset);
    public sealed virtual void Dispose();
    private void CalculateShufflePoolRows(IChannel ch, Int32& poolRows);
    private DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.IO.BinarySaver : object {
    private static FuncInstanceMethodInfo1`4<BinarySaver, Stream, IValueCodec, object> _loadValueMethodInfo;
    internal static string Summary;
    private IHost _host;
    private CodecFactory _factory;
    private MemoryStreamPool _memPool;
    private CompressionKind _compression;
    private Nullable`1<int> _maxRowsPerBlock;
    private Nullable`1<long> _maxBytesPerBlock;
    private bool _deterministicBlockOrder;
    private bool _silent;
    private long _rowCount;
    public BinarySaver(IHostEnvironment env, Arguments args);
    private static BinarySaver();
    private void CompressionWorker(BlockingCollection`1<Block> toCompress, BlockingCollection`1<Block> toWrite, int columns, OrderedWaiter waiter, ExceptionMarshaller exMarshaller);
    private long WriteMetadata(BinaryWriter writer, DataViewSchema schema, int col, IChannel ch);
    private IValueCodec WriteMetadataCore(Stream stream, DataViewSchema schema, int col, string kind, DataViewType type, CompressionKind& compressionKind);
    private void WriteWorker(Stream stream, BlockingCollection`1<Block> toWrite, ColumnCodec[] activeColumns, DataViewSchema sourceSchema, int rowsPerBlock, IChannelProvider cp, ExceptionMarshaller exMarshaller);
    private void FetchWorker(BlockingCollection`1<Block> toCompress, IDataView data, ColumnCodec[] activeColumns, int rowsPerBlock, IChannel ch, IProgressChannel pch, ExceptionMarshaller exMarshaller);
    public sealed virtual bool IsColumnSavable(DataViewType type);
    public sealed virtual void SaveData(Stream stream, IDataView data, Int32[] colIndices);
    private ColumnCodec[] GetActiveColumns(DataViewSchema schema, Int32[] colIndices);
    private int RowsPerBlockHeuristic(IDataView data, ColumnCodec[] actives);
    private void EstimatorCore(DataViewRowCursor cursor, ColumnCodec col, Func`1& fetchWriteEstimator, IValueWriter& writer);
    public bool TryWriteTypeDescription(Stream stream, DataViewType type, Int32& bytesWritten);
    public DataViewType LoadTypeDescriptionOrNull(Stream stream);
    public bool TryWriteTypeAndValue(Stream stream, DataViewType type, T& value, Int32& bytesWritten);
    public bool TryLoadTypeAndValue(Stream stream, DataViewType& type, Object& value);
    private object LoadValue(Stream stream, IValueCodec codec);
}
[IsReadOnlyAttribute]
internal class Microsoft.ML.Data.IO.BlockLookup : ValueType {
    public long BlockOffset;
    public int BlockLength;
    public int DecompressedBlockLength;
    public BlockLookup(long blockOffset, int blockLength, int decompressedBlockLength);
}
internal class Microsoft.ML.Data.IO.CodecFactory : object {
    private Dictionary`2<string, GetCodecFromStreamDelegate> _loadNameToCodecCreator;
    private Dictionary`2<Type, IValueCodec> _simpleCodecTypeMap;
    private MemoryStreamPool _memPool;
    private Encoding _encoding;
    private IHost _host;
    public CodecFactory(IHostEnvironment env, MemoryStreamPool memPool);
    private BinaryWriter OpenBinaryWriter(Stream stream);
    private BinaryReader OpenBinaryReader(Stream stream);
    private void RegisterSimpleCodec(SimpleCodec`1<T> codec);
    private void RegisterOtherCodec(string name, GetCodecFromStreamDelegate fn);
    public bool TryGetCodec(DataViewType type, IValueCodec& codec);
    public int WriteCodec(Stream definitionStream, IValueCodec codec);
    public bool TryReadCodec(Stream definitionStream, IValueCodec& codec);
    private bool GetVBufferCodec(Stream definitionStream, IValueCodec& codec);
    private bool GetVBufferCodec(VectorDataViewType type, IValueCodec& codec);
    private bool GetKeyCodecOld(Stream definitionStream, IValueCodec& codec);
    private bool GetKeyCodec(Stream definitionStream, IValueCodec& codec);
    private bool GetKeyCodec(DataViewType type, IValueCodec& codec);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Data.IO.CompressionCodecExtension : object {
    [ExtensionAttribute]
public static Stream CompressStream(CompressionKind compression, Stream stream);
    [ExtensionAttribute]
public static Stream DecompressStream(CompressionKind compression, Stream stream);
}
internal enum Microsoft.ML.Data.IO.CompressionKind : Enum {
    public byte value__;
    public static CompressionKind None;
    public static CompressionKind Deflate;
    public static CompressionKind Default;
}
internal class Microsoft.ML.Data.IO.Header : ValueType {
    public static int HeaderSize;
    public static ulong SignatureValue;
    public static ulong TailSignatureValue;
    public static ulong WriterVersion;
    public static ulong CanBeReadByVersion;
    public ulong Signature;
    public ulong Version;
    public ulong CompatibleVersion;
    public long TableOfContentsOffset;
    public long TailOffset;
    public long RowCount;
    public int ColumnCount;
    internal static string VersionToString(ulong v);
}
internal interface Microsoft.ML.Data.IO.IValueCodec {
    public string LoadName { get; }
    public DataViewType Type { get; }
    public abstract virtual string get_LoadName();
    public abstract virtual int WriteParameterization(Stream stream);
    public abstract virtual DataViewType get_Type();
}
internal interface Microsoft.ML.Data.IO.IValueCodec`1 {
    public abstract virtual IValueWriter`1<T> OpenWriter(Stream stream);
    public abstract virtual IValueReader`1<T> OpenReader(Stream stream, int items);
}
internal interface Microsoft.ML.Data.IO.IValueReader`1 {
    public abstract virtual void MoveNext();
    public abstract virtual void Get(T& value);
    public abstract virtual void Read(T[] values, int index, int count);
}
internal interface Microsoft.ML.Data.IO.IValueWriter {
    public abstract virtual void Commit();
    public abstract virtual long GetCommitLengthEstimate();
}
internal interface Microsoft.ML.Data.IO.IValueWriter`1 {
    public abstract virtual void Write(T& modreq(System.Runtime.InteropServices.InAttribute) value);
    public abstract virtual void Write(ReadOnlySpan`1<T> values);
}
internal class Microsoft.ML.Data.IO.MemoryStreamCollection : object {
    private MemoryStreamPool[] _pools;
    private static int IndexFor(int maxSize);
    public MemoryStreamPool Get(int maxSize);
}
internal class Microsoft.ML.Data.IO.MemoryStreamPool : object {
    private ObjectPool`1<MemoryStream> _memPool;
    public void Return(MemoryStream& mem);
    public MemoryStream Get();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.IO.TextSaver : object {
    internal static string Summary;
    private bool _forceDense;
    private bool _outputSchema;
    private bool _outputHeader;
    private char _sepChar;
    private string _sepStr;
    private bool _silent;
    private IHost _host;
    private static double _sparseWeight;
    public TextSaver(IHostEnvironment env, Arguments args);
    private static char SepStrToChar(string sep);
    public static string SeparatorCharToString(char separator);
    public sealed virtual bool IsColumnSavable(DataViewType type);
    public sealed virtual void SaveData(Stream stream, IDataView data, Int32[] cols);
    public void SaveData(String& argsLoader, Stream stream, IDataView data, Int32[] cols);
    public void WriteData(IDataView data, bool showCount, Int32[] cols);
    private void ShowCount(IChannel ch, long count, int min, int max);
    private void WriteDataCore(IChannel ch, TextWriter writer, IDataView data, String& argsLoader, Int64& count, Int32& min, Int32& max, Int32[] cols);
    private void WriteSchemaAsComment(TextWriter writer, string str);
    private string CreateLoaderArguments(DataViewSchema schema, ValueWriter[] pipes, bool hasHeader, IChannel ch);
    private Column GetColumn(string name, DataViewType type, Nullable`1<int> start);
}
internal static class Microsoft.ML.Data.IO.TextSaverUtils : object {
    internal static void MapText(ReadOnlySpan`1<char> span, StringBuilder& sb, char sep);
    internal static void MapTimeSpan(TimeSpan& src, StringBuilder& sb);
    internal static void MapDateTime(DateTime& src, StringBuilder& sb);
    internal static void MapDateTimeZone(DateTimeOffset& src, StringBuilder& sb);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.IO.TransposeLoader : object {
    private static FuncInstanceMethodInfo1`3<TransposeLoader, DataViewRowCursor, SlotCursor> _getSlotCursorCoreMethodInfo;
    private int _threads;
    private IMultiStreamSource _file;
    private IHost _host;
    private Header _header;
    private SchemaSubIdv _schemaEntry;
    private TransposedSubIdv[] _entries;
    private Transposer[] _colTransposers;
    private object _colTransposersLock;
    private static ulong ReaderFirstVersion;
    private static ulong ReaderVersion;
    internal static string Summary;
    internal static string LoadName;
    private bool HasRowData { get; }
    public DataViewSchema Schema { get; }
    public bool CanShuffle { get; }
    public TransposeLoader(IHostEnvironment env, Arguments args, IMultiStreamSource file);
    private TransposeLoader(IHost host, ModelLoadContext ctx, IMultiStreamSource file);
    private TransposeLoader(IHost host, ModelLoadContext ctx, IDataView schemaView);
    private static TransposeLoader();
    private static VersionInfo GetVersionInfo();
    private bool get_HasRowData();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual bool get_CanShuffle();
    public static TransposeLoader Create(IHostEnvironment env, ModelLoadContext ctx, IMultiStreamSource files);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private static void SaveSchema(IHostEnvironment env, ModelSaveContext ctx, DataViewSchema schema);
    private Header InitHeader(BinaryReader reader);
    private sealed virtual override VectorDataViewType Microsoft.ML.Data.ITransposeDataView.GetSlotType(int col);
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private sealed virtual override SlotCursor Microsoft.ML.Data.ITransposeDataView.GetSlotCursor(int col);
    private SlotCursor GetSlotCursorCore(DataViewRowCursor inputCursor);
    private Transposer EnsureAndGetTransposer(int col);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.IO.TransposeSaver : object {
    internal static string Summary;
    internal static string LoadName;
    private static ulong WriterVersion;
    private IHost _host;
    private IDataSaver _internalSaver;
    private bool _writeRowData;
    private bool _silent;
    public TransposeSaver(IHostEnvironment env, Arguments args);
    public sealed virtual bool IsColumnSavable(DataViewType type);
    public sealed virtual void SaveData(Stream stream, IDataView data, Int32[] cols);
    private void SaveTransposedData(IChannel ch, Stream stream, ITransposeDataView data, Int32[] cols);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IRowMapper {
    public abstract virtual Func`2<int, bool> GetDependencies(Func`2<int, bool> activeOutput);
    public abstract virtual Delegate[] CreateGetters(DataViewRow input, Func`2<int, bool> activeOutput, Action& disposer);
    public abstract virtual DetachedColumn[] GetOutputColumns();
    public abstract virtual ITransformer GetTransformer();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IRowReadableAs`1 {
    public abstract virtual void FillValues(TRow row);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.IRowSeekable {
    public DataViewSchema Schema { get; }
    public abstract virtual RowSeeker GetSeeker(Func`2<int, bool> predicate);
    public abstract virtual DataViewSchema get_Schema();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ITransformerChainAccessor {
    public ITransformer[] Transformers { get; }
    public TransformerScope[] Scopes { get; }
    public abstract virtual ITransformer[] get_Transformers();
    public abstract virtual TransformerScope[] get_Scopes();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ITransformTemplate {
    public abstract virtual IDataTransform ApplyToData(IHostEnvironment env, IDataView newSource);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Data.ITransposeDataView {
    public abstract virtual SlotCursor GetSlotCursor(int col);
    public abstract virtual VectorDataViewType GetSlotType(int col);
}
public class Microsoft.ML.Data.KeyCount : object {
    [ArgumentAttribute("0")]
public Nullable`1<ulong> Count;
    public KeyCount(ulong count);
    internal static KeyCount Parse(string str);
    private bool TryParse(string str);
    internal bool TryUnparse(StringBuilder sb);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.KeyTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private KeyCount <KeyCount>k__BackingField;
    internal KeyCount KeyCount { get; }
    public KeyTypeAttribute(ulong count);
    [CompilerGeneratedAttribute]
internal KeyCount get_KeyCount();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.LambdaColumnMapper : object {
    public static IDataView Create(IHostEnvironment env, string name, IDataView input, string src, string dst, DataViewType typeSrc, DataViewType typeDst, ValueMapper`2<TSrc, TDst> mapper, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> keyValueGetter, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> slotNamesGetter);
    private static Impl`3<T1, T2, T3> CreateImpl(IHostEnvironment env, string name, IDataView input, Column col, DataViewType typeDst, ValueMapper`2<T1, T2> map1, ValueMapper`2<T2, T3> map2, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> keyValueGetter, ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> slotNamesGetter);
}
internal static class Microsoft.ML.Data.LambdaFilter : object {
    public static IDataView Create(IHostEnvironment env, string name, IDataView input, string src, DataViewType typeSrc, InPredicate`1<TSrc> predicate);
    private static Impl`2<T1, T2> CreateImpl(IHostEnvironment env, string name, IDataView input, int colSrc, InPredicate`1<T2> pred, ValueMapper`2<T1, T2> conv);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.LegacyCompositeDataLoader : object {
    public static string LoaderSignature;
    private static string RegistrationName;
    private static int VersionAddedTags;
    private static string TransformDirTemplate;
    private ILegacyDataLoader _loader;
    private TransformEx[] _transforms;
    private ITransposeDataView _tview;
    private IHost _host;
    [CompilerGeneratedAttribute]
private IDataView <View>k__BackingField;
    public IDataView View { get; }
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    private LegacyCompositeDataLoader(IHost host, TransformEx[] transforms);
    private static VersionInfo GetVersionInfo();
    [CompilerGeneratedAttribute]
public IDataView get_View();
    public static ILegacyDataLoader Create(IHostEnvironment env, Arguments args, IMultiStreamSource files);
    public static ILegacyDataLoader Create(IHostEnvironment env, ILegacyDataLoader srcLoader, KeyValuePair`2[] transformArgs);
    private static ILegacyDataLoader CreateCore(IHost host, ILegacyDataLoader srcLoader, KeyValuePair`2[] transformArgs);
    public static ILegacyDataLoader ApplyTransforms(IHostEnvironment env, ILegacyDataLoader srcLoader, KeyValuePair`2[] tagData, Func`4<IHostEnvironment, int, IDataView, IDataView> createTransform);
    private static ILegacyDataLoader ApplyTransformsCore(IHost host, ILegacyDataLoader srcLoader, KeyValuePair`2[] tagData, Func`4<IHostEnvironment, int, IDataView, IDataView> createTransform);
    public static ILegacyDataLoader ApplyTransform(IHostEnvironment env, ILegacyDataLoader srcLoader, string tag, string creationArgs, Func`3<IHostEnvironment, IDataView, IDataView> createTransform);
    public static ILegacyDataLoader Create(IHostEnvironment env, ModelLoadContext ctx, IMultiStreamSource files);
    public static ILegacyDataLoader Create(IHostEnvironment env, ModelLoadContext ctx, ILegacyDataLoader srcLoader, Func`2<string, bool> isTransformTagAccepted);
    public static IDataView LoadSelectedTransforms(ModelLoadContext ctx, IDataView srcView, IHostEnvironment env, Func`2<string, bool> isTransformTagAccepted);
    internal TransformerChain`1<ITransformer> GetTransformer();
    private static ILegacyDataLoader LoadTransforms(ModelLoadContext ctx, ILegacyDataLoader srcLoader, IHost host, Func`2<string, bool> isTransformTagAccepted);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public static void SavePipe(IHostEnvironment env, ModelSaveContext ctx, Action`1<ModelSaveContext> loaderSaveAction, IList`1<IDataTransform> transforms);
    private static void SaveCore(ModelSaveContext ctx, Action`1<ModelSaveContext> loaderSaveAction, TransformEx[] transforms);
    private static string GenerateTag(int index);
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private sealed virtual override VectorDataViewType Microsoft.ML.Data.ITransposeDataView.GetSlotType(int col);
    private sealed virtual override SlotCursor Microsoft.ML.Data.ITransposeDataView.GetSlotCursor(int col);
    [CompilerGeneratedAttribute]
internal static string <CreateCore>g__GetTagData|16_0(IComponentFactory`2<IDataView, IDataTransform> factory);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.LoadColumnAttribute : Attribute {
    internal List`1<Range> Sources;
    public LoadColumnAttribute(int fieldIndex);
    public LoadColumnAttribute(int start, int end);
    public LoadColumnAttribute(Int32[] columnIndexes);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.LoadColumnNameAttribute : Attribute {
    [BestFriendAttribute]
internal IReadOnlyList`1<string> Sources;
    public LoadColumnNameAttribute(string fieldName);
    public LoadColumnNameAttribute(String[] fieldNames);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.LoaderUtils : object {
    public static void SaveLoader(ILegacyDataLoader loader, IFileHandle file, IHostEnvironment host);
    public static void SaveLoader(ILegacyDataLoader loader, Stream stream, IHostEnvironment host);
}
internal class Microsoft.ML.Data.LocalEnvironment : HostEnvironmentBase`1<LocalEnvironment> {
    public LocalEnvironment(Nullable`1<int> seed);
    public void AddListener(Action`2<IMessageSource, ChannelMessage> listener);
    public void RemoveListener(Action`2<IMessageSource, ChannelMessage> listener);
    protected virtual IHost RegisterCore(HostEnvironmentBase`1<LocalEnvironment> source, string shortName, string parentFullName, Random rand, bool verbose);
    protected virtual IChannel CreateCommChannel(ChannelProviderBase parent, string name);
    protected virtual IPipe`1<TMessage> CreatePipe(ChannelProviderBase parent, string name);
}
internal abstract class Microsoft.ML.Data.MamlEvaluatorBase : object {
    internal static ColumnRole Strat;
    [BestFriendAttribute]
private protected IHost Host;
    [BestFriendAttribute]
private protected string ScoreColumnKind;
    [BestFriendAttribute]
private protected string ScoreCol;
    [BestFriendAttribute]
private protected string LabelCol;
    [BestFriendAttribute]
private protected string WeightCol;
    [BestFriendAttribute]
private protected String[] StratCols;
    [BestFriendAttribute]
private protected IEvaluator Evaluator { get; }
    [BestFriendAttribute]
private protected MamlEvaluatorBase(ArgumentsBase args, IHostEnvironment env, string scoreColumnKind, string registrationName);
    private static MamlEvaluatorBase();
    private protected abstract virtual IEvaluator get_Evaluator();
    private sealed virtual override Dictionary`2<string, IDataView> Microsoft.ML.Data.IEvaluator.Evaluate(RoleMappedData data);
    [BestFriendAttribute]
private protected IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRoles(RoleMappedSchema schema, bool needStrat, bool needName);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MamlEvaluatorBase/<GetInputColumnRolesCore>d__13")]
[BestFriendAttribute]
private protected virtual IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRolesCore(RoleMappedSchema schema);
    public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private sealed virtual override void Microsoft.ML.Data.IMamlEvaluator.PrintFoldResults(IChannel ch, Dictionary`2<string, IDataView> metrics);
    [BestFriendAttribute]
private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
    private sealed virtual override IDataView Microsoft.ML.Data.IMamlEvaluator.GetOverallResults(IDataView[] metrics);
    [BestFriendAttribute]
private protected virtual IDataView CombineOverallMetricsCore(IDataView[] metrics);
    [BestFriendAttribute]
private protected virtual IDataView GetOverallResultsCore(IDataView overall);
    private sealed virtual override void Microsoft.ML.Data.IMamlEvaluator.PrintAdditionalMetrics(IChannel ch, Dictionary`2[] metrics);
    [BestFriendAttribute]
private protected virtual void PrintAdditionalMetricsCore(IChannel ch, Dictionary`2[] metrics);
    private sealed virtual override IDataTransform Microsoft.ML.Data.IEvaluator.GetPerInstanceMetrics(RoleMappedData scoredData);
    private IDataView WrapPerInstance(RoleMappedData perInst);
    [BestFriendAttribute]
private protected virtual IDataView GetPerInstanceMetricsCore(IDataView perInst, RoleMappedSchema schema);
    private sealed virtual override IDataView Microsoft.ML.Data.IMamlEvaluator.GetPerInstanceDataViewToSave(RoleMappedData perInstance);
    [BestFriendAttribute]
private protected abstract virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.ManyToOneColumn : object {
    [ArgumentAttribute("0")]
public string Name;
    [ArgumentAttribute("4")]
public String[] Source;
    [BestFriendAttribute]
private protected virtual bool TryParse(string str);
    [BestFriendAttribute]
private protected bool TryParse(string str, String& extra);
    protected virtual bool TryUnparseCore(StringBuilder sb);
    protected virtual bool TryUnparseCore(StringBuilder sb, string extra);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MetadataDispatcher : MetadataDispatcherBase {
    public MetadataDispatcher(int colCount);
    public Builder BuildMetadata(int index);
    public Builder BuildMetadata(int index, DataViewSchema schemaSrc, int indexSrc);
    public Builder BuildMetadata(int index, DataViewSchema schemaSrc, int indexSrc, Func`3<string, int, bool> filterSrc);
    public Builder BuildMetadata(int index, DataViewSchema schemaSrc, int indexSrc, string kindSrc);
    public Builder BuildMetadata(int index, DataViewSchema schemaSrc, int indexSrc, String[] kindsSrc);
    public void Seal();
}
internal abstract class Microsoft.ML.Data.MetadataDispatcherBase : object {
    private bool _sealed;
    private ColInfo[] _infos;
    protected int ColCount { get; }
    protected MetadataDispatcherBase(int colCount);
    protected int get_ColCount();
    protected ColInfo CreateInfo(DataViewSchema schemaSrc, int indexSrc, Func`3<string, int, bool> filterSrc);
    protected void RegisterColumn(int index, ColInfo info);
    protected void Seal();
    protected ColInfo GetColInfoOrNull(int index);
    public IEnumerable`1<KeyValuePair`2<string, DataViewType>> GetMetadataTypes(int index);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MetadataDispatcherBase/<GetTypesCore>d__15")]
private IEnumerable`1<KeyValuePair`2<string, DataViewType>> GetTypesCore(int index, ColInfo info);
    public DataViewType GetMetadataTypeOrNull(string kind, int index);
    public void GetMetadata(IExceptionContext ectx, string kind, int index, TValue& value);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MetricColumn : object {
    public string LoadName;
    public bool IsVector;
    public Objective MetricTarget;
    public string Name;
    public bool CanBeWeighted;
    private Regex _loadNamePattern;
    private string _groupName;
    private string _nameFormat;
    public MetricColumn(string loadName, string name, Objective target, bool canBeWeighted, bool isVector, Regex namePattern, string groupName, string nameFormat);
    public string GetNameMatch(string input);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.MetricKinds : object {
    public static string ConfusionMatrix;
    public static string OverallMetrics;
    public static string PrCurve;
    public static string Warnings;
}
internal static class Microsoft.ML.Data.MetricWriter : object {
    public static string GetConfusionTableAsFormattedString(IHost host, IDataView confusionDataView, String& weightedConfusionTable, bool binary, int sample);
    public static ConfusionMatrix GetConfusionMatrix(IHost host, IDataView confusionDataView, bool binary, int sample, bool getWeighted);
    private static List`1<ReadOnlyMemory`1<char>> GetPredictedLabelNames(VBuffer`1& labelNames, Int32[] labelIndexToConfIndexMap);
    private static Double[][] GetConfusionTableAsArray(IDataView confusionDataView, int countIndex, int numClasses, Int32[] labelIndexToConfIndexMap, int numConfusionTableLabels, Double[]& precisionSums, Double[]& recallSums);
    public static string GetPerFoldResults(IHostEnvironment env, IDataView fold, String& weightedMetrics);
    private static string GetOverallMetricsAsString(Double[] sumMetrics, Double[] sumSqMetrics, int numFolds, bool weighted, bool average, List`1<string> metricNames);
    private static string GetFoldMetricsAsString(IHostEnvironment env, IDataView data, String& weightedMetricsString);
    internal static string GetConfusionTableAsString(ConfusionMatrix confusionMatrix, bool isWeighted);
    public static void PrintOverallMetrics(IHostEnvironment env, IChannel ch, string filename, IDataView overall, int numFolds);
    private static string PadLeft(string str, int totalLength);
    public static void PrintWarnings(IChannel ch, Dictionary`2<string, IDataView> metrics);
    public static void SavePerInstance(IHostEnvironment env, IChannel ch, string filename, IDataView data, bool dense, bool saveSchema);
    public static IDataView GetNonStratifiedMetrics(IHostEnvironment env, IDataView data);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MulticlassClassificationEvaluator : RowToRowEvaluatorBase`1<Aggregator> {
    public static string AccuracyMicro;
    public static string AccuracyMacro;
    public static string TopKAccuracy;
    public static string AllTopKAccuracy;
    public static string PerClassLogLoss;
    public static string LogLoss;
    public static string LogLossReduction;
    internal static string LoadName;
    private Nullable`1<int> _outputTopKAcc;
    private bool _names;
    public MulticlassClassificationEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    private ReadOnlyMemory`1[] GetClassNames(RoleMappedSchema schema);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MulticlassClassificationEvaluator/<GetOverallMetricColumns>d__17")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
    public MulticlassClassificationMetrics Evaluate(IDataView data, string label, string score, string predictedLabel);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MulticlassClassificationMamlEvaluator : MamlEvaluatorBase {
    private static string TopKAccuracyFormat;
    private bool _outputPerClass;
    private int _numTopClasses;
    private int _numConfusionTableClasses;
    private Nullable`1<int> _outputTopKAcc;
    private MulticlassClassificationEvaluator _evaluator;
    private protected IEvaluator Evaluator { get; }
    public MulticlassClassificationMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
    private protected virtual IDataView CombineOverallMetricsCore(IDataView[] metrics);
    private IDataView ChangeTopKAccColumnName(IDataView input);
    private IDataView ChangeAllTopKAccColumnName(IDataView input);
    private IDataView DropColumn(IDataView input, string columnToDrop);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MulticlassClassificationMamlEvaluator/<GetOverallMetricColumns>d__15")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MulticlassClassificationMamlEvaluator/<GetPerInstanceColumnsToSave>d__16")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
    private protected virtual IDataView GetPerInstanceMetricsCore(IDataView perInst, RoleMappedSchema schema);
}
public class Microsoft.ML.Data.MulticlassClassificationMetrics : object {
    [CompilerGeneratedAttribute]
private double <LogLoss>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LogLossReduction>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MacroAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MicroAccuracy>k__BackingField;
    [CompilerGeneratedAttribute]
private int <TopKPredictionCount>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <TopKAccuracyForAllK>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <PerClassLogLoss>k__BackingField;
    [CompilerGeneratedAttribute]
private ConfusionMatrix <ConfusionMatrix>k__BackingField;
    public double LogLoss { get; }
    public double LogLossReduction { get; private set; }
    public double MacroAccuracy { get; }
    public double MicroAccuracy { get; }
    public double TopKAccuracy { get; }
    public int TopKPredictionCount { get; }
    public IReadOnlyList`1<double> TopKAccuracyForAllK { get; }
    public IReadOnlyList`1<double> PerClassLogLoss { get; }
    public ConfusionMatrix ConfusionMatrix { get; }
    internal MulticlassClassificationMetrics(IHost host, DataViewRow overallResult, int topKPredictionCount, IDataView confusionMatrix);
    internal MulticlassClassificationMetrics(double accuracyMicro, double accuracyMacro, double logLoss, double logLossReduction, int topKPredictionCount, Double[] topKAccuracies, Double[] perClassLogLoss);
    internal MulticlassClassificationMetrics(double accuracyMicro, double accuracyMacro, double logLoss, double logLossReduction, int topKPredictionCount, Double[] topKAccuracies, Double[] perClassLogLoss, ConfusionMatrix confusionMatrix);
    [CompilerGeneratedAttribute]
public double get_LogLoss();
    [CompilerGeneratedAttribute]
public double get_LogLossReduction();
    [CompilerGeneratedAttribute]
private void set_LogLossReduction(double value);
    [CompilerGeneratedAttribute]
public double get_MacroAccuracy();
    [CompilerGeneratedAttribute]
public double get_MicroAccuracy();
    public double get_TopKAccuracy();
    [CompilerGeneratedAttribute]
public int get_TopKPredictionCount();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_TopKAccuracyForAllK();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_PerClassLogLoss();
    [CompilerGeneratedAttribute]
public ConfusionMatrix get_ConfusionMatrix();
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__FetchDouble|27_0(string name, <>c__DisplayClass27_0& );
}
internal class Microsoft.ML.Data.MulticlassClassificationScorer : PredictedLabelScorerBase {
    public static string LoaderSignature;
    private static string RegistrationName;
    [BestFriendAttribute]
internal MulticlassClassificationScorer(IHostEnvironment env, Arguments args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private MulticlassClassificationScorer(IHostEnvironment env, MulticlassClassificationScorer transform, IDataView newSource);
    private MulticlassClassificationScorer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    private static ISchemaBoundMapper WrapIfNeeded(IHostEnvironment env, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    internal static bool CanWrapTrainingLabels(ISchemaBoundMapper mapper, DataViewType labelNameType);
    internal static bool GetTypesForWrapping(ISchemaBoundMapper mapper, DataViewType labelNameType, string metaKind, DataViewType& scoreType);
    internal static bool CanWrapSlotNames(ISchemaBoundMapper mapper, DataViewType labelNameType);
    internal static ISchemaBoundMapper WrapCore(IHostEnvironment env, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private static MulticlassClassificationScorer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private protected virtual IDataTransform ApplyToDataCore(IHostEnvironment env, IDataView newSource);
    protected virtual Delegate GetPredictedLabelGetter(DataViewRow output, Delegate& scoreGetter);
    private protected virtual JToken PredictedLabelPfa(String[] mapperOutputs);
    private static DataViewType GetPredColType(DataViewType scoreType, ISchemaBoundRowMapper mapper);
    private static bool OutputTypeMatches(DataViewType scoreType);
}
internal class Microsoft.ML.Data.MulticlassPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int AssignedCol;
    private static int LogLossCol;
    private static int SortedScoresCol;
    private static int SortedClassesCol;
    private static UInt32 VerInitial;
    public static string Assigned;
    public static string LogLoss;
    public static string SortedScores;
    public static string SortedClasses;
    private static float Epsilon;
    private int _numClasses;
    private ReadOnlyMemory`1[] _classNames;
    private DataViewType[] _types;
    public MulticlassPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, Column scoreColumn, string labelCol);
    private MulticlassPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static MulticlassPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> CreateSlotNamesGetter(int numTopClasses, string suffix);
    private ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> CreateKeyValueGetter();
    private void CheckInputColumnTypes(DataViewSchema schema);
    [CompilerGeneratedAttribute]
private void <CreateKeyValueGetter>b__23_0(VBuffer`1& dst);
}
internal static class Microsoft.ML.Data.MulticlassPredictionTransformer : object {
    public static string LoaderSignature;
    private static string DirModel;
    public static ISingleFeaturePredictionTransformer`1<object> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.MulticlassPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    private string _trainLabelColumn;
    private string _scoreColumn;
    private string _predictedLabelColumn;
    [BestFriendAttribute]
internal MulticlassPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn, string labelColumn, string scoreColumn, string predictedLabel);
    internal MulticlassPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    internal MulticlassPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx, IHost host, TModel model);
    private void InitializationLogic(ModelLoadContext ctx, String& trainLabelColumn, String& scoreColumn, String& predictedLabelColumn);
    private void SetScorer();
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
public class Microsoft.ML.Data.MultiFileSource : object {
    private String[] _paths;
    public int Count { get; }
    public MultiFileSource(String[] paths);
    public sealed virtual int get_Count();
    public sealed virtual string GetPathOrNull(int index);
    public sealed virtual Stream Open(int index);
    public sealed virtual TextReader OpenTextReader(int index);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MultiOutputRegressionEvaluator : RegressionLossEvaluatorBase`1<Aggregator> {
    private static string Dist;
    private static string PerLabelL1;
    private static string PerLabelL2;
    private static string PerLabelRms;
    private static string PerLabelLoss;
    public static string LoadName;
    public MultiOutputRegressionEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MultiOutputRegressionEvaluator/<GetOverallMetricColumns>d__11")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator : MamlEvaluatorBase {
    private MultiOutputRegressionEvaluator _evaluator;
    private bool _suppressScoresAndLabels;
    private protected IEvaluator Evaluator { get; }
    public MultiOutputRegressionMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.MultiOutputRegressionMamlEvaluator/<GetPerInstanceColumnsToSave>d__6")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
    private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
}
internal class Microsoft.ML.Data.MultiOutputRegressionPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int LabelOutput;
    private static int ScoreOutput;
    private static int L1Output;
    private static int L2Output;
    private static int DistCol;
    public static string L1;
    public static string L2;
    public static string Dist;
    private VectorDataViewType _labelType;
    private VectorDataViewType _scoreType;
    private Annotations _labelMetadata;
    private Annotations _scoreMetadata;
    public MultiOutputRegressionPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, string scoreCol, string labelCol);
    private MultiOutputRegressionPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static MultiOutputRegressionPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private void CheckInputColumnTypes(DataViewSchema schema, VectorDataViewType& labelType, VectorDataViewType& scoreType, Annotations& labelMetadata, Annotations& scoreMetadata);
    private ValueGetter`1<UInt32> GetScoreColumnSetId(DataViewSchema schema);
    private void GetScoreColumnKind(ReadOnlyMemory`1& dst);
    private void GetScoreValueKind(ReadOnlyMemory`1& dst);
    private ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> CreateSlotNamesGetter(DataViewSchema schema, int column, int length, string prefix);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.NoColumnAttribute : Attribute {
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.NopTransform : object {
    private IHost _host;
    [CompilerGeneratedAttribute]
private IDataView <Source>k__BackingField;
    internal static string Summary;
    public static string LoaderSignature;
    internal static string RegistrationName;
    public IDataView Source { get; }
    private DataViewSchema Microsoft.ML.Data.IRowToRowMapper.InputSchema { get; }
    public bool CanShuffle { get; }
    private DataViewSchema Microsoft.ML.IDataView.Schema { get; }
    public DataViewSchema OutputSchema { get; }
    private NopTransform(IHostEnvironment env, IDataView input);
    private NopTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static NopTransform();
    [CompilerGeneratedAttribute]
public sealed virtual IDataView get_Source();
    private sealed virtual override DataViewSchema Microsoft.ML.Data.IRowToRowMapper.get_InputSchema();
    public static IDataTransform CreateIfNeeded(IHostEnvironment env, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static NopTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual bool get_CanShuffle();
    private sealed virtual override DataViewSchema Microsoft.ML.IDataView.get_Schema();
    public sealed virtual DataViewSchema get_OutputSchema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private sealed virtual override IEnumerable`1<Column> Microsoft.ML.Data.IRowToRowMapper.GetDependencies(IEnumerable`1<Column> dependingColumns);
    private sealed virtual override DataViewRow Microsoft.ML.Data.IRowToRowMapper.GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
    [EntryPointAttribute]
public static TransformOutput Nop(IHostEnvironment env, NopInput input);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.Normalize : object {
    [EntryPointAttribute]
public static TransformOutput MinMax(IHostEnvironment env, MinMaxArguments input);
    [EntryPointAttribute]
public static TransformOutput MeanVar(IHostEnvironment env, MeanVarArguments input);
    [EntryPointAttribute]
public static TransformOutput LogMeanVar(IHostEnvironment env, LogMeanVarArguments input);
    [EntryPointAttribute]
public static TransformOutput Bin(IHostEnvironment env, BinArguments input);
    [EntryPointAttribute]
public static TransformOutput RobustScaling(IHostEnvironment env, RobustScalingArguments input);
    [EntryPointAttribute]
public static MacroOutput`1<TransformOutput> IfNeeded(IHostEnvironment env, MinMaxArguments input, EntryPointNode node);
}
[BestFriendAttribute]
internal enum Microsoft.ML.Data.NormalizeOption : Enum {
    public int value__;
    public static NormalizeOption No;
    public static NormalizeOption Warn;
    public static NormalizeOption Auto;
    public static NormalizeOption Yes;
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.OneToOneColumn : SourceNameColumnBase {
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.OneToOneTransformBase : RowToRowMapperTransformBase {
    private static FuncInstanceMethodInfo1`4<OneToOneTransformBase, DataViewRow, int, Delegate> _getSrcGetterMethodInfo;
    private Bindings _bindings;
    protected ColInfo[] Infos;
    private protected ITransposeDataView InputTranspose;
    [CompilerGeneratedAttribute]
private MetadataDispatcher <Metadata>k__BackingField;
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    private protected bool CanSavePfaCore { get; }
    private protected bool CanSaveOnnxCore { get; }
    [BestFriendAttribute]
private protected MetadataDispatcher Metadata { get; }
    public DataViewSchema OutputSchema { get; }
    [BestFriendAttribute]
private protected OneToOneTransformBase(IHostEnvironment env, string name, OneToOneColumn[] column, IDataView input, Func`2<DataViewType, string> testType);
    [BestFriendAttribute]
private protected OneToOneTransformBase(IHost host, OneToOneColumn[] column, IDataView input, Func`2<DataViewType, string> testType);
    [BestFriendAttribute]
private protected OneToOneTransformBase(IHost host, ModelLoadContext ctx, IDataView input, Func`2<DataViewType, string> testType);
    [BestFriendAttribute]
private protected OneToOneTransformBase(IHostEnvironment env, string name, OneToOneTransformBase transform, IDataView newInput, Func`2<DataViewType, string> checkType);
    private static OneToOneTransformBase();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private protected virtual bool get_CanSavePfaCore();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    private protected virtual bool get_CanSaveOnnxCore();
    [CompilerGeneratedAttribute]
private protected MetadataDispatcher get_Metadata();
    [BestFriendAttribute]
private protected void SaveBase(ModelSaveContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.ISaveAsPfa.SaveAsPfa(BoundPfaContext ctx);
    private sealed virtual override void Microsoft.ML.Model.OnnxConverter.ISaveAsOnnx.SaveAsOnnx(OnnxContext ctx);
    [BestFriendAttribute]
private protected virtual JToken SaveAsPfaCore(BoundPfaContext ctx, int iinfo, ColInfo info, JToken srcToken);
    [BestFriendAttribute]
private protected virtual bool SaveAsOnnxCore(OnnxContext ctx, int iinfo, ColInfo info, string srcVariableName, string dstVariableName);
    public sealed virtual DataViewSchema get_OutputSchema();
    private sealed virtual override VectorDataViewType Microsoft.ML.Data.ITransposeDataView.GetSlotType(int col);
    protected int ColumnIndex(int iinfo);
    protected abstract virtual DataViewType GetColumnTypeCore(int iinfo);
    protected virtual VectorDataViewType GetSlotTypeCore(int iinfo);
    protected virtual void ActivateSourceColumns(int iinfo, Boolean[] active);
    protected abstract virtual Delegate GetGetterCore(IChannel ch, DataViewRow input, int iinfo, Action& disposer);
    protected ValueGetter`1<T> GetSrcGetter(DataViewRow input, int iinfo);
    protected Delegate GetSrcGetter(DataViewType typeDst, DataViewRow row, int iinfo);
    protected sealed virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual bool WantParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    protected Exception ExceptGetSlotCursor(int col);
    private sealed virtual override SlotCursor Microsoft.ML.Data.ITransposeDataView.GetSlotCursor(int col);
    [BestFriendAttribute]
internal virtual SlotCursor GetSlotCursorCore(int iinfo);
    protected virtual int MapColumnIndex(Boolean& isSrc, int col);
    protected virtual IEnumerable`1<Column> GetDependenciesCore(IEnumerable`1<Column> dependingColumns);
    protected virtual Delegate[] CreateGetters(DataViewRow input, IEnumerable`1<Column> activeColumns, Action& disposer);
    protected static string TestIsText(DataViewType type);
    protected static string TestIsTextItem(DataViewType type);
    protected static string TestIsTextVector(DataViewType type);
    protected static string TestIsFloatItem(DataViewType type);
    protected static string TestIsFloatVector(DataViewType type);
    protected static string TestIsKnownSizeFloatVector(DataViewType type);
    protected static string TestIsKey(DataViewType type);
}
public abstract class Microsoft.ML.Data.OneToOneTransformerBase : RowToRowTransformerBase {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[BestFriendAttribute]
internal ValueTuple`2[] ColumnPairs;
    [BestFriendAttribute]
private protected OneToOneTransformerBase(IHost host, ValueTuple`2[] columns);
    [BestFriendAttribute]
private protected OneToOneTransformerBase(IHost host, ModelLoadContext ctx);
    [BestFriendAttribute]
private protected void SaveColumns(ModelSaveContext ctx);
    private void CheckInput(DataViewSchema inputSchema, int col, Int32& srcCol);
    [BestFriendAttribute]
private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.OpaqueDataView : object {
    private IDataView _source;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    public OpaqueDataView(IDataView source);
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal abstract class Microsoft.ML.Data.PerGroupTransformBase`3 : object {
    protected IHost Host;
    protected string LabelCol;
    protected string ScoreCol;
    protected string GroupCol;
    [CompilerGeneratedAttribute]
private IDataView <Source>k__BackingField;
    private DataViewSchema Microsoft.ML.IDataView.Schema { get; }
    public DataViewSchema OutputSchema { get; }
    public IDataView Source { get; }
    public bool CanShuffle { get; }
    protected PerGroupTransformBase`3(IHostEnvironment env, IDataView input, string labelCol, string scoreCol, string groupCol, string registrationName);
    protected PerGroupTransformBase`3(IHostEnvironment env, ModelLoadContext ctx, IDataView input, string registrationName);
    private sealed virtual override DataViewSchema Microsoft.ML.IDataView.get_Schema();
    public DataViewSchema get_OutputSchema();
    [CompilerGeneratedAttribute]
public sealed virtual IDataView get_Source();
    public sealed virtual bool get_CanShuffle();
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected abstract virtual BindingsBase<TLabel, TScore, TState> GetBindings();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    private DataViewRowCursor GetRowCursorCore(Func`2<int, bool> predicate);
    protected abstract virtual Delegate[] CreateGetters(TState state, Func`2<int, bool> predicate);
    protected abstract virtual ValueGetter`1<TLabel> GetLabelGetter(DataViewRow row);
    protected abstract virtual ValueGetter`1<TScore> GetScoreGetter(DataViewRow row);
    protected abstract virtual TState InitializeState(DataViewRow input);
    protected abstract virtual void ProcessExample(TState state, TLabel label, TScore score);
    protected abstract virtual void UpdateState(TState state);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.PerInstanceEvaluatorBase : object {
    protected IHost Host;
    protected string ScoreCol;
    protected string LabelCol;
    protected int ScoreIndex;
    protected int LabelIndex;
    protected PerInstanceEvaluatorBase(IHostEnvironment env, DataViewSchema schema, string scoreCol, string labelCol);
    protected PerInstanceEvaluatorBase(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private sealed virtual override Func`2<int, bool> Microsoft.ML.Data.IRowMapper.GetDependencies(Func`2<int, bool> activeOutput);
    [BestFriendAttribute]
private protected abstract virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private sealed virtual override DetachedColumn[] Microsoft.ML.Data.IRowMapper.GetOutputColumns();
    [BestFriendAttribute]
private protected abstract virtual DetachedColumn[] GetOutputColumnsCore();
    private sealed virtual override Delegate[] Microsoft.ML.Data.IRowMapper.CreateGetters(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    [BestFriendAttribute]
private protected abstract virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    public sealed virtual ITransformer GetTransformer();
}
internal abstract class Microsoft.ML.Data.PredictedLabelScorerBase : RowToRowScorerBase {
    [BestFriendAttribute]
private protected BindingsImpl Bindings;
    [CompilerGeneratedAttribute]
private DataViewSchema <OutputSchema>k__BackingField;
    private bool _disposed;
    public DataViewSchema OutputSchema { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    [BestFriendAttribute]
private protected PredictedLabelScorerBase(ScorerArgumentsBase args, IHostEnvironment env, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema, string registrationName, string scoreColKind, string scoreColName, Func`2<DataViewType, bool> outputTypeMatches, Func`3<DataViewType, ISchemaBoundRowMapper, DataViewType> getPredColType, string predictedLabelColumnName);
    protected PredictedLabelScorerBase(IHostEnvironment env, PredictedLabelScorerBase transform, IDataView newSource, string registrationName);
    [BestFriendAttribute]
private protected PredictedLabelScorerBase(IHost host, ModelLoadContext ctx, IDataView input, Func`2<DataViewType, bool> outputTypeMatches, Func`3<DataViewType, ISchemaBoundRowMapper, DataViewType> getPredColType);
    [BestFriendAttribute]
private protected sealed virtual BindingsBase GetBindings();
    [CompilerGeneratedAttribute]
public virtual DataViewSchema get_OutputSchema();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.ISaveAsPfa.SaveAsPfa(BoundPfaContext ctx);
    [BestFriendAttribute]
private protected abstract virtual JToken PredictedLabelPfa(String[] mapperOutputs);
    private sealed virtual override void Microsoft.ML.Model.OnnxConverter.ISaveAsOnnx.SaveAsOnnx(OnnxContext ctx);
    [BestFriendAttribute]
private protected virtual void SaveAsOnnxCore(OnnxContext ctx);
    protected virtual bool WantParallelCursors(Func`2<int, bool> predicate);
    protected virtual Delegate[] GetGetters(DataViewRow output, Func`2<int, bool> predicate);
    protected abstract virtual Delegate GetPredictedLabelGetter(DataViewRow output, Delegate& scoreGetter);
    protected void EnsureCachedPosition(Int64& cachedPosition, TScore& score, DataViewRow boundRow, ValueGetter`1<TScore> scoreGetter);
    public sealed virtual void Dispose();
}
internal static class Microsoft.ML.Data.PredictionTransformerBase : object {
    internal static string DirModel;
}
public abstract class Microsoft.ML.Data.PredictionTransformerBase`1 : object {
    [CompilerGeneratedAttribute]
private TModel <Model>k__BackingField;
    [BestFriendAttribute]
private protected static string DirModel;
    [BestFriendAttribute]
private protected static string DirTransSchema;
    [BestFriendAttribute]
private protected IHost Host;
    [BestFriendAttribute]
private protected ISchemaBindableMapper BindableMapper;
    [BestFriendAttribute]
internal DataViewSchema TrainSchema;
    [CompilerGeneratedAttribute]
private RowToRowScorerBase <Scorer>k__BackingField;
    private bool _disposed;
    public TModel Model { get; }
    private protected IPredictor ModelAsPredictor { get; }
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    [BestFriendAttribute]
private protected RowToRowScorerBase Scorer { get; private protected set; }
    [BestFriendAttribute]
private protected PredictionTransformerBase`1(IHost host, TModel model, DataViewSchema trainSchema);
    [BestFriendAttribute]
private protected PredictionTransformerBase`1(IHost host, ModelLoadContext ctx);
    [BestFriendAttribute]
private protected PredictionTransformerBase`1(IHost host, ModelLoadContext ctx, TModel model);
    [CompilerGeneratedAttribute]
public sealed virtual TModel get_Model();
    private protected IPredictor get_ModelAsPredictor();
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    [CompilerGeneratedAttribute]
private protected RowToRowScorerBase get_Scorer();
    [CompilerGeneratedAttribute]
private protected void set_Scorer(RowToRowScorerBase value);
    private void InitializeLogic(IHost host, ModelLoadContext ctx);
    public abstract virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected abstract virtual void SaveModel(ModelSaveContext ctx);
    [BestFriendAttribute]
private protected void SaveModelCore(ModelSaveContext ctx);
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
private void <SaveModelCore>b__25_0(BinaryWriter writer);
}
[AttributeUsageAttribute("4")]
internal class Microsoft.ML.Data.PredictionTransformerLoadTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Type <LoadType>k__BackingField;
    internal Type LoadType { get; }
    internal PredictionTransformerLoadTypeAttribute(Type loadtype);
    [CompilerGeneratedAttribute]
internal Type get_LoadType();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.QuantileRegressionEvaluator : RegressionEvaluatorBase`3<Aggregator, VBuffer`1<float>, VBuffer`1<double>> {
    public static string LoadName;
    public QuantileRegressionEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.QuantileRegressionEvaluator/<GetOverallMetricColumns>d__6")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.QuantileRegressionMamlEvaluator : MamlEvaluatorBase {
    private Nullable`1<int> _index;
    private QuantileRegressionEvaluator _evaluator;
    private protected IEvaluator Evaluator { get; }
    public QuantileRegressionMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    private protected virtual void PrintFoldResultsCore(IChannel ch, Dictionary`2<string, IDataView> metrics);
    private protected virtual IDataView GetOverallResultsCore(IDataView overall);
    private IDataView ExtractRelevantIndex(IDataView data);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.QuantileRegressionMamlEvaluator/<GetOverallMetricColumns>d__9")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.QuantileRegressionMamlEvaluator/<GetPerInstanceColumnsToSave>d__10")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
}
internal class Microsoft.ML.Data.QuantileRegressionPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int L1Col;
    private static int L2Col;
    public static string L1;
    public static string L2;
    private int _scoreSize;
    private VBuffer`1<ReadOnlyMemory`1<char>> _quantiles;
    private DataViewType _outputType;
    public QuantileRegressionPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, string scoreCol, string labelCol, int scoreSize, VBuffer`1<ReadOnlyMemory`1<char>> quantiles);
    private QuantileRegressionPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static QuantileRegressionPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> CreateSlotNamesGetter(string prefix);
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private void CheckInputColumnTypes(DataViewSchema schema);
}
internal static class Microsoft.ML.Data.QuantileRegressionScorerTransform : object {
    private static IDataScorerTransform Create(IHostEnvironment env, Arguments args, IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    private static ISchemaBindableMapper Create(IHostEnvironment env, Arguments args, IPredictor predictor);
    private static Double[] ParseQuantiles(string quantiles);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.R4Adder : Combiner`1<float> {
    private static R4Adder modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static R4Adder Instance { get; }
    public static R4Adder get_Instance();
    public virtual bool IsDefault(float value);
    public virtual void Combine(Single& dst, float src);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.R8Adder : Combiner`1<double> {
    private static R8Adder modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static R8Adder Instance { get; }
    public static R8Adder get_Instance();
    public virtual bool IsDefault(double value);
    public virtual void Combine(Double& dst, double src);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RankingEvaluator : EvaluatorBase`1<Aggregator> {
    internal static string LoadName;
    public static string Ndcg;
    public static string Dcg;
    public static string MaxDcg;
    public static string GroupSummary;
    private static string GroupId;
    private int _truncationLevel;
    private bool _groupSummary;
    private Double[] _labelGains;
    public RankingEvaluator(IHostEnvironment env, RankingEvaluatorOptions options);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual void CheckCustomColumnTypesCore(RoleMappedSchema schema);
    private protected virtual Func`2<int, bool> GetActiveColsCore(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    internal virtual IDataTransform GetPerInstanceMetricsCore(RoleMappedData data);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RankingEvaluator/<GetOverallMetricColumns>d__15")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    private protected virtual void GetAggregatorConsolidationFuncs(Aggregator aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
    public RankingMetrics Evaluate(IDataView data, string label, string groupId, string score);
}
public class Microsoft.ML.Data.RankingEvaluatorOptions : object {
    [ArgumentAttribute("0")]
public int DcgTruncationLevel;
    [ArgumentAttribute("0")]
public string LabelGains;
    [ArgumentAttribute("0")]
internal bool OutputGroupSummary;
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RankingMamlEvaluator : MamlEvaluatorBase {
    private RankingEvaluator _evaluator;
    private string _groupIdCol;
    private string _groupSummaryFilename;
    private protected IEvaluator Evaluator { get; }
    public RankingMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    private protected virtual IEnumerable`1<KeyValuePair`2<ColumnRole, string>> GetInputColumnRolesCore(RoleMappedSchema schema);
    private protected virtual void PrintAdditionalMetricsCore(IChannel ch, Dictionary`2[] metrics);
    private bool TryGetGroupSummaryMetrics(Dictionary`2[] metrics, IDataView& gs);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RankingMamlEvaluator/<GetPerInstanceColumnsToSave>d__10")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
}
public class Microsoft.ML.Data.RankingMetrics : object {
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <NormalizedDiscountedCumulativeGains>k__BackingField;
    [CompilerGeneratedAttribute]
private IReadOnlyList`1<double> <DiscountedCumulativeGains>k__BackingField;
    public IReadOnlyList`1<double> NormalizedDiscountedCumulativeGains { get; }
    public IReadOnlyList`1<double> DiscountedCumulativeGains { get; }
    internal RankingMetrics(IExceptionContext ectx, DataViewRow overallResult);
    internal RankingMetrics(Double[] dcg, Double[] ndcg);
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_NormalizedDiscountedCumulativeGains();
    [CompilerGeneratedAttribute]
public IReadOnlyList`1<double> get_DiscountedCumulativeGains();
    private static T Fetch(IExceptionContext ectx, DataViewRow row, string name);
    [CompilerGeneratedAttribute]
internal static VBuffer`1<double> <.ctor>g__Fetch|7_0(string name, <>c__DisplayClass7_0& );
}
internal class Microsoft.ML.Data.RankingPerInstanceTransform : object {
    public static string LoaderSignature;
    private static string RegistrationName;
    public static string Ndcg;
    public static string Dcg;
    public static string MaxDcg;
    private Transform _transform;
    public IDataView Source { get; }
    public bool CanShuffle { get; }
    private DataViewSchema Microsoft.ML.IDataView.Schema { get; }
    public DataViewSchema OutputSchema { get; }
    public RankingPerInstanceTransform(IHostEnvironment env, IDataView input, string labelCol, string scoreCol, string groupCol, int truncationLevel, Double[] labelGains);
    private RankingPerInstanceTransform(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public sealed virtual IDataView get_Source();
    public sealed virtual bool get_CanShuffle();
    private sealed virtual override DataViewSchema Microsoft.ML.IDataView.get_Schema();
    public DataViewSchema get_OutputSchema();
    public static RankingPerInstanceTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal static class Microsoft.ML.Data.RankingPredictionTransformer : object {
    public static string LoaderSignature;
    private static string DirModel;
    public static ISingleFeaturePredictionTransformer`1<object> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.RankingPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    [BestFriendAttribute]
internal RankingPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn);
    internal RankingPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    internal RankingPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx, IHost host, TModel model);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
internal static class Microsoft.ML.Data.RankingUtils : object {
    private static int FixedDiscountMapSize;
    private static Double[] _discountMapFixed;
    private static Double[] GetDiscountMapCore(int truncationLevel);
    public static Double[] GetDiscountMap(int truncationLevel);
    public static void QueryMaxDcg(Double[] labelGains, int truncationLevel, Double[] discountMap, List`1<short> queryLabels, List`1<float> queryOutputs, Double[] groupMaxDcgCur);
    public static void QueryDcg(Double[] labelGains, int truncationLevel, Double[] discountMap, List`1<short> queryLabels, List`1<float> queryOutputs, Double[] groupDcgCur);
    private static Comparison`1<int> GetCompareItems(List`1<short> queryLabels, List`1<float> queryOutputs);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RegressionEvaluator : RegressionEvaluatorBase`3<Aggregator, float, double> {
    public static string LoadName;
    public RegressionEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual void CheckScoreAndLabelTypes(RoleMappedSchema schema);
    private protected virtual Aggregator GetAggregatorCore(RoleMappedSchema schema, string stratName);
    private protected virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RegressionEvaluator/<GetOverallMetricColumns>d__7")]
public virtual IEnumerable`1<MetricColumn> GetOverallMetricColumns();
    public RegressionMetrics Evaluate(IDataView data, string label, string score);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RegressionEvaluatorBase`3 : RegressionLossEvaluatorBase`1<TAgg> {
    [BestFriendAttribute]
private protected RegressionEvaluatorBase`3(ArgumentsBase<TAgg> args, IHostEnvironment env, string registrationName);
    private protected virtual void GetAggregatorConsolidationFuncs(TAgg aggregator, AggregatorDictionaryBase[] dictionaries, Action`3& addAgg, Func`1& consolidate);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RegressionLossEvaluatorBase`1 : RowToRowEvaluatorBase`1<TAgg> {
    public static string L1;
    public static string L2;
    public static string Rms;
    public static string Loss;
    public static string RSquared;
    protected IRegressionLoss LossFunction;
    protected RegressionLossEvaluatorBase`1(ArgumentsBase<TAgg> args, IHostEnvironment env, string registrationName);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RegressionMamlEvaluator : MamlEvaluatorBase {
    private RegressionEvaluator _evaluator;
    private protected IEvaluator Evaluator { get; }
    public RegressionMamlEvaluator(IHostEnvironment env, Arguments args);
    private protected virtual IEvaluator get_Evaluator();
    [IteratorStateMachineAttribute("Microsoft.ML.Data.RegressionMamlEvaluator/<GetPerInstanceColumnsToSave>d__5")]
private protected virtual IEnumerable`1<string> GetPerInstanceColumnsToSave(RoleMappedSchema schema);
}
public class Microsoft.ML.Data.RegressionMetrics : object {
    [CompilerGeneratedAttribute]
private double <MeanAbsoluteError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <MeanSquaredError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RootMeanSquaredError>k__BackingField;
    [CompilerGeneratedAttribute]
private double <LossFunction>k__BackingField;
    [CompilerGeneratedAttribute]
private double <RSquared>k__BackingField;
    public double MeanAbsoluteError { get; }
    public double MeanSquaredError { get; }
    public double RootMeanSquaredError { get; }
    public double LossFunction { get; }
    public double RSquared { get; }
    internal RegressionMetrics(IExceptionContext ectx, DataViewRow overallResult);
    [BestFriendAttribute]
internal RegressionMetrics(double l1, double l2, double rms, double lossFunction, double rSquared);
    [CompilerGeneratedAttribute]
public double get_MeanAbsoluteError();
    [CompilerGeneratedAttribute]
public double get_MeanSquaredError();
    [CompilerGeneratedAttribute]
public double get_RootMeanSquaredError();
    [CompilerGeneratedAttribute]
public double get_LossFunction();
    [CompilerGeneratedAttribute]
public double get_RSquared();
    [CompilerGeneratedAttribute]
internal static double <.ctor>g__Fetch|15_0(string name, <>c__DisplayClass15_0& );
}
internal class Microsoft.ML.Data.RegressionPerInstanceEvaluator : PerInstanceEvaluatorBase {
    public static string LoaderSignature;
    private static int L1Col;
    private static int L2Col;
    public static string L1;
    public static string L2;
    public RegressionPerInstanceEvaluator(IHostEnvironment env, DataViewSchema schema, string scoreCol, string labelCol);
    private RegressionPerInstanceEvaluator(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private static VersionInfo GetVersionInfo();
    public static RegressionPerInstanceEvaluator Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema schema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual Func`2<int, bool> GetDependenciesCore(Func`2<int, bool> activeOutput);
    private protected virtual DetachedColumn[] GetOutputColumnsCore();
    private protected virtual Delegate[] CreateGettersCore(DataViewRow input, Func`2<int, bool> activeCols, Action& disposer);
    private void CheckInputColumnTypes(DataViewSchema schema);
}
internal static class Microsoft.ML.Data.RegressionPredictionTransformer : object {
    public static string LoaderSignature;
    private static string DirModel;
    public static ISingleFeaturePredictionTransformer`1<object> Create(IHostEnvironment env, ModelLoadContext ctx);
}
public class Microsoft.ML.Data.RegressionPredictionTransformer`1 : SingleFeaturePredictionTransformerBase`1<TModel> {
    [BestFriendAttribute]
internal RegressionPredictionTransformer`1(IHostEnvironment env, TModel model, DataViewSchema inputSchema, string featureColumn);
    internal RegressionPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx);
    internal RegressionPredictionTransformer`1(IHostEnvironment env, ModelLoadContext ctx, IHost host, TModel model);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private static VersionInfo GetVersionInfo();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RowCursor`1 : DataViewRowCursor {
    public abstract virtual void FillValues(TRow row);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.RowCursorUtils : object {
    private static FuncStaticMethodInfo1`3<DataViewRow, int, Delegate> _getGetterAsDelegateCoreMethodInfo;
    private static FuncStaticMethodInfo1`3<DataViewRow, int, Func`1<bool>> _getIsNewGroupDelegateCoreMethodInfo;
    [BestFriendAttribute]
internal static string FetchValueStateError;
    private static RowCursorUtils();
    public static Delegate GetGetterAsDelegate(DataViewRow row, int col);
    private static Delegate GetGetterAsDelegateCore(DataViewRow row, int col);
    public static Delegate GetGetterAs(DataViewType typeDst, DataViewRow row, int col);
    public static ValueGetter`1<TDst> GetGetterAs(DataViewType typeDst, DataViewRow row, int col);
    private static ValueGetter`1<TDst> GetGetterAsCore(DataViewType typeSrc, DataViewType typeDst, DataViewRow row, int col);
    public static ValueGetter`1<StringBuilder> GetGetterAsStringBuilder(DataViewRow row, int col);
    private static ValueGetter`1<StringBuilder> GetGetterAsStringBuilderCore(DataViewType typeSrc, DataViewRow row, int col);
    public static Delegate GetVecGetterAs(PrimitiveDataViewType typeDst, DataViewRow row, int col);
    public static ValueGetter`1<VBuffer`1<TDst>> GetVecGetterAs(PrimitiveDataViewType typeDst, DataViewRow row, int col);
    [BestFriendAttribute]
internal static ValueGetter`1<VBuffer`1<TDst>> GetVecGetterAs(PrimitiveDataViewType typeDst, SlotCursor cursor);
    private static ValueGetter`1<VBuffer`1<TDst>> GetVecGetterAsCore(VectorDataViewType typeSrc, PrimitiveDataViewType typeDst, GetterFactory getterFact);
    public static Func`1<bool> GetIsNewGroupDelegate(DataViewRow cursor, int col);
    private static Func`1<bool> GetIsNewGroupDelegateCore(DataViewRow cursor, int col);
    public static string TestGetLabelGetter(DataViewType type);
    public static string TestGetLabelGetter(DataViewType type, bool allowKeys);
    public static ValueGetter`1<float> GetLabelGetter(DataViewRow cursor, int labelIndex);
    private static ValueGetter`1<float> GetLabelGetterNotFloat(DataViewRow cursor, int labelIndex);
    [BestFriendAttribute]
internal static ValueGetter`1<VBuffer`1<float>> GetLabelGetter(SlotCursor cursor);
    public static T Fetch(IExceptionContext ectx, DataViewRow row, string name);
    public static IDataView RowAsDataView(IHostEnvironment env, DataViewRow row);
    [BestFriendAttribute]
internal static Func`2<int, bool> FromColumnsToPredicate(IEnumerable`1<Column> columnsNeeded, DataViewSchema sourceSchema);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RowSeeker : DataViewRow {
    public abstract virtual bool MoveTo(long rowIndex);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RowToRowEvaluatorBase`1 : EvaluatorBase`1<TAgg> {
    [BestFriendAttribute]
private protected RowToRowEvaluatorBase`1(IHostEnvironment env, string registrationName);
    internal virtual IDataTransform GetPerInstanceMetricsCore(RoleMappedData data);
    [BestFriendAttribute]
private protected abstract virtual IRowMapper CreatePerInstanceRowMapper(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.RowToRowMapperTransform : RowToRowTransformBase {
    private IRowMapper _mapper;
    private ColumnBindings _bindings;
    private Func`2<DataViewSchema, IRowMapper> _mapperFactory;
    public static string RegistrationName;
    public static string LoaderSignature;
    public DataViewSchema OutputSchema { get; }
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    public DataViewSchema InputSchema { get; }
    public RowToRowMapperTransform(IHostEnvironment env, IDataView input, IRowMapper mapper, Func`2<DataViewSchema, IRowMapper> mapperFactory);
    private RowToRowMapperTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public virtual DataViewSchema get_OutputSchema();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    public static DataViewSchema GetOutputSchema(DataViewSchema inputSchema, IRowMapper mapper);
    public static RowToRowMapperTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private Boolean[] GetActive(Func`2<int, bool> predicate, IEnumerable`1& inputColumns);
    private Func`2<int, bool> GetActiveOutputColumns(Boolean[] active);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private sealed virtual override void Microsoft.ML.Model.OnnxConverter.ISaveAsOnnx.SaveAsOnnx(OnnxContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.ISaveAsPfa.SaveAsPfa(BoundPfaContext ctx);
    private sealed virtual override IEnumerable`1<Column> Microsoft.ML.Data.IRowToRowMapper.GetDependencies(IEnumerable`1<Column> dependingColumns);
    public sealed virtual DataViewSchema get_InputSchema();
    private sealed virtual override DataViewRow Microsoft.ML.Data.IRowToRowMapper.GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
    private sealed virtual override IDataTransform Microsoft.ML.Data.ITransformTemplate.ApplyToData(IHostEnvironment env, IDataView newSource);
    internal ITransformer GetTransformer();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RowToRowMapperTransformBase : RowToRowTransformBase {
    public DataViewSchema InputSchema { get; }
    protected RowToRowMapperTransformBase(IHostEnvironment env, string name, IDataView input);
    protected RowToRowMapperTransformBase(IHost host, IDataView input);
    private sealed virtual override IEnumerable`1<Column> Microsoft.ML.Data.IRowToRowMapper.GetDependencies(IEnumerable`1<Column> dependingColumns);
    protected abstract virtual IEnumerable`1<Column> GetDependenciesCore(IEnumerable`1<Column> dependingColumns);
    public sealed virtual DataViewSchema get_InputSchema();
    private sealed virtual override DataViewRow Microsoft.ML.Data.IRowToRowMapper.GetRow(DataViewRow input, IEnumerable`1<Column> activeColumns);
    protected abstract virtual Delegate[] CreateGetters(DataViewRow input, IEnumerable`1<Column> activeColumns, Action& disp);
    protected abstract virtual int MapColumnIndex(Boolean& isSrc, int col);
}
internal abstract class Microsoft.ML.Data.RowToRowScorerBase : RowToRowMapperTransformBase {
    private static FuncStaticMethodInfo1`3<DataViewRow, int, Delegate> _getGetterFromRowMethodInfo;
    [BestFriendAttribute]
private protected ISchemaBindableMapper Bindable;
    [BestFriendAttribute]
private protected RowToRowScorerBase(IHostEnvironment env, IDataView input, string registrationName, ISchemaBindableMapper bindable);
    [BestFriendAttribute]
private protected RowToRowScorerBase(IHost host, ModelLoadContext ctx, IDataView input);
    private static RowToRowScorerBase();
    private protected sealed virtual void SaveModel(ModelSaveContext ctx);
    [BestFriendAttribute]
private protected abstract virtual void SaveCore(ModelSaveContext ctx);
    private protected abstract virtual IDataTransform ApplyToDataCore(IHostEnvironment env, IDataView newSource);
    private sealed virtual override IDataTransform Microsoft.ML.Data.ITransformTemplate.ApplyToData(IHostEnvironment env, IDataView newSource);
    internal IDataView ApplyToData(IHostEnvironment env, IDataView newSource);
    [BestFriendAttribute]
private protected abstract virtual BindingsBase GetBindings();
    private static Boolean[] GetActive(BindingsBase bindings, IEnumerable`1<Column> columns, IEnumerable`1& inputColumns, IEnumerable`1& activeRowMapperCols);
    protected sealed virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected abstract virtual bool WantParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    protected virtual Delegate[] CreateGetters(DataViewRow input, IEnumerable`1<Column> activeColumns, Action& disp);
    protected virtual IEnumerable`1<Column> GetDependenciesCore(IEnumerable`1<Column> columns);
    protected abstract virtual Delegate[] GetGetters(DataViewRow output, Func`2<int, bool> predicate);
    protected static Delegate[] GetGettersFromRow(DataViewRow row, Func`2<int, bool> predicate);
    protected static Delegate GetGetterFromRow(DataViewRow row, int col);
    protected static ValueGetter`1<T> GetGetterFromRow(DataViewRow output, int col);
    protected virtual int MapColumnIndex(Boolean& isSrc, int col);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.RowToRowTransformBase : TransformBase {
    protected RowToRowTransformBase(IHostEnvironment env, string name, IDataView input);
    protected RowToRowTransformBase(IHost host, IDataView input);
    public sealed virtual Nullable`1<long> GetRowCount();
}
public abstract class Microsoft.ML.Data.RowToRowTransformerBase : object {
    [BestFriendAttribute]
private protected IHost Host;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    [BestFriendAttribute]
private protected RowToRowTransformerBase(IHost host);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected abstract virtual void SaveModel(ModelSaveContext ctx);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    [BestFriendAttribute]
private protected abstract virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
    [BestFriendAttribute]
private protected RowToRowMapperTransform MakeDataTransform(IDataView input);
}
internal class Microsoft.ML.Data.SaveDataCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public SaveDataCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
}
[ExtensionAttribute]
public static class Microsoft.ML.Data.SchemaAnnotationsExtensions : object {
    [ExtensionAttribute]
public static bool HasSlotNames(Column column);
    [ExtensionAttribute]
public static void GetSlotNames(Column column, VBuffer`1& slotNames);
    [ExtensionAttribute]
public static bool HasKeyValues(Column column, PrimitiveDataViewType keyValueItemType);
    [ExtensionAttribute]
public static void GetKeyValues(Column column, VBuffer`1& keyValues);
    [ExtensionAttribute]
public static bool IsNormalized(Column column);
}
internal class Microsoft.ML.Data.SchemaBindableBinaryPredictorWrapper : SchemaBindablePredictorWrapperBase {
    public static string LoaderSignature;
    private IValueMapperDist _distMapper;
    public SchemaBindableBinaryPredictorWrapper(IPredictor predictor);
    private SchemaBindableBinaryPredictorWrapper(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    public static SchemaBindableBinaryPredictorWrapper Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual void SaveAsPfaCore(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputNames);
    private protected virtual bool SaveAsOnnxCore(OnnxContext ctx, RoleMappedSchema schema, String[] outputNames);
    private void CheckValid(IValueMapperDist& distMapper);
    private protected virtual ISchemaBoundMapper BindCore(IChannel ch, RoleMappedSchema schema);
}
internal class Microsoft.ML.Data.SchemaBindablePredictorWrapper : SchemaBindablePredictorWrapperBase {
    public static string LoaderSignature;
    private string _scoreColumnKind;
    public SchemaBindablePredictorWrapper(IPredictor predictor);
    private SchemaBindablePredictorWrapper(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    public static SchemaBindablePredictorWrapper Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual void SaveAsPfaCore(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputNames);
    private protected virtual bool SaveAsOnnxCore(OnnxContext ctx, RoleMappedSchema schema, String[] outputNames);
    private protected virtual ISchemaBoundMapper BindCore(IChannel ch, RoleMappedSchema schema);
    private static string GetScoreColumnKind(IPredictor predictor);
}
internal abstract class Microsoft.ML.Data.SchemaBindablePredictorWrapperBase : object {
    private static FuncInstanceMethodInfo2`4<SchemaBindablePredictorWrapperBase, DataViewRow, int, Delegate> _getValueGetterMethodInfo;
    protected IPredictor Predictor;
    private protected IValueMapper ValueMapper;
    protected DataViewType ScoreType;
    private bool _disposed;
    private bool Microsoft.ML.Model.Pfa.ICanSavePfa.CanSavePfa { get; }
    public SchemaBindablePredictorWrapperBase(IPredictor predictor);
    protected SchemaBindablePredictorWrapperBase(IHostEnvironment env, ModelLoadContext ctx);
    private static SchemaBindablePredictorWrapperBase();
    private sealed virtual override bool Microsoft.ML.Model.Pfa.ICanSavePfa.get_CanSavePfa();
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx.CanSaveOnnx(OnnxContext ctx);
    private static DataViewType GetScoreType(IPredictor predictor, IValueMapper& valueMapper);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private sealed virtual override void Microsoft.ML.Model.Pfa.IBindableCanSavePfa.SaveAsPfa(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputNames);
    [BestFriendAttribute]
private protected virtual void SaveAsPfaCore(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputNames);
    private sealed virtual override bool Microsoft.ML.Model.OnnxConverter.IBindableCanSaveOnnx.SaveAsOnnx(OnnxContext ctx, RoleMappedSchema schema, String[] outputNames);
    [BestFriendAttribute]
private protected virtual bool SaveAsOnnxCore(OnnxContext ctx, RoleMappedSchema schema, String[] outputNames);
    private sealed virtual override ISchemaBoundMapper Microsoft.ML.Data.ISchemaBindableMapper.Bind(IHostEnvironment env, RoleMappedSchema schema);
    [BestFriendAttribute]
private protected abstract virtual ISchemaBoundMapper BindCore(IChannel ch, RoleMappedSchema schema);
    protected virtual Delegate GetPredictionGetter(DataViewRow input, int colSrc);
    private ValueGetter`1<TDst> GetValueGetter(DataViewRow input, int colSrc);
    private sealed virtual override void Microsoft.ML.Model.ICanSaveSummary.SaveSummary(TextWriter writer, RoleMappedSchema schema);
    public sealed virtual void Dispose();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SchemaBindableQuantileRegressionPredictor : SchemaBindablePredictorWrapperBase {
    public static string LoaderSignature;
    private IQuantileValueMapper _qpred;
    private Double[] _quantiles;
    public SchemaBindableQuantileRegressionPredictor(IPredictor predictor, Double[] quantiles);
    private SchemaBindableQuantileRegressionPredictor(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public static SchemaBindableQuantileRegressionPredictor Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual ISchemaBoundMapper BindCore(IChannel ch, RoleMappedSchema schema);
    protected virtual Delegate GetPredictionGetter(DataViewRow input, int colSrc);
}
[DefaultMemberAttribute("Item")]
public class Microsoft.ML.Data.SchemaDefinition : List`1<Column> {
    public Column Item { get; public set; }
    public Column get_Item(string columnName);
    public void set_Item(string columnName, Column value);
    internal static MemberInfo[] GetMemberInfos(Type userType, Direction direction);
    internal static bool NeedToCheckMemberInfo(MemberInfo memberInfo);
    internal static bool GetNameAndCustomAttributes(MemberInfo memberInfo, Type userType, HashSet`1<string> colNames, String& name, IEnumerable`1& customAttributes);
    public static SchemaDefinition Create(Type userType, Direction direction);
}
internal class Microsoft.ML.Data.ScoreCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public ScoreCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
    private bool ShouldAddColumn(DataViewSchema schema, int i, UInt32 scoreSet, bool outputNamesAndLabels);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.ScorerArgumentsBase : object {
    [ArgumentAttribute("0")]
public string Suffix;
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.ScorerBindingsBase : ColumnBindingsBase {
    public ISchemaBoundMapper Mapper;
    public string Suffix;
    public int DerivedColumnCount;
    private UInt32 _crtScoreSet;
    private AnnotationGetter`1<UInt32> _getScoreColumnSetId;
    protected ScorerBindingsBase(DataViewSchema input, ISchemaBoundMapper mapper, string suffix, bool user, String[] namesDerived);
    private static String[] GetOutputNames(ISchemaBoundMapper mapper, string suffix, String[] namesDerived);
    protected static KeyValuePair`2[] LoadBaseInfo(ModelLoadContext ctx, String& suffix);
    protected void SaveBase(ModelSaveContext ctx);
    internal abstract virtual void SaveModel(ModelSaveContext ctx);
    protected virtual DataViewType GetColumnTypeCore(int iinfo);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ScorerBindingsBase/<GetAnnotationTypesCore>d__11")]
protected virtual IEnumerable`1<KeyValuePair`2<string, DataViewType>> GetAnnotationTypesCore(int iinfo);
    protected virtual DataViewType GetAnnotationTypeCore(string kind, int iinfo);
    protected virtual void GetAnnotationCore(string kind, int iinfo, TValue& value);
    public virtual Func`2<int, bool> GetActiveMapperColumns(Boolean[] active);
    protected void GetScoreColumnSetId(int iinfo, UInt32& dst);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ScoreSchemaFactory : object {
    public static DataViewSchema Create(DataViewType scoreType, string scoreColumnKindValue, string scoreColumnName);
    public static DataViewSchema CreateBinaryClassificationSchema(string scoreColumnName, string probabilityColumnName);
    public static DataViewSchema CreateQuantileRegressionSchema(DataViewType scoreType, Double[] quantiles);
    public static DataViewSchema CreateSequencePredictionSchema(DataViewType scoreType, string scoreColumnKindValue, VBuffer`1<ReadOnlyMemory`1<char>> keyNames);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.ScoreUtils : object {
    public static IDataScorerTransform GetScorer(IPredictor predictor, RoleMappedData data, IHostEnvironment env, RoleMappedSchema trainSchema);
    public static IDataScorerTransform GetScorer(IComponentFactory`4<IDataView, ISchemaBoundMapper, RoleMappedSchema, IDataScorerTransform> scorer, IPredictor predictor, IDataView input, string featureColName, string groupColName, IEnumerable`1<KeyValuePair`2<ColumnRole, string>> customColumns, IHostEnvironment env, RoleMappedSchema trainSchema, IComponentFactory`2<IPredictor, ISchemaBindableMapper> mapperFactory);
    private static IComponentFactory`4<IDataView, ISchemaBoundMapper, RoleMappedSchema, IDataScorerTransform> GetScorerComponentAndMapper(IPredictor predictor, IComponentFactory`4<IDataView, ISchemaBoundMapper, RoleMappedSchema, IDataScorerTransform> scorerFactory, RoleMappedSchema schema, IHostEnvironment env, IComponentFactory`2<IPredictor, ISchemaBindableMapper> mapperFactory, ISchemaBoundMapper& mapper);
    public static IComponentFactory`4<IDataView, ISchemaBoundMapper, RoleMappedSchema, IDataScorerTransform> GetScorerComponent(IHostEnvironment environment, ISchemaBoundMapper mapper, string suffix);
    public static ISchemaBindableMapper GetSchemaBindableMapper(IHostEnvironment env, IPredictor predictor, IComponentFactory`2<IPredictor, ISchemaBindableMapper> mapperFactory, ICommandLineComponentFactory scorerFactorySettings);
    private static bool TryCreateBindableFromScorer(IHostEnvironment env, IPredictor predictor, ICommandLineComponentFactory scorerSettings, ISchemaBindableMapper& bindable);
}
internal class Microsoft.ML.Data.ShowDataCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public ShowDataCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
}
internal class Microsoft.ML.Data.ShowSchemaCommand : ImplBase`1<Arguments> {
    internal static string LoadName;
    internal static string Summary;
    public ShowSchemaCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
    internal static void RunOnData(TextWriter writer, Arguments args, IDataView data);
    [IteratorStateMachineAttribute("Microsoft.ML.Data.ShowSchemaCommand/<GetViewChainReversed>d__7")]
private static IEnumerable`1<IDataView> GetViewChainReversed(IDataView data);
    private static void PrintSchema(TextWriter writer, Arguments args, DataViewSchema schema, ITransposeDataView transposeDataView);
    private static void ShowMetadata(IndentedTextWriter itw, DataViewSchema schema, int col, bool showVals);
    private static void ShowMetadataValue(IndentedTextWriter itw, DataViewSchema schema, int col, string kind, DataViewType type);
    private static void ShowMetadataValue(IndentedTextWriter itw, DataViewSchema schema, int col, string kind, DataViewType type);
    private static void ShowMetadataValueVec(IndentedTextWriter itw, DataViewSchema schema, int col, string kind, VectorDataViewType type);
    private static void ShowMetadataValueVec(IndentedTextWriter itw, DataViewSchema schema, int col, string kind, VectorDataViewType type);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureBindableMapper : MulticastDelegate {
    public SignatureBindableMapper(object object, IntPtr method);
    public virtual void Invoke(IPredictor predictor);
    public virtual IAsyncResult BeginInvoke(IPredictor predictor, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureDataLoader : MulticastDelegate {
    public SignatureDataLoader(object object, IntPtr method);
    public virtual void Invoke(IMultiStreamSource data);
    public virtual IAsyncResult BeginInvoke(IMultiStreamSource data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureDataSaver : MulticastDelegate {
    public SignatureDataSaver(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureDataScorer : MulticastDelegate {
    public SignatureDataScorer(object object, IntPtr method);
    public virtual void Invoke(IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema);
    public virtual IAsyncResult BeginInvoke(IDataView data, ISchemaBoundMapper mapper, RoleMappedSchema trainSchema, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureDataTransform : MulticastDelegate {
    public SignatureDataTransform(object object, IntPtr method);
    public virtual void Invoke(IDataView input);
    public virtual IAsyncResult BeginInvoke(IDataView input, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureEvaluator : MulticastDelegate {
    public SignatureEvaluator(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureLoadColumnFunction : MulticastDelegate {
    public SignatureLoadColumnFunction(object object, IntPtr method);
    public virtual void Invoke(ModelLoadContext ctx, IHost host, DataViewType typeSrc);
    public virtual IAsyncResult BeginInvoke(ModelLoadContext ctx, IHost host, DataViewType typeSrc, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureLoadDataLoader : MulticastDelegate {
    public SignatureLoadDataLoader(object object, IntPtr method);
    public virtual void Invoke(ModelLoadContext ctx, IMultiStreamSource data);
    public virtual IAsyncResult BeginInvoke(ModelLoadContext ctx, IMultiStreamSource data, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureLoadDataTransform : MulticastDelegate {
    public SignatureLoadDataTransform(object object, IntPtr method);
    public virtual void Invoke(ModelLoadContext ctx, IDataView input);
    public virtual IAsyncResult BeginInvoke(ModelLoadContext ctx, IDataView input, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureLoadRowMapper : MulticastDelegate {
    public SignatureLoadRowMapper(object object, IntPtr method);
    public virtual void Invoke(ModelLoadContext ctx, DataViewSchema schema);
    public virtual IAsyncResult BeginInvoke(ModelLoadContext ctx, DataViewSchema schema, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureMamlEvaluator : MulticastDelegate {
    public SignatureMamlEvaluator(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SignatureModelCombiner : MulticastDelegate {
    public SignatureModelCombiner(object object, IntPtr method);
    public virtual void Invoke(PredictionKind kind);
    public virtual IAsyncResult BeginInvoke(PredictionKind kind, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.SimpleRow : WrappingRow {
    private Delegate[] _getters;
    private Action _disposer;
    [CompilerGeneratedAttribute]
private DataViewSchema <Schema>k__BackingField;
    public DataViewSchema Schema { get; }
    public SimpleRow(DataViewSchema schema, DataViewRow input, Delegate[] getters, Action disposer);
    [CompilerGeneratedAttribute]
public virtual DataViewSchema get_Schema();
    protected virtual void DisposeCore(bool disposing);
    public virtual ValueGetter`1<TValue> GetGetter(Column column);
    public virtual bool IsColumnActive(Column column);
}
public abstract class Microsoft.ML.Data.SingleFeaturePredictionTransformerBase`1 : PredictionTransformerBase`1<TModel> {
    [CompilerGeneratedAttribute]
private string <FeatureColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private DataViewType <FeatureColumnType>k__BackingField;
    public string FeatureColumnName { get; }
    public DataViewType FeatureColumnType { get; }
    private protected SingleFeaturePredictionTransformerBase`1(IHost host, TModel model, DataViewSchema trainSchema, string featureColumn);
    private protected SingleFeaturePredictionTransformerBase`1(IHost host, ModelLoadContext ctx);
    private protected SingleFeaturePredictionTransformerBase`1(IHost host, ModelLoadContext ctx, TModel model);
    [CompilerGeneratedAttribute]
public sealed virtual string get_FeatureColumnName();
    [CompilerGeneratedAttribute]
public sealed virtual DataViewType get_FeatureColumnType();
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    private protected sealed virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual void SaveCore(ModelSaveContext ctx);
    private protected GenericScorer GetGenericScorer();
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.SlotCursor : object {
    [BestFriendAttribute]
private protected IChannel Ch;
    private bool _started;
    [CompilerGeneratedAttribute]
private bool <Disposed>k__BackingField;
    protected bool Disposed { get; private set; }
    [BestFriendAttribute]
private protected bool IsGood { get; }
    public int SlotIndex { get; }
    [BestFriendAttribute]
private protected SlotCursor(IChannelProvider provider);
    [CompilerGeneratedAttribute]
protected bool get_Disposed();
    [CompilerGeneratedAttribute]
private void set_Disposed(bool value);
    private protected bool get_IsGood();
    public abstract virtual int get_SlotIndex();
    public abstract virtual bool MoveNext();
    public abstract virtual VectorDataViewType GetSlotType();
    public abstract virtual ValueGetter`1<VBuffer`1<TValue>> GetGetter();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal abstract class Microsoft.ML.Data.SourceNameColumnBase : object {
    [ArgumentAttribute("0")]
public string Name;
    [ArgumentAttribute("0")]
public string Source;
    [BestFriendAttribute]
private protected virtual bool TryParse(string str);
    [BestFriendAttribute]
private protected bool TryParse(string str, String& extra);
    [BestFriendAttribute]
private protected virtual bool TryUnparseCore(StringBuilder sb);
    [BestFriendAttribute]
private protected virtual bool TryUnparseCore(StringBuilder sb, string extra);
    public bool TrySanitize();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TestCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public TestCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    private void RunCore(IChannel ch);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TextCombiner : Combiner`1<ReadOnlyMemory`1<char>> {
    private static TextCombiner modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static TextCombiner Instance { get; }
    public static TextCombiner get_Instance();
    public virtual bool IsDefault(ReadOnlyMemory`1<char> value);
    public virtual void Combine(ReadOnlyMemory`1& dst, ReadOnlyMemory`1<char> src);
}
public class Microsoft.ML.Data.TextLoader : object {
    internal static string Summary;
    internal static string LoaderSignature;
    private static UInt32 VerForceVectorSupported;
    private static UInt32 VersionNoMinCount;
    private static int SrcLim;
    private bool _useThreads;
    private OptionFlags _flags;
    private char _escapeChar;
    private long _maxRows;
    private int _inputSize;
    private Char[] _separators;
    private char _decimalMarker;
    private Bindings _bindings;
    private Parser _parser;
    private IHost _host;
    private static string RegistrationName;
    private bool HasHeader { get; }
    private bool ReadMultilines { get; }
    internal TextLoader(IHostEnvironment env, Options options, IMultiStreamSource dataSample);
    private TextLoader(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private bool get_HasHeader();
    private bool get_ReadMultilines();
    private char NormalizeSeparator(string sep);
    private static bool TryParseSchema(IHost host, IMultiStreamSource files, Options& options, Column[]& cols, Boolean& error);
    internal static bool FileContainsValidSchema(IHostEnvironment env, IMultiStreamSource files, Options& options);
    internal static TextLoader Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static ILegacyDataLoader Create(IHostEnvironment env, ModelLoadContext ctx, IMultiStreamSource files);
    internal static ILegacyDataLoader Create(IHostEnvironment env, Options options, IMultiStreamSource files);
    internal static IDataView LoadFile(IHostEnvironment env, Options options, IMultiStreamSource fileSource);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual DataViewSchema GetOutputSchema();
    public sealed virtual IDataView Load(IMultiStreamSource source);
    internal static TextLoader CreateTextLoader(IHostEnvironment host, bool hasHeader, char separator, bool allowQuoting, bool supportSparse, bool trimWhitespace, IMultiStreamSource dataSample);
    internal static TextLoader CreateTextLoader(IHostEnvironment host, Options options, IMultiStreamSource dataSample);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.TextModelHelper : object {
    private static string LoaderSignature;
    private static VersionInfo GetVersionInfo();
    private static void Load(IChannel ch, ModelLoadContext ctx, CodecFactory factory, VBuffer`1& values);
    private static void Save(IChannel ch, ModelSaveContext ctx, CodecFactory factory, VBuffer`1& values);
    public static void LoadAll(IHost host, ModelLoadContext ctx, int infoLim, VBuffer`1[]& keyValues, VectorDataViewType[]& kvTypes);
    public static void SaveAll(IHost host, ModelSaveContext ctx, int infoLim, VBuffer`1[] keyValues);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TrainCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    private IComponentFactory`1<ITrainer> _trainer;
    private string _labelColumn;
    private string _featureColumn;
    private string _groupColumn;
    private string _weightColumn;
    private string _nameColumn;
    public TrainCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    protected virtual void SendTelemetryCore(IPipe`1<TelemetryMessage> pipe);
    private void RunCore(IChannel ch, string cmd);
}
internal abstract class Microsoft.ML.Data.TrainedWrapperEstimatorBase : object {
    [BestFriendAttribute]
private protected IHost Host;
    [BestFriendAttribute]
private protected TrainedWrapperEstimatorBase(IHost host);
    public abstract virtual TransformWrapper Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TrainTestCommand : ImplBase`1<Arguments> {
    internal static string Summary;
    public static string LoadName;
    public TrainTestCommand(IHostEnvironment env, Arguments args);
    public virtual void Run();
    protected virtual void SendTelemetryCore(IPipe`1<TelemetryMessage> pipe);
    private void RunCore(IChannel ch, string cmd);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.TrainUtils : object {
    public static void CheckTrainer(IExceptionContext ectx, IComponentFactory`1<ITrainer> trainer, string dataFile);
    public static string MatchNameOrDefaultOrNull(IExceptionContext ectx, DataViewSchema schema, string argName, string userName, string defaultName);
    public static IPredictor Train(IHostEnvironment env, IChannel ch, RoleMappedData data, ITrainer trainer, IComponentFactory`1<ICalibratorTrainer> calibrator, int maxCalibrationExamples);
    public static IPredictor Train(IHostEnvironment env, IChannel ch, RoleMappedData data, ITrainer trainer, RoleMappedData validData, IComponentFactory`1<ICalibratorTrainer> calibrator, int maxCalibrationExamples, Nullable`1<bool> cacheData, IPredictor inputPredictor, RoleMappedData testData);
    private static IPredictor TrainCore(IHostEnvironment env, IChannel ch, RoleMappedData data, ITrainer trainer, RoleMappedData validData, IComponentFactory`1<ICalibratorTrainer> calibrator, int maxCalibrationExamples, Nullable`1<bool> cacheData, IPredictor inputPredictor, RoleMappedData testData);
    public static bool TryLoadPredictor(IChannel ch, IHostEnvironment env, string inputModelFile, IPredictor& inputPredictor);
    public static void SaveModel(IHostEnvironment env, IChannel ch, IFileHandle output, IPredictor predictor, RoleMappedData data, string command);
    public static void SaveModel(IHostEnvironment env, IChannel ch, Stream outputStream, IPredictor predictor, RoleMappedData data, string command);
    public static void SaveDataPipe(IHostEnvironment env, RepositoryWriter repositoryWriter, IDataView dataPipe, bool blankLoader);
    private static List`1<IDataTransform> BacktrackPipe(IDataView dataPipe, IDataView& pipeStart);
    public static bool AddNormalizerIfNeeded(IHostEnvironment env, IChannel ch, ITrainer trainer, IDataView& view, string featureColumn, NormalizeOption autoNorm);
    private static bool AddCacheIfWanted(IHostEnvironment env, IChannel ch, ITrainer trainer, RoleMappedData& data, Nullable`1<bool> cacheData);
    public static IEnumerable`1<KeyValuePair`2<ColumnRole, string>> CheckAndGenerateCustomColumns(IExceptionContext ectx, KeyValuePair`2[] customColumnArg);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Data.TransformBase : object {
    protected IHost Host;
    [CompilerGeneratedAttribute]
private IDataView <Source>k__BackingField;
    public IDataView Source { get; }
    public bool CanShuffle { get; }
    private DataViewSchema Microsoft.ML.IDataView.Schema { get; }
    public DataViewSchema OutputSchema { get; }
    protected TransformBase(IHostEnvironment env, string name, IDataView input);
    protected TransformBase(IHost host, IDataView input);
    [CompilerGeneratedAttribute]
public sealed virtual IDataView get_Source();
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    private protected abstract virtual void SaveModel(ModelSaveContext ctx);
    public abstract virtual Nullable`1<long> GetRowCount();
    public virtual bool get_CanShuffle();
    private sealed virtual override DataViewSchema Microsoft.ML.IDataView.get_Schema();
    public abstract virtual DataViewSchema get_OutputSchema();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    protected abstract virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected abstract virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public abstract virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Data.TransformerChain : object {
    public static string LoaderSignature;
    private static TransformerChain`1<ITransformer> Create(IHostEnvironment env, ModelLoadContext ctx);
    [ExtensionAttribute]
public static void SaveTo(ITransformer transformer, IHostEnvironment env, Stream outputStream);
    public static ITransformer LoadFromLegacy(IHostEnvironment env, Stream stream);
}
public class Microsoft.ML.Data.TransformerChain`1 : object {
    private ITransformer[] _transformers;
    private TransformerScope[] _scopes;
    public TLastTransformer LastTransformer;
    private static string TransformDirTemplate;
    private bool _disposed;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    private ITransformer[] Microsoft.ML.Data.ITransformerChainAccessor.Transformers { get; }
    private TransformerScope[] Microsoft.ML.Data.ITransformerChainAccessor.Scopes { get; }
    public TransformerChain`1(IEnumerable`1<ITransformer> transformers, IEnumerable`1<TransformerScope> scopes);
    public TransformerChain`1(ITransformer[] transformers);
    internal TransformerChain`1(IHostEnvironment env, ModelLoadContext ctx);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override ITransformer[] Microsoft.ML.Data.ITransformerChainAccessor.get_Transformers();
    private sealed virtual override TransformerScope[] Microsoft.ML.Data.ITransformerChainAccessor.get_Scopes();
    private static VersionInfo GetVersionInfo();
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    public DataViewSchema GetOutputSchema(DataViewSchema inputSchema, TransformerScope scope);
    public sealed virtual IDataView Transform(IDataView input);
    public IDataView Transform(IDataView input, TransformerScope scope);
    public TransformerChain`1<ITransformer> GetModelFor(TransformerScope scopeFilter);
    public TransformerChain`1<TNewLast> Append(TNewLast transformer, TransformerScope scope);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    [BestFriendAttribute]
internal void SaveTo(IHostEnvironment env, Stream outputStream);
    public sealed virtual IEnumerator`1<ITransformer> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    public sealed virtual void Dispose();
}
[FlagsAttribute]
public enum Microsoft.ML.Data.TransformerScope : Enum {
    public int value__;
    public static TransformerScope None;
    public static TransformerScope Training;
    public static TransformerScope Testing;
    public static TransformerScope Scoring;
    public static TransformerScope TrainTest;
    public static TransformerScope Everything;
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TransformWrapper : object {
    internal static string LoaderSignature;
    private IHost _host;
    private IDataView _xf;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    public TransformWrapper(IHostEnvironment env, IDataView xf);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    public sealed virtual IDataView Transform(IDataView input);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.Transposer : object {
    private static FuncInstanceMethodInfo1`3<Transposer, int, SlotCursor> _getSlotCursorCoreMethodInfo;
    private IHost _host;
    private IDataView _view;
    private ITransposeDataView _tview;
    private Dictionary`2<string, int> _nameToICol;
    private BinaryLoader _splitView;
    public int RowCount;
    private Int32[] _inputToTransposed;
    private Column[] _cols;
    private Int32[] _splitLim;
    private bool _disposed;
    public DataViewSchema Schema { get; }
    public bool CanShuffle { get; }
    private Transposer(IHost host, IDataView view, bool forceSave, Int32[] columns);
    private static Transposer();
    public static Transposer Create(IHostEnvironment env, IDataView view, bool forceSave, String[] columns);
    public static Transposer Create(IHostEnvironment env, IDataView view, bool forceSave, Int32[] columns);
    public sealed virtual void Dispose();
    private static Int32[] CheckNamesAndGetIndices(IHost host, IDataView view, String[] columns);
    private static Int32[] CheckIndices(IHost host, IDataView view, Int32[] columns);
    public sealed virtual SlotCursor GetSlotCursor(int col);
    private SlotCursor GetSlotCursorCore(int col);
    private sealed virtual override VectorDataViewType Microsoft.ML.Data.ITransposeDataView.GetSlotType(int col);
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    public sealed virtual Nullable`1<long> GetRowCount();
    [CompilerGeneratedAttribute]
private bool <.ctor>b__13_1(int c);
}
[ExtensionAttribute]
internal static class Microsoft.ML.Data.TransposerUtils : object {
    private static FuncStaticMethodInfo1`3<IChannelProvider, SlotCursor, DataViewRowCursor> _getRowCursorShimCoreMethodInfo;
    private static FuncInstanceMethodInfo1`2<SlotCursor, Delegate> _slotCursorGetGetterMethodInfo;
    private static TransposerUtils();
    [ExtensionAttribute]
public static void GetSingleSlotValue(ITransposeDataView view, int col, VBuffer`1& dst);
    [ExtensionAttribute]
public static ValueGetter`1<TValue> GetGetterWithVectorType(SlotCursor cursor, IExceptionContext ctx);
    public static DataViewRowCursor GetRowCursorShim(IChannelProvider provider, SlotCursor cursor);
    private static DataViewRowCursor GetRowCursorShimCore(IChannelProvider provider, SlotCursor cursor);
}
public abstract class Microsoft.ML.Data.TrivialEstimator`1 : object {
    [BestFriendAttribute]
private protected IHost Host;
    [BestFriendAttribute]
private protected TTransformer Transformer;
    [BestFriendAttribute]
private protected TrivialEstimator`1(IHost host, TTransformer transformer);
    public sealed virtual TTransformer Fit(IDataView input);
    public abstract virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
internal class Microsoft.ML.Data.TrivialLoaderEstimator`2 : object {
    [CompilerGeneratedAttribute]
private TLoader <Loader>k__BackingField;
    public TLoader Loader { get; }
    public TrivialLoaderEstimator`2(TLoader loader);
    [CompilerGeneratedAttribute]
public TLoader get_Loader();
    public sealed virtual TLoader Fit(TSource input);
    public sealed virtual SchemaShape GetOutputSchema();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.TypedCursorable`1 : object {
    private IHost _host;
    private IDataView _data;
    private Column[] _columns;
    private Int32[] _columnIndices;
    private Delegate[] _pokes;
    private Delegate[] _peeks;
    private TypedCursorable`1(IHostEnvironment env, IDataView data, bool ignoreMissingColumns, InternalSchemaDefinition schemaDefn);
    private static bool IsCompatibleType(DataViewType colType, MemberInfo memberInfo);
    public sealed virtual RowCursor`1<TRow> GetCursor();
    public sealed virtual RowCursor`1<TRow> GetRandomizedCursor(int randomSeed);
    public IRowReadableAs`1<TRow> GetRow(DataViewRow input);
    public RowCursor`1<TRow> GetCursor(Func`2<int, bool> additionalColumnsPredicate, Nullable`1<int> randomSeed);
    public Func`2<int, bool> GetDependencies(Func`2<int, bool> additionalColumnsPredicate);
    public RowCursor`1[] GetCursorSet(Func`2<int, bool> additionalColumnsPredicate, int n, Random rand);
    private static void ValidateMemberInfo(MemberInfo memberInfo, IDataView data);
    private static void ValidateUserType(SchemaDefinition schemaDefinition, Type userType, IDataView data);
    public static TypedCursorable`1<TRow> Create(IHostEnvironment env, IDataView data, bool ignoreMissingColumns, SchemaDefinition schemaDefinition);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Data.TypeParsingUtils : object {
    public static bool TryParseDataKind(string str, InternalDataKind& dataKind, KeyCount& keyCount);
    public static KeyDataViewType ConstructKeyType(Nullable`1<InternalDataKind> type, KeyCount keyCount);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.U4Adder : Combiner`1<UInt32> {
    private static U4Adder modreq(System.Runtime.CompilerServices.IsVolatile) _instance;
    public static U4Adder Instance { get; }
    public static U4Adder get_Instance();
    public virtual bool IsDefault(UInt32 value);
    public virtual void Combine(UInt32& dst, UInt32 src);
}
[AttributeUsageAttribute("384")]
public class Microsoft.ML.Data.VectorTypeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private Int32[] <Dims>k__BackingField;
    internal Int32[] Dims { get; }
    public VectorTypeAttribute(int size);
    public VectorTypeAttribute(Int32[] dimensions);
    [CompilerGeneratedAttribute]
internal Int32[] get_Dims();
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ZipBinding : object {
    private DataViewSchema[] _sources;
    [CompilerGeneratedAttribute]
private DataViewSchema <OutputSchema>k__BackingField;
    private Int32[] _cumulativeColCounts;
    public DataViewSchema OutputSchema { get; }
    public int ColumnCount { get; }
    public ZipBinding(DataViewSchema[] sources);
    [CompilerGeneratedAttribute]
public DataViewSchema get_OutputSchema();
    public int get_ColumnCount();
    public Func`2[] GetInputPredicates(Func`2<int, bool> predicate);
    public void CheckColumnInRange(int col);
    public void GetColumnSource(int col, Int32& srcIndex, Int32& srcCol);
}
[BestFriendAttribute]
internal class Microsoft.ML.Data.ZipDataView : object {
    public static string RegistrationName;
    private IHost _host;
    private IDataView[] _sources;
    private ZipBinding _zipBinding;
    public bool CanShuffle { get; }
    public DataViewSchema Schema { get; }
    private ZipDataView(IHost host, IDataView[] sources);
    public static IDataView Create(IHostEnvironment env, IEnumerable`1<IDataView> sources);
    public sealed virtual bool get_CanShuffle();
    public sealed virtual DataViewSchema get_Schema();
    public sealed virtual Nullable`1<long> GetRowCount();
    public sealed virtual DataViewRowCursor GetRowCursor(IEnumerable`1<Column> columnsNeeded, Random rand);
    private DataViewRowCursor GetMinimumCursor(IDataView dv);
    public sealed virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[ExtensionAttribute]
public static class Microsoft.ML.DatabaseLoaderCatalog : object {
    [ExtensionAttribute]
public static DatabaseLoader CreateDatabaseLoader(DataOperationsCatalog catalog, Column[] columns);
    [ExtensionAttribute]
public static DatabaseLoader CreateDatabaseLoader(DataOperationsCatalog catalog, Options options);
    [ExtensionAttribute]
public static DatabaseLoader CreateDatabaseLoader(DataOperationsCatalog catalog);
}
[ExtensionAttribute]
public static class Microsoft.ML.DataLoaderExtensions : object {
    [ExtensionAttribute]
public static IDataView Load(IDataLoader`1<IMultiStreamSource> loader, String[] path);
}
public class Microsoft.ML.DataOperationsCatalog : object {
    private IHostEnvironment _env;
    private IHostEnvironment Microsoft.ML.Data.IInternalCatalog.Environment { get; }
    internal DataOperationsCatalog(IHostEnvironment env);
    private sealed virtual override IHostEnvironment Microsoft.ML.Data.IInternalCatalog.get_Environment();
    public IDataView LoadFromEnumerable(IEnumerable`1<TRow> data, SchemaDefinition schemaDefinition);
    public IDataView LoadFromEnumerable(IEnumerable`1<TRow> data, DataViewSchema schema);
    public IEnumerable`1<TRow> CreateEnumerable(IDataView data, bool reuseRowObject, bool ignoreMissingColumns, SchemaDefinition schemaDefinition);
    public IDataView BootstrapSample(IDataView input, Nullable`1<int> seed, bool complement);
    public IDataView Cache(IDataView input, String[] columnsToPrefetch);
    public IDataView FilterRowsByColumn(IDataView input, string columnName, double lowerBound, double upperBound);
    public IDataView FilterRowsByKeyColumnFraction(IDataView input, string columnName, double lowerBound, double upperBound);
    public IDataView FilterRowsByMissingValues(IDataView input, String[] columns);
    public IDataView ShuffleRows(IDataView input, Nullable`1<int> seed, int shufflePoolSize, bool shuffleSource);
    public IDataView SkipRows(IDataView input, long count);
    public IDataView TakeRows(IDataView input, long count);
    public TrainTestData TrainTestSplit(IDataView data, double testFraction, string samplingKeyColumnName, Nullable`1<int> seed);
    public IReadOnlyList`1<TrainTestData> CrossValidationSplit(IDataView data, int numberOfFolds, string samplingKeyColumnName, Nullable`1<int> seed);
    [IteratorStateMachineAttribute("Microsoft.ML.DataOperationsCatalog/<CrossValidationSplit>d__18")]
internal static IEnumerable`1<TrainTestData> CrossValidationSplit(IHostEnvironment env, IDataView data, string splitColumn, int numberOfFolds);
    [BestFriendAttribute]
internal static string CreateSplitColumn(IHostEnvironment env, IDataView& data, string samplingKeyColumn, Nullable`1<int> seed, bool fallbackInEnvSeed);
}
[ExtensionAttribute]
public static class Microsoft.ML.DebuggerExtensions : object {
    [ExtensionAttribute]
public static DataDebuggerPreview Preview(IDataView data, int maxRows);
    [ExtensionAttribute]
public static DataDebuggerPreview Preview(ITransformer transformer, IDataView data, int maxRows);
    [ExtensionAttribute]
public static DataDebuggerPreview Preview(IEstimator`1<ITransformer> estimator, IDataView data, int maxRows, int maxTrainingRows);
    [ExtensionAttribute]
public static DataDebuggerPreview Preview(IDataLoader`1<TSource> loader, TSource source, int maxRows);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.ArrayIndexParameterBinding : ParameterBinding {
    public int Index;
    public ArrayIndexParameterBinding(string name, int index);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.ArrayIndexVariableBinding : VariableBinding {
    public int Index;
    public ArrayIndexVariableBinding(string name, int index);
    public virtual object GetVariableValueOrNull(EntryPointVariable variable);
    public virtual string ToJson();
}
[DefaultMemberAttribute("Item")]
[JsonConverterAttribute("Microsoft.ML.EntryPoints.VarSerializer")]
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.ArrayVar`1 : object {
    [CompilerGeneratedAttribute]
private string <VarName>k__BackingField;
    private bool _isValue;
    private String[] _values;
    public string VarName { get; public set; }
    private bool Microsoft.ML.EntryPoints.IVarSerializationHelper.IsValue { get; }
    private String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.Values { get; }
    public Var`1<T> Item { get; }
    public ArrayVar`1(Var`1[] variables);
    [CompilerGeneratedAttribute]
public sealed virtual string get_VarName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VarName(string value);
    private sealed virtual override bool Microsoft.ML.EntryPoints.IVarSerializationHelper.get_IsValue();
    private sealed virtual override String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.get_Values();
    public Var`1<T> get_Item(int i);
}
[BestFriendAttribute]
internal enum Microsoft.ML.EntryPoints.CachingOptions : Enum {
    public int value__;
    public static CachingOptions Auto;
    public static CachingOptions Memory;
    public static CachingOptions None;
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.CommonInputs : object {
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.CommonOutputs : object {
}
internal class Microsoft.ML.EntryPoints.DictionaryKeyParameterBinding : ParameterBinding {
    public string Key;
    public DictionaryKeyParameterBinding(string name, string key);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Microsoft.ML.EntryPoints.DictionaryKeyVariableBinding : VariableBinding {
    public string Key;
    public DictionaryKeyVariableBinding(string name, string key);
    public virtual object GetVariableValueOrNull(EntryPointVariable variable);
    public virtual string ToJson();
}
[DefaultMemberAttribute("Item")]
[JsonConverterAttribute("Microsoft.ML.EntryPoints.VarSerializer")]
internal class Microsoft.ML.EntryPoints.DictionaryVar`1 : object {
    [CompilerGeneratedAttribute]
private string <VarName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Microsoft.ML.EntryPoints.IVarSerializationHelper.IsValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Microsoft.ML.EntryPoints.IVarSerializationHelper.Values>k__BackingField;
    public string VarName { get; public set; }
    private bool Microsoft.ML.EntryPoints.IVarSerializationHelper.IsValue { get; }
    private String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.Values { get; }
    public Var`1<T> Item { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_VarName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VarName(string value);
    [CompilerGeneratedAttribute]
private sealed virtual override bool Microsoft.ML.EntryPoints.IVarSerializationHelper.get_IsValue();
    [CompilerGeneratedAttribute]
private sealed virtual override String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.get_Values();
    public Var`1<T> get_Item(string key);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.EntryPointGraph : object {
    private static string RegistrationName;
    private IHost _host;
    private RunContext _context;
    private List`1<EntryPointNode> _nodes;
    public bool HasRunnableNodes { get; }
    public IEnumerable`1<EntryPointNode> Macros { get; }
    public IEnumerable`1<EntryPointNode> NonMacros { get; }
    public IEnumerable`1<EntryPointNode> AllNodes { get; }
    public RunContext Context { get; }
    public EntryPointGraph(IHostEnvironment env, JArray nodes);
    public bool get_HasRunnableNodes();
    public IEnumerable`1<EntryPointNode> get_Macros();
    public IEnumerable`1<EntryPointNode> get_NonMacros();
    public IEnumerable`1<EntryPointNode> get_AllNodes();
    public RunContext get_Context();
    public String[] GetMissingInputs();
    public void RunNode(EntryPointNode node);
    public bool TryGetVariable(string name, EntryPointVariable& v);
    public EntryPointVariable GetVariableOrNull(string name);
    public void AddNode(EntryPointNode node);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.EntryPointNode : object {
    public string Id;
    private IHost _host;
    private EntryPointInfo _entryPoint;
    private InputBuilder _inputBuilder;
    private OutputHelper _outputHelper;
    private RunContext _context;
    private Dictionary`2<string, List`1<ParameterBinding>> _inputBindingMap;
    private Dictionary`2<ParameterBinding, VariableBinding> _inputMap;
    private Dictionary`2<string, string> _outputMap;
    [CompilerGeneratedAttribute]
private bool <IsFinished>k__BackingField;
    [CompilerGeneratedAttribute]
private TimeSpan <RunTime>k__BackingField;
    private static Regex _stageIdRegex;
    private string _stageId;
    [CompilerGeneratedAttribute]
private bool <Checkpoint>k__BackingField;
    private float _cost;
    private IEnumerable`1<EntryPointNode> _macroNodes;
    public bool IsFinished { get; private set; }
    public TimeSpan RunTime { get; internal set; }
    public string StageId { get; public set; }
    public bool Checkpoint { get; public set; }
    public float Cost { get; public set; }
    public bool IsMacro { get; }
    public IEnumerable`1<EntryPointNode> MacroNodes { get; }
    public ComponentCatalog Catalog { get; }
    public RunContext Context { get; }
    public Dictionary`2<string, List`1<ParameterBinding>> InputBindingMap { get; }
    public Dictionary`2<ParameterBinding, VariableBinding> InputMap { get; }
    public Dictionary`2<string, string> OutputMap { get; }
    private EntryPointNode(IHostEnvironment env, IChannel ch, RunContext context, string id, string entryPointName, JObject inputs, JObject outputs, bool checkpoint, string stageId, float cost, string label, string group, string weight, string name);
    private static EntryPointNode();
    [CompilerGeneratedAttribute]
public bool get_IsFinished();
    [CompilerGeneratedAttribute]
private void set_IsFinished(bool value);
    [CompilerGeneratedAttribute]
public TimeSpan get_RunTime();
    [CompilerGeneratedAttribute]
internal void set_RunTime(TimeSpan value);
    public string get_StageId();
    public void set_StageId(string value);
    [CompilerGeneratedAttribute]
public bool get_Checkpoint();
    [CompilerGeneratedAttribute]
public void set_Checkpoint(bool value);
    public float get_Cost();
    public void set_Cost(float value);
    private void SetColumnArgument(IChannel ch, object inputInstance, string argName, string colName, string columnRole, Type[] inputKinds);
    public static EntryPointNode Create(IHostEnvironment env, string entryPointName, object arguments, RunContext context, Dictionary`2<string, List`1<ParameterBinding>> inputBindingMap, Dictionary`2<ParameterBinding, VariableBinding> inputMap, Dictionary`2<string, string> outputMap, bool checkpoint, string stageId, float cost);
    public static EntryPointNode Create(IHostEnvironment env, string entryPointName, object arguments, ComponentCatalog catalog, RunContext context, Dictionary`2<string, string> inputMap, Dictionary`2<string, string> outputMap, bool checkpoint, string stageId, float cost);
    private void CheckAndSetInputValue(KeyValuePair`2<string, JToken> pair);
    private void CheckAndMarkOutputValue(KeyValuePair`2<string, JToken> pair);
    public void RenameInputVariable(string oldName, VariableBinding newBinding);
    public void RenameOutputVariable(string oldName, string newName, bool cascadeChanges);
    public void RenameAllVariables(Dictionary`2<string, string> mapping);
    private static bool IsStageIdValid(string str);
    public JObject ToJson();
    public bool CanStart();
    public void Run();
    public bool get_IsMacro();
    public IEnumerable`1<EntryPointNode> get_MacroNodes();
    public ComponentCatalog get_Catalog();
    public RunContext get_Context();
    public Dictionary`2<string, List`1<ParameterBinding>> get_InputBindingMap();
    public Dictionary`2<ParameterBinding, VariableBinding> get_InputMap();
    public Dictionary`2<string, string> get_OutputMap();
    public virtual string ToString();
    private object BuildParameterValue(List`1<ParameterBinding> bindings);
    public static List`1<EntryPointNode> ValidateNodes(IHostEnvironment env, RunContext context, JArray nodes, string label, string group, string weight, string name);
    public void SetContext(RunContext context);
    public VariableBinding GetInputVariable(string paramName);
    public string GetOutputVariableName(string paramName);
    public Tuple`2<Var`1<T>, VariableBinding> AddNewVariable(string uniqueName, T value);
    [CompilerGeneratedAttribute]
private bool <CanStart>b__41_0(KeyValuePair`2<ParameterBinding, VariableBinding> kv);
    [CompilerGeneratedAttribute]
private bool <CanStart>b__41_2(VariableBinding varBinding);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.EntryPointVariable : object {
    private IExceptionContext _ectx;
    public string Name;
    public Type Type;
    [CompilerGeneratedAttribute]
private object <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasInputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <HasOutputs>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsValueSet>k__BackingField;
    public object Value { get; private set; }
    public bool HasInputs { get; private set; }
    public bool HasOutputs { get; private set; }
    public bool IsValueSet { get; private set; }
    public EntryPointVariable(IExceptionContext ectx, string name, Type type);
    [CompilerGeneratedAttribute]
public object get_Value();
    [CompilerGeneratedAttribute]
private void set_Value(object value);
    [CompilerGeneratedAttribute]
public bool get_HasInputs();
    [CompilerGeneratedAttribute]
private void set_HasInputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_HasOutputs();
    [CompilerGeneratedAttribute]
private void set_HasOutputs(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsValueSet();
    [CompilerGeneratedAttribute]
private void set_IsValueSet(bool value);
    public static bool IsValidType(Type variableType);
    public void SetValue(object value);
    public void MarkUsage(bool isInput);
    public EntryPointVariable Clone(string newName);
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.EvaluateInputBase : object {
    [ArgumentAttribute("1")]
public IDataView Data;
    [ArgumentAttribute("0")]
public string NameColumn;
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.FieldNames : object {
    public static string Nodes;
    public static string Kind;
    public static string Components;
    public static string ComponentKind;
    public static string Type;
    public static string ItemType;
    public static string Fields;
    public static string Values;
    public static string Name;
    public static string Aliases;
    public static string FriendlyName;
    public static string ShortName;
    public static string Desc;
    public static string Required;
    public static string Default;
    public static string Checkpoint;
    public static string StageId;
    public static string Cost;
    public static string Settings;
    public static string Inputs;
    public static string Outputs;
    public static string InputKind;
    public static string OutputKind;
    public static string SortOrder;
    public static string IsNullable;
    public static string TopEntryPoints;
    public static string TopComponents;
    public static string TopEntryPointKinds;
}
internal class Microsoft.ML.EntryPoints.InputBuilder : object {
    private static FuncStaticMethodInfo1`2<object, object> _makeNullableMethodInfo;
    private static FuncStaticMethodInfo1`2<object, object> _makeOptionalMethodInfo;
    private IExceptionContext _ectx;
    private object _instance;
    private Type _type;
    private FieldInfo[] _fields;
    private Boolean[] _wasSet;
    private Attributes[] _attrs;
    private ComponentCatalog _catalog;
    public InputBuilder(IExceptionContext ectx, Type inputType, ComponentCatalog catalog);
    private static InputBuilder();
    private static bool AnyMatch(string name, String[] aliases);
    private int GetFieldIndex(string name);
    public Type GetFieldTypeOrNull(string alias);
    public string GetFieldNameOrNull(string alias);
    public String[] GetMissingValues();
    public bool IsInputOptional(string name);
    public bool TrySetValueJson(string name, JToken value);
    public bool TrySetValue(string name, object value);
    public JObject GetJsonObject(object instance, Dictionary`2<string, List`1<ParameterBinding>> inputBindingMap, Dictionary`2<ParameterBinding, VariableBinding> inputMap);
    private static bool ExtractOptional(Object& value, Type& type);
    private static object ParseJsonValue(IExceptionContext ectx, Type type, Attributes attributes, JToken value, ComponentCatalog catalog);
    private static object GetFieldAssignableValue(IExceptionContext ectx, Type type, object value);
    private static IComponentFactory GetComponentJson(IExceptionContext ectx, Type signatureType, string name, JObject settings, ComponentCatalog catalog);
    private static object MakeArray(IExceptionContext ectx, JArray jArray, Attributes attributes, ComponentCatalog catalog);
    private static object MakeDictionary(IExceptionContext ectx, JObject jDict, Attributes attributes, ComponentCatalog catalog);
    private static object MakeOptional(object value);
    private static object MakeNullable(object value);
    private static object MakeOptionalIfNeeded(IExceptionContext ectx, object innerValue, Type outerType);
    public object GetInstance();
}
internal interface Microsoft.ML.EntryPoints.IVarSerializationHelper {
    public string VarName { get; public set; }
    public bool IsValue { get; }
    public String[] Values { get; }
    public abstract virtual string get_VarName();
    public abstract virtual void set_VarName(string value);
    public abstract virtual bool get_IsValue();
    public abstract virtual String[] get_Values();
}
internal class Microsoft.ML.EntryPoints.OutputHelper : object {
    private IExceptionContext _ectx;
    private Type _type;
    private FieldInfo[] _fields;
    private OutputAttribute[] _attrs;
    public OutputHelper(IExceptionContext ectx, Type outputType);
    private FieldInfo GetField(string name);
    public Type GetFieldType(string name);
    [IteratorStateMachineAttribute("Microsoft.ML.EntryPoints.OutputHelper/<ExtractValues>d__7")]
public IEnumerable`1<KeyValuePair`2<string, object>> ExtractValues(object output);
    public JObject GetJsonObject(Dictionary`2<string, string> outputMap);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.ParameterBinding : object {
    public string ParameterName;
    protected ParameterBinding(string name);
    public virtual string ToString();
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.PredictorModelImpl : PredictorModel {
    private KeyValuePair`2[] _roleMappings;
    [CompilerGeneratedAttribute]
private TransformModel <TransformModel>k__BackingField;
    [CompilerGeneratedAttribute]
private IPredictor <Predictor>k__BackingField;
    internal TransformModel TransformModel { get; }
    internal IPredictor Predictor { get; }
    [BestFriendAttribute]
internal PredictorModelImpl(IHostEnvironment env, RoleMappedData trainingData, IDataView startingData, IPredictor predictor);
    [BestFriendAttribute]
internal PredictorModelImpl(IHostEnvironment env, Stream stream);
    private PredictorModelImpl(TransformModel transformModel, IPredictor predictor, KeyValuePair`2[] roleMappings);
    [CompilerGeneratedAttribute]
internal virtual TransformModel get_TransformModel();
    [CompilerGeneratedAttribute]
internal virtual IPredictor get_Predictor();
    internal virtual void Save(IHostEnvironment env, Stream stream);
    internal virtual PredictorModel Apply(IHostEnvironment env, TransformModel transformModel);
    internal virtual void PrepareData(IHostEnvironment env, IDataView input, RoleMappedData& roleMappedData, IPredictor& predictor);
    internal virtual String[] GetLabelInfo(IHostEnvironment env, DataViewType& labelType);
    internal virtual RoleMappedSchema GetTrainingSchema(IHostEnvironment env);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.RunContext : object {
    private Dictionary`2<string, EntryPointVariable> _vars;
    private IExceptionContext _ectx;
    private int _idCount;
    public RunContext(IExceptionContext ectx);
    public bool TryGetVariable(string name, EntryPointVariable& v);
    public object GetValueOrNull(VariableBinding binding);
    public void AddInputVariable(VariableBinding binding, Type type);
    public void RemoveVariable(EntryPointVariable variable);
    public bool AddOutputVariable(string name, Type type);
    public String[] GetMissingInputs();
    public string GenerateId(string name);
    public void AddContextVariables(RunContext subGraphRunContext);
    public void RenameContextVariable(string oldName, string newName);
    public EntryPointVariable CreateTempOutputVar(string varPrefix);
}
internal static class Microsoft.ML.EntryPoints.SchemaManipulation : object {
    [EntryPointAttribute]
public static TransformOutput ConcatColumns(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput SelectColumns(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput CopyColumns(IHostEnvironment env, Options input);
}
internal static class Microsoft.ML.EntryPoints.SelectRows : object {
    [EntryPointAttribute]
public static TransformOutput FilterByRange(IHostEnvironment env, Options input);
    [EntryPointAttribute]
public static TransformOutput SkipFilter(IHostEnvironment env, SkipOptions input);
    [EntryPointAttribute]
public static TransformOutput TakeFilter(IHostEnvironment env, TakeOptions input);
    [EntryPointAttribute]
public static TransformOutput SkipAndTakeFilter(IHostEnvironment env, Options input);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.SimpleParameterBinding : ParameterBinding {
    public SimpleParameterBinding(string name);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.SimpleVariableBinding : VariableBinding {
    public SimpleVariableBinding(string name);
    public virtual object GetVariableValueOrNull(EntryPointVariable variable);
    public virtual string ToJson();
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.SummarizePredictor : object {
    [EntryPointAttribute]
public static SummaryOutput Summarize(IHostEnvironment env, Input input);
    [BestFriendAttribute]
internal static IDataView GetSummaryAndStats(IHostEnvironment env, IPredictor predictor, RoleMappedSchema schema, IDataView& stats);
}
[BestFriendAttribute]
internal static class Microsoft.ML.EntryPoints.TrainerEntryPointsUtils : object {
    public static string FindColumn(IExceptionContext ectx, DataViewSchema schema, Optional`1<string> value);
    public static TOut Train(IHost host, TArg input, Func`1<ITrainer> createTrainer, Func`1<string> getLabel, Func`1<string> getWeight, Func`1<string> getGroup, Func`1<string> getName, Func`1<IEnumerable`1<KeyValuePair`2<ColumnRole, string>>> getCustom, ICalibratorTrainerFactory calibrator, int maxCalibrationExamples);
}
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.TransformModelImpl : TransformModel {
    private DataViewSchema _schemaRoot;
    private IDataView _chain;
    internal DataViewSchema InputSchema { get; }
    internal DataViewSchema OutputSchema { get; }
    public TransformModelImpl(IHostEnvironment env, IDataView result, IDataView input);
    private TransformModelImpl(IHostEnvironment env, DataViewSchema schemaRoot, IDataView chain);
    public TransformModelImpl(IHostEnvironment env, DataViewSchema schemaRoot, IDataTransform[] xfs);
    public TransformModelImpl(IHostEnvironment env, Stream stream);
    internal virtual DataViewSchema get_InputSchema();
    internal virtual DataViewSchema get_OutputSchema();
    internal virtual IDataView Apply(IHostEnvironment env, IDataView input);
    internal virtual TransformModel Apply(IHostEnvironment env, TransformModel input);
    internal virtual void Save(IHostEnvironment env, Stream stream);
    internal virtual IRowToRowMapper AsRowToRowMapper(IExceptionContext ectx);
}
[JsonConverterAttribute("Microsoft.ML.EntryPoints.VarSerializer")]
[BestFriendAttribute]
internal class Microsoft.ML.EntryPoints.Var`1 : object {
    [CompilerGeneratedAttribute]
private string <VarName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <Microsoft.ML.EntryPoints.IVarSerializationHelper.IsValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Microsoft.ML.EntryPoints.IVarSerializationHelper.Values>k__BackingField;
    public string VarName { get; public set; }
    private bool Microsoft.ML.EntryPoints.IVarSerializationHelper.IsValue { get; }
    private String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.Values { get; }
    [CompilerGeneratedAttribute]
public sealed virtual string get_VarName();
    [CompilerGeneratedAttribute]
public sealed virtual void set_VarName(string value);
    [CompilerGeneratedAttribute]
private sealed virtual override bool Microsoft.ML.EntryPoints.IVarSerializationHelper.get_IsValue();
    [CompilerGeneratedAttribute]
private sealed virtual override String[] Microsoft.ML.EntryPoints.IVarSerializationHelper.get_Values();
    public static bool CheckType(Type type);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.EntryPoints.VariableBinding : object {
    [CompilerGeneratedAttribute]
private string <VariableName>k__BackingField;
    private static Regex _variableRegex;
    public string VariableName { get; private set; }
    protected VariableBinding(string varName);
    private static VariableBinding();
    [CompilerGeneratedAttribute]
public string get_VariableName();
    [CompilerGeneratedAttribute]
private void set_VariableName(string value);
    public abstract virtual object GetVariableValueOrNull(EntryPointVariable variable);
    public static VariableBinding Create(IExceptionContext ectx, string jsonString);
    public static bool IsBindingToken(JToken tok);
    public static bool IsValidVariableName(IExceptionContext ectx, string variableName);
    public void Rename(string newName);
    public abstract virtual string ToJson();
    public virtual string ToString();
}
internal class Microsoft.ML.EntryPoints.VarSerializer : JsonConverter {
    public bool CanRead { get; }
    public virtual void WriteJson(JsonWriter writer, object value, JsonSerializer serializer);
    public virtual object ReadJson(JsonReader reader, Type objectType, object existingValue, JsonSerializer serializer);
    public virtual bool CanConvert(Type objectType);
    public virtual bool get_CanRead();
}
[ExtensionAttribute]
public static class Microsoft.ML.ExplainabilityCatalog : object {
    [ExtensionAttribute]
public static FeatureContributionCalculatingEstimator CalculateFeatureContribution(TransformsCatalog catalog, ISingleFeaturePredictionTransformer`1<ICalculateFeatureContribution> predictionTransformer, int numberOfPositiveContributions, int numberOfNegativeContributions, bool normalize);
    [ExtensionAttribute]
public static FeatureContributionCalculatingEstimator CalculateFeatureContribution(TransformsCatalog catalog, ISingleFeaturePredictionTransformer`1<CalibratedModelParametersBase`2<TModelParameters, TCalibrator>> predictionTransformer, int numberOfPositiveContributions, int numberOfNegativeContributions, bool normalize);
}
public class Microsoft.ML.ForecastingCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private Forecasters <Trainers>k__BackingField;
    public Forecasters Trainers { get; }
    internal ForecastingCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public Forecasters get_Trainers();
}
public class Microsoft.ML.InputOutputColumnPair : object {
    [CompilerGeneratedAttribute]
private string <InputColumnName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputColumnName>k__BackingField;
    public string InputColumnName { get; }
    public string OutputColumnName { get; }
    public InputOutputColumnPair(string outputColumnName, string inputColumnName);
    [CompilerGeneratedAttribute]
public string get_InputColumnName();
    [CompilerGeneratedAttribute]
public string get_OutputColumnName();
    [BestFriendAttribute]
internal static ValueTuple`2[] ConvertToValueTuples(InputOutputColumnPair[] infos);
    [BestFriendAttribute]
internal static IReadOnlyList`1<InputOutputColumnPair> ConvertFromValueTuples(ValueTuple`2[] infos);
}
[DefaultMemberAttribute("Item")]
[BestFriendAttribute]
internal abstract class Microsoft.ML.Internal.Internallearn.FeatureNameCollection : object {
    private static string DefaultFmt;
    private Dictionary`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lookup;
    private Object modreq(System.Runtime.CompilerServices.IsVolatile) _lock;
    public static string LoaderSignature;
    public RoleMappedSchema Schema { get; }
    public int Count { get; }
    public int NonDefaultCount { get; }
    public string Item { get; }
    public abstract virtual RoleMappedSchema get_Schema();
    public static FeatureNameCollection Create(String[] names);
    public static FeatureNameCollection Create(int count, String[] names);
    public static FeatureNameCollection Create(int count, Dictionary`2<int, string> map);
    private static VersionInfo GetVersionInfo();
    public static void Save(ModelSaveContext ctx, VBuffer`1& names);
    public static FeatureNameCollection Create(ModelLoadContext ctx);
    public abstract virtual int get_Count();
    public abstract virtual int get_NonDefaultCount();
    public string get_Item(int index);
    public abstract virtual string GetNameOrNull(int index);
    public abstract virtual IEnumerator`1<string> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    private string GetDefault(int index);
    public bool TryLookup(string name, Int32& index);
    private void BuildLookup();
    protected abstract virtual void PopulateLookup(Dictionary`2<string, int> lookup);
    protected abstract virtual IEnumerable`1<KeyValuePair`2<int, string>> GetNonDefaultFeatureNames();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Internallearn.PredictionUtil : object {
    private static Char[] _dontSplitChars;
    private static PredictionUtil();
    public static void ParseArguments(IHostEnvironment env, object args, string settings, string name);
    public static string CombineSettings(String[] settings, String[] extraSettings);
    public static String[] SplitOnSemis(String[] args);
    public static string Array2String(Single[] a, string sep);
    public static Char[] SeparatorFromString(string sep);
    public static char SepCharFromString(string s);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Internallearn.PredictorUtils : object {
    public static void SaveSummary(IChannel ch, IPredictor predictor, RoleMappedSchema schema, TextWriter writer);
    public static void SaveText(IChannel ch, IPredictor predictor, RoleMappedSchema schema, TextWriter writer);
    public static void SaveBinary(IChannel ch, IPredictor predictor, BinaryWriter writer);
    public static void SaveIni(IChannel ch, IPredictor predictor, RoleMappedSchema schema, TextWriter writer);
    public static void SaveCode(IChannel ch, IPredictor predictor, RoleMappedSchema schema, TextWriter writer);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Internallearn.SlotDropper : object {
    private Int32[] _lengthReduction;
    private int _srcLength;
    [CompilerGeneratedAttribute]
private int <DstLength>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <SlotsMin>k__BackingField;
    [CompilerGeneratedAttribute]
private Int32[] <SlotsMax>k__BackingField;
    public int DstLength { get; }
    public Int32[] SlotsMin { get; }
    public Int32[] SlotsMax { get; }
    public SlotDropper(int srcLength, Int32[] slotsMin, Int32[] slotsMax);
    [CompilerGeneratedAttribute]
public int get_DstLength();
    [CompilerGeneratedAttribute]
public Int32[] get_SlotsMin();
    [CompilerGeneratedAttribute]
public Int32[] get_SlotsMax();
    private int ComputeLength(int srcLength);
    private Int32[] ComputeLengthReduction();
    public ValueGetter`1<VBuffer`1<T>> SubsetGetter(ValueGetter`1<VBuffer`1<T>> getter);
    public void DropSlots(VBuffer`1& src, VBuffer`1& dst);
    public IEnumerable`1<long> GetPreservedSlots();
}
[AttributeUsageAttribute("256")]
internal class Microsoft.ML.Internal.Internallearn.TGUIAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Label>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsSaveFileName>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsFolder>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowPreviewIcon>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputFilenameTemplate>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SuggestedSweeps>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <RegistryBacked>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NotGui>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoSweep>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ShowSettingsForCheckbox>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Settings>k__BackingField;
    public string Label { get; public set; }
    public string Description { get; public set; }
    public bool IsSaveFileName { get; public set; }
    public bool IsFolder { get; public set; }
    public bool ShowPreviewIcon { get; public set; }
    public string OutputFilenameTemplate { get; public set; }
    public string SuggestedSweeps { get; public set; }
    public bool RegistryBacked { get; public set; }
    public bool NotGui { get; public set; }
    public bool NoSweep { get; public set; }
    public bool ShowSettingsForCheckbox { get; public set; }
    public object Settings { get; public set; }
    [CompilerGeneratedAttribute]
public string get_Label();
    [CompilerGeneratedAttribute]
public void set_Label(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
public void set_Description(string value);
    [CompilerGeneratedAttribute]
public bool get_IsSaveFileName();
    [CompilerGeneratedAttribute]
public void set_IsSaveFileName(bool value);
    [CompilerGeneratedAttribute]
public bool get_IsFolder();
    [CompilerGeneratedAttribute]
public void set_IsFolder(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowPreviewIcon();
    [CompilerGeneratedAttribute]
public void set_ShowPreviewIcon(bool value);
    [CompilerGeneratedAttribute]
public string get_OutputFilenameTemplate();
    [CompilerGeneratedAttribute]
public void set_OutputFilenameTemplate(string value);
    [CompilerGeneratedAttribute]
public string get_SuggestedSweeps();
    [CompilerGeneratedAttribute]
public void set_SuggestedSweeps(string value);
    [CompilerGeneratedAttribute]
public bool get_RegistryBacked();
    [CompilerGeneratedAttribute]
public void set_RegistryBacked(bool value);
    [CompilerGeneratedAttribute]
public bool get_NotGui();
    [CompilerGeneratedAttribute]
public void set_NotGui(bool value);
    [CompilerGeneratedAttribute]
public bool get_NoSweep();
    [CompilerGeneratedAttribute]
public void set_NoSweep(bool value);
    [CompilerGeneratedAttribute]
public bool get_ShowSettingsForCheckbox();
    [CompilerGeneratedAttribute]
public void set_ShowSettingsForCheckbox(bool value);
    [CompilerGeneratedAttribute]
public object get_Settings();
    [CompilerGeneratedAttribute]
public void set_Settings(object value);
}
internal abstract class Microsoft.ML.Internal.Internallearn.UnsafeTypeOps`1 : object {
    public int Size { get; }
    public abstract virtual int get_Size();
    public abstract virtual void Apply(ReadOnlySpan`1<T> array, Action`1<IntPtr> func);
    public abstract virtual void Write(T a, BinaryWriter writer);
    public abstract virtual T Read(BinaryReader reader);
}
internal static class Microsoft.ML.Internal.Internallearn.UnsafeTypeOpsFactory : object {
    private static Dictionary`2<Type, object> _type2ops;
    private static UnsafeTypeOpsFactory();
    public static UnsafeTypeOps`1<T> Get();
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.IniFileUtils : object {
    public static string AddEvaluator(string ini, string evaluator);
    public static int NumEvaluators(string ini);
    public static string GetCalibratorEvaluatorIni(string originalIni, PlattCalibrator calibrator);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.SequencePool : object {
    private int _mask;
    private Int32[] _buckets;
    private int _idLim;
    private Int32[] _next;
    private Int32[] _start;
    private UInt32[] _hash;
    private Byte[] _bytes;
    public int Count { get; }
    public SequencePool(BinaryReader reader);
    public int get_Count();
    public void Save(BinaryWriter writer);
    [ConditionalAttribute("DEBUG")]
private void AssertValid();
    private int GetFirstIdInBucket(UInt32 hash);
    private int GetBucketIndex(UInt32 hash);
    private int GetCore(UInt32[] sequence, int min, int lim, UInt32& hash);
    public bool TryAdd(UInt32[] sequence, int min, int lim, Int32& id);
    public int Get(UInt32[] sequence, int min, int lim);
    private void AddCore(UInt32[] sequence, int min, int lim, UInt32 hash);
    private void GrowTable();
    public int GetById(int id, UInt32[]& sequence);
    private static void UIntArrayToLeb128(UInt32[] values, int min, int lim, Byte[] bytes, Int32& ib);
    private static bool TryDecodeOne(Byte[] bytes, Int32& ib, int ibLim, UInt32& value);
    private static int Leb128ToUIntArray(Byte[] bytes, int min, int lim, UInt32[]& sequence);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Internal.Utilities.StreamUtils : object {
    private static Char[] _wildChars;
    private static Char[] _wildPlusChars;
    private static StreamUtils();
    public static Stream OpenInStream(string fileName);
    public static StreamWriter CreateWriter(string fileName);
    public static String[] ExpandWildCards(string pattern);
    private static String[] Expand(string pattern);
}
[BestFriendAttribute]
internal class Microsoft.ML.Internal.Utilities.TimerScope : object {
    private IChannel _ch;
    private Stopwatch _watch;
    private IHost _host;
    public TimerScope(IHost host, IChannel ch);
    public sealed virtual void Dispose();
}
public interface Microsoft.ML.IPredictionTransformer`1 {
    public TModel Model { get; }
    public abstract virtual TModel get_Model();
}
[BestFriendAttribute]
internal interface Microsoft.ML.ISingleFeaturePredictionTransformer {
    public string FeatureColumnName { get; }
    public abstract virtual string get_FeatureColumnName();
}
public interface Microsoft.ML.ISingleFeaturePredictionTransformer`1 {
    public string FeatureColumnName { get; }
    public DataViewType FeatureColumnType { get; }
    public abstract virtual string get_FeatureColumnName();
    public abstract virtual DataViewType get_FeatureColumnType();
}
[ExtensionAttribute]
public static class Microsoft.ML.LearningPipelineExtensions : object {
    [ExtensionAttribute]
public static CompositeLoaderEstimator`2<TSource, TTrans> Append(IDataLoaderEstimator`2<TSource, IDataLoader`1<TSource>> start, IEstimator`1<TTrans> estimator);
    [ExtensionAttribute]
public static CompositeLoaderEstimator`2<TSource, TTrans> Append(IDataLoader`1<TSource> start, IEstimator`1<TTrans> estimator);
    [ExtensionAttribute]
public static EstimatorChain`1<TTrans> Append(IEstimator`1<ITransformer> start, IEstimator`1<TTrans> estimator, TransformerScope scope);
    [ExtensionAttribute]
public static EstimatorChain`1<TTrans> AppendCacheCheckpoint(IEstimator`1<TTrans> start, IHostEnvironment env);
    [ExtensionAttribute]
public static CompositeDataLoader`2<TSource, TTrans> Append(IDataLoader`1<TSource> loader, TTrans transformer);
    [ExtensionAttribute]
public static TransformerChain`1<TTrans> Append(ITransformer start, TTrans transformer);
    [ExtensionAttribute]
public static IEstimator`1<TTransformer> WithOnFitDelegate(IEstimator`1<TTransformer> estimator, Action`1<TTransformer> onFit);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static T[] AppendElement(T[] array, T element);
}
public class Microsoft.ML.LoggingEventArgs : EventArgs {
    [CompilerGeneratedAttribute]
private string <Source>k__BackingField;
    [CompilerGeneratedAttribute]
private ChannelMessageKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <RawMessage>k__BackingField;
    public string Source { get; }
    public ChannelMessageKind Kind { get; }
    public string Message { get; }
    public string RawMessage { get; }
    public LoggingEventArgs(string message);
    public LoggingEventArgs(string message, ChannelMessageKind kind, string source);
    [CompilerGeneratedAttribute]
public string get_Source();
    [CompilerGeneratedAttribute]
public ChannelMessageKind get_Kind();
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_RawMessage();
}
public class Microsoft.ML.MLContext : object {
    private LocalEnvironment _env;
    [CompilerGeneratedAttribute]
private BinaryClassificationCatalog <BinaryClassification>k__BackingField;
    [CompilerGeneratedAttribute]
private MulticlassClassificationCatalog <MulticlassClassification>k__BackingField;
    [CompilerGeneratedAttribute]
private RegressionCatalog <Regression>k__BackingField;
    [CompilerGeneratedAttribute]
private ClusteringCatalog <Clustering>k__BackingField;
    [CompilerGeneratedAttribute]
private RankingCatalog <Ranking>k__BackingField;
    [CompilerGeneratedAttribute]
private AnomalyDetectionCatalog <AnomalyDetection>k__BackingField;
    [CompilerGeneratedAttribute]
private ForecastingCatalog <Forecasting>k__BackingField;
    [CompilerGeneratedAttribute]
private TransformsCatalog <Transforms>k__BackingField;
    [CompilerGeneratedAttribute]
private ModelOperationsCatalog <Model>k__BackingField;
    [CompilerGeneratedAttribute]
private DataOperationsCatalog <Data>k__BackingField;
    [CompilerGeneratedAttribute]
private EventHandler`1<LoggingEventArgs> Log;
    [BestFriendAttribute]
internal static bool OneDalDispatchingEnabled;
    public BinaryClassificationCatalog BinaryClassification { get; }
    public MulticlassClassificationCatalog MulticlassClassification { get; }
    public RegressionCatalog Regression { get; }
    public ClusteringCatalog Clustering { get; }
    public RankingCatalog Ranking { get; }
    public AnomalyDetectionCatalog AnomalyDetection { get; }
    public ForecastingCatalog Forecasting { get; }
    public TransformsCatalog Transforms { get; }
    public ModelOperationsCatalog Model { get; }
    public DataOperationsCatalog Data { get; }
    public ComponentCatalog ComponentCatalog { get; }
    public string TempFilePath { get; public set; }
    public bool FallbackToCpu { get; public set; }
    public Nullable`1<int> GpuDeviceId { get; public set; }
    private string Microsoft.ML.Runtime.IExceptionContext.ContextDescription { get; }
    private Nullable`1<int> Microsoft.ML.Runtime.IHostEnvironmentInternal.Seed { get; }
    public MLContext(Nullable`1<int> seed);
    private static MLContext();
    [CompilerGeneratedAttribute]
public BinaryClassificationCatalog get_BinaryClassification();
    [CompilerGeneratedAttribute]
public MulticlassClassificationCatalog get_MulticlassClassification();
    [CompilerGeneratedAttribute]
public RegressionCatalog get_Regression();
    [CompilerGeneratedAttribute]
public ClusteringCatalog get_Clustering();
    [CompilerGeneratedAttribute]
public RankingCatalog get_Ranking();
    [CompilerGeneratedAttribute]
public AnomalyDetectionCatalog get_AnomalyDetection();
    [CompilerGeneratedAttribute]
public ForecastingCatalog get_Forecasting();
    [CompilerGeneratedAttribute]
public TransformsCatalog get_Transforms();
    [CompilerGeneratedAttribute]
public ModelOperationsCatalog get_Model();
    [CompilerGeneratedAttribute]
public DataOperationsCatalog get_Data();
    [CompilerGeneratedAttribute]
public void add_Log(EventHandler`1<LoggingEventArgs> value);
    [CompilerGeneratedAttribute]
public void remove_Log(EventHandler`1<LoggingEventArgs> value);
    public sealed virtual ComponentCatalog get_ComponentCatalog();
    public sealed virtual string get_TempFilePath();
    public sealed virtual void set_TempFilePath(string value);
    public sealed virtual bool get_FallbackToCpu();
    public sealed virtual void set_FallbackToCpu(bool value);
    public sealed virtual Nullable`1<int> get_GpuDeviceId();
    public sealed virtual void set_GpuDeviceId(Nullable`1<int> value);
    private void ProcessMessage(IMessageSource source, ChannelMessage message);
    private sealed virtual override string Microsoft.ML.Runtime.IExceptionContext.get_ContextDescription();
    private sealed virtual override TException Microsoft.ML.Runtime.IExceptionContext.Process(TException ex);
    private sealed virtual override IHost Microsoft.ML.Runtime.IHostEnvironment.Register(string name, Nullable`1<int> seed, Nullable`1<bool> verbose);
    private sealed virtual override IChannel Microsoft.ML.Runtime.IChannelProvider.Start(string name);
    private sealed virtual override IPipe`1<TMessage> Microsoft.ML.Runtime.IChannelProvider.StartPipe(string name);
    private sealed virtual override IProgressChannel Microsoft.ML.Runtime.IProgressChannelProvider.StartProgressChannel(string name);
    private sealed virtual override Nullable`1<int> Microsoft.ML.Runtime.IHostEnvironmentInternal.get_Seed();
    [BestFriendAttribute]
internal void CancelExecution();
    private static bool InitializeOneDalDispatchingEnabled();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanGetSummaryAsIDataView {
    public abstract virtual IDataView GetSummaryDataView(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanGetSummaryAsIRow {
    public abstract virtual DataViewRow GetSummaryIRowOrNull(RoleMappedSchema schema);
    public abstract virtual DataViewRow GetStatsIRowOrNull(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanGetSummaryInKeyValuePairs {
    public abstract virtual IList`1<KeyValuePair`2<string, object>> GetSummaryInKeyValuePairs(RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanGetTrainingLabelNames {
    public abstract virtual String[] GetLabelNamesOrNull(DataViewType& labelType);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanSaveInIniFormat {
    public abstract virtual void SaveAsIni(TextWriter writer, RoleMappedSchema schema, ICalibrator calibrator);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanSaveInSourceCode {
    public abstract virtual void SaveAsCode(TextWriter writer, RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanSaveInTextFormat {
    public abstract virtual void SaveAsText(TextWriter writer, RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ICanSaveSummary {
    public abstract virtual void SaveSummary(TextWriter writer, RoleMappedSchema schema);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IDistribution`1 {
    public TResult Minimum { get; }
    public TResult Maximum { get; }
    public TResult Mean { get; }
    public TResult StandardDeviation { get; }
    public abstract virtual TResult get_Minimum();
    public abstract virtual TResult get_Maximum();
    public abstract virtual TResult get_Mean();
    public abstract virtual TResult get_StandardDeviation();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IHaveFeatureWeights {
    public abstract virtual void GetFeatureWeights(VBuffer`1& weights);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IParameterMixer {
    public abstract virtual IParameterMixer CombineParameters(IList`1<IParameterMixer> models);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IParameterMixer`1 {
    public abstract virtual IParameterMixer`1<TOutput> CombineParameters(IList`1<IParameterMixer`1<TOutput>> models);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IPredictorWithFeatureWeights`1 {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IQuantileRegressionPredictor {
    public abstract virtual ISchemaBindableMapper CreateMapper(Double[] quantiles);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.IQuantileValueMapper {
    public abstract virtual ValueMapper`2<VBuffer`1<float>, VBuffer`1<float>> GetMapper(Single[] quantiles);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.ISampleableDistribution`1 {
    public abstract virtual TResult[] GetSupportSample(TResult[]& weights);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Model.ModelFileUtils : object {
    public static string DirPredictor;
    public static string DirDataLoaderModel;
    public static string DirTransformerChain;
    public static string SchemaEntryName;
    public static string DirTrainingInfo;
    private static string RoleMappingFile;
    public static IDataView LoadPipeline(IHostEnvironment env, Stream modelStream, IMultiStreamSource files, bool extractInnerPipe);
    public static IDataView LoadPipeline(IHostEnvironment env, RepositoryReader rep, IMultiStreamSource files, bool extractInnerPipe);
    public static IDataView LoadTransforms(IHostEnvironment env, IDataView data, Stream modelStream);
    public static IDataView LoadTransforms(IHostEnvironment env, IDataView data, RepositoryReader rep);
    public static IPredictor LoadPredictorOrNull(IHostEnvironment env, Stream modelStream);
    public static IPredictor LoadPredictorOrNull(IHostEnvironment env, RepositoryReader rep);
    public static ModelSaveContext GetDataModelSavingContext(RepositoryWriter rep);
    public static ILegacyDataLoader LoadLoader(IHostEnvironment env, RepositoryReader rep, IMultiStreamSource files, bool loadTransforms);
    public static bool TryLoadFeatureNames(FeatureNameCollection& featureNames, RepositoryReader rep);
    internal static void SaveRoleMappings(IHostEnvironment env, IChannel ch, RoleMappedSchema schema, RepositoryWriter rep);
    public static IEnumerable`1<KeyValuePair`2<ColumnRole, string>> LoadRoleMappingsOrNull(IHostEnvironment env, Stream modelStream);
    public static IEnumerable`1<KeyValuePair`2<ColumnRole, string>> LoadRoleMappingsOrNull(IHostEnvironment env, RepositoryReader rep);
    public static RoleMappedSchema LoadRoleMappedSchemaOrNull(IHostEnvironment env, Stream modelStream);
    public static RoleMappedSchema LoadRoleMappedSchemaOrNull(IHostEnvironment env, RepositoryReader rep);
}
internal static class Microsoft.ML.Model.ModelUtils : object {
    private static string ArgCase(string name);
    public static string CreateNameCore(string name, Func`2<string, bool> contains);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.IBindableCanSaveOnnx {
    public abstract virtual bool SaveAsOnnx(OnnxContext ctx, RoleMappedSchema schema, String[] outputNames);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.ICanSaveOnnx {
    public abstract virtual bool CanSaveOnnx(OnnxContext ctx);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.IDistCanSaveOnnx {
    public abstract virtual bool SaveAsOnnx(OnnxContext ctx, String[] outputNames, string featureColumn);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.ISaveAsOnnx {
    public abstract virtual void SaveAsOnnx(OnnxContext ctx);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.ISingleCanSaveOnnx {
    public abstract virtual bool SaveAsOnnx(OnnxContext ctx, String[] outputNames, string featureColumn);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.OnnxConverter.ITransformCanSaveOnnx {
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Model.OnnxConverter.OnnxContext : object {
    public abstract virtual string GetNodeName(string prefix);
    public abstract virtual bool IsVariableDefined(string variableName);
    public abstract virtual bool ContainsColumn(string colName);
    public abstract virtual void CheckOpSetVersion(int thisTransformerMinumumOpSetVersion, string registerTransformerName);
    public abstract virtual void RemoveColumn(string colName, bool removeVariable);
    public abstract virtual void RemoveVariable(string variableName, bool removeColumn);
    public abstract virtual void RemoveInputVariable(string variableName);
    public abstract virtual string GetVariableName(string colName);
    public abstract virtual string AddIntermediateVariable(DataViewType type, string colName, bool skip);
    public abstract virtual OnnxNode CreateNode(string opType, IEnumerable`1<string> inputs, IEnumerable`1<string> outputs, string name, string domain);
    public OnnxNode CreateNode(string opType, string input, string output, string name, string domain);
    public abstract virtual OnnxVersion GetOnnxVersion();
    public abstract virtual List`1<long> RetrieveShapeOrNull(string variableName);
    public abstract virtual string AddInitializer(bool value, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(float value, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(int value, Type type, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(string value, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(long value, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(double value, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(ulong value, bool isUint64, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<bool> values, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<float> values, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<int> values, Type type, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<string> values, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<long> values, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<double> values, IEnumerable`1<long> dims, string name, bool makeUniqueName);
    public abstract virtual string AddInitializer(IEnumerable`1<ulong> values, bool isUint64, IEnumerable`1<long> dims, string name, bool makeUniqueName);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Model.OnnxConverter.OnnxNode : object {
    public abstract virtual void AddAttribute(string argName, double value);
    public abstract virtual void AddAttribute(string argName, long value);
    public abstract virtual void AddAttribute(string argName, ReadOnlyMemory`1<char> value);
    public abstract virtual void AddAttribute(string argName, string value);
    public abstract virtual void AddAttribute(string argName, bool value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<double> value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<float> value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<long> value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<ReadOnlyMemory`1<char>> value);
    public abstract virtual void AddAttribute(string argName, String[] value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<string> value);
    public abstract virtual void AddAttribute(string argName, IEnumerable`1<bool> value);
    public abstract virtual void AddAttribute(string argName, Type t);
}
[BestFriendAttribute]
internal enum Microsoft.ML.Model.OnnxConverter.OnnxVersion : Enum {
    public int value__;
    public static OnnxVersion Stable;
    public static OnnxVersion Experimental;
}
[BestFriendAttribute]
internal class Microsoft.ML.Model.Pfa.BoundPfaContext : object {
    [CompilerGeneratedAttribute]
private PfaContext <Pfa>k__BackingField;
    private Dictionary`2<string, string> _nameToVarName;
    private HashSet`1<string> _unavailable;
    private bool _allowSet;
    private IHost _host;
    public PfaContext Pfa { get; }
    public BoundPfaContext(IHostEnvironment env, DataViewSchema inputSchema, HashSet`1<string> toDrop, bool allowSet);
    [CompilerGeneratedAttribute]
public PfaContext get_Pfa();
    private void SetInput(DataViewSchema schema, HashSet`1<string> toDrop);
    public JObject Finalize(DataViewSchema schema, String[] toOutput);
    private JToken PfaTypeOrNullForColumn(DataViewSchema schema, int col);
    private string CreateNameVar(string name);
    private string CreateNameCell(string name);
    public String[] DeclareVar(KeyValuePair`2[] vars);
    public string DeclareVar(string name, JToken value);
    public string GetFreeFunctionName(string baseName);
    public string DeclareCell(string name, JToken type, JToken init);
    public void Hide(String[] names);
    public string TokenOrNullForName(string name);
    public bool IsInput(string name);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.IBindableCanSavePfa {
    public abstract virtual void SaveAsPfa(BoundPfaContext ctx, RoleMappedSchema schema, String[] outputNames);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.ICanSavePfa {
    public bool CanSavePfa { get; }
    public abstract virtual bool get_CanSavePfa();
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.IDistCanSavePfa {
    public abstract virtual void SaveAsPfa(BoundPfaContext ctx, JToken input, string score, JToken& scoreToken, string prob, JToken& probToken);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.ISaveAsPfa {
    public abstract virtual void SaveAsPfa(BoundPfaContext ctx);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.ISingleCanSavePfa {
    public abstract virtual JToken SaveAsPfa(BoundPfaContext ctx, JToken input);
}
[BestFriendAttribute]
internal interface Microsoft.ML.Model.Pfa.ITransformCanSavePfa {
}
[BestFriendAttribute]
internal class Microsoft.ML.Model.Pfa.PfaContext : object {
    [CompilerGeneratedAttribute]
private JToken <InputType>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <OutputType>k__BackingField;
    [CompilerGeneratedAttribute]
private JToken <Final>k__BackingField;
    private HashSet`1<string> _variables;
    private List`1<CellBlock> _cellBlocks;
    private List`1<VariableBlock> _letSetBlocks;
    private List`1<FuncBlock> _funcBlocks;
    private HashSet`1<string> _types;
    private IHost _host;
    public JToken InputType { get; public set; }
    public JToken OutputType { get; public set; }
    public JToken Final { get; public set; }
    public PfaContext(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public JToken get_InputType();
    [CompilerGeneratedAttribute]
public void set_InputType(JToken value);
    [CompilerGeneratedAttribute]
public JToken get_OutputType();
    [CompilerGeneratedAttribute]
public void set_OutputType(JToken value);
    [CompilerGeneratedAttribute]
public JToken get_Final();
    [CompilerGeneratedAttribute]
public void set_Final(JToken value);
    public JObject Finalize();
    public KeyValuePair`2<string, JToken> CreatePair(string varName, string token);
    public void AddVariables(KeyValuePair`2[] locals);
    public void AddCell(string name, JToken type, JToken init);
    public void AddFunc(string name, JArray prms, JToken returnType, JToken doBlock);
    public static JObject CreateFuncBlock(JArray prms, JToken returnType, JToken doBlock);
    public bool ContainsCell(string name);
    public bool ContainsVar(string name);
    public bool ContainsFunc(string name);
    public bool ContainsType(string name);
    public bool RegisterType(string name);
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Model.Pfa.PfaUtils : object {
    [ExtensionAttribute]
public static JObject AddReturn(JObject toEdit, string name, JToken value);
    public static JObject Call(string func, JToken[] prms);
    public static JObject FuncRef(string func);
    public static JObject Param(string name, JToken type);
    public static JObject Index(JToken arrayOrMap, JToken key);
    public static JObject String(string str);
    public static JObject For(JObject initBlock, JObject whileBlock, JObject stepBlock, JObject doBlock);
    public static JObject If(JToken condition, JToken thenBlock, JToken elseBlock);
    public static JObject VectorCase(JToken itemType, JToken src, string asMapName, JToken mapDo, string asArrName, JToken arrDo);
    public static JObject Cell(string name);
    [ExtensionAttribute]
public static string EnsureCount(PfaContext ctx, JToken itemType);
    [ExtensionAttribute]
public static string EnsureHasChars(PfaContext ctx);
    [ExtensionAttribute]
public static string EnsureNewArray(PfaContext ctx);
    [ExtensionAttribute]
public static string EnsureAdd(PfaContext ctx, JToken itemType);
    [ExtensionAttribute]
public static string EnsureSub(PfaContext ctx, JToken itemType);
    [ExtensionAttribute]
public static string EnsureMul(PfaContext ctx, JToken itemType);
    [ExtensionAttribute]
public static string EnsureDiv(PfaContext ctx, JToken itemType);
    private static string EnsureOpCore(PfaContext ctx, string funcPrefix, string binOp, JToken itemType, JToken returnType);
}
internal class Microsoft.ML.Model.Pfa.SavePfaCommand : ImplBase`1<Arguments> {
    public static string Summary;
    public static string LoadName;
    private string _outputModelPath;
    private string _name;
    private bool _allowSet;
    private bool _keepInput;
    private Nullable`1<bool> _loadPredictor;
    private HashSet`1<string> _inputsToDrop;
    private HashSet`1<string> _outputsToDrop;
    private Formatting _formatting;
    public SavePfaCommand(IHostEnvironment env, Arguments args);
    private static HashSet`1<string> CreateDropMap(string toDrop);
    public virtual void Run();
    private void GetPipe(IChannel ch, IDataView end, IDataView& source, IDataView& trueEnd, LinkedList`1& transforms);
    private void Run(IChannel ch);
}
[BestFriendAttribute]
internal class Microsoft.ML.Model.SignatureFeatureScorerTrainer : MulticastDelegate {
    public SignatureFeatureScorerTrainer(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.ModelOperationsCatalog : object {
    internal static string SchemaEntryName;
    private IHostEnvironment _env;
    private IHostEnvironment Microsoft.ML.Data.IInternalCatalog.Environment { get; }
    internal ModelOperationsCatalog(IHostEnvironment env);
    private sealed virtual override IHostEnvironment Microsoft.ML.Data.IInternalCatalog.get_Environment();
    public void Save(ITransformer model, IDataLoader`1<TSource> loader, Stream stream);
    public void Save(ITransformer model, IDataLoader`1<TSource> loader, string filePath);
    public void Save(ITransformer model, DataViewSchema inputSchema, Stream stream);
    public void Save(ITransformer model, DataViewSchema inputSchema, string filePath);
    private void SaveInputSchema(DataViewSchema inputSchema, RepositoryWriter rep);
    public ITransformer Load(Stream stream, DataViewSchema& inputSchema);
    public ITransformer Load(string filePath, DataViewSchema& inputSchema);
    private ITransformer DecomposeLoader(IDataLoader`1& loader);
    public ITransformer LoadWithDataLoader(Stream stream, IDataLoader`1& loader);
    public ITransformer LoadWithDataLoader(string filePath, IDataLoader`1& loader);
    public PredictionEngine`2<TSrc, TDst> CreatePredictionEngine(ITransformer transformer, bool ignoreMissingColumns, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition);
    public PredictionEngine`2<TSrc, TDst> CreatePredictionEngine(ITransformer transformer, DataViewSchema inputSchema);
    public PredictionEngine`2<TSrc, TDst> CreatePredictionEngine(ITransformer transformer, PredictionEngineOptions options);
}
public class Microsoft.ML.MulticlassClassificationCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private MulticlassClassificationTrainers <Trainers>k__BackingField;
    public MulticlassClassificationTrainers Trainers { get; }
    internal MulticlassClassificationCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public MulticlassClassificationTrainers get_Trainers();
    public MulticlassClassificationMetrics Evaluate(IDataView data, string labelColumnName, string scoreColumnName, string predictedLabelColumnName, int topKPredictionCount);
    public IReadOnlyList`1<CrossValidationResult`1<MulticlassClassificationMetrics>> CrossValidate(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string samplingKeyColumnName, Nullable`1<int> seed);
}
internal class Microsoft.ML.Numeric.GenericSpanSortHelper`1 : object {
    public static void Sort(Span`1<TKey> keys, Span`1<TValue> values, int index, int length);
    public static void Sort(Span`1<TKey> keys, int index, int length);
    private static void SwapIfGreaterWithItems(Span`1<TKey> keys, Span`1<TValue> values, int a, int b);
    private static void Swap(Span`1<TKey> keys, Span`1<TValue> values, int i, int j);
    internal static void IntrospectiveSort(Span`1<TKey> keys, Span`1<TValue> values, int left, int length);
    private static void IntroSort(Span`1<TKey> keys, Span`1<TValue> values, int lo, int hi, int depthLimit);
    private static int PickPivotAndPartition(Span`1<TKey> keys, Span`1<TValue> values, int lo, int hi);
    private static void Heapsort(Span`1<TKey> keys, Span`1<TValue> values, int lo, int hi);
    private static void DownHeap(Span`1<TKey> keys, Span`1<TValue> values, int i, int n, int lo);
    private static void InsertionSort(Span`1<TKey> keys, Span`1<TValue> values, int lo, int hi);
}
internal static class Microsoft.ML.Numeric.IntrospectiveSortUtilities : object {
    internal static int IntrosortSizeThreshold;
    internal static int FloorLog2PlusOne(int n);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Numeric.VectorUtils : object {
    public static float NormSquared(VBuffer`1& a);
    public static float NormSquared(ReadOnlySpan`1<float> a);
    public static float Norm(VBuffer`1& a);
    public static float L1Norm(VBuffer`1& a);
    public static float MaxNorm(VBuffer`1& a);
    public static float Sum(VBuffer`1& a);
    public static void ScaleBy(VBuffer`1& dst, float c);
    public static void ScaleBy(VBuffer`1& src, VBuffer`1& dst, float c);
    public static void Add(VBuffer`1& src, VBuffer`1& dst);
    public static void AddMult(VBuffer`1& src, float c, VBuffer`1& dst);
    public static void AddMult(VBuffer`1& src, float c, VBuffer`1& dst, VBuffer`1& res);
    public static void AddMultInto(VBuffer`1& a, float c, VBuffer`1& b, VBuffer`1& dst);
    public static void AddMultWithOffset(VBuffer`1& src, float c, VBuffer`1& dst, int offset);
    public static void ScaleInto(VBuffer`1& src, float c, VBuffer`1& dst);
    public static int ArgMax(VBuffer`1& src);
    public static int ArgMin(VBuffer`1& src);
    public static float DotProduct(Single[] a, Single[] b);
    public static float DotProduct(Single[] a, VBuffer`1& b);
    public static float DotProduct(VBuffer`1& a, VBuffer`1& b);
    public static void SparsifyNormalize(VBuffer`1& a, int top, int bottom, bool normalize);
    public static void MulElementWise(VBuffer`1& a, VBuffer`1& dst);
    private static float L2DistSquaredSparse(ReadOnlySpan`1<float> valuesA, ReadOnlySpan`1<int> indicesA, ReadOnlySpan`1<float> valuesB, ReadOnlySpan`1<int> indicesB);
    private static float L2DistSquaredHalfSparse(ReadOnlySpan`1<float> valuesA, ReadOnlySpan`1<float> valuesB, ReadOnlySpan`1<int> indicesB);
    private static float L2DiffSquaredDense(ReadOnlySpan`1<float> valuesA, ReadOnlySpan`1<float> valuesB, int length);
    public static float DotProductWithOffset(VBuffer`1& a, int offset, VBuffer`1& b);
    public static float DotProductWithOffset(Single[] a, int offset, VBuffer`1& b);
    private static float DotProductSparse(ReadOnlySpan`1<float> aValues, ReadOnlySpan`1<int> aIndices, int ia, int iaLim, ReadOnlySpan`1<float> bValues, ReadOnlySpan`1<int> bIndices, int ib, int ibLim);
    public static float L1Distance(VBuffer`1& a, VBuffer`1& b);
    public static float Distance(VBuffer`1& a, VBuffer`1& b);
    public static float L2DistSquared(VBuffer`1& a, VBuffer`1& b);
    public static float L2DistSquared(Single[] a, VBuffer`1& b);
    public static void Add(Single[] src, Single[] dst);
    public static void AddMult(VBuffer`1& src, Span`1<float> dst, float c);
    public static void AddMultWithOffset(VBuffer`1& src, Single[] dst, int offset, float c);
    public static void AddMult(Single[] src, Single[] dst, float c);
    public static float Norm(Single[] a);
    public static float Sum(Single[] a);
    public static void ScaleBy(Single[] dst, float c);
    public static float Distance(Single[] a, Single[] b);
}
internal class Microsoft.ML.Peek`2 : MulticastDelegate {
    public Peek`2(object object, IntPtr method);
    public virtual void Invoke(TRow row, long position, TValue& value);
    public virtual IAsyncResult BeginInvoke(TRow row, long position, TValue& value, AsyncCallback callback, object object);
    public virtual void EndInvoke(TValue& value, IAsyncResult result);
}
internal class Microsoft.ML.PipeEngine`1 : object {
    private ICursorable`1<TDst> _cursorablePipe;
    internal PipeEngine`1(IHostEnvironment env, IDataView pipe, bool ignoreMissingColumns, SchemaDefinition schemaDefinition);
    [IteratorStateMachineAttribute("Microsoft.ML.PipeEngine`1/<RunPipe>d__2")]
public IEnumerable`1<TDst> RunPipe(bool reuseRowObject);
}
internal class Microsoft.ML.Poke`2 : MulticastDelegate {
    public Poke`2(object object, IntPtr method);
    public virtual void Invoke(TRow dst, TValue src);
    public virtual IAsyncResult BeginInvoke(TRow dst, TValue src, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.PredictionEngine`2 : PredictionEngineBase`2<TSrc, TDst> {
    internal PredictionEngine`2(IHostEnvironment env, ITransformer transformer, bool ignoreMissingColumns, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition, bool ownsTransformer);
    public virtual void Predict(TSrc example, TDst& prediction);
}
public abstract class Microsoft.ML.PredictionEngineBase`2 : object {
    private InputRow`1<TSrc> _inputRow;
    private IRowReadableAs`1<TDst> _outputRow;
    private Action _disposer;
    private bool _ownsTransformer;
    private bool _disposed;
    [CompilerGeneratedAttribute]
private DataViewSchema <OutputSchema>k__BackingField;
    [CompilerGeneratedAttribute]
private ITransformer <Transformer>k__BackingField;
    public DataViewSchema OutputSchema { get; }
    [BestFriendAttribute]
private protected ITransformer Transformer { get; }
    [BestFriendAttribute]
private protected PredictionEngineBase`2(IHostEnvironment env, ITransformer transformer, bool ignoreMissingColumns, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition, bool ownsTransformer);
    [CompilerGeneratedAttribute]
public DataViewSchema get_OutputSchema();
    [CompilerGeneratedAttribute]
private protected ITransformer get_Transformer();
    [BestFriendAttribute]
private protected virtual void PredictionEngineCore(IHostEnvironment env, InputRow`1<TSrc> inputRow, IRowToRowMapper mapper, bool ignoreMissingColumns, SchemaDefinition outputSchemaDefinition, Action& disposer, IRowReadableAs`1& outputRow);
    private protected virtual Func`2<DataViewSchema, IRowToRowMapper> TransformerChecker(IExceptionContext ectx, ITransformer transformer);
    public sealed virtual void Dispose();
    public TDst Predict(TSrc example);
    [BestFriendAttribute]
private protected void ExtractValues(TSrc example);
    [BestFriendAttribute]
private protected void FillValues(TDst prediction);
    public abstract virtual void Predict(TSrc example, TDst& prediction);
}
[ExtensionAttribute]
internal static class Microsoft.ML.PredictionEngineExtensions : object {
    [ExtensionAttribute]
public static PredictionEngine`2<TSrc, TDst> CreatePredictionEngine(ITransformer transformer, IHostEnvironment env, bool ignoreMissingColumns, SchemaDefinition inputSchemaDefinition, SchemaDefinition outputSchemaDefinition, bool ownsTransformer);
}
public class Microsoft.ML.PredictionEngineOptions : object {
    [ArgumentAttribute("0")]
public bool IgnoreMissingColumns;
    [ArgumentAttribute("0")]
public SchemaDefinition InputSchemaDefinition;
    [ArgumentAttribute("0")]
public SchemaDefinition OutputSchemaDefinition;
    [ArgumentAttribute("0")]
public bool OwnsTransformer;
}
public class Microsoft.ML.RankingCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private RankingTrainers <Trainers>k__BackingField;
    public RankingTrainers Trainers { get; }
    internal RankingCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public RankingTrainers get_Trainers();
    public RankingMetrics Evaluate(IDataView data, string labelColumnName, string rowGroupColumnName, string scoreColumnName);
    public RankingMetrics Evaluate(IDataView data, RankingEvaluatorOptions options, string labelColumnName, string rowGroupColumnName, string scoreColumnName);
    public IReadOnlyList`1<CrossValidationResult`1<RankingMetrics>> CrossValidate(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string rowGroupColumnName, Nullable`1<int> seed);
}
public class Microsoft.ML.RegressionCatalog : TrainCatalogBase {
    [CompilerGeneratedAttribute]
private RegressionTrainers <Trainers>k__BackingField;
    public RegressionTrainers Trainers { get; }
    internal RegressionCatalog(IHostEnvironment env);
    [CompilerGeneratedAttribute]
public RegressionTrainers get_Trainers();
    public RegressionMetrics Evaluate(IDataView data, string labelColumnName, string scoreColumnName);
    public IReadOnlyList`1<CrossValidationResult`1<RegressionMetrics>> CrossValidate(IDataView data, IEstimator`1<ITransformer> estimator, int numberOfFolds, string labelColumnName, string samplingKeyColumnName, Nullable`1<int> seed);
}
[ExtensionAttribute]
public static class Microsoft.ML.TextLoaderSaverCatalog : object {
    [ExtensionAttribute]
public static TextLoader CreateTextLoader(DataOperationsCatalog catalog, Column[] columns, char separatorChar, bool hasHeader, IMultiStreamSource dataSample, bool allowQuoting, bool trimWhitespace, bool allowSparse);
    [ExtensionAttribute]
public static TextLoader CreateTextLoader(DataOperationsCatalog catalog, Options options, IMultiStreamSource dataSample);
    [ExtensionAttribute]
public static TextLoader CreateTextLoader(DataOperationsCatalog catalog, char separatorChar, bool hasHeader, IMultiStreamSource dataSample, bool allowQuoting, bool trimWhitespace, bool allowSparse);
    [ExtensionAttribute]
public static TextLoader CreateTextLoader(DataOperationsCatalog catalog, Options options, IMultiStreamSource dataSample);
    [ExtensionAttribute]
public static IDataView LoadFromTextFile(DataOperationsCatalog catalog, string path, Column[] columns, char separatorChar, bool hasHeader, bool allowQuoting, bool trimWhitespace, bool allowSparse);
    [ExtensionAttribute]
public static IDataView LoadFromTextFile(DataOperationsCatalog catalog, string path, Options options);
    [ExtensionAttribute]
public static IDataView LoadFromTextFile(DataOperationsCatalog catalog, string path, char separatorChar, bool hasHeader, bool allowQuoting, bool trimWhitespace, bool allowSparse);
    [ExtensionAttribute]
public static IDataView LoadFromTextFile(DataOperationsCatalog catalog, string path, Options options);
    [ExtensionAttribute]
public static void SaveAsText(DataOperationsCatalog catalog, IDataView data, Stream stream, char separatorChar, bool headerRow, bool schema, bool keepHidden, bool forceDense);
    private static void CheckValidPathContents(string path);
}
internal class Microsoft.ML.Tools.SavePredictorCommand : object {
    internal static string Summary;
    private Arguments _args;
    private IHost _host;
    public SavePredictorCommand(IHostEnvironment env, Arguments args);
    private void CheckOutputDirectories();
    public sealed virtual void Run();
    private IFileHandle CreateFile(string path);
    private Stream CreateStrm(IFileHandle file);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Tools.SavePredictorUtils : object {
    public static void SavePredictor(IHostEnvironment env, Stream modelStream, Stream binaryModelStream, Stream summaryModelStream, Stream textModelStream, Stream iniModelStream, Stream codeModelStream);
    public static void SavePredictor(IChannel ch, IPredictor predictor, RoleMappedSchema schema, Stream binaryModelStream, Stream summaryModelStream, Stream textModelStream, Stream iniModelStream, Stream codeModelStream);
    public static void LoadModel(IHostEnvironment env, Stream modelStream, bool loadNames, IPredictor& predictor, RoleMappedSchema& schema);
}
public abstract class Microsoft.ML.TrainCatalogBase : object {
    [CompilerGeneratedAttribute]
private IHostEnvironment <Environment>k__BackingField;
    private IHostEnvironment Microsoft.ML.Data.IInternalCatalog.Environment { get; }
    [BestFriendAttribute]
private protected IHostEnvironment Environment { get; }
    [BestFriendAttribute]
private protected TrainCatalogBase(IHostEnvironment env, string registrationName);
    private sealed virtual override IHostEnvironment Microsoft.ML.Data.IInternalCatalog.get_Environment();
    [CompilerGeneratedAttribute]
private protected IHostEnvironment get_Environment();
    [BestFriendAttribute]
private protected CrossValidationResult[] CrossValidateTrain(IDataView data, IEstimator`1<ITransformer> estimator, int numFolds, string samplingKeyColumn, Nullable`1<int> seed);
    private static bool IsCastableToTransformerChainOfITransformer(object o);
}
[FlagsAttribute]
[BestFriendAttribute]
internal enum Microsoft.ML.Trainers.CursOpt : Enum {
    public UInt32 value__;
    public static CursOpt Weight;
    public static CursOpt Group;
    public static CursOpt Id;
    public static CursOpt Label;
    public static CursOpt Features;
    public static CursOpt AllowBadWeights;
    public static CursOpt AllowBadGroups;
    public static CursOpt AllowBadLabels;
    public static CursOpt AllowBadFeatures;
    public static CursOpt AllowBadEverything;
    public static CursOpt AllWeights;
    public static CursOpt AllGroups;
    public static CursOpt AllLabels;
    public static CursOpt AllFeatures;
}
public class Microsoft.ML.Trainers.ExpLoss : object {
    internal static string Summary;
    private float _beta;
    internal ExpLoss(Options options);
    public ExpLoss(float beta);
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
}
public class Microsoft.ML.Trainers.FeatureContributionCalculator : object {
    [CompilerGeneratedAttribute]
private IFeatureContributionMapper <ContributionMapper>k__BackingField;
    internal IFeatureContributionMapper ContributionMapper { get; }
    internal FeatureContributionCalculator(IFeatureContributionMapper contributionMapper);
    [CompilerGeneratedAttribute]
internal IFeatureContributionMapper get_ContributionMapper();
}
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.FeatureFloatVectorCursor : StandardScalarCursor {
    private ValueGetter`1<VBuffer`1<float>> _get;
    private bool _keepBad;
    [CompilerGeneratedAttribute]
private long <BadFeaturesRowCount>k__BackingField;
    public VBuffer`1<float> Features;
    public long BadFeaturesRowCount { get; private set; }
    public FeatureFloatVectorCursor(RoleMappedData data, CursOpt opt, Random rand, Int32[] extraCols);
    protected FeatureFloatVectorCursor(DataViewRowCursor input, RoleMappedData data, CursOpt opt, Action`1<CursOpt> signal);
    [CompilerGeneratedAttribute]
public long get_BadFeaturesRowCount();
    [CompilerGeneratedAttribute]
private void set_BadFeaturesRowCount(long value);
    protected virtual CursOpt CursoringCompleteFlags();
    public virtual bool Accept();
}
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.FloatLabelCursor : FeatureFloatVectorCursor {
    private ValueGetter`1<float> _get;
    private bool _keepBad;
    [CompilerGeneratedAttribute]
private long <BadLabelCount>k__BackingField;
    public float Label;
    public long BadLabelCount { get; private set; }
    public FloatLabelCursor(RoleMappedData data, CursOpt opt, Random rand, Int32[] extraCols);
    protected FloatLabelCursor(DataViewRowCursor input, RoleMappedData data, CursOpt opt, Action`1<CursOpt> signal);
    [CompilerGeneratedAttribute]
public long get_BadLabelCount();
    [CompilerGeneratedAttribute]
private void set_BadLabelCount(long value);
    protected virtual CursOpt CursoringCompleteFlags();
    public virtual bool Accept();
}
public class Microsoft.ML.Trainers.HingeLoss : object {
    internal static string Summary;
    private static float Threshold;
    private float _margin;
    private HingeLoss(Options options);
    public HingeLoss(float margin);
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
    public sealed virtual float ComputeDualUpdateInvariant(float scaledFeaturesNormSquared);
    public sealed virtual float DualUpdate(float output, float label, float alpha, float invariant, int maxNumThreads);
    public sealed virtual double DualLoss(float label, float dual);
}
public interface Microsoft.ML.Trainers.ICalculateFeatureContribution {
    public FeatureContributionCalculator FeatureContributionCalculator { get; }
    public abstract virtual FeatureContributionCalculator get_FeatureContributionCalculator();
}
public interface Microsoft.ML.Trainers.IClassificationLoss {
}
[BestFriendAttribute]
internal interface Microsoft.ML.Trainers.IFeatureContributionMapper {
    public abstract virtual ValueMapper`2<TSrc, VBuffer`1<float>> GetFeatureContributionMapper(int top, int bottom, bool normalize);
}
public interface Microsoft.ML.Trainers.ILossFunction`2 {
    public abstract virtual double Loss(TOutput output, TLabel label);
}
public interface Microsoft.ML.Trainers.IRegressionLoss {
}
public interface Microsoft.ML.Trainers.IScalarLoss {
    public abstract virtual float Derivative(float output, float label);
}
[ComponentKindAttribute("ClassificationLossFunction")]
[BestFriendAttribute]
internal interface Microsoft.ML.Trainers.ISupportClassificationLossFactory {
}
[ComponentKindAttribute("RegressionLossFunction")]
[BestFriendAttribute]
internal interface Microsoft.ML.Trainers.ISupportRegressionLossFactory {
}
public interface Microsoft.ML.Trainers.ISupportSdcaClassificationLoss {
}
[ComponentKindAttribute("SDCAClassificationLossFunction")]
[BestFriendAttribute]
internal interface Microsoft.ML.Trainers.ISupportSdcaClassificationLossFactory {
}
public interface Microsoft.ML.Trainers.ISupportSdcaLoss {
    public abstract virtual float ComputeDualUpdateInvariant(float scaledFeaturesNormSquared);
    public abstract virtual float DualUpdate(float output, float label, float dual, float invariant, int maxNumThreads);
    public abstract virtual double DualLoss(float label, float dual);
}
public interface Microsoft.ML.Trainers.ISupportSdcaRegressionLoss {
}
[ComponentKindAttribute("SDCARegressionLossFunction")]
[BestFriendAttribute]
internal interface Microsoft.ML.Trainers.ISupportSdcaRegressionLossFactory {
    public abstract virtual ISupportSdcaRegressionLoss CreateComponent(IHostEnvironment env);
}
public interface Microsoft.ML.Trainers.ITrainerEstimator`2 {
    public TrainerInfo Info { get; }
    public abstract virtual TrainerInfo get_Info();
}
public class Microsoft.ML.Trainers.LogLoss : object {
    internal static string Summary;
    private static float Threshold;
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
    public sealed virtual float ComputeDualUpdateInvariant(float scaledFeaturesNormSquared);
    public sealed virtual float DualUpdate(float output, float label, float dual, float invariant, int maxNumThreads);
    public sealed virtual double DualLoss(float label, float dual);
    private static double Log(double x);
}
[ComponentAttribute]
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.LogLossFactory : object {
    public sealed virtual ISupportSdcaClassificationLoss CreateComponent(IHostEnvironment env);
    private sealed virtual override IClassificationLoss Microsoft.ML.Runtime.IComponentFactory<Microsoft.ML.Trainers.IClassificationLoss>.CreateComponent(IHostEnvironment env);
}
public abstract class Microsoft.ML.Trainers.ModelParametersBase`1 : object {
    private static string NormalizerWarningFormat;
    [BestFriendAttribute]
private protected IHost Host;
    private PredictionKind Microsoft.ML.IPredictor.PredictionKind { get; }
    [BestFriendAttribute]
private protected PredictionKind PredictionKind { get; }
    [BestFriendAttribute]
private protected ModelParametersBase`1(IHostEnvironment env, string name);
    [BestFriendAttribute]
private protected ModelParametersBase`1(IHostEnvironment env, string name, ModelLoadContext ctx);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    [BestFriendAttribute]
private protected virtual void Save(ModelSaveContext ctx);
    [BestFriendAttribute]
private protected virtual void SaveCore(ModelSaveContext ctx);
    private sealed virtual override PredictionKind Microsoft.ML.IPredictor.get_PredictionKind();
    private protected abstract virtual PredictionKind get_PredictionKind();
    [BestFriendAttribute]
private protected static bool WarnOnOldNormalizer(ModelLoadContext ctx, Type typePredictor, IChannelProvider provider);
}
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.MulticlassLabelCursor : FeatureFloatVectorCursor {
    private int _classCount;
    private ValueGetter`1<float> _get;
    private bool _keepBad;
    [CompilerGeneratedAttribute]
private long <BadLabelCount>k__BackingField;
    private float _raw;
    public int Label;
    public long BadLabelCount { get; private set; }
    public MulticlassLabelCursor(int classCount, RoleMappedData data, CursOpt opt, Random rand, Int32[] extraCols);
    protected MulticlassLabelCursor(int classCount, DataViewRowCursor input, RoleMappedData data, CursOpt opt, Action`1<CursOpt> signal);
    [CompilerGeneratedAttribute]
public long get_BadLabelCount();
    [CompilerGeneratedAttribute]
private void set_BadLabelCount(long value);
    protected virtual CursOpt CursoringCompleteFlags();
    public virtual bool Accept();
}
public class Microsoft.ML.Trainers.PoissonLoss : object {
    internal static string Summary;
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
}
[ComponentAttribute]
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.PoissonLossFactory : object {
    public sealed virtual IRegressionLoss CreateComponent(IHostEnvironment env);
}
internal class Microsoft.ML.Trainers.SignatureClassificationLoss : MulticastDelegate {
    public SignatureClassificationLoss(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class Microsoft.ML.Trainers.SignatureRegressionLoss : MulticastDelegate {
    public SignatureRegressionLoss(object object, IntPtr method);
    public virtual void Invoke();
    public virtual IAsyncResult BeginInvoke(AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
public class Microsoft.ML.Trainers.SmoothedHingeLoss : object {
    internal static string Summary;
    private static float Threshold;
    private float _smoothConst;
    private double _halfSmoothConst;
    private double _doubleSmoothConst;
    public SmoothedHingeLoss(float smoothingConstant);
    private SmoothedHingeLoss(IHostEnvironment env, Options options);
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
    public sealed virtual float ComputeDualUpdateInvariant(float scaledFeaturesNormSquared);
    public sealed virtual float DualUpdate(float output, float label, float alpha, float invariant, int maxNumThreads);
    public sealed virtual double DualLoss(float label, float dual);
}
public class Microsoft.ML.Trainers.SquaredLoss : object {
    internal static string Summary;
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
    public sealed virtual float ComputeDualUpdateInvariant(float scaledFeaturesNormSquared);
    public sealed virtual float DualUpdate(float output, float label, float dual, float invariant, int maxNumThreads);
    public sealed virtual double DualLoss(float label, float dual);
}
[ComponentAttribute]
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.SquaredLossFactory : object {
    public sealed virtual ISupportSdcaRegressionLoss CreateComponent(IHostEnvironment env);
    private sealed virtual override IRegressionLoss Microsoft.ML.Runtime.IComponentFactory<Microsoft.ML.Trainers.IRegressionLoss>.CreateComponent(IHostEnvironment env);
}
[BestFriendAttribute]
internal class Microsoft.ML.Trainers.StandardScalarCursor : TrainingCursorBase {
    private ValueGetter`1<float> _getWeight;
    private ValueGetter`1<ulong> _getGroup;
    private ValueGetter`1<DataViewRowId> _getId;
    private bool _keepBadWeight;
    private bool _keepBadGroup;
    [CompilerGeneratedAttribute]
private long <BadWeightCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <BadGroupCount>k__BackingField;
    public float Weight;
    public ulong Group;
    public DataViewRowId Id;
    public long BadWeightCount { get; private set; }
    public long BadGroupCount { get; private set; }
    public StandardScalarCursor(RoleMappedData data, CursOpt opt, Random rand, Int32[] extraCols);
    protected StandardScalarCursor(DataViewRowCursor input, RoleMappedData data, CursOpt opt, Action`1<CursOpt> signal);
    [CompilerGeneratedAttribute]
public long get_BadWeightCount();
    [CompilerGeneratedAttribute]
private void set_BadWeightCount(long value);
    [CompilerGeneratedAttribute]
public long get_BadGroupCount();
    [CompilerGeneratedAttribute]
private void set_BadGroupCount(long value);
    protected virtual CursOpt CursoringCompleteFlags();
    public virtual bool Accept();
}
public abstract class Microsoft.ML.Trainers.TrainerEstimatorBase`2 : object {
    [BestFriendAttribute]
private protected static string NoTrainingInstancesMessage;
    public Column FeatureColumn;
    public Column LabelColumn;
    public Column WeightColumn;
    [BestFriendAttribute]
private protected IHost Host;
    public TrainerInfo Info { get; }
    private PredictionKind Microsoft.ML.ITrainer.PredictionKind { get; }
    [BestFriendAttribute]
private protected PredictionKind PredictionKind { get; }
    [BestFriendAttribute]
private protected TrainerEstimatorBase`2(IHost host, Column feature, Column label, Column weight);
    public abstract virtual TrainerInfo get_Info();
    private sealed virtual override PredictionKind Microsoft.ML.ITrainer.get_PredictionKind();
    private protected abstract virtual PredictionKind get_PredictionKind();
    public sealed virtual TTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    private protected abstract virtual Column[] GetOutputColumnsCore(SchemaShape inputSchema);
    private sealed virtual override IPredictor Microsoft.ML.ITrainer<Microsoft.ML.IPredictor>.Train(TrainContext context);
    private void CheckInputSchema(SchemaShape inputSchema);
    private protected virtual void CheckLabelCompatible(Column labelCol);
    [BestFriendAttribute]
private protected TTransformer TrainTransformer(IDataView trainSet, IDataView validationSet, IPredictor initPredictor);
    private protected abstract virtual TModel TrainModelCore(TrainContext trainContext);
    private protected abstract virtual TTransformer MakeTransformer(TModel model, DataViewSchema trainSchema);
    private protected virtual RoleMappedData MakeRoles(IDataView data);
    private sealed virtual override IPredictor Microsoft.ML.ITrainer.Train(TrainContext context);
}
public abstract class Microsoft.ML.Trainers.TrainerEstimatorBaseWithGroupId`2 : TrainerEstimatorBase`2<TTransformer, TModel> {
    public Column GroupIdColumn;
    [BestFriendAttribute]
private protected TrainerEstimatorBaseWithGroupId`2(IHost host, Column feature, Column label, Column weight, Column groupId);
    private protected virtual RoleMappedData MakeRoles(IDataView data);
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Trainers.TrainerInputBase : object {
    [BestFriendAttribute]
[ArgumentAttribute("1")]
internal IDataView TrainingData;
    [ArgumentAttribute("0")]
public string FeatureColumnName;
    [BestFriendAttribute]
[ArgumentAttribute("0")]
internal NormalizeOption NormalizeFeatures;
    [BestFriendAttribute]
[ArgumentAttribute("4")]
internal CachingOptions Caching;
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Trainers.TrainerInputBaseWithGroupId : TrainerInputBaseWithWeight {
    [ArgumentAttribute("0")]
public string RowGroupColumnName;
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Trainers.TrainerInputBaseWithLabel : TrainerInputBase {
    [ArgumentAttribute("0")]
public string LabelColumnName;
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Trainers.TrainerInputBaseWithWeight : TrainerInputBaseWithLabel {
    [ArgumentAttribute("0")]
public string ExampleWeightColumnName;
}
[ExtensionAttribute]
[BestFriendAttribute]
internal static class Microsoft.ML.Trainers.TrainerUtils : object {
    [ExtensionAttribute]
public static void CheckFeatureFloatVector(RoleMappedData data);
    [ExtensionAttribute]
public static void CheckFeatureFloatVector(RoleMappedData data, Int32& length);
    [ExtensionAttribute]
public static void CheckBinaryLabel(RoleMappedData data);
    [ExtensionAttribute]
public static void CheckRegressionLabel(RoleMappedData data);
    [ExtensionAttribute]
public static void CheckMulticlassLabel(RoleMappedData data, Int32& count);
    [ExtensionAttribute]
public static void CheckMultiOutputRegressionLabel(RoleMappedData data);
    [ExtensionAttribute]
public static void CheckOptFloatWeight(RoleMappedData data);
    [ExtensionAttribute]
public static void CheckOptGroup(RoleMappedData data);
    private static IEnumerable`1<Column> CreatePredicate(RoleMappedData data, CursOpt opt, IEnumerable`1<int> extraCols);
    [ExtensionAttribute]
public static DataViewRowCursor CreateRowCursor(RoleMappedData data, CursOpt opt, Random rand, IEnumerable`1<int> extraCols);
    [ExtensionAttribute]
public static DataViewRowCursor[] CreateRowCursorSet(RoleMappedData data, CursOpt opt, int n, Random rand, IEnumerable`1<int> extraCols);
    [ExtensionAttribute]
public static ValueGetter`1<VBuffer`1<float>> GetFeatureFloatVectorGetter(DataViewRow row, RoleMappedSchema schema);
    [ExtensionAttribute]
public static ValueGetter`1<VBuffer`1<float>> GetFeatureFloatVectorGetter(DataViewRow row, RoleMappedData data);
    [ExtensionAttribute]
public static ValueGetter`1<float> GetLabelFloatGetter(DataViewRow row, RoleMappedSchema schema);
    [ExtensionAttribute]
public static ValueGetter`1<float> GetLabelFloatGetter(DataViewRow row, RoleMappedData data);
    [ExtensionAttribute]
public static ValueGetter`1<float> GetOptWeightFloatGetter(DataViewRow row, RoleMappedSchema schema);
    [ExtensionAttribute]
public static ValueGetter`1<float> GetOptWeightFloatGetter(DataViewRow row, RoleMappedData data);
    [ExtensionAttribute]
public static ValueGetter`1<ulong> GetOptGroupGetter(DataViewRow row, RoleMappedSchema schema);
    [ExtensionAttribute]
public static ValueGetter`1<ulong> GetOptGroupGetter(DataViewRow row, RoleMappedData data);
    public static Column MakeBoolScalarLabel(string labelColumn);
    public static Column MakeR4ScalarColumn(string columnName);
    public static Column MakeU4ScalarColumn(string columnName);
    public static Column MakeR4VecFeature(string featureColumn);
    public static Column MakeR4ScalarWeightColumn(string weightColumn);
    public static ITrainer`1<TPredictor> MapTrainerEstimatorToTrainer(IHostEnvironment env, T trainer);
}
[BestFriendAttribute]
internal abstract class Microsoft.ML.Trainers.TrainingCursorBase : object {
    private DataViewRowCursor _cursor;
    private Action`1<CursOpt> _signal;
    [CompilerGeneratedAttribute]
private long <SkippedRowCount>k__BackingField;
    [CompilerGeneratedAttribute]
private long <KeptRowCount>k__BackingField;
    public DataViewRow Row { get; }
    public long SkippedRowCount { get; private set; }
    public long KeptRowCount { get; private set; }
    protected TrainingCursorBase(DataViewRowCursor input, Action`1<CursOpt> signal);
    public DataViewRow get_Row();
    [CompilerGeneratedAttribute]
public long get_SkippedRowCount();
    [CompilerGeneratedAttribute]
private void set_SkippedRowCount(long value);
    [CompilerGeneratedAttribute]
public long get_KeptRowCount();
    [CompilerGeneratedAttribute]
private void set_KeptRowCount(long value);
    protected static DataViewRowCursor CreateCursor(RoleMappedData data, CursOpt opt, Random rand, Int32[] extraCols);
    protected virtual CursOpt CursoringCompleteFlags();
    public bool MoveNext();
    public virtual bool Accept();
    public sealed virtual void Dispose();
}
public class Microsoft.ML.Trainers.TweedieLoss : object {
    internal static string Summary;
    private double _index;
    private double _index1;
    private double _index2;
    private TweedieLoss(Options options);
    public TweedieLoss(double index);
    private static void Clamp(Single& val);
    public sealed virtual double Loss(float output, float label);
    public sealed virtual float Derivative(float output, float label);
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Trainers.UnsupervisedTrainerInputBaseWithWeight : TrainerInputBase {
    [ArgumentAttribute("0")]
public string ExampleWeightColumnName;
}
[ExtensionAttribute]
public static class Microsoft.ML.TransformExtensionsCatalog : object {
    [ExtensionAttribute]
public static ColumnCopyingEstimator CopyColumns(TransformsCatalog catalog, string outputColumnName, string inputColumnName);
    [ExtensionAttribute]
[BestFriendAttribute]
internal static ColumnCopyingEstimator CopyColumns(TransformsCatalog catalog, InputOutputColumnPair[] columns);
    [ExtensionAttribute]
public static ColumnConcatenatingEstimator Concatenate(TransformsCatalog catalog, string outputColumnName, String[] inputColumnNames);
    [ExtensionAttribute]
public static ColumnSelectingEstimator DropColumns(TransformsCatalog catalog, String[] columnNames);
    [ExtensionAttribute]
public static ColumnSelectingEstimator SelectColumns(TransformsCatalog catalog, String[] columnNames, bool keepHidden);
    [ExtensionAttribute]
public static ColumnSelectingEstimator SelectColumns(TransformsCatalog catalog, String[] columnNames);
}
internal static class Microsoft.ML.Transforms.AffineNormSerializationUtils : object {
    public static string LoaderSignature;
    private static VersionInfo GetVersionInfo();
    public static void SaveModel(ModelSaveContext ctx, int numFeatures, Int32[] indices, Double[] scales, Double[] offsets, bool saveText);
    public static void LoadModel(ModelLoadContext ctx, List`1& indicesShift, Int32& numFeatures, Double[]& scales, Double[]& offsets, Int32[]& indicesMorph, Double[]& scalesSparse, Double[]& offsetsSparse);
    public static void SaveModel(ModelSaveContext ctx, int numFeatures, Int32[] indices, Single[] scales, Single[] offsets, bool saveText);
    public static void LoadModel(ModelLoadContext ctx, List`1& indicesShift, Int32& numFeatures, Single[]& scales, Single[]& offsets, Int32[]& indicesMorph, Single[]& scalesSparse, Single[]& offsetsSparse);
}
internal static class Microsoft.ML.Transforms.BinNormSerializationUtils : object {
    public static string LoaderSignature;
    private static VersionInfo GetVersionInfo();
    public static void SaveModel(ModelSaveContext ctx, Double[][] binUpperBounds, bool saveText);
    public static void LoadModel(ModelLoadContext ctx, Double[][]& binUpperBounds);
    public static void SaveModel(ModelSaveContext ctx, Single[][] binUpperBounds, bool saveText);
    public static void LoadModel(ModelLoadContext ctx, Single[][]& binUpperBounds);
}
internal static class Microsoft.ML.Transforms.BootstrapSample : object {
    [EntryPointAttribute]
public static TransformOutput GetSample(IHostEnvironment env, Options input);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.BootstrapSamplingTransformer : FilterBase {
    internal static string Summary;
    internal static string UserName;
    public static string LoaderSignature;
    internal static string RegistrationName;
    private bool _complement;
    private State _state;
    private bool _shuffleInput;
    private int _poolSize;
    public bool CanShuffle { get; }
    public BootstrapSamplingTransformer(IHostEnvironment env, Options options, IDataView input);
    public BootstrapSamplingTransformer(IHostEnvironment env, IDataView input, bool complement, Nullable`1<UInt32> seed, bool shuffleInput, int poolSize);
    private BootstrapSamplingTransformer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public virtual bool get_CanShuffle();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public static BootstrapSamplingTransformer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
internal static class Microsoft.ML.Transforms.CdfNormSerializationUtils : object {
    public static void SaveModel(ModelSaveContext ctx, bool useLog, Double[] mean, Double[] stddev);
    public static void LoadModel(ModelLoadContext ctx, int cv, Boolean& useLog, Double[]& mean, Double[]& stddev);
    public static void SaveModel(ModelSaveContext ctx, bool useLog, Single[] mean, Single[] stddev);
    public static void LoadModel(ModelLoadContext ctx, int cv, Boolean& useLog, Single[]& mean, Single[]& stddev);
}
public class Microsoft.ML.Transforms.ColumnConcatenatingEstimator : object {
    private IHost _host;
    private string _name;
    private String[] _source;
    internal ColumnConcatenatingEstimator(IHostEnvironment env, string outputColumnName, String[] inputColumnNames);
    public sealed virtual ColumnConcatenatingTransformer Fit(IDataView input);
    private bool HasCategoricals(Column col);
    private Column CheckInputsAndMakeColumn(SchemaShape inputSchema, string name, String[] sources);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ColumnCopyingEstimator : TrivialEstimator`1<ColumnCopyingTransformer> {
    [BestFriendAttribute]
internal ColumnCopyingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName);
    [BestFriendAttribute]
internal ColumnCopyingEstimator(IHostEnvironment env, ValueTuple`2[] columns);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ColumnCopyingTransformer : OneToOneTransformerBase {
    [BestFriendAttribute]
internal static string LoaderSignature;
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal ColumnCopyingTransformer(IHostEnvironment env, ValueTuple`2[] columns);
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private static VersionInfo GetVersionInfo();
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static ColumnCopyingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema inputSchema);
}
public class Microsoft.ML.Transforms.ColumnSelectingEstimator : TrivialEstimator`1<ColumnSelectingTransformer> {
    private Func`2<string, bool> _selectPredicate;
    private ColumnSelectingEstimator(IHostEnvironment env, String[] keepColumns);
    internal ColumnSelectingEstimator(IHostEnvironment env, String[] keepColumns, String[] dropColumns, bool keepHidden, bool ignoreMissing);
    internal static ColumnSelectingEstimator KeepColumns(IHostEnvironment env, String[] columnsToKeep);
    internal static ColumnSelectingEstimator DropColumns(IHostEnvironment env, String[] columnsToDrop);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
    [CompilerGeneratedAttribute]
private bool <GetOutputSchema>b__6_1(Column c);
}
public class Microsoft.ML.Transforms.ColumnSelectingTransformer : object {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    internal static string LoaderSignature;
    internal static string DropLoaderSignature;
    internal static string ChooseLoaderSignature;
    internal static string ChooseLoaderSignatureOld;
    private IHost _host;
    private String[] _selectedColumns;
    [CompilerGeneratedAttribute]
private bool <KeepColumns>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepHidden>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreMissing>k__BackingField;
    private bool Microsoft.ML.ITransformer.IsRowToRowMapper { get; }
    internal IEnumerable`1<string> SelectColumns { get; }
    internal bool KeepColumns { get; }
    internal bool KeepHidden { get; }
    internal bool IgnoreMissing { get; }
    internal ColumnSelectingTransformer(IHostEnvironment env, String[] keepColumns, String[] dropColumns, bool keepHidden, bool ignoreMissing);
    private sealed virtual override bool Microsoft.ML.ITransformer.get_IsRowToRowMapper();
    internal IEnumerable`1<string> get_SelectColumns();
    [CompilerGeneratedAttribute]
internal bool get_KeepColumns();
    [CompilerGeneratedAttribute]
internal bool get_KeepHidden();
    [CompilerGeneratedAttribute]
internal bool get_IgnoreMissing();
    private static VersionInfo GetVersionInfo();
    private static VersionInfo GetDropVersionInfo();
    private static VersionInfo GetChooseVersionInfo();
    private static bool CheckModelVersion(ModelLoadContext ctx, VersionInfo versionInfo);
    private static ColumnSelectingTransformer LoadDropColumnsTransform(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static bool GetHiddenOption(IHostEnvironment env, HiddenColumnOption option);
    private static ColumnSelectingTransformer LoadChooseColumnsTransform(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static ColumnSelectingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataView Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    [BestFriendAttribute]
internal static IDataView CreateKeep(IHostEnvironment env, IDataView input, String[] keepColumns, bool keepHidden);
    [BestFriendAttribute]
internal static IDataView CreateDrop(IHostEnvironment env, IDataView input, String[] dropColumns);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private sealed virtual override void Microsoft.ML.ICanSaveModel.Save(ModelSaveContext ctx);
    internal void SaveModel(ModelSaveContext ctx);
    internal static bool IsSchemaValid(IEnumerable`1<string> inputColumns, IEnumerable`1<string> selectColumns, IEnumerable`1& invalidColumns);
    public sealed virtual DataViewSchema GetOutputSchema(DataViewSchema inputSchema);
    private sealed virtual override IRowToRowMapper Microsoft.ML.ITransformer.GetRowToRowMapper(DataViewSchema inputSchema);
    public sealed virtual IDataView Transform(IDataView input);
}
internal class Microsoft.ML.Transforms.DataViewHelper : object {
    internal static PrimitiveDataViewType GetPrimitiveType(Type rawType, Boolean& isVectorType);
    private static ValueGetter`1<VBuffer`1<ReadOnlyMemory`1<char>>> GetKeyValueGetter(TKey[] keys);
    internal static void AddColumnWrapper(ArrayDataViewBuilder builder, string columnName, PrimitiveDataViewType primitiveType, T[] values);
    internal static void AddColumnWrapper(ArrayDataViewBuilder builder, string columnName, PrimitiveDataViewType primitiveType, T[][] values);
    internal static IDataView CreateDataView(IHostEnvironment env, IEnumerable`1<TKey> keys, IEnumerable`1<TValue[]> values, string keyColumnName, string valueColumnName);
    internal static IDataView CreateDataView(IHostEnvironment env, IEnumerable`1<TKey> keys, IEnumerable`1<TValue> values, string keyColumnName, string valueColumnName, bool treatValuesAsKeyTypes);
}
public class Microsoft.ML.Transforms.FeatureContributionCalculatingEstimator : TrivialEstimator`1<FeatureContributionCalculatingTransformer> {
    private string _featureColumn;
    private ICalculateFeatureContribution _predictor;
    internal FeatureContributionCalculatingEstimator(IHostEnvironment env, ICalculateFeatureContribution model, int numberOfPositiveContributions, int numberOfNegativeContributions, string featureColumnName, bool normalize);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.FeatureContributionCalculatingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string FriendlyName;
    internal static string LoaderSignature;
    internal int Top;
    internal int Bottom;
    internal bool Normalize;
    private IFeatureContributionMapper _predictor;
    internal FeatureContributionCalculatingTransformer(IHostEnvironment env, ICalculateFeatureContribution modelParameters, string featureColumnName, int numberOfPositiveContributions, int numberOfNegativeContributions, bool normalize);
    private FeatureContributionCalculatingTransformer(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    internal static FeatureContributionCalculatingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.FeatureContributionEntryPoint : object {
    [EntryPointAttribute]
public static TransformOutput FeatureContributionCalculation(IHostEnvironment env, Options options);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.GenerateNumberTransform : RowToRowTransformBase {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    public static string LoadName;
    public static string LoaderSignature;
    private Bindings _bindings;
    private static string RegistrationName;
    public DataViewSchema OutputSchema { get; }
    public bool CanShuffle { get; }
    public GenerateNumberTransform(IHostEnvironment env, IDataView input, string name, Nullable`1<UInt32> seed, bool useCounter);
    public GenerateNumberTransform(IHostEnvironment env, Options options, IDataView input);
    private GenerateNumberTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static GenerateNumberTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual DataViewSchema get_OutputSchema();
    public virtual bool get_CanShuffle();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
public class Microsoft.ML.Transforms.HashingEstimator : object {
    internal static int NumBitsMin;
    [BestFriendAttribute]
internal static int NumBitsLim;
    private IHost _host;
    private ColumnOptions[] _columns;
    internal static string ExpectedColumnType;
    internal HashingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int numberOfBits, int maximumNumberOfInverts, bool useOrderedHashing, bool combine);
    [BestFriendAttribute]
internal HashingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal static bool IsColumnTypeValid(DataViewType type);
    public sealed virtual HashingTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.HashingTransformer : OneToOneTransformerBase {
    private static string RegistrationName;
    internal static string Summary;
    internal static string LoaderSignature;
    private ColumnOptions[] _columns;
    private VBuffer`1[] _keyValues;
    private VectorDataViewType[] _kvTypes;
    private bool _nonOnnxExportableVersion;
    [BestFriendAttribute]
internal IReadOnlyCollection`1<ColumnOptions> Columns { get; }
    internal HashingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    internal HashingTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    private HashingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ColumnOptions> get_Columns();
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private DataViewType GetOutputType(DataViewSchema inputSchema, ColumnOptions column);
    private Delegate GetGetterCore(DataViewRow input, int iinfo, Action& disposer);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private static HashingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private ValueGetter`1<UInt32> ComposeGetterOne(DataViewRow input, int iinfo, int srcCol, DataViewType srcType);
    private ValueGetter`1<VBuffer`1<UInt32>> ComposeGetterVec(DataViewRow input, int iinfo, int srcCol, VectorDataViewType srcType);
    private ValueGetter`1<VBuffer`1<UInt32>> ComposeGetterVecCore(DataViewRow input, int iinfo, int srcCol, VectorDataViewType srcType);
    private ValueGetter`1<UInt32> ComposeGetterCombined(DataViewRow input, int iinfo, int srcCol, VectorDataViewType srcType);
    private static ValueGetter`1<UInt32> MakeScalarHashGetter(DataViewRow input, int srcCol, UInt32 seed, UInt32 mask, bool useOldHashing);
    private static ValueGetter`1<VBuffer`1<UInt32>> MakeVectorHashGetter(UInt32 seed, UInt32 mask, ValueGetter`1<VBuffer`1<T>> srcGetter, bool useOldHashing);
    private static ValueGetter`1<VBuffer`1<UInt32>> MakeVectorOrderedHashGetter(UInt32 seed, UInt32 mask, ValueGetter`1<VBuffer`1<T>> srcGetter, bool useOldHashing);
    private static ValueGetter`1<UInt32> MakeCombinedVectorHashGetter(DataViewRow input, int srcCol, UInt32 seed, UInt32 mask);
}
public class Microsoft.ML.Transforms.KeyToValueMappingEstimator : TrivialEstimator`1<KeyToValueMappingTransformer> {
    internal KeyToValueMappingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName);
    internal KeyToValueMappingEstimator(IHostEnvironment env, ValueTuple`2[] columns);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.KeyToValueMappingTransformer : OneToOneTransformerBase {
    internal static string LoaderSignature;
    [BestFriendAttribute]
internal static string UserName;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal IReadOnlyCollection`1<ValueTuple`2<string, string>> Columns { get; }
    internal KeyToValueMappingTransformer(IHostEnvironment env, string outputColumnName, string inputColumnName);
    internal KeyToValueMappingTransformer(IHostEnvironment env, ValueTuple`2[] columns);
    private KeyToValueMappingTransformer(IHost host, ModelLoadContext ctx);
    internal IReadOnlyCollection`1<ValueTuple`2<string, string>> get_Columns();
    private static VersionInfo GetVersionInfo();
    [BestFriendAttribute]
internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static KeyToValueMappingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema inputSchema);
}
public class Microsoft.ML.Transforms.KeyToVectorMappingEstimator : TrivialEstimator`1<KeyToVectorMappingTransformer> {
    internal KeyToVectorMappingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    internal KeyToVectorMappingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, bool outputCountVector);
    private KeyToVectorMappingEstimator(IHostEnvironment env, KeyToVectorMappingTransformer transformer);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.KeyToVectorMappingTransformer : OneToOneTransformerBase {
    private static string RegistrationName;
    private ColumnOptions[] _columns;
    internal static string LoaderSignature;
    internal static string UserName;
    internal static string Summary;
    internal IReadOnlyCollection`1<ColumnOptions> Columns { get; }
    internal KeyToVectorMappingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private KeyToVectorMappingTransformer(IHost host, ModelLoadContext ctx);
    internal IReadOnlyCollection`1<ColumnOptions> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private string TestIsKey(DataViewType type);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    private static VersionInfo GetVersionInfo();
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static KeyToVectorMappingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.LabelConvertTransform : OneToOneTransformBase {
    internal static string Summary;
    public static string LoaderSignature;
    private static string RegistrationName;
    private VectorDataViewType _slotType;
    public LabelConvertTransform(IHostEnvironment env, IDataView input, string outputColumnName, string inputColumnName);
    public LabelConvertTransform(IHostEnvironment env, Arguments args, IDataView input);
    private LabelConvertTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static LabelConvertTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    protected virtual DataViewType GetColumnTypeCore(int iinfo);
    private void SetMetadata();
    private bool PassThrough(string kind, int iinfo);
    protected virtual Delegate GetGetterCore(IChannel ch, DataViewRow input, int iinfo, Action& disposer);
    protected virtual VectorDataViewType GetSlotTypeCore(int iinfo);
    [BestFriendAttribute]
internal virtual SlotCursor GetSlotCursorCore(int iinfo);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.LabelIndicatorTransform : OneToOneTransformBase {
    internal static string Summary;
    internal static string UserName;
    public static string LoaderSignature;
    public static string LoadName;
    private Int32[] _classIndex;
    public LabelIndicatorTransform(IHostEnvironment env, IDataView input, int classIndex, string name, string source);
    internal LabelIndicatorTransform(IHostEnvironment env, Options options, IDataView input);
    private LabelIndicatorTransform(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static LabelIndicatorTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    public static LabelIndicatorTransform Create(IHostEnvironment env, Options options, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static string TestIsMulticlassLabel(DataViewType type);
    protected virtual DataViewType GetColumnTypeCore(int iinfo);
    protected virtual Delegate GetGetterCore(IChannel ch, DataViewRow input, int iinfo, Action& disposer);
    private ValueGetter`1<bool> GetGetter(IChannel ch, DataViewRow input, int iinfo);
    [EntryPointAttribute]
public static TransformOutput LabelIndicator(IHostEnvironment env, Options input);
}
internal class Microsoft.ML.Transforms.MeanVarDblAggregator : object {
    private bool _useLog;
    private Double[] _mean;
    private Double[] _m2;
    private Int64[] _cnan;
    private Int64[] _cnz;
    private long _trainCount;
    public Int64[] Counts { get; }
    public Double[] Mean { get; }
    public Double[] StdDev { get; }
    public Double[] MeanSquareError { get; }
    public Double[] M2 { get; }
    public MeanVarDblAggregator(int size, bool useLog);
    public Int64[] get_Counts();
    public Double[] get_Mean();
    public Double[] get_StdDev();
    public Double[] get_MeanSquareError();
    public Double[] get_M2();
    public void ProcessValue(VBuffer`1& value);
    public void Finish();
    private void Update(int j, double origVal);
    [CompilerGeneratedAttribute]
private double <get_StdDev>b__12_0(double m2, int i);
    [CompilerGeneratedAttribute]
private double <get_MeanSquareError>b__14_0(double m2, int i);
}
internal class Microsoft.ML.Transforms.MeanVarSngAggregator : object {
    private bool _useLog;
    private Double[] _mean;
    private Double[] _m2;
    private Int64[] _cnan;
    private Int64[] _cnz;
    private long _trainCount;
    public Int64[] Counts { get; }
    public Double[] Mean { get; }
    public Double[] StdDev { get; }
    public Double[] MeanSquareError { get; }
    public Double[] M2 { get; }
    public MeanVarSngAggregator(int size, bool useLog);
    public Int64[] get_Counts();
    public Double[] get_Mean();
    public Double[] get_StdDev();
    public Double[] get_MeanSquareError();
    public Double[] get_M2();
    public void ProcessValue(VBuffer`1& value);
    public void Finish();
    private void Update(int j, float origVal);
    [CompilerGeneratedAttribute]
private double <get_StdDev>b__12_0(double m2, int i);
    [CompilerGeneratedAttribute]
private double <get_MeanSquareError>b__14_0(double m2, int i);
}
internal static class Microsoft.ML.Transforms.MeanVarUtils : object {
    internal static void AdjustForZeros(Double& mean, Double& m2, Int64& count, long numZeros);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Transforms.MedianAggregatorUtils : object {
    [BestFriendAttribute]
internal static void GetMedianSoFar(Double& num, Double& median, MaxHeap`1& belowMedianHeap, MinHeap`1& aboveMedianHeap);
    [BestFriendAttribute]
internal static void GetMedianSoFar(Single& num, Single& median, MaxHeap`1& belowMedianHeap, MinHeap`1& aboveMedianHeap);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.MedianDblAggregator : object {
    private MaxHeap`1<double> _belowMedianHeap;
    private MinHeap`1<double> _aboveMedianHeap;
    private double _median;
    public double Median { get; }
    public MedianDblAggregator(int contatinerStartingSize);
    public double get_Median();
    public void ProcessValue(Double& value);
    public sealed virtual void Finish();
    private sealed virtual override void Microsoft.ML.Data.IColumnAggregator<System.Double>.ProcessValue(Double& modreq(System.Runtime.InteropServices.InAttribute) val);
}
internal class Microsoft.ML.Transforms.MedianSngAggregator : object {
    private MaxHeap`1<float> _belowMedianHeap;
    private MinHeap`1<float> _aboveMedianHeap;
    private float _median;
    public float Median { get; }
    public MedianSngAggregator(int contatinerStartingSize);
    public float get_Median();
    public void ProcessValue(Single& value);
    public sealed virtual void Finish();
    private sealed virtual override void Microsoft.ML.Data.IColumnAggregator<System.Single>.ProcessValue(Single& modreq(System.Runtime.InteropServices.InAttribute) val);
}
internal class Microsoft.ML.Transforms.MinMaxDblAggregator : object {
    private Double[] _min;
    private Double[] _max;
    private Int64[] _vCount;
    private long _trainCount;
    public Double[] Min { get; }
    public Double[] Max { get; }
    public Int64[] Count { get; }
    public MinMaxDblAggregator(int size);
    public Double[] get_Min();
    public Double[] get_Max();
    public Int64[] get_Count();
    public void ProcessValue(VBuffer`1& value);
    public sealed virtual void Finish();
    private void Update(int j, double val);
    private sealed virtual override void Microsoft.ML.Data.IColumnAggregator<Microsoft.ML.Data.VBuffer<System.Double>>.ProcessValue(VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) val);
}
internal class Microsoft.ML.Transforms.MinMaxSngAggregator : object {
    private Single[] _min;
    private Single[] _max;
    private Int64[] _vCount;
    private long _trainCount;
    public Single[] Min { get; }
    public Single[] Max { get; }
    public Int64[] Count { get; }
    public MinMaxSngAggregator(int size);
    public Single[] get_Min();
    public Single[] get_Max();
    public Int64[] get_Count();
    public void ProcessValue(VBuffer`1& value);
    public sealed virtual void Finish();
    private void Update(int j, float val);
    private sealed virtual override void Microsoft.ML.Data.IColumnAggregator<Microsoft.ML.Data.VBuffer<System.Single>>.ProcessValue(VBuffer`1& modreq(System.Runtime.InteropServices.InAttribute) val);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.NAFilter : FilterBase {
    public static string Summary;
    public static string FriendlyName;
    public static string ShortName;
    public static string LoaderSignature;
    private ColInfo[] _infos;
    private Dictionary`2<int, int> _srcIndexToInfoIndex;
    private bool _complement;
    private static string RegistrationName;
    public NAFilter(IHostEnvironment env, IDataView input, bool complement, String[] columns);
    public NAFilter(IHostEnvironment env, Arguments args, IDataView input);
    public NAFilter(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static NAFilter Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static bool TestType(DataViewType type);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private Func`2<int, bool> GetActive(Func`2<int, bool> predicate, Boolean[]& active);
}
internal class Microsoft.ML.Transforms.NormalizeTransform : object {
    internal static string MinMaxNormalizerSummary;
    internal static string MeanVarNormalizerSummary;
    internal static string LogMeanVarNormalizerSummary;
    internal static string BinNormalizerSummary;
    internal static string SupervisedBinNormalizerSummary;
    internal static string RobustScalingNormalizerSummary;
    internal static string MinMaxNormalizerUserName;
    internal static string MeanVarNormalizerUserName;
    internal static string LogMeanVarNormalizerUserName;
    internal static string BinNormalizerUserName;
    internal static string SupervisedBinNormalizerUserName;
    internal static string RobustScalingNormalizerUserName;
    internal static string MinMaxNormalizerShortName;
    internal static string MeanVarNormalizerShortName;
    internal static string LogMeanVarNormalizerShortName;
    internal static string BinNormalizerShortName;
    internal static string SupervisedBinNormalizerShortName;
    internal static string RobustScalingNormalizerShortName;
    public static IDataView CreateMinMaxNormalizer(IHostEnvironment env, IDataView input, string outputColumnName, string inputColumnName);
    internal static IDataTransform Create(IHostEnvironment env, MinMaxArguments args, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, MeanVarArguments args, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, LogMeanVarArguments args, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, BinArguments args, IDataView input);
    internal static IDataTransform Create(IHostEnvironment env, RobustScalingArguments args, IDataView input);
}
public class Microsoft.ML.Transforms.NormalizingEstimator : object {
    private IHost _host;
    private ColumnOptionsBase[] _columns;
    internal NormalizingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, NormalizationMode mode);
    internal NormalizingEstimator(IHostEnvironment env, NormalizationMode mode, ValueTuple`2[] columns);
    internal NormalizingEstimator(IHostEnvironment env, ColumnOptionsBase[] columns);
    public sealed virtual NormalizingTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.NormalizingTransformer : OneToOneTransformerBase {
    internal static string LoaderSignature;
    internal static string LoaderSignatureOld;
    [BestFriendAttribute]
internal IReadOnlyList`1<IColumnFunction> ColumnFunctions;
    [BestFriendAttribute]
internal ImmutableArray`1<ColumnOptions> Columns;
    private NormalizingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private NormalizingTransformer(IHost host, ModelLoadContext ctx);
    private NormalizingTransformer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetOldVersionInfo();
    private static VersionInfo GetVersionInfo();
    public NormalizerModelParametersBase GetNormalizerModelParameters(int index);
    internal static NormalizingTransformer Train(IHostEnvironment env, IDataView data, ColumnOptionsBase[] columns);
    private static NormalizingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private protected virtual void CheckInputColumn(DataViewSchema inputSchema, int col, int srcCol);
    internal IDataTransform MakeDataTransform(IDataView input);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
internal static class Microsoft.ML.Transforms.RandomNumberGenerator : object {
    [EntryPointAttribute]
public static TransformOutput Generate(IHostEnvironment env, Options input);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.RangeFilter : FilterBase {
    public static string Summary;
    public static string LoaderSignature;
    public static string UserName;
    private static string RegistrationName;
    private int _index;
    private DataViewType _type;
    private double _min;
    private double _max;
    private bool _complement;
    private bool _includeMin;
    private bool _includeMax;
    public RangeFilter(IHostEnvironment env, IDataView input, string column, double lowerBound, double upperBound, bool includeUpperBound);
    public RangeFilter(IHostEnvironment env, Options options, IDataView input);
    private RangeFilter(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static RangeFilter Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
    private DataViewRowCursor CreateCursorCore(DataViewRowCursor input, Boolean[] active);
    private Func`2<int, bool> GetActive(Func`2<int, bool> predicate, Boolean[]& active);
    public static bool IsValidRangeFilterColumnType(IExceptionContext ectx, DataViewType type);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.RowShufflingTransformer : RowToRowTransformBase {
    internal static string Summary;
    public static string LoaderSignature;
    private static string RegistrationName;
    private int _poolRows;
    private bool _poolOnly;
    private bool _forceShuffle;
    private bool _forceShuffleSource;
    private int _forceShuffleSeed;
    private IDataView _subsetInput;
    public bool CanShuffle { get; }
    public DataViewSchema OutputSchema { get; }
    public RowShufflingTransformer(IHostEnvironment env, IDataView input, int poolRows, bool poolOnly, bool forceShuffle);
    public RowShufflingTransformer(IHostEnvironment env, Options options, IDataView input);
    private RowShufflingTransformer(IHost host, ModelLoadContext ctx, IDataView input);
    private static VersionInfo GetVersionInfo();
    public static RowShufflingTransformer Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static IDataView SelectCachableColumns(IDataView data, IHostEnvironment env);
    internal static bool CanShuffleAll(DataViewSchema schema);
    public static DataViewRowCursor GetShuffledCursor(IChannelProvider provider, int poolRows, DataViewRowCursor cursor, Random rand);
    public virtual bool get_CanShuffle();
    public virtual DataViewSchema get_OutputSchema();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Transforms.ScoringTransformer : object {
    internal static string Summary;
    internal static IDataTransform Create(IHostEnvironment env, IDataView input, string inputModelFile, string featureColumn, string groupColumn);
    private static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.SkipTakeFilter : FilterBase {
    public static string LoaderSignature;
    private static string ModelSignature;
    private static string RegistrationName;
    public static string SkipTakeFilterSummary;
    public static string TakeFilterSummary;
    public static string SkipFilterSummary;
    public static string SkipTakeFilterUserName;
    public static string SkipTakeFilterShortName;
    public static string SkipFilterUserName;
    public static string SkipFilterShortName;
    public static string TakeFilterUserName;
    public static string TakeFilterShortName;
    private long _skip;
    private long _take;
    public bool CanShuffle { get; }
    private SkipTakeFilter(long skip, long take, IHostEnvironment env, IDataView input);
    internal SkipTakeFilter(IHostEnvironment env, SkipOptions options, IDataView input);
    internal SkipTakeFilter(IHostEnvironment env, TakeOptions options, IDataView input);
    private static VersionInfo GetVersionInfo();
    private sealed virtual override IDataTransform Microsoft.ML.Data.ITransformTemplate.ApplyToData(IHostEnvironment env, IDataView newSource);
    public static SkipTakeFilter Create(IHostEnvironment env, Options options, IDataView input);
    public static SkipTakeFilter Create(IHostEnvironment env, SkipOptions options, IDataView input);
    public static SkipTakeFilter Create(IHostEnvironment env, TakeOptions options, IDataView input);
    public static SkipTakeFilter Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    public virtual bool get_CanShuffle();
    public virtual Nullable`1<long> GetRowCount();
    protected virtual Nullable`1<bool> ShouldUseParallelCursors(Func`2<int, bool> predicate);
    protected virtual DataViewRowCursor GetRowCursorCore(IEnumerable`1<Column> columnsNeeded, Random rand);
    public virtual DataViewRowCursor[] GetRowCursorSet(IEnumerable`1<Column> columnsNeeded, int n, Random rand);
}
[BestFriendAttribute]
internal class Microsoft.ML.Transforms.SlotsDroppingTransformer : OneToOneTransformerBase {
    private static string RegistrationName;
    internal static string Summary;
    internal static string FriendlyName;
    internal static string LoaderSignature;
    internal Int32[][] SlotsMin;
    internal Int32[][] SlotsMax;
    internal SlotsDroppingTransformer(IHostEnvironment env, string outputColumnName, string inputColumnName, int min, Nullable`1<int> max);
    internal SlotsDroppingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private SlotsDroppingTransformer(IHostEnvironment env, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal static SlotsDroppingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private void GetSlotsMinMax(Column col, Int32[]& slotsMin, Int32[]& slotsMax);
    private static void GetSlotsMinMax(ColumnOptions[] columns, Int32[][]& slotsMin, Int32[][]& slotsMax);
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private static bool AreRangesValid(Int32[][] slotsMin, Int32[][] slotsMax);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
}
[BestFriendAttribute]
internal static class Microsoft.ML.Transforms.TrainAndScoreTransformer : object {
    internal static string Summary;
    internal static IDataTransform Create(IHostEnvironment env, IDataView input, ITrainer trainer, string featureColumn, string labelColumn, string groupColumn);
    private static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input);
    [BestFriendAttribute]
internal static IDataTransform Create(IHostEnvironment env, Arguments args, IDataView input, IComponentFactory`2<IPredictor, ISchemaBindableMapper> mapperFactory);
    private static IDataTransform Create(IHostEnvironment env, Arguments args, ITrainer trainer, IDataView input, IComponentFactory`2<IPredictor, ISchemaBindableMapper> mapperFactory);
    public static RoleMappedData CreateDataFromArgs(IExceptionContext ectx, IDataView input, ArgumentsBase args);
    private static RoleMappedData CreateDataFromArgs(IExceptionContext ectx, IDataView input, ArgumentsBase args, String& feat, String& group);
}
[EntryPointKindAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public abstract class Microsoft.ML.Transforms.TransformInputBase : object {
    [BestFriendAttribute]
[ArgumentAttribute("1")]
internal IDataView Data;
}
internal static class Microsoft.ML.Transforms.TypeConversion : object {
    [EntryPointAttribute]
public static TransformOutput Convert(IHostEnvironment env, Options input);
}
public class Microsoft.ML.Transforms.TypeConvertingEstimator : TrivialEstimator`1<TypeConvertingTransformer> {
    internal TypeConvertingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, DataKind outputKind);
    internal TypeConvertingEstimator(IHostEnvironment env, ColumnOptions[] columns);
    public virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.TypeConvertingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string UserName;
    internal static string ShortName;
    internal static string LoaderSignature;
    internal static string LoaderSignatureOld;
    private static UInt32 VersionNoMinCount;
    private static int VersionTransformer;
    private static string RegistrationName;
    private ColumnOptions[] _columns;
    internal IReadOnlyCollection`1<ColumnOptions> Columns { get; }
    internal TypeConvertingTransformer(IHostEnvironment env, string outputColumnName, DataKind outputKind, string inputColumnName, KeyCount outputKeyCount);
    internal TypeConvertingTransformer(IHostEnvironment env, ColumnOptions[] columns);
    private TypeConvertingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    internal IReadOnlyCollection`1<ColumnOptions> get_Columns();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptions[] columns);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static TypeConvertingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    internal static bool GetNewType(IExceptionContext ectx, DataViewType srcType, InternalDataKind kind, KeyCount keyCount, PrimitiveDataViewType& itemType);
}
public class Microsoft.ML.Transforms.ValueMappingEstimator : TrivialEstimator`1<ValueMappingTransformer> {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueTuple`2[] _columns;
    internal ValueMappingEstimator(IHostEnvironment env, IDataView lookupMap, Column keyColumn, Column valueColumn, ValueTuple`2[] columns);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ValueMappingEstimator`2 : ValueMappingEstimator {
    internal ValueMappingEstimator`2(IHostEnvironment env, IDataView lookupMap, Column keyColumn, Column valueColumn, ValueTuple`2[] columns);
}
public class Microsoft.ML.Transforms.ValueMappingTransformer : OneToOneTransformerBase {
    internal static string Summary;
    internal static string LoaderSignature;
    internal static string UserName;
    internal static string ShortName;
    internal static string TermLookupLoaderSignature;
    private static string DefaultMapName;
    internal static string DefaultKeyColumnName;
    internal static string DefaultValueColumnName;
    private ValueMap _valueMap;
    private Byte[] _dataView;
    internal DataViewType ValueColumnType { get; }
    internal Annotations ValueColumnMetadata { get; }
    internal ValueMappingTransformer(IHostEnvironment env, IDataView lookupMap, Column lookupKeyColumn, Column lookupValueColumn, ValueTuple`2[] columns);
    private static ValueMappingTransformer();
    internal DataViewType get_ValueColumnType();
    internal Annotations get_ValueColumnMetadata();
    private static VersionInfo GetVersionInfo();
    private static VersionInfo GetTermLookupVersionInfo();
    private ValueMap CreateValueMapFromDataView(IDataView dataView, Column keyColumn, Column valueColumn);
    private static Column GenerateValueColumn(IHostEnvironment env, IDataView loader, string valueColumnName, int keyIdx, int valueIdx, string fileName);
    private static ValueMappingTransformer CreateTransformInvoke(IHostEnvironment env, IDataView idv, string keyColumnName, string valueColumnName, bool treatValuesAsKeyTypes, ValueTuple`2[] columns);
    private static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static bool CheckModelVersion(ModelLoadContext ctx, VersionInfo versionInfo);
    private protected static ValueMappingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static Byte[] ReadAllBytes(IExceptionContext ectx, BinaryReader rdr);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    private protected static PrimitiveDataViewType GetPrimitiveType(Type rawType, Boolean& isVectorType);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    private static Byte[] GetBytesFromDataView(IHost host, IDataView lookup, string keyColumn, string valueColumn);
    private static BinaryLoader GetLoader(IHostEnvironment env, Byte[] bytes);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    [CompilerGeneratedAttribute]
private void <SaveModel>b__29_0(BinaryWriter w);
}
public class Microsoft.ML.Transforms.ValueToKeyMappingEstimator : object {
    private IHost _host;
    private ColumnOptionsBase[] _columns;
    private IDataView _keyData;
    internal ValueToKeyMappingEstimator(IHostEnvironment env, string outputColumnName, string inputColumnName, int maximumNumberOfKeys, KeyOrdinality keyOrdinality);
    internal ValueToKeyMappingEstimator(IHostEnvironment env, ColumnOptionsBase[] columns, IDataView keyData);
    public sealed virtual ValueToKeyMappingTransformer Fit(IDataView input);
    public sealed virtual SchemaShape GetOutputSchema(SchemaShape inputSchema);
}
public class Microsoft.ML.Transforms.ValueToKeyMappingTransformer : OneToOneTransformerBase {
    [BestFriendAttribute]
internal static string Summary;
    [BestFriendAttribute]
internal static string UserName;
    [BestFriendAttribute]
internal static string LoaderSignature;
    [BestFriendAttribute]
internal static string FriendlyName;
    private static UInt32 VerNonTextTypesSupported;
    private static UInt32 VerManagerNonTextTypesSupported;
    internal static string TermManagerLoaderSignature;
    private static MemoryStreamPool modreq(System.Runtime.CompilerServices.IsVolatile) _codecFactoryPool;
    private CodecFactory modreq(System.Runtime.CompilerServices.IsVolatile) _codecFactory;
    private TermMap[] _unboundMaps;
    private Boolean[] _textMetadata;
    private static string RegistrationName;
    private CodecFactory CodecFactory { get; }
    internal ValueToKeyMappingTransformer(IHostEnvironment env, IDataView input, ColumnOptions[] columns);
    internal ValueToKeyMappingTransformer(IHostEnvironment env, IDataView input, ColumnOptionsBase[] columns, IDataView keyData, bool autoConvert);
    private ValueToKeyMappingTransformer(IHost host, ModelLoadContext ctx);
    private static VersionInfo GetVersionInfo();
    private CodecFactory get_CodecFactory();
    private static VersionInfo GetTermManagerVersionInfo();
    private static ValueTuple`2[] GetColumnPairs(ColumnOptionsBase[] columns);
    private string TestIsKnownDataKind(DataViewType type);
    private ColInfo[] CreateInfos(DataViewSchema inputSchema);
    [BestFriendAttribute]
internal static IDataTransform Create(IHostEnvironment env, Options options, IDataView input);
    private static ValueToKeyMappingTransformer Create(IHostEnvironment env, ModelLoadContext ctx);
    private static IDataTransform Create(IHostEnvironment env, ModelLoadContext ctx, IDataView input);
    private static IRowMapper Create(IHostEnvironment env, ModelLoadContext ctx, DataViewSchema inputSchema);
    [BestFriendAttribute]
internal static IDataView GetKeyDataViewOrNull(IHostEnvironment env, IChannel ch, string file, string termsColumn, IComponentFactory`2<IMultiStreamSource, ILegacyDataLoader> loaderFactory, Boolean& autoConvert);
    private static TermMap CreateTermMapFromData(IHostEnvironment env, IChannel ch, IDataView keyData, bool autoConvert, Builder bldr);
    private static TermMap[] Train(IHostEnvironment env, IChannel ch, ColInfo[] infos, IDataView keyData, ColumnOptionsBase[] columns, IDataView trainingData, bool autoConvert);
    private protected virtual void SaveModel(ModelSaveContext ctx);
    [BestFriendAttribute]
internal TermMap GetTermMap(int iinfo);
    private protected virtual IRowMapper MakeRowMapper(DataViewSchema schema);
    private static BoundTermMap Bind(IHostEnvironment env, DataViewSchema schema, TermMap unbound, ColInfo[] infos, Boolean[] textMetadata, int iinfo);
    private static void GetTextTerms(VBuffer`1& src, ValueMapper`2<T, StringBuilder> stringMapper, VBuffer`1& dst);
    [CompilerGeneratedAttribute]
private void <SaveModel>b__34_0(ModelSaveContext c);
    [CompilerGeneratedAttribute]
private void <SaveModel>b__34_1(TextWriter writer);
}
public class Microsoft.ML.TransformsCatalog : object {
    private IHostEnvironment _env;
    [CompilerGeneratedAttribute]
private CategoricalTransforms <Categorical>k__BackingField;
    [CompilerGeneratedAttribute]
private ConversionTransforms <Conversion>k__BackingField;
    [CompilerGeneratedAttribute]
private TextTransforms <Text>k__BackingField;
    [CompilerGeneratedAttribute]
private FeatureSelectionTransforms <FeatureSelection>k__BackingField;
    private IHostEnvironment Microsoft.ML.Data.IInternalCatalog.Environment { get; }
    public CategoricalTransforms Categorical { get; }
    public ConversionTransforms Conversion { get; }
    public TextTransforms Text { get; }
    public FeatureSelectionTransforms FeatureSelection { get; }
    internal TransformsCatalog(IHostEnvironment env);
    private sealed virtual override IHostEnvironment Microsoft.ML.Data.IInternalCatalog.get_Environment();
    [CompilerGeneratedAttribute]
public CategoricalTransforms get_Categorical();
    [CompilerGeneratedAttribute]
public ConversionTransforms get_Conversion();
    [CompilerGeneratedAttribute]
public TextTransforms get_Text();
    [CompilerGeneratedAttribute]
public FeatureSelectionTransforms get_FeatureSelection();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
