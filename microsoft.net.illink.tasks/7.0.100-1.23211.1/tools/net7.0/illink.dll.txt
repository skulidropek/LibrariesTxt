[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ILLink.Shared.Annotations : object {
    private static DynamicallyAccessedMemberTypes[] AllDynamicallyAccessedMemberTypes;
    private static Annotations();
    public static bool SourceHasRequiredAnnotations(DynamicallyAccessedMemberTypes sourceMemberTypes, DynamicallyAccessedMemberTypes targetMemberTypes, String& missingMemberTypesString);
    public static DynamicallyAccessedMemberTypes GetMissingMemberTypes(DynamicallyAccessedMemberTypes requiredMemberTypes, DynamicallyAccessedMemberTypes availableMemberTypes);
    public static string GetMemberTypesString(DynamicallyAccessedMemberTypes memberTypes);
    private static DynamicallyAccessedMemberTypes[] GetAllDynamicallyAccessedMemberTypes();
    public static ValueTuple`2<DiagnosticId, String[]> GetDiagnosticForAnnotationMismatch(ValueWithDynamicallyAccessedMembers source, ValueWithDynamicallyAccessedMembers target, string missingAnnotations);
}
public class ILLink.Shared.DataFlow.Box`1 : object {
    [CompilerGeneratedAttribute]
private T <Value>k__BackingField;
    public T Value { get; public set; }
    public Box`1(T value);
    [CompilerGeneratedAttribute]
public T get_Value();
    [CompilerGeneratedAttribute]
public void set_Value(T value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.DataFlow.DefaultValueDictionary`2 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TKey, TValue> Dictionary;
    private TValue DefaultValue;
    public int Count { get; }
    public DefaultValueDictionary`2(TValue defaultValue);
    private DefaultValueDictionary`2(TValue defaultValue, Dictionary`2<TKey, TValue> dictionary);
    public DefaultValueDictionary`2(DefaultValueDictionary`2<TKey, TValue> other);
    public TValue Get(TKey key);
    public void Set(TKey key, TValue value);
    public sealed virtual bool Equals(DefaultValueDictionary`2<TKey, TValue> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public int get_Count();
    public sealed virtual IEnumerator`1<KeyValuePair`2<TKey, TValue>> GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public virtual string ToString();
    public DefaultValueDictionary`2<TKey, TValue> Clone();
    public virtual int GetHashCode();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.DictionaryLattice`3 : ValueType {
    public TValueLattice ValueLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private DefaultValueDictionary`2<TKey, TValue> <Top>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DefaultValueDictionary`2<TKey, TValue> Top { get; }
    public DictionaryLattice`3(TValueLattice valueLattice);
    [CompilerGeneratedAttribute]
public sealed virtual DefaultValueDictionary`2<TKey, TValue> get_Top();
    public sealed virtual DefaultValueDictionary`2<TKey, TValue> Meet(DefaultValueDictionary`2<TKey, TValue> left, DefaultValueDictionary`2<TKey, TValue> right);
}
public abstract class ILLink.Shared.DataFlow.ForwardDataFlowAnalysis`7 : object {
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public virtual void TraceStart(TControlFlowGraph cfg);
    [NullableContextAttribute("1")]
[ConditionalAttribute("DEBUG")]
public virtual void TraceVisitBlock(TBlock block);
    [ConditionalAttribute("DEBUG")]
public virtual void TraceBlockInput(TValue normalState, Nullable`1<TValue> exceptionState, Nullable`1<TValue> exceptionFinallyState);
    [ConditionalAttribute("DEBUG")]
public virtual void TraceBlockOutput(TValue normalState, Nullable`1<TValue> exceptionState, Nullable`1<TValue> exceptionFinallyState);
    [NullableContextAttribute("1")]
public void Fixpoint(TControlFlowGraph cfg, TLattice lattice, TTransfer transfer);
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.IControlFlowGraph`2 {
    public IEnumerable`1<TBlock> Blocks { get; }
    public TBlock Entry { get; }
    public abstract virtual IEnumerable`1<TBlock> get_Blocks();
    public abstract virtual TBlock get_Entry();
    public abstract virtual IEnumerable`1<Predecessor<TBlock, TRegion>> GetPredecessors(TBlock block);
    public abstract virtual bool TryGetEnclosingTryOrCatchOrFilter(TBlock block, TRegion& tryOrCatchOrFilterRegion);
    public abstract virtual bool TryGetEnclosingTryOrCatchOrFilter(TRegion region, TRegion& tryOrCatchOrFilterRegion);
    public abstract virtual bool TryGetEnclosingFinally(TBlock block, TRegion& region);
    public abstract virtual TRegion GetCorrespondingTry(TRegion cathOrFilterOrFinallyRegion);
    public abstract virtual IEnumerable`1<TRegion> GetPreviousFilters(TRegion catchOrFilterRegion);
    public abstract virtual bool HasFilter(TRegion catchRegion);
    public abstract virtual TBlock FirstBlock(TRegion region);
    public abstract virtual TBlock LastBlock(TRegion region);
}
public interface ILLink.Shared.DataFlow.IDataFlowState`2 {
    public TValue Current { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Box`1<TValue> Exception { get; public set; }
    [NullableAttribute("1")]
public TValueLattice Lattice { get; public set; }
    public abstract virtual TValue get_Current();
    public abstract virtual void set_Current(TValue value);
    public abstract virtual Box`1<TValue> get_Exception();
    public abstract virtual void set_Exception(Box`1<TValue> value);
    [NullableContextAttribute("1")]
public abstract virtual TValueLattice get_Lattice();
    [NullableContextAttribute("1")]
public abstract virtual Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Lattice(TValueLattice value);
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.IDeepCopyValue`1 {
    public abstract virtual TSingleValue DeepCopy();
}
[NullableContextAttribute("1")]
public interface ILLink.Shared.DataFlow.ILattice`1 {
    public TValue Top { get; }
    public abstract virtual TValue get_Top();
    public abstract virtual TValue Meet(TValue left, TValue right);
}
[NullableContextAttribute("2")]
public interface ILLink.Shared.DataFlow.IRegion`1 {
    public RegionKind Kind { get; }
    public abstract virtual RegionKind get_Kind();
}
public interface ILLink.Shared.DataFlow.ITransfer`4 {
    [NullableContextAttribute("1")]
public abstract virtual void Transfer(TOperation operation, TState state);
}
public class ILLink.Shared.DataFlow.Maybe`1 : ValueType {
    public Nullable`1<T> MaybeValue;
    public Maybe`1(T value);
    public sealed virtual bool Equals(Maybe`1<T> other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public Maybe`1<T> Clone();
}
public class ILLink.Shared.DataFlow.MaybeLattice`2 : ValueType {
    [NullableAttribute("1")]
public TValueLattice ValueLattice;
    [CompilerGeneratedAttribute]
private Maybe`1<T> <Top>k__BackingField;
    public Maybe`1<T> Top { get; }
    [NullableContextAttribute("1")]
public MaybeLattice`2(TValueLattice valueLattice);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public sealed virtual Maybe`1<T> get_Top();
    public sealed virtual Maybe`1<T> Meet(Maybe`1<T> left, Maybe`1<T> right);
}
public enum ILLink.Shared.DataFlow.RegionKind : Enum {
    public int value__;
    public static RegionKind Try;
    public static RegionKind Catch;
    public static RegionKind Filter;
    public static RegionKind Finally;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.Shared.DataFlow.SingleValue : object {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected SingleValue(SingleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual SingleValue DeepCopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SingleValue left, SingleValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SingleValue left, SingleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(SingleValue other);
    [CompilerGeneratedAttribute]
public abstract virtual SingleValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.ValueSet`1 : ValueType {
    [NullableAttribute("2")]
private object _values;
    public ValueSet`1(TValue value);
    public ValueSet`1(IEnumerable`1<TValue> values);
    private ValueSet`1(EnumerableValues<TValue> values);
    public static ValueSet`1<TValue> op_Implicit(TValue value);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public sealed virtual bool Equals(ValueSet`1<TValue> other);
    public virtual int GetHashCode();
    [NullableContextAttribute("0")]
public Enumerator<TValue> GetEnumerator();
    private sealed virtual override IEnumerator`1<TValue> System.Collections.Generic.IEnumerable<TValue>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public bool Contains(TValue value);
    internal static ValueSet`1<TValue> Meet(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
    public bool IsEmpty();
    public virtual string ToString();
    public ValueSet`1<TValue> Clone();
}
[IsReadOnlyAttribute]
public class ILLink.Shared.DataFlow.ValueSetLattice`1 : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<TValue> Top { get; }
    public sealed virtual ValueSet`1<TValue> get_Top();
    public sealed virtual ValueSet`1<TValue> Meet(ValueSet`1<TValue> left, ValueSet`1<TValue> right);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ILLink.Shared.DiagnosticCategory : object {
    public static string SingleFile;
    public static string Trimming;
    public static string AOT;
}
public enum ILLink.Shared.DiagnosticId : Enum {
    public int value__;
    public static DiagnosticId XmlFeatureDoesNotSpecifyFeatureValue;
    public static DiagnosticId XmlUnsupportedNonBooleanValueForFeature;
    public static DiagnosticId XmlException;
    public static DiagnosticId _unused_FailedToProcessDescriptorFile;
    public static DiagnosticId CouldNotFindMethodInAssembly;
    public static DiagnosticId CannotStubConstructorWhenBaseTypeDoesNotHaveConstructor;
    public static DiagnosticId CouldNotFindType;
    public static DiagnosticId CouldNotFindConstructor;
    public static DiagnosticId CouldNotFindAssemblyReference;
    public static DiagnosticId CouldNotLoadAssembly;
    public static DiagnosticId FailedToWriteOutput;
    public static DiagnosticId LinkerUnexpectedError;
    public static DiagnosticId ErrorProcessingXmlLocation;
    public static DiagnosticId XmlDocumentLocationHasInvalidFeatureDefault;
    public static DiagnosticId UnrecognizedCommandLineOption;
    public static DiagnosticId InvalidWarningVersion;
    public static DiagnosticId InvalidGenerateWarningSuppressionsValue;
    public static DiagnosticId MissingArgumentForCommanLineOptionName;
    public static DiagnosticId CustomDataFormatIsInvalid;
    public static DiagnosticId NoFilesToLinkSpecified;
    public static DiagnosticId NewMvidAndDeterministicCannotBeUsedAtSameTime;
    public static DiagnosticId AssemblyInCustomStepOptionCouldNotBeFound;
    public static DiagnosticId AssemblyPathInCustomStepMustBeFullyQualified;
    public static DiagnosticId InvalidArgForCustomStep;
    public static DiagnosticId ExpectedSignToControlNewStepInsertion;
    public static DiagnosticId PipelineStepCouldNotBeFound;
    public static DiagnosticId CustomStepTypeCouldNotBeFound;
    public static DiagnosticId CustomStepTypeIsIncompatibleWithLinkerVersion;
    public static DiagnosticId InvalidOptimizationValue;
    public static DiagnosticId InvalidArgumentForTokenOption;
    public static DiagnosticId InvalidAssemblyAction;
    public static DiagnosticId RootAssemblyCouldNotBeFound;
    public static DiagnosticId XmlDescriptorCouldNotBeFound;
    public static DiagnosticId RootAssemblyDoesNotHaveEntryPoint;
    public static DiagnosticId RootAssemblyCannotUseAction;
    public static DiagnosticId InvalidAssemblyName;
    public static DiagnosticId InvalidAssemblyRootMode;
    public static DiagnosticId ExportedTypeCannotBeResolved;
    public static DiagnosticId ReferenceAssemblyCouldNotBeLoaded;
    public static DiagnosticId FailedToResolveMetadataElement;
    public static DiagnosticId TypeUsedWithAttributeValueCouldNotBeFound;
    public static DiagnosticId CannotConverValueToType;
    public static DiagnosticId CustomAttributeArgumentForTypeRequiresNestedNode;
    public static DiagnosticId CouldNotResolveCustomAttributeTypeValue;
    public static DiagnosticId UnexpectedAttributeArgumentType;
    public static DiagnosticId InvalidMetadataOption;
    public static DiagnosticId InvalidDependenciesFileFormat;
    public static DiagnosticId TypeHasNoFieldsToPreserve;
    public static DiagnosticId TypeHasNoMethodsToPreserve;
    public static DiagnosticId CouldNotResolveDependencyAssembly;
    public static DiagnosticId CouldNotResolveDependencyType;
    public static DiagnosticId CouldNotResolveDependencyMember;
    public static DiagnosticId _unused_UnrecognizedReflectionPattern;
    public static DiagnosticId XmlCouldNotResolveAssembly;
    public static DiagnosticId XmlCouldNotResolveType;
    public static DiagnosticId XmlCouldNotFindMethodOnType;
    public static DiagnosticId XmlInvalidValueForStub;
    public static DiagnosticId XmlUnkownBodyModification;
    public static DiagnosticId XmlCouldNotFindFieldOnType;
    public static DiagnosticId XmlSubstitutedFieldNeedsToBeStatic;
    public static DiagnosticId XmlMissingSubstitutionValueForField;
    public static DiagnosticId XmlInvalidSubstitutionValueForField;
    public static DiagnosticId XmlCouldNotFindEventOnType;
    public static DiagnosticId XmlCouldNotFindPropertyOnType;
    public static DiagnosticId XmlCouldNotFindGetAccesorOfPropertyOnType;
    public static DiagnosticId XmlCouldNotFindSetAccesorOfPropertyOnType;
    public static DiagnosticId _unused_RearrangedXmlWarning1;
    public static DiagnosticId _unused_RearrangedXmlWarning2;
    public static DiagnosticId XmlCouldNotFindMatchingConstructorForCustomAttribute;
    public static DiagnosticId XmlMoreThanOneReturnElementForMethod;
    public static DiagnosticId XmlMoreThanOneValyForParameterOfMethod;
    public static DiagnosticId XmlDuplicatePreserveMember;
    public static DiagnosticId RequiresUnreferencedCode;
    public static DiagnosticId AttributeShouldOnlyBeUsedOnceOnMember;
    public static DiagnosticId AttributeDoesntHaveTheRequiredNumberOfParameters;
    public static DiagnosticId XmlElementDoesNotContainRequiredAttributeFullname;
    public static DiagnosticId XmlCouldNotResolveAssemblyForAttribute;
    public static DiagnosticId XmlAttributeTypeCouldNotBeFound;
    public static DiagnosticId UnrecognizedParameterInMethodCreateInstance;
    public static DiagnosticId DeprecatedPreserveDependencyAttribute;
    public static DiagnosticId DynamicDependencyAttributeCouldNotBeAnalyzed;
    public static DiagnosticId UnresolvedAssemblyInDynamicDependencyAttribute;
    public static DiagnosticId UnresolvedTypeInDynamicDependencyAttribute;
    public static DiagnosticId NoMembersResolvedForMemberSignatureOrType;
    public static DiagnosticId XmlMissingNameAttributeInResource;
    public static DiagnosticId XmlInvalidValueForAttributeActionForResource;
    public static DiagnosticId XmlCouldNotFindResourceToRemoveInAssembly;
    public static DiagnosticId DynamicallyAccessedMembersIsNotAllowedOnMethods;
    public static DiagnosticId DynamicallyAccessedMembersCouldNotFindBackingField;
    public static DiagnosticId DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessor;
    public static DiagnosticId XmlCouldNotFindAnyTypeInNamespace;
    public static DiagnosticId AttributeIsReferencedButTrimmerRemoveAllInstances;
    public static DiagnosticId RequiresUnreferencedCodeAttributeMismatch;
    public static DiagnosticId _unused_DynamicallyAccessedMembersMismatchBetweenOverrides;
    public static DiagnosticId XmlRemoveAttributeInstancesCanOnlyBeUsedOnType;
    public static DiagnosticId UnrecognizedInternalAttribute;
    public static DiagnosticId CorrectnessOfCOMCannotBeGuaranteed;
    public static DiagnosticId XmlPropertyDoesNotContainAttributeName;
    public static DiagnosticId XmlCouldNotFindProperty;
    public static DiagnosticId _unused_XmlInvalidPropertyValueForProperty;
    public static DiagnosticId _unused_XmlInvalidArgumentForParameterOfType;
    public static DiagnosticId MakeGenericType;
    public static DiagnosticId DynamicallyAccessedMembersOnPropertyConflictsWithBackingField;
    public static DiagnosticId UnrecognizedTypeNameInTypeGetType;
    public static DiagnosticId ParametersOfAssemblyCreateInstanceCannotBeAnalyzed;
    public static DiagnosticId UnrecognizedTypeInRuntimeHelpersRunClassConstructor;
    public static DiagnosticId MakeGenericMethod;
    public static DiagnosticId UnresolvedAssemblyInCreateInstance;
    public static DiagnosticId MethodParameterCannotBeStaticallyDetermined;
    public static DiagnosticId MethodReturnValueCannotBeStaticallyDetermined;
    public static DiagnosticId FieldValueCannotBeStaticallyDetermined;
    public static DiagnosticId ImplicitThisCannotBeStaticallyDetermined;
    public static DiagnosticId TypePassedToGenericParameterCannotBeStaticallyDetermined;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchParameterTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchFieldTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnType;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsField;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameter;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverrides;
    public static DiagnosticId DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverrides;
    public static DiagnosticId CaseInsensitiveTypeGetTypeCallIsNotSupported;
    public static DiagnosticId DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId XmlUnsuportedWildcard;
    public static DiagnosticId AssemblyWithEmbeddedXmlApplyToAnotherAssembly;
    public static DiagnosticId InvalidIsTrimmableValue;
    public static DiagnosticId PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDetermined;
    public static DiagnosticId AssemblyProducedTrimWarnings;
    public static DiagnosticId TypeWasNotFoundInAssemblyNorBaseLibrary;
    public static DiagnosticId DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStrings;
    public static DiagnosticId MethodsAreAssociatedWithStateMachine;
    public static DiagnosticId InvalidScopeInUnconditionalSuppressMessage;
    public static DiagnosticId RequiresUnreferencedCodeOnBaseClass;
    public static DiagnosticId DynamicallyAccessedMembersFieldAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersMethodAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCode;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCode;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembers;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembers;
    public static DiagnosticId RequiresUnreferencedCodeOnStaticConstructor;
    public static DiagnosticId MethodsAreAssociatedWithUserMethod;
    public static DiagnosticId CompilerGeneratedMemberAccessedViaReflection;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMember;
    public static DiagnosticId DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBase;
    public static DiagnosticId RedundantSuppression;
    public static DiagnosticId AvoidAssemblyLocationInSingleFile;
    public static DiagnosticId AvoidAssemblyGetFilesInSingleFile;
    public static DiagnosticId RequiresAssemblyFiles;
    public static DiagnosticId RequiresAssemblyFilesAttributeMismatch;
    public static DiagnosticId RequiresAssemblyFilesOnStaticConstructor;
    public static DiagnosticId RequiresDynamicCode;
    public static DiagnosticId RequiresDynamicCodeAttributeMismatch;
    public static DiagnosticId COMInteropNotSupportedInFullAOT;
    public static DiagnosticId AssemblyProducedAOTWarnings;
    public static DiagnosticId GenericRecursionCycle;
    public static DiagnosticId CorrectnessOfAbstractDelegatesCannotBeGuaranteed;
    public static DiagnosticId RequiresDynamicCodeOnStaticConstructor;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.Shared.DiagnosticIdExtensions : object {
    [ExtensionAttribute]
public static string AsString(DiagnosticId diagnosticId);
    [ExtensionAttribute]
public static string GetDiagnosticSubcategory(DiagnosticId diagnosticId);
    [ExtensionAttribute]
public static string GetDiagnosticCategory(DiagnosticId diagnosticId);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.DiagnosticString : ValueType {
    private string _titleFormat;
    private string _messageFormat;
    public DiagnosticString(DiagnosticId diagnosticId);
    public DiagnosticString(string diagnosticResourceStringName);
    public string GetMessage(String[] args);
    public string GetMessageFormat();
    public string GetTitle(String[] args);
    public string GetTitleFormat();
}
internal static class ILLink.Shared.DynamicallyAccessedMemberTypesOverlay : object {
    public static DynamicallyAccessedMemberTypes Interfaces;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ILLink.Shared.HashUtils : object {
    public static int Combine(T1 value1, T2 value2);
    public static int Combine(T1 value1, T2 value2, T3 value3);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class ILLink.Shared.MessageFormat : object {
    public static string FormatRequiresAttributeMessageArg(string message);
    public static string FormatRequiresAttributeUrlArg(string url);
    public static string FormatRequiresAttributeMismatch(bool memberHasAttribute, bool isInterface, Object[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class ILLink.Shared.MessageSubCategory : object {
    public static string None;
    public static string TrimAnalysis;
    public static string UnresolvedAssembly;
    public static string AotAnalysis;
}
internal static class ILLink.Shared.SharedStrings : object {
    private static ResourceManager s_resourceManager;
    [CompilerGeneratedAttribute]
private static CultureInfo <Culture>k__BackingField;
    internal static ResourceManager ResourceManager { get; }
    internal static CultureInfo Culture { get; internal set; }
    internal static string XmlFeatureDoesNotSpecifyFeatureValueTitle { get; }
    internal static string XmlFeatureDoesNotSpecifyFeatureValueMessage { get; }
    internal static string XmlUnsupportedNonBooleanValueForFeatureTitle { get; }
    internal static string XmlUnsupportedNonBooleanValueForFeatureMessage { get; }
    internal static string XmlExceptionTitle { get; }
    internal static string XmlExceptionMessage { get; }
    internal static string CouldNotFindMethodInAssemblyTitle { get; }
    internal static string CouldNotFindMethodInAssemblyMessage { get; }
    internal static string CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorTitle { get; }
    internal static string CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorMessage { get; }
    internal static string CouldNotFindTypeTitle { get; }
    internal static string CouldNotFindTypeMessage { get; }
    internal static string CouldNotFindConstructorTitle { get; }
    internal static string CouldNotFindConstructorMessage { get; }
    internal static string CouldNotFindAssemblyReferenceTitle { get; }
    internal static string CouldNotFindAssemblyReferenceMessage { get; }
    internal static string CouldNotLoadAssemblyTitle { get; }
    internal static string CouldNotLoadAssemblyMessage { get; }
    internal static string FailedToWriteOutputTitle { get; }
    internal static string FailedToWriteOutputMessage { get; }
    internal static string LinkerUnexpectedErrorTitle { get; }
    internal static string LinkerUnexpectedErrorMessage { get; }
    internal static string ErrorProcessingXmlLocationTitle { get; }
    internal static string ErrorProcessingXmlLocationMessage { get; }
    internal static string XmlDocumentLocationHasInvalidFeatureDefaultTitle { get; }
    internal static string XmlDocumentLocationHasInvalidFeatureDefaultMessage { get; }
    internal static string UnrecognizedCommandLineOptionTitle { get; }
    internal static string UnrecognizedCommandLineOptionMessage { get; }
    internal static string InvalidWarningVersionTitle { get; }
    internal static string InvalidWarningVersionMessage { get; }
    internal static string InvalidGenerateWarningSuppressionsValueTitle { get; }
    internal static string InvalidGenerateWarningSuppressionsValueMessage { get; }
    internal static string MissingArgumentForCommanLineOptionNameTitle { get; }
    internal static string MissingArgumentForCommanLineOptionNameMessage { get; }
    internal static string CustomDataFormatIsInvalidTitle { get; }
    internal static string CustomDataFormatIsInvalidMessage { get; }
    internal static string NoFilesToLinkSpecifiedTitle { get; }
    internal static string NoFilesToLinkSpecifiedMessage { get; }
    internal static string NewMvidAndDeterministicCannotBeUsedAtSameTimeTitle { get; }
    internal static string NewMvidAndDeterministicCannotBeUsedAtSameTimeMessage { get; }
    internal static string AssemblyInCustomStepOptionCouldNotBeFoundTitle { get; }
    internal static string AssemblyInCustomStepOptionCouldNotBeFoundMessage { get; }
    internal static string AssemblyPathInCustomStepMustBeFullyQualifiedTitle { get; }
    internal static string AssemblyPathInCustomStepMustBeFullyQualifiedMessage { get; }
    internal static string InvalidArgForCustomStepTitle { get; }
    internal static string InvalidArgForCustomStepMessage { get; }
    internal static string ExpectedSignToControlNewStepInsertionTitle { get; }
    internal static string ExpectedSignToControlNewStepInsertionMessage { get; }
    internal static string PipelineStepCouldNotBeFoundTitle { get; }
    internal static string PipelineStepCouldNotBeFoundMessage { get; }
    internal static string CustomStepTypeCouldNotBeFoundTitle { get; }
    internal static string CustomStepTypeCouldNotBeFoundMessage { get; }
    internal static string CustomStepTypeIsIncompatibleWithLinkerVersionTitle { get; }
    internal static string CustomStepTypeIsIncompatibleWithLinkerVersionMessage { get; }
    internal static string InvalidOptimizationValueTitle { get; }
    internal static string InvalidOptimizationValueMessage { get; }
    internal static string InvalidArgumentForTokenOptionTitle { get; }
    internal static string InvalidArgumentForTokenOptionMessage { get; }
    internal static string InvalidAssemblyActionTitle { get; }
    internal static string InvalidAssemblyActionMessage { get; }
    internal static string RootAssemblyCouldNotBeFoundTitle { get; }
    internal static string RootAssemblyCouldNotBeFoundMessage { get; }
    internal static string XmlDescriptorCouldNotBeFoundTitle { get; }
    internal static string XmlDescriptorCouldNotBeFoundMessage { get; }
    internal static string RootAssemblyDoesNotHaveEntryPointTitle { get; }
    internal static string RootAssemblyDoesNotHaveEntryPointMessage { get; }
    internal static string RootAssemblyCannotUseActionTitle { get; }
    internal static string RootAssemblyCannotUseActionMessage { get; }
    internal static string InvalidAssemblyNameTitle { get; }
    internal static string InvalidAssemblyNameMessage { get; }
    internal static string InvalidAssemblyRootModeTitle { get; }
    internal static string InvalidAssemblyRootModeMessage { get; }
    internal static string ExportedTypeCannotBeResolvedTitle { get; }
    internal static string ExportedTypeCannotBeResolvedMessage { get; }
    internal static string ReferenceAssemblyCouldNotBeLoadedTitle { get; }
    internal static string ReferenceAssemblyCouldNotBeLoadedMessage { get; }
    internal static string FailedToResolveMetadataElementTitle { get; }
    internal static string FailedToResolveMetadataElementMessage { get; }
    internal static string FailedToResolveFieldElementTitle { get; }
    internal static string FailedToResolveFieldElementMessage { get; }
    internal static string FailedToResolveMethodElementTitle { get; }
    internal static string FailedToResolveMethodElementMessage { get; }
    internal static string FailedToResolveTypeElementTitle { get; }
    internal static string FailedToResolveTypeElementMessage { get; }
    internal static string TypeUsedWithAttributeValueCouldNotBeFoundTitle { get; }
    internal static string TypeUsedWithAttributeValueCouldNotBeFoundMessage { get; }
    internal static string CannotConverValueToTypeTitle { get; }
    internal static string CannotConverValueToTypeMessage { get; }
    internal static string CustomAttributeArgumentForTypeRequiresNestedNodeTitle { get; }
    internal static string CustomAttributeArgumentForTypeRequiresNestedNodeMessage { get; }
    internal static string CouldNotResolveCustomAttributeTypeValueTitle { get; }
    internal static string CouldNotResolveCustomAttributeTypeValueMessage { get; }
    internal static string UnexpectedAttributeArgumentTypeTitle { get; }
    internal static string UnexpectedAttributeArgumentTypeMessage { get; }
    internal static string InvalidMetadataOptionTitle { get; }
    internal static string InvalidMetadataOptionMessage { get; }
    internal static string TypeHasNoFieldsToPreserveTitle { get; }
    internal static string TypeHasNoFieldsToPreserveMessage { get; }
    internal static string TypeHasNoMethodsToPreserveTitle { get; }
    internal static string TypeHasNoMethodsToPreserveMessage { get; }
    internal static string CouldNotResolveDependencyAssemblyTitle { get; }
    internal static string CouldNotResolveDependencyAssemblyMessage { get; }
    internal static string CouldNotResolveDependencyTypeTitle { get; }
    internal static string CouldNotResolveDependencyTypeMessage { get; }
    internal static string CouldNotResolveDependencyMemberTitle { get; }
    internal static string CouldNotResolveDependencyMemberMessage { get; }
    internal static string XmlCouldNotResolveAssemblyTitle { get; }
    internal static string XmlCouldNotResolveAssemblyMessage { get; }
    internal static string XmlCouldNotResolveTypeTitle { get; }
    internal static string XmlCouldNotResolveTypeMessage { get; }
    internal static string XmlCouldNotFindMethodOnTypeTitle { get; }
    internal static string XmlCouldNotFindMethodOnTypeMessage { get; }
    internal static string XmlInvalidValueForStubTitle { get; }
    internal static string XmlInvalidValueForStubMessage { get; }
    internal static string XmlUnkownBodyModificationTitle { get; }
    internal static string XmlUnkownBodyModificationMessage { get; }
    internal static string XmlCouldNotFindFieldOnTypeTitle { get; }
    internal static string XmlCouldNotFindFieldOnTypeMessage { get; }
    internal static string XmlSubstitutedFieldNeedsToBeStaticTitle { get; }
    internal static string XmlSubstitutedFieldNeedsToBeStaticMessage { get; }
    internal static string XmlMissingSubstitutionValueForFieldTitle { get; }
    internal static string XmlMissingSubstitutionValueForFieldMessage { get; }
    internal static string XmlInvalidSubstitutionValueForFieldTitle { get; }
    internal static string XmlInvalidSubstitutionValueForFieldMessage { get; }
    internal static string XmlCouldNotFindEventOnTypeTitle { get; }
    internal static string XmlCouldNotFindEventOnTypeMessage { get; }
    internal static string XmlCouldNotFindPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindGetAccesorOfPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindGetAccesorOfPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindSetAccesorOfPropertyOnTypeTitle { get; }
    internal static string XmlCouldNotFindSetAccesorOfPropertyOnTypeMessage { get; }
    internal static string XmlCouldNotFindMatchingConstructorForCustomAttributeTitle { get; }
    internal static string XmlCouldNotFindMatchingConstructorForCustomAttributeMessage { get; }
    internal static string XmlMoreThanOneReturnElementForMethodTitle { get; }
    internal static string XmlMoreThanOneReturnElementForMethodMessage { get; }
    internal static string XmlMoreThanOneValyForParameterOfMethodTitle { get; }
    internal static string XmlMoreThanOneValyForParameterOfMethodMessage { get; }
    internal static string XmlDuplicatePreserveMemberTitle { get; }
    internal static string XmlDuplicatePreserveMemberMessage { get; }
    internal static string RequiresUnreferencedCodeTitle { get; }
    internal static string RequiresUnreferencedCodeMessage { get; }
    internal static string DynamicTypeInvocationTitle { get; }
    internal static string DynamicTypeInvocationMessage { get; }
    internal static string AttributeShouldOnlyBeUsedOnceOnMemberTitle { get; }
    internal static string AttributeShouldOnlyBeUsedOnceOnMemberMessage { get; }
    internal static string AttributeDoesntHaveTheRequiredNumberOfParametersTitle { get; }
    internal static string AttributeDoesntHaveTheRequiredNumberOfParametersMessage { get; }
    internal static string XmlElementDoesNotContainRequiredAttributeFullnameTitle { get; }
    internal static string XmlElementDoesNotContainRequiredAttributeFullnameMessage { get; }
    internal static string XmlCouldNotResolveAssemblyForAttributeTitle { get; }
    internal static string XmlCouldNotResolveAssemblyForAttributeMessage { get; }
    internal static string XmlAttributeTypeCouldNotBeFoundTitle { get; }
    internal static string XmlAttributeTypeCouldNotBeFoundMessage { get; }
    internal static string UnrecognizedParameterInMethodCreateInstanceTitle { get; }
    internal static string UnrecognizedParameterInMethodCreateInstanceMessage { get; }
    internal static string DeprecatedPreserveDependencyAttributeTitle { get; }
    internal static string DeprecatedPreserveDependencyAttributeMessage { get; }
    internal static string DynamicDependencyAttributeCouldNotBeAnalyzedTitle { get; }
    internal static string DynamicDependencyAttributeCouldNotBeAnalyzedMessage { get; }
    internal static string UnresolvedAssemblyInDynamicDependencyAttributeTitle { get; }
    internal static string UnresolvedAssemblyInDynamicDependencyAttributeMessage { get; }
    internal static string UnresolvedTypeInDynamicDependencyAttributeTitle { get; }
    internal static string UnresolvedTypeInDynamicDependencyAttributeMessage { get; }
    internal static string NoMembersResolvedForMemberSignatureOrTypeTitle { get; }
    internal static string NoMembersResolvedForMemberSignatureOrTypeMessage { get; }
    internal static string XmlMissingNameAttributeInResourceTitle { get; }
    internal static string XmlMissingNameAttributeInResourceMessage { get; }
    internal static string XmlInvalidValueForAttributeActionForResourceTitle { get; }
    internal static string XmlInvalidValueForAttributeActionForResourceMessage { get; }
    internal static string XmlCouldNotFindResourceToRemoveInAssemblyTitle { get; }
    internal static string XmlCouldNotFindResourceToRemoveInAssemblyMessage { get; }
    internal static string DynamicallyAccessedMembersIsNotAllowedOnMethodsTitle { get; }
    internal static string DynamicallyAccessedMembersIsNotAllowedOnMethodsMessage { get; }
    internal static string DynamicallyAccessedMembersCouldNotFindBackingFieldTitle { get; }
    internal static string DynamicallyAccessedMembersCouldNotFindBackingFieldMessage { get; }
    internal static string DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorTitle { get; }
    internal static string DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorMessage { get; }
    internal static string XmlCouldNotFindAnyTypeInNamespaceTitle { get; }
    internal static string XmlCouldNotFindAnyTypeInNamespaceMessage { get; }
    internal static string AttributeIsReferencedButTrimmerRemoveAllInstancesTitle { get; }
    internal static string AttributeIsReferencedButTrimmerRemoveAllInstancesMessage { get; }
    internal static string RequiresUnreferencedCodeAttributeMismatchTitle { get; }
    internal static string RequiresUnreferencedCodeAttributeMismatchMessage { get; }
    internal static string XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeTitle { get; }
    internal static string XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeMessage { get; }
    internal static string CorrectnessOfCOMCannotBeGuaranteedTitle { get; }
    internal static string CorrectnessOfCOMCannotBeGuaranteedMessage { get; }
    internal static string XmlPropertyDoesNotContainAttributeNameTitle { get; }
    internal static string XmlPropertyDoesNotContainAttributeNameMessage { get; }
    internal static string XmlCouldNotFindPropertyTitle { get; }
    internal static string XmlCouldNotFindPropertyMessage { get; }
    internal static string MakeGenericTypeTitle { get; }
    internal static string MakeGenericTypeMessage { get; }
    internal static string DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldTitle { get; }
    internal static string DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldMessage { get; }
    internal static string UnrecognizedTypeNameInTypeGetTypeTitle { get; }
    internal static string UnrecognizedTypeNameInTypeGetTypeMessage { get; }
    internal static string ParametersOfAssemblyCreateInstanceCannotBeAnalyzedTitle { get; }
    internal static string ParametersOfAssemblyCreateInstanceCannotBeAnalyzedMessage { get; }
    internal static string UnrecognizedTypeInRuntimeHelpersRunClassConstructorTitle { get; }
    internal static string UnrecognizedTypeInRuntimeHelpersRunClassConstructorMessage { get; }
    internal static string MakeGenericMethodTitle { get; }
    internal static string MakeGenericMethodMessage { get; }
    internal static string UnresolvedAssemblyInCreateInstanceTitle { get; }
    internal static string UnresolvedAssemblyInCreateInstanceMessage { get; }
    internal static string MethodParameterCannotBeStaticallyDeterminedTitle { get; }
    internal static string MethodParameterCannotBeStaticallyDeterminedMessage { get; }
    internal static string MethodReturnValueCannotBeStaticallyDeterminedTitle { get; }
    internal static string MethodReturnValueCannotBeStaticallyDeterminedMessage { get; }
    internal static string FieldValueCannotBeStaticallyDeterminedTitle { get; }
    internal static string FieldValueCannotBeStaticallyDeterminedMessage { get; }
    internal static string ImplicitThisCannotBeStaticallyDeterminedTitle { get; }
    internal static string ImplicitThisCannotBeStaticallyDeterminedMessage { get; }
    internal static string TypePassedToGenericParameterCannotBeStaticallyDeterminedTitle { get; }
    internal static string TypePassedToGenericParameterCannotBeStaticallyDeterminedMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesMessage { get; }
    internal static string DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesTitle { get; }
    internal static string DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesMessage { get; }
    internal static string CaseInsensitiveTypeGetTypeCallIsNotSupportedTitle { get; }
    internal static string CaseInsensitiveTypeGetTypeCallIsNotSupportedMessage { get; }
    internal static string DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string XmlUnsuportedWildcardTitle { get; }
    internal static string XmlUnsuportedWildcardMessage { get; }
    internal static string AssemblyWithEmbeddedXmlApplyToAnotherAssemblyTitle { get; }
    internal static string AssemblyWithEmbeddedXmlApplyToAnotherAssemblyMessage { get; }
    internal static string InvalidIsTrimmableValueTitle { get; }
    internal static string InvalidIsTrimmableValueMessage { get; }
    internal static string PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedTitle { get; }
    internal static string PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedMessage { get; }
    internal static string AssemblyProducedTrimWarningsTitle { get; }
    internal static string AssemblyProducedTrimWarningsMessage { get; }
    internal static string TypeWasNotFoundInAssemblyNorBaseLibraryTitle { get; }
    internal static string TypeWasNotFoundInAssemblyNorBaseLibraryMessage { get; }
    internal static string DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsTitle { get; }
    internal static string DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsMessage { get; }
    internal static string MethodsAreAssociatedWithStateMachineTitle { get; }
    internal static string MethodsAreAssociatedWithStateMachineMessage { get; }
    internal static string InvalidScopeInUnconditionalSuppressMessageTitle { get; }
    internal static string InvalidScopeInUnconditionalSuppressMessageMessage { get; }
    internal static string RequiresUnreferencedCodeOnBaseClassTitle { get; }
    internal static string RequiresUnreferencedCodeOnBaseClassMessage { get; }
    internal static string DynamicallyAccessedMembersFieldAccessedViaReflectionTitle { get; }
    internal static string DynamicallyAccessedMembersFieldAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersMethodAccessedViaReflectionTitle { get; }
    internal static string DynamicallyAccessedMembersMethodAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersMessage { get; }
    internal static string RequiresUnreferencedCodeOnStaticConstructorTitle { get; }
    internal static string RequiresUnreferencedCodeOnStaticConstructorMessage { get; }
    internal static string MethodsAreAssociatedWithUserMethodTitle { get; }
    internal static string MethodsAreAssociatedWithUserMethodMessage { get; }
    internal static string CompilerGeneratedMemberAccessedViaReflectionTitle { get; }
    internal static string CompilerGeneratedMemberAccessedViaReflectionMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberMessage { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseTitle { get; }
    internal static string DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseMessage { get; }
    internal static string AvoidAssemblyLocationInSingleFileTitle { get; }
    internal static string AvoidAssemblyLocationInSingleFileMessage { get; }
    internal static string AvoidAssemblyGetFilesInSingleFileTitle { get; }
    internal static string AvoidAssemblyGetFilesInSingleFileMessage { get; }
    internal static string RequiresAssemblyFilesTitle { get; }
    internal static string RequiresAssemblyFilesMessage { get; }
    internal static string RequiresAssemblyFilesAttributeMismatchTitle { get; }
    internal static string RequiresAssemblyFilesAttributeMismatchMessage { get; }
    internal static string RequiresDynamicCodeTitle { get; }
    internal static string RequiresDynamicCodeMessage { get; }
    internal static string RequiresDynamicCodeAttributeMismatchTitle { get; }
    internal static string RequiresDynamicCodeAttributeMismatchMessage { get; }
    internal static string COMInteropNotSupportedInFullAOTTitle { get; }
    internal static string COMInteropNotSupportedInFullAOTMessage { get; }
    internal static string AssemblyProducedAOTWarningsTitle { get; }
    internal static string AssemblyProducedAOTWarningsMessage { get; }
    internal static string GenericRecursionCycleTitle { get; }
    internal static string GenericRecursionCycleMessage { get; }
    internal static string CorrectnessOfAbstractDelegatesCannotBeGuaranteedTitle { get; }
    internal static string CorrectnessOfAbstractDelegatesCannotBeGuaranteedMessage { get; }
    internal static string BaseRequiresMismatchMessage { get; }
    internal static string DerivedRequiresMismatchMessage { get; }
    internal static string ImplementationRequiresMismatchMessage { get; }
    internal static string InterfaceRequiresMismatchMessage { get; }
    internal static string RequiresOnBaseClassMessage { get; }
    internal static string RequiresOnBaseClassTitle { get; }
    internal static string RequiresDynamicCodeOnStaticConstructorMessage { get; }
    internal static string RequiresDynamicCodeOnStaticConstructorTitle { get; }
    internal static string RequiresAssemblyFilesOnStaticConstructorMessage { get; }
    internal static string RequiresAssemblyFilesOnStaticConstructorTitle { get; }
    internal static string UnrecognizedInternalAttributeMessage { get; }
    internal static string UnrecognizedInternalAttributeTitle { get; }
    internal static string InvalidDependenciesFileFormatMessage { get; }
    internal static string InvalidDependenciesFileFormatTitle { get; }
    internal static string RedundantSuppressionMessage { get; }
    internal static string RedundantSuppressionTitle { get; }
    internal static ResourceManager get_ResourceManager();
    [CompilerGeneratedAttribute]
internal static CultureInfo get_Culture();
    [CompilerGeneratedAttribute]
internal static void set_Culture(CultureInfo value);
    internal static string GetResourceString(string resourceKey, string defaultValue);
    internal static string get_XmlFeatureDoesNotSpecifyFeatureValueTitle();
    internal static string get_XmlFeatureDoesNotSpecifyFeatureValueMessage();
    internal static string get_XmlUnsupportedNonBooleanValueForFeatureTitle();
    internal static string get_XmlUnsupportedNonBooleanValueForFeatureMessage();
    internal static string get_XmlExceptionTitle();
    internal static string get_XmlExceptionMessage();
    internal static string get_CouldNotFindMethodInAssemblyTitle();
    internal static string get_CouldNotFindMethodInAssemblyMessage();
    internal static string get_CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorTitle();
    internal static string get_CannotStubConstructorWhenBaseTypeDoesNotHaveConstructorMessage();
    internal static string get_CouldNotFindTypeTitle();
    internal static string get_CouldNotFindTypeMessage();
    internal static string get_CouldNotFindConstructorTitle();
    internal static string get_CouldNotFindConstructorMessage();
    internal static string get_CouldNotFindAssemblyReferenceTitle();
    internal static string get_CouldNotFindAssemblyReferenceMessage();
    internal static string get_CouldNotLoadAssemblyTitle();
    internal static string get_CouldNotLoadAssemblyMessage();
    internal static string get_FailedToWriteOutputTitle();
    internal static string get_FailedToWriteOutputMessage();
    internal static string get_LinkerUnexpectedErrorTitle();
    internal static string get_LinkerUnexpectedErrorMessage();
    internal static string get_ErrorProcessingXmlLocationTitle();
    internal static string get_ErrorProcessingXmlLocationMessage();
    internal static string get_XmlDocumentLocationHasInvalidFeatureDefaultTitle();
    internal static string get_XmlDocumentLocationHasInvalidFeatureDefaultMessage();
    internal static string get_UnrecognizedCommandLineOptionTitle();
    internal static string get_UnrecognizedCommandLineOptionMessage();
    internal static string get_InvalidWarningVersionTitle();
    internal static string get_InvalidWarningVersionMessage();
    internal static string get_InvalidGenerateWarningSuppressionsValueTitle();
    internal static string get_InvalidGenerateWarningSuppressionsValueMessage();
    internal static string get_MissingArgumentForCommanLineOptionNameTitle();
    internal static string get_MissingArgumentForCommanLineOptionNameMessage();
    internal static string get_CustomDataFormatIsInvalidTitle();
    internal static string get_CustomDataFormatIsInvalidMessage();
    internal static string get_NoFilesToLinkSpecifiedTitle();
    internal static string get_NoFilesToLinkSpecifiedMessage();
    internal static string get_NewMvidAndDeterministicCannotBeUsedAtSameTimeTitle();
    internal static string get_NewMvidAndDeterministicCannotBeUsedAtSameTimeMessage();
    internal static string get_AssemblyInCustomStepOptionCouldNotBeFoundTitle();
    internal static string get_AssemblyInCustomStepOptionCouldNotBeFoundMessage();
    internal static string get_AssemblyPathInCustomStepMustBeFullyQualifiedTitle();
    internal static string get_AssemblyPathInCustomStepMustBeFullyQualifiedMessage();
    internal static string get_InvalidArgForCustomStepTitle();
    internal static string get_InvalidArgForCustomStepMessage();
    internal static string get_ExpectedSignToControlNewStepInsertionTitle();
    internal static string get_ExpectedSignToControlNewStepInsertionMessage();
    internal static string get_PipelineStepCouldNotBeFoundTitle();
    internal static string get_PipelineStepCouldNotBeFoundMessage();
    internal static string get_CustomStepTypeCouldNotBeFoundTitle();
    internal static string get_CustomStepTypeCouldNotBeFoundMessage();
    internal static string get_CustomStepTypeIsIncompatibleWithLinkerVersionTitle();
    internal static string get_CustomStepTypeIsIncompatibleWithLinkerVersionMessage();
    internal static string get_InvalidOptimizationValueTitle();
    internal static string get_InvalidOptimizationValueMessage();
    internal static string get_InvalidArgumentForTokenOptionTitle();
    internal static string get_InvalidArgumentForTokenOptionMessage();
    internal static string get_InvalidAssemblyActionTitle();
    internal static string get_InvalidAssemblyActionMessage();
    internal static string get_RootAssemblyCouldNotBeFoundTitle();
    internal static string get_RootAssemblyCouldNotBeFoundMessage();
    internal static string get_XmlDescriptorCouldNotBeFoundTitle();
    internal static string get_XmlDescriptorCouldNotBeFoundMessage();
    internal static string get_RootAssemblyDoesNotHaveEntryPointTitle();
    internal static string get_RootAssemblyDoesNotHaveEntryPointMessage();
    internal static string get_RootAssemblyCannotUseActionTitle();
    internal static string get_RootAssemblyCannotUseActionMessage();
    internal static string get_InvalidAssemblyNameTitle();
    internal static string get_InvalidAssemblyNameMessage();
    internal static string get_InvalidAssemblyRootModeTitle();
    internal static string get_InvalidAssemblyRootModeMessage();
    internal static string get_ExportedTypeCannotBeResolvedTitle();
    internal static string get_ExportedTypeCannotBeResolvedMessage();
    internal static string get_ReferenceAssemblyCouldNotBeLoadedTitle();
    internal static string get_ReferenceAssemblyCouldNotBeLoadedMessage();
    internal static string get_FailedToResolveMetadataElementTitle();
    internal static string get_FailedToResolveMetadataElementMessage();
    internal static string get_FailedToResolveFieldElementTitle();
    internal static string get_FailedToResolveFieldElementMessage();
    internal static string get_FailedToResolveMethodElementTitle();
    internal static string get_FailedToResolveMethodElementMessage();
    internal static string get_FailedToResolveTypeElementTitle();
    internal static string get_FailedToResolveTypeElementMessage();
    internal static string get_TypeUsedWithAttributeValueCouldNotBeFoundTitle();
    internal static string get_TypeUsedWithAttributeValueCouldNotBeFoundMessage();
    internal static string get_CannotConverValueToTypeTitle();
    internal static string get_CannotConverValueToTypeMessage();
    internal static string get_CustomAttributeArgumentForTypeRequiresNestedNodeTitle();
    internal static string get_CustomAttributeArgumentForTypeRequiresNestedNodeMessage();
    internal static string get_CouldNotResolveCustomAttributeTypeValueTitle();
    internal static string get_CouldNotResolveCustomAttributeTypeValueMessage();
    internal static string get_UnexpectedAttributeArgumentTypeTitle();
    internal static string get_UnexpectedAttributeArgumentTypeMessage();
    internal static string get_InvalidMetadataOptionTitle();
    internal static string get_InvalidMetadataOptionMessage();
    internal static string get_TypeHasNoFieldsToPreserveTitle();
    internal static string get_TypeHasNoFieldsToPreserveMessage();
    internal static string get_TypeHasNoMethodsToPreserveTitle();
    internal static string get_TypeHasNoMethodsToPreserveMessage();
    internal static string get_CouldNotResolveDependencyAssemblyTitle();
    internal static string get_CouldNotResolveDependencyAssemblyMessage();
    internal static string get_CouldNotResolveDependencyTypeTitle();
    internal static string get_CouldNotResolveDependencyTypeMessage();
    internal static string get_CouldNotResolveDependencyMemberTitle();
    internal static string get_CouldNotResolveDependencyMemberMessage();
    internal static string get_XmlCouldNotResolveAssemblyTitle();
    internal static string get_XmlCouldNotResolveAssemblyMessage();
    internal static string get_XmlCouldNotResolveTypeTitle();
    internal static string get_XmlCouldNotResolveTypeMessage();
    internal static string get_XmlCouldNotFindMethodOnTypeTitle();
    internal static string get_XmlCouldNotFindMethodOnTypeMessage();
    internal static string get_XmlInvalidValueForStubTitle();
    internal static string get_XmlInvalidValueForStubMessage();
    internal static string get_XmlUnkownBodyModificationTitle();
    internal static string get_XmlUnkownBodyModificationMessage();
    internal static string get_XmlCouldNotFindFieldOnTypeTitle();
    internal static string get_XmlCouldNotFindFieldOnTypeMessage();
    internal static string get_XmlSubstitutedFieldNeedsToBeStaticTitle();
    internal static string get_XmlSubstitutedFieldNeedsToBeStaticMessage();
    internal static string get_XmlMissingSubstitutionValueForFieldTitle();
    internal static string get_XmlMissingSubstitutionValueForFieldMessage();
    internal static string get_XmlInvalidSubstitutionValueForFieldTitle();
    internal static string get_XmlInvalidSubstitutionValueForFieldMessage();
    internal static string get_XmlCouldNotFindEventOnTypeTitle();
    internal static string get_XmlCouldNotFindEventOnTypeMessage();
    internal static string get_XmlCouldNotFindPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindGetAccesorOfPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindGetAccesorOfPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindSetAccesorOfPropertyOnTypeTitle();
    internal static string get_XmlCouldNotFindSetAccesorOfPropertyOnTypeMessage();
    internal static string get_XmlCouldNotFindMatchingConstructorForCustomAttributeTitle();
    internal static string get_XmlCouldNotFindMatchingConstructorForCustomAttributeMessage();
    internal static string get_XmlMoreThanOneReturnElementForMethodTitle();
    internal static string get_XmlMoreThanOneReturnElementForMethodMessage();
    internal static string get_XmlMoreThanOneValyForParameterOfMethodTitle();
    internal static string get_XmlMoreThanOneValyForParameterOfMethodMessage();
    internal static string get_XmlDuplicatePreserveMemberTitle();
    internal static string get_XmlDuplicatePreserveMemberMessage();
    internal static string get_RequiresUnreferencedCodeTitle();
    internal static string get_RequiresUnreferencedCodeMessage();
    internal static string get_DynamicTypeInvocationTitle();
    internal static string get_DynamicTypeInvocationMessage();
    internal static string get_AttributeShouldOnlyBeUsedOnceOnMemberTitle();
    internal static string get_AttributeShouldOnlyBeUsedOnceOnMemberMessage();
    internal static string get_AttributeDoesntHaveTheRequiredNumberOfParametersTitle();
    internal static string get_AttributeDoesntHaveTheRequiredNumberOfParametersMessage();
    internal static string get_XmlElementDoesNotContainRequiredAttributeFullnameTitle();
    internal static string get_XmlElementDoesNotContainRequiredAttributeFullnameMessage();
    internal static string get_XmlCouldNotResolveAssemblyForAttributeTitle();
    internal static string get_XmlCouldNotResolveAssemblyForAttributeMessage();
    internal static string get_XmlAttributeTypeCouldNotBeFoundTitle();
    internal static string get_XmlAttributeTypeCouldNotBeFoundMessage();
    internal static string get_UnrecognizedParameterInMethodCreateInstanceTitle();
    internal static string get_UnrecognizedParameterInMethodCreateInstanceMessage();
    internal static string get_DeprecatedPreserveDependencyAttributeTitle();
    internal static string get_DeprecatedPreserveDependencyAttributeMessage();
    internal static string get_DynamicDependencyAttributeCouldNotBeAnalyzedTitle();
    internal static string get_DynamicDependencyAttributeCouldNotBeAnalyzedMessage();
    internal static string get_UnresolvedAssemblyInDynamicDependencyAttributeTitle();
    internal static string get_UnresolvedAssemblyInDynamicDependencyAttributeMessage();
    internal static string get_UnresolvedTypeInDynamicDependencyAttributeTitle();
    internal static string get_UnresolvedTypeInDynamicDependencyAttributeMessage();
    internal static string get_NoMembersResolvedForMemberSignatureOrTypeTitle();
    internal static string get_NoMembersResolvedForMemberSignatureOrTypeMessage();
    internal static string get_XmlMissingNameAttributeInResourceTitle();
    internal static string get_XmlMissingNameAttributeInResourceMessage();
    internal static string get_XmlInvalidValueForAttributeActionForResourceTitle();
    internal static string get_XmlInvalidValueForAttributeActionForResourceMessage();
    internal static string get_XmlCouldNotFindResourceToRemoveInAssemblyTitle();
    internal static string get_XmlCouldNotFindResourceToRemoveInAssemblyMessage();
    internal static string get_DynamicallyAccessedMembersIsNotAllowedOnMethodsTitle();
    internal static string get_DynamicallyAccessedMembersIsNotAllowedOnMethodsMessage();
    internal static string get_DynamicallyAccessedMembersCouldNotFindBackingFieldTitle();
    internal static string get_DynamicallyAccessedMembersCouldNotFindBackingFieldMessage();
    internal static string get_DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorTitle();
    internal static string get_DynamicallyAccessedMembersConflictsBetweenPropertyAndAccessorMessage();
    internal static string get_XmlCouldNotFindAnyTypeInNamespaceTitle();
    internal static string get_XmlCouldNotFindAnyTypeInNamespaceMessage();
    internal static string get_AttributeIsReferencedButTrimmerRemoveAllInstancesTitle();
    internal static string get_AttributeIsReferencedButTrimmerRemoveAllInstancesMessage();
    internal static string get_RequiresUnreferencedCodeAttributeMismatchTitle();
    internal static string get_RequiresUnreferencedCodeAttributeMismatchMessage();
    internal static string get_XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeTitle();
    internal static string get_XmlRemoveAttributeInstancesCanOnlyBeUsedOnTypeMessage();
    internal static string get_CorrectnessOfCOMCannotBeGuaranteedTitle();
    internal static string get_CorrectnessOfCOMCannotBeGuaranteedMessage();
    internal static string get_XmlPropertyDoesNotContainAttributeNameTitle();
    internal static string get_XmlPropertyDoesNotContainAttributeNameMessage();
    internal static string get_XmlCouldNotFindPropertyTitle();
    internal static string get_XmlCouldNotFindPropertyMessage();
    internal static string get_MakeGenericTypeTitle();
    internal static string get_MakeGenericTypeMessage();
    internal static string get_DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldTitle();
    internal static string get_DynamicallyAccessedMembersOnPropertyConflictsWithBackingFieldMessage();
    internal static string get_UnrecognizedTypeNameInTypeGetTypeTitle();
    internal static string get_UnrecognizedTypeNameInTypeGetTypeMessage();
    internal static string get_ParametersOfAssemblyCreateInstanceCannotBeAnalyzedTitle();
    internal static string get_ParametersOfAssemblyCreateInstanceCannotBeAnalyzedMessage();
    internal static string get_UnrecognizedTypeInRuntimeHelpersRunClassConstructorTitle();
    internal static string get_UnrecognizedTypeInRuntimeHelpersRunClassConstructorMessage();
    internal static string get_MakeGenericMethodTitle();
    internal static string get_MakeGenericMethodMessage();
    internal static string get_UnresolvedAssemblyInCreateInstanceTitle();
    internal static string get_UnresolvedAssemblyInCreateInstanceMessage();
    internal static string get_MethodParameterCannotBeStaticallyDeterminedTitle();
    internal static string get_MethodParameterCannotBeStaticallyDeterminedMessage();
    internal static string get_MethodReturnValueCannotBeStaticallyDeterminedTitle();
    internal static string get_MethodReturnValueCannotBeStaticallyDeterminedMessage();
    internal static string get_FieldValueCannotBeStaticallyDeterminedTitle();
    internal static string get_FieldValueCannotBeStaticallyDeterminedMessage();
    internal static string get_ImplicitThisCannotBeStaticallyDeterminedTitle();
    internal static string get_ImplicitThisCannotBeStaticallyDeterminedMessage();
    internal static string get_TypePassedToGenericParameterCannotBeStaticallyDeterminedTitle();
    internal static string get_TypePassedToGenericParameterCannotBeStaticallyDeterminedMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchParameterTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchMethodReturnTypeTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchFieldTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchThisParameterTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsMethodReturnTypeMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsFieldMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsThisParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterTitle();
    internal static string get_DynamicallyAccessedMembersMismatchTypeArgumentTargetsGenericParameterMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodParameterBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnMethodReturnValueBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnImplicitThisBetweenOverridesMessage();
    internal static string get_DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesTitle();
    internal static string get_DynamicallyAccessedMembersMismatchOnGenericParameterBetweenOverridesMessage();
    internal static string get_CaseInsensitiveTypeGetTypeCallIsNotSupportedTitle();
    internal static string get_CaseInsensitiveTypeGetTypeCallIsNotSupportedMessage();
    internal static string get_DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnFieldCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnMethodParameterCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnPropertyCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_XmlUnsuportedWildcardTitle();
    internal static string get_XmlUnsuportedWildcardMessage();
    internal static string get_AssemblyWithEmbeddedXmlApplyToAnotherAssemblyTitle();
    internal static string get_AssemblyWithEmbeddedXmlApplyToAnotherAssemblyMessage();
    internal static string get_InvalidIsTrimmableValueTitle();
    internal static string get_InvalidIsTrimmableValueMessage();
    internal static string get_PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedTitle();
    internal static string get_PropertyAccessorParameterInLinqExpressionsCannotBeStaticallyDeterminedMessage();
    internal static string get_AssemblyProducedTrimWarningsTitle();
    internal static string get_AssemblyProducedTrimWarningsMessage();
    internal static string get_TypeWasNotFoundInAssemblyNorBaseLibraryTitle();
    internal static string get_TypeWasNotFoundInAssemblyNorBaseLibraryMessage();
    internal static string get_DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsTitle();
    internal static string get_DynamicallyAccessedMembersOnMethodReturnValueCanOnlyApplyToTypesOrStringsMessage();
    internal static string get_MethodsAreAssociatedWithStateMachineTitle();
    internal static string get_MethodsAreAssociatedWithStateMachineMessage();
    internal static string get_InvalidScopeInUnconditionalSuppressMessageTitle();
    internal static string get_InvalidScopeInUnconditionalSuppressMessageMessage();
    internal static string get_RequiresUnreferencedCodeOnBaseClassTitle();
    internal static string get_RequiresUnreferencedCodeOnBaseClassMessage();
    internal static string get_DynamicallyAccessedMembersFieldAccessedViaReflectionTitle();
    internal static string get_DynamicallyAccessedMembersFieldAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersMethodAccessedViaReflectionTitle();
    internal static string get_DynamicallyAccessedMembersMethodAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithRequiresUnreferencedCodeMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithRequiresUnreferencedCodeMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberWithDynamicallyAccessedMembersMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesMemberOnBaseWithDynamicallyAccessedMembersMessage();
    internal static string get_RequiresUnreferencedCodeOnStaticConstructorTitle();
    internal static string get_RequiresUnreferencedCodeOnStaticConstructorMessage();
    internal static string get_MethodsAreAssociatedWithUserMethodTitle();
    internal static string get_MethodsAreAssociatedWithUserMethodMessage();
    internal static string get_CompilerGeneratedMemberAccessedViaReflectionTitle();
    internal static string get_CompilerGeneratedMemberAccessedViaReflectionMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberMessage();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseTitle();
    internal static string get_DynamicallyAccessedMembersOnTypeReferencesCompilerGeneratedMemberOnBaseMessage();
    internal static string get_AvoidAssemblyLocationInSingleFileTitle();
    internal static string get_AvoidAssemblyLocationInSingleFileMessage();
    internal static string get_AvoidAssemblyGetFilesInSingleFileTitle();
    internal static string get_AvoidAssemblyGetFilesInSingleFileMessage();
    internal static string get_RequiresAssemblyFilesTitle();
    internal static string get_RequiresAssemblyFilesMessage();
    internal static string get_RequiresAssemblyFilesAttributeMismatchTitle();
    internal static string get_RequiresAssemblyFilesAttributeMismatchMessage();
    internal static string get_RequiresDynamicCodeTitle();
    internal static string get_RequiresDynamicCodeMessage();
    internal static string get_RequiresDynamicCodeAttributeMismatchTitle();
    internal static string get_RequiresDynamicCodeAttributeMismatchMessage();
    internal static string get_COMInteropNotSupportedInFullAOTTitle();
    internal static string get_COMInteropNotSupportedInFullAOTMessage();
    internal static string get_AssemblyProducedAOTWarningsTitle();
    internal static string get_AssemblyProducedAOTWarningsMessage();
    internal static string get_GenericRecursionCycleTitle();
    internal static string get_GenericRecursionCycleMessage();
    internal static string get_CorrectnessOfAbstractDelegatesCannotBeGuaranteedTitle();
    internal static string get_CorrectnessOfAbstractDelegatesCannotBeGuaranteedMessage();
    internal static string get_BaseRequiresMismatchMessage();
    internal static string get_DerivedRequiresMismatchMessage();
    internal static string get_ImplementationRequiresMismatchMessage();
    internal static string get_InterfaceRequiresMismatchMessage();
    internal static string get_RequiresOnBaseClassMessage();
    internal static string get_RequiresOnBaseClassTitle();
    internal static string get_RequiresDynamicCodeOnStaticConstructorMessage();
    internal static string get_RequiresDynamicCodeOnStaticConstructorTitle();
    internal static string get_RequiresAssemblyFilesOnStaticConstructorMessage();
    internal static string get_RequiresAssemblyFilesOnStaticConstructorTitle();
    internal static string get_UnrecognizedInternalAttributeMessage();
    internal static string get_UnrecognizedInternalAttributeTitle();
    internal static string get_InvalidDependenciesFileFormatMessage();
    internal static string get_InvalidDependenciesFileFormatTitle();
    internal static string get_RedundantSuppressionMessage();
    internal static string get_RedundantSuppressionTitle();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.ArrayValue : SingleValue {
    [CompilerGeneratedAttribute]
private TypeReference <ElementType>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, ValueBasicBlockPair> <IndexValues>k__BackingField;
    public SingleValue Size;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public TypeReference ElementType { get; }
    public Dictionary`2<int, ValueBasicBlockPair> IndexValues { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueSetLattice`1<SingleValue> MultiValueLattice { get; }
    private ArrayValue(SingleValue size, TypeReference elementType);
    [CompilerGeneratedAttribute]
private ArrayValue(ArrayValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public static ValueSet`1<SingleValue> Create(ValueSet`1<SingleValue> size, TypeReference elementType);
    public static ArrayValue Create(int size, TypeReference elementType);
    [CompilerGeneratedAttribute]
public TypeReference get_ElementType();
    [CompilerGeneratedAttribute]
public Dictionary`2<int, ValueBasicBlockPair> get_IndexValues();
    public virtual int GetHashCode();
    [NullableContextAttribute("2")]
public sealed virtual bool Equals(ArrayValue otherArr);
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    private static ValueSetLattice`1<SingleValue> get_MultiValueLattice();
    public bool TryGetValueByIndex(int index, ValueSet`1& value);
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ArrayValue left, ArrayValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ArrayValue left, ArrayValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ArrayValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.ConstIntValue : SingleValue {
    public int Value;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ConstIntValue(int value);
    [CompilerGeneratedAttribute]
private ConstIntValue(ConstIntValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ConstIntValue left, ConstIntValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ConstIntValue left, ConstIntValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ConstIntValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ConstIntValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class ILLink.Shared.TrimAnalysis.DiagnosticContext : ValueType {
    public MessageOrigin Origin;
    public bool DiagnosticsEnabled;
    private LinkContext _context;
    public DiagnosticContext(MessageOrigin& origin, bool diagnosticsEnabled, LinkContext context);
    public void AddDiagnostic(DiagnosticId id, String[] args);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.TrimAnalysis.FieldReferenceValue : ReferenceValue {
    [CompilerGeneratedAttribute]
private FieldDefinition <FieldDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public FieldDefinition FieldDefinition { get; public set; }
    public FieldReferenceValue(FieldDefinition FieldDefinition);
    [CompilerGeneratedAttribute]
protected FieldReferenceValue(FieldReferenceValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public FieldDefinition get_FieldDefinition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FieldDefinition(FieldDefinition value);
    public virtual SingleValue DeepCopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FieldReferenceValue left, FieldReferenceValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FieldReferenceValue left, FieldReferenceValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(FieldReferenceValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override FieldReferenceValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(FieldDefinition& FieldDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.FieldValue : ValueWithDynamicallyAccessedMembers {
    public FieldDefinition Field;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TypeDefinition <StaticType>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [NullableAttribute("2")]
public TypeDefinition StaticType { get; }
    public FieldValue(TypeDefinition staticType, FieldDefinition fieldToLoad, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private FieldValue(FieldValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual TypeDefinition get_StaticType();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(FieldValue left, FieldValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(FieldValue left, FieldValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(FieldValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override FieldValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.FlowAnnotations : object {
    private LinkContext _context;
    private Dictionary`2<TypeDefinition, TypeAnnotations> _annotations;
    private TypeHierarchyCache _hierarchyInfo;
    public FlowAnnotations(LinkContext context);
    public bool RequiresDataFlowAnalysis(MethodDefinition method);
    public bool RequiresVirtualMethodDataFlowAnalysis(MethodDefinition method);
    public bool RequiresDataFlowAnalysis(FieldDefinition field);
    public bool RequiresGenericArgumentDataFlowAnalysis(GenericParameter genericParameter);
    public DynamicallyAccessedMemberTypes GetParameterAnnotation(MethodDefinition method, int parameterIndex);
    public DynamicallyAccessedMemberTypes GetReturnParameterAnnotation(MethodDefinition method);
    public DynamicallyAccessedMemberTypes GetFieldAnnotation(FieldDefinition field);
    public DynamicallyAccessedMemberTypes GetTypeAnnotation(TypeDefinition type);
    public bool ShouldWarnWhenAccessedForReflection(IMemberDefinition provider);
    public DynamicallyAccessedMemberTypes GetGenericParameterAnnotation(GenericParameter genericParameter);
    public bool ShouldWarnWhenAccessedForReflection(MethodDefinition method);
    public bool ShouldWarnWhenAccessedForReflection(FieldDefinition field);
    public bool IsTypeInterestingForDataflow(TypeReference typeReference);
    private TypeAnnotations GetAnnotations(TypeDefinition type);
    private static bool IsDynamicallyAccessedMembersAttribute(CustomAttribute attribute);
    private DynamicallyAccessedMemberTypes GetMemberTypesForDynamicallyAccessedMembersAttribute(IMemberDefinition member, ICustomAttributeProvider providerIfNotMember);
    private TypeAnnotations BuildTypeAnnotations(TypeDefinition type);
    private IReadOnlyList`1<ICustomAttributeProvider> GetGeneratedTypeAttributes(TypeDefinition typeDef);
    private bool ScanMethodBodyForFieldAccess(MethodBody body, bool write, FieldDefinition& found);
    internal void ValidateMethodAnnotationsAreSame(MethodDefinition method, MethodDefinition baseMethod);
    private void ValidateMethodParametersHaveNoAnnotations(DynamicallyAccessedMemberTypes[] parameterAnnotations, MethodDefinition method, MethodDefinition baseMethod, IMemberDefinition origin);
    private void ValidateMethodGenericParametersHaveNoAnnotations(DynamicallyAccessedMemberTypes[] genericParameterAnnotations, MethodDefinition method, MethodDefinition baseMethod, IMemberDefinition origin);
    private void LogValidationWarning(IMetadataTokenProvider provider, IMetadataTokenProvider baseProvider, IMemberDefinition origin);
    internal SingleValue GetFieldValue(FieldDefinition field);
    internal SingleValue GetTypeValueFromGenericArgument(TypeReference genericArgument);
    internal bool MethodRequiresDataFlowAnalysis(MethodProxy method);
    internal MethodReturnValue GetMethodReturnValue(MethodProxy method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodReturnValue GetMethodReturnValue(MethodProxy method);
    internal GenericParameterValue GetGenericParameterValue(GenericParameterProxy genericParameter);
    internal MethodThisParameterValue GetMethodThisParameterValue(MethodProxy method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodThisParameterValue GetMethodThisParameterValue(MethodProxy method);
    internal MethodParameterValue GetMethodParameterValue(MethodProxy method, int parameterIndex, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    internal MethodParameterValue GetMethodParameterValue(MethodProxy method, int parameterIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.GenericParameterValue : ValueWithDynamicallyAccessedMembers {
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    public GenericParameterProxy GenericParameter;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public GenericParameterValue(GenericParameter genericParameter, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private GenericParameterValue(GenericParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(GenericParameterValue left, GenericParameterValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(GenericParameterValue left, GenericParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(GenericParameterValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override GenericParameterValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.HandleCallAction : ValueType {
    private LinkContext _context;
    private ReflectionMarker _reflectionMarker;
    private MethodDefinition _callingMethodDefinition;
    private DiagnosticContext _diagnosticContext;
    private FlowAnnotations _annotations;
    private RequireDynamicallyAccessedMembersAction _requireDynamicallyAccessedMembersAction;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private static ValueSetLattice`1<SingleValue> MultiValueLattice { get; }
    public HandleCallAction(LinkContext context, ReflectionMarker reflectionMarker, DiagnosticContext& diagnosticContext, MethodDefinition callingMethodDefinition);
    private static ValueSetLattice`1<SingleValue> get_MultiValueLattice();
    public bool Invoke(MethodProxy calledMethod, ValueSet`1<SingleValue> instanceValue, IReadOnlyList`1<ValueSet`1<SingleValue>> argumentValues, ValueSet`1& methodReturnValue, IntrinsicId& intrinsicId);
    [IteratorStateMachineAttribute("ILLink.Shared.TrimAnalysis.HandleCallAction/<ProcessGetMethodByName>d__10")]
private IEnumerable`1<ValueSet`1<SingleValue>> ProcessGetMethodByName(TypeProxy type, string methodName, Nullable`1<BindingFlags> bindingFlags);
    private bool AnalyzeGenericInstantiationTypeArray(ValueSet`1& arrayParam, MethodProxy& calledMethod, ImmutableArray`1<GenericParameterValue> genericParameters);
    private void ValidateGenericMethodInstantiation(MethodProxy genericMethod, ValueSet`1& genericParametersArray, MethodProxy reflectionMethod);
    [NullableContextAttribute("0")]
private ImmutableArray`1<GenericParameterValue> GetGenericParameterValues(ImmutableArray`1<GenericParameterProxy> genericParameters);
    private void ProcessCreateInstanceByName(MethodProxy calledMethod, IReadOnlyList`1<ValueSet`1<SingleValue>> argumentValues);
    internal static Nullable`1<BindingFlags> GetBindingFlagsFromValue(ValueSet`1& parameter);
    internal static bool BindingFlagsAreUnsupported(Nullable`1<BindingFlags> bindingFlags);
    internal static bool HasBindingFlag(Nullable`1<BindingFlags> bindingFlags, Nullable`1<BindingFlags> search);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForNestedTypes(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForConstructors(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForMethods(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForFields(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForProperties(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForEvents(Nullable`1<BindingFlags> bindingFlags);
    internal static DynamicallyAccessedMemberTypes GetDynamicallyAccessedMemberTypesFromBindingFlagsForMembers(Nullable`1<BindingFlags> bindingFlags);
    private bool MethodIsTypeConstructor(MethodProxy method);
    private IEnumerable`1<SystemReflectionMethodBaseValue> GetMethodsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private IEnumerable`1<SystemTypeValue> GetNestedTypesOnType(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private bool TryGetBaseType(TypeProxy type, Nullable`1& baseType);
    private bool TryResolveTypeNameForCreateInstanceAndMark(MethodProxy& calledMethod, string assemblyName, string typeName, TypeProxy& resolvedType);
    private void MarkStaticConstructor(TypeProxy type);
    private void MarkEventsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkFieldsOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkPropertiesOnTypeHierarchy(TypeProxy type, string name, Nullable`1<BindingFlags> bindingFlags);
    private void MarkPublicParameterlessConstructorOnType(TypeProxy type);
    private void MarkConstructorsOnType(TypeProxy type, Nullable`1<BindingFlags> bindingFlags, Nullable`1<int> parameterCount);
    private void MarkMethod(MethodProxy method);
    private void MarkType(TypeProxy type);
    private bool MarkAssociatedProperty(MethodProxy method);
    private string GetContainingSymbolDisplayName();
    [CompilerGeneratedAttribute]
internal static void <Invoke>g__AddReturnValue|9_0(ValueSet`1<SingleValue> value, <>c__DisplayClass9_0& );
    [CompilerGeneratedAttribute]
internal static DynamicallyAccessedMemberTypes <AnalyzeGenericInstantiationTypeArray>g__GetGenericParameterEffectiveMemberTypes|11_0(GenericParameterValue genericParameter);
}
internal enum ILLink.Shared.TrimAnalysis.IntrinsicId : Enum {
    public int value__;
    public static IntrinsicId None;
    public static IntrinsicId IntrospectionExtensions_GetTypeInfo;
    public static IntrinsicId Type_GetTypeFromHandle;
    public static IntrinsicId Type_get_TypeHandle;
    public static IntrinsicId Object_GetType;
    public static IntrinsicId TypeDelegator_Ctor;
    public static IntrinsicId Array_Empty;
    public static IntrinsicId TypeInfo_AsType;
    public static IntrinsicId MethodBase_GetMethodFromHandle;
    public static IntrinsicId MethodBase_get_MethodHandle;
    public static IntrinsicId RequiresReflectionBodyScanner_Sentinel;
    public static IntrinsicId Type_MakeGenericType;
    public static IntrinsicId Type_GetType;
    public static IntrinsicId Type_GetConstructor;
    public static IntrinsicId Type_GetConstructors;
    public static IntrinsicId Type_GetMethod;
    public static IntrinsicId Type_GetMethods;
    public static IntrinsicId Type_GetField;
    public static IntrinsicId Type_GetFields;
    public static IntrinsicId Type_GetProperty;
    public static IntrinsicId Type_GetProperties;
    public static IntrinsicId Type_GetEvent;
    public static IntrinsicId Type_GetEvents;
    public static IntrinsicId Type_GetNestedType;
    public static IntrinsicId Type_GetNestedTypes;
    public static IntrinsicId Type_GetMember;
    public static IntrinsicId Type_GetMembers;
    public static IntrinsicId Type_GetInterface;
    public static IntrinsicId Type_get_AssemblyQualifiedName;
    public static IntrinsicId Type_get_UnderlyingSystemType;
    public static IntrinsicId Type_get_BaseType;
    public static IntrinsicId Expression_Call;
    public static IntrinsicId Expression_Field;
    public static IntrinsicId Expression_Property;
    public static IntrinsicId Expression_New;
    public static IntrinsicId Enum_GetValues;
    public static IntrinsicId Marshal_SizeOf;
    public static IntrinsicId Marshal_OffsetOf;
    public static IntrinsicId Marshal_PtrToStructure;
    public static IntrinsicId Marshal_DestroyStructure;
    public static IntrinsicId Marshal_GetDelegateForFunctionPointer;
    public static IntrinsicId Activator_CreateInstance_Type;
    public static IntrinsicId Activator_CreateInstance_AssemblyName_TypeName;
    public static IntrinsicId Activator_CreateInstanceFrom;
    public static IntrinsicId AppDomain_CreateInstance;
    public static IntrinsicId AppDomain_CreateInstanceAndUnwrap;
    public static IntrinsicId AppDomain_CreateInstanceFrom;
    public static IntrinsicId AppDomain_CreateInstanceFromAndUnwrap;
    public static IntrinsicId Assembly_CreateInstance;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeEvent;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeField;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeMethod;
    public static IntrinsicId RuntimeReflectionExtensions_GetRuntimeProperty;
    public static IntrinsicId RuntimeHelpers_RunClassConstructor;
    public static IntrinsicId MethodInfo_MakeGenericMethod;
    public static IntrinsicId Nullable_GetUnderlyingType;
}
internal static class ILLink.Shared.TrimAnalysis.Intrinsics : object {
    public static IntrinsicId GetIntrinsicIdForMethod(MethodProxy calledMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.KnownStringValue : SingleValue {
    public string Contents;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public KnownStringValue(string contents);
    [CompilerGeneratedAttribute]
private KnownStringValue(KnownStringValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(KnownStringValue left, KnownStringValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(KnownStringValue left, KnownStringValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(KnownStringValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override KnownStringValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.TrimAnalysis.LocalVariableReferenceValue : ReferenceValue {
    [CompilerGeneratedAttribute]
private VariableDefinition <LocalDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public VariableDefinition LocalDefinition { get; public set; }
    public LocalVariableReferenceValue(VariableDefinition LocalDefinition);
    [CompilerGeneratedAttribute]
protected LocalVariableReferenceValue(LocalVariableReferenceValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public VariableDefinition get_LocalDefinition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_LocalDefinition(VariableDefinition value);
    public virtual SingleValue DeepCopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(LocalVariableReferenceValue left, LocalVariableReferenceValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(LocalVariableReferenceValue left, LocalVariableReferenceValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(LocalVariableReferenceValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override LocalVariableReferenceValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(VariableDefinition& LocalDefinition);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.MethodParameterValue : ValueWithDynamicallyAccessedMembers {
    public MethodDefinition Method;
    public int ParameterIndex;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TypeDefinition <StaticType>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public ParameterDefinition ParameterDefinition { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [NullableAttribute("2")]
public TypeDefinition StaticType { get; }
    public MethodParameterValue(TypeDefinition staticType, MethodDefinition method, int parameterIndex, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private MethodParameterValue(MethodParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public ParameterDefinition get_ParameterDefinition();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual TypeDefinition get_StaticType();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MethodParameterValue left, MethodParameterValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MethodParameterValue left, MethodParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodParameterValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MethodParameterValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.MethodReturnValue : ValueWithDynamicallyAccessedMembers {
    public MethodDefinition Method;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private TypeDefinition <StaticType>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [NullableAttribute("2")]
public TypeDefinition StaticType { get; }
    public MethodReturnValue(TypeDefinition staticType, MethodDefinition method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private MethodReturnValue(MethodReturnValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual TypeDefinition get_StaticType();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MethodReturnValue left, MethodReturnValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MethodReturnValue left, MethodReturnValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodReturnValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MethodReturnValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.MethodThisParameterValue : ValueWithDynamicallyAccessedMembers {
    public MethodDefinition Method;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <DynamicallyAccessedMemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [NullableAttribute("2")]
public TypeDefinition StaticType { get; }
    public MethodThisParameterValue(MethodDefinition method, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    [CompilerGeneratedAttribute]
private MethodThisParameterValue(MethodThisParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [NullableContextAttribute("2")]
public sealed virtual TypeDefinition get_StaticType();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(MethodThisParameterValue left, MethodThisParameterValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(MethodThisParameterValue left, MethodThisParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodThisParameterValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override MethodThisParameterValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.NullableSystemTypeValue : SingleValue {
    public TypeProxy NullableType;
    public SystemTypeValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public NullableSystemTypeValue(TypeProxy& nullableType, SystemTypeValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private NullableSystemTypeValue(NullableSystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NullableSystemTypeValue left, NullableSystemTypeValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NullableSystemTypeValue left, NullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullableSystemTypeValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override NullableSystemTypeValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.NullableValueWithDynamicallyAccessedMembers : ValueWithDynamicallyAccessedMembers {
    public TypeProxy NullableType;
    public ValueWithDynamicallyAccessedMembers UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    public NullableValueWithDynamicallyAccessedMembers(TypeProxy& nullableType, ValueWithDynamicallyAccessedMembers& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private NullableValueWithDynamicallyAccessedMembers(NullableValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NullableValueWithDynamicallyAccessedMembers left, NullableValueWithDynamicallyAccessedMembers right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NullableValueWithDynamicallyAccessedMembers left, NullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullableValueWithDynamicallyAccessedMembers other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override NullableValueWithDynamicallyAccessedMembers <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.NullValue : SingleValue {
    [CompilerGeneratedAttribute]
private static NullValue <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public static NullValue Instance { get; }
    [CompilerGeneratedAttribute]
private NullValue(NullValue original);
    private static NullValue();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public static NullValue get_Instance();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(NullValue left, NullValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(NullValue left, NullValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(NullValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override NullValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class ILLink.Shared.TrimAnalysis.ParameterReferenceValue : ReferenceValue {
    [CompilerGeneratedAttribute]
private MethodDefinition <MethodDefinition>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ParameterIndex>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public MethodDefinition MethodDefinition { get; public set; }
    public int ParameterIndex { get; public set; }
    public ParameterReferenceValue(MethodDefinition MethodDefinition, int ParameterIndex);
    [CompilerGeneratedAttribute]
protected ParameterReferenceValue(ParameterReferenceValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public MethodDefinition get_MethodDefinition();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_MethodDefinition(MethodDefinition value);
    [CompilerGeneratedAttribute]
public int get_ParameterIndex();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_ParameterIndex(int value);
    public virtual SingleValue DeepCopy();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ParameterReferenceValue left, ParameterReferenceValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ParameterReferenceValue left, ParameterReferenceValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(ReferenceValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ParameterReferenceValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override ParameterReferenceValue <Clone>$();
    [CompilerGeneratedAttribute]
public void Deconstruct(MethodDefinition& MethodDefinition, Int32& ParameterIndex);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.Shared.TrimAnalysis.ReferenceValue : SingleValue {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    [CompilerGeneratedAttribute]
protected ReferenceValue(ReferenceValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ReferenceValue left, ReferenceValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ReferenceValue left, ReferenceValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ReferenceValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override ReferenceValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RequireDynamicallyAccessedMembersAction : ValueType {
    private ReflectionMarker _reflectionMarker;
    private DiagnosticContext _diagnosticContext;
    public RequireDynamicallyAccessedMembersAction(ReflectionMarker reflectionMarker, DiagnosticContext& diagnosticContext);
    public void Invoke(ValueSet`1& value, ValueWithDynamicallyAccessedMembers targetValue);
    public bool TryResolveTypeNameAndMark(string typeName, bool needsAssemblyName, TypeProxy& type);
    private void MarkTypeForDynamicallyAccessedMembers(TypeProxy& type, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RuntimeMethodHandleValue : SingleValue {
    public MethodProxy RepresentedMethod;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeMethodHandleValue(MethodProxy& representedMethod);
    [CompilerGeneratedAttribute]
private RuntimeMethodHandleValue(RuntimeMethodHandleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeMethodHandleValue left, RuntimeMethodHandleValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeMethodHandleValue left, RuntimeMethodHandleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeMethodHandleValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RuntimeMethodHandleValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForGenericParameterValue : SingleValue {
    public GenericParameterProxy GenericParameter;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForGenericParameterValue(GenericParameterProxy genericParameter);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForGenericParameterValue(RuntimeTypeHandleForGenericParameterValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForGenericParameterValue left, RuntimeTypeHandleForGenericParameterValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForGenericParameterValue left, RuntimeTypeHandleForGenericParameterValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForGenericParameterValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RuntimeTypeHandleForGenericParameterValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForNullableSystemTypeValue : SingleValue {
    public TypeProxy NullableType;
    public SystemTypeValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForNullableSystemTypeValue(TypeProxy& nullableType, SystemTypeValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForNullableSystemTypeValue(RuntimeTypeHandleForNullableSystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForNullableSystemTypeValue left, RuntimeTypeHandleForNullableSystemTypeValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForNullableSystemTypeValue left, RuntimeTypeHandleForNullableSystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForNullableSystemTypeValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RuntimeTypeHandleForNullableSystemTypeValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers : SingleValue {
    public TypeProxy NullableType;
    public SingleValue UnderlyingTypeValue;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers(TypeProxy& nullableType, SingleValue& underlyingTypeValue);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers left, RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers left, RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RuntimeTypeHandleForNullableValueWithDynamicallyAccessedMembers <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.RuntimeTypeHandleValue : SingleValue {
    public TypeProxy RepresentedType;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public RuntimeTypeHandleValue(TypeProxy& representedType);
    [CompilerGeneratedAttribute]
private RuntimeTypeHandleValue(RuntimeTypeHandleValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(RuntimeTypeHandleValue left, RuntimeTypeHandleValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(RuntimeTypeHandleValue left, RuntimeTypeHandleValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(RuntimeTypeHandleValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override RuntimeTypeHandleValue <Clone>$();
}
[ExtensionAttribute]
internal static class ILLink.Shared.TrimAnalysis.SingleValueExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool DetectCycle(SingleValue node, HashSet`1<SingleValue> seenNodes, HashSet`1<SingleValue> allNodesSeen);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.SystemReflectionMethodBaseValue : SingleValue {
    public MethodProxy RepresentedMethod;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SystemReflectionMethodBaseValue(MethodProxy representedMethod);
    [CompilerGeneratedAttribute]
private SystemReflectionMethodBaseValue(SystemReflectionMethodBaseValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SystemReflectionMethodBaseValue left, SystemReflectionMethodBaseValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SystemReflectionMethodBaseValue left, SystemReflectionMethodBaseValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SystemReflectionMethodBaseValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SystemReflectionMethodBaseValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.SystemTypeValue : SingleValue {
    public TypeProxy RepresentedType;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public SystemTypeValue(TypeProxy& representedType);
    [CompilerGeneratedAttribute]
private SystemTypeValue(SystemTypeValue original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(SystemTypeValue left, SystemTypeValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(SystemTypeValue left, SystemTypeValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SystemTypeValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override SystemTypeValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class ILLink.Shared.TrimAnalysis.UnknownValue : SingleValue {
    [CompilerGeneratedAttribute]
private static UnknownValue <Instance>k__BackingField;
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public static UnknownValue Instance { get; }
    [CompilerGeneratedAttribute]
private UnknownValue(UnknownValue original);
    private static UnknownValue();
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    [CompilerGeneratedAttribute]
public static UnknownValue get_Instance();
    public virtual SingleValue DeepCopy();
    public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(UnknownValue left, UnknownValue right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(UnknownValue left, UnknownValue right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(UnknownValue other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public virtual override UnknownValue <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class ILLink.Shared.TrimAnalysis.ValueExtensions : object {
    [ExtensionAttribute]
internal static string ValueToString(SingleValue value, Object[] args);
    [ExtensionAttribute]
internal static Nullable`1<int> AsConstInt(SingleValue value);
    [ExtensionAttribute]
internal static Nullable`1<int> AsConstInt(ValueSet`1& value);
    [NullableContextAttribute("2")]
[ExtensionAttribute]
internal static SingleValue AsSingleValue(ValueSet`1& node);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class ILLink.Shared.TrimAnalysis.ValueWithDynamicallyAccessedMembers : SingleValue {
    [CompilerGeneratedAttribute]
protected Type EqualityContract { get; }
    public DynamicallyAccessedMemberTypes DynamicallyAccessedMemberTypes { get; }
    [CompilerGeneratedAttribute]
protected ValueWithDynamicallyAccessedMembers(ValueWithDynamicallyAccessedMembers original);
    [CompilerGeneratedAttribute]
protected virtual Type get_EqualityContract();
    public abstract virtual DynamicallyAccessedMemberTypes get_DynamicallyAccessedMemberTypes();
    public abstract virtual IEnumerable`1<string> GetDiagnosticArgumentsForAnnotationMismatch();
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
protected virtual bool PrintMembers(StringBuilder builder);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Inequality(ValueWithDynamicallyAccessedMembers left, ValueWithDynamicallyAccessedMembers right);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public static bool op_Equality(ValueWithDynamicallyAccessedMembers left, ValueWithDynamicallyAccessedMembers right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public sealed virtual bool Equals(SingleValue other);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public virtual bool Equals(ValueWithDynamicallyAccessedMembers other);
    [PreserveBaseOverridesAttribute]
[CompilerGeneratedAttribute]
public abstract virtual override ValueWithDynamicallyAccessedMembers <Clone>$();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.GenericParameterProxy : ValueType {
    public GenericParameter GenericParameter;
    public GenericParameterProxy(GenericParameter genericParameter);
    public static GenericParameterProxy op_Implicit(GenericParameter genericParameter);
    public virtual string ToString();
    internal bool HasDefaultConstructorConstraint();
}
[NullableContextAttribute("1")]
internal interface ILLink.Shared.TypeSystemProxy.IMemberProxy {
    public string Name { get; }
    public abstract virtual string get_Name();
    public abstract virtual string GetDisplayName();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.MethodProxy : ValueType {
    public MethodDefinition Method;
    public string Name { get; }
    public MethodProxy(MethodDefinition method);
    public static MethodProxy op_Implicit(MethodDefinition method);
    public sealed virtual string get_Name();
    public sealed virtual string GetDisplayName();
    public virtual string ToString();
    public ReferenceKind ParameterReferenceKind(int index);
    public sealed virtual bool Equals(MethodProxy other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    internal bool IsDeclaredOnType(string fullTypeName);
    internal bool HasParameters();
    internal int GetParametersCount();
    internal bool HasParametersCount(int parameterCount);
    internal bool HasParameterOfType(int parameterIndex, string fullTypeName);
    internal string GetParameterDisplayName(int parameterIndex);
    internal bool HasGenericParameters();
    internal bool HasGenericParametersCount(int genericParameterCount);
    [NullableContextAttribute("0")]
internal ImmutableArray`1<GenericParameterProxy> GetGenericParameters();
    internal bool IsStatic();
    internal bool ReturnsVoid();
}
public enum ILLink.Shared.TypeSystemProxy.ReferenceKind : Enum {
    public int value__;
    public static ReferenceKind Ref;
    public static ReferenceKind In;
    public static ReferenceKind Out;
    public static ReferenceKind None;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class ILLink.Shared.TypeSystemProxy.TypeProxy : ValueType {
    [CompilerGeneratedAttribute]
private TypeDefinition <Type>k__BackingField;
    public TypeDefinition Type { get; }
    public string Name { get; }
    [NullableAttribute("2")]
public string Namespace { get; }
    public TypeProxy(TypeDefinition type);
    public static TypeProxy op_Implicit(TypeDefinition type);
    [CompilerGeneratedAttribute]
public TypeDefinition get_Type();
    public sealed virtual string get_Name();
    [NullableContextAttribute("2")]
public string get_Namespace();
    public bool IsTypeOf(string namespace, string name);
    public bool IsTypeOf(WellKnownType wellKnownType);
    public sealed virtual string GetDisplayName();
    public virtual string ToString();
    [NullableContextAttribute("0")]
internal ImmutableArray`1<GenericParameterProxy> GetGenericParameters();
}
public enum ILLink.Shared.TypeSystemProxy.WellKnownType : Enum {
    public int value__;
    public static WellKnownType System_String;
    public static WellKnownType System_Nullable_T;
    public static WellKnownType System_Type;
    public static WellKnownType System_Reflection_IReflect;
    public static WellKnownType System_Array;
    public static WellKnownType System_Object;
    public static WellKnownType System_Attribute;
    public static WellKnownType System_NotSupportedException;
    public static WellKnownType System_Runtime_CompilerServices_DisablePrivateReflectionAttribute;
    public static WellKnownType System_Void;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class ILLink.Shared.TypeSystemProxy.WellKnownTypeExtensions : object {
    [ExtensionAttribute]
public static ValueTuple`2<string, string> GetNamespaceAndName(WellKnownType type);
    [ExtensionAttribute]
public static string GetNamespace(WellKnownType type);
    [ExtensionAttribute]
public static string GetName(WellKnownType type);
    public static Nullable`1<WellKnownType> GetWellKnownType(string namespace, string name);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.AnnotationStore : object {
    protected LinkContext context;
    protected Dictionary`2<AssemblyDefinition, AssemblyAction> assembly_actions;
    protected HashSet`1<TypeDefinition> fieldType_init;
    protected Dictionary`2<IMetadataTokenProvider, MessageOrigin> marked_pending;
    protected HashSet`1<IMetadataTokenProvider> processed;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Dictionary`2<TypeDefinition, ValueTuple`2<TypePreserve, bool>> preserved_types;
    protected HashSet`1<TypeDefinition> pending_preserve;
    protected Dictionary`2<TypeDefinition, TypePreserveMembers> preserved_type_members;
    protected Dictionary`2<ExportedType, TypePreserveMembers> preserved_exportedtype_members;
    protected Dictionary`2<IMemberDefinition, List`1<MethodDefinition>> preserved_methods;
    protected HashSet`1<IMetadataTokenProvider> public_api;
    protected Dictionary`2<AssemblyDefinition, ISymbolReader> symbol_readers;
    private Dictionary`2<IMemberDefinition, LinkerAttributesInformation> linker_attributes;
    private Dictionary`2<object, Dictionary`2<IMetadataTokenProvider, object>> custom_annotations;
    protected Dictionary`2<AssemblyDefinition, HashSet`1<EmbeddedResource>> resources_to_remove;
    protected HashSet`1<CustomAttribute> marked_attributes;
    private HashSet`1<TypeDefinition> marked_types_with_cctor;
    protected HashSet`1<TypeDefinition> marked_instantiated;
    protected HashSet`1<MethodDefinition> indirectly_called;
    protected HashSet`1<TypeDefinition> types_relevant_to_variant_casting;
    private HashSet`1<IMemberDefinition> reflection_used;
    [CompilerGeneratedAttribute]
private bool <ProcessSatelliteAssemblies>k__BackingField;
    [CompilerGeneratedAttribute]
private FlowAnnotations <FlowAnnotations>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<MethodDefinition> <VirtualMethodsWithAnnotationsToValidate>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeMapInfo <TypeMapInfo>k__BackingField;
    [CompilerGeneratedAttribute]
private MemberActionStore <MemberActions>k__BackingField;
    public bool ProcessSatelliteAssemblies { get; public set; }
    protected Tracer Tracer { get; }
    internal FlowAnnotations FlowAnnotations { get; }
    internal HashSet`1<MethodDefinition> VirtualMethodsWithAnnotationsToValidate { get; }
    private TypeMapInfo TypeMapInfo { get; }
    public MemberActionStore MemberActions { get; }
    public AnnotationStore(LinkContext context);
    [CompilerGeneratedAttribute]
public bool get_ProcessSatelliteAssemblies();
    [CompilerGeneratedAttribute]
public void set_ProcessSatelliteAssemblies(bool value);
    protected Tracer get_Tracer();
    [CompilerGeneratedAttribute]
internal FlowAnnotations get_FlowAnnotations();
    [CompilerGeneratedAttribute]
internal HashSet`1<MethodDefinition> get_VirtualMethodsWithAnnotationsToValidate();
    [CompilerGeneratedAttribute]
private TypeMapInfo get_TypeMapInfo();
    [CompilerGeneratedAttribute]
public MemberActionStore get_MemberActions();
    [ObsoleteAttribute("Use Tracer in LinkContext directly")]
public void PrepareDependenciesDump();
    [ObsoleteAttribute("Use Tracer in LinkContext directly")]
public void PrepareDependenciesDump(string filename);
    public ICollection`1<AssemblyDefinition> GetAssemblies();
    public AssemblyAction GetAction(AssemblyDefinition assembly);
    public MethodAction GetAction(MethodDefinition method);
    public void SetAction(AssemblyDefinition assembly, AssemblyAction action);
    public bool HasAction(AssemblyDefinition assembly);
    public void SetAction(MethodDefinition method, MethodAction action);
    public void SetStubValue(MethodDefinition method, object value);
    public bool HasSubstitutedInit(FieldDefinition field);
    public void SetSubstitutedInit(TypeDefinition type);
    public bool HasSubstitutedInit(TypeDefinition type);
    [ObsoleteAttribute("Mark token providers with a reason instead.")]
public void Mark(IMetadataTokenProvider provider);
    public void Mark(IMetadataTokenProvider provider, DependencyInfo& reason, MessageOrigin& origin);
    [ObsoleteAttribute("Mark attributes with a reason instead.")]
public void Mark(CustomAttribute attribute);
    public void Mark(CustomAttribute attribute, DependencyInfo& reason);
    public KeyValuePair`2[] GetMarkedPending();
    public bool IsMarked(IMetadataTokenProvider provider);
    public bool IsMarked(CustomAttribute attribute);
    public void MarkIndirectlyCalledMethod(MethodDefinition method);
    public bool HasMarkedAnyIndirectlyCalledMethods();
    public bool IsIndirectlyCalled(MethodDefinition method);
    public void MarkReflectionUsed(IMemberDefinition member);
    public bool IsReflectionUsed(IMemberDefinition method);
    public void MarkInstantiated(TypeDefinition type);
    public bool IsInstantiated(TypeDefinition type);
    public void MarkRelevantToVariantCasting(TypeDefinition type);
    public bool IsRelevantToVariantCasting(TypeDefinition type);
    public bool SetProcessed(IMetadataTokenProvider provider);
    public bool IsProcessed(IMetadataTokenProvider provider);
    public bool MarkProcessed(IMetadataTokenProvider provider, DependencyInfo& reason);
    public TypeDefinition[] GetPendingPreserve();
    public bool SetAppliedPreserve(TypeDefinition type, TypePreserve preserve);
    public bool HasAppliedPreserve(TypeDefinition type, TypePreserve preserve);
    public void SetPreserve(TypeDefinition type, TypePreserve preserve);
    public static TypePreserve ChoosePreserveActionWhichPreservesTheMost(TypePreserve leftPreserveAction, TypePreserve rightPreserveAction);
    public bool TryGetPreserve(TypeDefinition type, TypePreserve& preserve);
    public void SetMembersPreserve(TypeDefinition type, TypePreserveMembers preserve);
    private static TypePreserveMembers CombineMembers(TypePreserveMembers left, TypePreserveMembers right);
    public void SetMembersPreserve(ExportedType type, TypePreserveMembers preserve);
    public bool TryGetPreservedMembers(TypeDefinition type, TypePreserveMembers& preserve);
    public bool TryGetPreservedMembers(ExportedType type, TypePreserveMembers& preserve);
    public bool TryGetMethodStubValue(MethodDefinition method, Object& value);
    public bool TryGetFieldUserValue(FieldDefinition field, Object& value);
    public HashSet`1<EmbeddedResource> GetResourcesToRemove(AssemblyDefinition assembly);
    public void AddResourceToRemove(AssemblyDefinition assembly, EmbeddedResource resource);
    public void SetPublic(IMetadataTokenProvider provider);
    public bool IsPublic(IMetadataTokenProvider provider);
    public IEnumerable`1<OverrideInformation> GetOverrides(MethodDefinition method);
    public IEnumerable`1<ValueTuple`2<TypeDefinition, InterfaceImplementation>> GetDefaultInterfaceImplementations(MethodDefinition method);
    public List`1<OverrideInformation> GetBaseMethods(MethodDefinition method);
    public List`1<MethodDefinition> GetPreservedMethods(TypeDefinition type);
    public bool ClearPreservedMethods(TypeDefinition type);
    public void AddPreservedMethod(TypeDefinition type, MethodDefinition method);
    public List`1<MethodDefinition> GetPreservedMethods(MethodDefinition method);
    public bool ClearPreservedMethods(MethodDefinition key);
    public void AddPreservedMethod(MethodDefinition key, MethodDefinition method);
    private List`1<MethodDefinition> GetPreservedMethods(IMemberDefinition definition);
    private void AddPreservedMethod(IMemberDefinition definition, MethodDefinition method);
    public void AddSymbolReader(AssemblyDefinition assembly, ISymbolReader symbolReader);
    public void CloseSymbolReader(AssemblyDefinition assembly);
    public object GetCustomAnnotation(object key, IMetadataTokenProvider item);
    public void SetCustomAnnotation(object key, IMetadataTokenProvider item, object value);
    public bool HasPreservedStaticCtor(TypeDefinition type);
    public bool SetPreservedStaticCtor(TypeDefinition type);
    public bool HasLinkerAttribute(IMemberDefinition member);
    public IEnumerable`1<T> GetLinkerAttributes(IMemberDefinition member);
    public bool TryGetLinkerAttribute(IMemberDefinition member, T& attribute);
    internal bool IsInRequiresUnreferencedCodeScope(MethodDefinition method);
    internal bool DoesMemberRequireUnreferencedCode(IMemberDefinition member, RequiresUnreferencedCodeAttribute& attribute);
    [NullableContextAttribute("2")]
internal bool ShouldSuppressAnalysisWarningsForRequiresUnreferencedCode(ICustomAttributeProvider originMember);
    internal bool DoesMethodRequireUnreferencedCode(MethodDefinition originalMethod, RequiresUnreferencedCodeAttribute& attribute);
    internal bool DoesFieldRequireUnreferencedCode(FieldDefinition field, RequiresUnreferencedCodeAttribute& attribute);
    public void EnqueueVirtualMethod(MethodDefinition method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.ArrayBuilder`1 : ValueType {
    private List`1<T> _list;
    public int Count { get; }
    public void Add(T value);
    public bool Any(Predicate`1<T> callback);
    public T[] ToArray();
    public int get_Count();
}
public enum Mono.Linker.AssemblyAction : Enum {
    public int value__;
    public static AssemblyAction Skip;
    public static AssemblyAction Copy;
    public static AssemblyAction CopyUsed;
    public static AssemblyAction Link;
    public static AssemblyAction Delete;
    public static AssemblyAction Save;
    public static AssemblyAction AddBypassNGen;
    public static AssemblyAction AddBypassNGenUsed;
}
[ExtensionAttribute]
public static class Mono.Linker.AssemblyDefinitionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static EmbeddedResource FindEmbeddedResource(AssemblyDefinition assembly, string name);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.AssemblyResolver : object {
    private List`1<string> _references;
    private LinkContext _context;
    private List`1<string> _directories;
    private Dictionary`2<AssemblyDefinition, string> _assemblyToPath;
    private List`1<MemoryMappedViewStream> _viewStreams;
    private ReaderParameters _defaultReaderParameters;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _unresolvedAssemblies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<string> _reportedUnresolvedAssemblies;
    [CompilerGeneratedAttribute]
private IDictionary`2<string, AssemblyDefinition> <AssemblyCache>k__BackingField;
    private static String[] Extensions;
    public IDictionary`2<string, AssemblyDefinition> AssemblyCache { get; }
    public AssemblyResolver(LinkContext context);
    private static AssemblyResolver();
    [CompilerGeneratedAttribute]
public IDictionary`2<string, AssemblyDefinition> get_AssemblyCache();
    public string GetAssemblyLocation(AssemblyDefinition assembly);
    private AssemblyDefinition ResolveFromReferences(AssemblyNameReference name);
    public AssemblyDefinition Resolve(AssemblyNameReference name, bool probing);
    private void ReportUnresolvedAssembly(AssemblyNameReference reference);
    public void AddSearchDirectory(string directory);
    public AssemblyDefinition GetAssembly(string file);
    public sealed virtual AssemblyDefinition Resolve(AssemblyNameReference name);
    private sealed virtual override AssemblyDefinition Mono.Cecil.IAssemblyResolver.Resolve(AssemblyNameReference name, ReaderParameters parameters);
    private AssemblyDefinition SearchDirectory(AssemblyNameReference name);
    public void CacheAssembly(AssemblyDefinition assembly);
    public void AddReferenceAssembly(string referencePath);
    public List`1<string> GetReferencePaths();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
public enum Mono.Linker.AssemblyRootMode : Enum {
    public int value__;
    public static AssemblyRootMode Default;
    public static AssemblyRootMode EntryPoint;
    public static AssemblyRootMode AllMembers;
    public static AssemblyRootMode VisibleMembers;
    public static AssemblyRootMode Library;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.AttributeInfo : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<ICustomAttributeProvider, CustomAttribute[]> <CustomAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<CustomAttribute, MessageOrigin> <CustomAttributesOrigins>k__BackingField;
    public Dictionary`2<ICustomAttributeProvider, CustomAttribute[]> CustomAttributes { get; }
    public Dictionary`2<CustomAttribute, MessageOrigin> CustomAttributesOrigins { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<ICustomAttributeProvider, CustomAttribute[]> get_CustomAttributes();
    [CompilerGeneratedAttribute]
public Dictionary`2<CustomAttribute, MessageOrigin> get_CustomAttributesOrigins();
    public void AddCustomAttributes(ICustomAttributeProvider provider, CustomAttribute[] customAttributes, MessageOrigin[] origins);
    public void AddCustomAttributes(ICustomAttributeProvider provider, CustomAttribute[] customAttributes);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.BCL : object {
    private static String[] corlibNames;
    private static BCL();
    public static bool IsIDisposableImplementation(MethodDefinition method);
    public static TypeDefinition FindPredefinedType(WellKnownType type, LinkContext context);
}
[FlagsAttribute]
public enum Mono.Linker.CodeOptimizations : Enum {
    public int value__;
    public static CodeOptimizations BeforeFieldInit;
    public static CodeOptimizations OverrideRemoval;
    public static CodeOptimizations UnreachableBodies;
    public static CodeOptimizations UnusedInterfaces;
    public static CodeOptimizations IPConstantPropagation;
    public static CodeOptimizations Sealer;
    public static CodeOptimizations UnusedTypeChecks;
    public static CodeOptimizations RemoveDescriptors;
    public static CodeOptimizations RemoveSubstitutions;
    public static CodeOptimizations RemoveLinkAttributes;
    public static CodeOptimizations RemoveDynamicDependencyAttribute;
    public static CodeOptimizations OptimizeTypeHierarchyAnnotations;
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Mono.Linker.CodeOptimizationsSettings : object {
    [NullableAttribute("1")]
private Dictionary`2<string, Pair> perAssembly;
    [CompilerGeneratedAttribute]
private CodeOptimizations <Global>k__BackingField;
    public CodeOptimizations Global { get; private set; }
    public CodeOptimizationsSettings(CodeOptimizations globalOptimizations);
    [CompilerGeneratedAttribute]
public CodeOptimizations get_Global();
    [CompilerGeneratedAttribute]
private void set_Global(CodeOptimizations value);
    internal bool IsEnabled(CodeOptimizations optimizations, AssemblyDefinition context);
    public bool IsEnabled(CodeOptimizations optimizations, string assemblyName);
    public void Enable(CodeOptimizations optimizations, string assemblyContext);
    public void Disable(CodeOptimizations optimizations, string assemblyContext);
}
public class Mono.Linker.ConsoleLogger : object {
    public sealed virtual void LogMessage(MessageContainer message);
}
internal static class Mono.Linker.Constants : object {
    [NullableAttribute("1")]
public static string ILLink;
}
[ExtensionAttribute]
public static class Mono.Linker.CustomAttributeArgumentExtensions : object {
    [ExtensionAttribute]
public static bool IsEqualTo(CustomAttributeArgument A, CustomAttributeArgument B);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
private static object BaseValue(object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.CustomAttributeSource : object {
    [CompilerGeneratedAttribute]
private AttributeInfo <PrimaryAttributeInfo>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<AssemblyDefinition, AttributeInfo> _embeddedXmlInfos;
    private LinkContext _context;
    public AttributeInfo PrimaryAttributeInfo { get; }
    public CustomAttributeSource(LinkContext context);
    [CompilerGeneratedAttribute]
public AttributeInfo get_PrimaryAttributeInfo();
    public static AssemblyDefinition GetAssemblyFromCustomAttributeProvider(ICustomAttributeProvider provider);
    public bool TryGetEmbeddedXmlInfo(ICustomAttributeProvider provider, AttributeInfo& xmlInfo);
    [IteratorStateMachineAttribute("Mono.Linker.CustomAttributeSource/<GetCustomAttributes>d__8")]
public IEnumerable`1<CustomAttribute> GetCustomAttributes(ICustomAttributeProvider provider);
    public bool TryGetCustomAttributeOrigin(ICustomAttributeProvider provider, CustomAttribute customAttribute, MessageOrigin& origin);
    public bool HasAny(ICustomAttributeProvider provider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.AttributeDataFlow : ValueType {
    private LinkContext _context;
    private MarkStep _markStep;
    private MessageOrigin _origin;
    public AttributeDataFlow(LinkContext context, MarkStep markStep, MessageOrigin& origin);
    public void ProcessAttributeDataflow(MethodDefinition method, IList`1<CustomAttributeArgument> arguments);
    public void ProcessAttributeDataflow(FieldDefinition field, CustomAttributeArgument value);
    private ValueSet`1<SingleValue> GetValueForCustomAttributeArgument(CustomAttributeArgument argument);
    private void RequireDynamicallyAccessedMembers(DiagnosticContext& diagnosticContext, ValueSet`1& value, ValueWithDynamicallyAccessedMembers targetValue);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.Dataflow.CompilerGeneratedCallGraph : object {
    private Dictionary`2<IMemberDefinition, HashSet`1<IMemberDefinition>> _callGraph;
    private void TrackCallInternal(IMemberDefinition fromMember, IMemberDefinition toMember);
    public void TrackCall(MethodDefinition fromMethod, MethodDefinition toMethod);
    public void TrackCall(MethodDefinition fromMethod, TypeDefinition toType);
    public void TrackCall(TypeDefinition fromType, MethodDefinition toMethod);
    [IteratorStateMachineAttribute("Mono.Linker.Dataflow.CompilerGeneratedCallGraph/<GetReachableMembers>d__6")]
public IEnumerable`1<IMemberDefinition> GetReachableMembers(MethodDefinition start);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.Dataflow.CompilerGeneratedNames : object {
    internal static bool IsGeneratedMemberName(string memberName);
    internal static bool IsLambdaDisplayClass(string className);
    internal static bool IsStateMachineType(string typeName);
    internal static bool IsGeneratedType(string name);
    internal static bool IsLambdaOrLocalFunction(string methodName);
    internal static bool IsLambdaMethod(string methodName);
    internal static bool IsLocalFunction(string methodName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Dataflow.CompilerGeneratedState : object {
    private LinkContext _context;
    private Dictionary`2<TypeDefinition, MethodDefinition> _compilerGeneratedTypeToUserCodeMethod;
    private Dictionary`2<TypeDefinition, TypeArgumentInfo> _generatedTypeToTypeArgumentInfo;
    private Dictionary`2<MethodDefinition, MethodDefinition> _compilerGeneratedMethodToUserCodeMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TypeDefinition, Dictionary`2<MethodDefinition, List`1<IMemberDefinition>>> _cachedTypeToCompilerGeneratedMembers;
    public CompilerGeneratedState(LinkContext context);
    [IteratorStateMachineAttribute("Mono.Linker.Dataflow.CompilerGeneratedState/<GetCompilerGeneratedNestedTypes>d__7")]
private static IEnumerable`1<TypeDefinition> GetCompilerGeneratedNestedTypes(TypeDefinition type);
    public static bool IsHoistedLocal(FieldDefinition field);
    public static bool IsNestedFunctionOrStateMachineMember(IMemberDefinition member);
    public static bool TryGetStateMachineType(MethodDefinition method, TypeDefinition& stateMachineType);
    private TypeDefinition GetCompilerGeneratedStateForType(TypeDefinition type);
    private static TypeDefinition GetFirstConstructorArgumentAsType(CustomAttribute attribute);
    public bool TryGetCompilerGeneratedCalleesForUserMethod(MethodDefinition method, List`1& callees);
    public IReadOnlyList`1<ICustomAttributeProvider> GetGeneratedTypeAttributes(TypeDefinition generatedType);
    public bool TryGetOwningMethodForCompilerGeneratedMember(IMemberDefinition sourceMember, MethodDefinition& owningMethod);
    [CompilerGeneratedAttribute]
private void <GetCompilerGeneratedStateForType>g__ProcessMethod|11_0(MethodDefinition method, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
internal static bool <GetCompilerGeneratedStateForType>g__HasGenericParameters|11_1(TypeDefinition typeDef);
    [CompilerGeneratedAttribute]
private void <GetCompilerGeneratedStateForType>g__MapGeneratedTypeTypeParameters|11_2(TypeDefinition generatedType, <>c__DisplayClass11_0& );
    [CompilerGeneratedAttribute]
private GenericInstanceType <GetCompilerGeneratedStateForType>g__ScanForInit|11_3(TypeDefinition compilerGeneratedType, MethodBody body, <>c__DisplayClass11_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal static class Mono.Linker.Dataflow.DiagnosticUtilities : object {
    internal static IMetadataTokenProvider GetMethodParameterFromIndex(MethodDefinition method, int parameterIndex);
    internal static string GetParameterNameForErrorMessage(ParameterDefinition parameterDefinition);
    internal static string GetGenericParameterDeclaringMemberDisplayName(GenericParameter genericParameter);
    internal static string GetMethodSignatureDisplayName(IMethodSignature methodSignature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.Dataflow.DynamicallyAccessedMembersTypeHierarchy : object {
    private LinkContext _context;
    private MarkStep _markStep;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TypeDefinition, ValueTuple`2<DynamicallyAccessedMemberTypes, bool>> _typesInDynamicallyAccessedMembersHierarchy;
    public DynamicallyAccessedMembersTypeHierarchy(LinkContext context, MarkStep markStep);
    [NullableContextAttribute("0")]
public ValueTuple`2<DynamicallyAccessedMemberTypes, bool> ProcessMarkedTypeForDynamicallyAccessedMembersHierarchy(TypeDefinition type);
    public DynamicallyAccessedMemberTypes ApplyDynamicallyAccessedMembersToTypeHierarchy(TypeDefinition type);
    private bool ApplyDynamicallyAccessedMembersToTypeHierarchyInner(ReflectionMarker& reflectionMarker, TypeDefinition type);
    private void ApplyDynamicallyAccessedMembersToType(ReflectionMarker& reflectionMarker, MessageOrigin& origin, TypeDefinition type, DynamicallyAccessedMemberTypes annotation);
    [NullableContextAttribute("0")]
private ValueTuple`2<DynamicallyAccessedMemberTypes, bool> GetCachedInfoForTypeInHierarchy(TypeDefinition type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.GenericArgumentDataFlow : ValueType {
    private LinkContext _context;
    private MarkStep _markStep;
    private MessageOrigin _origin;
    public GenericArgumentDataFlow(LinkContext context, MarkStep markStep, MessageOrigin& origin);
    public void ProcessGenericArgumentDataFlow(GenericParameter genericParameter, TypeReference genericArgument);
    private void RequireDynamicallyAccessedMembers(DiagnosticContext& diagnosticContext, ValueSet`1& value, ValueWithDynamicallyAccessedMembers targetValue);
}
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.HoistedLocalKey : ValueType {
    [NullableAttribute("1")]
private FieldDefinition Field;
    [NullableContextAttribute("1")]
public HoistedLocalKey(FieldDefinition field);
    public sealed virtual bool Equals(HoistedLocalKey other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
internal class Mono.Linker.Dataflow.InterproceduralState : ValueType {
    public ValueSet`1<MethodIL> MethodBodies;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DefaultValueDictionary`2<HoistedLocalKey, ValueSet`1<SingleValue>> HoistedLocals;
    private InterproceduralStateLattice lattice;
    public InterproceduralState(ValueSet`1<MethodIL> methodBodies, DefaultValueDictionary`2<HoistedLocalKey, ValueSet`1<SingleValue>> hoistedLocals, InterproceduralStateLattice lattice);
    public sealed virtual bool Equals(InterproceduralState other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public InterproceduralState Clone();
    [NullableContextAttribute("1")]
public void TrackMethod(MethodDefinition method);
    [NullableContextAttribute("1")]
public void TrackMethod(MethodBody methodBody);
    public void TrackMethod(MethodIL methodIL);
    public void SetHoistedLocal(HoistedLocalKey key, ValueSet`1<SingleValue> value);
    public ValueSet`1<SingleValue> GetHoistedLocal(HoistedLocalKey key);
}
[IsReadOnlyAttribute]
internal class Mono.Linker.Dataflow.InterproceduralStateLattice : ValueType {
    public ValueSetLattice`1<MethodIL> MethodBodyLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public DictionaryLattice`3<HoistedLocalKey, ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> HoistedLocalsLattice;
    [NullableAttribute("1")]
public LinkContext Context;
    public InterproceduralState Top { get; }
    public InterproceduralStateLattice(ValueSetLattice`1<MethodIL> methodBodyLattice, DictionaryLattice`3<HoistedLocalKey, ValueSet`1<SingleValue>, ValueSetLattice`1<SingleValue>> hoistedLocalsLattice, LinkContext context);
    public sealed virtual InterproceduralState get_Top();
    public sealed virtual InterproceduralState Meet(InterproceduralState left, InterproceduralState right);
}
[NullableContextAttribute("2")]
internal interface Mono.Linker.Dataflow.IValueWithStaticType {
    public TypeDefinition StaticType { get; }
    public abstract virtual TypeDefinition get_StaticType();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Mono.Linker.Dataflow.MethodBodyScanner : object {
    protected LinkContext _context;
    protected InterproceduralStateLattice InterproceduralStateLattice;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <ReturnValue>k__BackingField;
    private static int MaxTrackedArrayValues;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected static ValueSetLattice`1<SingleValue> MultiValueLattice { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
internal ValueSet`1<SingleValue> ReturnValue { get; private set; }
    protected MethodBodyScanner(LinkContext context);
    protected static ValueSetLattice`1<SingleValue> get_MultiValueLattice();
    [CompilerGeneratedAttribute]
private void set_ReturnValue(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
internal ValueSet`1<SingleValue> get_ReturnValue();
    protected virtual void WarnAboutInvalidILInMethod(MethodBody method, int ilOffset);
    private void CheckForInvalidStack(Stack`1<StackSlot> stack, int depthRequired, MethodBody method, int ilOffset);
    private static void PushUnknown(Stack`1<StackSlot> stack);
    private void PushUnknownAndWarnAboutInvalidIL(Stack`1<StackSlot> stack, MethodBody methodBody, int offset);
    private StackSlot PopUnknown(Stack`1<StackSlot> stack, int count, MethodBody method, int ilOffset);
    private static StackSlot MergeStackElement(StackSlot a, StackSlot b);
    private static Stack`1<StackSlot> MergeStack(Stack`1<StackSlot> a, Stack`1<StackSlot> b);
    [NullableContextAttribute("2")]
private static void ClearStack(Stack`1& stack);
    private static void NewKnownStack(Dictionary`2<int, Stack`1<StackSlot>> knownStacks, int newOffset, Stack`1<StackSlot> newStack);
    [ConditionalAttribute("DEBUG")]
private static void ValidateNoReferenceToReference(Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, MethodDefinition method, int ilOffset);
    protected static void StoreMethodLocalValue(Dictionary`2<KeyType, ValueBasicBlockPair> valueCollection, ValueSet`1& valueToStore, KeyType collectionKey, int curBasicBlock, Nullable`1<int> maxTrackedValues);
    public virtual void InterproceduralScan(MethodIL startingMethodIL);
    private void TrackNestedFunctionReference(MethodReference referencedMethod, InterproceduralState& interproceduralState);
    protected virtual void Scan(MethodIL methodIL, InterproceduralState& interproceduralState);
    private static void ScanExceptionInformation(Dictionary`2<int, Stack`1<StackSlot>> knownStacks, MethodIL methodIL);
    protected abstract virtual SingleValue GetMethodParameterValue(MethodDefinition method, int parameterIndex);
    private void ScanLdarg(Instruction operation, Stack`1<StackSlot> currentStack, MethodDefinition thisMethod, MethodIL methodBody);
    private void ScanStarg(Instruction operation, Stack`1<StackSlot> currentStack, MethodDefinition thisMethod, MethodBody methodBody);
    private void ScanLdloc(Instruction operation, Stack`1<StackSlot> currentStack, MethodIL methodIL, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals);
    private void ScanLdtoken(Instruction operation, Stack`1<StackSlot> currentStack);
    private void ScanStloc(Instruction operation, Stack`1<StackSlot> currentStack, MethodIL methodIL, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, int curBasicBlock);
    private void ScanIndirectStore(Instruction operation, Stack`1<StackSlot> currentStack, MethodBody methodBody, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, int curBasicBlock, InterproceduralState& ipState);
    protected void StoreInReference(ValueSet`1<SingleValue> target, ValueSet`1<SingleValue> source, MethodDefinition method, Instruction operation, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, int curBasicBlock, InterproceduralState& ipState);
    protected abstract virtual ValueSet`1<SingleValue> GetFieldValue(FieldDefinition field);
    private void ScanLdfld(Instruction operation, Stack`1<StackSlot> currentStack, MethodBody methodBody, InterproceduralState& interproceduralState);
    protected virtual void HandleStoreField(MethodDefinition method, FieldValue field, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    protected virtual void HandleStoreParameter(MethodDefinition method, MethodParameterValue parameter, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    protected virtual void HandleStoreMethodThisParameter(MethodDefinition method, MethodThisParameterValue thisParameter, Instruction operation, ValueSet`1<SingleValue> sourceValue);
    protected virtual void HandleStoreMethodReturnValue(MethodDefinition method, MethodReturnValue thisParameter, Instruction operation, ValueSet`1<SingleValue> sourceValue);
    private void ScanStfld(Instruction operation, Stack`1<StackSlot> currentStack, MethodDefinition thisMethod, MethodBody methodBody, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, InterproceduralState& interproceduralState);
    private static VariableDefinition GetLocalDef(Instruction operation, Collection`1<VariableDefinition> localVariables);
    private ValueNodeList PopCallArguments(Stack`1<StackSlot> currentStack, MethodReference methodCalled, MethodBody containingMethodBody, bool isNewObj, int ilOffset, SingleValue& newObjValue);
    internal ValueSet`1<SingleValue> DereferenceValue(ValueSet`1<SingleValue> maybeReferenceValue, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, InterproceduralState& interproceduralState);
    protected void AssignRefAndOutParameters(MethodBody callingMethodBody, MethodReference calledMethod, ValueNodeList methodArguments, Instruction operation, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, int curBasicBlock, InterproceduralState& ipState);
    private void HandleCall(MethodBody callingMethodBody, Instruction operation, Stack`1<StackSlot> currentStack, Dictionary`2<VariableDefinition, ValueBasicBlockPair> locals, InterproceduralState& interproceduralState, int curBasicBlock);
    public TypeDefinition ResolveToTypeDefinition(TypeReference typeReference);
    public abstract virtual bool HandleCall(MethodBody callingMethodBody, MethodReference calledMethod, Instruction operation, ValueNodeList methodParams, ValueSet`1& methodReturnValue);
    private static void MarkArrayValuesAsUnknown(ArrayValue arrValue, int curBasicBlock);
    private void ScanStelem(Instruction operation, Stack`1<StackSlot> currentStack, MethodBody methodBody, int curBasicBlock);
    private void ScanLdelem(Instruction operation, Stack`1<StackSlot> currentStack, MethodBody methodBody, int curBasicBlock);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.ReflectionMarker : ValueType {
    private LinkContext _context;
    private MarkStep _markStep;
    private bool _enabled;
    public ReflectionMarker(LinkContext context, MarkStep markStep, bool enabled);
    internal void MarkTypeForDynamicallyAccessedMembers(MessageOrigin& origin, TypeDefinition typeDefinition, DynamicallyAccessedMemberTypes requiredMemberTypes, DependencyKind dependencyKind, bool declaredOnly);
    internal bool TryResolveTypeNameAndMark(string typeName, DiagnosticContext& diagnosticContext, bool needsAssemblyName, TypeDefinition& type);
    internal bool TryResolveTypeNameAndMark(AssemblyDefinition assembly, string typeName, DiagnosticContext& diagnosticContext, TypeDefinition& type);
    private void MarkResolvedType(DiagnosticContext& diagnosticContext, TypeReference typeReference, TypeDefinition typeDefinition, List`1<TypeResolutionRecord> typeResolutionRecords);
    internal void MarkType(MessageOrigin& origin, TypeDefinition type, DependencyKind dependencyKind);
    internal void MarkMethod(MessageOrigin& origin, MethodDefinition method, DependencyKind dependencyKind);
    private void MarkField(MessageOrigin& origin, FieldDefinition field, DependencyKind dependencyKind);
    internal void MarkProperty(MessageOrigin& origin, PropertyDefinition property, DependencyKind dependencyKind);
    private void MarkEvent(MessageOrigin& origin, EventDefinition event, DependencyKind dependencyKind);
    private void MarkInterfaceImplementation(MessageOrigin& origin, InterfaceImplementation interfaceImplementation, DependencyKind dependencyKind);
    internal void MarkConstructorsOnType(MessageOrigin& origin, TypeDefinition type, Func`2<MethodDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    internal void MarkFieldsOnTypeHierarchy(MessageOrigin& origin, TypeDefinition type, Func`2<FieldDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    internal void MarkPropertiesOnTypeHierarchy(MessageOrigin& origin, TypeDefinition type, Func`2<PropertyDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    internal void MarkEventsOnTypeHierarchy(MessageOrigin& origin, TypeDefinition type, Func`2<EventDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    internal void MarkStaticConstructor(MessageOrigin& origin, TypeDefinition type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.Dataflow.ReflectionMethodBodyScanner : MethodBodyScanner {
    private MarkStep _markStep;
    private MessageOrigin _origin;
    private FlowAnnotations _annotations;
    private ReflectionMarker _reflectionMarker;
    public TrimAnalysisPatternStore TrimAnalysisPatterns;
    public ReflectionMethodBodyScanner(LinkContext context, MarkStep parent, MessageOrigin origin);
    public static bool RequiresReflectionMethodBodyScannerForCallSite(LinkContext context, MethodReference calledMethod);
    public static bool RequiresReflectionMethodBodyScannerForMethodBody(LinkContext context, MethodDefinition methodDefinition);
    public static bool RequiresReflectionMethodBodyScannerForAccess(LinkContext context, FieldReference field);
    public virtual void InterproceduralScan(MethodIL methodIL);
    protected virtual void Scan(MethodIL methodIL, InterproceduralState& interproceduralState);
    protected virtual void WarnAboutInvalidILInMethod(MethodBody method, int ilOffset);
    [PreserveBaseOverridesAttribute]
protected virtual override ValueWithDynamicallyAccessedMembers GetMethodParameterValue(MethodDefinition method, int parameterIndex);
    private ValueWithDynamicallyAccessedMembers GetMethodParameterValue(MethodDefinition method, int parameterIndex, DynamicallyAccessedMemberTypes dynamicallyAccessedMemberTypes);
    protected virtual ValueSet`1<SingleValue> GetFieldValue(FieldDefinition field);
    private void HandleStoreValueWithDynamicallyAccessedMembers(ValueWithDynamicallyAccessedMembers targetValue, Instruction operation, ValueSet`1<SingleValue> sourceValue);
    protected virtual void HandleStoreField(MethodDefinition method, FieldValue field, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    protected virtual void HandleStoreParameter(MethodDefinition method, MethodParameterValue parameter, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    protected virtual void HandleStoreMethodThisParameter(MethodDefinition method, MethodThisParameterValue thisParameter, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    protected virtual void HandleStoreMethodReturnValue(MethodDefinition method, MethodReturnValue returnValue, Instruction operation, ValueSet`1<SingleValue> valueToStore);
    public virtual bool HandleCall(MethodBody callingMethodBody, MethodReference calledMethod, Instruction operation, ValueNodeList methodParams, ValueSet`1& methodReturnValue);
    public static bool HandleCall(Instruction operation, MethodReference calledMethod, ValueSet`1<SingleValue> instanceValue, ImmutableArray`1<ValueSet`1<SingleValue>> argumentValues, DiagnosticContext diagnosticContext, ReflectionMarker reflectionMarker, LinkContext context, MarkStep markStep, ValueSet`1& methodReturnValue);
    private static bool IsComInterop(IMarshalInfoProvider marshalInfoProvider, TypeReference parameterType, LinkContext context);
    private void HandleAssignmentPattern(MessageOrigin& origin, ValueSet`1& value, ValueWithDynamicallyAccessedMembers targetValue);
    [CompilerGeneratedAttribute]
internal static void <HandleCall>g__AddReturnValue|21_0(ValueSet`1<SingleValue> value, <>c__DisplayClass21_0& );
}
[ExtensionAttribute]
internal static class Mono.Linker.Dataflow.ScannerExtensions : object {
    [ExtensionAttribute]
public static bool IsControlFlowInstruction(OpCode& opcode);
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static HashSet`1<int> ComputeBranchTargets(MethodIL methodIL);
}
[IsReadOnlyAttribute]
internal class Mono.Linker.Dataflow.StackSlot : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Value>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Value { get; }
    [NullableContextAttribute("1")]
public StackSlot(SingleValue value);
    public StackSlot(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Value();
}
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.TrimAnalysisAssignmentPattern : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Source>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageOrigin <Origin>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Source { get; public set; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Target { get; public set; }
    public MessageOrigin Origin { get; public set; }
    public TrimAnalysisAssignmentPattern(ValueSet`1<SingleValue> source, ValueSet`1<SingleValue> target, MessageOrigin origin);
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Source(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Source();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Target(ValueSet`1<SingleValue> value);
    [CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Target();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_Origin(MessageOrigin value);
    [CompilerGeneratedAttribute]
public MessageOrigin get_Origin();
    public TrimAnalysisAssignmentPattern Merge(ValueSetLattice`1<SingleValue> lattice, TrimAnalysisAssignmentPattern other);
    [NullableContextAttribute("1")]
public void MarkAndProduceDiagnostics(ReflectionMarker reflectionMarker, LinkContext context);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrimAnalysisAssignmentPattern left, TrimAnalysisAssignmentPattern right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrimAnalysisAssignmentPattern left, TrimAnalysisAssignmentPattern right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrimAnalysisAssignmentPattern other);
}
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.TrimAnalysisMethodCallPattern : ValueType {
    [NullableAttribute("1")]
public Instruction Operation;
    [NullableAttribute("1")]
public MethodReference CalledMethod;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Instance;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ImmutableArray`1<ValueSet`1<SingleValue>> Arguments;
    public MessageOrigin Origin;
    [NullableContextAttribute("1")]
public TrimAnalysisMethodCallPattern(Instruction operation, MethodReference calledMethod, ValueSet`1<SingleValue> instance, ImmutableArray`1<ValueSet`1<SingleValue>> arguments, MessageOrigin origin);
    public TrimAnalysisMethodCallPattern Merge(ValueSetLattice`1<SingleValue> lattice, TrimAnalysisMethodCallPattern other);
    [NullableContextAttribute("1")]
public void MarkAndProduceDiagnostics(ReflectionMarker reflectionMarker, MarkStep markStep, LinkContext context);
    [CompilerGeneratedAttribute]
public virtual string ToString();
    [CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(TrimAnalysisMethodCallPattern left, TrimAnalysisMethodCallPattern right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(TrimAnalysisMethodCallPattern left, TrimAnalysisMethodCallPattern right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(TrimAnalysisMethodCallPattern other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.Dataflow.TrimAnalysisPatternStore : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<ValueTuple`2<MessageOrigin, bool>, TrimAnalysisAssignmentPattern> AssignmentPatterns;
    private Dictionary`2<MessageOrigin, TrimAnalysisMethodCallPattern> MethodCallPatterns;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private ValueSetLattice`1<SingleValue> Lattice;
    private LinkContext _context;
    public TrimAnalysisPatternStore(ValueSetLattice`1<SingleValue> lattice, LinkContext context);
    public void Add(TrimAnalysisAssignmentPattern pattern);
    public void Add(TrimAnalysisMethodCallPattern pattern);
    public void MarkAndProduceDiagnostics(ReflectionMarker reflectionMarker, MarkStep markStep);
}
public class Mono.Linker.Dataflow.ValueBasicBlockPair : ValueType {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private ValueSet`1<SingleValue> <Value>k__BackingField;
    [CompilerGeneratedAttribute]
private int <BasicBlockIndex>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public ValueSet`1<SingleValue> Value { get; }
    public int BasicBlockIndex { get; }
    public ValueBasicBlockPair(ValueSet`1<SingleValue> value, int basicBlockIndex);
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public ValueSet`1<SingleValue> get_Value();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public int get_BasicBlockIndex();
    public sealed virtual bool Equals(ValueBasicBlockPair other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
}
[NullableContextAttribute("2")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public class Mono.Linker.Dataflow.ValueNodeList : List`1<ValueSet`1<SingleValue>> {
    public ValueNodeList(int capacity);
    public ValueNodeList(List`1<ValueSet`1<SingleValue>> other);
    public virtual int GetHashCode();
    public virtual bool Equals(object other);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.DependencyInfo : ValueType {
    [CompilerGeneratedAttribute]
private DependencyKind <Kind>k__BackingField;
    [CompilerGeneratedAttribute]
private object <Source>k__BackingField;
    public static DependencyInfo Unspecified;
    public static DependencyInfo AlreadyMarked;
    public static DependencyInfo DisablePrivateReflectionRequirement;
    public DependencyKind Kind { get; }
    public object Source { get; }
    public DependencyInfo(DependencyKind kind, object source);
    private static DependencyInfo();
    [CompilerGeneratedAttribute]
public DependencyKind get_Kind();
    [CompilerGeneratedAttribute]
public object get_Source();
    public sealed virtual bool Equals(DependencyInfo other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(DependencyInfo lhs, DependencyInfo rhs);
    public static bool op_Inequality(DependencyInfo lhs, DependencyInfo rhs);
}
public enum Mono.Linker.DependencyKind : Enum {
    public int value__;
    public static DependencyKind Custom;
    public static DependencyKind Unspecified;
    public static DependencyKind AssemblyAction;
    public static DependencyKind RootAssembly;
    public static DependencyKind XmlDescriptor;
    public static DependencyKind AssemblyOrModuleAttribute;
    public static DependencyKind NestedType;
    public static DependencyKind MemberOfType;
    public static DependencyKind DeclaringType;
    public static DependencyKind FieldOnGenericInstance;
    public static DependencyKind MethodOnGenericInstance;
    public static DependencyKind BaseType;
    public static DependencyKind FieldType;
    public static DependencyKind ParameterType;
    public static DependencyKind ReturnType;
    public static DependencyKind VariableType;
    public static DependencyKind CatchType;
    public static DependencyKind BaseMethod;
    public static DependencyKind Override;
    public static DependencyKind MethodImplOverride;
    public static DependencyKind VirtualNeededDueToPreservedScope;
    public static DependencyKind MethodForInstantiatedType;
    public static DependencyKind BaseDefaultCtorForStubbedMethod;
    public static DependencyKind GenericArgumentType;
    public static DependencyKind GenericParameterConstraintType;
    public static DependencyKind DefaultCtorForNewConstrainedGenericArgument;
    public static DependencyKind ElementType;
    public static DependencyKind ElementMethod;
    public static DependencyKind ModifierType;
    public static DependencyKind ScopeOfType;
    public static DependencyKind AssemblyOfModule;
    public static DependencyKind TypeInAssembly;
    public static DependencyKind ModuleOfExportedType;
    public static DependencyKind ExportedType;
    public static DependencyKind PropertyOfPropertyMethod;
    public static DependencyKind EventOfEventMethod;
    public static DependencyKind EventMethod;
    public static DependencyKind InterfaceImplementationInterfaceType;
    public static DependencyKind InterfaceImplementationOnType;
    public static DependencyKind ReturnTypeMarshalSpec;
    public static DependencyKind ParameterMarshalSpec;
    public static DependencyKind FieldMarshalSpec;
    public static DependencyKind InteropMethodDependency;
    public static DependencyKind DirectCall;
    public static DependencyKind VirtualCall;
    public static DependencyKind Ldvirtftn;
    public static DependencyKind Ldftn;
    public static DependencyKind Newobj;
    public static DependencyKind Ldtoken;
    public static DependencyKind FieldAccess;
    public static DependencyKind InstructionTypeRef;
    public static DependencyKind CustomAttribute;
    public static DependencyKind ParameterAttribute;
    public static DependencyKind ReturnTypeAttribute;
    public static DependencyKind GenericParameterCustomAttribute;
    public static DependencyKind GenericParameterConstraintCustomAttribute;
    public static DependencyKind AttributeConstructor;
    public static DependencyKind AttributeType;
    public static DependencyKind AttributeProperty;
    public static DependencyKind CustomAttributeArgumentType;
    public static DependencyKind CustomAttributeArgumentValue;
    public static DependencyKind CustomAttributeField;
    public static DependencyKind TriggersCctorThroughFieldAccess;
    public static DependencyKind TriggersCctorForCalledMethod;
    public static DependencyKind DeclaringTypeOfCalledMethod;
    public static DependencyKind CctorForType;
    public static DependencyKind CctorForField;
    public static DependencyKind InstantiatedByCtor;
    public static DependencyKind OverrideOnInstantiatedType;
    public static DependencyKind DynamicDependency;
    public static DependencyKind PreservedDependency;
    public static DependencyKind AccessedViaReflection;
    public static DependencyKind PreservedMethod;
    public static DependencyKind TypePreserve;
    public static DependencyKind DisablePrivateReflection;
    public static DependencyKind DynamicallyAccessedMember;
    public static DependencyKind ReferencedBySpecialAttribute;
    public static DependencyKind KeptForSpecialAttribute;
    public static DependencyKind SerializationMethodForType;
    public static DependencyKind EventSourceProviderField;
    public static DependencyKind MethodForSpecialType;
    public static DependencyKind UnreachableBodyRequirement;
    public static DependencyKind DisablePrivateReflectionRequirement;
    public static DependencyKind DynamicInterfaceCastableImplementation;
    public static DependencyKind AlreadyMarked;
    public static DependencyKind DataContractSerialized;
    public static DependencyKind XmlSerialized;
    public static DependencyKind SerializedRecursiveType;
    public static DependencyKind SerializedMember;
    public static DependencyKind PreservedOperator;
    public static DependencyKind DynamicallyAccessedMemberOnType;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.DependencyRecorderHelper : object {
    private static bool IsAssemblyBound(TypeDefinition td);
    public static string TokenString(LinkContext context, object o);
    private static bool WillAssemblyBeModified(LinkContext context, AssemblyDefinition assembly);
    public static bool ShouldRecord(LinkContext context, object source, object target);
    public static bool ShouldRecord(LinkContext context, object o);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.DgmlDependencyRecorder : object {
    public static string DefaultDependenciesFileName;
    public Dictionary`2<string, int> nodeList;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public HashSet`1<ValueTuple`3<string, string, string>> linkList;
    private LinkContext context;
    [NullableAttribute("2")]
private XmlWriter writer;
    [NullableAttribute("2")]
private Stream stream;
    private int _nodeIndex;
    public DgmlDependencyRecorder(LinkContext context, string fileName);
    public sealed virtual void FinishRecording();
    public sealed virtual void Dispose();
    public void RecordDependency(object target, DependencyInfo& reason, bool marked);
    [NullableContextAttribute("2")]
public void RecordDependency(object source, object target, object reason);
    private void AddNode(string node);
    private void AddLink(string source, string target, object kind);
    public sealed virtual void RecordDependency(object source, object target, bool marked);
    private sealed virtual override void Mono.Linker.IDependencyRecorder.RecordDependency(object target, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, bool marked);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.DocumentationSignatureGenerator : object {
    internal static string MethodPrefix;
    internal static string FieldPrefix;
    internal static string EventPrefix;
    internal static string PropertyPrefix;
    internal static string TypePrefix;
    public static void VisitMember(IMemberDefinition member, StringBuilder builder, ITryResolveMetadata resolver);
    private static void VisitMethod(MethodDefinition method, StringBuilder builder, ITryResolveMetadata resolver);
    private static void VisitField(FieldDefinition field, StringBuilder builder, ITryResolveMetadata resolver);
    private static void VisitEvent(EventDefinition evt, StringBuilder builder, ITryResolveMetadata resolver);
    private static void VisitProperty(PropertyDefinition property, StringBuilder builder, ITryResolveMetadata resolver);
    private static void VisitTypeDefinition(TypeDefinition type, StringBuilder builder, ITryResolveMetadata resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.DocumentationSignatureParser : object {
    private static Char[] s_nameDelimiters;
    private static DocumentationSignatureParser();
    public static IEnumerable`1<IMemberDefinition> GetMembersForDocumentationSignature(string id, ModuleDefinition module, ITryResolveMetadata resolver);
    public static TypeDefinition GetTypeByDocumentationSignature(AssemblyDefinition assembly, string signature, ITryResolveMetadata resolver);
    public static IEnumerable`1<IMemberDefinition> GetMembersByDocumentationSignature(TypeDefinition type, string signature, ITryResolveMetadata resolver, bool acceptName);
    private static string GetSignaturePart(TypeReference type, ITryResolveMetadata resolver);
    private static bool ParseDocumentationSignature(string id, ModuleDefinition module, List`1<IMemberDefinition> results, ITryResolveMetadata resolver);
    private static void ParseSignature(string id, Int32& index, ModuleDefinition module, List`1<IMemberDefinition> results, ITryResolveMetadata resolver);
    public static void ParseSignaturePart(string id, Int32& index, ModuleDefinition module, MemberType memberTypes, List`1<IMemberDefinition> results, ITryResolveMetadata resolver);
    public static void GetMatchingMembers(string id, Int32& index, ModuleDefinition module, TypeDefinition containingType, string memberName, int arity, MemberType memberTypes, List`1<IMemberDefinition> results, ITryResolveMetadata resolver, bool acceptName);
    public static ValueTuple`2<string, int> ParseTypeOrNamespaceName(string id, Int32& index, StringBuilder nameBuilder);
    [NullableContextAttribute("2")]
private static string ParseTypeSymbol(string id, Int32& index, IGenericParameterProvider typeParameterContext);
    private static void ParseTypeSymbol(string id, Int32& index, IGenericParameterProvider typeParameterContext, List`1<string> results);
    private static void ParseTypeParameterSymbol(string id, Int32& index, IGenericParameterProvider typeParameterContext, List`1<string> results);
    private static void ParseNamedTypeSymbol(string id, Int32& index, IGenericParameterProvider typeParameterContext, List`1<string> results);
    private static int ParseArrayBounds(string id, Int32& index);
    private static bool ParseTypeArguments(string id, Int32& index, IGenericParameterProvider typeParameterContext, List`1<string> typeArguments);
    private static void GetMatchingTypes(ModuleDefinition module, TypeDefinition declaringType, string name, int arity, List`1<IMemberDefinition> results, ITryResolveMetadata resolver);
    private static void GetMatchingMethods(string id, Int32& index, TypeDefinition type, string memberName, int arity, List`1<IMemberDefinition> results, ITryResolveMetadata resolver, bool acceptName);
    private static void GetMatchingProperties(string id, Int32& index, TypeDefinition type, string memberName, List`1<IMemberDefinition> results, ITryResolveMetadata resolver, bool acceptName);
    private static void GetMatchingFields(TypeDefinition type, string memberName, List`1<IMemberDefinition> results);
    private static void GetMatchingEvents(TypeDefinition type, string memberName, List`1<IMemberDefinition> results);
    private static bool AllParametersMatch(Collection`1<ParameterDefinition> methodParameters, List`1<string> expectedParameters, ITryResolveMetadata resolver);
    private static bool ParseParameterList(string id, Int32& index, IGenericParameterProvider typeParameterContext, List`1<string> parameters);
    private static char PeekNextChar(string id, int index);
    private static string ParseName(string id, Int32& index);
    private static string DecodeName(string name);
    private static int ReadNextInteger(string id, Int32& index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Driver : object {
    private static string resolvers;
    private static string _linker;
    private Queue`1<string> arguments;
    private bool _needAddBypassNGenStep;
    [NullableAttribute("2")]
private LinkContext context;
    protected LinkContext Context { get; }
    public Driver(Queue`1<string> arguments);
    public static int Main(String[] args);
    protected LinkContext get_Context();
    public static bool ProcessResponseFile(String[] args, Queue`1& result);
    public static void ParseResponseFile(TextReader reader, Queue`1<string> result);
    private void ErrorMissingArgument(string optionName);
    [NullableContextAttribute("2")]
protected int SetupContext(ILogger customLogger);
    [NullableContextAttribute("2")]
public int Run(ILogger customLogger);
    private bool LogFatalError(Exception e);
    [IteratorStateMachineAttribute("Mono.Linker.Driver/<ProcessWarningCodes>d__17")]
private static IEnumerable`1<int> ProcessWarningCodes(string value);
    private Assembly GetCustomAssembly(string arg);
    protected virtual void AddResolveFromXmlStep(Pipeline pipeline, string file);
    protected virtual void AddLinkAttributesStep(Pipeline pipeline, string file);
    private static void AddBodySubstituterStep(Pipeline pipeline, string file);
    protected virtual void AddXmlDependencyRecorder(LinkContext context, string fileName);
    protected virtual void AddDgmlDependencyRecorder(LinkContext context, string fileName);
    protected bool AddMarkHandler(Pipeline pipeline, string arg);
    private bool TryGetCustomAssembly(String& arg, Assembly& assembly);
    protected bool AddCustomStep(Pipeline pipeline, string arg);
    protected virtual IStep FindStep(Pipeline pipeline, string name);
    private static IMarkHandler FindMarkHandler(Pipeline pipeline, string name);
    private Type ResolveStepType(string type, Assembly assembly);
    private TStep ResolveStep(string type, Assembly assembly);
    private static String[] GetFiles(string param);
    private static String[] ReadLines(string file);
    private Nullable`1<AssemblyAction> ParseAssemblyAction(string s);
    private Nullable`1<AssemblyRootMode> ParseAssemblyRootsMode(string s);
    private bool GetWarnVersion(string text, WarnVersion& version);
    protected bool GetOptimizationName(string text, CodeOptimizations& optimization);
    private bool TryGetMetadataTrimming(string text, MetadataTrimming& metadataTrimming);
    protected static bool GetWarningSuppressionWriterFileOutputKind(string text, FileOutputKind& fileOutputKind);
    private bool GetBoolParam(string token, Action`1<bool> action);
    private bool GetStringParam(string token, String& value);
    [NullableContextAttribute("2")]
private string GetNextStringValue();
    protected virtual LinkContext GetDefaultContext(Pipeline pipeline, ILogger logger);
    protected virtual List`1<BaseStep> CreateDefaultResolvers();
    private static bool IsValidAssemblyName(string value);
    private static void Usage();
    private static void Version();
    private static void About();
    private static Pipeline GetStandardPipeline();
    public sealed virtual void Dispose();
    [CompilerGeneratedAttribute]
internal static string <ProcessWarningCodes>g__Unquote|17_0(string arg);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
internal static class Mono.Linker.DynamicallyAccessedMembersBinder : object {
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetDynamicallyAccessedMembers>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<IMetadataTokenProvider> GetDynamicallyAccessedMembers(TypeDefinition typeDefinition, LinkContext context, DynamicallyAccessedMemberTypes memberTypes, bool declaredOnly);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetConstructorsOnType>d__1")]
[ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetConstructorsOnType(TypeDefinition type, Func`2<MethodDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetMethodsOnTypeHierarchy>d__2")]
[ExtensionAttribute]
public static IEnumerable`1<MethodDefinition> GetMethodsOnTypeHierarchy(TypeDefinition thisType, LinkContext context, Func`2<MethodDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetFieldsOnTypeHierarchy>d__3")]
[ExtensionAttribute]
public static IEnumerable`1<FieldDefinition> GetFieldsOnTypeHierarchy(TypeDefinition thisType, LinkContext context, Func`2<FieldDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetNestedTypesOnType>d__4")]
[ExtensionAttribute]
public static IEnumerable`1<TypeDefinition> GetNestedTypesOnType(TypeDefinition type, Func`2<TypeDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetPropertiesOnTypeHierarchy>d__5")]
[ExtensionAttribute]
public static IEnumerable`1<PropertyDefinition> GetPropertiesOnTypeHierarchy(TypeDefinition thisType, LinkContext context, Func`2<PropertyDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetEventsOnTypeHierarchy>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<EventDefinition> GetEventsOnTypeHierarchy(TypeDefinition thisType, LinkContext context, Func`2<EventDefinition, bool> filter, Nullable`1<BindingFlags> bindingFlags);
    [IteratorStateMachineAttribute("Mono.Linker.DynamicallyAccessedMembersBinder/<GetAllInterfaceImplementations>d__7")]
[ExtensionAttribute]
public static IEnumerable`1<InterfaceImplementation> GetAllInterfaceImplementations(TypeDefinition thisType, LinkContext context, bool declaredOnly);
    [ExtensionAttribute]
public static void GetAllOnType(TypeDefinition type, LinkContext context, bool declaredOnly, List`1<IMetadataTokenProvider> members);
    private static void GetAllOnType(TypeDefinition type, LinkContext context, bool declaredOnly, List`1<IMetadataTokenProvider> members, HashSet`1<TypeDefinition> types);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[AttributeUsageAttribute("352")]
internal class Mono.Linker.DynamicDependency : Attribute {
    [CompilerGeneratedAttribute]
private CustomAttribute <OriginalAttribute>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MemberSignature>k__BackingField;
    [CompilerGeneratedAttribute]
private DynamicallyAccessedMemberTypes <MemberTypes>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeReference <Type>k__BackingField;
    [CompilerGeneratedAttribute]
private string <TypeName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Condition>k__BackingField;
    public CustomAttribute OriginalAttribute { get; private set; }
    public string MemberSignature { get; }
    public DynamicallyAccessedMemberTypes MemberTypes { get; }
    public TypeReference Type { get; }
    public string TypeName { get; }
    public string AssemblyName { get; }
    public string Condition { get; public set; }
    [NullableContextAttribute("1")]
public DynamicDependency(string memberSignature);
    [NullableContextAttribute("1")]
public DynamicDependency(string memberSignature, TypeReference type);
    [NullableContextAttribute("1")]
public DynamicDependency(string memberSignature, string typeName, string assemblyName);
    [NullableContextAttribute("1")]
public DynamicDependency(DynamicallyAccessedMemberTypes memberTypes, TypeReference type);
    [NullableContextAttribute("1")]
public DynamicDependency(DynamicallyAccessedMemberTypes memberTypes, string typeName, string assemblyName);
    [CompilerGeneratedAttribute]
public CustomAttribute get_OriginalAttribute();
    [CompilerGeneratedAttribute]
private void set_OriginalAttribute(CustomAttribute value);
    [CompilerGeneratedAttribute]
public string get_MemberSignature();
    [CompilerGeneratedAttribute]
public DynamicallyAccessedMemberTypes get_MemberTypes();
    [CompilerGeneratedAttribute]
public TypeReference get_Type();
    [CompilerGeneratedAttribute]
public string get_TypeName();
    [CompilerGeneratedAttribute]
public string get_AssemblyName();
    [CompilerGeneratedAttribute]
public string get_Condition();
    [CompilerGeneratedAttribute]
public void set_Condition(string value);
    [NullableContextAttribute("1")]
public static DynamicDependency ProcessAttribute(LinkContext context, ICustomAttributeProvider provider, CustomAttribute customAttribute);
    [NullableContextAttribute("1")]
private static DynamicDependency GetDynamicDependency(CustomAttribute ca);
    [NullableContextAttribute("1")]
public static bool ShouldProcess(LinkContext context, CustomAttribute ca);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.EmbeddedXmlInfo : object {
    private static EmbeddedResource GetEmbeddedXml(AssemblyDefinition assembly, Func`2<Resource, bool> predicate);
    public static void ProcessDescriptors(AssemblyDefinition assembly, LinkContext context);
    public static SubstitutionInfo ProcessSubstitutions(AssemblyDefinition assembly, LinkContext context);
    public static AttributeInfo ProcessAttributes(AssemblyDefinition assembly, LinkContext context);
    private static string GetAssemblyName(string descriptor);
    private static bool ShouldProcessRootDescriptorResource(AssemblyDefinition assembly, LinkContext context, string resourceName);
    private static DescriptorMarker GetExternalResolveStep(LinkContext context, EmbeddedResource resource, AssemblyDefinition assembly);
    private static BodySubstitutionParser GetExternalSubstitutionParser(LinkContext context, EmbeddedResource resource, AssemblyDefinition assembly);
    private static LinkAttributesParser GetExternalLinkAttributesParser(LinkContext context, EmbeddedResource resource, AssemblyDefinition assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.FeatureSettings : object {
    public static bool ShouldProcessElement(XPathNavigator nav, LinkContext context, string documentLocation);
    public static string GetAttribute(XPathNavigator nav, string attribute);
}
[ExtensionAttribute]
internal static class Mono.Linker.FieldDefinitionExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static bool IsCompilerGenerated(FieldDefinition field);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.IDependencyRecorder {
    public abstract virtual void RecordDependency(object source, object target, bool marked);
    public abstract virtual void RecordDependency(object target, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, bool marked);
    public abstract virtual void FinishRecording();
}
public interface Mono.Linker.ILogger {
    public abstract virtual void LogMessage(MessageContainer message);
}
[ExtensionAttribute]
internal static class Mono.Linker.ILProcessorExtensions : object {
    [NullableContextAttribute("1")]
[ExtensionAttribute]
public static LinkerILProcessor GetLinkerILProcessor(MethodBody body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Mono.Linker.InterfacesOnStackScanner : ValueType {
    private LinkContext context;
    public InterfacesOnStackScanner(LinkContext context);
    public IEnumerable`1<ValueTuple`2<InterfaceImplementation, TypeDefinition>> GetReferencedInterfaces(MethodIL methodIL);
    private HashSet`1<TypeDefinition> AllPossibleStackTypes(MethodIL methodIL);
    private void AddMatchingInterfaces(HashSet`1<ValueTuple`2<InterfaceImplementation, TypeDefinition>> results, TypeDefinition type, TypeDefinition[] interfaceTypes);
    private bool HasInterface(TypeDefinition type, TypeDefinition interfaceType, InterfaceImplementation& implementation);
    private void AddFromGenericInstance(HashSet`1<TypeDefinition> set, IGenericInstance instance);
    private void AddFromGenericParameterProvider(HashSet`1<TypeDefinition> set, IGenericParameterProvider provider);
    private void AddIfResolved(HashSet`1<TypeDefinition> set, TypeReference item);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.InternalErrorException : Exception {
    public InternalErrorException(string message);
    public InternalErrorException(string message, Exception innerException);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.ITryResolveMetadata {
    public abstract virtual MethodDefinition TryResolve(MethodReference methodReference);
    public abstract virtual TypeDefinition TryResolve(TypeReference typeReference);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.IXApiVisitor {
    public abstract virtual void OnAssembly(XPathNavigator nav, AssemblyDefinition assembly);
    public abstract virtual void OnAttribute(XPathNavigator nav);
    public abstract virtual void OnClass(XPathNavigator nav, TypeDefinition type);
    public abstract virtual void OnInterface(XPathNavigator nav, TypeDefinition type);
    public abstract virtual void OnField(XPathNavigator nav, FieldDefinition field);
    public abstract virtual void OnMethod(XPathNavigator nav, MethodDefinition method);
    public abstract virtual void OnConstructor(XPathNavigator nav, MethodDefinition method);
    public abstract virtual void OnProperty(XPathNavigator nav, PropertyDefinition property);
    public abstract virtual void OnEvent(XPathNavigator nav, EventDefinition evt);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
public class Mono.Linker.KnownMembers : object {
    [CompilerGeneratedAttribute]
private MethodDefinition <NotSupportedExceptionCtorString>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDefinition <DisablePrivateReflectionAttributeCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private MethodDefinition <ObjectCtor>k__BackingField;
    [CompilerGeneratedAttribute]
private TypeDefinition <RemoveAttributeInstancesAttributeDefinition>k__BackingField;
    public MethodDefinition NotSupportedExceptionCtorString { get; public set; }
    public MethodDefinition DisablePrivateReflectionAttributeCtor { get; public set; }
    public MethodDefinition ObjectCtor { get; public set; }
    public TypeDefinition RemoveAttributeInstancesAttributeDefinition { get; public set; }
    [CompilerGeneratedAttribute]
public MethodDefinition get_NotSupportedExceptionCtorString();
    [CompilerGeneratedAttribute]
public void set_NotSupportedExceptionCtorString(MethodDefinition value);
    [CompilerGeneratedAttribute]
public MethodDefinition get_DisablePrivateReflectionAttributeCtor();
    [CompilerGeneratedAttribute]
public void set_DisablePrivateReflectionAttributeCtor(MethodDefinition value);
    [CompilerGeneratedAttribute]
public MethodDefinition get_ObjectCtor();
    [CompilerGeneratedAttribute]
public void set_ObjectCtor(MethodDefinition value);
    [CompilerGeneratedAttribute]
public TypeDefinition get_RemoveAttributeInstancesAttributeDefinition();
    [CompilerGeneratedAttribute]
public void set_RemoveAttributeInstancesAttributeDefinition(TypeDefinition value);
    [NullableContextAttribute("1")]
public static bool IsNotSupportedExceptionCtorString(MethodDefinition method);
    [NullableContextAttribute("1")]
public static bool IsSatelliteAssemblyMarker(MethodDefinition method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.LinkContext : object {
    private Pipeline _pipeline;
    private Dictionary`2<string, AssemblyAction> _actions;
    private Dictionary`2<string, string> _parameters;
    private Nullable`1<int> _targetRuntime;
    private AssemblyResolver _resolver;
    private TypeNameResolver _typeNameResolver;
    private AnnotationStore _annotations;
    private CustomAttributeSource _customAttributes;
    private CompilerGeneratedState _compilerGeneratedState;
    private List`1<MessageContainer> _cachedWarningMessageContainers;
    private ILogger _logger;
    private Dictionary`2<AssemblyDefinition, bool> _isTrimmable;
    private UnreachableBlocksOptimizer _unreachableBlocksOptimizer;
    [CompilerGeneratedAttribute]
private bool <DeterministicOutput>k__BackingField;
    [CompilerGeneratedAttribute]
private int <ErrorsCount>k__BackingField;
    [CompilerGeneratedAttribute]
private string <OutputDirectory>k__BackingField;
    [CompilerGeneratedAttribute]
private MetadataTrimming <MetadataTrimming>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyAction <TrimAction>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyAction <DefaultAction>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LinkSymbols>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepTypeForwarderOnlyAssemblies>k__BackingField;
    public bool KeepMembersForDebugger;
    [CompilerGeneratedAttribute]
private bool <IgnoreUnresolved>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableReducedTracing>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <KeepUsedAttributeTypesOnly>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <EnableSerializationDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableOperatorDiscovery>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <DisableEventSourceSpecialHandling>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreDescriptors>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreSubstitutions>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IgnoreLinkAttributes>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, bool> <FeatureSettings>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<PInvokeInfo> <PInvokes>k__BackingField;
    [NullableAttribute("2")]
public string PInvokesListFile;
    [CompilerGeneratedAttribute]
private bool <StripSecurity>k__BackingField;
    [CompilerGeneratedAttribute]
private ISymbolReaderProvider <SymbolReaderProvider>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <LogMessages>k__BackingField;
    [CompilerGeneratedAttribute]
private MarkingHelpers <MarkingHelpers>k__BackingField;
    [CompilerGeneratedAttribute]
private KnownMembers <MarkedKnownMembers>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private WarningSuppressionWriter <WarningSuppressionWriter>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<int> <NoWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <NoTrimWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<int, bool> <WarnAsError>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneralWarnAsError>k__BackingField;
    [CompilerGeneratedAttribute]
private WarnVersion <WarnVersion>k__BackingField;
    [CompilerGeneratedAttribute]
private UnconditionalSuppressMessageAttributeState <Suppressions>k__BackingField;
    [CompilerGeneratedAttribute]
private Tracer <Tracer>k__BackingField;
    [CompilerGeneratedAttribute]
private CodeOptimizationsSettings <Optimizations>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <AddReflectionAnnotations>k__BackingField;
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private string <AssemblyListFile>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<IMarkHandler> <MarkHandlers>k__BackingField;
    [CompilerGeneratedAttribute]
private Dictionary`2<string, bool> <SingleWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <GeneralSingleWarn>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<string> <AssembliesWithGeneratedSingleWarning>k__BackingField;
    [CompilerGeneratedAttribute]
private SerializationMarker <SerializationMarker>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<MethodReference, MethodDefinition> methodresolveCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<FieldReference, FieldDefinition> fieldresolveCache;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TypeReference, TypeDefinition> typeresolveCache;
    private HashSet`1<MethodDefinition> _processed_bodies_for_method;
    private HashSet`1<MemberReference> unresolved_reported;
    public Pipeline Pipeline { get; }
    public CustomAttributeSource CustomAttributes { get; }
    public CompilerGeneratedState CompilerGeneratedState { get; }
    public AnnotationStore Annotations { get; }
    public bool DeterministicOutput { get; public set; }
    public int ErrorsCount { get; private set; }
    public string OutputDirectory { get; public set; }
    public MetadataTrimming MetadataTrimming { get; public set; }
    public AssemblyAction TrimAction { get; public set; }
    public AssemblyAction DefaultAction { get; public set; }
    public bool LinkSymbols { get; public set; }
    public bool KeepTypeForwarderOnlyAssemblies { get; public set; }
    public bool IgnoreUnresolved { get; public set; }
    public bool EnableReducedTracing { get; public set; }
    public bool KeepUsedAttributeTypesOnly { get; public set; }
    public bool EnableSerializationDiscovery { get; public set; }
    public bool DisableOperatorDiscovery { get; public set; }
    public bool DisableEventSourceSpecialHandling { get; public set; }
    public bool IgnoreDescriptors { get; public set; }
    public bool IgnoreSubstitutions { get; public set; }
    public bool IgnoreLinkAttributes { get; public set; }
    public Dictionary`2<string, bool> FeatureSettings { get; public set; }
    public List`1<PInvokeInfo> PInvokes { get; private set; }
    public bool StripSecurity { get; public set; }
    public Dictionary`2<string, AssemblyAction> Actions { get; }
    public AssemblyResolver Resolver { get; }
    internal TypeNameResolver TypeNameResolver { get; }
    public ISymbolReaderProvider SymbolReaderProvider { get; public set; }
    public bool LogMessages { get; public set; }
    public MarkingHelpers MarkingHelpers { get; private set; }
    public KnownMembers MarkedKnownMembers { get; private set; }
    [NullableAttribute("2")]
public WarningSuppressionWriter WarningSuppressionWriter { get; public set; }
    public HashSet`1<int> NoWarn { get; public set; }
    public bool NoTrimWarn { get; public set; }
    public Dictionary`2<int, bool> WarnAsError { get; public set; }
    public bool GeneralWarnAsError { get; public set; }
    public WarnVersion WarnVersion { get; public set; }
    public UnconditionalSuppressMessageAttributeState Suppressions { get; public set; }
    public Tracer Tracer { get; private set; }
    public CodeOptimizationsSettings Optimizations { get; public set; }
    public bool AddReflectionAnnotations { get; public set; }
    [NullableAttribute("2")]
public string AssemblyListFile { get; public set; }
    public List`1<IMarkHandler> MarkHandlers { get; }
    public Dictionary`2<string, bool> SingleWarn { get; public set; }
    public bool GeneralSingleWarn { get; public set; }
    public HashSet`1<string> AssembliesWithGeneratedSingleWarning { get; public set; }
    public SerializationMarker SerializationMarker { get; }
    public LinkContext(Pipeline pipeline, ILogger logger, string outputDirectory);
    public Pipeline get_Pipeline();
    public CustomAttributeSource get_CustomAttributes();
    public CompilerGeneratedState get_CompilerGeneratedState();
    public AnnotationStore get_Annotations();
    [CompilerGeneratedAttribute]
public bool get_DeterministicOutput();
    [CompilerGeneratedAttribute]
public void set_DeterministicOutput(bool value);
    [CompilerGeneratedAttribute]
public int get_ErrorsCount();
    [CompilerGeneratedAttribute]
private void set_ErrorsCount(int value);
    [CompilerGeneratedAttribute]
public string get_OutputDirectory();
    [CompilerGeneratedAttribute]
public void set_OutputDirectory(string value);
    [CompilerGeneratedAttribute]
public MetadataTrimming get_MetadataTrimming();
    [CompilerGeneratedAttribute]
public void set_MetadataTrimming(MetadataTrimming value);
    [CompilerGeneratedAttribute]
public AssemblyAction get_TrimAction();
    [CompilerGeneratedAttribute]
public void set_TrimAction(AssemblyAction value);
    [CompilerGeneratedAttribute]
public AssemblyAction get_DefaultAction();
    [CompilerGeneratedAttribute]
public void set_DefaultAction(AssemblyAction value);
    [CompilerGeneratedAttribute]
public bool get_LinkSymbols();
    [CompilerGeneratedAttribute]
public void set_LinkSymbols(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepTypeForwarderOnlyAssemblies();
    [CompilerGeneratedAttribute]
public void set_KeepTypeForwarderOnlyAssemblies(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreUnresolved();
    [CompilerGeneratedAttribute]
public void set_IgnoreUnresolved(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableReducedTracing();
    [CompilerGeneratedAttribute]
public void set_EnableReducedTracing(bool value);
    [CompilerGeneratedAttribute]
public bool get_KeepUsedAttributeTypesOnly();
    [CompilerGeneratedAttribute]
public void set_KeepUsedAttributeTypesOnly(bool value);
    [CompilerGeneratedAttribute]
public bool get_EnableSerializationDiscovery();
    [CompilerGeneratedAttribute]
public void set_EnableSerializationDiscovery(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableOperatorDiscovery();
    [CompilerGeneratedAttribute]
public void set_DisableOperatorDiscovery(bool value);
    [CompilerGeneratedAttribute]
public bool get_DisableEventSourceSpecialHandling();
    [CompilerGeneratedAttribute]
public void set_DisableEventSourceSpecialHandling(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreDescriptors();
    [CompilerGeneratedAttribute]
public void set_IgnoreDescriptors(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreSubstitutions();
    [CompilerGeneratedAttribute]
public void set_IgnoreSubstitutions(bool value);
    [CompilerGeneratedAttribute]
public bool get_IgnoreLinkAttributes();
    [CompilerGeneratedAttribute]
public void set_IgnoreLinkAttributes(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<string, bool> get_FeatureSettings();
    [CompilerGeneratedAttribute]
public Void modreq(System.Runtime.CompilerServices.IsExternalInit) set_FeatureSettings(Dictionary`2<string, bool> value);
    [CompilerGeneratedAttribute]
public List`1<PInvokeInfo> get_PInvokes();
    [CompilerGeneratedAttribute]
private void set_PInvokes(List`1<PInvokeInfo> value);
    [CompilerGeneratedAttribute]
public bool get_StripSecurity();
    [CompilerGeneratedAttribute]
public void set_StripSecurity(bool value);
    public Dictionary`2<string, AssemblyAction> get_Actions();
    public AssemblyResolver get_Resolver();
    internal TypeNameResolver get_TypeNameResolver();
    [CompilerGeneratedAttribute]
public ISymbolReaderProvider get_SymbolReaderProvider();
    [CompilerGeneratedAttribute]
public void set_SymbolReaderProvider(ISymbolReaderProvider value);
    [CompilerGeneratedAttribute]
public bool get_LogMessages();
    [CompilerGeneratedAttribute]
public void set_LogMessages(bool value);
    [CompilerGeneratedAttribute]
public MarkingHelpers get_MarkingHelpers();
    [CompilerGeneratedAttribute]
private void set_MarkingHelpers(MarkingHelpers value);
    [CompilerGeneratedAttribute]
public KnownMembers get_MarkedKnownMembers();
    [CompilerGeneratedAttribute]
private void set_MarkedKnownMembers(KnownMembers value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public WarningSuppressionWriter get_WarningSuppressionWriter();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_WarningSuppressionWriter(WarningSuppressionWriter value);
    [CompilerGeneratedAttribute]
public HashSet`1<int> get_NoWarn();
    [CompilerGeneratedAttribute]
public void set_NoWarn(HashSet`1<int> value);
    [CompilerGeneratedAttribute]
public bool get_NoTrimWarn();
    [CompilerGeneratedAttribute]
public void set_NoTrimWarn(bool value);
    [CompilerGeneratedAttribute]
public Dictionary`2<int, bool> get_WarnAsError();
    [CompilerGeneratedAttribute]
public void set_WarnAsError(Dictionary`2<int, bool> value);
    [CompilerGeneratedAttribute]
public bool get_GeneralWarnAsError();
    [CompilerGeneratedAttribute]
public void set_GeneralWarnAsError(bool value);
    [CompilerGeneratedAttribute]
public WarnVersion get_WarnVersion();
    [CompilerGeneratedAttribute]
public void set_WarnVersion(WarnVersion value);
    [CompilerGeneratedAttribute]
public UnconditionalSuppressMessageAttributeState get_Suppressions();
    [CompilerGeneratedAttribute]
public void set_Suppressions(UnconditionalSuppressMessageAttributeState value);
    [CompilerGeneratedAttribute]
public Tracer get_Tracer();
    [CompilerGeneratedAttribute]
private void set_Tracer(Tracer value);
    [CompilerGeneratedAttribute]
public CodeOptimizationsSettings get_Optimizations();
    [CompilerGeneratedAttribute]
public void set_Optimizations(CodeOptimizationsSettings value);
    [CompilerGeneratedAttribute]
public bool get_AddReflectionAnnotations();
    [CompilerGeneratedAttribute]
public void set_AddReflectionAnnotations(bool value);
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public string get_AssemblyListFile();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
public void set_AssemblyListFile(string value);
    [CompilerGeneratedAttribute]
public List`1<IMarkHandler> get_MarkHandlers();
    [CompilerGeneratedAttribute]
public Dictionary`2<string, bool> get_SingleWarn();
    [CompilerGeneratedAttribute]
public void set_SingleWarn(Dictionary`2<string, bool> value);
    [CompilerGeneratedAttribute]
public bool get_GeneralSingleWarn();
    [CompilerGeneratedAttribute]
public void set_GeneralSingleWarn(bool value);
    [CompilerGeneratedAttribute]
public HashSet`1<string> get_AssembliesWithGeneratedSingleWarning();
    [CompilerGeneratedAttribute]
public void set_AssembliesWithGeneratedSingleWarning(HashSet`1<string> value);
    [CompilerGeneratedAttribute]
public SerializationMarker get_SerializationMarker();
    public void SetFeatureValue(string feature, bool value);
    public bool HasFeatureValue(string feature, bool value);
    public TypeDefinition GetType(string fullName);
    public AssemblyDefinition TryResolve(string name);
    public AssemblyDefinition TryResolve(AssemblyNameReference name);
    public AssemblyDefinition Resolve(IMetadataScope scope);
    public AssemblyDefinition Resolve(AssemblyNameReference name);
    public void RegisterAssembly(AssemblyDefinition assembly);
    protected bool SeenFirstTime(AssemblyDefinition assembly);
    public virtual void SafeReadSymbols(AssemblyDefinition assembly);
    public virtual ICollection`1<AssemblyDefinition> ResolveReferences(AssemblyDefinition assembly);
    private static AssemblyNameReference GetReference(IMetadataScope scope);
    public void RegisterAssemblyAction(string assemblyName, AssemblyAction action);
    public void SetAction(AssemblyDefinition assembly, AssemblyAction defaultAction);
    public AssemblyAction CalculateAssemblyAction(AssemblyDefinition assembly);
    public bool IsTrimmable(AssemblyDefinition assembly);
    public virtual AssemblyDefinition[] GetAssemblies();
    public AssemblyDefinition GetLoadedAssembly(string name);
    public string GetAssemblyLocation(AssemblyDefinition assembly);
    [IteratorStateMachineAttribute("Mono.Linker.LinkContext/<GetReferencedAssemblies>d__207")]
public IEnumerable`1<AssemblyDefinition> GetReferencedAssemblies();
    public void SetCustomData(string key, string value);
    public bool HasCustomData(string key);
    public bool TryGetCustomData(string key, String& value);
    public sealed virtual void Dispose();
    public bool IsOptimizationEnabled(CodeOptimizations optimization, MemberReference context);
    [NullableContextAttribute("2")]
public bool IsOptimizationEnabled(CodeOptimizations optimization, AssemblyDefinition context);
    public bool CanApplyOptimization(CodeOptimizations optimization, AssemblyDefinition context);
    public void LogMessage(MessageContainer message);
    public void LogMessage(string message);
    public void LogDiagnostic(string message);
    public void LogWarning(string text, int code, MessageOrigin origin, string subcategory);
    public void LogWarning(MessageOrigin origin, DiagnosticId id, String[] args);
    public void LogWarning(string text, int code, IMemberDefinition origin, Nullable`1<int> ilOffset, string subcategory);
    public void LogWarning(IMemberDefinition origin, DiagnosticId id, Nullable`1<int> ilOffset, String[] args);
    public void LogWarning(IMemberDefinition origin, DiagnosticId id, String[] args);
    public void LogWarning(string text, int code, string origin, string subcategory);
    public void LogWarning(string origin, DiagnosticId id, String[] args);
    public void LogError(string text, int code, string subcategory, Nullable`1<MessageOrigin> origin);
    public void LogError(Nullable`1<MessageOrigin> origin, DiagnosticId id, String[] args);
    public void FlushCachedWarnings();
    public bool IsWarningSuppressed(int warningCode, string subcategory, MessageOrigin origin);
    public bool IsWarningAsError(int warningCode);
    public bool IsSingleWarn(string assemblyName);
    private static WarnVersion GetWarningVersion();
    public int GetTargetRuntimeVersion();
    public sealed virtual MethodDefinition Resolve(MethodReference methodReference);
    public sealed virtual MethodDefinition TryResolve(MethodReference methodReference);
    public sealed virtual FieldDefinition Resolve(FieldReference fieldReference);
    public FieldDefinition TryResolve(FieldReference fieldReference);
    public sealed virtual TypeDefinition Resolve(TypeReference typeReference);
    public sealed virtual TypeDefinition TryResolve(TypeReference typeReference);
    public TypeDefinition TryResolve(AssemblyDefinition assembly, string typeNameString);
    public MethodIL GetMethodIL(MethodBody methodBody);
    public MethodIL GetMethodIL(MethodDefinition method);
    protected virtual void ReportUnresolved(FieldReference fieldReference);
    protected virtual void ReportUnresolved(MethodReference methodReference);
    protected virtual void ReportUnresolved(TypeReference typeReference);
    [CompilerGeneratedAttribute]
internal static bool <CalculateAssemblyAction>g__IsCPPCLIAssembly|202_0(ModuleDefinition module);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
internal class Mono.Linker.LinkerAttributesInformation : ValueType {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`2<Type, List`1<Attribute>>> _linkerAttributes;
    private LinkerAttributesInformation(List`1<ValueTuple`2<Type, List`1<Attribute>>> cache);
    private static bool TryFindAttributeList(List`1<ValueTuple`2<Type, List`1<Attribute>>> list, Type type, List`1& foundAttributes);
    public static LinkerAttributesInformation Create(LinkContext context, IMemberDefinition provider);
    [NullableContextAttribute("0")]
public bool HasAttribute();
    public IEnumerable`1<T> GetAttributes();
    private static Attribute ProcessRequiresUnreferencedCodeAttribute(LinkContext context, ICustomAttributeProvider provider, CustomAttribute customAttribute);
}
public class Mono.Linker.LinkerFatalErrorException : Exception {
    [CompilerGeneratedAttribute]
private MessageContainer <MessageContainer>k__BackingField;
    public MessageContainer MessageContainer { get; }
    public LinkerFatalErrorException(MessageContainer message);
    [NullableContextAttribute("1")]
public LinkerFatalErrorException(MessageContainer message, Exception innerException);
    [CompilerGeneratedAttribute]
public MessageContainer get_MessageContainer();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.LinkerILProcessor : object {
    private ILProcessor _ilProcessor;
    private Collection`1<Instruction> Instructions { get; }
    internal LinkerILProcessor(MethodBody body);
    private Collection`1<Instruction> get_Instructions();
    public void Emit(OpCode opcode);
    public void Emit(OpCode opcode, TypeReference type);
    public void Emit(OpCode opcode, MethodReference method);
    public void Emit(OpCode opcode, VariableDefinition variable);
    public void Emit(OpCode opcode, string value);
    public void InsertBefore(Instruction target, Instruction instruction);
    public void InsertAfter(Instruction target, Instruction instruction);
    public void Append(Instruction instruction);
    public void Replace(Instruction target, Instruction instruction);
    public void Replace(int index, Instruction instruction);
    public void Remove(Instruction instruction);
    public void RemoveAt(int index);
    private void RedirectScopeStart(Instruction oldTarget, Instruction newTarget);
    [NullableContextAttribute("2")]
private static void RedirectScopeEnd(Instruction oldTarget, Instruction newTarget);
    private void ReplaceInstructionReference(Instruction oldTarget, Instruction newTarget);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.MarkingHelpers : object {
    protected LinkContext _context;
    public MarkingHelpers(LinkContext context);
    public void MarkMatchingExportedType(TypeDefinition typeToMatch, AssemblyDefinition assembly, DependencyInfo& reason, MessageOrigin& origin);
    public void MarkExportedType(ExportedType exportedType, ModuleDefinition module, DependencyInfo& reason, MessageOrigin& origin);
    public void MarkForwardedScope(TypeReference typeReference, MessageOrigin& origin);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.MemberActionStore : object {
    [CompilerGeneratedAttribute]
private SubstitutionInfo <PrimarySubstitutionInfo>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<AssemblyDefinition, SubstitutionInfo> _embeddedXmlInfos;
    private LinkContext _context;
    public SubstitutionInfo PrimarySubstitutionInfo { get; }
    public MemberActionStore(LinkContext context);
    [CompilerGeneratedAttribute]
public SubstitutionInfo get_PrimarySubstitutionInfo();
    public bool TryGetSubstitutionInfo(MemberReference member, SubstitutionInfo& xmlInfo);
    public MethodAction GetAction(MethodDefinition method);
    public bool TryGetMethodStubValue(MethodDefinition method, Object& value);
    public bool TryGetFieldUserValue(FieldDefinition field, Object& value);
    public bool HasSubstitutedInit(FieldDefinition field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.MemberReferenceExtensions : object {
    [ExtensionAttribute]
public static string GetDisplayName(MemberReference member);
    [ExtensionAttribute]
public static string GetNamespaceDisplayName(MemberReference member);
}
public enum Mono.Linker.MessageCategory : Enum {
    public int value__;
    public static MessageCategory Error;
    public static MessageCategory Warning;
    public static MessageCategory Info;
    public static MessageCategory Diagnostic;
    public static MessageCategory WarningAsError;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.MessageContainer : ValueType {
    public static MessageContainer Empty;
    [CompilerGeneratedAttribute]
private Nullable`1<MessageOrigin> <Origin>k__BackingField;
    [CompilerGeneratedAttribute]
private MessageCategory <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <SubCategory>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <Code>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Text>k__BackingField;
    public Nullable`1<MessageOrigin> Origin { get; }
    public MessageCategory Category { get; }
    public string SubCategory { get; }
    public Nullable`1<int> Code { get; }
    public string Text { get; }
    private MessageContainer(MessageCategory category, string text, Nullable`1<int> code, string subcategory, Nullable`1<MessageOrigin> origin);
    private MessageContainer(MessageCategory category, DiagnosticId id, string subcategory, Nullable`1<MessageOrigin> origin, String[] args);
    [CompilerGeneratedAttribute]
public Nullable`1<MessageOrigin> get_Origin();
    [CompilerGeneratedAttribute]
public MessageCategory get_Category();
    [CompilerGeneratedAttribute]
public string get_SubCategory();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_Code();
    [CompilerGeneratedAttribute]
public string get_Text();
    internal static MessageContainer CreateErrorMessage(string text, int code, string subcategory, Nullable`1<MessageOrigin> origin);
    internal static MessageContainer CreateErrorMessage(Nullable`1<MessageOrigin> origin, DiagnosticId id, String[] args);
    public static MessageContainer CreateCustomErrorMessage(string text, int code, string subcategory, Nullable`1<MessageOrigin> origin);
    internal static MessageContainer CreateWarningMessage(LinkContext context, string text, int code, MessageOrigin origin, WarnVersion version, string subcategory);
    internal static MessageContainer CreateWarningMessage(LinkContext context, MessageOrigin origin, DiagnosticId id, WarnVersion version, String[] args);
    public static MessageContainer CreateCustomWarningMessage(LinkContext context, string text, int code, MessageOrigin origin, WarnVersion version, string subcategory);
    private static MessageContainer CreateWarningMessageContainer(LinkContext context, string text, int code, MessageOrigin origin, WarnVersion version, string subcategory);
    private static MessageContainer CreateWarningMessageContainer(LinkContext context, MessageOrigin origin, DiagnosticId id, WarnVersion version, string subcategory, String[] args);
    public bool IsWarningMessage(Nullable`1& code);
    private static bool TryLogSingleWarning(LinkContext context, int code, MessageOrigin origin, string subcategory);
    public static MessageContainer CreateInfoMessage(string text);
    public static MessageContainer CreateDiagnosticMessage(string text);
    public virtual string ToString();
    public string ToMSBuildString();
    public sealed virtual bool Equals(MessageContainer other);
    [NullableContextAttribute("2")]
public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public sealed virtual int CompareTo(MessageContainer other);
    public static bool op_Equality(MessageContainer lhs, MessageContainer rhs);
    public static bool op_Inequality(MessageContainer lhs, MessageContainer rhs);
}
[NullableContextAttribute("2")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.MessageOrigin : ValueType {
    [CompilerGeneratedAttribute]
private string <FileName>k__BackingField;
    [CompilerGeneratedAttribute]
private ICustomAttributeProvider <Provider>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceLine>k__BackingField;
    [CompilerGeneratedAttribute]
private int <SourceColumn>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<int> <ILOffset>k__BackingField;
    private static int HiddenLineNumber;
    public string FileName { get; }
    public ICustomAttributeProvider Provider { get; }
    public int SourceLine { get; }
    public int SourceColumn { get; }
    public Nullable`1<int> ILOffset { get; }
    public MessageOrigin(IMemberDefinition memberDefinition, Nullable`1<int> ilOffset);
    public MessageOrigin(ICustomAttributeProvider provider);
    [NullableContextAttribute("1")]
public MessageOrigin(string fileName, int sourceLine, int sourceColumn);
    [NullableContextAttribute("1")]
public MessageOrigin(string fileName, int sourceLine, int sourceColumn, AssemblyDefinition assembly);
    public MessageOrigin(ICustomAttributeProvider provider, Nullable`1<int> ilOffset);
    public MessageOrigin(MessageOrigin other);
    public MessageOrigin(MessageOrigin other, int ilOffset);
    [CompilerGeneratedAttribute]
public string get_FileName();
    [CompilerGeneratedAttribute]
public ICustomAttributeProvider get_Provider();
    [CompilerGeneratedAttribute]
public int get_SourceLine();
    [CompilerGeneratedAttribute]
public int get_SourceColumn();
    [CompilerGeneratedAttribute]
public Nullable`1<int> get_ILOffset();
    public MessageOrigin WithInstructionOffset(int ilOffset);
    public virtual string ToString();
    public sealed virtual bool Equals(MessageOrigin other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(MessageOrigin lhs, MessageOrigin rhs);
    public static bool op_Inequality(MessageOrigin lhs, MessageOrigin rhs);
    public sealed virtual int CompareTo(MessageOrigin other);
}
[FlagsAttribute]
public enum Mono.Linker.MetadataTrimming : Enum {
    public int value__;
    public static MetadataTrimming None;
    public static MetadataTrimming ParameterName;
    public static MetadataTrimming Any;
}
public enum Mono.Linker.MethodAction : Enum {
    public int value__;
    public static MethodAction Nothing;
    public static MethodAction Parse;
    public static MethodAction ForceParse;
    public static MethodAction ConvertToStub;
    public static MethodAction ConvertToThrow;
}
public static class Mono.Linker.MethodBodyScanner : object {
    public static bool IsWorthConvertingToThrow(MethodIL body);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.MethodDefinitionExtensions : object {
    [ExtensionAttribute]
public static bool IsDefaultConstructor(MethodDefinition method);
    [ExtensionAttribute]
public static bool IsInstanceConstructor(MethodDefinition method);
    [ExtensionAttribute]
public static bool IsIntrinsic(MethodDefinition method);
    [ExtensionAttribute]
public static bool IsPropertyMethod(MethodDefinition md);
    [ExtensionAttribute]
public static bool IsPublicInstancePropertyMethod(MethodDefinition md);
    [ExtensionAttribute]
public static bool IsEventMethod(MethodDefinition md);
    [ExtensionAttribute]
public static bool TryGetProperty(MethodDefinition md, PropertyDefinition& property);
    [ExtensionAttribute]
public static bool TryGetEvent(MethodDefinition md, EventDefinition& event);
    [ExtensionAttribute]
public static bool IsStaticConstructor(MethodDefinition method);
    [ExtensionAttribute]
public static void ClearDebugInformation(MethodDefinition method);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[IsReadOnlyAttribute]
public class Mono.Linker.MethodIL : ValueType {
    public MethodBody Body;
    public MethodDefinition Method { get; }
    public Collection`1<Instruction> Instructions { get; }
    public Collection`1<ExceptionHandler> ExceptionHandlers { get; }
    public Collection`1<VariableDefinition> Variables { get; }
    private MethodIL(MethodBody body);
    public MethodDefinition get_Method();
    public Collection`1<Instruction> get_Instructions();
    public Collection`1<ExceptionHandler> get_ExceptionHandlers();
    public Collection`1<VariableDefinition> get_Variables();
    public static MethodIL Create(MethodBody body);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual string ToString();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool PrintMembers(StringBuilder builder);
    [CompilerGeneratedAttribute]
public static bool op_Inequality(MethodIL left, MethodIL right);
    [CompilerGeneratedAttribute]
public static bool op_Equality(MethodIL left, MethodIL right);
    [CompilerGeneratedAttribute]
public virtual int GetHashCode();
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
public virtual bool Equals(object obj);
    [CompilerGeneratedAttribute]
public sealed virtual bool Equals(MethodIL other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.MethodReferenceExtensions : object {
    [ExtensionAttribute]
public static string GetDisplayName(MethodReference method);
    [ExtensionAttribute]
public static TypeReference GetReturnType(MethodReference method, LinkContext context);
    [ExtensionAttribute]
public static bool ReturnsVoid(IMethodSignature method);
    [ExtensionAttribute]
public static TypeReference GetParameterType(MethodReference method, int parameterIndex, LinkContext context);
    [ExtensionAttribute]
public static bool IsDeclaredOnType(MethodReference method, string fullTypeName);
    [ExtensionAttribute]
public static bool HasParameterOfType(MethodReference method, int parameterIndex, string fullTypeName);
    [ExtensionAttribute]
public static bool HasImplicitThis(MethodReference method);
    [ExtensionAttribute]
public static ReferenceKind ParameterReferenceKind(MethodReference method, int index);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.ModuleDefinitionExtensions : object {
    [ExtensionAttribute]
public static bool IsCrossgened(ModuleDefinition module);
    [ExtensionAttribute]
public static bool GetMatchingExportedType(ModuleDefinition module, TypeDefinition typeDefinition, ExportedType& exportedType);
    [ExtensionAttribute]
public static TypeDefinition ResolveType(ModuleDefinition module, string typeFullName, ITryResolveMetadata resolver);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DebuggerDisplayAttribute("{Override}")]
public class Mono.Linker.OverrideInformation : object {
    private ITryResolveMetadata resolver;
    private OverridePair _pair;
    [NullableAttribute("2")]
private InterfaceImplementation _matchingInterfaceImplementation;
    public MethodDefinition Base { get; }
    public MethodDefinition Override { get; }
    [NullableAttribute("2")]
public InterfaceImplementation MatchingInterfaceImplementation { get; }
    public bool IsOverrideOfInterfaceMember { get; }
    [NullableAttribute("2")]
public TypeDefinition InterfaceType { get; }
    public bool IsStaticInterfaceMethodPair { get; }
    public OverrideInformation(MethodDefinition base, MethodDefinition override, ITryResolveMetadata resolver, InterfaceImplementation matchingInterfaceImplementation);
    public MethodDefinition get_Base();
    public MethodDefinition get_Override();
    [NullableContextAttribute("2")]
public InterfaceImplementation get_MatchingInterfaceImplementation();
    public bool get_IsOverrideOfInterfaceMember();
    [NullableContextAttribute("2")]
public TypeDefinition get_InterfaceType();
    public bool get_IsStaticInterfaceMethodPair();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[DataContractAttribute]
public class Mono.Linker.PInvokeInfo : object {
    [CompilerGeneratedAttribute]
private string <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <EntryPoint>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FullName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <ModuleName>k__BackingField;
    [DataMemberAttribute]
internal string AssemblyName { get; internal set; }
    [DataMemberAttribute]
internal string EntryPoint { get; internal set; }
    [DataMemberAttribute]
internal string FullName { get; internal set; }
    [DataMemberAttribute]
internal string ModuleName { get; internal set; }
    public PInvokeInfo(string assemblyName, string entryPoint, string fullName, string moduleName);
    [CompilerGeneratedAttribute]
internal string get_AssemblyName();
    [CompilerGeneratedAttribute]
internal void set_AssemblyName(string value);
    [CompilerGeneratedAttribute]
internal string get_EntryPoint();
    [CompilerGeneratedAttribute]
internal void set_EntryPoint(string value);
    [CompilerGeneratedAttribute]
internal string get_FullName();
    [CompilerGeneratedAttribute]
internal void set_FullName(string value);
    [CompilerGeneratedAttribute]
internal string get_ModuleName();
    [CompilerGeneratedAttribute]
internal void set_ModuleName(string value);
    [NullableContextAttribute("2")]
public sealed virtual int CompareTo(PInvokeInfo other);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Pipeline : object {
    private List`1<IStep> _steps;
    [CompilerGeneratedAttribute]
private List`1<IMarkHandler> <MarkHandlers>k__BackingField;
    public List`1<IMarkHandler> MarkHandlers { get; }
    [CompilerGeneratedAttribute]
public List`1<IMarkHandler> get_MarkHandlers();
    public void PrependStep(IStep step);
    public void AppendStep(IStep step);
    public void AppendMarkHandler(IMarkHandler step);
    public void AddStepBefore(Type target, IStep step);
    public void AddStepBefore(IStep target, IStep step);
    public void AddMarkHandlerBefore(IMarkHandler target, IMarkHandler step);
    public void ReplaceStep(Type target, IStep step);
    public void AddStepAfter(Type target, IStep step);
    public void AddStepAfter(IStep target, IStep step);
    public void AddMarkHandlerAfter(IMarkHandler target, IMarkHandler step);
    public void RemoveStep(Type target);
    public void Process(LinkContext context);
    protected virtual void ProcessStep(LinkContext context, IStep step);
    public IStep[] GetSteps();
    public void InitializeMarkHandlers(LinkContext context, MarkContext markContext);
    public bool ContainsStep(Type type);
}
public static class Mono.Linker.PlatformAssemblies : object {
    [NullableAttribute("1")]
public static string CoreLib;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[AttributeUsageAttribute("4")]
public class Mono.Linker.RemoveAttributeInstancesAttribute : Attribute {
    [CompilerGeneratedAttribute]
private CustomAttributeArgument[] <Arguments>k__BackingField;
    public CustomAttributeArgument[] Arguments { get; }
    public RemoveAttributeInstancesAttribute(Collection`1<CustomAttributeArgument> args);
    [CompilerGeneratedAttribute]
public CustomAttributeArgument[] get_Arguments();
}
[GeneratedCodeAttribute("System.Resources.Tools.StronglyTypedResourceBuilder", "16.0.0.0")]
[DebuggerNonUserCodeAttribute]
[CompilerGeneratedAttribute]
internal class Mono.Linker.Resources.Strings : object {
    private static ResourceManager resourceMan;
    private static CultureInfo resourceCulture;
    [EditorBrowsableAttribute("2")]
internal static ResourceManager ResourceManager { get; }
    [EditorBrowsableAttribute("2")]
internal static CultureInfo Culture { get; internal set; }
    internal static string IL2067 { get; }
    internal static string IL2068 { get; }
    internal static string IL2069 { get; }
    internal static string IL2070 { get; }
    internal static string IL2071 { get; }
    internal static string IL2072 { get; }
    internal static string IL2073 { get; }
    internal static string IL2074 { get; }
    internal static string IL2075 { get; }
    internal static string IL2076 { get; }
    internal static string IL2077 { get; }
    internal static string IL2078 { get; }
    internal static string IL2079 { get; }
    internal static string IL2080 { get; }
    internal static string IL2081 { get; }
    internal static string IL2082 { get; }
    internal static string IL2083 { get; }
    internal static string IL2084 { get; }
    internal static string IL2085 { get; }
    internal static string IL2086 { get; }
    internal static string IL2087 { get; }
    internal static string IL2088 { get; }
    internal static string IL2089 { get; }
    internal static string IL2090 { get; }
    internal static string IL2091 { get; }
    internal static string IL2103 { get; }
    internal static string IL2121 { get; }
    internal static ResourceManager get_ResourceManager();
    internal static CultureInfo get_Culture();
    internal static void set_Culture(CultureInfo value);
    internal static string get_IL2067();
    internal static string get_IL2068();
    internal static string get_IL2069();
    internal static string get_IL2070();
    internal static string get_IL2071();
    internal static string get_IL2072();
    internal static string get_IL2073();
    internal static string get_IL2074();
    internal static string get_IL2075();
    internal static string get_IL2076();
    internal static string get_IL2077();
    internal static string get_IL2078();
    internal static string get_IL2079();
    internal static string get_IL2080();
    internal static string get_IL2081();
    internal static string get_IL2082();
    internal static string get_IL2083();
    internal static string get_IL2084();
    internal static string get_IL2085();
    internal static string get_IL2086();
    internal static string get_IL2087();
    internal static string get_IL2088();
    internal static string get_IL2089();
    internal static string get_IL2090();
    internal static string get_IL2091();
    internal static string get_IL2103();
    internal static string get_IL2121();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.SerializationMarker : object {
    private LinkContext _context;
    [CompilerGeneratedAttribute]
private SerializerKind <ActiveSerializers>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<SerializerKind, HashSet`1<ICustomAttributeProvider>> _trackedRoots;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<TypeDefinition> _recursiveTypes;
    private SerializerKind ActiveSerializers { get; private set; }
    private Dictionary`2<SerializerKind, HashSet`1<ICustomAttributeProvider>> TrackedRoots { get; }
    private HashSet`1<TypeDefinition> RecursiveTypes { get; }
    public SerializationMarker(LinkContext context);
    [CompilerGeneratedAttribute]
private SerializerKind get_ActiveSerializers();
    [CompilerGeneratedAttribute]
private void set_ActiveSerializers(SerializerKind value);
    private Dictionary`2<SerializerKind, HashSet`1<ICustomAttributeProvider>> get_TrackedRoots();
    private HashSet`1<TypeDefinition> get_RecursiveTypes();
    public bool IsActive(SerializerKind serializerKind);
    private static DependencyKind ToDependencyKind(SerializerKind serializerKind);
    public void TrackForSerialization(ICustomAttributeProvider provider, SerializerKind serializerKind);
    public void Activate(SerializerKind serializerKind);
    public void MarkRecursiveMembers(ICustomAttributeProvider provider, SerializerKind serializerKind);
    private void MarkRecursiveMembersInternal(TypeReference typeRef, DependencyInfo& reason);
}
[FlagsAttribute]
public enum Mono.Linker.SerializerKind : Enum {
    public int value__;
    public static SerializerKind None;
    public static SerializerKind XmlSerializer;
    public static SerializerKind DataContractSerializer;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.AddBypassNGenStep : BaseStep {
    [NullableAttribute("2")]
private AssemblyDefinition coreLibAssembly;
    [NullableAttribute("2")]
private CustomAttribute bypassNGenAttribute;
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private void ProcessType(TypeDefinition type);
    private void ProcessMethods(Collection`1<MethodDefinition> methods, ModuleDefinition module);
    private void ProcessNestedTypes(TypeDefinition type);
    private void EnsureBypassNGenAttribute(ModuleDefinition targetModule);
}
[FlagsAttribute]
public enum Mono.Linker.Steps.AllowedAssemblies : Enum {
    public int value__;
    public static AllowedAssemblies ContainingAssembly;
    public static AllowedAssemblies AnyAssembly;
    public static AllowedAssemblies AllAssemblies;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Mono.Linker.Steps.BaseStep : object {
    [NullableAttribute("2")]
private LinkContext _context;
    public LinkContext Context { get; }
    public AnnotationStore Annotations { get; }
    public Tracer Tracer { get; }
    public MarkingHelpers MarkingHelpers { get; }
    public LinkContext get_Context();
    public AnnotationStore get_Annotations();
    public Tracer get_Tracer();
    public MarkingHelpers get_MarkingHelpers();
    public sealed virtual void Process(LinkContext context);
    protected virtual bool ConditionToProcess();
    protected virtual void Process();
    protected virtual void EndProcess();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Mono.Linker.Steps.BaseSubStep : object {
    [NullableAttribute("2")]
[CompilerGeneratedAttribute]
private LinkContext <_context>k__BackingField;
    protected AnnotationStore Annotations { get; }
    [NullableAttribute("2")]
private LinkContext _context { get; private set; }
    protected LinkContext Context { get; }
    public SubStepTargets Targets { get; }
    protected AnnotationStore get_Annotations();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private LinkContext get__context();
    [NullableContextAttribute("2")]
[CompilerGeneratedAttribute]
private void set__context(LinkContext value);
    protected LinkContext get_Context();
    public abstract virtual SubStepTargets get_Targets();
    public virtual void Initialize(LinkContext context);
    public virtual bool IsActiveFor(AssemblyDefinition assembly);
    public virtual void ProcessAssembly(AssemblyDefinition assembly);
    public virtual void ProcessType(TypeDefinition type);
    public virtual void ProcessField(FieldDefinition field);
    public virtual void ProcessMethod(MethodDefinition method);
    public virtual void ProcessProperty(PropertyDefinition property);
    public virtual void ProcessEvent(EventDefinition event);
}
public class Mono.Linker.Steps.BodySubstituterStep : ProcessLinkerXmlStepBase {
    [NullableContextAttribute("1")]
public BodySubstituterStep(Stream documentStream, string xmlDocumentLocation);
    protected virtual void Process();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.BodySubstitutionParser : ProcessLinkerXmlBase {
    [NullableAttribute("2")]
private SubstitutionInfo _substitutionInfo;
    public BodySubstitutionParser(LinkContext context, Stream documentStream, string xmlDocumentLocation);
    public BodySubstitutionParser(LinkContext context, Stream documentStream, EmbeddedResource resource, AssemblyDefinition resourceAssembly, string xmlDocumentLocation);
    public void Parse(SubstitutionInfo xmlInfo);
    protected virtual void ProcessAssembly(AssemblyDefinition assembly, XPathNavigator nav, bool warnOnUnresolvedTypes);
    protected virtual TypeDefinition ProcessExportedType(ExportedType exported, AssemblyDefinition assembly, XPathNavigator nav);
    protected virtual bool ProcessTypePattern(string fullname, AssemblyDefinition assembly, XPathNavigator nav);
    protected virtual void ProcessType(TypeDefinition type, XPathNavigator nav);
    protected virtual void ProcessMethod(TypeDefinition type, XPathNavigator methodNav, object _customData);
    protected virtual void ProcessField(TypeDefinition type, XPathNavigator fieldNav);
    private void ProcessResources(AssemblyDefinition assembly, XPathNavigator nav);
    private static MethodDefinition FindMethod(TypeDefinition type, string signature);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.Steps.CategorizedSubSteps : ValueType {
    public List`1<ISubStep> on_assemblies;
    public List`1<ISubStep> on_types;
    public List`1<ISubStep> on_fields;
    public List`1<ISubStep> on_methods;
    public List`1<ISubStep> on_properties;
    public List`1<ISubStep> on_events;
}
public class Mono.Linker.Steps.CheckSuppressionsDispatcher : SubStepsDispatcher {
    [NullableContextAttribute("1")]
public virtual void Process(LinkContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.CheckSuppressionsStep : BaseSubStep {
    public SubStepTargets Targets { get; }
    public virtual SubStepTargets get_Targets();
    public virtual bool IsActiveFor(AssemblyDefinition assembly);
    public virtual void ProcessType(TypeDefinition type);
    public virtual void ProcessField(FieldDefinition field);
    public virtual void ProcessMethod(MethodDefinition method);
    public virtual void ProcessProperty(PropertyDefinition property);
    public virtual void ProcessEvent(EventDefinition event);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.CleanStep : BaseStep {
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private static void CleanAssembly(AssemblyDefinition asm);
    private static void CleanType(TypeDefinition type);
    private static MethodDefinition CheckMethod(TypeDefinition type, MethodDefinition method);
    private static void CleanEvents(TypeDefinition type);
    private static bool IsEventUsed(EventDefinition evt);
    private static void CleanProperties(TypeDefinition type);
    private static bool IsPropertyUsed(PropertyDefinition prop);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.CodeRewriterStep : BaseStep {
    [NullableAttribute("2")]
private AssemblyDefinition assembly;
    private AssemblyDefinition Assembly { get; }
    private AssemblyDefinition get_Assembly();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private void ProcessType(TypeDefinition type);
    private void AddFieldsInitializations(TypeDefinition type);
    private void ProcessMethod(MethodDefinition method);
    protected virtual void RewriteBodyToLinkedAway(MethodDefinition method);
    protected virtual void RewriteBodyToStub(MethodDefinition method);
    private MethodBody CreateThrowLinkedAwayBody(MethodDefinition method);
    private MethodBody CreateStubBody(MethodDefinition method);
    private static void StubComplexBody(MethodDefinition method, MethodBody body, LinkerILProcessor il);
    public static Instruction CreateConstantResultInstruction(LinkContext context, MethodDefinition method);
    public static Instruction CreateConstantResultInstruction(LinkContext context, TypeReference inputRtype, object value);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.DescriptorMarker : ProcessLinkerXmlBase {
    private static string NamespaceElementName;
    private static string _required;
    private static string _preserve;
    private static string _accessors;
    private static String[] _accessorsAll;
    private static Char[] _accessorsSep;
    protected AllowedAssemblies AllowedAssemblySelector { get; }
    public DescriptorMarker(LinkContext context, Stream documentStream, string xmlDocumentLocation);
    public DescriptorMarker(LinkContext context, Stream documentStream, EmbeddedResource resource, AssemblyDefinition resourceAssembly, string xmlDocumentLocation);
    private static DescriptorMarker();
    public void Mark();
    protected virtual AllowedAssemblies get_AllowedAssemblySelector();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly, XPathNavigator nav, bool warnOnUnresolvedTypes);
    private void ProcessNamespaces(AssemblyDefinition assembly, XPathNavigator nav);
    private void MarkAndPreserveAll(TypeDefinition type, XPathNavigator nav);
    protected virtual TypeDefinition ProcessExportedType(ExportedType exported, AssemblyDefinition assembly, XPathNavigator nav);
    protected virtual void ProcessType(TypeDefinition type, XPathNavigator nav);
    protected static TypePreserve GetTypePreserve(XPathNavigator nav);
    protected virtual void ProcessField(TypeDefinition type, FieldDefinition field, XPathNavigator nav);
    protected virtual void ProcessMethod(TypeDefinition type, MethodDefinition method, XPathNavigator nav, object customData);
    private void ProcessMethodIfNotNull(TypeDefinition type, MethodDefinition method, XPathNavigator nav, object customData);
    protected virtual MethodDefinition GetMethod(TypeDefinition type, string signature);
    public static string GetMethodSignature(MethodDefinition meth, bool includeGenericParameters);
    protected virtual void ProcessEvent(TypeDefinition type, EventDefinition event, XPathNavigator nav, object customData);
    protected virtual void ProcessProperty(TypeDefinition type, PropertyDefinition property, XPathNavigator nav, object customData, bool fromSignature);
    private static bool IsRequired(XPathNavigator nav);
    protected static String[] GetAccessors(XPathNavigator nav);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.DiscoverOperatorsHandler : object {
    [NullableAttribute("2")]
private LinkContext _context;
    private bool _seenLinqExpressions;
    private HashSet`1<TypeDefinition> _trackedTypesWithOperators;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<TypeDefinition, List`1<MethodDefinition>> _pendingOperatorsForType;
    [NullableAttribute("2")]
private TypeDefinition _nullableOfT;
    private LinkContext Context { get; }
    private Dictionary`2<TypeDefinition, List`1<MethodDefinition>> PendingOperatorsForType { get; }
    [NullableAttribute("2")]
private TypeDefinition NullableOfT { get; }
    private LinkContext get_Context();
    private Dictionary`2<TypeDefinition, List`1<MethodDefinition>> get_PendingOperatorsForType();
    public sealed virtual void Initialize(LinkContext context, MarkContext markContext);
    private void ProcessType(TypeDefinition type);
    private void CheckForLinqExpressions(TypeDefinition type);
    private void MarkOperator(MethodDefinition method);
    private bool ProcessCustomOperators(TypeDefinition type, bool mark);
    [NullableContextAttribute("2")]
private TypeDefinition get_NullableOfT();
    private TypeDefinition NonNullableType(TypeReference type);
    private bool IsOperator(MethodDefinition method, TypeDefinition& otherType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.DiscoverSerializationHandler : object {
    [NullableAttribute("2")]
private LinkContext _context;
    private LinkContext Context { get; }
    private LinkContext get_Context();
    public sealed virtual void Initialize(LinkContext context, MarkContext markContext);
    private void CheckForSerializerActivation(MethodDefinition method);
    private void ProcessType(TypeDefinition type);
    private void ProcessAttributeProvider(ICustomAttributeProvider provider);
    private static bool IsPreservedSerializationAttribute(ICustomAttributeProvider provider, CustomAttribute attribute, SerializerKind& serializerKind);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.Steps.IMarkHandler {
    public abstract virtual void Initialize(LinkContext context, MarkContext markContext);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.Steps.IStep {
    public abstract virtual void Process(LinkContext context);
}
[NullableContextAttribute("1")]
public interface Mono.Linker.Steps.ISubStep {
    public SubStepTargets Targets { get; }
    public abstract virtual SubStepTargets get_Targets();
    public abstract virtual void Initialize(LinkContext context);
    public abstract virtual bool IsActiveFor(AssemblyDefinition assembly);
    public abstract virtual void ProcessAssembly(AssemblyDefinition assembly);
    public abstract virtual void ProcessType(TypeDefinition type);
    public abstract virtual void ProcessField(FieldDefinition field);
    public abstract virtual void ProcessMethod(MethodDefinition method);
    public abstract virtual void ProcessProperty(PropertyDefinition property);
    public abstract virtual void ProcessEvent(EventDefinition event);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.LinkAttributesParser : ProcessLinkerXmlBase {
    [NullableAttribute("2")]
private AttributeInfo _attributeInfo;
    protected AllowedAssemblies AllowedAssemblySelector { get; }
    public LinkAttributesParser(LinkContext context, Stream documentStream, string xmlDocumentLocation);
    public LinkAttributesParser(LinkContext context, Stream documentStream, EmbeddedResource resource, AssemblyDefinition resourceAssembly, string xmlDocumentLocation);
    public void Parse(AttributeInfo xmlInfo);
    private static bool IsRemoveAttributeInstances(string attributeName);
    private ValueTuple`2<CustomAttribute[], MessageOrigin[]> ProcessAttributes(XPathNavigator nav, ICustomAttributeProvider provider);
    [NullableContextAttribute("2")]
private TypeDefinition GenerateRemoveAttributeInstancesAttribute();
    private CustomAttribute CreateCustomAttribute(XPathNavigator nav, TypeDefinition attributeType);
    private MethodDefinition FindBestMatchingConstructor(TypeDefinition attributeType, CustomAttributeArgument[] args);
    private void ReadCustomAttributeProperties(XPathNavigator nav, TypeDefinition attributeType, CustomAttribute customAttribute);
    private CustomAttributeArgument[] ReadCustomAttributeArguments(XPathNavigator nav, TypeDefinition attributeType);
    private Nullable`1<CustomAttributeArgument> ReadCustomAttributeArgument(XPathNavigator nav, IMemberDefinition memberWithAttribute);
    private object ConvertStringValue(object value, TypeReference targetType);
    private bool GetAttributeType(XPathNavigator nav, string attributeFullName, TypeDefinition& attributeType);
    protected virtual AllowedAssemblies get_AllowedAssemblySelector();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly, XPathNavigator nav, bool warnOnUnresolvedTypes);
    protected virtual void ProcessType(TypeDefinition type, XPathNavigator nav);
    protected virtual void ProcessField(TypeDefinition type, FieldDefinition field, XPathNavigator nav);
    protected virtual void ProcessMethod(TypeDefinition type, MethodDefinition method, XPathNavigator nav, object customData);
    private void ProcessParameters(MethodDefinition method, XPathNavigator nav);
    private void ProcessReturnParameters(MethodDefinition method, XPathNavigator nav);
    protected virtual MethodDefinition GetMethod(TypeDefinition type, string signature);
    private static string GetMethodSignature(MethodDefinition method, bool includeReturnType);
    protected virtual void ProcessProperty(TypeDefinition type, PropertyDefinition property, XPathNavigator nav, object customData, bool fromSignature);
    protected virtual void ProcessEvent(TypeDefinition type, EventDefinition event, XPathNavigator nav, object customData);
    private void PopulateAttributeInfo(ICustomAttributeProvider provider, XPathNavigator nav);
    [CompilerGeneratedAttribute]
internal static string <ProcessAttributes>g__FormatCustomAttribute|5_0(CustomAttribute ca);
}
public class Mono.Linker.Steps.LinkAttributesStep : ProcessLinkerXmlStepBase {
    [NullableContextAttribute("1")]
public LinkAttributesStep(Stream documentStream, string xmlDocumentLocation);
    protected virtual void Process();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Mono.Linker.Steps.MarkContext : object {
    public abstract virtual void RegisterMarkAssemblyAction(Action`1<AssemblyDefinition> action);
    public abstract virtual void RegisterMarkTypeAction(Action`1<TypeDefinition> action);
    public abstract virtual void RegisterMarkMethodAction(Action`1<MethodDefinition> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.Steps.MarkExportedTypesTarget : object {
    public static void ProcessAssembly(AssemblyDefinition assembly, LinkContext context);
    private static void InitializeExportedType(ExportedType exportedType, LinkContext context, AssemblyDefinition assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.MarkScopeStack : object {
    private Stack`1<Scope> _scopeStack;
    public Scope CurrentScope { get; }
    public IDisposable PushScope(MessageOrigin& origin);
    public IDisposable PushScope(Scope& scope);
    public IDisposable PopToParent();
    public Scope get_CurrentScope();
    public void UpdateCurrentScopeInstructionOffset(int offset);
    private void Push(Scope& scope);
    private Scope Pop();
    [ConditionalAttribute("DEBUG")]
public void AssertIsEmpty();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.MarkStep : object {
    [NullableAttribute("2")]
private LinkContext _context;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Queue`1<ValueTuple`3<MethodDefinition, DependencyInfo, MessageOrigin>> _methods;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected HashSet`1<ValueTuple`2<MethodDefinition, Scope>> _virtual_methods;
    protected Queue`1<AttributeProviderPair> _assemblyLevelAttributes;
    private List`1<AttributeProviderPair> _ivt_attributes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Queue`1<ValueTuple`3<AttributeProviderPair, DependencyInfo, Scope>> _lateMarkedAttributes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected List`1<ValueTuple`2<TypeDefinition, Scope>> _typesWithInterfaces;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected HashSet`1<ValueTuple`2<OverrideInformation, Scope>> _interfaceOverrides;
    protected HashSet`1<AssemblyDefinition> _dynamicInterfaceCastableImplementationTypesDiscovered;
    protected List`1<TypeDefinition> _dynamicInterfaceCastableImplementationTypes;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected List`1<ValueTuple`2<MethodBody, Scope>> _unreachableBodies;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<ValueTuple`3<TypeDefinition, MethodBody, Instruction>> _pending_isinst_instr;
    private Dictionary`2<MethodBody, bool> _compilerGeneratedMethodRequiresScanner;
    [NullableAttribute("2")]
private MarkStepContext _markContext;
    private HashSet`1<TypeDefinition> _entireTypesMarked;
    [NullableAttribute("2")]
private DynamicallyAccessedMembersTypeHierarchy _dynamicallyAccessedMembersTypeHierarchy;
    [NullableAttribute("2")]
private MarkScopeStack _scopeStack;
    private static Regex DebuggerDisplayAttributeValueRegex;
    protected LinkContext Context { get; }
    private MarkStepContext MarkContext { get; }
    private MarkScopeStack ScopeStack { get; }
    internal DynamicallyAccessedMembersTypeHierarchy DynamicallyAccessedMembersTypeHierarchy { get; }
    public AnnotationStore Annotations { get; }
    public MarkingHelpers MarkingHelpers { get; }
    public Tracer Tracer { get; }
    protected bool ShouldMarkSystemObjectFinalize { get; }
    private static MarkStep();
    protected LinkContext get_Context();
    private MarkStepContext get_MarkContext();
    private MarkScopeStack get_ScopeStack();
    internal DynamicallyAccessedMembersTypeHierarchy get_DynamicallyAccessedMembersTypeHierarchy();
    public AnnotationStore get_Annotations();
    public MarkingHelpers get_MarkingHelpers();
    public Tracer get_Tracer();
    public virtual void Process(LinkContext context);
    private void Initialize();
    private void InitializeCorelibAttributeXml();
    private void Complete();
    private bool ProcessInternalsVisibleAttributes();
    private static bool TypeIsDynamicInterfaceCastableImplementation(TypeDefinition type);
    protected bool IsFullyPreserved(TypeDefinition type);
    internal void MarkEntireType(TypeDefinition type, DependencyInfo& reason);
    private void Process();
    private static bool IsFullyPreservedAction(AssemblyAction action);
    private bool MarkFullyPreservedAssemblies();
    private bool ProcessPrimaryQueue();
    private bool ProcessMarkedPending();
    private void ProcessPendingTypeChecks();
    private void ProcessQueue();
    private bool QueueIsEmpty();
    protected virtual void EnqueueMethod(MethodDefinition method, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, MessageOrigin& modreq(System.Runtime.InteropServices.InAttribute) origin);
    private void ProcessVirtualMethods();
    private void ProcessMarkedTypesWithInterfaces();
    private void DiscoverDynamicCastableImplementationInterfaces();
    private void ProcessDynamicCastableImplementationInterfaces();
    private void ProcessPendingBodies();
    private void ProcessVirtualMethod(MethodDefinition method);
    private bool ShouldMarkOverrideForBase(OverrideInformation overrideInformation);
    private void MarkOverrideForBaseMethod(OverrideInformation overrideInformation);
    private void MarkMethodIfNeededByBaseMethod(MethodDefinition method);
    private bool IsInterfaceImplementationMarkedRecursively(TypeDefinition type, TypeDefinition interfaceType);
    private bool RequiresInterfaceRecursively(TypeDefinition typeToExamine, TypeDefinition interfaceType);
    private void ProcessDefaultImplementation(TypeDefinition typeWithDefaultImplementedInterfaceMethod, InterfaceImplementation implementation);
    private void MarkMarshalSpec(IMarshalInfoProvider spec, DependencyInfo& reason);
    private void MarkCustomAttributes(ICustomAttributeProvider provider, DependencyInfo& reason);
    private bool IsAttributeRemoved(CustomAttribute ca, TypeDefinition attributeType);
    protected virtual bool ProcessLinkerSpecialAttribute(CustomAttribute ca, ICustomAttributeProvider provider, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    private void MarkDynamicDependency(DynamicDependency dynamicDependency, IMemberDefinition context);
    private void MarkMembersVisibleToReflection(IEnumerable`1<IMetadataTokenProvider> members, DependencyInfo& reason);
    protected virtual bool IsUserDependencyMarker(TypeReference type);
    protected virtual void MarkUserDependency(IMemberDefinition context, CustomAttribute ca);
    private bool MarkDependencyMethod(TypeDefinition type, string name, String[] signature, DependencyInfo& reason);
    private void LazyMarkCustomAttributes(ICustomAttributeProvider provider);
    protected virtual void MarkCustomAttribute(CustomAttribute ca, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    protected virtual bool ShouldMarkCustomAttribute(CustomAttribute ca, ICustomAttributeProvider provider);
    protected virtual bool ShouldMarkTypeStaticConstructor(TypeDefinition type);
    protected internal void MarkStaticConstructor(TypeDefinition type, DependencyInfo& reason, MessageOrigin& origin);
    protected virtual bool ShouldMarkTopLevelCustomAttribute(AttributeProviderPair app, MethodDefinition resolvedConstructor);
    protected void MarkSecurityDeclarations(ISecurityDeclarationProvider provider, DependencyInfo& reason);
    protected virtual void MarkSecurityDeclaration(SecurityDeclaration sd, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    protected virtual void MarkSecurityAttribute(SecurityAttribute sa, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    protected void MarkCustomAttributeProperties(ICustomAttribute ca, TypeDefinition attribute);
    protected void MarkCustomAttributeProperty(CustomAttributeNamedArgument namedArgument, TypeDefinition attribute, ICustomAttribute ca, DependencyInfo& reason);
    private PropertyDefinition GetProperty(TypeDefinition inputType, string propertyname);
    protected void MarkCustomAttributeFields(ICustomAttribute ca, TypeDefinition attribute);
    protected void MarkCustomAttributeField(CustomAttributeNamedArgument namedArgument, TypeDefinition attribute, ICustomAttribute ca);
    private FieldDefinition GetField(TypeDefinition inputType, string fieldname);
    private MethodDefinition GetMethodWithNoParameters(TypeDefinition inputType, string methodname);
    private void MarkCustomAttributeArguments(CustomAttribute ca);
    private void MarkCustomAttributeArgument(CustomAttributeArgument argument, ICustomAttribute ca);
    protected bool CheckProcessed(IMetadataTokenProvider provider);
    protected void MarkAssembly(AssemblyDefinition assembly, DependencyInfo reason);
    private void MarkEntireAssembly(AssemblyDefinition assembly);
    private void ProcessModuleType(AssemblyDefinition assembly);
    private bool ProcessLazyAttributes();
    private bool ProcessLateMarkedAttributes();
    protected void MarkField(FieldReference reference, DependencyInfo reason, MessageOrigin& origin);
    private void ReportWarningsForTypeHierarchyReflectionAccess(IMemberDefinition member, MessageOrigin origin);
    private void MarkField(FieldDefinition field, DependencyInfo& reason, MessageOrigin& origin);
    private bool ShouldWarnForReflectionAccessToCompilerGeneratedCode(FieldDefinition field, bool isCoveredByAnnotations);
    private void ProcessAnalysisAnnotationsForField(FieldDefinition field, DependencyKind dependencyKind, MessageOrigin& origin);
    protected virtual bool IgnoreScope(IMetadataScope scope);
    private void MarkModule(ModuleDefinition module, DependencyInfo reason);
    protected virtual void MarkSerializable(TypeDefinition type);
    protected internal virtual TypeDefinition MarkTypeVisibleToReflection(TypeReference type, TypeDefinition definition, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, MessageOrigin& modreq(System.Runtime.InteropServices.InAttribute) origin);
    internal void MarkMethodVisibleToReflection(MethodDefinition method, DependencyInfo& reason, MessageOrigin& origin);
    internal void MarkFieldVisibleToReflection(FieldDefinition field, DependencyInfo& reason, MessageOrigin& origin);
    internal void MarkPropertyVisibleToReflection(PropertyDefinition property, DependencyInfo& reason, MessageOrigin& origin);
    internal void MarkEventVisibleToReflection(EventDefinition event, DependencyInfo& reason, MessageOrigin& origin);
    internal void MarkStaticConstructorVisibleToReflection(TypeDefinition type, DependencyInfo& reason, MessageOrigin& origin);
    protected internal virtual TypeDefinition MarkType(TypeReference reference, DependencyInfo reason, Nullable`1<MessageOrigin> origin);
    protected virtual bool get_ShouldMarkSystemObjectFinalize();
    protected virtual void DoAdditionalProcessing();
    protected virtual void DoAdditionalTypeProcessing(TypeDefinition type);
    protected virtual void DoAdditionalFieldProcessing(FieldDefinition field);
    protected virtual void DoAdditionalPropertyProcessing(PropertyDefinition property);
    protected virtual void DoAdditionalEventProcessing(EventDefinition evt);
    protected virtual void DoAdditionalInstantiatedTypeProcessing(TypeDefinition type);
    private TypeDefinition GetDebuggerAttributeTargetType(CustomAttribute ca, AssemblyDefinition asm);
    private void MarkTypeSpecialCustomAttributes(TypeDefinition type);
    private void MarkMethodSpecialCustomAttributes(MethodDefinition method);
    private void MarkXmlSchemaProvider(TypeDefinition type, CustomAttribute attribute);
    private void MarkTypeWithDebuggerDisplayAttribute(TypeDefinition type, CustomAttribute attribute);
    private void MarkTypeWithDebuggerTypeProxyAttribute(TypeDefinition type, CustomAttribute attribute);
    private static bool TryGetStringArgument(CustomAttribute attribute, String& argument);
    protected int MarkNamedMethod(TypeDefinition type, string method_name, DependencyInfo& reason);
    private void MarkSoapHeader(MethodDefinition method, CustomAttribute attribute);
    private bool MarkNamedField(TypeDefinition type, string field_name, DependencyInfo& reason);
    private void MarkNamedProperty(TypeDefinition type, string property_name, DependencyInfo& reason);
    private void MarkInterfaceImplementations(TypeDefinition type);
    private void MarkGenericParameterProvider(IGenericParameterProvider provider);
    private void MarkGenericParameter(GenericParameter parameter);
    private bool IsMethodNeededByTypeDueToPreservedScope(MethodDefinition method);
    private bool IsInterfaceImplementationMethodNeededByTypeDueToInterface(OverrideInformation overrideInformation);
    private static bool IsSpecialSerializationConstructor(MethodDefinition method);
    protected internal bool MarkMethodsIf(Collection`1<MethodDefinition> methods, Func`2<MethodDefinition, bool> predicate, DependencyInfo& reason, MessageOrigin& origin);
    protected MethodDefinition MarkMethodIf(Collection`1<MethodDefinition> methods, Func`2<MethodDefinition, bool> predicate, DependencyInfo& reason, MessageOrigin& origin);
    protected bool MarkDefaultConstructor(TypeDefinition type, DependencyInfo& reason);
    private void MarkCustomMarshalerGetInstance(TypeDefinition type, DependencyInfo& reason);
    private void MarkICustomMarshalerMethods(TypeDefinition inputType, DependencyInfo& reason);
    private bool IsNonEmptyStaticConstructor(MethodDefinition method);
    private static bool HasOnSerializeOrDeserializeAttribute(MethodDefinition method);
    protected virtual bool AlwaysMarkTypeAsInstantiated(TypeDefinition td);
    private void MarkEventSourceProviders(TypeDefinition td);
    protected virtual void MarkMulticastDelegate(TypeDefinition type);
    protected ValueTuple`2<TypeReference, DependencyInfo> GetOriginalType(TypeReference type, DependencyInfo reason);
    private void MarkParameters(FunctionPointerType fnptr);
    private void MarkModifierType(IModifierType mod);
    private void MarkGenericArguments(IGenericInstance instance);
    private IGenericParameterProvider GetGenericProviderFromInstance(IGenericInstance instance);
    private void ApplyPreserveInfo(TypeDefinition type);
    private static bool IsMethodVisible(MethodDefinition method);
    private static bool IsMethodInternal(MethodDefinition method);
    private static bool IsFieldVisible(FieldDefinition field);
    private static bool IsFieldInternal(FieldDefinition field);
    private void ApplyPreserveMethods(TypeDefinition type);
    private void ApplyPreserveMethods(MethodDefinition method);
    protected bool MarkFields(TypeDefinition type, bool includeStatic, DependencyInfo& reason, bool markBackingFieldsOnlyIfPropertyMarked);
    private PropertyDefinition SearchPropertiesForMatchingFieldDefinition(FieldDefinition field);
    protected void MarkStaticFields(TypeDefinition type, DependencyInfo& reason);
    protected virtual bool MarkMethods(TypeDefinition type, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    private void MarkMethodCollection(IList`1<MethodDefinition> methods, DependencyInfo& reason);
    protected internal void MarkIndirectlyCalledMethod(MethodDefinition method, DependencyInfo& reason, MessageOrigin& origin);
    protected virtual MethodDefinition MarkMethod(MethodReference reference, DependencyInfo reason, MessageOrigin& modreq(System.Runtime.InteropServices.InAttribute) origin);
    private bool ShouldWarnForReflectionAccessToCompilerGeneratedCode(MethodDefinition method, bool isCoveredByAnnotations);
    private void ProcessAnalysisAnnotationsForMethod(MethodDefinition method, DependencyKind dependencyKind, MessageOrigin& origin);
    internal static void ReportRequiresUnreferencedCode(string displayName, RequiresUnreferencedCodeAttribute requiresUnreferencedCode, DiagnosticContext& diagnosticContext);
    protected ValueTuple`2<MethodReference, DependencyInfo> GetOriginalMethod(MethodReference method, DependencyInfo reason);
    protected virtual void ProcessMethod(MethodDefinition method, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, MessageOrigin& modreq(System.Runtime.InteropServices.InAttribute) origin);
    protected virtual void DoAdditionalMethodProcessing(MethodDefinition method);
    private void MarkImplicitlyUsedFields(TypeDefinition type);
    protected virtual void MarkRequirementsForInstantiatedTypes(TypeDefinition type);
    private void MarkExplicitInterfaceImplementation(MethodDefinition method, MethodReference ov);
    private void MarkNewCodeDependencies(MethodDefinition method);
    protected virtual void MarkAndCacheConvertToThrowExceptionCtor(DependencyInfo reason);
    private bool MarkDisablePrivateReflectionAttribute();
    private void MarkBaseMethods(MethodDefinition method);
    private void ProcessInteropMethod(MethodDefinition method);
    protected virtual bool ShouldParseMethodBody(MethodDefinition method);
    protected internal void MarkProperty(PropertyDefinition prop, DependencyInfo& reason);
    protected internal virtual void MarkEvent(EventDefinition evt, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason);
    internal void MarkMethodIfNotNull(MethodReference method, DependencyInfo& reason, MessageOrigin& origin);
    protected virtual void MarkMethodBody(MethodBody body);
    private bool CheckRequiresReflectionMethodBodyScanner(MethodIL methodIL);
    private bool MarkAndCheckRequiresReflectionMethodBodyScanner(MethodIL methodIL);
    private bool IsUnreachableBody(MethodIL methodIL);
    private void MarkInterfacesNeededByBodyStack(MethodIL methodIL);
    private bool InstructionRequiresReflectionMethodBodyScannerForFieldAccess(Instruction instruction);
    protected virtual void MarkInstruction(Instruction instruction, MethodDefinition method, Boolean& requiresReflectionMethodBodyScanner);
    protected internal virtual void MarkInterfaceImplementation(InterfaceImplementation iface, Nullable`1<MessageOrigin> origin, Nullable`1<DependencyInfo> reason);
    protected internal virtual bool ProcessReflectionDependency(MethodBody body, Instruction instruction);
    protected virtual void MarkReflectionLikeDependencies(MethodIL methodIL, bool requiresReflectionMethodBodyScanner);
    [CompilerGeneratedAttribute]
private bool <ProcessInternalsVisibleAttributes>g__IsInternalsVisibleAttributeAssemblyMarked|36_0(CustomAttribute ca);
    [CompilerGeneratedAttribute]
private void <DiscoverDynamicCastableImplementationInterfaces>g__CheckIfTypeOrNestedTypesIsDynamicCastableImplementation|51_0(TypeDefinition type);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <MarkMethodIfNeededByBaseMethod>b__57_0(OverrideInformation ov);
    [CompilerGeneratedAttribute]
internal static bool <IsAttributeRemoved>g__HasMatchingArguments|63_0(CustomAttributeArgument[] removeAttrInstancesArgs, Collection`1<CustomAttributeArgument> attributeInstanceArgs);
    [CompilerGeneratedAttribute]
internal static bool <ReportWarningsForTypeHierarchyReflectionAccess>g__IsDeclaredWithinType|96_0(IMemberDefinition member, TypeDefinition type);
    [CompilerGeneratedAttribute]
private bool <MarkInterfaceImplementations>g__ShouldMarkInterfaceImplementation|130_0(TypeDefinition type, InterfaceImplementation iface);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.MarkStepContext : MarkContext {
    [CompilerGeneratedAttribute]
private List`1<Action`1<AssemblyDefinition>> <MarkAssemblyActions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<TypeDefinition>> <MarkTypeActions>k__BackingField;
    [CompilerGeneratedAttribute]
private List`1<Action`1<MethodDefinition>> <MarkMethodActions>k__BackingField;
    public List`1<Action`1<AssemblyDefinition>> MarkAssemblyActions { get; }
    public List`1<Action`1<TypeDefinition>> MarkTypeActions { get; }
    public List`1<Action`1<MethodDefinition>> MarkMethodActions { get; }
    [CompilerGeneratedAttribute]
public List`1<Action`1<AssemblyDefinition>> get_MarkAssemblyActions();
    [CompilerGeneratedAttribute]
public List`1<Action`1<TypeDefinition>> get_MarkTypeActions();
    [CompilerGeneratedAttribute]
public List`1<Action`1<MethodDefinition>> get_MarkMethodActions();
    public virtual void RegisterMarkAssemblyAction(Action`1<AssemblyDefinition> action);
    public virtual void RegisterMarkTypeAction(Action`1<TypeDefinition> action);
    public virtual void RegisterMarkMethodAction(Action`1<MethodDefinition> action);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.MarkSubStepsDispatcher : object {
    private List`1<ISubStep> substeps;
    private Nullable`1<CategorizedSubSteps> categorized;
    private CategorizedSubSteps Categorized { get; }
    public MarkSubStepsDispatcher(IEnumerable`1<ISubStep> subSteps);
    private CategorizedSubSteps get_Categorized();
    public virtual void Initialize(LinkContext context, MarkContext markContext);
    private static bool HasSubSteps(List`1<ISubStep> substeps);
    private void BrowseAssembly(AssemblyDefinition assembly);
    private bool ShouldDispatchTypes();
    private void BrowseTypes(Collection`1<TypeDefinition> types);
    private void DispatchAssembly(AssemblyDefinition assembly);
    private void DispatchType(TypeDefinition type);
    private void DispatchField(FieldDefinition field);
    private void DispatchMethod(MethodDefinition method);
    private void DispatchProperty(PropertyDefinition property);
    private void DispatchEvent(EventDefinition event);
    private void InitializeSubSteps(LinkContext context);
    private void CategorizeSubSteps(AssemblyDefinition assembly);
    private void CategorizeSubStep(ISubStep substep, AssemblyDefinition assembly);
    private static void CategorizeTarget(ISubStep substep, SubStepTargets target, List`1<ISubStep> list);
    private static bool Targets(ISubStep substep, SubStepTargets target);
    [CompilerGeneratedAttribute]
private void <Initialize>b__5_0(AssemblyDefinition assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.OutputStep : BaseStep {
    [NullableAttribute("2")]
private Dictionary`2<ushort, TargetArchitecture> architectureMap;
    private List`1<string> assembliesWritten;
    private TargetArchitecture CalculateArchitecture(TargetArchitecture readyToRunArch);
    protected virtual bool ConditionToProcess();
    protected virtual void Process();
    protected virtual void EndProcess();
    private void CheckOutputDirectory();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    protected void WriteAssembly(AssemblyDefinition assembly, string directory);
    protected virtual void WriteAssembly(AssemblyDefinition assembly, string directory, WriterParameters writerParameters);
    private void OutputAssembly(AssemblyDefinition assembly);
    private void OutputPInvokes();
    protected virtual void DeleteAssembly(AssemblyDefinition assembly, string directory);
    private void CloseSymbols(AssemblyDefinition assembly);
    private WriterParameters SaveSymbols(AssemblyDefinition assembly);
    private void CopySatelliteAssembliesIfNeeded(AssemblyDefinition assembly, string directory);
    private void CopyConfigFileIfNeeded(AssemblyDefinition assembly, string directory);
    private static string GetAssemblyResourceFileName(string assembly);
    private static string GetConfigFile(string assembly);
    private FileInfo GetOriginalAssemblyFileInfo(AssemblyDefinition assembly);
    protected virtual void CopyAssembly(AssemblyDefinition assembly, string directory);
    protected virtual string GetAssemblyFileName(AssemblyDefinition assembly, string directory);
}
public class Mono.Linker.Steps.OutputWarningSuppressions : BaseStep {
    protected virtual bool ConditionToProcess();
    protected virtual void Process();
    private void CheckOutputDirectory();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Mono.Linker.Steps.ProcessLinkerXmlBase : object {
    private static string FullNameAttributeName;
    private static string LinkerElementName;
    private static string TypeElementName;
    private static string SignatureAttributeName;
    private static string NameAttributeName;
    private static string FieldElementName;
    private static string MethodElementName;
    private static string EventElementName;
    private static string PropertyElementName;
    private static string AllAssembliesFullName;
    protected static string XmlNamespace;
    protected string _xmlDocumentLocation;
    private XPathNavigator _document;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Nullable`1<ValueTuple`2<EmbeddedResource, AssemblyDefinition>> _resource;
    protected LinkContext _context;
    protected AllowedAssemblies AllowedAssemblySelector { get; }
    protected ProcessLinkerXmlBase(LinkContext context, Stream documentStream, string xmlDocumentLocation);
    protected ProcessLinkerXmlBase(LinkContext context, Stream documentStream, EmbeddedResource resource, AssemblyDefinition resourceAssembly, string xmlDocumentLocation);
    protected virtual bool ShouldProcessElement(XPathNavigator nav);
    protected virtual void ProcessXml(bool stripResource, bool ignoreResource);
    protected virtual AllowedAssemblies get_AllowedAssemblySelector();
    private bool ShouldProcessAllAssemblies(XPathNavigator nav, AssemblyNameReference& assemblyName);
    protected virtual void ProcessAssemblies(XPathNavigator nav);
    protected abstract virtual void ProcessAssembly(AssemblyDefinition assembly, XPathNavigator nav, bool warnOnUnresolvedTypes);
    protected virtual void ProcessTypes(AssemblyDefinition assembly, XPathNavigator nav, bool warnOnUnresolvedTypes);
    protected virtual TypeDefinition ProcessExportedType(ExportedType exported, AssemblyDefinition assembly, XPathNavigator nav);
    private void MatchType(TypeDefinition type, Regex regex, XPathNavigator nav);
    protected virtual bool ProcessTypePattern(string fullname, AssemblyDefinition assembly, XPathNavigator nav);
    protected abstract virtual void ProcessType(TypeDefinition type, XPathNavigator nav);
    protected void ProcessTypeChildren(TypeDefinition type, XPathNavigator nav, object customData);
    private void ProcessSelectedFields(XPathNavigator nav, TypeDefinition type);
    protected virtual void ProcessField(TypeDefinition type, XPathNavigator nav);
    protected static FieldDefinition GetField(TypeDefinition type, string signature);
    protected virtual void ProcessField(TypeDefinition type, FieldDefinition field, XPathNavigator nav);
    private void ProcessSelectedMethods(XPathNavigator nav, TypeDefinition type, object customData);
    protected virtual void ProcessMethod(TypeDefinition type, XPathNavigator nav, object customData);
    protected virtual MethodDefinition GetMethod(TypeDefinition type, string signature);
    protected virtual void ProcessMethod(TypeDefinition type, MethodDefinition method, XPathNavigator nav, object customData);
    private void ProcessSelectedEvents(XPathNavigator nav, TypeDefinition type, object customData);
    protected virtual void ProcessEvent(TypeDefinition type, XPathNavigator nav, object customData);
    protected static EventDefinition GetEvent(TypeDefinition type, string signature);
    protected virtual void ProcessEvent(TypeDefinition type, EventDefinition event, XPathNavigator nav, object customData);
    private void ProcessSelectedProperties(XPathNavigator nav, TypeDefinition type, object customData);
    protected virtual void ProcessProperty(TypeDefinition type, XPathNavigator nav, object customData);
    protected static PropertyDefinition GetProperty(TypeDefinition type, string signature);
    protected virtual void ProcessProperty(TypeDefinition type, PropertyDefinition property, XPathNavigator nav, object customData, bool fromSignature);
    protected virtual AssemblyNameReference GetAssemblyName(XPathNavigator nav);
    protected static string GetFullName(XPathNavigator nav);
    protected static string GetName(XPathNavigator nav);
    protected static string GetSignature(XPathNavigator nav);
    protected static string GetAttribute(XPathNavigator nav, string attribute);
    protected MessageOrigin GetMessageOriginForPosition(XPathNavigator position);
    protected void LogWarning(string message, int warningCode, XPathNavigator position);
    protected void LogWarning(XPathNavigator position, DiagnosticId id, String[] args);
    public virtual string ToString();
    public bool TryConvertValue(string value, TypeReference target, Object& result);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.ProcessLinkerXmlStepBase : BaseStep {
    protected string _xmlDocumentLocation;
    protected Stream _documentStream;
    public ProcessLinkerXmlStepBase(Stream documentStream, string xmlDocumentLocation);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.ProcessReferencesStep : BaseStep {
    protected virtual void Process();
    [IteratorStateMachineAttribute("Mono.Linker.Steps.ProcessReferencesStep/<GetInputAssemblyPaths>d__1")]
private IEnumerable`1<string> GetInputAssemblyPaths();
    public static bool IsFullyPreservedAction(AssemblyAction action);
    private bool MaybeIsFullyPreservedAssembly(string assemblyName);
}
public class Mono.Linker.Steps.ProcessWarningsStep : BaseStep {
    protected virtual void Process();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.ReflectionBlockedStep : BaseStep {
    [NullableAttribute("2")]
private AssemblyDefinition assembly;
    private AssemblyDefinition Assembly { get; }
    private AssemblyDefinition get_Assembly();
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private void ProcessType(TypeDefinition type);
    private bool HasIndirectCallers(TypeDefinition type);
    private void AddCustomAttribute(ICustomAttributeProvider caProvider);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.RegenerateGuidStep : BaseStep {
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private static void RegenerateGuid(AssemblyDefinition asm);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.RemoveResourcesStep : BaseStep {
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    private bool ShouldProcess(AssemblyDefinition assembly);
    private void RemoveFSharpCompilationResources(AssemblyDefinition assembly);
    [CompilerGeneratedAttribute]
internal static bool <RemoveFSharpCompilationResources>g__IsFSharpCompilationResource|2_0(Resource resource);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public static class Mono.Linker.Steps.RemoveSecurity : object {
    public static void ProcessAssembly(AssemblyDefinition assembly, LinkContext context);
    private static void ProcessType(TypeDefinition type);
    private static void ClearSecurityDeclarations(ISecurityDeclarationProvider provider);
    private static void RemoveCustomAttributesThatAreForSecurity(ICustomAttributeProvider provider);
    private static bool IsCustomAttributeForSecurity(CustomAttribute attr);
}
public class Mono.Linker.Steps.ResolveFromXmlStep : ProcessLinkerXmlStepBase {
    [NullableContextAttribute("1")]
public ResolveFromXmlStep(Stream documentStream, string xmlDocumentLocation);
    protected virtual void Process();
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.RootAssemblyInput : BaseStep {
    private string fileName;
    private AssemblyRootMode rootMode;
    public RootAssemblyInput(string fileName, AssemblyRootMode rootMode);
    protected virtual void Process();
    [NullableContextAttribute("2")]
private AssemblyDefinition LoadAssemblyFile();
    private void MarkAndPreserve(AssemblyDefinition assembly, TypePreserveMembers preserve);
    private void MarkAndPreserve(TypeDefinition type, TypePreserveMembers preserve);
    private void MarkAndPreserve(AssemblyDefinition assembly, ExportedType type, TypePreserveMembers preserve);
    private static bool IsTypeVisible(TypeDefinition type);
    private static bool IsTypePrivate(TypeDefinition type);
    private bool MarkInternalsVisibleTo(AssemblyDefinition assembly);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.SealerStep : BaseStep {
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private HashSet`1<TypeDefinition> referencedBaseTypeCache;
    protected virtual void ProcessAssembly(AssemblyDefinition assembly);
    protected virtual void EndProcess();
    private bool IsSubclassed(TypeDefinition type);
    private void ProcessType(TypeDefinition type);
    protected virtual void SealType(TypeDefinition type);
    protected virtual void SealMethod(MethodDefinition method);
    private bool IsAnyOverrideMarked(IEnumerable`1<OverrideInformation> list);
    private bool IsAnyBaseMarked(IEnumerable`1<OverrideInformation> list);
    [CompilerGeneratedAttribute]
private void <IsSubclassed>g__PopulateCache|4_0(Collection`1<TypeDefinition> types);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public abstract class Mono.Linker.Steps.SubStepsDispatcher : object {
    private List`1<ISubStep> substeps;
    private Nullable`1<CategorizedSubSteps> categorized;
    private CategorizedSubSteps Categorized { get; }
    protected SubStepsDispatcher(IEnumerable`1<ISubStep> subSteps);
    private CategorizedSubSteps get_Categorized();
    public void Add(ISubStep substep);
    public virtual void Process(LinkContext context);
    private static bool HasSubSteps(List`1<ISubStep> substeps);
    private void BrowseAssemblies(IEnumerable`1<AssemblyDefinition> assemblies);
    private bool ShouldDispatchTypes();
    private void BrowseTypes(Collection`1<TypeDefinition> types);
    private void DispatchAssembly(AssemblyDefinition assembly);
    private void DispatchType(TypeDefinition type);
    private void DispatchField(FieldDefinition field);
    private void DispatchMethod(MethodDefinition method);
    private void DispatchProperty(PropertyDefinition property);
    private void DispatchEvent(EventDefinition event);
    private void InitializeSubSteps(LinkContext context);
    private void CategorizeSubSteps(AssemblyDefinition assembly);
    private void CategorizeSubStep(ISubStep substep, AssemblyDefinition assembly);
    private static void CategorizeTarget(ISubStep substep, SubStepTargets target, List`1<ISubStep> list);
    private static bool Targets(ISubStep substep, SubStepTargets target);
}
[FlagsAttribute]
public enum Mono.Linker.Steps.SubStepTargets : Enum {
    public int value__;
    public static SubStepTargets None;
    public static SubStepTargets Assembly;
    public static SubStepTargets Type;
    public static SubStepTargets Field;
    public static SubStepTargets Method;
    public static SubStepTargets Property;
    public static SubStepTargets Event;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.SweepStep : BaseStep {
    private bool sweepSymbols;
    private HashSet`1<AssemblyDefinition> BypassNGenToSave;
    public SweepStep(bool sweepSymbols);
    protected virtual void Process();
    private void RemoveUnmarkedAssembly(AssemblyDefinition assembly);
    private void UpdateAssemblyReferencesToRemovedAssemblies(AssemblyDefinition assembly);
    protected void ProcessAssemblyAction(AssemblyDefinition assembly);
    protected virtual void SweepAssembly(AssemblyDefinition assembly);
    private bool IsUsedAssembly(AssemblyDefinition assembly);
    private bool IsMarkedAssembly(AssemblyDefinition assembly);
    private bool CanSweepNamesForMember(IMemberDefinition member, MetadataTrimming metadataTrimming);
    protected virtual void RemoveAssembly(AssemblyDefinition assembly);
    private void SweepResources(AssemblyDefinition assembly);
    private bool SweepTypeForwarders(AssemblyDefinition assembly);
    protected virtual void SweepType(TypeDefinition type);
    protected void SweepNestedTypes(TypeDefinition type);
    protected void SweepInterfaces(TypeDefinition type);
    protected void SweepGenericParameters(Collection`1<GenericParameter> genericParameters);
    protected void SweepCustomAttributes(TypeDefinition type);
    protected void SweepCustomAttributes(MethodDefinition method);
    private bool ShouldSetHasSecurityToFalse(ISecurityDeclarationProvider providerAsSecurity, ICustomAttributeProvider provider);
    private bool IsSecurityAttributeType(TypeDefinition definition);
    protected bool SweepCustomAttributes(ICustomAttributeProvider provider);
    protected void SweepCustomAttributeCollection(Collection`1<T> providers);
    protected virtual void SweepMethods(Collection`1<MethodDefinition> methods);
    private void SweepOverrides(MethodDefinition method);
    private bool IsLinkScope(IMetadataScope scope);
    private void SweepDebugInfo(Collection`1<MethodDefinition> methods);
    protected void SweepCollectionWithCustomAttributes(IList`1<T> list);
    protected bool SweepCollectionMetadata(IList`1<T> list);
    protected virtual bool ShouldRemove(T element);
    protected virtual void ElementRemoved(IMetadataTokenProvider element);
    protected virtual void InterfaceRemoved(TypeDefinition type, InterfaceImplementation iface);
    protected virtual void CustomAttributeUsageRemoved(ICustomAttributeProvider provider, CustomAttribute attribute);
    [NullableContextAttribute("0")]
[CompilerGeneratedAttribute]
private bool <ShouldSetHasSecurityToFalse>b__20_0(CustomAttribute attr);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Steps.UnreachableBlocksOptimizer : object {
    private LinkContext _context;
    private Dictionary`2<MethodDefinition, Nullable`1<MethodResult>> _cache_method_results;
    private Stack`1<MethodDefinition> _resursion_guard;
    [NullableAttribute("2")]
private MethodDefinition IntPtrSize;
    [NullableAttribute("2")]
private MethodDefinition UIntPtrSize;
    public UnreachableBlocksOptimizer(LinkContext context);
    public void ProcessMethod(MethodDefinition method);
    private static bool IsMethodSupported(MethodDefinition method);
    private static bool HasJumpIntoTargetRange(Collection`1<Instruction> instructions, int firstInstr, int lastInstr, Func`2<Instruction, int> mapping);
    private static bool IsSideEffectFreeLoad(Instruction instr);
    private static bool IsComparisonAlwaysTrue(OpCode opCode, int left, int right);
    private Nullable`1<MethodResult> AnalyzeMethodForConstantResult(CalleePayload& callee, Stack`1<MethodDefinition> callStack);
    private static bool HasSideEffects(MethodDefinition method);
    private Nullable`1<MethodResult> TryGetMethodCallResult(CalleePayload& callee);
    private Nullable`1<MethodResult> TryGetMethodCallResult(CalleePayload& callee, Stack`1<MethodDefinition> callStack);
    private Instruction GetSizeOfResult(TypeReference type);
    private static Instruction EvaluateIntrinsicCall(MethodReference method, Instruction[] arguments);
    private static Instruction[] GetArgumentsOnStack(MethodDefinition method, Collection`1<Instruction> instructions, int index);
    private static bool GetConstantValue(Instruction instruction, Object& value);
    [NullableContextAttribute("2")]
private static MethodDefinition FindSizeMethod(TypeDefinition type);
    [CompilerGeneratedAttribute]
internal static bool <TryGetMethodCallResult>g__IsDeepStack|14_0(Stack`1<MethodDefinition> callStack);
    [CompilerGeneratedAttribute]
internal static bool <GetArgumentsOnStack>g__IsConstantValue|17_0(Instruction instr);
}
public class Mono.Linker.Steps.ValidateVirtualMethodAnnotationsStep : BaseStep {
    protected virtual void Process();
    [NullableContextAttribute("1")]
private void ValidateMethodRequiresUnreferencedCodeAreSame(MethodDefinition method, MethodDefinition baseMethod);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.SubstitutionInfo : object {
    [CompilerGeneratedAttribute]
private Dictionary`2<MethodDefinition, MethodAction> <MethodActions>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<MethodDefinition, object> <MethodStubValues>k__BackingField;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[CompilerGeneratedAttribute]
private Dictionary`2<FieldDefinition, object> <FieldValues>k__BackingField;
    [CompilerGeneratedAttribute]
private HashSet`1<FieldDefinition> <FieldInit>k__BackingField;
    public Dictionary`2<MethodDefinition, MethodAction> MethodActions { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<MethodDefinition, object> MethodStubValues { get; }
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
public Dictionary`2<FieldDefinition, object> FieldValues { get; }
    public HashSet`1<FieldDefinition> FieldInit { get; }
    [CompilerGeneratedAttribute]
public Dictionary`2<MethodDefinition, MethodAction> get_MethodActions();
    [CompilerGeneratedAttribute]
public Dictionary`2<MethodDefinition, object> get_MethodStubValues();
    [CompilerGeneratedAttribute]
public Dictionary`2<FieldDefinition, object> get_FieldValues();
    [CompilerGeneratedAttribute]
public HashSet`1<FieldDefinition> get_FieldInit();
    public void SetMethodAction(MethodDefinition method, MethodAction action);
    public void SetMethodStubValue(MethodDefinition method, object value);
    public void SetFieldValue(FieldDefinition field, object value);
    public void SetFieldInit(FieldDefinition field);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.SuppressMessageInfo : ValueType {
    public int Id;
    public string Scope;
    public string Target;
    public string MessageId;
}
public static class Mono.Linker.TargetRuntimeVersion : object {
    public static int NET5;
    public static int NET6;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.Tracer : object {
    protected LinkContext context;
    [NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private List`1<IDependencyRecorder> recorders;
    public Tracer(LinkContext context);
    public void Finish();
    public void AddRecorder(IDependencyRecorder recorder);
    [MemberNotNullWhenAttribute("True", "recorders")]
private bool IsRecordingEnabled();
    public void AddDirectDependency(object target, DependencyInfo& reason, bool marked);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.TypeDefinitionExtensions : object {
    [ExtensionAttribute]
public static TypeReference GetEnumUnderlyingType(TypeDefinition enumType);
    [ExtensionAttribute]
public static bool IsMulticastDelegate(TypeDefinition td);
    [ExtensionAttribute]
public static bool IsSerializable(TypeDefinition td);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.TypeHierarchyCache : object {
    private Dictionary`2<TypeDefinition, HierarchyFlags> _cache;
    private LinkContext context;
    public TypeHierarchyCache(LinkContext context);
    private HierarchyFlags GetFlags(TypeDefinition resolvedType);
    public bool IsSystemType(TypeDefinition type);
    public bool IsSystemReflectionIReflect(TypeDefinition type);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.TypeMapInfo : object {
    private HashSet`1<AssemblyDefinition> assemblies;
    private LinkContext context;
    protected Dictionary`2<MethodDefinition, List`1<OverrideInformation>> base_methods;
    protected Dictionary`2<MethodDefinition, List`1<OverrideInformation>> override_methods;
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
protected Dictionary`2<MethodDefinition, List`1<ValueTuple`2<TypeDefinition, InterfaceImplementation>>> default_interface_implementations;
    public TypeMapInfo(LinkContext context);
    private void EnsureProcessed(AssemblyDefinition assembly);
    public IEnumerable`1<OverrideInformation> GetOverrides(MethodDefinition method);
    public List`1<OverrideInformation> GetBaseMethods(MethodDefinition method);
    public IEnumerable`1<ValueTuple`2<TypeDefinition, InterfaceImplementation>> GetDefaultInterfaceImplementations(MethodDefinition method);
    public void AddBaseMethod(MethodDefinition method, MethodDefinition base, InterfaceImplementation matchingInterfaceImplementation);
    public void AddOverride(MethodDefinition base, MethodDefinition override, InterfaceImplementation matchingInterfaceImplementation);
    public void AddDefaultInterfaceImplementation(MethodDefinition base, TypeDefinition implementingType, InterfaceImplementation matchingInterfaceImplementation);
    protected virtual void MapType(TypeDefinition type);
    private void MapInterfaceMethodsInTypeHierarchy(TypeDefinition type);
    private void MapVirtualMethods(TypeDefinition type);
    private void MapVirtualMethod(MethodDefinition method);
    private void MapOverrides(MethodDefinition method);
    private void AnnotateMethods(MethodDefinition base, MethodDefinition override, InterfaceImplementation matchingInterfaceImplementation);
    private MethodDefinition GetBaseMethodInTypeHierarchy(MethodDefinition method);
    private MethodDefinition GetBaseMethodInTypeHierarchy(TypeDefinition type, MethodReference method);
    private TypeReference GetInflatedBaseType(TypeReference type);
    [IteratorStateMachineAttribute("Mono.Linker.TypeMapInfo/<GetDefaultInterfaceImplementations>d__22")]
private IEnumerable`1<InterfaceImplementation> GetDefaultInterfaceImplementations(TypeDefinition type, MethodDefinition interfaceMethod);
    private MethodDefinition TryMatchMethod(TypeReference type, MethodReference method);
    private bool MethodMatch(MethodReference candidate, MethodReference method);
    private static bool TypeMatch(IModifierType a, IModifierType b);
    private static bool TypeMatch(TypeSpecification a, TypeSpecification b);
    private static bool TypeMatch(GenericInstanceType a, GenericInstanceType b);
    private static bool TypeMatch(GenericParameter a, GenericParameter b);
    private static bool TypeMatch(FunctionPointerType a, FunctionPointerType b);
    private static bool TypeMatch(TypeReference a, TypeReference b);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal class Mono.Linker.TypeNameResolver : object {
    private LinkContext _context;
    public TypeNameResolver(LinkContext context);
    [NullableContextAttribute("2")]
public bool TryResolveTypeName(string typeNameString, DiagnosticContext& diagnosticContext, TypeReference& typeReference, List`1& typeResolutionRecords, bool needsAssemblyName);
    public bool TryResolveTypeName(AssemblyDefinition assembly, string typeNameString, TypeReference& typeReference, List`1& typeResolutionRecords);
    private TypeReference ResolveTypeName(AssemblyDefinition assembly, TypeName typeName, List`1<TypeResolutionRecord> typeResolutionRecords);
    [CompilerGeneratedAttribute]
private bool <TryResolveTypeName>g__TryResolveTypeName|3_0(AssemblyDefinition assemblyDefinition, TypeName typeName, TypeReference& typeReference, List`1<TypeResolutionRecord> typeResolutionRecords);
}
public enum Mono.Linker.TypePreserve : Enum {
    public int value__;
    public static TypePreserve Nothing;
    public static TypePreserve All;
    public static TypePreserve Fields;
    public static TypePreserve Methods;
}
[FlagsAttribute]
public enum Mono.Linker.TypePreserveMembers : Enum {
    public int value__;
    public static TypePreserveMembers Visible;
    public static TypePreserveMembers Internal;
    public static TypePreserveMembers Library;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
[ExtensionAttribute]
public static class Mono.Linker.TypeReferenceExtensions : object {
    [ExtensionAttribute]
public static string GetDisplayName(TypeReference type);
    [ExtensionAttribute]
public static StringBuilder GetDisplayNameWithoutNamespace(TypeReference type);
    internal static void PrependGenericParameters(IList`1<GenericParameter> genericParameters, StringBuilder sb);
    private static void PrependGenericArguments(Stack`1<TypeReference> genericArguments, int argumentsToTake, StringBuilder sb);
    private static void AppendArrayType(ArrayType arrayType, StringBuilder sb);
    [ExtensionAttribute]
public static TypeReference GetInflatedDeclaringType(TypeReference type, ITryResolveMetadata resolver);
    [IteratorStateMachineAttribute("Mono.Linker.TypeReferenceExtensions/<GetInflatedInterfaces>d__6")]
[ExtensionAttribute]
public static IEnumerable`1<ValueTuple`2<TypeReference, InterfaceImplementation>> GetInflatedInterfaces(TypeReference typeRef, ITryResolveMetadata resolver);
    public static TypeReference InflateGenericType(GenericInstanceType genericInstanceProvider, TypeReference typeToInflate, ITryResolveMetadata resolver);
    private static GenericInstanceType MakeGenericType(GenericInstanceType genericInstanceProvider, GenericInstanceType type, ITryResolveMetadata resolver);
    [IteratorStateMachineAttribute("Mono.Linker.TypeReferenceExtensions/<GetMethods>d__9")]
[ExtensionAttribute]
public static IEnumerable`1<MethodReference> GetMethods(TypeReference type, ITryResolveMetadata resolver);
    private static MethodReference MakeMethodReferenceForGenericInstanceType(GenericInstanceType genericInstanceType, MethodDefinition methodDef);
    [ExtensionAttribute]
public static string ToCecilName(string fullTypeName);
    [ExtensionAttribute]
public static bool HasDefaultConstructor(TypeDefinition type);
    [ExtensionAttribute]
public static MethodReference GetDefaultInstanceConstructor(TypeDefinition type);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference type, string ns, string name);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference type, string fullTypeName);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference tr);
    [ExtensionAttribute]
public static bool IsTypeOf(TypeReference tr, WellKnownType type);
    [ExtensionAttribute]
public static Nullable`1<WellKnownType> TryGetWellKnownType(TypeReference tr);
    [ExtensionAttribute]
public static bool IsSubclassOf(TypeReference type, string ns, string name, ITryResolveMetadata resolver);
    [ExtensionAttribute]
public static TypeReference WithoutModifiers(TypeReference type);
    [ExtensionAttribute]
public static TypeDefinition ResolveToTypeDefinition(TypeReference typeReference, LinkContext context);
    [ExtensionAttribute]
public static bool IsByRefOrPointer(TypeReference typeReference);
    [CompilerGeneratedAttribute]
internal static void <AppendArrayType>g__parseArrayDimensions|4_0(ArrayType at, <>c__DisplayClass4_0& );
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
internal abstract class Mono.Linker.TypeReferenceWalker : object {
    protected AssemblyDefinition assembly;
    [CompilerGeneratedAttribute]
private HashSet`1<TypeReference> <Visited>k__BackingField;
    protected HashSet`1<TypeReference> Visited { get; }
    public TypeReferenceWalker(AssemblyDefinition assembly);
    [CompilerGeneratedAttribute]
protected HashSet`1<TypeReference> get_Visited();
    protected virtual void Process();
    protected virtual void ProcessExtra();
    private void WalkScopes(TypeDefinition typeDefinition);
    private void WalkTypeScope(Collection`1<GenericParameter> genericParameters);
    private void WalkTypeScope(Collection`1<GenericParameterConstraint> constraints);
    private void WalkTypeScope(Collection`1<ParameterDefinition> parameters);
    private void WalkTypeScope(Collection`1<ExportedType> forwarders);
    private void WalkTypeScope(MethodBody body);
    private void WalkMethodReference(MethodReference mr);
    private void WalkFieldReference(FieldReference fr);
    private void WalkMarshalInfoTypeScope(IMarshalInfoProvider provider);
    private void WalkCustomAttributesTypesScopes(ICustomAttributeProvider customAttributeProvider);
    private void WalkSecurityAttributesTypesScopes(ISecurityDeclarationProvider securityAttributeProvider);
    private void WalkForwardedTypesScope(CustomAttribute attribute);
    private void WalkForwardedTypesScope(SecurityAttribute attribute);
    private void WalkForwardedTypesScope(CustomAttributeArgument attributeArgument);
    private void WalkScopeOfTypeReference(TypeReference type);
    protected abstract virtual void ProcessTypeReference(TypeReference type);
    protected abstract virtual void ProcessExportedType(ExportedType exportedType);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.UnconditionalSuppressMessageAttributeState : object {
    internal static string ScopeProperty;
    internal static string TargetProperty;
    internal static string MessageIdProperty;
    private LinkContext _context;
    private Dictionary`2<ICustomAttributeProvider, Dictionary`2<int, Suppression>> _suppressions;
    [CompilerGeneratedAttribute]
private HashSet`1<AssemblyDefinition> <InitializedAssemblies>k__BackingField;
    private HashSet`1<AssemblyDefinition> InitializedAssemblies { get; }
    public UnconditionalSuppressMessageAttributeState(LinkContext context);
    [CompilerGeneratedAttribute]
private HashSet`1<AssemblyDefinition> get_InitializedAssemblies();
    private void AddSuppression(Suppression suppression);
    public bool IsSuppressed(int id, MessageOrigin warningOrigin, SuppressMessageInfo& info);
    public void GatherSuppressions(ICustomAttributeProvider provider);
    [IteratorStateMachineAttribute("Mono.Linker.UnconditionalSuppressMessageAttributeState/<GetUnusedSuppressions>d__13")]
public IEnumerable`1<Suppression> GetUnusedSuppressions();
    private bool IsSuppressed(int id, ICustomAttributeProvider warningOrigin, SuppressMessageInfo& info);
    [NullableContextAttribute("2")]
private bool IsSuppressedOnElement(int id, ICustomAttributeProvider provider, SuppressMessageInfo& info);
    [NullableContextAttribute("2")]
private bool TryGetSuppressionsForProvider(ICustomAttributeProvider provider, Dictionary`2& suppressions);
    private static bool TryDecodeSuppressMessageAttributeData(CustomAttribute attribute, SuppressMessageInfo& info);
    public static ModuleDefinition GetModuleFromProvider(ICustomAttributeProvider provider);
    [IteratorStateMachineAttribute("Mono.Linker.UnconditionalSuppressMessageAttributeState/<DecodeSuppressions>d__19")]
private IEnumerable`1<Suppression> DecodeSuppressions(ICustomAttributeProvider provider);
    [IteratorStateMachineAttribute("Mono.Linker.UnconditionalSuppressMessageAttributeState/<DecodeAssemblyAndModuleSuppressions>d__20")]
private IEnumerable`1<Suppression> DecodeAssemblyAndModuleSuppressions(ModuleDefinition module);
    [IteratorStateMachineAttribute("Mono.Linker.UnconditionalSuppressMessageAttributeState/<DecodeGlobalSuppressions>d__21")]
private IEnumerable`1<Suppression> DecodeGlobalSuppressions(ModuleDefinition module, ICustomAttributeProvider provider);
    private static bool TypeRefHasUnconditionalSuppressions(TypeReference typeRef);
    public MessageOrigin GetSuppressionOrigin(Suppression suppression);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.UnintializedContextFactory : object {
    public virtual AnnotationStore CreateAnnotationStore(LinkContext context);
    public virtual MarkingHelpers CreateMarkingHelpers(LinkContext context);
    public virtual Tracer CreateTracer(LinkContext context);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.WarningSuppressionWriter : object {
    [TupleElementNamesAttribute("Mono.Cecil.CustomAttributeArgument[]")]
[NullableAttribute("Mono.Cecil.CustomAttributeArgument[]")]
private Dictionary`2<AssemblyNameDefinition, HashSet`1<ValueTuple`2<int, IMemberDefinition>>> _warnings;
    private FileOutputKind _fileOutputKind;
    private LinkContext _context;
    public bool IsEmpty { get; }
    public WarningSuppressionWriter(LinkContext context, FileOutputKind fileOutputKind);
    public bool get_IsEmpty();
    public void AddWarning(int code, ICustomAttributeProvider provider);
    public void OutputSuppressions(string directory);
    private void OutputSuppressionsXmlFormat(AssemblyNameDefinition assemblyName, string directory);
    private void OutputSuppressionsCSharpFormat(AssemblyNameDefinition assemblyName, string directory);
    private List`1<ValueTuple`2<int, string>> GetListOfWarnings(AssemblyNameDefinition assemblyName);
    private static string GetWarningSuppressionScopeString(string memberDocumentationSignature);
}
public enum Mono.Linker.WarnVersion : Enum {
    public int value__;
    public static WarnVersion ILLink0;
    public static WarnVersion ILLink5;
    public static WarnVersion Latest;
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class Mono.Linker.XmlDependencyRecorder : object {
    public static string DefaultDependenciesFileName;
    private LinkContext context;
    [NullableAttribute("2")]
private XmlWriter writer;
    [NullableAttribute("2")]
private Stream stream;
    public XmlDependencyRecorder(LinkContext context, string fileName);
    public sealed virtual void FinishRecording();
    public sealed virtual void Dispose();
    public void RecordDependency(object target, DependencyInfo& reason, bool marked);
    public sealed virtual void RecordDependency(object source, object target, bool marked);
    private sealed virtual override void Mono.Linker.IDependencyRecorder.RecordDependency(object target, DependencyInfo& modreq(System.Runtime.InteropServices.InAttribute) reason, bool marked);
}
[AttributeUsageAttribute("16")]
[ConditionalAttribute("EMIT_STATICCS_CLOSEDATTRIBUTE")]
internal class StaticCs.ClosedAttribute : Attribute {
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameFormatter : object {
    public static KeyValuePair`2[] EscapeSequences;
    private static AssemblyNameFormatter();
    public static string ComputeDisplayName(RuntimeAssemblyName a);
    [ExtensionAttribute]
private static void AppendQuoted(StringBuilder sb, string s);
    [ExtensionAttribute]
private static Version CanonicalizeVersion(Version version);
}
[ExtensionAttribute]
public static class System.Reflection.AssemblyNameHelpers : object {
    [ExtensionAttribute]
internal static AssemblyContentType ExtractAssemblyContentType(AssemblyNameFlags flags);
    [ExtensionAttribute]
internal static ProcessorArchitecture ExtractProcessorArchitecture(AssemblyNameFlags flags);
    [ExtensionAttribute]
public static AssemblyNameFlags ExtractAssemblyNameFlags(AssemblyNameFlags combinedFlags);
    internal static AssemblyNameFlags CombineAssemblyNameFlags(AssemblyNameFlags flags, AssemblyContentType contentType, ProcessorArchitecture processorArchitecture);
}
internal class System.Reflection.AssemblyNameLexer : ValueType {
    private Char[] _chars;
    private int _index;
    internal AssemblyNameLexer(string s);
    internal Token GetNext();
    internal Token GetNext(String& tokenString);
}
internal static class System.Reflection.AssemblyNameParser : object {
    private static Char[] s_illegalCharactersInSimpleName;
    private static AssemblyNameParser();
    internal static RuntimeAssemblyName Parse(string s);
    private static Version ParseVersion(string attributeValue);
    private static string ParseCulture(string attributeValue);
    private static Byte[] ParsePKT(string attributeValue);
    private static ProcessorArchitecture ParseProcessorArchitecture(string attributeValue);
    private static byte ParseHexNybble(char c);
}
internal class System.Reflection.Runtime.TypeParsing.ArrayTypeName : HasElementTypeName {
    public ArrayTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
}
public class System.Reflection.Runtime.TypeParsing.AssemblyQualifiedTypeName : TypeName {
    [CompilerGeneratedAttribute]
private RuntimeAssemblyName <AssemblyName>k__BackingField;
    [CompilerGeneratedAttribute]
private NonQualifiedTypeName <TypeName>k__BackingField;
    public RuntimeAssemblyName AssemblyName { get; }
    public NonQualifiedTypeName TypeName { get; }
    public AssemblyQualifiedTypeName(NonQualifiedTypeName typeName, RuntimeAssemblyName assemblyName);
    public sealed virtual string ToString();
    [CompilerGeneratedAttribute]
public RuntimeAssemblyName get_AssemblyName();
    [CompilerGeneratedAttribute]
public NonQualifiedTypeName get_TypeName();
}
internal class System.Reflection.Runtime.TypeParsing.ByRefTypeName : HasElementTypeName {
    public ByRefTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
}
internal class System.Reflection.Runtime.TypeParsing.ConstructedGenericTypeName : NonQualifiedTypeName {
    [CompilerGeneratedAttribute]
private NamedTypeName <GenericType>k__BackingField;
    [CompilerGeneratedAttribute]
private IEnumerable`1<TypeName> <GenericArguments>k__BackingField;
    public NamedTypeName GenericType { get; }
    public IEnumerable`1<TypeName> GenericArguments { get; }
    public ConstructedGenericTypeName(NamedTypeName genericType, IEnumerable`1<TypeName> genericArguments);
    [CompilerGeneratedAttribute]
public NamedTypeName get_GenericType();
    [CompilerGeneratedAttribute]
public IEnumerable`1<TypeName> get_GenericArguments();
    public sealed virtual string ToString();
}
internal abstract class System.Reflection.Runtime.TypeParsing.HasElementTypeName : NonQualifiedTypeName {
    [CompilerGeneratedAttribute]
private TypeName <ElementTypeName>k__BackingField;
    public TypeName ElementTypeName { get; }
    public HasElementTypeName(TypeName elementTypeName);
    [CompilerGeneratedAttribute]
public TypeName get_ElementTypeName();
}
internal class System.Reflection.Runtime.TypeParsing.MultiDimArrayTypeName : HasElementTypeName {
    [CompilerGeneratedAttribute]
private int <Rank>k__BackingField;
    public int Rank { get; }
    public MultiDimArrayTypeName(TypeName elementTypeName, int rank);
    public sealed virtual string ToString();
    [CompilerGeneratedAttribute]
public int get_Rank();
}
internal abstract class System.Reflection.Runtime.TypeParsing.NamedTypeName : NonQualifiedTypeName {
}
internal class System.Reflection.Runtime.TypeParsing.NamespaceTypeName : NamedTypeName {
    private string _name;
    private String[] _namespaceParts;
    public NamespaceTypeName(String[] namespaceParts, string name);
    public sealed virtual string ToString();
}
internal class System.Reflection.Runtime.TypeParsing.NestedTypeName : NamedTypeName {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private NamedTypeName <DeclaringType>k__BackingField;
    public string Name { get; private set; }
    public NamedTypeName DeclaringType { get; private set; }
    public NestedTypeName(string name, NamedTypeName declaringType);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    [CompilerGeneratedAttribute]
public NamedTypeName get_DeclaringType();
    [CompilerGeneratedAttribute]
private void set_DeclaringType(NamedTypeName value);
    public sealed virtual string ToString();
}
public abstract class System.Reflection.Runtime.TypeParsing.NonQualifiedTypeName : TypeName {
}
internal class System.Reflection.Runtime.TypeParsing.PointerTypeName : HasElementTypeName {
    public PointerTypeName(TypeName elementTypeName);
    public sealed virtual string ToString();
}
internal enum System.Reflection.Runtime.TypeParsing.TokenType : Enum {
    public int value__;
    public static TokenType End;
    public static TokenType OpenSqBracket;
    public static TokenType CloseSqBracket;
    public static TokenType Comma;
    public static TokenType Plus;
    public static TokenType Asterisk;
    public static TokenType Ampersand;
    public static TokenType Other;
}
internal class System.Reflection.Runtime.TypeParsing.TypeLexer : object {
    private int _index;
    private Char[] _chars;
    private static char NUL;
    public TokenType Peek { get; }
    public TokenType PeekSecond { get; }
    public TypeLexer(string s);
    public TokenType get_Peek();
    public TokenType get_PeekSecond();
    public void Skip();
    public TokenType GetNextToken();
    public string GetNextIdentifier();
    public RuntimeAssemblyName GetNextAssemblyName();
    public RuntimeAssemblyName GetNextEmbeddedAssemblyName();
    private static TokenType CharToToken(char c);
    private void SkipWhiteSpace();
}
public abstract class System.Reflection.Runtime.TypeParsing.TypeName : object {
    public abstract virtual string ToString();
}
public class System.Reflection.Runtime.TypeParsing.TypeParser : object {
    private TypeLexer _lexer;
    private TypeParser(string s);
    public static TypeName ParseTypeName(string s);
    private static TypeName ParseAssemblyQualifiedTypeName(string s);
    private NonQualifiedTypeName ParseNonQualifiedTypeName();
    private NonQualifiedTypeName ParseNamedOrConstructedGenericTypeName();
    private NamedTypeName ParseNamedTypeName();
    private NamespaceTypeName ParseNamespaceTypeName();
    private TypeName ParseGenericTypeArgument();
}
public class System.Reflection.RuntimeAssemblyName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    [CompilerGeneratedAttribute]
private AssemblyNameFlags <Flags>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <PublicKeyOrToken>k__BackingField;
    public string Name { get; }
    public Version Version { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public Byte[] PublicKeyOrToken { get; }
    public string FullName { get; }
    public RuntimeAssemblyName(string name, Version version, string cultureName, AssemblyNameFlags flags, Byte[] publicKeyOrToken);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public AssemblyNameFlags get_Flags();
    [CompilerGeneratedAttribute]
public Byte[] get_PublicKeyOrToken();
    public sealed virtual bool Equals(RuntimeAssemblyName other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public string get_FullName();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.RefSafetyRulesAttribute : Attribute {
    public int Version;
    public RefSafetyRulesAttribute(int );
}
