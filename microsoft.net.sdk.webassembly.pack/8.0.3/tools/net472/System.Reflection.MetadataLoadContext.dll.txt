internal static class FxResources.System.Reflection.MetadataLoadContext.SR : object {
}
internal static class Internal.Reflection.Core.Execution.ReflectionCoreExecution : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal abstract class System.Collections.Concurrent.ConcurrentUnifier`2 : object {
    private ConcurrentDictionary`2<K, V> _dict;
    public V GetOrAdd(K key);
    protected abstract virtual V Factory(K key);
}
internal class System.DefaultBinder : Binder {
    private MetadataLoadContext _loader;
    private Type _objectType;
    private static Primitives[] s_primitiveConversions;
    internal DefaultBinder(MetadataLoadContext loader);
    private static DefaultBinder();
    private bool IsImplementedByMetadataLoadContext(Type type);
    public sealed virtual MethodBase BindToMethod(BindingFlags bindingAttr, MethodBase[] match, Object[]& args, ParameterModifier[] modifiers, CultureInfo cultureInfo, String[] names, Object& state);
    public sealed virtual FieldInfo BindToField(BindingFlags bindingAttr, FieldInfo[] match, object value, CultureInfo cultureInfo);
    public sealed virtual MethodBase SelectMethod(BindingFlags bindingAttr, MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual PropertyInfo SelectProperty(BindingFlags bindingAttr, PropertyInfo[] match, Type returnType, Type[] indexes, ParameterModifier[] modifiers);
    public virtual object ChangeType(object value, Type type, CultureInfo cultureInfo);
    public sealed virtual void ReorderArgumentArray(Object[]& args, object state);
    public static MethodBase ExactBinding(MethodBase[] match, Type[] types, ParameterModifier[] modifiers);
    public static PropertyInfo ExactPropertyBinding(PropertyInfo[] match, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private static int FindMostSpecific(ParameterInfo[] p1, Int32[] paramOrder1, Type paramArrayType1, ParameterInfo[] p2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificType(Type c1, Type c2, Type t);
    private static int FindMostSpecificMethod(MethodBase m1, Int32[] paramOrder1, Type paramArrayType1, MethodBase m2, Int32[] paramOrder2, Type paramArrayType2, Type[] types, Object[] args);
    private static int FindMostSpecificProperty(PropertyInfo cur1, PropertyInfo cur2);
    public static bool CompareMethodSig(MethodBase m1, MethodBase m2);
    private static int GetHierarchyDepth(Type t);
    internal static MethodBase FindMostDerivedNewSlotMeth(MethodBase[] match, int cMatches);
    private static bool CanChangePrimitive(Type source, Type target);
    private static bool CanPrimitiveWiden(Type source, Type target);
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.AllowNullAttribute : Attribute {
}
[AttributeUsageAttribute("2432")]
internal class System.Diagnostics.CodeAnalysis.DisallowNullAttribute : Attribute {
}
[AttributeUsageAttribute("64")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ParameterValue>k__BackingField;
    public bool ParameterValue { get; }
    public DoesNotReturnIfAttribute(bool parameterValue);
    [CompilerGeneratedAttribute]
public bool get_ParameterValue();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullAttribute : Attribute {
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public MaybeNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public String[] Members { get; }
    public MemberNotNullAttribute(string member);
    public MemberNotNullAttribute(String[] members);
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("192")]
internal class System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    [CompilerGeneratedAttribute]
private String[] <Members>k__BackingField;
    public bool ReturnValue { get; }
    public String[] Members { get; }
    public MemberNotNullWhenAttribute(bool returnValue, string member);
    public MemberNotNullWhenAttribute(bool returnValue, String[] members);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
    [CompilerGeneratedAttribute]
public String[] get_Members();
}
[AttributeUsageAttribute("10624")]
internal class System.Diagnostics.CodeAnalysis.NotNullAttribute : Attribute {
}
[AttributeUsageAttribute("10368")]
internal class System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <ParameterName>k__BackingField;
    public string ParameterName { get; }
    public NotNullIfNotNullAttribute(string parameterName);
    [CompilerGeneratedAttribute]
public string get_ParameterName();
}
[AttributeUsageAttribute("2048")]
internal class System.Diagnostics.CodeAnalysis.NotNullWhenAttribute : Attribute {
    [CompilerGeneratedAttribute]
private bool <ReturnValue>k__BackingField;
    public bool ReturnValue { get; }
    public NotNullWhenAttribute(bool returnValue);
    [CompilerGeneratedAttribute]
public bool get_ReturnValue();
}
[AttributeUsageAttribute("100")]
internal class System.Diagnostics.CodeAnalysis.RequiresUnreferencedCodeAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Message>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Url>k__BackingField;
    public string Message { get; }
    public string Url { get; public set; }
    public RequiresUnreferencedCodeAttribute(string message);
    [CompilerGeneratedAttribute]
public string get_Message();
    [CompilerGeneratedAttribute]
public string get_Url();
    [CompilerGeneratedAttribute]
public void set_Url(string value);
}
[AttributeUsageAttribute("32767")]
internal class System.Diagnostics.CodeAnalysis.UnconditionalSuppressMessageAttribute : Attribute {
    [CompilerGeneratedAttribute]
private string <Category>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CheckId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Scope>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Target>k__BackingField;
    [CompilerGeneratedAttribute]
private string <MessageId>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Justification>k__BackingField;
    public string Category { get; }
    public string CheckId { get; }
    public string Scope { get; public set; }
    public string Target { get; public set; }
    public string MessageId { get; public set; }
    public string Justification { get; public set; }
    public UnconditionalSuppressMessageAttribute(string category, string checkId);
    [CompilerGeneratedAttribute]
public string get_Category();
    [CompilerGeneratedAttribute]
public string get_CheckId();
    [CompilerGeneratedAttribute]
public string get_Scope();
    [CompilerGeneratedAttribute]
public void set_Scope(string value);
    [CompilerGeneratedAttribute]
public string get_Target();
    [CompilerGeneratedAttribute]
public void set_Target(string value);
    [CompilerGeneratedAttribute]
public string get_MessageId();
    [CompilerGeneratedAttribute]
public void set_MessageId(string value);
    [CompilerGeneratedAttribute]
public string get_Justification();
    [CompilerGeneratedAttribute]
public void set_Justification(string value);
}
internal static class System.Obsoletions : object {
    internal static string SharedUrlFormat;
    internal static string SystemTextEncodingUTF7Message;
    internal static string SystemTextEncodingUTF7DiagId;
    internal static string PrincipalPermissionAttributeMessage;
    internal static string PrincipalPermissionAttributeDiagId;
    internal static string CodeAccessSecurityMessage;
    internal static string CodeAccessSecurityDiagId;
    internal static string ConstrainedExecutionRegionMessage;
    internal static string ConstrainedExecutionRegionDiagId;
    internal static string GlobalAssemblyCacheMessage;
    internal static string GlobalAssemblyCacheDiagId;
    internal static string ThreadAbortMessage;
    internal static string ThreadAbortDiagId;
    internal static string DefaultCryptoAlgorithmsMessage;
    internal static string DefaultCryptoAlgorithmsDiagId;
    internal static string CreatePdbGeneratorMessage;
    internal static string CreatePdbGeneratorDiagId;
    internal static string AuthenticationManagerMessage;
    internal static string AuthenticationManagerDiagId;
    internal static string RemotingApisMessage;
    internal static string RemotingApisDiagId;
    internal static string BinaryFormatterMessage;
    internal static string BinaryFormatterDiagId;
    internal static string CodeBaseMessage;
    internal static string CodeBaseDiagId;
    internal static string EscapeUriStringMessage;
    internal static string EscapeUriStringDiagId;
    internal static string WebRequestMessage;
    internal static string WebRequestDiagId;
    internal static string DisablePrivateReflectionAttributeMessage;
    internal static string DisablePrivateReflectionAttributeDiagId;
    internal static string GetContextInfoMessage;
    internal static string GetContextInfoDiagId;
    internal static string StrongNameKeyPairMessage;
    internal static string StrongNameKeyPairDiagId;
    internal static string ReflectionOnlyLoadingMessage;
    internal static string ReflectionOnlyLoadingDiagId;
    internal static string RuntimeEnvironmentMessage;
    internal static string RuntimeEnvironmentDiagId;
    internal static string JsonSerializerOptionsIgnoreNullValuesMessage;
    internal static string JsonSerializerOptionsIgnoreNullValuesDiagId;
    internal static string DerivedCryptographicTypesMessage;
    internal static string DerivedCryptographicTypesDiagId;
    internal static string RijndaelMessage;
    internal static string RijndaelDiagId;
    internal static string RNGCryptoServiceProviderMessage;
    internal static string RNGCryptoServiceProviderDiagId;
    internal static string AppDomainCreateUnloadMessage;
    internal static string AppDomainCreateUnloadDiagId;
    internal static string SuppressIldasmAttributeMessage;
    internal static string SuppressIldasmAttributeDiagId;
    internal static string X509CertificateImmutableMessage;
    internal static string X509CertificateImmutableDiagId;
    internal static string PublicKeyPropertyMessage;
    internal static string PublicKeyPropertyDiagId;
    internal static string X509CertificatePrivateKeyMessage;
    internal static string X509CertificatePrivateKeyDiagId;
    internal static string ProduceLegacyHmacValuesMessage;
    internal static string ProduceLegacyHmacValuesDiagId;
    internal static string UseManagedSha1Message;
    internal static string UseManagedSha1DiagId;
    internal static string CryptoConfigEncodeOIDMessage;
    internal static string CryptoConfigEncodeOIDDiagId;
    internal static string CorruptedStateRecoveryMessage;
    internal static string CorruptedStateRecoveryDiagId;
    internal static string Rfc2898CryptDeriveKeyMessage;
    internal static string Rfc2898CryptDeriveKeyDiagId;
    internal static string CmsSignerCspParamsCtorMessage;
    internal static string CmsSignerCspParamsCtorDiagId;
    internal static string SignerInfoCounterSigMessage;
    internal static string SignerInfoCounterSigDiagId;
}
[ExtensionAttribute]
internal static class System.Reflection.AssemblyNameHelpers : object {
    [ExtensionAttribute]
internal static AssemblyContentType ExtractAssemblyContentType(AssemblyNameFlags flags);
    [ExtensionAttribute]
public static AssemblyNameFlags ExtractAssemblyNameFlags(AssemblyNameFlags combinedFlags);
}
public abstract class System.Reflection.MetadataAssemblyResolver : object {
    [NullableContextAttribute("1")]
public abstract virtual Assembly Resolve(MetadataLoadContext context, AssemblyName assemblyName);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.MetadataLoadContext : object {
    private MetadataAssemblyResolver resolver;
    private static String[] s_CoreNames;
    private RoAssembly _coreAssembly;
    private CoreTypes _coreTypes;
    private Binder modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDefaultBinder;
    private ConcurrentBag`1<IDisposable> _disposables;
    [CompilerGeneratedAttribute]
private bool <IsDisposed>k__BackingField;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFieldOffset;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIn;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOut;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyOptional;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPreserveSig;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyComImport;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDllImport;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMarshalAs;
    private ConcurrentDictionary`2<RoAssemblyName, RoAssembly> _loadedAssemblies;
    private ConcurrentDictionary`2<RoAssemblyName, RoAssembly> _binds;
    [NullableAttribute("2")]
public Assembly CoreAssembly { get; }
    internal bool IsDisposed { get; private set; }
    public MetadataLoadContext(MetadataAssemblyResolver resolver, string coreAssemblyName);
    private static MetadataLoadContext();
    public Assembly LoadFromAssemblyPath(string assemblyPath);
    public Assembly LoadFromByteArray(Byte[] assembly);
    public Assembly LoadFromStream(Stream assembly);
    public Assembly LoadFromAssemblyName(string assemblyName);
    public Assembly LoadFromAssemblyName(AssemblyName assemblyName);
    [NullableContextAttribute("2")]
public Assembly get_CoreAssembly();
    public IEnumerable`1<Assembly> GetAssemblies();
    public sealed virtual void Dispose();
    internal RoAssembly TryGetCoreAssembly(string coreAssemblyName, Exception& e);
    private RoAssembly TryGetDefaultCoreAssembly(Exception& e);
    internal RoType GetCoreType(CoreType coreType);
    internal RoType TryGetCoreType(CoreType coreType);
    internal CoreTypes GetAllFoundCoreTypes();
    internal Binder GetDefaultBinder();
    [CompilerGeneratedAttribute]
internal bool get_IsDisposed();
    [CompilerGeneratedAttribute]
private void set_IsDisposed(bool value);
    internal void DisposeCheck();
    internal void RegisterForDisposal(IDisposable disposable);
    private void Dispose(bool disposing);
    internal ConstructorInfo TryGetFieldOffsetCtor();
    internal ConstructorInfo TryGetInCtor();
    internal ConstructorInfo TryGetOutCtor();
    internal ConstructorInfo TryGetOptionalCtor();
    internal ConstructorInfo TryGetPreserveSigCtor();
    internal ConstructorInfo TryGetComImportCtor();
    internal ConstructorInfo TryGetDllImportCtor();
    internal ConstructorInfo TryGetMarshalAsCtor();
    private ConstructorInfo TryGetConstructor(CoreType attributeCoreType, CoreType[] parameterCoreTypes);
    private RoAssembly LoadFromStreamCore(Stream peStream);
    internal RoAssembly ResolveAssembly(RoAssemblyName refName);
    internal RoAssembly TryResolveAssembly(RoAssemblyName refName, Exception& e);
    internal RoAssembly ResolveToAssemblyOrExceptionAssembly(RoAssemblyName refName);
    private RoAssembly TryFindAssemblyByCallingResolveHandler(RoAssemblyName refName);
}
internal abstract class System.Reflection.NameFilter : object {
    [CompilerGeneratedAttribute]
private string <ExpectedName>k__BackingField;
    protected string ExpectedName { get; }
    protected NameFilter(string expectedName);
    public abstract virtual bool Matches(string name);
    [CompilerGeneratedAttribute]
protected string get_ExpectedName();
    public abstract virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
}
internal class System.Reflection.NameFilterCaseInsensitive : NameFilter {
    public NameFilterCaseInsensitive(string expectedName);
    public sealed virtual bool Matches(string name);
    public sealed virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
}
internal class System.Reflection.NameFilterCaseSensitive : NameFilter {
    private Byte[] _expectedNameUtf8;
    public NameFilterCaseSensitive(string expectedName);
    public sealed virtual bool Matches(string name);
    public sealed virtual bool Matches(StringHandle stringHandle, MetadataReader reader);
}
[NullableContextAttribute("1")]
[NullableAttribute("0")]
public class System.Reflection.PathAssemblyResolver : MetadataAssemblyResolver {
    private Dictionary`2<string, List`1<string>> _fileToPaths;
    public PathAssemblyResolver(IEnumerable`1<string> assemblyPaths);
    public virtual Assembly Resolve(MetadataLoadContext context, AssemblyName assemblyName);
}
internal class System.Reflection.Runtime.BindingFlagSupport.ConstructorPolicies : MemberPolicies`1<ConstructorInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<ConstructorInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<ConstructorInfo> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(ConstructorInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(ConstructorInfo baseMember, ConstructorInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(ConstructorInfo member, ConstructorInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(ConstructorInfo m1, ConstructorInfo m2);
}
internal class System.Reflection.Runtime.BindingFlagSupport.EventPolicies : MemberPolicies`1<EventInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<EventInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<EventInfo> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(EventInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(EventInfo member, EventInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool ImplicitlyOverrides(EventInfo baseMember, EventInfo derivedMember);
    public sealed virtual bool OkToIgnoreAmbiguity(EventInfo m1, EventInfo m2);
    private MethodInfo GetAccessorMethod(EventInfo e);
}
internal class System.Reflection.Runtime.BindingFlagSupport.FieldPolicies : MemberPolicies`1<FieldInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<FieldInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<FieldInfo> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(FieldInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(FieldInfo baseMember, FieldInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(FieldInfo member, FieldInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(FieldInfo m1, FieldInfo m2);
}
internal abstract class System.Reflection.Runtime.BindingFlagSupport.MemberPolicies`1 : object {
    public static MemberPolicies`1<M> Default;
    public static int MemberTypeIndex;
    public bool AlwaysTreatAsDeclaredOnly { get; }
    private static MemberPolicies`1();
    public abstract virtual IEnumerable`1<M> GetDeclaredMembers(TypeInfo typeInfo);
    public abstract virtual IEnumerable`1<M> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public abstract virtual void GetMemberAttributes(M member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public abstract virtual bool ImplicitlyOverrides(M baseMember, M derivedMember);
    public virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public abstract virtual bool get_AlwaysTreatAsDeclaredOnly();
    public abstract virtual bool IsSuppressedByMoreDerivedMember(M member, M[] priorMembers, int startIndex, int endIndex);
    public abstract virtual bool OkToIgnoreAmbiguity(M m1, M m2);
    protected static bool AreNamesAndSignaturesEqual(MethodInfo method1, MethodInfo method2);
    private static bool GenericMethodAwareAreParameterTypesEqual(Type t1, Type t2);
}
internal static class System.Reflection.Runtime.BindingFlagSupport.MemberTypeIndex : object {
    public static int Constructor;
    public static int Event;
    public static int Field;
    public static int Method;
    public static int NestedType;
    public static int Property;
    public static int Count;
}
internal class System.Reflection.Runtime.BindingFlagSupport.MethodPolicies : MemberPolicies`1<MethodInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<MethodInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<MethodInfo> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(MethodInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(MethodInfo baseMember, MethodInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(MethodInfo member, MethodInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(MethodInfo m1, MethodInfo m2);
}
internal class System.Reflection.Runtime.BindingFlagSupport.NestedTypePolicies : MemberPolicies`1<Type> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<Type> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<Type> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(Type member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(Type baseMember, Type derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(Type member, Type[] priorMembers, int startIndex, int endIndex);
    public sealed virtual BindingFlags ModifyBindingFlags(BindingFlags bindingFlags);
    public sealed virtual bool OkToIgnoreAmbiguity(Type m1, Type m2);
}
internal class System.Reflection.Runtime.BindingFlagSupport.PropertyPolicies : MemberPolicies`1<PropertyInfo> {
    public bool AlwaysTreatAsDeclaredOnly { get; }
    public sealed virtual IEnumerable`1<PropertyInfo> GetDeclaredMembers(TypeInfo typeInfo);
    public sealed virtual IEnumerable`1<PropertyInfo> CoreGetDeclaredMembers(RoType type, NameFilter filter, RoType reflectedType);
    public sealed virtual bool get_AlwaysTreatAsDeclaredOnly();
    public sealed virtual void GetMemberAttributes(PropertyInfo member, MethodAttributes& visibility, Boolean& isStatic, Boolean& isVirtual, Boolean& isNewSlot);
    public sealed virtual bool ImplicitlyOverrides(PropertyInfo baseMember, PropertyInfo derivedMember);
    public sealed virtual bool IsSuppressedByMoreDerivedMember(PropertyInfo member, PropertyInfo[] priorMembers, int startIndex, int endIndex);
    public sealed virtual bool OkToIgnoreAmbiguity(PropertyInfo m1, PropertyInfo m2);
    private MethodInfo GetAccessorMethod(PropertyInfo property);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Runtime.BindingFlagSupport.QueriedMemberList`1 : object {
    [CompilerGeneratedAttribute]
private bool <ImmediateTypeOnly>k__BackingField;
    private int _totalCount;
    private int _declaredOnlyCount;
    private M[] _members;
    private BindingFlags[] _allFlagsThatMustMatch;
    private RoType _typeThatBlockedBrowsing;
    private static int Grow;
    public int TotalCount { get; }
    public int DeclaredOnlyCount { get; }
    public bool ImmediateTypeOnly { get; }
    public M Item { get; }
    private QueriedMemberList`1(bool immediateTypeOnly);
    private QueriedMemberList`1(int totalCount, int declaredOnlyCount, M[] members, BindingFlags[] allFlagsThatMustMatch, RoType typeThatBlockedBrowsing);
    public int get_TotalCount();
    public int get_DeclaredOnlyCount();
    [CompilerGeneratedAttribute]
public bool get_ImmediateTypeOnly();
    public M get_Item(int index);
    public bool Matches(int index, BindingFlags bindingAttr);
    public QueriedMemberList`1<M> Filter(Func`2<M, bool> predicate);
    public static QueriedMemberList`1<M> Create(RoType type, string filter, bool ignoreCase, bool immediateTypeOnly);
    public void Compact();
    private void Add(M member, BindingFlags allFlagsThatMustMatch);
}
internal class System.Reflection.Runtime.BindingFlagSupport.QueryResult`1 : ValueType {
    private BindingFlags _bindingAttr;
    private int _lazyCount;
    private QueriedMemberList`1<M> _queriedMembers;
    public int Count { get; }
    private int UnfilteredCount { get; }
    public QueryResult`1(BindingFlags bindingAttr, QueriedMemberList`1<M> queriedMembers);
    public QueryResultEnumerator<M> GetEnumerator();
    public int get_Count();
    public M[] ToArray();
    public void CopyTo(MemberInfo[] array, int startIndex);
    public M Disambiguate();
    private int get_UnfilteredCount();
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.BindingFlagSupport.Shared : object {
    [ExtensionAttribute]
public static bool QualifiesBasedOnParameterCount(MethodBase methodBase, BindingFlags bindingFlags, CallingConventions callConv, Type[] argumentTypes);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.Runtime.General.ListBuilder`1 : ValueType {
    private T[] _items;
    private T _item;
    private int _count;
    private int _capacity;
    public T Item { get; }
    public int Count { get; }
    public ListBuilder`1(int capacity);
    public T get_Item(int index);
    public T[] ToArray();
    public void CopyTo(Object[] array, int index);
    public int get_Count();
    public void Add(T item);
}
[ExtensionAttribute]
internal static class System.Reflection.Runtime.TypeInfos.RoShims : object {
    [ExtensionAttribute]
internal static RoType CastToRuntimeTypeInfo(Type t);
    [ExtensionAttribute]
internal static bool CanBrowseWithoutMissingMetadataExceptions(Type t);
    [ExtensionAttribute]
internal static Type[] GetGenericTypeParameters(Type t);
}
[ExtensionAttribute]
internal static class System.Reflection.SignatureTypeExtensions : object {
    [ExtensionAttribute]
public static bool MatchesParameterTypeExactly(Type pattern, ParameterInfo parameter);
    [ExtensionAttribute]
internal static bool MatchesExactly(Type pattern, Type actual);
    [ExtensionAttribute]
internal static Type TryResolveAgainstGenericMethod(Type signatureType, MethodInfo genericMethod);
    [ExtensionAttribute]
private static Type TryResolve(Type signatureType, Type[] genericMethodParameters);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type);
    [ExtensionAttribute]
private static Type TryMakeArrayType(Type type, int rank);
    [ExtensionAttribute]
private static Type TryMakeByRefType(Type type);
    [ExtensionAttribute]
private static Type TryMakePointerType(Type type);
    [ExtensionAttribute]
private static Type TryMakeGenericType(Type type, Type[] instantiation);
}
[IsReadOnlyAttribute]
internal class System.Reflection.TypeLoading.AssemblyFileInfo : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private int <RowIndex>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <ContainsMetadata>k__BackingField;
    public string Name { get; }
    public int RowIndex { get; }
    public bool ContainsMetadata { get; }
    public AssemblyFileInfo(string name, bool containsMetadata, int rowIndex);
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public int get_RowIndex();
    [CompilerGeneratedAttribute]
public bool get_ContainsMetadata();
}
internal class System.Reflection.TypeLoading.AssemblyNameData : object {
    public AssemblyNameFlags Flags;
    public string Name;
    public Version Version;
    public string CultureName;
    public Byte[] PublicKey;
    public Byte[] PublicKeyToken;
    public AssemblyContentType ContentType;
    public AssemblyHashAlgorithm HashAlgorithm;
    public ProcessorArchitecture ProcessorArchitecture;
    public AssemblyName CreateAssemblyName();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Assignability : object {
    public static bool IsAssignableFrom(Type toTypeInfo, Type fromTypeInfo, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool CanCastTo(Type fromTypeInfo, Type toTypeInfo, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool MatchesWithVariance(Type fromTypeInfo, Type toTypeInfo, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool IsElementTypeCompatibleWith(Type fromTypeInfo, Type toTypeInfo, CoreTypes coreTypes);
    [ExtensionAttribute]
private static Type ReducedType(Type t, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool IsGcReferenceTypeAndCastableTo(Type fromTypeInfo, Type toTypeInfo, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool ProvablyAGcReferenceType(Type t, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool ProvablyAGcReferenceTypeHelper(Type t, CoreTypes coreTypes);
    [ExtensionAttribute]
private static bool CanCastArrayToInterface(Type fromTypeInfo, Type toTypeInfo, CoreTypes coreTypes);
}
internal enum System.Reflection.TypeLoading.CoreType : Enum {
    public int value__;
    public static CoreType Array;
    public static CoreType Boolean;
    public static CoreType Byte;
    public static CoreType Char;
    public static CoreType Double;
    public static CoreType Enum;
    public static CoreType Int16;
    public static CoreType Int32;
    public static CoreType Int64;
    public static CoreType IntPtr;
    public static CoreType Object;
    public static CoreType NullableT;
    public static CoreType SByte;
    public static CoreType Single;
    public static CoreType String;
    public static CoreType TypedReference;
    public static CoreType UInt16;
    public static CoreType UInt32;
    public static CoreType UInt64;
    public static CoreType UIntPtr;
    public static CoreType ValueType;
    public static CoreType Void;
    public static CoreType MulticastDelegate;
    public static CoreType IEnumerableT;
    public static CoreType ICollectionT;
    public static CoreType IListT;
    public static CoreType IReadOnlyListT;
    public static CoreType DBNull;
    public static CoreType Decimal;
    public static CoreType DateTime;
    public static CoreType Type;
    public static CoreType ComImportAttribute;
    public static CoreType DllImportAttribute;
    public static CoreType CallingConvention;
    public static CoreType CharSet;
    public static CoreType MarshalAsAttribute;
    public static CoreType UnmanagedType;
    public static CoreType VarEnum;
    public static CoreType InAttribute;
    public static CoreType OutAttribute;
    public static CoreType OptionalAttribute;
    public static CoreType PreserveSigAttribute;
    public static CoreType FieldOffsetAttribute;
    public static CoreType NumCoreTypes;
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.CoreTypeHelpers : object {
    [ExtensionAttribute]
public static void GetFullName(CoreType coreType, ReadOnlySpan`1& ns, ReadOnlySpan`1& name);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.TypeLoading.CoreTypes : object {
    private RoType[] _coreTypes;
    private Exception[] _exceptions;
    public RoType Item { get; }
    internal CoreTypes(MetadataLoadContext loader, string coreAssemblyName);
    public RoType get_Item(CoreType coreType);
    public Exception GetException(CoreType coreType);
}
[IsReadOnlyAttribute]
internal class System.Reflection.TypeLoading.CustomAttributeArguments : ValueType {
    [CompilerGeneratedAttribute]
private IList`1<CustomAttributeTypedArgument> <FixedArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private IList`1<CustomAttributeNamedArgument> <NamedArguments>k__BackingField;
    public IList`1<CustomAttributeTypedArgument> FixedArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public CustomAttributeArguments(IList`1<CustomAttributeTypedArgument> fixedArguments, IList`1<CustomAttributeNamedArgument> namedArguments);
    [CompilerGeneratedAttribute]
public IList`1<CustomAttributeTypedArgument> get_FixedArguments();
    [CompilerGeneratedAttribute]
public IList`1<CustomAttributeNamedArgument> get_NamedArguments();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.CustomAttributeHelpers : object {
    [ExtensionAttribute]
public static CustomAttributeNamedArgument ToCustomAttributeNamedArgument(Type attributeType, string name, Type argumentType, object value);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<CustomAttributeTypedArgument> CloneForApiReturn(IList`1<CustomAttributeTypedArgument> cats);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<CustomAttributeNamedArgument> CloneForApiReturn(IList`1<CustomAttributeNamedArgument> cans);
    [ExtensionAttribute]
private static CustomAttributeTypedArgument CloneForApiReturn(CustomAttributeTypedArgument cat);
    [ExtensionAttribute]
private static CustomAttributeNamedArgument CloneForApiReturn(CustomAttributeNamedArgument can);
    public static CustomAttributeData TryComputeMarshalAsCustomAttributeData(Func`1<MarshalAsAttribute> marshalAsAttributeComputer, MetadataLoadContext loader);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.DefaultBinderThunks : object {
    [ExtensionAttribute]
internal static ParameterInfo[] GetParametersNoCopy(MethodBase m);
    [ExtensionAttribute]
internal static int GetGenericParameterCount(MethodInfo m);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaAssembly : RoAssembly {
    private string _location;
    private EcmaModule _manifestModule;
    [DebuggerBrowsableAttribute("0")]
private AssemblyDefinition _neverAccessThisExceptThroughAssemblyDefinitionProperty;
    [CompilerGeneratedAttribute]
private ModuleResolveEventHandler ModuleResolve;
    public MethodInfo EntryPoint { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public string Location { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal MetadataReader Reader { get; }
    [IsReadOnlyAttribute]
private AssemblyDefinition& modreq(System.Runtime.InteropServices.InAttribute) AssemblyDefinition { get; }
    internal EcmaAssembly(MetadataLoadContext loader, PEReader peReader, MetadataReader reader, string location);
    internal sealed virtual RoModule GetRoManifestModule();
    internal EcmaModule GetEcmaManifestModule();
    public sealed virtual MethodInfo get_EntryPoint();
    public sealed virtual string get_ImageRuntimeVersion();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual string get_Location();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected sealed virtual AssemblyNameData[] ComputeAssemblyReferences();
    protected sealed virtual void IterateTypeForwards(TypeForwardHandler handler);
    internal MetadataReader get_Reader();
    private AssemblyDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_AssemblyDefinition();
    protected sealed virtual AssemblyNameData ComputeNameData();
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public sealed virtual String[] GetManifestResourceNames();
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3002:RequiresAssemblyFiles on Module.GetFile")]
public sealed virtual Stream GetManifestResourceStream(string name);
    [CompilerGeneratedAttribute]
public sealed virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
public sealed virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    protected sealed virtual RoModule LoadModule(string moduleName, bool containsMetadata);
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3000: Avoid accessing Assembly file path when publishing as a single file")]
private FileStream FindModuleNextToAssembly(string moduleName);
    protected sealed virtual RoModule CreateModule(Stream peStream, bool containsMetadata);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaAssembly/<GetAssemblyFileInfosFromManifest>d__32")]
protected sealed virtual IEnumerable`1<AssemblyFileInfo> GetAssemblyFileInfosFromManifest(bool includeManifestModule, bool includeResourceModules);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaCustomAttributeData : RoCustomAttributeData {
    private CustomAttributeHandle _handle;
    private EcmaModule _module;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFixedArguments;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyNamedArguments;
    [DebuggerBrowsableAttribute("0")]
private CustomAttribute _neverAccessThisExceptThroughCustomAttributeProperty;
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private CustomAttribute& modreq(System.Runtime.InteropServices.InAttribute) CustomAttribute { get; }
    internal EcmaCustomAttributeData(CustomAttributeHandle handle, EcmaModule module);
    public sealed virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public sealed virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    protected sealed virtual Type ComputeAttributeType();
    protected sealed virtual ConstructorInfo ComputeConstructor();
    private void LoadArguments();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private CustomAttribute& modreq(System.Runtime.InteropServices.InAttribute) get_CustomAttribute();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.EcmaCustomAttributeHelpers : object {
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaCustomAttributeHelpers/<ToTrueCustomAttributes>d__0")]
[ExtensionAttribute]
public static IEnumerable`1<CustomAttributeData> ToTrueCustomAttributes(CustomAttributeHandleCollection handles, EcmaModule module);
    [ExtensionAttribute]
public static CustomAttributeData ToCustomAttributeData(CustomAttributeHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static bool IsCustomAttributeDefined(CustomAttributeHandleCollection handles, ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, EcmaModule module);
    [ExtensionAttribute]
public static CustomAttributeData TryFindCustomAttribute(CustomAttributeHandleCollection handles, ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, EcmaModule module);
    [ExtensionAttribute]
private static CustomAttributeHandle FindCustomAttributeByName(CustomAttributeHandleCollection handles, ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, EcmaModule module);
    [ExtensionAttribute]
public static bool TypeMatchesNameAndNamespace(EntityHandle handle, ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, MetadataReader reader);
    [ExtensionAttribute]
public static EntityHandle TryGetDeclaringTypeHandle(CustomAttribute& ca, MetadataReader reader);
    [ExtensionAttribute]
public static IList`1<CustomAttributeTypedArgument> ToApiForm(IList`1<CustomAttributeTypedArgument`1<RoType>> catgs);
    [ExtensionAttribute]
public static CustomAttributeTypedArgument ToApiForm(CustomAttributeTypedArgument`1<RoType> catg);
    private static CustomAttributeTypedArgument ToApiForm(Type type, object value);
    [ExtensionAttribute]
public static IList`1<CustomAttributeNamedArgument> ToApiForm(IList`1<CustomAttributeNamedArgument`1<RoType>> cangs, Type attributeType);
    [ExtensionAttribute]
public static CustomAttributeNamedArgument ToApiForm(CustomAttributeNamedArgument`1<RoType> cang, Type attributeType);
    [ExtensionAttribute]
public static MarshalAsAttribute ToMarshalAsAttribute(BlobHandle blobHandle, EcmaModule module);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.EcmaDefaultValueProcessing : object {
    [ExtensionAttribute]
public static object ToRawObject(ConstantHandle constantHandle, MetadataReader metadataReader);
    [ExtensionAttribute]
public static bool TryFindRawDefaultValueFromCustomAttributes(CustomAttributeHandleCollection handles, EcmaModule module, Object& rawDefaultValue);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaDefinitionType : RoDefinitionType {
    private EcmaModule _module;
    private TypeDefinitionHandle _handle;
    private RoType[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGenericParameters;
    [DebuggerBrowsableAttribute("0")]
private TypeDefinition _neverAccessThisExceptThroughTypeDefinitionProperty;
    public int MetadataToken { get; }
    public bool IsGenericTypeDefinition { get; }
    private MetadataLoadContext Loader { get; }
    private MetadataReader Reader { get; }
    [IsReadOnlyAttribute]
private TypeDefinition& modreq(System.Runtime.InteropServices.InAttribute) TypeDefinition { get; }
    internal EcmaDefinitionType(TypeDefinitionHandle handle, EcmaModule module);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeConstructors>d__0")]
internal sealed virtual IEnumerable`1<ConstructorInfo> SpecializeConstructors(NameFilter filter, RoInstantiationProviderType declaringType);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeMethods>d__1")]
internal sealed virtual IEnumerable`1<MethodInfo> SpecializeMethods(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeEvents>d__2")]
internal sealed virtual IEnumerable`1<EventInfo> SpecializeEvents(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeFields>d__3")]
internal sealed virtual IEnumerable`1<FieldInfo> SpecializeFields(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeProperties>d__4")]
internal sealed virtual IEnumerable`1<PropertyInfo> SpecializeProperties(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<GetNestedTypesCore>d__5")]
internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
    internal sealed virtual RoDefinitionType GetNestedTypeCore(ReadOnlySpan`1<byte> utf8Name);
    internal sealed virtual RoModule GetRoModule();
    internal EcmaModule GetEcmaModule();
    protected sealed virtual RoType ComputeDeclaringType();
    protected sealed virtual string ComputeName();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    internal sealed virtual RoType SpecializeBaseType(RoType[] instantiation);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.EcmaDefinitionType/<SpecializeInterfaces>d__17")]
internal sealed virtual IEnumerable`1<RoType> SpecializeInterfaces(RoType[] instantiation);
    protected sealed virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool get_IsGenericTypeDefinition();
    internal sealed virtual int GetGenericParameterCount();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    private RoType[] ComputeGenericTypeParameters();
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    protected sealed virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    internal sealed virtual bool IsTypeNameEqual(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    private MetadataLoadContext get_Loader();
    private MetadataReader get_Reader();
    private TypeDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_TypeDefinition();
}
internal class System.Reflection.TypeLoading.Ecma.EcmaEvent : RoEvent {
    private EcmaModule _module;
    private EventDefinitionHandle _handle;
    [DebuggerBrowsableAttribute("0")]
private EventDefinition _neverAccessThisExceptThroughEventDefinitionProperty;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private EventDefinition& modreq(System.Runtime.InteropServices.InAttribute) EventDefinition { get; }
    internal EcmaEvent(RoInstantiationProviderType declaringType, EventDefinitionHandle handle, Type reflectedType);
    internal sealed virtual RoModule GetRoModule();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected sealed virtual string ComputeName();
    protected sealed virtual EventAttributes ComputeAttributes();
    protected sealed virtual Type ComputeEventHandlerType();
    public sealed virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public sealed virtual string ToString();
    protected sealed virtual RoMethod ComputeEventAddMethod();
    protected sealed virtual RoMethod ComputeEventRemoveMethod();
    protected sealed virtual RoMethod ComputeEventRaiseMethod();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private EventDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_EventDefinition();
}
internal class System.Reflection.TypeLoading.Ecma.EcmaFatMethodParameter : RoFatMethodParameter {
    private EcmaModule _module;
    private ParameterHandle _handle;
    [DebuggerBrowsableAttribute("0")]
private Parameter _neverAccessThisExceptThroughParameterProperty;
    public int MetadataToken { get; }
    public bool HasDefaultValue { get; }
    public object RawDefaultValue { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private Parameter& modreq(System.Runtime.InteropServices.InAttribute) Parameter { get; }
    internal EcmaFatMethodParameter(IRoMethodBase roMethodBase, int position, Type parameterType, ParameterHandle handle);
    public sealed virtual int get_MetadataToken();
    protected sealed virtual string ComputeName();
    protected sealed virtual ParameterAttributes ComputeAttributes();
    protected sealed virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object get_RawDefaultValue();
    private bool TryGetRawDefaultValue(Object& rawDefaultValue);
    protected sealed virtual MarshalAsAttribute ComputeMarshalAsAttribute();
    private EcmaModule GetEcmaModule();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private Parameter& modreq(System.Runtime.InteropServices.InAttribute) get_Parameter();
}
internal class System.Reflection.TypeLoading.Ecma.EcmaField : RoField {
    private EcmaModule _module;
    private FieldDefinitionHandle _handle;
    [DebuggerBrowsableAttribute("0")]
private FieldDefinition _neverAccessThisExceptThroughFieldDefinitionProperty;
    public int MetadataToken { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private FieldDefinition& modreq(System.Runtime.InteropServices.InAttribute) FieldDefinition { get; }
    internal EcmaField(RoInstantiationProviderType declaringType, FieldDefinitionHandle handle, Type reflectedType);
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    protected sealed virtual int GetExplicitFieldOffset();
    protected sealed virtual MarshalAsAttribute ComputeMarshalAsAttribute();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected sealed virtual string ComputeName();
    protected sealed virtual FieldAttributes ComputeAttributes();
    protected sealed virtual Type ComputeFieldType();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool isRequired);
    protected sealed virtual object ComputeRawConstantValue();
    public sealed virtual string ToString();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private FieldDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_FieldDefinition();
}
internal class System.Reflection.TypeLoading.Ecma.EcmaGenericMethodParameterType : EcmaGenericParameterType {
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDeclaringMethod;
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    protected TypeContext TypeContext { get; }
    internal EcmaGenericMethodParameterType(GenericParameterHandle handle, EcmaModule module);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    protected sealed virtual RoType ComputeDeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    private RoMethod GetRoDeclaringMethod();
    private RoMethod ComputeDeclaringMethod();
    protected sealed virtual TypeContext get_TypeContext();
}
internal abstract class System.Reflection.TypeLoading.Ecma.EcmaGenericParameterType : RoGenericParameterType {
    private EcmaModule _ecmaModule;
    [CompilerGeneratedAttribute]
private GenericParameterHandle <Handle>k__BackingField;
    [DebuggerBrowsableAttribute("0")]
private GenericParameter _neverAccessThisExceptThroughGenericParameterProperty;
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public MethodBase DeclaringMethod { get; }
    internal GenericParameterHandle Handle { get; }
    internal MetadataReader Reader { get; }
    protected TypeContext TypeContext { get; }
    [IsReadOnlyAttribute]
protected GenericParameter& modreq(System.Runtime.InteropServices.InAttribute) GenericParameter { get; }
    internal EcmaGenericParameterType(GenericParameterHandle handle, EcmaModule module);
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual int ComputePosition();
    protected sealed virtual string ComputeName();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual int get_MetadataToken();
    protected sealed virtual RoType[] ComputeGenericParameterConstraints();
    protected abstract virtual RoType ComputeDeclaringType();
    public abstract virtual MethodBase get_DeclaringMethod();
    [CompilerGeneratedAttribute]
internal GenericParameterHandle get_Handle();
    internal EcmaModule GetEcmaModule();
    internal MetadataReader get_Reader();
    protected abstract virtual TypeContext get_TypeContext();
    protected GenericParameter& modreq(System.Runtime.InteropServices.InAttribute) get_GenericParameter();
}
internal class System.Reflection.TypeLoading.Ecma.EcmaGenericTypeParameterType : EcmaGenericParameterType {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public MethodBase DeclaringMethod { get; }
    protected TypeContext TypeContext { get; }
    internal EcmaGenericTypeParameterType(GenericParameterHandle handle, EcmaModule module);
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    protected sealed virtual RoType ComputeDeclaringType();
    public sealed virtual MethodBase get_DeclaringMethod();
    protected sealed virtual TypeContext get_TypeContext();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.EcmaHelpers : object {
    [ExtensionAttribute]
public static RoAssemblyName ToRoAssemblyName(AssemblyReferenceHandle h, MetadataReader reader);
    [ExtensionAttribute]
public static CoreType ToCoreType(PrimitiveTypeCode typeCode);
    [ExtensionAttribute]
public static PrimitiveTypeCode GetEnumUnderlyingPrimitiveTypeCode(Type enumType, MetadataLoadContext loader);
    [ExtensionAttribute]
public static AssemblyHashAlgorithm ToConfigurationAssemblyHashAlgorithm(AssemblyHashAlgorithm srmHash);
    [ExtensionAttribute]
public static ExceptionHandlingClauseOptions ToExceptionHandlingClauseOptions(ExceptionRegionKind kind);
    [ExtensionAttribute]
public static AssemblyNameFlags ToAssemblyNameFlags(AssemblyFlags flags);
    [ExtensionAttribute]
public static bool IsConstructor(MethodDefinition& method, MetadataReader reader);
    [ExtensionAttribute]
public static ReadOnlySpan`1<byte> AsReadOnlySpan(StringHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static RoMethod ToMethodOrNull(MethodDefinitionHandle handle, RoInstantiationProviderType declaringType, Type reflectedType);
    [ExtensionAttribute]
public static RoMethod ToMethod(MethodDefinitionHandle handle, RoInstantiationProviderType declaringType, Type reflectedType);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaMethodBody : RoMethodBody {
    private IRoMethodBase _roMethodBase;
    [DebuggerBrowsableAttribute("0")]
private MethodBodyBlock _neverAccessThisExceptThroughBlockProperty;
    public bool InitLocals { get; }
    public int MaxStackSize { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    private TypeContext TypeContext { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private MethodBodyBlock& modreq(System.Runtime.InteropServices.InAttribute) Block { get; }
    internal EcmaMethodBody(IRoMethodBase roMethodBase, MethodBodyBlock methodBodyBlock);
    public sealed virtual bool get_InitLocals();
    public sealed virtual int get_MaxStackSize();
    public sealed virtual int get_LocalSignatureMetadataToken();
    protected sealed virtual Byte[] ComputeIL();
    public sealed virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public sealed virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
    private TypeContext get_TypeContext();
    private EcmaModule GetEcmaModule();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private MethodBodyBlock& modreq(System.Runtime.InteropServices.InAttribute) get_Block();
}
[IsReadOnlyAttribute]
internal class System.Reflection.TypeLoading.Ecma.EcmaMethodDecoder : ValueType {
    private MethodDefinitionHandle _handle;
    private EcmaModule _module;
    [DebuggerBrowsableAttribute("0")]
private MethodDefinition _neverAccessThisExceptThroughMethodDefinitionProperty;
    public int MetadataToken { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    private MethodDefinition MethodDefinition { get; }
    internal EcmaMethodDecoder(MethodDefinitionHandle handle, EcmaModule module);
    public sealed virtual RoModule GetRoModule();
    public sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual IEnumerable`1<CustomAttributeData> ComputeTrueCustomAttributes();
    public sealed virtual int ComputeGenericParameterCount();
    public sealed virtual RoType[] ComputeGenericArgumentsOrParameters();
    public sealed virtual MethodAttributes ComputeAttributes();
    public sealed virtual CallingConventions ComputeCallingConvention();
    public sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    public sealed virtual MethodSig`1<RoParameter> SpecializeMethodSig(IRoMethodBase roMethodBase);
    public MethodSig`1<RoType> SpecializeCustomModifiers(TypeContext& typeContext);
    public MethodSig`1<string> SpecializeMethodSigStrings(TypeContext& typeContext);
    public sealed virtual MethodBody SpecializeMethodBody(IRoMethodBase owner);
    public sealed virtual DllImportAttribute ComputeDllImportAttribute();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private MethodDefinition get_MethodDefinition();
    private sealed virtual override MethodSig`1<RoType> System.Reflection.TypeLoading.IMethodDecoder.SpecializeCustomModifiers(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    private sealed virtual override MethodSig`1<string> System.Reflection.TypeLoading.IMethodDecoder.SpecializeMethodSigStrings(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaModifiedTypeProvider : EcmaWrappedTypeProvider {
    internal EcmaModifiedTypeProvider(EcmaModule module);
    public sealed virtual RoType GetModifiedType(RoType modifier, RoType unmodifiedType, bool isRequired);
    public sealed virtual RoType GetPinnedType(RoType elementType);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaModule : RoModule {
    private static int ModuleTypeToken;
    private EcmaAssembly _assembly;
    private GuardedPEReader _guardedPEReader;
    [DebuggerBrowsableAttribute("0")]
private ModuleDefinition _neverAccessThisExceptThroughModuleDefinitionProperty;
    private MetadataTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyTypeDefTable;
    private bool _typeDefTableFullyFilled;
    private MetadataTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyTypeRefTable;
    private MetadataTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGenericParamTable;
    private MetadataTable`2 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAssemblyRefTable;
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    public string ScopeName { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal PEReader PEReader { get; }
    internal MetadataReader Reader { get; }
    [IsReadOnlyAttribute]
private ModuleDefinition& modreq(System.Runtime.InteropServices.InAttribute) ModuleDefinition { get; }
    internal MetadataTable`2<EcmaDefinitionType, EcmaModule> TypeDefTable { get; }
    internal MetadataTable`2<RoDefinitionType, EcmaModule> TypeRefTable { get; }
    internal MetadataTable`2<EcmaGenericParameterType, EcmaModule> GenericParamTable { get; }
    internal MetadataTable`2<RoAssembly, EcmaModule> AssemblyRefTable { get; }
    internal EcmaModule(EcmaAssembly assembly, string fullyQualifiedName, PEReader peReader, MetadataReader reader);
    internal sealed virtual RoAssembly GetRoAssembly();
    internal EcmaAssembly GetEcmaAssembly();
    public sealed virtual bool IsResource();
    public sealed virtual int get_MDStreamVersion();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Guid get_ModuleVersionId();
    public sealed virtual string get_ScopeName();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal MethodInfo ComputeEntryPoint(bool fileRefEntryPointAllowed);
    public sealed virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    private RoType GetModuleType();
    public sealed virtual Type[] GetTypes();
    internal sealed virtual IEnumerable`1<RoType> GetDefinedRoTypes();
    internal PEReader get_PEReader();
    internal MetadataReader get_Reader();
    private ModuleDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_ModuleDefinition();
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3002:RequiresAssemblyFiles on FullyQualifiedName")]
protected sealed virtual RoDefinitionType GetTypeCoreNoCache(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, Exception& e);
    internal InternalManifestResourceInfo GetInternalManifestResourceInfo(string resourceName);
    internal MetadataTable`2<EcmaDefinitionType, EcmaModule> get_TypeDefTable();
    private void EnsureTypeDefTableFullyFilled();
    internal MetadataTable`2<RoDefinitionType, EcmaModule> get_TypeRefTable();
    internal MetadataTable`2<EcmaGenericParameterType, EcmaModule> get_GenericParamTable();
    internal MetadataTable`2<RoAssembly, EcmaModule> get_AssemblyRefTable();
    private MetadataTable`2<T, EcmaModule> CreateTable(TableIndex tableIndex);
    public sealed virtual RoType GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetTypeFromSpecification(MetadataReader reader, TypeContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetSZArrayType(RoType elementType);
    public sealed virtual RoType GetArrayType(RoType elementType, ArrayShape shape);
    public sealed virtual RoType GetByReferenceType(RoType elementType);
    public sealed virtual RoType GetPointerType(RoType elementType);
    public sealed virtual RoType GetGenericInstantiation(RoType genericType, ImmutableArray`1<RoType> typeArguments);
    public sealed virtual RoType GetGenericTypeParameter(TypeContext genericContext, int index);
    public sealed virtual RoType GetGenericMethodParameter(TypeContext genericContext, int index);
    public sealed virtual RoType GetFunctionPointerType(MethodSignature`1<RoType> signature);
    public sealed virtual RoType GetModifiedType(RoType modifier, RoType unmodifiedType, bool isRequired);
    public sealed virtual RoType GetPinnedType(RoType elementType);
    public sealed virtual RoType GetPrimitiveType(PrimitiveTypeCode typeCode);
    public sealed virtual RoType GetSystemType();
    public sealed virtual bool IsSystemType(RoType type);
    public sealed virtual PrimitiveTypeCode GetUnderlyingEnumType(RoType type);
    public sealed virtual RoType GetTypeFromSerializedName(string name);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaPinnedTypeProvider : EcmaWrappedTypeProvider {
    internal EcmaPinnedTypeProvider(EcmaModule module);
    public sealed virtual RoType GetModifiedType(RoType modifier, RoType unmodifiedType, bool isRequired);
    public sealed virtual RoType GetPinnedType(RoType elementType);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaProperty : RoProperty {
    private EcmaModule _module;
    private PropertyDefinitionHandle _handle;
    [DebuggerBrowsableAttribute("0")]
private PropertyDefinition _neverAccessThisExceptThroughPropertyDefinitionProperty;
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    private MetadataReader Reader { get; }
    private MetadataLoadContext Loader { get; }
    [IsReadOnlyAttribute]
private PropertyDefinition& modreq(System.Runtime.InteropServices.InAttribute) PropertyDefinition { get; }
    internal EcmaProperty(RoInstantiationProviderType declaringType, PropertyDefinitionHandle handle, Type reflectedType);
    internal sealed virtual RoModule GetRoModule();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected sealed virtual string ComputeName();
    protected sealed virtual PropertyAttributes ComputeAttributes();
    protected sealed virtual Type ComputePropertyType();
    protected sealed virtual object ComputeRawConstantValue();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    private Type[] GetCustomModifiers(bool isRequired);
    public sealed virtual string ToString();
    protected sealed virtual RoMethod ComputeGetterMethod();
    protected sealed virtual RoMethod ComputeSetterMethod();
    private MetadataReader get_Reader();
    private MetadataLoadContext get_Loader();
    private PropertyDefinition& modreq(System.Runtime.InteropServices.InAttribute) get_PropertyDefinition();
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.EcmaResolver : object {
    private static Func`3<EntityHandle, EcmaModule, EcmaDefinitionType> s_resolveTypeDef;
    private static Func`3<EntityHandle, EcmaModule, RoDefinitionType> s_resolveTypeRef;
    private static Func`3<EntityHandle, EcmaModule, EcmaGenericParameterType> s_resolveGenericParam;
    private static Func`3<EntityHandle, EcmaModule, RoAssembly> s_resolveAssembly;
    private static EcmaResolver();
    [ExtensionAttribute]
public static RoType ResolveTypeDefRefOrSpec(EntityHandle handle, EcmaModule module, TypeContext& typeContext);
    [ExtensionAttribute]
public static EcmaDefinitionType ResolveTypeDef(TypeDefinitionHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static RoDefinitionType ResolveTypeRef(TypeReferenceHandle handle, EcmaModule module);
    private static RoDefinitionType ComputeTypeRefResolution(TypeReferenceHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static RoType ResolveTypeSpec(TypeSpecificationHandle handle, EcmaModule module, TypeContext& typeContext);
    [ExtensionAttribute]
public static EcmaGenericParameterType ResolveGenericParameter(GenericParameterHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static RoAssembly ResolveAssembly(AssemblyReferenceHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static RoAssembly TryResolveAssembly(AssemblyReferenceHandle handle, EcmaModule module, Exception& e);
    [ExtensionAttribute]
public static RoAssembly ResolveToAssemblyOrExceptionAssembly(AssemblyReferenceHandle handle, EcmaModule module);
    [ExtensionAttribute]
public static T ResolveMethod(MethodDefinitionHandle handle, EcmaModule module, TypeContext& typeContext);
    [ExtensionAttribute]
private static RoInstantiationProviderType ResolveAndSpecializeType(TypeDefinitionHandle handle, EcmaModule module, TypeContext& typeContext);
}
internal class System.Reflection.TypeLoading.Ecma.EcmaSignatureTypeProviderForToString : object {
    public static EcmaSignatureTypeProviderForToString Instance;
    private static EcmaSignatureTypeProviderForToString();
    public sealed virtual string GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual string GetTypeFromSpecification(MetadataReader reader, TypeContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual string GetSZArrayType(string elementType);
    public sealed virtual string GetArrayType(string elementType, ArrayShape shape);
    public sealed virtual string GetByReferenceType(string elementType);
    public sealed virtual string GetPointerType(string elementType);
    public sealed virtual string GetGenericInstantiation(string genericType, ImmutableArray`1<string> typeArguments);
    public sealed virtual string GetGenericTypeParameter(TypeContext genericContext, int index);
    public sealed virtual string GetGenericMethodParameter(TypeContext genericContext, int index);
    public sealed virtual string GetFunctionPointerType(MethodSignature`1<string> signature);
    public sealed virtual string GetModifiedType(string modifier, string unmodifiedType, bool isRequired);
    public sealed virtual string GetPinnedType(string elementType);
    public sealed virtual string GetPrimitiveType(PrimitiveTypeCode typeCode);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.EcmaToStringHelpers : object {
    [ExtensionAttribute]
public static string ToTypeString(EntityHandle handle, TypeContext& typeContext, MetadataReader reader);
    [ExtensionAttribute]
public static string ToTypeString(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string ToTypeString(TypeReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string ToTypeString(TypeSpecificationHandle handle, MetadataReader reader, TypeContext& typeContext);
}
internal abstract class System.Reflection.TypeLoading.Ecma.EcmaWrappedTypeProvider : object {
    private EcmaModule _module;
    private ISignatureTypeProvider`2<RoType, TypeContext> _typeProvider;
    protected EcmaWrappedTypeProvider(EcmaModule module);
    public sealed virtual RoType GetTypeFromDefinition(MetadataReader reader, TypeDefinitionHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetTypeFromReference(MetadataReader reader, TypeReferenceHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetTypeFromSpecification(MetadataReader reader, TypeContext genericContext, TypeSpecificationHandle handle, byte rawTypeKind);
    public sealed virtual RoType GetSZArrayType(RoType elementType);
    public sealed virtual RoType GetArrayType(RoType elementType, ArrayShape shape);
    public sealed virtual RoType GetByReferenceType(RoType elementType);
    public sealed virtual RoType GetPointerType(RoType elementType);
    public sealed virtual RoType GetGenericInstantiation(RoType genericType, ImmutableArray`1<RoType> typeArguments);
    public sealed virtual RoType GetGenericTypeParameter(TypeContext genericContext, int index);
    public sealed virtual RoType GetGenericMethodParameter(TypeContext genericContext, int index);
    public sealed virtual RoType GetFunctionPointerType(MethodSignature`1<RoType> signature);
    public abstract virtual RoType GetModifiedType(RoType modifier, RoType unmodifiedType, bool isRequired);
    public abstract virtual RoType GetPinnedType(RoType elementType);
    public sealed virtual RoType GetPrimitiveType(PrimitiveTypeCode typeCode);
}
[IsReadOnlyAttribute]
internal class System.Reflection.TypeLoading.Ecma.GuardedPEReader : ValueType {
    private MetadataLoadContext _loader;
    [DebuggerBrowsableAttribute("0")]
private PEReader _peReader;
    [DebuggerBrowsableAttribute("0")]
private MetadataReader _reader;
    public PEReader PEReader { get; }
    public MetadataReader Reader { get; }
    public GuardedPEReader(MetadataLoadContext loader, PEReader peReader, MetadataReader reader);
    public PEReader get_PEReader();
    public MetadataReader get_Reader();
}
internal class System.Reflection.TypeLoading.Ecma.InternalManifestResourceInfo : ValueType {
    public bool Found;
    public string FileName;
    public Assembly ReferencedAssembly;
    public Byte* PointerToResource;
    public UInt32 SizeOfResource;
    public ResourceLocation ResourceLocation;
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Ecma.MetadataExtensions : object {
    [ExtensionAttribute]
public static AssemblyFile GetAssemblyFile(AssemblyFileHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static AssemblyReference GetAssemblyReference(AssemblyReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Byte[] GetBlobBytes(BlobHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ImmutableArray`1<byte> GetBlobContent(BlobHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static BlobReader GetBlobReader(BlobHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static BlobReader GetBlobReader(StringHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Constant GetConstant(ConstantHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static CustomAttribute GetCustomAttribute(CustomAttributeHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static CustomAttributeHandleCollection GetCustomAttributes(EntityHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static CustomDebugInformation GetCustomDebugInformation(CustomDebugInformationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static CustomDebugInformationHandleCollection GetCustomDebugInformation(EntityHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static DeclarativeSecurityAttribute GetDeclarativeSecurityAttribute(DeclarativeSecurityAttributeHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Document GetDocument(DocumentHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static EventDefinition GetEventDefinition(EventDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ExportedType GetExportedType(ExportedTypeHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static FieldDefinition GetFieldDefinition(FieldDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static GenericParameter GetGenericParameter(GenericParameterHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static GenericParameterConstraint GetGenericParameterConstraint(GenericParameterConstraintHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Guid GetGuid(GuidHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ImportScope GetImportScope(ImportScopeHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static InterfaceImplementation GetInterfaceImplementation(InterfaceImplementationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static LocalConstant GetLocalConstant(LocalConstantHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static LocalScope GetLocalScope(LocalScopeHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static LocalScopeHandleCollection GetLocalScopes(MethodDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static LocalScopeHandleCollection GetLocalScopes(MethodDebugInformationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static LocalVariable GetLocalVariable(LocalVariableHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ManifestResource GetManifestResource(ManifestResourceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MemberReference GetMemberReference(MemberReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodDebugInformation GetMethodDebugInformation(MethodDebugInformationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodDebugInformation GetMethodDebugInformation(MethodDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodDefinition GetMethodDefinition(MethodDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodImplementation GetMethodImplementation(MethodImplementationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static MethodSpecification GetMethodSpecification(MethodSpecificationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static ModuleReference GetModuleReference(ModuleReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static NamespaceDefinition GetNamespaceDefinition(NamespaceDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static Parameter GetParameter(ParameterHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static PropertyDefinition GetPropertyDefinition(PropertyDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static StandaloneSignature GetStandaloneSignature(StandaloneSignatureHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetString(StringHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetString(NamespaceDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetString(DocumentNameBlobHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static TypeDefinition GetTypeDefinition(TypeDefinitionHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static TypeReference GetTypeReference(TypeReferenceHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static TypeSpecification GetTypeSpecification(TypeSpecificationHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static string GetUserString(UserStringHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static int GetToken(Handle handle);
    [ExtensionAttribute]
public static int GetToken(EntityHandle handle);
    [ExtensionAttribute]
public static int GetToken(TypeDefinitionHandle handle);
    [ExtensionAttribute]
public static int GetToken(TypeReferenceHandle handle);
    [ExtensionAttribute]
public static int GetToken(TypeSpecificationHandle handle);
    [ExtensionAttribute]
public static int GetToken(GenericParameterHandle handle);
    [ExtensionAttribute]
public static int GetToken(GenericParameterConstraintHandle handle);
    [ExtensionAttribute]
public static int GetToken(FieldDefinitionHandle handle);
    [ExtensionAttribute]
public static int GetToken(EventDefinitionHandle handle);
    [ExtensionAttribute]
public static int GetToken(MethodDefinitionHandle handle);
    [ExtensionAttribute]
public static int GetToken(PropertyDefinitionHandle handle);
    [ExtensionAttribute]
public static int GetToken(ParameterHandle handle);
    [ExtensionAttribute]
public static int GetToken(StandaloneSignatureHandle handle);
    [ExtensionAttribute]
public static int GetToken(AssemblyFileHandle handle);
    [ExtensionAttribute]
public static string GetStringOrNull(StringHandle handle, MetadataReader reader);
    [ExtensionAttribute]
public static bool Equals(StringHandle handle, string value, MetadataReader reader);
    [ExtensionAttribute]
public static bool Equals(StringHandle handle, ReadOnlySpan`1<byte> utf8, MetadataReader reader);
    [ExtensionAttribute]
public static Handle ToHandle(int token);
    [ExtensionAttribute]
public static TypeDefinitionHandle ToTypeDefinitionHandle(int token);
    [ExtensionAttribute]
public static TypeReferenceHandle ToTypeReferenceHandle(int token);
    [ExtensionAttribute]
public static TypeSpecificationHandle ToTypeSpecificationHandle(int token);
}
internal class System.Reflection.TypeLoading.Ecma.MetadataTable`2 : object {
    private T[] _table;
    [CompilerGeneratedAttribute]
private int <Count>k__BackingField;
    public int Count { get; }
    public MetadataTable`2(int count);
    public T GetOrAdd(EntityHandle handle, C context, Func`3<EntityHandle, C, T> factory);
    [CompilerGeneratedAttribute]
public int get_Count();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.Ecma.MetadataTable`2/<EnumerateValues>d__6")]
public IEnumerable`1<T> EnumerateValues(int skip);
    public TOut[] ToArray(int skip);
}
internal class System.Reflection.TypeLoading.GetTypeCoreCache : object {
    private Container modreq(System.Runtime.CompilerServices.IsVolatile) _container;
    private object _lock;
    public bool TryGet(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, int hashCode, RoDefinitionType& type);
    public RoDefinitionType GetOrAdd(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, int hashCode, RoDefinitionType type);
    public static int ComputeHashCode(ReadOnlySpan`1<byte> name);
}
internal static class System.Reflection.TypeLoading.HashHelpers : object {
    public static int HashPrime;
    public static Int32[] primes;
    private static HashHelpers();
    public static bool IsPrime(int candidate);
    public static int GetPrime(int min);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.Helpers : object {
    private static Char[] s_charsToEscape;
    private static Helpers();
    [ExtensionAttribute]
public static T[] CloneArray(T[] original);
    [ExtensionAttribute]
public static ReadOnlyCollection`1<T> ToReadOnlyCollection(IEnumerable`1<T> enumeration);
    [ExtensionAttribute]
public static int GetTokenRowNumber(int token);
    [ExtensionAttribute]
public static RoMethod FilterInheritedAccessor(RoMethod accessor);
    [ExtensionAttribute]
public static MethodInfo FilterAccessor(MethodInfo accessor, bool nonPublic);
    public static string ComputeArraySuffix(int rank, bool multiDim);
    [ExtensionAttribute]
public static string EscapeTypeNameIdentifier(string identifier);
    [ExtensionAttribute]
public static bool TypeNameContainsTypeParserMetacharacters(string identifier);
    [ExtensionAttribute]
public static bool NeedsEscapingInTypeName(char c);
    [ExtensionAttribute]
public static string UnescapeTypeNameIdentifier(string identifier);
    [ExtensionAttribute]
public static Version AdjustForUnspecifiedVersionComponents(Version v);
    [ExtensionAttribute]
public static Byte[] ComputePublicKeyToken(Byte[] pkt);
    public static AssemblyNameFlags ConvertAssemblyFlagsToAssemblyNameFlags(AssemblyFlags assemblyFlags);
    [ExtensionAttribute]
public static void SplitTypeName(string fullName, String& ns, String& name);
    [ExtensionAttribute]
public static string AppendTypeName(string ns, string name);
    [ExtensionAttribute]
public static string ToString(IRoMethodBase roMethodBase, MethodSig`1<string> methodSigStrings);
    [ExtensionAttribute]
public static bool HasSameMetadataDefinitionAsCore(M thisMember, MemberInfo other);
    public static RoType LoadTypeFromAssemblyQualifiedName(string name, RoAssembly defaultAssembly, bool ignoreCase, bool throwOnError);
    [ExtensionAttribute]
public static Type[] ExtractCustomModifiers(RoType type, bool isRequired);
    [ExtensionAttribute]
public static RoType SkipTypeWrappers(RoType type);
    [ExtensionAttribute]
public static bool IsVisibleOutsideAssembly(Type type);
    [ExtensionAttribute]
public static RoAssemblyName ToRoAssemblyName(AssemblyName assemblyName);
    [ExtensionAttribute]
public static Byte[] ToUtf8(string s);
    [ExtensionAttribute]
public static string ToUtf16(ReadOnlySpan`1<byte> utf8);
    [ExtensionAttribute]
public static string GetDisposedString(MetadataLoadContext loader);
    [ExtensionAttribute]
public static TypeContext ToTypeContext(RoType[] instantiation);
}
internal interface System.Reflection.TypeLoading.IMethodDecoder {
    public int MetadataToken { get; }
    public abstract virtual RoModule GetRoModule();
    public abstract virtual string ComputeName();
    public abstract virtual MethodAttributes ComputeAttributes();
    public abstract virtual CallingConventions ComputeCallingConvention();
    public abstract virtual MethodImplAttributes ComputeMethodImplementationFlags();
    public abstract virtual int get_MetadataToken();
    public abstract virtual int ComputeGenericParameterCount();
    public abstract virtual RoType[] ComputeGenericArgumentsOrParameters();
    public abstract virtual IEnumerable`1<CustomAttributeData> ComputeTrueCustomAttributes();
    public abstract virtual DllImportAttribute ComputeDllImportAttribute();
    public abstract virtual MethodSig`1<RoParameter> SpecializeMethodSig(IRoMethodBase member);
    public abstract virtual MethodSig`1<RoType> SpecializeCustomModifiers(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    public abstract virtual MethodBody SpecializeMethodBody(IRoMethodBase owner);
    public abstract virtual MethodSig`1<string> SpecializeMethodSigStrings(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
}
internal interface System.Reflection.TypeLoading.IRoMethodBase {
    public MethodBase MethodBase { get; }
    public MetadataLoadContext Loader { get; }
    public TypeContext TypeContext { get; }
    public abstract virtual MethodBase get_MethodBase();
    public abstract virtual MetadataLoadContext get_Loader();
    public abstract virtual TypeContext get_TypeContext();
    public abstract virtual Type[] GetCustomModifiers(int position, bool isRequired);
    public abstract virtual string GetMethodSigString(int position);
}
internal abstract class System.Reflection.TypeLoading.LeveledAssembly : Assembly {
    public abstract virtual Type[] GetForwardedTypes();
}
internal abstract class System.Reflection.TypeLoading.LeveledConstructorInfo : ConstructorInfo {
    public bool IsConstructedGenericMethod { get; }
    public abstract virtual bool get_IsConstructedGenericMethod();
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
internal abstract class System.Reflection.TypeLoading.LeveledCustomAttributeData : CustomAttributeData {
    public Type AttributeType { get; }
    public abstract virtual Type get_AttributeType();
}
internal abstract class System.Reflection.TypeLoading.LeveledEventInfo : EventInfo {
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
internal abstract class System.Reflection.TypeLoading.LeveledFieldInfo : FieldInfo {
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
internal abstract class System.Reflection.TypeLoading.LeveledMethodInfo : MethodInfo {
    public bool IsConstructedGenericMethod { get; }
    public abstract virtual bool get_IsConstructedGenericMethod();
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
internal abstract class System.Reflection.TypeLoading.LeveledPropertyInfo : PropertyInfo {
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
internal abstract class System.Reflection.TypeLoading.LeveledTypeInfo : TypeDelegator {
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsTypeDefinition { get; }
    public bool IsByRefLike { get; }
    public bool IsSignatureType { get; }
    public virtual EventInfo[] GetEvents();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    public abstract virtual bool get_IsTypeDefinition();
    public abstract virtual bool get_IsByRefLike();
    public virtual bool get_IsSignatureType();
    protected abstract virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public abstract virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
}
[DefaultMemberAttribute("Item")]
internal class System.Reflection.TypeLoading.MethodSig`1 : object {
    [CompilerGeneratedAttribute]
private T <Return>k__BackingField;
    [CompilerGeneratedAttribute]
private T[] <Parameters>k__BackingField;
    public T Return { get; private set; }
    public T[] Parameters { get; }
    public T Item { get; public set; }
    public MethodSig`1(int parameterCount);
    [CompilerGeneratedAttribute]
public T get_Return();
    [CompilerGeneratedAttribute]
private void set_Return(T value);
    [CompilerGeneratedAttribute]
public T[] get_Parameters();
    public T get_Item(int position);
    public void set_Item(int position, T value);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.NetCoreApiEmulators : object {
    [ExtensionAttribute]
public static bool IsSignatureType(Type type);
    [ExtensionAttribute]
public static bool IsSZArray(Type type);
    [ExtensionAttribute]
public static bool IsVariableBoundArray(Type type);
    [ExtensionAttribute]
public static bool IsGenericMethodParameter(Type type);
    [ExtensionAttribute]
public static Type MakeSignatureGenericType(Type genericTypeDefinition, Type[] typeArguments);
}
internal class System.Reflection.TypeLoading.RoArrayType : RoHasElementType {
    private bool _multiDim;
    private int _rank;
    private static CoreType[] s_typesImplementedByArray;
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal RoArrayType(RoType elementType, bool multiDim, int rank);
    private static RoArrayType();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    protected sealed virtual string get_Suffix();
    public sealed virtual int GetArrayRank();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoArrayType/<ComputeDirectlyImplementedInterfaces>d__14")]
protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoArrayType/<GetConstructorsCore>d__17")]
internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoArrayType/<GetMethodsCore>d__18")]
internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
}
internal abstract class System.Reflection.TypeLoading.RoAssembly : LeveledAssembly {
    private RoModule[] _loadedModules;
    [CompilerGeneratedAttribute]
private bool <IsSingleModule>k__BackingField;
    private AssemblyNameData modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAssemblyNameData;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFullName;
    internal static string ThrowingMessageInRAF;
    private AssemblyNameData[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAssemblyReferences;
    [CompilerGeneratedAttribute]
private MetadataLoadContext <Loader>k__BackingField;
    public Module ManifestModule { get; }
    protected bool IsSingleModule { get; }
    public string FullName { get; }
    public string Location { get; }
    public string CodeBase { get; }
    public string EscapedCodeBase { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public IEnumerable`1<TypeInfo> DefinedTypes { get; }
    public IEnumerable`1<Type> ExportedTypes { get; }
    public bool ReflectionOnly { get; }
    public bool GlobalAssemblyCache { get; }
    public long HostContext { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public MethodInfo EntryPoint { get; }
    internal MetadataLoadContext Loader { get; }
    protected RoAssembly(MetadataLoadContext loader, int assemblyFileCount);
    public sealed virtual Module get_ManifestModule();
    internal abstract virtual RoModule GetRoManifestModule();
    [CompilerGeneratedAttribute]
protected bool get_IsSingleModule();
    public sealed virtual string ToString();
    public sealed virtual AssemblyName GetName(bool copiedName);
    internal AssemblyNameData GetAssemblyNameDataNoCopy();
    protected abstract virtual AssemblyNameData ComputeNameData();
    public sealed virtual string get_FullName();
    public abstract virtual string get_Location();
    public sealed virtual string get_CodeBase();
    public sealed virtual string get_EscapedCodeBase();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Type[] GetTypes();
    public sealed virtual IEnumerable`1<TypeInfo> get_DefinedTypes();
    private IEnumerable`1<RoType> GetDefinedRoTypes();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoAssembly/<MultiModuleGetDefinedRoTypes>d__30")]
private IEnumerable`1<RoType> MultiModuleGetDefinedRoTypes();
    public sealed virtual Type[] GetExportedTypes();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoAssembly/<get_ExportedTypes>d__33")]
public sealed virtual IEnumerable`1<Type> get_ExportedTypes();
    public sealed virtual Type GetType(string name, bool throwOnError, bool ignoreCase);
    internal RoDefinitionType GetTypeCore(string ns, string name, bool ignoreCase, Exception& e);
    internal RoDefinitionType GetTypeCore(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, bool ignoreCase, Exception& e);
    public sealed virtual AssemblyName[] GetReferencedAssemblies();
    private AssemblyNameData[] GetReferencedAssembliesNoCopy();
    protected abstract virtual AssemblyNameData[] ComputeAssemblyReferences();
    public sealed virtual bool get_ReflectionOnly();
    public sealed virtual bool get_GlobalAssemblyCache();
    public sealed virtual long get_HostContext();
    public abstract virtual string get_ImageRuntimeVersion();
    public abstract virtual bool get_IsDynamic();
    public abstract virtual MethodInfo get_EntryPoint();
    public abstract virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public abstract virtual String[] GetManifestResourceNames();
    public abstract virtual Stream GetManifestResourceStream(string name);
    public sealed virtual Stream GetManifestResourceStream(Type type, string name);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public sealed virtual Assembly GetSatelliteAssembly(CultureInfo culture);
    public sealed virtual Assembly GetSatelliteAssembly(CultureInfo culture, Version version);
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual object CreateInstance(string typeName, bool ignoreCase, BindingFlags bindingAttr, Binder binder, Object[] args, CultureInfo culture, Object[] activationAttributes);
    [CompilerGeneratedAttribute]
internal MetadataLoadContext get_Loader();
    public sealed virtual Type[] GetForwardedTypes();
    private static void AddPublicNestedTypes(Type type, List`1<Type> types);
    protected abstract virtual void IterateTypeForwards(TypeForwardHandler handler);
    public sealed virtual Module GetModule(string name);
    public sealed virtual Module[] GetModules(bool getResourceModules);
    public sealed virtual FileStream GetFile(string name);
    public sealed virtual FileStream[] GetFiles(bool getResourceModules);
    public sealed virtual Module[] GetLoadedModules(bool getResourceModules);
    [CompilerGeneratedAttribute]
public abstract virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    [CompilerGeneratedAttribute]
public abstract virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    internal RoModule GetRoModule(string name);
    private RoModule GetRoModule(AssemblyFileInfo& afi);
    internal RoModule[] ComputeRoModules(bool getResourceModules);
    public sealed virtual Module LoadModule(string moduleName, Byte[] rawModule, Byte[] rawSymbolStore);
    private bool TryGetAssemblyFileInfo(string name, bool includeManifestModule, AssemblyFileInfo& afi);
    protected abstract virtual RoModule LoadModule(string moduleName, bool containsMetadata);
    protected abstract virtual RoModule CreateModule(Stream peStream, bool containsMetadata);
    protected abstract virtual IEnumerable`1<AssemblyFileInfo> GetAssemblyFileInfosFromManifest(bool includeManifestModule, bool includeResourceModules);
}
internal class System.Reflection.TypeLoading.RoAssemblyName : object {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private Version <Version>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CultureName>k__BackingField;
    public Byte[] PublicKeyToken;
    [CompilerGeneratedAttribute]
private AssemblyNameFlags <Flags>k__BackingField;
    private static Version s_Version0000;
    public string Name { get; }
    public Version Version { get; }
    public string CultureName { get; }
    public AssemblyNameFlags Flags { get; }
    public string FullName { get; }
    public RoAssemblyName(string name, Version version, string cultureName, Byte[] publicKeyToken, AssemblyNameFlags flags);
    private static RoAssemblyName();
    [CompilerGeneratedAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
public Version get_Version();
    [CompilerGeneratedAttribute]
public string get_CultureName();
    [CompilerGeneratedAttribute]
public AssemblyNameFlags get_Flags();
    public string get_FullName();
    public sealed virtual bool Equals(RoAssemblyName other);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual string ToString();
    public AssemblyName ToAssemblyName();
}
internal class System.Reflection.TypeLoading.RoByRefType : RoHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal RoByRefType(RoType elementType);
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual int GetArrayRank();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual string get_Suffix();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
}
internal class System.Reflection.TypeLoading.RoConstructedGenericMethod : RoMethod {
    private RoDefinitionMethod _genericMethodDefinition;
    private RoType[] _genericMethodArguments;
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public TypeContext TypeContext { get; }
    internal RoConstructedGenericMethod(RoDefinitionMethod genericMethodDefinition, RoType[] genericMethodArguments);
    internal sealed virtual RoType GetRoDeclaringType();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    protected sealed virtual MethodAttributes ComputeAttributes();
    protected sealed virtual CallingConventions ComputeCallingConvention();
    protected sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    protected sealed virtual MethodSig`1<RoParameter> ComputeMethodSig();
    protected sealed virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual MethodBody GetMethodBody();
    protected sealed virtual RoType[] ComputeGenericArgumentsOrParameters();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    protected sealed virtual MethodSig`1<string> ComputeMethodSigStrings();
    public sealed virtual TypeContext get_TypeContext();
}
internal class System.Reflection.TypeLoading.RoConstructedGenericType : RoInstantiationProviderType {
    private RoDefinitionType _genericTypeDefinition;
    private RoType[] _genericTypeArguments;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    internal RoType[] Instantiation { get; }
    internal RoConstructedGenericType(RoDefinitionType genericTypeDefinition, RoType[] genericTypeArguments);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual string ComputeFullName();
    public sealed virtual string ToString();
    public sealed virtual MethodBase get_DeclaringMethod();
    protected sealed virtual RoType ComputeDeclaringType();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    public sealed virtual int get_MetadataToken();
    internal sealed virtual RoType GetRoElementType();
    public sealed virtual Type GetGenericTypeDefinition();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    protected internal sealed virtual RoType[] GetGenericArgumentsNoCopy();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Guid get_GUID();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    public sealed virtual int GetArrayRank();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual Type[] GetGenericParameterConstraints();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
    internal sealed virtual RoType[] get_Instantiation();
}
internal abstract class System.Reflection.TypeLoading.RoConstructor : LeveledConstructorInfo {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static MethodAttributes MethodAttributesSentinel;
    private MethodAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodAttributes;
    private static CallingConventions CallingConventionsSentinel;
    private CallingConventions modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCallingConventions;
    private static MethodImplAttributes MethodImplAttributesSentinel;
    private MethodImplAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodImplAttributes;
    private MethodSig`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodSig;
    private MethodSig`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCustomModifiers;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public bool ContainsGenericParameters { get; }
    private MethodSig`1<RoParameter> MethodSig { get; }
    private MethodSig`1<RoType> CustomModifiers { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    private MethodBase System.Reflection.TypeLoading.IRoMethodBase.MethodBase { get; }
    public MetadataLoadContext Loader { get; }
    public TypeContext TypeContext { get; }
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public sealed virtual Type get_DeclaringType();
    internal abstract virtual RoType GetRoDeclaringType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual MethodAttributes get_Attributes();
    protected abstract virtual MethodAttributes ComputeAttributes();
    public sealed virtual CallingConventions get_CallingConvention();
    protected abstract virtual CallingConventions ComputeCallingConvention();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    protected abstract virtual MethodImplAttributes ComputeMethodImplementationFlags();
    public sealed virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual MethodBody GetMethodBody();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual ParameterInfo[] GetParameters();
    internal RoParameter[] GetParametersNoCopy();
    private MethodSig`1<RoParameter> get_MethodSig();
    protected abstract virtual MethodSig`1<RoParameter> ComputeMethodSig();
    private MethodSig`1<RoType> get_CustomModifiers();
    protected abstract virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual string ToString();
    protected abstract virtual MethodSig`1<string> ComputeMethodSigStrings();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual object Invoke(BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    private sealed virtual override MethodBase System.Reflection.TypeLoading.IRoMethodBase.get_MethodBase();
    public sealed virtual MetadataLoadContext get_Loader();
    public abstract virtual TypeContext get_TypeContext();
    private sealed virtual override Type[] System.Reflection.TypeLoading.IRoMethodBase.GetCustomModifiers(int position, bool isRequired);
    private sealed virtual override string System.Reflection.TypeLoading.IRoMethodBase.GetMethodSigString(int position);
}
internal abstract class System.Reflection.TypeLoading.RoCustomAttributeData : LeveledCustomAttributeData {
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAttributeType;
    private ConstructorInfo modreq(System.Runtime.CompilerServices.IsVolatile) _lazyConstructorInfo;
    public Type AttributeType { get; }
    public ConstructorInfo Constructor { get; }
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    public sealed virtual Type get_AttributeType();
    protected abstract virtual Type ComputeAttributeType();
    public sealed virtual ConstructorInfo get_Constructor();
    protected abstract virtual ConstructorInfo ComputeConstructor();
    public abstract virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public abstract virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    public sealed virtual string ToString();
}
internal class System.Reflection.TypeLoading.RoDefinitionConstructor`1 : RoConstructor {
    private RoInstantiationProviderType _declaringType;
    private TMethodDecoder _decoder;
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public TypeContext TypeContext { get; }
    internal RoDefinitionConstructor`1(RoInstantiationProviderType declaringType, TMethodDecoder decoder);
    internal sealed virtual RoType GetRoDeclaringType();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected sealed virtual MethodAttributes ComputeAttributes();
    protected sealed virtual CallingConventions ComputeCallingConvention();
    protected sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    protected sealed virtual MethodSig`1<RoParameter> ComputeMethodSig();
    public sealed virtual MethodBody GetMethodBody();
    protected sealed virtual MethodSig`1<string> ComputeMethodSigStrings();
    protected sealed virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual TypeContext get_TypeContext();
}
internal abstract class System.Reflection.TypeLoading.RoDefinitionMethod : RoMethod {
    protected RoDefinitionMethod(Type reflectedType);
    internal abstract virtual MethodSig`1<RoParameter> SpecializeMethodSig(IRoMethodBase member);
    internal abstract virtual MethodSig`1<RoType> SpecializeCustomModifiers(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    internal abstract virtual MethodSig`1<string> SpecializeMethodSigStrings(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    internal abstract virtual MethodBody SpecializeMethodBody(IRoMethodBase owner);
}
internal class System.Reflection.TypeLoading.RoDefinitionMethod`1 : RoDefinitionMethod {
    private RoInstantiationProviderType _declaringType;
    private TMethodDecoder _decoder;
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public TypeContext TypeContext { get; }
    internal RoDefinitionMethod`1(RoInstantiationProviderType declaringType, Type reflectedType, TMethodDecoder decoder);
    internal sealed virtual RoType GetRoDeclaringType();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoDefinitionMethod`1/<get_CustomAttributes>d__9")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected sealed virtual MethodAttributes ComputeAttributes();
    protected sealed virtual CallingConventions ComputeCallingConvention();
    protected sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    protected sealed virtual MethodSig`1<RoParameter> ComputeMethodSig();
    public sealed virtual MethodBody GetMethodBody();
    protected sealed virtual MethodSig`1<string> ComputeMethodSigStrings();
    protected sealed virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    protected sealed virtual RoType[] ComputeGenericArgumentsOrParameters();
    internal sealed virtual MethodSig`1<RoParameter> SpecializeMethodSig(IRoMethodBase member);
    internal sealed virtual MethodSig`1<RoType> SpecializeCustomModifiers(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    internal sealed virtual MethodSig`1<string> SpecializeMethodSigStrings(TypeContext& modreq(System.Runtime.InteropServices.InAttribute) typeContext);
    internal sealed virtual MethodBody SpecializeMethodBody(IRoMethodBase owner);
    public sealed virtual TypeContext get_TypeContext();
    private CustomAttributeData ComputeDllImportCustomAttributeDataIfAny();
}
internal abstract class System.Reflection.TypeLoading.RoDefinitionType : RoInstantiationProviderType {
    public bool IsTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public MethodBase DeclaringMethod { get; }
    internal RoType[] Instantiation { get; }
    public sealed virtual bool get_IsTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    protected sealed virtual string ComputeFullName();
    public sealed virtual string ToString();
    internal abstract virtual int GetGenericParameterCount();
    internal abstract virtual RoType[] GetGenericTypeParametersNoCopy();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoDefinitionType/<get_CustomAttributes>d__26")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected abstract virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    public sealed virtual Type GetGenericTypeDefinition();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    internal abstract virtual RoType SpecializeBaseType(RoType[] instantiation);
    protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal abstract virtual IEnumerable`1<RoType> SpecializeInterfaces(RoType[] instantiation);
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Guid get_GUID();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected abstract virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    protected sealed virtual TypeCode GetTypeCodeImpl();
    internal sealed virtual RoType GetRoElementType();
    public sealed virtual int GetArrayRank();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    protected internal sealed virtual RoType[] GetGenericArgumentsNoCopy();
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual MethodBase get_DeclaringMethod();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal abstract virtual IEnumerable`1<ConstructorInfo> SpecializeConstructors(NameFilter filter, RoInstantiationProviderType declaringType);
    internal abstract virtual IEnumerable`1<MethodInfo> SpecializeMethods(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal abstract virtual IEnumerable`1<EventInfo> SpecializeEvents(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal abstract virtual IEnumerable`1<FieldInfo> SpecializeFields(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal abstract virtual IEnumerable`1<PropertyInfo> SpecializeProperties(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal abstract virtual bool IsTypeNameEqual(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal abstract virtual RoDefinitionType GetNestedTypeCore(ReadOnlySpan`1<byte> utf8Name);
    internal sealed virtual RoType[] get_Instantiation();
}
internal abstract class System.Reflection.TypeLoading.RoEvent : LeveledEventInfo {
    private RoInstantiationProviderType _declaringType;
    private Type _reflectedType;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static EventAttributes EventAttributesSentinel;
    private EventAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEventAttributes;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyEventType;
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAdder;
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRemover;
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazyRaiser;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public EventAttributes Attributes { get; }
    public Type EventHandlerType { get; }
    public bool IsMulticast { get; }
    private MetadataLoadContext Loader { get; }
    internal TypeContext TypeContext { get; }
    protected RoEvent(RoInstantiationProviderType declaringType, Type reflectedType);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public sealed virtual Type get_DeclaringType();
    internal RoInstantiationProviderType GetRoDeclaringType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual EventAttributes get_Attributes();
    protected abstract virtual EventAttributes ComputeAttributes();
    public sealed virtual Type get_EventHandlerType();
    protected abstract virtual Type ComputeEventHandlerType();
    private MethodInfo GetRoAddMethod();
    private MethodInfo GetRoRemoveMethod();
    private MethodInfo GetRoRaiseMethod();
    public sealed virtual MethodInfo GetAddMethod(bool nonPublic);
    public sealed virtual MethodInfo GetRemoveMethod(bool nonPublic);
    public sealed virtual MethodInfo GetRaiseMethod(bool nonPublic);
    protected abstract virtual RoMethod ComputeEventAddMethod();
    protected abstract virtual RoMethod ComputeEventRemoveMethod();
    protected abstract virtual RoMethod ComputeEventRaiseMethod();
    public abstract virtual MethodInfo[] GetOtherMethods(bool nonPublic);
    public sealed virtual bool get_IsMulticast();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual void AddEventHandler(object target, Delegate handler);
    public sealed virtual void RemoveEventHandler(object target, Delegate handler);
    private MetadataLoadContext get_Loader();
    internal TypeContext get_TypeContext();
}
internal class System.Reflection.TypeLoading.RoExceptionAssembly : RoStubAssembly {
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    internal Exception Exception { get; }
    internal RoExceptionAssembly(Exception exception);
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
}
internal class System.Reflection.TypeLoading.RoExceptionHandlingClause : ExceptionHandlingClause {
    private Type _catchType;
    private ExceptionHandlingClauseOptions _flags;
    private int _filterOffset;
    private int _tryOffset;
    private int _tryLength;
    private int _handlerOffset;
    private int _handlerLength;
    public Type CatchType { get; }
    public ExceptionHandlingClauseOptions Flags { get; }
    public int FilterOffset { get; }
    public int HandlerOffset { get; }
    public int HandlerLength { get; }
    public int TryOffset { get; }
    public int TryLength { get; }
    internal RoExceptionHandlingClause(Type catchType, ExceptionHandlingClauseOptions flags, int filterOffset, int tryOffset, int tryLength, int handlerOffset, int handlerLength);
    public sealed virtual Type get_CatchType();
    public sealed virtual ExceptionHandlingClauseOptions get_Flags();
    public sealed virtual int get_FilterOffset();
    public sealed virtual int get_HandlerOffset();
    public sealed virtual int get_HandlerLength();
    public sealed virtual int get_TryOffset();
    public sealed virtual int get_TryLength();
}
internal class System.Reflection.TypeLoading.RoExceptionType : RoDefinitionType {
    private Byte[] _ns;
    private Byte[] _name;
    [CompilerGeneratedAttribute]
private Exception <Exception>k__BackingField;
    internal Exception Exception { get; }
    public bool IsGenericTypeDefinition { get; }
    public int MetadataToken { get; }
    internal RoExceptionType(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, Exception exception);
    [CompilerGeneratedAttribute]
internal Exception get_Exception();
    internal sealed virtual bool IsTypeNameEqual(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual bool get_IsGenericTypeDefinition();
    public sealed virtual int get_MetadataToken();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual RoType ComputeDeclaringType();
    internal sealed virtual int GetGenericParameterCount();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    protected sealed virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    protected sealed virtual void GetPackSizeAndSize(Int32& packSize, Int32& size);
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    internal sealed virtual RoType SpecializeBaseType(RoType[] instantiation);
    internal sealed virtual IEnumerable`1<RoType> SpecializeInterfaces(RoType[] instantiation);
    internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
    internal sealed virtual RoDefinitionType GetNestedTypeCore(ReadOnlySpan`1<byte> utf8Name);
    internal sealed virtual IEnumerable`1<ConstructorInfo> SpecializeConstructors(NameFilter filter, RoInstantiationProviderType declaringType);
    internal sealed virtual IEnumerable`1<MethodInfo> SpecializeMethods(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal sealed virtual IEnumerable`1<EventInfo> SpecializeEvents(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal sealed virtual IEnumerable`1<FieldInfo> SpecializeFields(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
    internal sealed virtual IEnumerable`1<PropertyInfo> SpecializeProperties(NameFilter filter, Type reflectedType, RoInstantiationProviderType declaringType);
}
internal abstract class System.Reflection.TypeLoading.RoFatMethodParameter : RoMethodParameter {
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static ParameterAttributes ParameterAttributesSentinel;
    private ParameterAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyParameterAttributes;
    public string Name { get; }
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool HasDefaultValue { get; }
    public object RawDefaultValue { get; }
    private MetadataLoadContext Loader { get; }
    protected RoFatMethodParameter(IRoMethodBase roMethodBase, int position, Type parameterType);
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual ParameterAttributes get_Attributes();
    protected abstract virtual ParameterAttributes ComputeAttributes();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoFatMethodParameter/<get_CustomAttributes>d__11")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected abstract virtual MarshalAsAttribute ComputeMarshalAsAttribute();
    public abstract virtual bool get_HasDefaultValue();
    public abstract virtual object get_RawDefaultValue();
    protected abstract virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    private MetadataLoadContext get_Loader();
}
internal abstract class System.Reflection.TypeLoading.RoField : LeveledFieldInfo {
    private RoInstantiationProviderType _declaringType;
    private Type _reflectedType;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static FieldAttributes FieldAttributesSentinel;
    private FieldAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFieldAttributes;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFieldType;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public FieldAttributes Attributes { get; }
    public Type FieldType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeFieldHandle FieldHandle { get; }
    private MetadataLoadContext Loader { get; }
    internal TypeContext TypeContext { get; }
    protected RoField(RoInstantiationProviderType declaringType, Type reflectedType);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public sealed virtual Type get_DeclaringType();
    internal RoInstantiationProviderType GetRoDeclaringType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoField/<get_CustomAttributes>d__23")]
public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected abstract virtual IEnumerable`1<CustomAttributeData> GetTrueCustomAttributes();
    protected abstract virtual int GetExplicitFieldOffset();
    protected abstract virtual MarshalAsAttribute ComputeMarshalAsAttribute();
    public sealed virtual FieldAttributes get_Attributes();
    protected abstract virtual FieldAttributes ComputeAttributes();
    public sealed virtual Type get_FieldType();
    protected abstract virtual Type ComputeFieldType();
    public sealed virtual object GetRawConstantValue();
    protected abstract virtual object ComputeRawConstantValue();
    public abstract virtual Type[] GetOptionalCustomModifiers();
    public abstract virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual RuntimeFieldHandle get_FieldHandle();
    public sealed virtual object GetValue(object obj);
    public sealed virtual object GetValueDirect(TypedReference obj);
    public sealed virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, CultureInfo culture);
    public sealed virtual void SetValueDirect(TypedReference obj, object value);
    private MetadataLoadContext get_Loader();
    internal TypeContext get_TypeContext();
}
internal abstract class System.Reflection.TypeLoading.RoGenericParameterType : RoType {
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPosition;
    private RoType[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyConstraints;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool ContainsGenericParameters { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual string ComputeFullName();
    public sealed virtual string ToString();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    internal sealed virtual RoType GetRoElementType();
    public sealed virtual int GetArrayRank();
    public sealed virtual Type GetGenericTypeDefinition();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    protected internal sealed virtual RoType[] GetGenericArgumentsNoCopy();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual int get_GenericParameterPosition();
    protected abstract virtual int ComputePosition();
    public sealed virtual Type[] GetGenericParameterConstraints();
    private RoType[] GetGenericParameterConstraintsNoCopy();
    protected abstract virtual RoType[] ComputeGenericParameterConstraints();
    public sealed virtual Guid get_GUID();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoGenericParameterType/<ComputeDirectlyImplementedInterfaces>d__45")]
protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
}
internal abstract class System.Reflection.TypeLoading.RoHasElementType : RoType {
    private RoType _elementType;
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    protected string Suffix { get; }
    protected RoHasElementType(RoType elementType);
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual string ComputeFullName();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    public sealed virtual string ToString();
    public sealed virtual MethodBase get_DeclaringMethod();
    protected sealed virtual RoType ComputeDeclaringType();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual int get_MetadataToken();
    internal sealed virtual RoType GetRoElementType();
    public sealed virtual Type GetGenericTypeDefinition();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    protected internal sealed virtual RoType[] GetGenericArgumentsNoCopy();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual Guid get_GUID();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    protected abstract virtual string get_Suffix();
    internal sealed virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
}
internal abstract class System.Reflection.TypeLoading.RoInstantiationProviderType : RoType {
    internal RoType[] Instantiation { get; }
    internal abstract virtual RoType[] get_Instantiation();
}
internal class System.Reflection.TypeLoading.RoLocalVariableInfo : LocalVariableInfo {
    private int _localIndex;
    private bool _isPinned;
    private Type _localType;
    public int LocalIndex { get; }
    public bool IsPinned { get; }
    public Type LocalType { get; }
    internal RoLocalVariableInfo(int localIndex, bool isPinned, Type localType);
    public sealed virtual int get_LocalIndex();
    public sealed virtual bool get_IsPinned();
    public sealed virtual Type get_LocalType();
}
internal abstract class System.Reflection.TypeLoading.RoMethod : LeveledMethodInfo {
    private Type _reflectedType;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static MethodAttributes MethodAttributesSentinel;
    private MethodAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodAttributes;
    private static CallingConventions CallingConventionsSentinel;
    private CallingConventions modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCallingConventions;
    private static MethodImplAttributes MethodImplAttributesSentinel;
    private MethodImplAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodImplAttributes;
    private MethodSig`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyMethodSig;
    private MethodSig`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCustomModifiers;
    private RoType[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGenericArgumentsOrParameters;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsConstructedGenericMethod { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsGenericMethod { get; }
    public MethodAttributes Attributes { get; }
    public CallingConventions CallingConvention { get; }
    public MethodImplAttributes MethodImplementationFlags { get; }
    public bool ContainsGenericParameters { get; }
    public ParameterInfo ReturnParameter { get; }
    private MethodSig`1<RoParameter> MethodSig { get; }
    private MethodSig`1<RoType> CustomModifiers { get; }
    public ICustomAttributeProvider ReturnTypeCustomAttributes { get; }
    public Type ReturnType { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeMethodHandle MethodHandle { get; }
    private MethodBase System.Reflection.TypeLoading.IRoMethodBase.MethodBase { get; }
    public MetadataLoadContext Loader { get; }
    public TypeContext TypeContext { get; }
    protected RoMethod(Type reflectedType);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public sealed virtual Type get_DeclaringType();
    internal abstract virtual RoType GetRoDeclaringType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual bool get_IsConstructedGenericMethod();
    public abstract virtual bool get_IsGenericMethodDefinition();
    public sealed virtual bool get_IsGenericMethod();
    public sealed virtual MethodAttributes get_Attributes();
    protected abstract virtual MethodAttributes ComputeAttributes();
    public sealed virtual CallingConventions get_CallingConvention();
    protected abstract virtual CallingConventions ComputeCallingConvention();
    public sealed virtual MethodImplAttributes get_MethodImplementationFlags();
    protected abstract virtual MethodImplAttributes ComputeMethodImplementationFlags();
    public sealed virtual MethodImplAttributes GetMethodImplementationFlags();
    public abstract virtual MethodBody GetMethodBody();
    public sealed virtual bool get_ContainsGenericParameters();
    public sealed virtual ParameterInfo[] GetParameters();
    public sealed virtual ParameterInfo get_ReturnParameter();
    internal RoParameter[] GetParametersNoCopy();
    private MethodSig`1<RoParameter> get_MethodSig();
    protected abstract virtual MethodSig`1<RoParameter> ComputeMethodSig();
    private MethodSig`1<RoType> get_CustomModifiers();
    protected abstract virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual ICustomAttributeProvider get_ReturnTypeCustomAttributes();
    public sealed virtual Type get_ReturnType();
    public abstract virtual MethodInfo GetGenericMethodDefinition();
    public sealed virtual Type[] GetGenericArguments();
    internal RoType[] GetGenericArgumentsOrParametersNoCopy();
    protected abstract virtual RoType[] ComputeGenericArgumentsOrParameters();
    internal abstract virtual RoType[] GetGenericTypeParametersNoCopy();
    internal abstract virtual RoType[] GetGenericTypeArgumentsNoCopy();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public abstract virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    public sealed virtual string ToString();
    protected abstract virtual MethodSig`1<string> ComputeMethodSigStrings();
    public sealed virtual MethodInfo GetBaseDefinition();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual object Invoke(object obj, BindingFlags invokeAttr, Binder binder, Object[] parameters, CultureInfo culture);
    public sealed virtual Delegate CreateDelegate(Type delegateType);
    public sealed virtual Delegate CreateDelegate(Type delegateType, object target);
    public sealed virtual RuntimeMethodHandle get_MethodHandle();
    private sealed virtual override MethodBase System.Reflection.TypeLoading.IRoMethodBase.get_MethodBase();
    public sealed virtual MetadataLoadContext get_Loader();
    public abstract virtual TypeContext get_TypeContext();
    private sealed virtual override Type[] System.Reflection.TypeLoading.IRoMethodBase.GetCustomModifiers(int position, bool isRequired);
    private sealed virtual override string System.Reflection.TypeLoading.IRoMethodBase.GetMethodSigString(int position);
}
internal abstract class System.Reflection.TypeLoading.RoMethodBody : MethodBody {
    private Byte[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIL;
    public bool InitLocals { get; }
    public int MaxStackSize { get; }
    public int LocalSignatureMetadataToken { get; }
    public IList`1<LocalVariableInfo> LocalVariables { get; }
    public IList`1<ExceptionHandlingClause> ExceptionHandlingClauses { get; }
    public abstract virtual bool get_InitLocals();
    public abstract virtual int get_MaxStackSize();
    public abstract virtual int get_LocalSignatureMetadataToken();
    public sealed virtual Byte[] GetILAsByteArray();
    protected abstract virtual Byte[] ComputeIL();
    public abstract virtual IList`1<LocalVariableInfo> get_LocalVariables();
    public abstract virtual IList`1<ExceptionHandlingClause> get_ExceptionHandlingClauses();
}
internal abstract class System.Reflection.TypeLoading.RoMethodParameter : RoParameter {
    private Type _parameterType;
    public Type ParameterType { get; }
    private MetadataLoadContext Loader { get; }
    protected RoMethodParameter(IRoMethodBase roMethodBase, int position, Type parameterType);
    public sealed virtual Type get_ParameterType();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual string ToString();
    internal IRoMethodBase GetRoMethodBase();
    private MetadataLoadContext get_Loader();
}
internal class System.Reflection.TypeLoading.RoModifiedType : RoWrappedType {
    [CompilerGeneratedAttribute]
private RoType <Modifier>k__BackingField;
    [CompilerGeneratedAttribute]
private bool <IsRequired>k__BackingField;
    internal RoType Modifier { get; }
    internal bool IsRequired { get; }
    internal RoModifiedType(RoType modifier, RoType unmodifiedType, bool isRequired);
    [CompilerGeneratedAttribute]
internal RoType get_Modifier();
    [CompilerGeneratedAttribute]
internal bool get_IsRequired();
}
internal abstract class System.Reflection.TypeLoading.RoModule : Module {
    private string _fullyQualifiedName;
    internal static string FullyQualifiedNameForModulesLoadedFromByteArrays;
    internal static string UnknownStringMessageInRAF;
    internal GetTypeCoreCache _getTypeCoreCache;
    private static Func`2<RoType, RoArrayType> s_szArrayTypeFactory;
    private ConcurrentDictionary`2<RoType, RoArrayType> _szArrayDict;
    private static Func`2<Key, RoArrayType> s_mdArrayTypeFactory;
    private ConcurrentDictionary`2<Key, RoArrayType> _mdArrayDict;
    private static Func`2<RoType, RoByRefType> s_byrefTypeFactory;
    private ConcurrentDictionary`2<RoType, RoByRefType> _byRefDict;
    private ConcurrentDictionary`2<RoType, RoPointerType> _pointerDict;
    private static Func`2<Key, RoConstructedGenericType> s_constructedGenericTypeFactory;
    private ConcurrentDictionary`2<Key, RoConstructedGenericType> _constructedGenericTypeDict;
    public Assembly Assembly { get; }
    public string FullyQualifiedName { get; }
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    public string Name { get; }
    public string ScopeName { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal MetadataLoadContext Loader { get; }
    internal RoModule(string fullyQualifiedName);
    private static RoModule();
    public sealed virtual string ToString();
    public sealed virtual Assembly get_Assembly();
    internal abstract virtual RoAssembly GetRoAssembly();
    public sealed virtual string get_FullyQualifiedName();
    public abstract virtual int get_MDStreamVersion();
    public abstract virtual int get_MetadataToken();
    public abstract virtual Guid get_ModuleVersionId();
    public sealed virtual string get_Name();
    public abstract virtual string get_ScopeName();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public abstract virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public abstract virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public abstract virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected abstract virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual void GetObjectData(SerializationInfo info, StreamingContext context);
    public abstract virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public abstract virtual Type[] GetTypes();
    internal abstract virtual IEnumerable`1<RoType> GetDefinedRoTypes();
    public abstract virtual bool IsResource();
    public sealed virtual FieldInfo ResolveField(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual MemberInfo ResolveMember(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual MethodBase ResolveMethod(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual Byte[] ResolveSignature(int metadataToken);
    public sealed virtual string ResolveString(int metadataToken);
    public sealed virtual Type ResolveType(int metadataToken, Type[] genericTypeArguments, Type[] genericMethodArguments);
    public sealed virtual Type GetType(string className, bool throwOnError, bool ignoreCase);
    internal RoDefinitionType GetTypeCore(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, bool ignoreCase, Exception& e);
    protected abstract virtual RoDefinitionType GetTypeCoreNoCache(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, Exception& e);
    internal MetadataLoadContext get_Loader();
    internal RoArrayType GetUniqueArrayType(RoType elementType);
    internal RoArrayType GetUniqueArrayType(RoType elementType, int rank);
    internal RoByRefType GetUniqueByRefType(RoType elementType);
    internal RoPointerType GetUniquePointerType(RoType elementType);
    internal RoConstructedGenericType GetUniqueConstructedGenericType(RoDefinitionType genericTypeDefinition, RoType[] genericTypeArguments);
}
internal abstract class System.Reflection.TypeLoading.RoParameter : ParameterInfo {
    private MemberInfo _member;
    private int _position;
    public MemberInfo Member { get; }
    public int Position { get; }
    public int MetadataToken { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool HasDefaultValue { get; }
    public object DefaultValue { get; }
    public object RawDefaultValue { get; }
    protected RoParameter(MemberInfo member, int position);
    public sealed virtual MemberInfo get_Member();
    public sealed virtual int get_Position();
    public abstract virtual int get_MetadataToken();
    public abstract virtual string get_Name();
    public abstract virtual Type get_ParameterType();
    public abstract virtual ParameterAttributes get_Attributes();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public abstract virtual bool get_HasDefaultValue();
    public sealed virtual object get_DefaultValue();
    public abstract virtual object get_RawDefaultValue();
    public abstract virtual Type[] GetOptionalCustomModifiers();
    public abstract virtual Type[] GetRequiredCustomModifiers();
    public abstract virtual string ToString();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
}
internal class System.Reflection.TypeLoading.RoPinnedType : RoWrappedType {
    internal RoPinnedType(RoType unmodifiedType);
}
internal class System.Reflection.TypeLoading.RoPointerType : RoHasElementType {
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    protected string Suffix { get; }
    internal RoPointerType(RoType elementType);
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual int GetArrayRank();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual string get_Suffix();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
}
internal abstract class System.Reflection.TypeLoading.RoProperty : LeveledPropertyInfo {
    private RoInstantiationProviderType _declaringType;
    private Type _reflectedType;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private static PropertyAttributes PropertyAttributesSentinel;
    private PropertyAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPropertyAttributes;
    private Type modreq(System.Runtime.CompilerServices.IsVolatile) _lazyPropertyType;
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazyGetter;
    private RoMethod modreq(System.Runtime.CompilerServices.IsVolatile) _lazySetter;
    private RoPropertyIndexParameter[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyIndexedParameters;
    public Type DeclaringType { get; }
    public Type ReflectedType { get; }
    public string Name { get; }
    public Module Module { get; }
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public PropertyAttributes Attributes { get; }
    public Type PropertyType { get; }
    public bool CanRead { get; }
    public bool CanWrite { get; }
    internal TypeContext TypeContext { get; }
    protected RoProperty(RoInstantiationProviderType declaringType, Type reflectedType);
    public abstract virtual bool Equals(object obj);
    public abstract virtual int GetHashCode();
    public abstract virtual string ToString();
    public sealed virtual Type get_DeclaringType();
    internal RoInstantiationProviderType GetRoDeclaringType();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual PropertyAttributes get_Attributes();
    protected abstract virtual PropertyAttributes ComputeAttributes();
    public sealed virtual Type get_PropertyType();
    protected abstract virtual Type ComputePropertyType();
    public sealed virtual MethodInfo GetGetMethod(bool nonPublic);
    public sealed virtual MethodInfo GetSetMethod(bool nonPublic);
    private RoMethod GetRoGetMethod();
    private RoMethod GetRoSetMethod();
    protected abstract virtual RoMethod ComputeGetterMethod();
    protected abstract virtual RoMethod ComputeSetterMethod();
    public sealed virtual bool get_CanRead();
    public sealed virtual bool get_CanWrite();
    public sealed virtual MethodInfo[] GetAccessors(bool nonPublic);
    public sealed virtual ParameterInfo[] GetIndexParameters();
    private RoPropertyIndexParameter[] ComputeIndexParameters();
    public sealed virtual object GetRawConstantValue();
    protected abstract virtual object ComputeRawConstantValue();
    public abstract virtual Type[] GetOptionalCustomModifiers();
    public abstract virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual object GetConstantValue();
    public sealed virtual object GetValue(object obj, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    public sealed virtual void SetValue(object obj, object value, BindingFlags invokeAttr, Binder binder, Object[] index, CultureInfo culture);
    internal TypeContext get_TypeContext();
}
internal class System.Reflection.TypeLoading.RoPropertyIndexParameter : RoParameter {
    private RoParameter _backingParameter;
    public int MetadataToken { get; }
    public string Name { get; }
    public Type ParameterType { get; }
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool HasDefaultValue { get; }
    public object RawDefaultValue { get; }
    internal RoPropertyIndexParameter(RoProperty member, RoParameter backingParameter);
    public sealed virtual int get_MetadataToken();
    public sealed virtual string get_Name();
    public sealed virtual Type get_ParameterType();
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object get_RawDefaultValue();
    public sealed virtual Type[] GetOptionalCustomModifiers();
    public sealed virtual Type[] GetRequiredCustomModifiers();
    public sealed virtual string ToString();
}
internal class System.Reflection.TypeLoading.RoPseudoCustomAttributeData : RoCustomAttributeData {
    private ConstructorInfo _constructor;
    private Func`1<CustomAttributeArguments> _argumentsPromise;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFixedArguments;
    private IList`1 modreq(System.Runtime.CompilerServices.IsVolatile) _lazyNamedArguments;
    public IList`1<CustomAttributeTypedArgument> ConstructorArguments { get; }
    public IList`1<CustomAttributeNamedArgument> NamedArguments { get; }
    internal RoPseudoCustomAttributeData(ConstructorInfo constructor, Func`1<CustomAttributeArguments> argumentsPromise);
    internal RoPseudoCustomAttributeData(ConstructorInfo constructor, IList`1<CustomAttributeTypedArgument> fixedArguments, IList`1<CustomAttributeNamedArgument> namedArguments);
    public sealed virtual IList`1<CustomAttributeTypedArgument> get_ConstructorArguments();
    public sealed virtual IList`1<CustomAttributeNamedArgument> get_NamedArguments();
    private IList`1<CustomAttributeTypedArgument> GetLatchedFixedArguments();
    private IList`1<CustomAttributeNamedArgument> GetLatchedNamedArguments();
    protected sealed virtual Type ComputeAttributeType();
    protected sealed virtual ConstructorInfo ComputeConstructor();
    private CustomAttributeArguments LazilyComputeArguments();
}
internal class System.Reflection.TypeLoading.RoResourceModule : RoModule {
    private RoAssembly _assembly;
    public int MDStreamVersion { get; }
    public int MetadataToken { get; }
    public Guid ModuleVersionId { get; }
    [UnconditionalSuppressMessageAttribute("SingleFile", "IL3002:RequiresAssemblyFiles on Name")]
public string ScopeName { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    internal RoResourceModule(RoAssembly assembly, string fullyQualifiedName);
    internal sealed virtual RoAssembly GetRoAssembly();
    public sealed virtual int get_MDStreamVersion();
    public sealed virtual int get_MetadataToken();
    public sealed virtual Guid get_ModuleVersionId();
    public sealed virtual string get_ScopeName();
    public sealed virtual void GetPEKind(PortableExecutableKinds& peKind, ImageFileMachine& machine);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingFlags);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingFlags);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual bool IsResource();
    public sealed virtual Type[] GetTypes();
    protected sealed virtual RoDefinitionType GetTypeCoreNoCache(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name, Exception& e);
    internal sealed virtual IEnumerable`1<RoType> GetDefinedRoTypes();
}
internal abstract class System.Reflection.TypeLoading.RoStubAssembly : RoAssembly {
    public string Location { get; }
    public MethodInfo EntryPoint { get; }
    public string ImageRuntimeVersion { get; }
    public bool IsDynamic { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public sealed virtual string get_Location();
    public sealed virtual MethodInfo get_EntryPoint();
    public sealed virtual string get_ImageRuntimeVersion();
    public sealed virtual bool get_IsDynamic();
    public sealed virtual void add_ModuleResolve(ModuleResolveEventHandler value);
    public sealed virtual void remove_ModuleResolve(ModuleResolveEventHandler value);
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual ManifestResourceInfo GetManifestResourceInfo(string resourceName);
    public sealed virtual String[] GetManifestResourceNames();
    public sealed virtual Stream GetManifestResourceStream(string name);
    protected sealed virtual AssemblyNameData[] ComputeAssemblyReferences();
    protected sealed virtual AssemblyNameData ComputeNameData();
    internal sealed virtual RoModule GetRoManifestModule();
    protected sealed virtual void IterateTypeForwards(TypeForwardHandler handler);
    protected sealed virtual RoModule LoadModule(string moduleName, bool containsMetadata);
    protected sealed virtual IEnumerable`1<AssemblyFileInfo> GetAssemblyFileInfosFromManifest(bool includeManifestModule, bool includeResourceModules);
    protected sealed virtual RoModule CreateModule(Stream peStream, bool containsMetadata);
}
internal abstract class System.Reflection.TypeLoading.RoStubType : RoType {
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool ContainsGenericParameters { get; }
    public MethodBase DeclaringMethod { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public sealed virtual bool get_IsTypeDefinition();
    public sealed virtual bool get_IsGenericTypeDefinition();
    protected sealed virtual bool HasElementTypeImpl();
    protected sealed virtual bool IsArrayImpl();
    public sealed virtual bool get_IsSZArray();
    public sealed virtual bool get_IsVariableBoundArray();
    protected sealed virtual bool IsByRefImpl();
    protected sealed virtual bool IsPointerImpl();
    public sealed virtual bool get_IsConstructedGenericType();
    public sealed virtual bool get_IsGenericParameter();
    public sealed virtual bool get_IsGenericTypeParameter();
    public sealed virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_ContainsGenericParameters();
    internal sealed virtual RoModule GetRoModule();
    public sealed virtual int GetArrayRank();
    protected sealed virtual string ComputeName();
    protected sealed virtual string ComputeNamespace();
    protected sealed virtual string ComputeFullName();
    protected sealed virtual TypeAttributes ComputeAttributeFlags();
    protected sealed virtual TypeCode GetTypeCodeImpl();
    public sealed virtual string ToString();
    public sealed virtual MethodBase get_DeclaringMethod();
    protected sealed virtual RoType ComputeDeclaringType();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal sealed virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal sealed virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual int get_MetadataToken();
    internal sealed virtual RoType GetRoElementType();
    public sealed virtual Type GetGenericTypeDefinition();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    protected internal sealed virtual RoType[] GetGenericArgumentsNoCopy();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual GenericParameterAttributes get_GenericParameterAttributes();
    public sealed virtual int get_GenericParameterPosition();
    public sealed virtual Type[] GetGenericParameterConstraints();
    public sealed virtual Guid get_GUID();
    public sealed virtual StructLayoutAttribute get_StructLayoutAttribute();
    protected internal sealed virtual RoType ComputeEnumUnderlyingType();
    protected sealed virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    protected sealed virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal sealed virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal sealed virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal sealed virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
}
internal class System.Reflection.TypeLoading.RoSyntheticConstructor : RoConstructor {
    private RoType _declaringType;
    private int _uniquifier;
    private RoType[] _parameterTypes;
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public TypeContext TypeContext { get; }
    internal RoSyntheticConstructor(RoType declaringType, int uniquifier, RoType[] parameterTypes);
    internal sealed virtual RoType GetRoDeclaringType();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected sealed virtual MethodAttributes ComputeAttributes();
    protected sealed virtual CallingConventions ComputeCallingConvention();
    protected sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    protected sealed virtual MethodSig`1<RoParameter> ComputeMethodSig();
    public sealed virtual MethodBody GetMethodBody();
    protected sealed virtual MethodSig`1<string> ComputeMethodSigStrings();
    protected sealed virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual TypeContext get_TypeContext();
}
internal class System.Reflection.TypeLoading.RoSyntheticMethod : RoMethod {
    private RoType _declaringType;
    private int _uniquifier;
    private string _name;
    private RoType _returnType;
    private RoType[] _parameterTypes;
    public int MetadataToken { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public bool IsGenericMethodDefinition { get; }
    public bool IsConstructedGenericMethod { get; }
    public TypeContext TypeContext { get; }
    internal RoSyntheticMethod(RoType declaringType, int uniquifier, string name, RoType returnType, RoType[] parameterTypes);
    internal sealed virtual RoType GetRoDeclaringType();
    internal sealed virtual RoModule GetRoModule();
    protected sealed virtual string ComputeName();
    public sealed virtual int get_MetadataToken();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    protected sealed virtual MethodAttributes ComputeAttributes();
    protected sealed virtual CallingConventions ComputeCallingConvention();
    protected sealed virtual MethodImplAttributes ComputeMethodImplementationFlags();
    protected sealed virtual MethodSig`1<RoParameter> ComputeMethodSig();
    public sealed virtual MethodBody GetMethodBody();
    protected sealed virtual MethodSig`1<string> ComputeMethodSigStrings();
    protected sealed virtual MethodSig`1<RoType> ComputeCustomModifiers();
    public sealed virtual bool Equals(object obj);
    public sealed virtual int GetHashCode();
    public sealed virtual bool get_IsGenericMethodDefinition();
    public sealed virtual bool get_IsConstructedGenericMethod();
    public sealed virtual MethodInfo GetGenericMethodDefinition();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public sealed virtual MethodInfo MakeGenericMethod(Type[] typeArguments);
    protected sealed virtual RoType[] ComputeGenericArgumentsOrParameters();
    internal sealed virtual RoType[] GetGenericTypeArgumentsNoCopy();
    internal sealed virtual RoType[] GetGenericTypeParametersNoCopy();
    public sealed virtual TypeContext get_TypeContext();
}
internal class System.Reflection.TypeLoading.RoThinMethodParameter : RoMethodParameter {
    public string Name { get; }
    public ParameterAttributes Attributes { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public int MetadataToken { get; }
    public bool HasDefaultValue { get; }
    public object RawDefaultValue { get; }
    internal RoThinMethodParameter(IRoMethodBase roMethodBase, int position, Type parameterType);
    public sealed virtual string get_Name();
    public sealed virtual ParameterAttributes get_Attributes();
    public sealed virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    public sealed virtual int get_MetadataToken();
    public sealed virtual bool get_HasDefaultValue();
    public sealed virtual object get_RawDefaultValue();
}
internal abstract class System.Reflection.TypeLoading.RoType : LeveledTypeInfo {
    private TypeComponentsCache modreq(System.Runtime.CompilerServices.IsVolatile) _lazyCache;
    private static int GenericParameterCountAny;
    private static TypeAttributes TypeAttributesSentinel;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyNamespace;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyFullName;
    private String modreq(System.Runtime.CompilerServices.IsVolatile) _lazyAssemblyQualifiedFullName;
    private RoType modreq(System.Runtime.CompilerServices.IsVolatile) _lazyDeclaringType;
    private RoType modreq(System.Runtime.CompilerServices.IsVolatile) _lazyBaseType;
    private RoType[] modreq(System.Runtime.CompilerServices.IsVolatile) _lazyInterfaces;
    private TypeAttributes modreq(System.Runtime.CompilerServices.IsVolatile) _lazyTypeAttributes;
    private RoType modreq(System.Runtime.CompilerServices.IsVolatile) _lazyUnderlyingEnumType;
    private TypeClassification modreq(System.Runtime.CompilerServices.IsVolatile) _lazyClassification;
    private BaseTypeClassification modreq(System.Runtime.CompilerServices.IsVolatile) _lazyBaseTypeClassification;
    private static CoreType[] s_primitiveTypes;
    private TypeComponentsCache Cache { get; }
    public Type UnderlyingSystemType { get; }
    public bool IsTypeDefinition { get; }
    public bool IsGenericTypeDefinition { get; }
    public bool IsSZArray { get; }
    public bool IsVariableBoundArray { get; }
    public bool IsConstructedGenericType { get; }
    public bool IsGenericParameter { get; }
    public bool IsGenericTypeParameter { get; }
    public bool IsGenericMethodParameter { get; }
    public bool IsByRefLike { get; }
    public bool ContainsGenericParameters { get; }
    public Type[] GenericTypeParameters { get; }
    public Type[] GenericTypeArguments { get; }
    public GenericParameterAttributes GenericParameterAttributes { get; }
    public int GenericParameterPosition { get; }
    public bool IsGenericType { get; }
    public string Name { get; }
    public string Namespace { get; }
    public string FullName { get; }
    public string AssemblyQualifiedName { get; }
    public Assembly Assembly { get; }
    public Module Module { get; }
    public Type DeclaringType { get; }
    public MethodBase DeclaringMethod { get; }
    public Type ReflectedType { get; }
    public IEnumerable`1<CustomAttributeData> CustomAttributes { get; }
    public Type BaseType { get; }
    public IEnumerable`1<Type> ImplementedInterfaces { get; }
    public bool IsEnum { get; }
    public int MetadataToken { get; }
    public MemberTypes MemberType { get; }
    public Guid GUID { get; }
    public StructLayoutAttribute StructLayoutAttribute { get; }
    public bool IsSecurityCritical { get; }
    public bool IsSecuritySafeCritical { get; }
    public bool IsSecurityTransparent { get; }
    public RuntimeTypeHandle TypeHandle { get; }
    internal MetadataLoadContext Loader { get; }
    private static RoType();
    public sealed virtual ConstructorInfo[] GetConstructors(BindingFlags bindingAttr);
    protected sealed virtual ConstructorInfo GetConstructorImpl(BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual EventInfo[] GetEvents(BindingFlags bindingAttr);
    public sealed virtual EventInfo GetEvent(string name, BindingFlags bindingAttr);
    public sealed virtual FieldInfo[] GetFields(BindingFlags bindingAttr);
    public sealed virtual FieldInfo GetField(string name, BindingFlags bindingAttr);
    public sealed virtual MethodInfo[] GetMethods(BindingFlags bindingAttr);
    protected sealed virtual MethodInfo GetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    protected sealed virtual MethodInfo GetMethodImpl(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    private MethodInfo GetMethodImplCommon(string name, int genericParameterCount, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    public sealed virtual Type[] GetNestedTypes(BindingFlags bindingAttr);
    public sealed virtual Type GetNestedType(string name, BindingFlags bindingAttr);
    public sealed virtual PropertyInfo[] GetProperties(BindingFlags bindingAttr);
    protected sealed virtual PropertyInfo GetPropertyImpl(string name, BindingFlags bindingAttr, Binder binder, Type returnType, Type[] types, ParameterModifier[] modifiers);
    private QueryResult`1<M> Query(BindingFlags bindingAttr);
    private QueryResult`1<M> Query(string name, BindingFlags bindingAttr);
    private QueryResult`1<M> Query(string optionalName, BindingFlags bindingAttr, Func`2<M, bool> optionalPredicate);
    private static bool NeedToSearchImmediateTypeOnly(BindingFlags bf);
    private TypeComponentsCache get_Cache();
    public sealed virtual MemberInfo[] GetMembers(BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, BindingFlags bindingAttr);
    public sealed virtual MemberInfo[] GetMember(string name, MemberTypes type, BindingFlags bindingAttr);
    private MemberInfo[] GetMemberImpl(string optionalNameOrPrefix, MemberTypes type, BindingFlags bindingAttr);
    private M[] QuerySpecificMemberTypeIfRequested(MemberTypes memberType, string optionalName, BindingFlags bindingAttr, Func`2<MemberInfo, bool> optionalPredicate, MemberTypes targetMemberType, QueryResult`1& queryResult);
    public sealed virtual Type AsType();
    public sealed virtual Type get_UnderlyingSystemType();
    public abstract virtual bool get_IsTypeDefinition();
    public abstract virtual bool get_IsGenericTypeDefinition();
    protected abstract virtual bool HasElementTypeImpl();
    protected abstract virtual bool IsArrayImpl();
    public abstract virtual bool get_IsSZArray();
    public abstract virtual bool get_IsVariableBoundArray();
    protected abstract virtual bool IsByRefImpl();
    protected abstract virtual bool IsPointerImpl();
    public abstract virtual bool get_IsConstructedGenericType();
    public abstract virtual bool get_IsGenericParameter();
    public abstract virtual bool get_IsGenericTypeParameter();
    public abstract virtual bool get_IsGenericMethodParameter();
    public sealed virtual bool get_IsByRefLike();
    public abstract virtual bool get_ContainsGenericParameters();
    public sealed virtual Type[] get_GenericTypeParameters();
    internal abstract virtual RoType[] GetGenericTypeParametersNoCopy();
    public sealed virtual Type GetElementType();
    internal abstract virtual RoType GetRoElementType();
    public abstract virtual int GetArrayRank();
    public abstract virtual Type GetGenericTypeDefinition();
    public sealed virtual Type[] get_GenericTypeArguments();
    internal abstract virtual RoType[] GetGenericTypeArgumentsNoCopy();
    public abstract virtual GenericParameterAttributes get_GenericParameterAttributes();
    public abstract virtual int get_GenericParameterPosition();
    public abstract virtual Type[] GetGenericParameterConstraints();
    public sealed virtual bool get_IsGenericType();
    public sealed virtual Type[] GetGenericArguments();
    protected internal abstract virtual RoType[] GetGenericArgumentsNoCopy();
    public sealed virtual string get_Name();
    protected abstract virtual string ComputeName();
    public sealed virtual string get_Namespace();
    protected abstract virtual string ComputeNamespace();
    public sealed virtual string get_FullName();
    protected abstract virtual string ComputeFullName();
    public sealed virtual string get_AssemblyQualifiedName();
    private string ComputeAssemblyQualifiedName();
    public sealed virtual Assembly get_Assembly();
    public sealed virtual Module get_Module();
    internal abstract virtual RoModule GetRoModule();
    public sealed virtual Type get_DeclaringType();
    protected abstract virtual RoType ComputeDeclaringType();
    internal RoType GetRoDeclaringType();
    public abstract virtual MethodBase get_DeclaringMethod();
    public sealed virtual Type get_ReflectedType();
    public sealed virtual IList`1<CustomAttributeData> GetCustomAttributesData();
    public abstract virtual IEnumerable`1<CustomAttributeData> get_CustomAttributes();
    internal abstract virtual bool IsCustomAttributeDefined(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    internal abstract virtual CustomAttributeData TryFindCustomAttribute(ReadOnlySpan`1<byte> ns, ReadOnlySpan`1<byte> name);
    public sealed virtual Type get_BaseType();
    internal RoType GetRoBaseType();
    private RoType ComputeBaseType();
    protected abstract virtual RoType ComputeBaseTypeWithoutDesktopQuirk();
    public sealed virtual Type[] GetInterfaces();
    [IteratorStateMachineAttribute("System.Reflection.TypeLoading.RoType/<get_ImplementedInterfaces>d__119")]
public sealed virtual IEnumerable`1<Type> get_ImplementedInterfaces();
    protected abstract virtual IEnumerable`1<RoType> ComputeDirectlyImplementedInterfaces();
    internal RoType[] GetInterfacesNoCopy();
    private RoType[] ComputeInterfaceClosure();
    public sealed virtual InterfaceMapping GetInterfaceMap(Type interfaceType);
    public sealed virtual bool IsAssignableFrom(TypeInfo typeInfo);
    public sealed virtual bool IsAssignableFrom(Type c);
    protected sealed virtual bool IsCOMObjectImpl();
    public sealed virtual bool get_IsEnum();
    protected sealed virtual bool IsValueTypeImpl();
    public abstract virtual int get_MetadataToken();
    public sealed virtual bool HasSameMetadataDefinitionAs(MemberInfo other);
    protected sealed virtual TypeAttributes GetAttributeFlagsImpl();
    protected abstract virtual TypeAttributes ComputeAttributeFlags();
    public sealed virtual MemberTypes get_MemberType();
    protected abstract virtual TypeCode GetTypeCodeImpl();
    public abstract virtual string ToString();
    public abstract virtual Guid get_GUID();
    public abstract virtual StructLayoutAttribute get_StructLayoutAttribute();
    public sealed virtual MemberInfo[] GetDefaultMembers();
    private string GetDefaultMemberName();
    public sealed virtual Type MakeArrayType();
    public sealed virtual Type MakeArrayType(int rank);
    public sealed virtual Type MakeByRefType();
    public sealed virtual Type MakePointerType();
    [RequiresUnreferencedCodeAttribute("If some of the generic arguments are annotated (either with DynamicallyAccessedMembersAttribute, or generic constraints), trimming can't validate that the requirements of those annotations are met.")]
public abstract virtual Type MakeGenericType(Type[] typeArguments);
    public sealed virtual Type GetEnumUnderlyingType();
    protected internal abstract virtual RoType ComputeEnumUnderlyingType();
    public sealed virtual Array GetEnumValues();
    public sealed virtual bool get_IsSecurityCritical();
    public sealed virtual bool get_IsSecuritySafeCritical();
    public sealed virtual bool get_IsSecurityTransparent();
    public sealed virtual RuntimeTypeHandle get_TypeHandle();
    public sealed virtual Object[] GetCustomAttributes(bool inherit);
    public sealed virtual Object[] GetCustomAttributes(Type attributeType, bool inherit);
    public sealed virtual bool IsDefined(Type attributeType, bool inherit);
    public sealed virtual object InvokeMember(string name, BindingFlags invokeAttr, Binder binder, object target, Object[] args, ParameterModifier[] modifiers, CultureInfo culture, String[] namedParameters);
    internal abstract virtual IEnumerable`1<ConstructorInfo> GetConstructorsCore(NameFilter filter);
    internal abstract virtual IEnumerable`1<MethodInfo> GetMethodsCore(NameFilter filter, Type reflectedType);
    internal abstract virtual IEnumerable`1<EventInfo> GetEventsCore(NameFilter filter, Type reflectedType);
    internal abstract virtual IEnumerable`1<FieldInfo> GetFieldsCore(NameFilter filter, Type reflectedType);
    internal abstract virtual IEnumerable`1<PropertyInfo> GetPropertiesCore(NameFilter filter, Type reflectedType);
    internal abstract virtual IEnumerable`1<RoType> GetNestedTypesCore(NameFilter filter);
    internal MethodInfo InternalGetMethodImpl(string name, BindingFlags bindingAttr, Binder binder, CallingConventions callConvention, Type[] types, ParameterModifier[] modifiers);
    internal MetadataLoadContext get_Loader();
    public sealed virtual Type GetInterface(string name, bool ignoreCase);
    private TypeClassification GetClassification();
    private TypeClassification ComputeClassification();
    private BaseTypeClassification GetBaseTypeClassification();
    private BaseTypeClassification ComputeBaseTypeClassification();
    protected sealed virtual bool IsPrimitiveImpl();
}
internal abstract class System.Reflection.TypeLoading.RoWrappedType : RoStubType {
    [CompilerGeneratedAttribute]
private RoType <UnmodifiedType>k__BackingField;
    internal RoType UnmodifiedType { get; }
    internal RoWrappedType(RoType unmodifiedType);
    [CompilerGeneratedAttribute]
internal RoType get_UnmodifiedType();
}
internal static class System.Reflection.TypeLoading.Sentinels : object {
    public static RoType RoType;
    public static RoMethod RoMethod;
    private static Sentinels();
}
[IsReadOnlyAttribute]
internal class System.Reflection.TypeLoading.TypeContext : ValueType {
    [CompilerGeneratedAttribute]
private RoType[] <GenericTypeArguments>k__BackingField;
    [CompilerGeneratedAttribute]
private RoType[] <GenericMethodArguments>k__BackingField;
    public RoType[] GenericTypeArguments { get; }
    public RoType[] GenericMethodArguments { get; }
    internal TypeContext(RoType[] genericTypeArguments, RoType[] genericMethodArguments);
    [CompilerGeneratedAttribute]
public RoType[] get_GenericTypeArguments();
    [CompilerGeneratedAttribute]
public RoType[] get_GenericMethodArguments();
    public RoType GetGenericTypeArgumentOrNull(int index);
    public RoType GetGenericMethodArgumentOrNull(int index);
}
[ExtensionAttribute]
internal static class System.Reflection.TypeLoading.TypeFactories : object {
    [ExtensionAttribute]
public static RoArrayType GetUniqueArrayType(RoType elementType);
    [ExtensionAttribute]
public static RoArrayType GetUniqueArrayType(RoType elementType, int rank);
    [ExtensionAttribute]
public static RoByRefType GetUniqueByRefType(RoType elementType);
    [ExtensionAttribute]
public static RoPointerType GetUniquePointerType(RoType elementType);
    [ExtensionAttribute]
public static RoConstructedGenericType GetUniqueConstructedGenericType(RoDefinitionType genericTypeDefinition, RoType[] genericTypeArguments);
}
internal static class System.Reflection.TypeLoading.Utf8Constants : object {
    public static ReadOnlySpan`1<byte> System { get; }
    public static ReadOnlySpan`1<byte> SystemReflection { get; }
    public static ReadOnlySpan`1<byte> SystemCollectionsGeneric { get; }
    public static ReadOnlySpan`1<byte> SystemRuntimeInteropServices { get; }
    public static ReadOnlySpan`1<byte> SystemRuntimeCompilerServices { get; }
    public static ReadOnlySpan`1<byte> Array { get; }
    public static ReadOnlySpan`1<byte> Boolean { get; }
    public static ReadOnlySpan`1<byte> Byte { get; }
    public static ReadOnlySpan`1<byte> Char { get; }
    public static ReadOnlySpan`1<byte> Double { get; }
    public static ReadOnlySpan`1<byte> Enum { get; }
    public static ReadOnlySpan`1<byte> Int16 { get; }
    public static ReadOnlySpan`1<byte> Int32 { get; }
    public static ReadOnlySpan`1<byte> Int64 { get; }
    public static ReadOnlySpan`1<byte> IntPtr { get; }
    public static ReadOnlySpan`1<byte> Object { get; }
    public static ReadOnlySpan`1<byte> NullableT { get; }
    public static ReadOnlySpan`1<byte> SByte { get; }
    public static ReadOnlySpan`1<byte> Single { get; }
    public static ReadOnlySpan`1<byte> String { get; }
    public static ReadOnlySpan`1<byte> TypedReference { get; }
    public static ReadOnlySpan`1<byte> UInt16 { get; }
    public static ReadOnlySpan`1<byte> UInt32 { get; }
    public static ReadOnlySpan`1<byte> UInt64 { get; }
    public static ReadOnlySpan`1<byte> UIntPtr { get; }
    public static ReadOnlySpan`1<byte> ValueType { get; }
    public static ReadOnlySpan`1<byte> Void { get; }
    public static ReadOnlySpan`1<byte> MulticastDelegate { get; }
    public static ReadOnlySpan`1<byte> IEnumerableT { get; }
    public static ReadOnlySpan`1<byte> ICollectionT { get; }
    public static ReadOnlySpan`1<byte> IListT { get; }
    public static ReadOnlySpan`1<byte> IReadOnlyListT { get; }
    public static ReadOnlySpan`1<byte> Type { get; }
    public static ReadOnlySpan`1<byte> DBNull { get; }
    public static ReadOnlySpan`1<byte> Decimal { get; }
    public static ReadOnlySpan`1<byte> DateTime { get; }
    public static ReadOnlySpan`1<byte> ComImportAttribute { get; }
    public static ReadOnlySpan`1<byte> DllImportAttribute { get; }
    public static ReadOnlySpan`1<byte> CallingConvention { get; }
    public static ReadOnlySpan`1<byte> CharSet { get; }
    public static ReadOnlySpan`1<byte> MarshalAsAttribute { get; }
    public static ReadOnlySpan`1<byte> UnmanagedType { get; }
    public static ReadOnlySpan`1<byte> VarEnum { get; }
    public static ReadOnlySpan`1<byte> InAttribute { get; }
    public static ReadOnlySpan`1<byte> OutAttriubute { get; }
    public static ReadOnlySpan`1<byte> OptionalAttribute { get; }
    public static ReadOnlySpan`1<byte> PreserveSigAttribute { get; }
    public static ReadOnlySpan`1<byte> FieldOffsetAttribute { get; }
    public static ReadOnlySpan`1<byte> IsByRefLikeAttribute { get; }
    public static ReadOnlySpan`1<byte> DecimalConstantAttribute { get; }
    public static ReadOnlySpan`1<byte> CustomConstantAttribute { get; }
    public static ReadOnlySpan`1<byte> GuidAttribute { get; }
    public static ReadOnlySpan`1<byte> DefaultMemberAttribute { get; }
    public static ReadOnlySpan`1<byte> DateTimeConstantAttribute { get; }
    public static ReadOnlySpan`1<byte> get_System();
    public static ReadOnlySpan`1<byte> get_SystemReflection();
    public static ReadOnlySpan`1<byte> get_SystemCollectionsGeneric();
    public static ReadOnlySpan`1<byte> get_SystemRuntimeInteropServices();
    public static ReadOnlySpan`1<byte> get_SystemRuntimeCompilerServices();
    public static ReadOnlySpan`1<byte> get_Array();
    public static ReadOnlySpan`1<byte> get_Boolean();
    public static ReadOnlySpan`1<byte> get_Byte();
    public static ReadOnlySpan`1<byte> get_Char();
    public static ReadOnlySpan`1<byte> get_Double();
    public static ReadOnlySpan`1<byte> get_Enum();
    public static ReadOnlySpan`1<byte> get_Int16();
    public static ReadOnlySpan`1<byte> get_Int32();
    public static ReadOnlySpan`1<byte> get_Int64();
    public static ReadOnlySpan`1<byte> get_IntPtr();
    public static ReadOnlySpan`1<byte> get_Object();
    public static ReadOnlySpan`1<byte> get_NullableT();
    public static ReadOnlySpan`1<byte> get_SByte();
    public static ReadOnlySpan`1<byte> get_Single();
    public static ReadOnlySpan`1<byte> get_String();
    public static ReadOnlySpan`1<byte> get_TypedReference();
    public static ReadOnlySpan`1<byte> get_UInt16();
    public static ReadOnlySpan`1<byte> get_UInt32();
    public static ReadOnlySpan`1<byte> get_UInt64();
    public static ReadOnlySpan`1<byte> get_UIntPtr();
    public static ReadOnlySpan`1<byte> get_ValueType();
    public static ReadOnlySpan`1<byte> get_Void();
    public static ReadOnlySpan`1<byte> get_MulticastDelegate();
    public static ReadOnlySpan`1<byte> get_IEnumerableT();
    public static ReadOnlySpan`1<byte> get_ICollectionT();
    public static ReadOnlySpan`1<byte> get_IListT();
    public static ReadOnlySpan`1<byte> get_IReadOnlyListT();
    public static ReadOnlySpan`1<byte> get_Type();
    public static ReadOnlySpan`1<byte> get_DBNull();
    public static ReadOnlySpan`1<byte> get_Decimal();
    public static ReadOnlySpan`1<byte> get_DateTime();
    public static ReadOnlySpan`1<byte> get_ComImportAttribute();
    public static ReadOnlySpan`1<byte> get_DllImportAttribute();
    public static ReadOnlySpan`1<byte> get_CallingConvention();
    public static ReadOnlySpan`1<byte> get_CharSet();
    public static ReadOnlySpan`1<byte> get_MarshalAsAttribute();
    public static ReadOnlySpan`1<byte> get_UnmanagedType();
    public static ReadOnlySpan`1<byte> get_VarEnum();
    public static ReadOnlySpan`1<byte> get_InAttribute();
    public static ReadOnlySpan`1<byte> get_OutAttriubute();
    public static ReadOnlySpan`1<byte> get_OptionalAttribute();
    public static ReadOnlySpan`1<byte> get_PreserveSigAttribute();
    public static ReadOnlySpan`1<byte> get_FieldOffsetAttribute();
    public static ReadOnlySpan`1<byte> get_IsByRefLikeAttribute();
    public static ReadOnlySpan`1<byte> get_DecimalConstantAttribute();
    public static ReadOnlySpan`1<byte> get_CustomConstantAttribute();
    public static ReadOnlySpan`1<byte> get_GuidAttribute();
    public static ReadOnlySpan`1<byte> get_DefaultMemberAttribute();
    public static ReadOnlySpan`1<byte> get_DateTimeConstantAttribute();
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsReadOnlyAttribute : Attribute {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("27524")]
internal class System.Runtime.CompilerServices.NullableAttribute : Attribute {
    public Byte[] NullableFlags;
    public NullableAttribute(byte );
    public NullableAttribute(Byte[] );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("5196")]
internal class System.Runtime.CompilerServices.NullableContextAttribute : Attribute {
    public byte Flag;
    public NullableContextAttribute(byte );
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
[AttributeUsageAttribute("2")]
internal class System.Runtime.CompilerServices.NullablePublicOnlyAttribute : Attribute {
    public bool IncludesInternals;
    public NullablePublicOnlyAttribute(bool );
}
internal static class System.SR : object {
    private static bool s_usingResourceKeys;
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Argument_GenericArgsCount { get; }
    internal static string Argument_HasToBeArrayClass { get; }
    internal static string Argument_InvalidEnum { get; }
    internal static string Arg_AmbiguousMatchException { get; }
    internal static string Arg_EmptyArray { get; }
    internal static string Arg_EnumLitValueNotFound { get; }
    internal static string Arg_HTCapacityOverflow { get; }
    internal static string Arg_MustBeEnum { get; }
    internal static string Arg_MustBeType { get; }
    internal static string Arg_NotGenericMethodDefinition { get; }
    internal static string Arg_NotGenericParameter { get; }
    internal static string Arg_NotGenericTypeDefinition { get; }
    internal static string Arg_ReflectionOnlyCA { get; }
    internal static string Arg_InvalidOperation_Reflection { get; }
    internal static string Arg_ReflectionOnlyInvoke { get; }
    internal static string Arg_ReflectionOnlyParameterDefaultValue { get; }
    internal static string BadImageFormat_TypeRefBadScopeType { get; }
    internal static string BadImageFormat_TypeRefModuleNotInManifest { get; }
    internal static string CoreTypeNotFound { get; }
    internal static string ExternalAssemblyReturnedByMetadataAssemblyResolver { get; }
    internal static string FileLoadDuplicateAssemblies { get; }
    internal static string FileNotFoundAssembly { get; }
    internal static string FileNotFoundModule { get; }
    internal static string GenericMethodParamIndexOutOfRange { get; }
    internal static string GenericTypeParamIndexOutOfRange { get; }
    internal static string InvalidOperation_IsSecurity { get; }
    internal static string InvalidOperation_NotGenericType { get; }
    internal static string MakeGenericType_NotLoadedByMetadataLoadContext { get; }
    internal static string ManifestResourceInfoReferencedBadModule { get; }
    internal static string MetadataLoadContextDisposed { get; }
    internal static string MissingCustomAttributeConstructor { get; }
    internal static string ModuleResolveEventReturnedExternalModule { get; }
    internal static string NoInvokeMember { get; }
    internal static string NoMetadataInPeImage { get; }
    internal static string NotAClause { get; }
    internal static string NotAFilter { get; }
    internal static string NotSupported_AssemblyCodeBase { get; }
    internal static string NotSupported_CaseInsensitive { get; }
    internal static string NotSupported_FunctionPointers { get; }
    internal static string NotSupported_GetBaseDefinition { get; }
    internal static string NotSupported_InterfaceMapping { get; }
    internal static string NotSupported_MakeGenericType_SignatureTypes { get; }
    internal static string NotSupported_MDStreamVersion { get; }
    internal static string NotSupported_ResolvingTokens { get; }
    internal static string ResourceOnlyModule { get; }
    internal static string SpecifiedFileNameInvalid { get; }
    internal static string NotSupported_SatelliteAssembly { get; }
    internal static string TypeNotFound { get; }
    internal static string UnexpectedUnderlyingEnumType { get; }
    internal static string UnableToDetermineCoreAssembly { get; }
    internal static string Arg_InvalidPath { get; }
    private static SR();
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey);
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2);
    internal static string Format(IFormatProvider provider, string resourceFormat, object p1, object p2, object p3);
    internal static string Format(IFormatProvider provider, string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Argument_GenericArgsCount();
    internal static string get_Argument_HasToBeArrayClass();
    internal static string get_Argument_InvalidEnum();
    internal static string get_Arg_AmbiguousMatchException();
    internal static string get_Arg_EmptyArray();
    internal static string get_Arg_EnumLitValueNotFound();
    internal static string get_Arg_HTCapacityOverflow();
    internal static string get_Arg_MustBeEnum();
    internal static string get_Arg_MustBeType();
    internal static string get_Arg_NotGenericMethodDefinition();
    internal static string get_Arg_NotGenericParameter();
    internal static string get_Arg_NotGenericTypeDefinition();
    internal static string get_Arg_ReflectionOnlyCA();
    internal static string get_Arg_InvalidOperation_Reflection();
    internal static string get_Arg_ReflectionOnlyInvoke();
    internal static string get_Arg_ReflectionOnlyParameterDefaultValue();
    internal static string get_BadImageFormat_TypeRefBadScopeType();
    internal static string get_BadImageFormat_TypeRefModuleNotInManifest();
    internal static string get_CoreTypeNotFound();
    internal static string get_ExternalAssemblyReturnedByMetadataAssemblyResolver();
    internal static string get_FileLoadDuplicateAssemblies();
    internal static string get_FileNotFoundAssembly();
    internal static string get_FileNotFoundModule();
    internal static string get_GenericMethodParamIndexOutOfRange();
    internal static string get_GenericTypeParamIndexOutOfRange();
    internal static string get_InvalidOperation_IsSecurity();
    internal static string get_InvalidOperation_NotGenericType();
    internal static string get_MakeGenericType_NotLoadedByMetadataLoadContext();
    internal static string get_ManifestResourceInfoReferencedBadModule();
    internal static string get_MetadataLoadContextDisposed();
    internal static string get_MissingCustomAttributeConstructor();
    internal static string get_ModuleResolveEventReturnedExternalModule();
    internal static string get_NoInvokeMember();
    internal static string get_NoMetadataInPeImage();
    internal static string get_NotAClause();
    internal static string get_NotAFilter();
    internal static string get_NotSupported_AssemblyCodeBase();
    internal static string get_NotSupported_CaseInsensitive();
    internal static string get_NotSupported_FunctionPointers();
    internal static string get_NotSupported_GetBaseDefinition();
    internal static string get_NotSupported_InterfaceMapping();
    internal static string get_NotSupported_MakeGenericType_SignatureTypes();
    internal static string get_NotSupported_MDStreamVersion();
    internal static string get_NotSupported_ResolvingTokens();
    internal static string get_ResourceOnlyModule();
    internal static string get_SpecifiedFileNameInvalid();
    internal static string get_NotSupported_SatelliteAssembly();
    internal static string get_TypeNotFound();
    internal static string get_UnexpectedUnderlyingEnumType();
    internal static string get_UnableToDetermineCoreAssembly();
    internal static string get_Arg_InvalidPath();
}
