internal static class FxResources.System.Net.HttpListener.SR : object {
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class Microsoft.Win32.SafeHandles.SafeLibraryHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeLocalAllocHandle : SafeBuffer {
    internal static SafeLocalAllocHandle Zero;
    private static SafeLocalAllocHandle();
    internal static SafeLocalAllocHandle LocalAlloc(int cb);
    protected virtual bool ReleaseHandle();
}
internal class System.Collections.Generic.BidirectionalDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _backward;
    public BidirectionalDictionary`2(int capacity);
    public void Add(T1 item1, T2 item2);
    public bool TryGetForward(T1 item1, T2& item2);
    public bool TryGetBackward(T2 item2, T1& item1);
    public Enumerator<T1, T2> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Net.AsyncRequestContext : RequestContextBase {
    private NativeOverlapped* _nativeOverlapped;
    private ThreadPoolBoundHandle _boundHandle;
    private ListenerAsyncResult _result;
    internal NativeOverlapped* NativeOverlapped { get; }
    internal AsyncRequestContext(ThreadPoolBoundHandle boundHandle, ListenerAsyncResult result);
    private HTTP_REQUEST* Allocate(ThreadPoolBoundHandle boundHandle, UInt32 size);
    internal void Reset(ThreadPoolBoundHandle boundHandle, ulong requestId, UInt32 size);
    protected virtual void OnReleasePins();
    protected virtual void Dispose(bool disposing);
    internal NativeOverlapped* get_NativeOverlapped();
}
public class System.Net.AuthenticationSchemeSelector : MulticastDelegate {
    public AuthenticationSchemeSelector(object object, IntPtr method);
    public virtual AuthenticationSchemes Invoke(HttpListenerRequest httpRequest);
    public virtual IAsyncResult BeginInvoke(HttpListenerRequest httpRequest, AsyncCallback callback, object object);
    public virtual AuthenticationSchemes EndInvoke(IAsyncResult result);
}
internal enum System.Net.BoundaryType : Enum {
    public int value__;
    public static BoundaryType ContentLength;
    public static BoundaryType Chunked;
    public static BoundaryType Multipart;
    public static BoundaryType None;
    public static BoundaryType Invalid;
}
internal class System.Net.CaseInsensitiveAscii : object {
    internal static CaseInsensitiveAscii StaticInstance;
    internal static Byte[] AsciiToLower;
    private static CaseInsensitiveAscii();
    public sealed virtual int GetHashCode(object myObject);
    public sealed virtual int Compare(object firstObject, object secondObject);
    private int FastGetHashCode(string myString);
    public sealed virtual bool Equals(object firstObject, object secondObject);
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(ContextFlags win32Flags);
    internal static ContextFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
[ExtensionAttribute]
internal static class System.Net.CookieCollectionExtensions : object {
    private static Func`4<CookieCollection, Cookie, bool, int> s_internalAddFunc;
    [ExtensionAttribute]
public static int InternalAdd(CookieCollection cookieCollection, Cookie cookie, bool isStrict);
}
[ExtensionAttribute]
internal static class System.Net.CookieExtensions : object {
    private static Func`2<Cookie, string> s_toServerStringFunc;
    private static Func`2<Cookie, Cookie> s_cloneFunc;
    private static Func`2<Cookie, CookieVariant> s_getVariantFunc;
    [ExtensionAttribute]
public static string ToServerString(Cookie cookie);
    [ExtensionAttribute]
public static Cookie Clone(Cookie cookie);
    [ExtensionAttribute]
public static bool IsRfc2965Variant(Cookie cookie);
}
internal class System.Net.CookieParser : object {
    private CookieTokenizer _tokenizer;
    private Cookie _savedCookie;
    private static Func`3<Cookie, string, bool> s_internalSetNameMethod;
    private static FieldInfo s_isQuotedDomainField;
    private static Func`3<Cookie, string, bool> InternalSetNameMethod { get; }
    private static FieldInfo IsQuotedDomainField { get; }
    internal CookieParser(string cookieString);
    private static CookieParser();
    private static Func`3<Cookie, string, bool> get_InternalSetNameMethod();
    private static FieldInfo get_IsQuotedDomainField();
    internal Cookie GetServer();
    internal static string CheckQuoted(string value);
}
internal enum System.Net.CookieToken : Enum {
    public int value__;
    public static CookieToken Nothing;
    public static CookieToken NameValuePair;
    public static CookieToken Attribute;
    public static CookieToken EndToken;
    public static CookieToken EndCookie;
    public static CookieToken End;
    public static CookieToken Equals;
    public static CookieToken Comment;
    public static CookieToken CommentUrl;
    public static CookieToken CookieName;
    public static CookieToken Discard;
    public static CookieToken Domain;
    public static CookieToken Expires;
    public static CookieToken MaxAge;
    public static CookieToken Path;
    public static CookieToken Port;
    public static CookieToken Secure;
    public static CookieToken HttpOnly;
    public static CookieToken Unknown;
    public static CookieToken Version;
}
internal class System.Net.CookieTokenizer : object {
    private bool _eofCookie;
    private int _index;
    private int _length;
    private string _name;
    private bool _quoted;
    private int _start;
    private CookieToken _token;
    private int _tokenLength;
    private string _tokenStream;
    private string _value;
    private int _cookieStartIndex;
    private int _cookieLength;
    private static RecognizedAttribute[] s_recognizedAttributes;
    private static RecognizedAttribute[] s_recognizedServerAttributes;
    internal bool EndOfCookie { get; internal set; }
    internal bool Eof { get; }
    internal string Name { get; internal set; }
    internal bool Quoted { get; internal set; }
    internal CookieToken Token { get; internal set; }
    internal string Value { get; internal set; }
    internal CookieTokenizer(string tokenStream);
    private static CookieTokenizer();
    internal bool get_EndOfCookie();
    internal void set_EndOfCookie(bool value);
    internal bool get_Eof();
    internal string get_Name();
    internal void set_Name(string value);
    internal bool get_Quoted();
    internal void set_Quoted(bool value);
    internal CookieToken get_Token();
    internal void set_Token(CookieToken value);
    internal string get_Value();
    internal void set_Value(string value);
    internal string Extract();
    internal CookieToken FindNext(bool ignoreComma, bool ignoreEquals);
    internal CookieToken Next(bool first, bool parseResponseCookies);
    internal void Reset();
    internal CookieToken TokenFromName(bool parseResponseCookies);
}
internal enum System.Net.EntitySendFormat : Enum {
    public int value__;
    public static EntitySendFormat ContentLength;
    public static EntitySendFormat Chunked;
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIAuthType SSPIAuth;
    internal static SSPISecureChannelType SSPISecureChannel;
    private static GlobalSSPI();
}
public class System.Net.HttpListener : object {
    private object _internalLock;
    private State modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private HttpListenerPrefixCollection _prefixes;
    internal Hashtable _uriPrefixes;
    private bool _ignoreWriteExceptions;
    private ServiceNameStore _defaultServiceNames;
    private HttpListenerTimeoutManager _timeoutManager;
    private ExtendedProtectionPolicy _extendedProtectionPolicy;
    private AuthenticationSchemeSelector _authenticationDelegate;
    private AuthenticationSchemes _authenticationScheme;
    private ExtendedProtectionSelector _extendedProtectionSelectorDelegate;
    private string _realm;
    internal static bool SkipIOCPCallbackOnSuccess;
    private static Byte[] s_wwwAuthenticateBytes;
    private SafeHandle _requestQueueHandle;
    private ThreadPoolBoundHandle _requestQueueBoundHandle;
    private bool _unsafeConnectionNtlmAuthentication;
    private HttpServerSessionHandle _serverSessionHandle;
    private ulong _urlGroupId;
    private bool _V2Initialized;
    private Dictionary`2<ulong, DisconnectAsyncResult> _disconnectResults;
    internal ICollection PrefixCollection { get; }
    public AuthenticationSchemeSelector AuthenticationSchemeSelectorDelegate { get; public set; }
    public ExtendedProtectionSelector ExtendedProtectionSelectorDelegate { get; public set; }
    public AuthenticationSchemes AuthenticationSchemes { get; public set; }
    public ExtendedProtectionPolicy ExtendedProtectionPolicy { get; public set; }
    public ServiceNameCollection DefaultServiceNames { get; }
    public HttpListenerPrefixCollection Prefixes { get; }
    public string Realm { get; public set; }
    public bool IsListening { get; }
    public bool IgnoreWriteExceptions { get; public set; }
    public static bool IsSupported { get; }
    internal SafeHandle RequestQueueHandle { get; }
    public bool UnsafeConnectionNtlmAuthentication { get; public set; }
    private Dictionary`2<ulong, DisconnectAsyncResult> DisconnectResults { get; }
    public HttpListenerTimeoutManager TimeoutManager { get; }
    internal ThreadPoolBoundHandle RequestQueueBoundHandle { get; }
    private static HttpListener();
    internal ICollection get_PrefixCollection();
    public AuthenticationSchemeSelector get_AuthenticationSchemeSelectorDelegate();
    public void set_AuthenticationSchemeSelectorDelegate(AuthenticationSchemeSelector value);
    public ExtendedProtectionSelector get_ExtendedProtectionSelectorDelegate();
    public void set_ExtendedProtectionSelectorDelegate(ExtendedProtectionSelector value);
    public AuthenticationSchemes get_AuthenticationSchemes();
    public void set_AuthenticationSchemes(AuthenticationSchemes value);
    public ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    public void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    public ServiceNameCollection get_DefaultServiceNames();
    public HttpListenerPrefixCollection get_Prefixes();
    internal void AddPrefix(string uriPrefix);
    internal bool ContainsPrefix(string uriPrefix);
    internal bool RemovePrefix(string uriPrefix);
    internal void RemoveAll(bool clear);
    public string get_Realm();
    public void set_Realm(string value);
    public bool get_IsListening();
    public bool get_IgnoreWriteExceptions();
    public void set_IgnoreWriteExceptions(bool value);
    public Task`1<HttpListenerContext> GetContextAsync();
    public void Close();
    internal void CheckDisposed();
    private sealed virtual override void System.IDisposable.Dispose();
    public static bool get_IsSupported();
    internal SafeHandle get_RequestQueueHandle();
    private void ValidateV2Property();
    public bool get_UnsafeConnectionNtlmAuthentication();
    public void set_UnsafeConnectionNtlmAuthentication(bool value);
    private Dictionary`2<ulong, DisconnectAsyncResult> get_DisconnectResults();
    private void SetUrlGroupProperty(HTTP_SERVER_PROPERTY property, IntPtr info, UInt32 infosize);
    internal void SetServerTimeout(Int32[] timeouts, UInt32 minSendBytesPerSecond);
    public HttpListenerTimeoutManager get_TimeoutManager();
    private IntPtr DangerousGetHandle();
    internal ThreadPoolBoundHandle get_RequestQueueBoundHandle();
    private void SetupV2Config();
    public void Start();
    private void CleanupV2Config();
    private void AttachRequestQueueToUrlGroup();
    private void DetachRequestQueueFromUrlGroup();
    public void Stop();
    private void CreateRequestQueueHandle();
    private void CloseRequestQueueHandle();
    public void Abort();
    private void Dispose();
    private void RemovePrefixCore(string uriPrefix);
    private void AddAllPrefixes();
    private void AddPrefixCore(string registeredPrefix);
    public HttpListenerContext GetContext();
    internal bool ValidateRequest(RequestContextBase requestMemory);
    public IAsyncResult BeginGetContext(AsyncCallback callback, object state);
    public HttpListenerContext EndGetContext(IAsyncResult asyncResult);
    internal HttpListenerContext HandleAuthentication(RequestContextBase memoryBlob, Boolean& stoleBlob);
    private static void FreeContext(HttpListenerContext& httpContext, RequestContextBase memoryBlob);
    internal void SetAuthenticationHeaders(HttpListenerContext context);
    private ChannelBinding GetChannelBinding(ulong connectionId, bool isSecureConnection, ExtendedProtectionPolicy policy);
    private bool CheckSpn(NTAuthentication context, bool isSecureConnection, ExtendedProtectionPolicy policy);
    private ServiceNameCollection GetServiceNames(ExtendedProtectionPolicy policy);
    private static bool ScenarioChecksChannelBinding(bool isSecureConnection, ProtectionScenario scenario);
    private ContextFlagsPal GetContextFlags(ExtendedProtectionPolicy policy, bool isSecureConnection);
    private HttpStatusCode HttpStatusFromSecurityStatus(SecurityStatusPalErrorCode statusErrorCode);
    internal static bool IsCredentialFailure(SecurityStatusPalErrorCode error);
    internal static bool IsClientFault(SecurityStatusPalErrorCode error);
    private static void AddChallenge(ArrayList& challenges, string challenge);
    private ArrayList BuildChallenge(AuthenticationSchemes authenticationScheme, ulong connectionId, NTAuthentication& newContext, ExtendedProtectionPolicy policy, bool isSecureConnection);
    private void RegisterForDisconnectNotification(ulong connectionId, DisconnectAsyncResult& disconnectResult);
    private void SendError(ulong requestId, HttpStatusCode httpStatusCode, ArrayList challenges);
    private static int GetTokenOffsetFromBlob(IntPtr blob);
    private static int GetTokenSizeFromBlob(IntPtr blob);
    internal ChannelBinding GetChannelBindingFromTls(ulong connectionId);
}
public class System.Net.HttpListenerBasicIdentity : GenericIdentity {
    [CompilerGeneratedAttribute]
private string <Password>k__BackingField;
    public string Password { get; }
    public HttpListenerBasicIdentity(string username, string password);
    [CompilerGeneratedAttribute]
public virtual string get_Password();
}
public class System.Net.HttpListenerContext : object {
    internal HttpListener _listener;
    private HttpListenerResponse _response;
    private IPrincipal _user;
    [CompilerGeneratedAttribute]
private HttpListenerRequest <Request>k__BackingField;
    [CompilerGeneratedAttribute]
private AuthenticationSchemes <AuthenticationSchemes>k__BackingField;
    private string _mutualAuthentication;
    [CompilerGeneratedAttribute]
private ExtendedProtectionPolicy <ExtendedProtectionPolicy>k__BackingField;
    public HttpListenerRequest Request { get; }
    public IPrincipal User { get; }
    internal AuthenticationSchemes AuthenticationSchemes { get; internal set; }
    public HttpListenerResponse Response { get; }
    internal ExtendedProtectionPolicy ExtendedProtectionPolicy { get; internal set; }
    internal string MutualAuthentication { get; }
    internal HttpListener Listener { get; }
    internal SafeHandle RequestQueueHandle { get; }
    internal ThreadPoolBoundHandle RequestQueueBoundHandle { get; }
    internal ulong RequestId { get; }
    internal HttpListenerContext(HttpListener httpListener, RequestContextBase memoryBlob);
    [CompilerGeneratedAttribute]
public HttpListenerRequest get_Request();
    public IPrincipal get_User();
    [CompilerGeneratedAttribute]
internal AuthenticationSchemes get_AuthenticationSchemes();
    [CompilerGeneratedAttribute]
internal void set_AuthenticationSchemes(AuthenticationSchemes value);
    public HttpListenerResponse get_Response();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol);
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, TimeSpan keepAliveInterval);
    internal void SetIdentity(IPrincipal principal, string mutualAuthentication);
    [CompilerGeneratedAttribute]
internal ExtendedProtectionPolicy get_ExtendedProtectionPolicy();
    [CompilerGeneratedAttribute]
internal void set_ExtendedProtectionPolicy(ExtendedProtectionPolicy value);
    internal string get_MutualAuthentication();
    internal HttpListener get_Listener();
    internal SafeHandle get_RequestQueueHandle();
    internal ThreadPoolBoundHandle get_RequestQueueBoundHandle();
    internal ulong get_RequestId();
    public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval);
    [EditorBrowsableAttribute("1")]
public Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal void Close();
    internal void Abort();
    internal HTTP_VERB GetKnownMethod();
    internal static void CancelRequest(SafeHandle requestQueueHandle, ulong requestId);
    internal void ForceCancelRequest(SafeHandle requestQueueHandle, ulong requestId);
    internal void SetAuthenticationHeaders();
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.HttpListenerException : Win32Exception {
    public int ErrorCode { get; }
    public HttpListenerException(int errorCode);
    public HttpListenerException(int errorCode, string message);
    protected HttpListenerException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual int get_ErrorCode();
}
public class System.Net.HttpListenerPrefixCollection : object {
    private HttpListener _httpListener;
    public int Count { get; }
    public bool IsSynchronized { get; }
    public bool IsReadOnly { get; }
    internal HttpListenerPrefixCollection(HttpListener listener);
    public void CopyTo(Array array, int offset);
    public sealed virtual void CopyTo(String[] array, int offset);
    public sealed virtual int get_Count();
    public bool get_IsSynchronized();
    public sealed virtual bool get_IsReadOnly();
    public sealed virtual void Add(string uriPrefix);
    public sealed virtual bool Contains(string uriPrefix);
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
    public sealed virtual IEnumerator`1<string> GetEnumerator();
    public sealed virtual bool Remove(string uriPrefix);
    public sealed virtual void Clear();
}
public class System.Net.HttpListenerRequest : object {
    private CookieCollection _cookies;
    private Nullable`1<bool> _keepAlive;
    private string _rawUrl;
    private Uri _requestUri;
    private Version _version;
    [CompilerGeneratedAttribute]
private ListenerClientCertState <ClientCertState>k__BackingField;
    [CompilerGeneratedAttribute]
private X509Certificate2 <ClientCertificate>k__BackingField;
    private ulong _requestId;
    internal ulong _connectionId;
    private SslStatus _sslStatus;
    private string _cookedUrlHost;
    private string _cookedUrlPath;
    private string _cookedUrlQuery;
    private long _contentLength;
    private Stream _requestStream;
    private string _httpMethod;
    private WebHeaderCollection _webHeaders;
    private IPEndPoint _localEndPoint;
    private IPEndPoint _remoteEndPoint;
    private BoundaryType _boundaryType;
    private int _clientCertificateError;
    private RequestContextBase _memoryBlob;
    private HttpListenerContext _httpContext;
    private bool _isDisposed;
    private string _serviceName;
    private object _lock;
    public String[] AcceptTypes { get; }
    public String[] UserLanguages { get; }
    public CookieCollection Cookies { get; }
    public Encoding ContentEncoding { get; }
    public string ContentType { get; }
    public bool IsLocal { get; }
    public bool IsWebSocketRequest { get; }
    public bool KeepAlive { get; }
    public NameValueCollection QueryString { get; }
    public string RawUrl { get; }
    private string RequestScheme { get; }
    public string UserAgent { get; }
    public string UserHostAddress { get; }
    public string UserHostName { get; }
    public Uri UrlReferrer { get; }
    public Uri Url { get; }
    public Version ProtocolVersion { get; }
    internal ListenerClientCertState ClientCertState { get; internal set; }
    internal X509Certificate2 ClientCertificate { get; internal set; }
    public int ClientCertificateError { get; }
    internal HttpListenerContext HttpListenerContext { get; }
    internal IntPtr RequestBuffer { get; }
    internal IntPtr OriginalBlobAddress { get; }
    internal ulong RequestId { get; }
    public Guid RequestTraceIdentifier { get; }
    public long ContentLength64 { get; }
    public NameValueCollection Headers { get; }
    public string HttpMethod { get; }
    public Stream InputStream { get; }
    public bool IsAuthenticated { get; }
    public bool IsSecureConnection { get; }
    public string ServiceName { get; internal set; }
    public TransportContext TransportContext { get; }
    public bool HasEntityBody { get; }
    public IPEndPoint RemoteEndPoint { get; }
    public IPEndPoint LocalEndPoint { get; }
    private Uri RequestUri { get; }
    private bool SupportsWebSockets { get; }
    internal HttpListenerRequest(HttpListenerContext httpContext, RequestContextBase memoryBlob);
    public String[] get_AcceptTypes();
    public String[] get_UserLanguages();
    private CookieCollection ParseCookies(Uri uri, string setCookieHeader);
    public CookieCollection get_Cookies();
    public Encoding get_ContentEncoding();
    public string get_ContentType();
    public bool get_IsLocal();
    public bool get_IsWebSocketRequest();
    public bool get_KeepAlive();
    public NameValueCollection get_QueryString();
    public string get_RawUrl();
    private string get_RequestScheme();
    public string get_UserAgent();
    public string get_UserHostAddress();
    public string get_UserHostName();
    public Uri get_UrlReferrer();
    public Uri get_Url();
    public Version get_ProtocolVersion();
    public X509Certificate2 GetClientCertificate();
    public IAsyncResult BeginGetClientCertificate(AsyncCallback requestCallback, object state);
    public Task`1<X509Certificate2> GetClientCertificateAsync();
    [CompilerGeneratedAttribute]
internal ListenerClientCertState get_ClientCertState();
    [CompilerGeneratedAttribute]
internal void set_ClientCertState(ListenerClientCertState value);
    [CompilerGeneratedAttribute]
internal X509Certificate2 get_ClientCertificate();
    [CompilerGeneratedAttribute]
internal void set_ClientCertificate(X509Certificate2 value);
    public int get_ClientCertificateError();
    internal HttpListenerContext get_HttpListenerContext();
    internal IntPtr get_RequestBuffer();
    internal IntPtr get_OriginalBlobAddress();
    internal void DetachBlob(RequestContextBase memoryBlob);
    internal void ReleasePins();
    internal ulong get_RequestId();
    public Guid get_RequestTraceIdentifier();
    public long get_ContentLength64();
    public NameValueCollection get_Headers();
    public string get_HttpMethod();
    public Stream get_InputStream();
    public bool get_IsAuthenticated();
    public bool get_IsSecureConnection();
    public string get_ServiceName();
    internal void set_ServiceName(string value);
    private int GetClientCertificateErrorCore();
    internal void SetClientCertificateError(int clientCertificateError);
    public X509Certificate2 EndGetClientCertificate(IAsyncResult asyncResult);
    public TransportContext get_TransportContext();
    public bool get_HasEntityBody();
    public IPEndPoint get_RemoteEndPoint();
    public IPEndPoint get_LocalEndPoint();
    internal void Close();
    private ListenerClientCertAsyncResult BeginGetClientCertificateCore(AsyncCallback requestCallback, object state);
    private void GetClientCertificateCore();
    private Uri get_RequestUri();
    internal ChannelBinding GetChannelBinding();
    internal void CheckDisposed();
    private bool get_SupportsWebSockets();
}
internal class System.Net.HttpListenerRequestContext : TransportContext {
    private HttpListenerRequest _request;
    internal HttpListenerRequestContext(HttpListenerRequest request);
    public virtual ChannelBinding GetChannelBinding(ChannelBindingKind kind);
}
internal class System.Net.HttpListenerRequestUriBuilder : object {
    private static Encoding s_utf8Encoding;
    private static Encoding s_ansiEncoding;
    private string _rawUri;
    private string _cookedUriScheme;
    private string _cookedUriHost;
    private string _cookedUriPath;
    private string _cookedUriQuery;
    private StringBuilder _requestUriString;
    private List`1<byte> _rawOctets;
    private string _rawPath;
    private Uri _requestUri;
    private HttpListenerRequestUriBuilder(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private static HttpListenerRequestUriBuilder();
    public static Uri GetRequestUri(string rawUri, string cookedUriScheme, string cookedUriHost, string cookedUriPath, string cookedUriQuery);
    private Uri Build();
    private void BuildRequestUriUsingCookedPath();
    private void BuildRequestUriUsingRawPath();
    private static Encoding GetEncoding(EncodingType type);
    private ParsingResult BuildRequestUriUsingRawPath(Encoding encoding);
    private ParsingResult ParseRawPath(Encoding encoding);
    private bool AppendUnicodeCodePointValuePercentEncoded(string codePoint);
    private bool AddPercentEncodedOctetToRawOctetsList(Encoding encoding, string escapedCharacter);
    private bool EmptyDecodeAndAppendRawOctetsList(Encoding encoding);
    private static void AppendOctetsPercentEncoded(StringBuilder target, IEnumerable`1<byte> octets);
    private static string GetOctetsAsString(IEnumerable`1<byte> octets);
    private static string GetPath(string uriString);
    private static string AddSlashToAsteriskOnlyPath(string path);
}
public class System.Net.HttpListenerResponse : object {
    private BoundaryType _boundaryType;
    private CookieCollection _cookies;
    private HttpListenerContext _httpContext;
    private bool _keepAlive;
    private HttpResponseStream _responseStream;
    private string _statusDescription;
    private WebHeaderCollection _webHeaders;
    [CompilerGeneratedAttribute]
private Encoding <ContentEncoding>k__BackingField;
    private static Int32[] s_noResponseBody;
    private ResponseState _responseState;
    private long _contentLength;
    private HTTP_RESPONSE _nativeResponse;
    public WebHeaderCollection Headers { get; public set; }
    public Encoding ContentEncoding { get; public set; }
    public string ContentType { get; public set; }
    private HttpListenerContext HttpListenerContext { get; }
    private HttpListenerRequest HttpListenerRequest { get; }
    internal EntitySendFormat EntitySendFormat { get; internal set; }
    public bool SendChunked { get; public set; }
    public long ContentLength64 { get; public set; }
    public CookieCollection Cookies { get; public set; }
    public bool KeepAlive { get; public set; }
    public Stream OutputStream { get; }
    public string RedirectLocation { get; public set; }
    public string StatusDescription { get; public set; }
    public int StatusCode { get; public set; }
    public Version ProtocolVersion { get; public set; }
    internal BoundaryType BoundaryType { get; }
    internal bool ComputedHeaders { get; }
    internal bool SentHeaders { get; }
    private bool Disposed { get; }
    internal HttpListenerResponse(HttpListenerContext httpContext);
    private static HttpListenerResponse();
    public WebHeaderCollection get_Headers();
    public void set_Headers(WebHeaderCollection value);
    [CompilerGeneratedAttribute]
public Encoding get_ContentEncoding();
    [CompilerGeneratedAttribute]
public void set_ContentEncoding(Encoding value);
    public string get_ContentType();
    public void set_ContentType(string value);
    private HttpListenerContext get_HttpListenerContext();
    private HttpListenerRequest get_HttpListenerRequest();
    internal EntitySendFormat get_EntitySendFormat();
    internal void set_EntitySendFormat(EntitySendFormat value);
    public bool get_SendChunked();
    public void set_SendChunked(bool value);
    private static bool CanSendResponseBody(int responseCode);
    public long get_ContentLength64();
    public void set_ContentLength64(long value);
    public CookieCollection get_Cookies();
    public void set_Cookies(CookieCollection value);
    public bool get_KeepAlive();
    public void set_KeepAlive(bool value);
    public Stream get_OutputStream();
    public string get_RedirectLocation();
    public void set_RedirectLocation(string value);
    public string get_StatusDescription();
    public void set_StatusDescription(string value);
    public void AddHeader(string name, string value);
    public void AppendHeader(string name, string value);
    public void AppendCookie(Cookie cookie);
    private void ComputeCookies();
    public void Redirect(string url);
    public void SetCookie(Cookie cookie);
    private sealed virtual override void System.IDisposable.Dispose();
    private void CheckDisposed();
    private void CheckSentHeaders();
    public int get_StatusCode();
    public void set_StatusCode(int value);
    public void CopyFrom(HttpListenerResponse templateResponse);
    public Version get_ProtocolVersion();
    public void set_ProtocolVersion(Version value);
    public void Abort();
    public void Close();
    public void Close(Byte[] responseEntity, bool willBlock);
    private void Dispose();
    internal BoundaryType get_BoundaryType();
    private void EnsureResponseStream();
    private void NonBlockingCloseCallback(IAsyncResult asyncResult);
    internal UInt32 SendHeaders(HTTP_DATA_CHUNK* pDataChunk, HttpResponseStreamAsyncResult asyncResult, HTTP_FLAGS flags, bool isWebSocketHandshake);
    internal HTTP_FLAGS ComputeHeaders();
    internal void ComputeCoreHeaders();
    private List`1<GCHandle> SerializeHeaders(HTTP_RESPONSE_HEADERS& headers, bool isWebSocketHandshake);
    private void FreePinnedHeaders(List`1<GCHandle> pinnedHeaders);
    internal void CancelLastWrite(SafeHandle requestQueueHandle);
    internal bool get_ComputedHeaders();
    internal bool get_SentHeaders();
    private bool get_Disposed();
}
public class System.Net.HttpListenerTimeoutManager : object {
    private HttpListener _listener;
    private Int32[] _timeouts;
    private UInt32 _minSendBytesPerSecond;
    public TimeSpan EntityBody { get; public set; }
    public TimeSpan DrainEntityBody { get; public set; }
    public TimeSpan RequestQueue { get; public set; }
    public TimeSpan IdleConnection { get; public set; }
    public TimeSpan HeaderWait { get; public set; }
    public long MinSendBytesPerSecond { get; public set; }
    internal HttpListenerTimeoutManager(HttpListener context);
    private TimeSpan GetTimeout(HTTP_TIMEOUT_TYPE type);
    private void SetTimespanTimeout(HTTP_TIMEOUT_TYPE type, TimeSpan value);
    public TimeSpan get_EntityBody();
    public void set_EntityBody(TimeSpan value);
    public TimeSpan get_DrainEntityBody();
    public void set_DrainEntityBody(TimeSpan value);
    public TimeSpan get_RequestQueue();
    public void set_RequestQueue(TimeSpan value);
    public TimeSpan get_IdleConnection();
    public void set_IdleConnection(TimeSpan value);
    public TimeSpan get_HeaderWait();
    public void set_HeaderWait(TimeSpan value);
    public long get_MinSendBytesPerSecond();
    public void set_MinSendBytesPerSecond(long value);
}
internal class System.Net.HttpRequestQueueV2Handle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.HttpRequestStream : Stream {
    private bool _closed;
    private HttpListenerContext _httpContext;
    private UInt32 _dataChunkOffset;
    private int _dataChunkIndex;
    private bool _inOpaqueMode;
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public bool CanRead { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal bool Closed { get; }
    internal bool BufferedDataChunksAvailable { get; }
    internal HttpListenerContext InternalHttpContext { get; }
    internal HttpRequestStream(HttpListenerContext httpContext);
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual bool get_CanRead();
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    internal bool get_Closed();
    protected virtual void Dispose(bool disposing);
    internal bool get_BufferedDataChunksAvailable();
    internal HttpListenerContext get_InternalHttpContext();
    private int ReadCore(Byte[] buffer, int offset, int size);
    private void UpdateAfterRead(UInt32 statusCode, UInt32 dataRead);
    public IAsyncResult BeginReadCore(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    internal void SwitchToOpaqueMode();
    internal UInt32 GetChunks(Byte[] buffer, int offset, int size);
}
internal class System.Net.HttpResponseStream : Stream {
    private bool _closed;
    private HttpListenerContext _httpContext;
    private long _leftToWrite;
    private bool _inOpaqueMode;
    private HttpResponseStreamAsyncResult _lastWrite;
    private static Byte[] s_chunkTerminator;
    internal bool Closed { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    internal HttpListenerContext InternalHttpContext { get; }
    internal HttpResponseStream(HttpListenerContext httpContext);
    private static HttpResponseStream();
    internal bool get_Closed();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    protected virtual void Dispose(bool disposing);
    internal HTTP_FLAGS ComputeLeftToWrite();
    internal HttpListenerContext get_InternalHttpContext();
    internal void SetClosedFlag();
    private void WriteCore(Byte[] buffer, int offset, int size);
    private IAsyncResult BeginWriteCore(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    private void EndWriteCore(IAsyncResult asyncResult);
    private void UpdateAfterWrite(UInt32 dataWritten);
    private void DisposeCore();
    internal void SwitchToOpaqueMode();
    internal void CancelLastWrite(SafeHandle requestQueueHandle);
}
internal class System.Net.HttpResponseStreamAsyncResult : LazyAsyncResult {
    private ThreadPoolBoundHandle _boundHandle;
    internal NativeOverlapped* _pOverlapped;
    private HTTP_DATA_CHUNK[] _dataChunks;
    internal bool _sentHeaders;
    private static IOCompletionCallback s_IOCallback;
    private static Byte[] s_CRLFArray;
    internal ushort dataChunkCount { get; }
    internal HTTP_DATA_CHUNK* pDataChunks { get; }
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback);
    internal HttpResponseStreamAsyncResult(object asyncObject, object userState, AsyncCallback callback, Byte[] buffer, int offset, int size, bool chunked, bool sentHeaders, ThreadPoolBoundHandle boundHandle);
    private static HttpResponseStreamAsyncResult();
    internal ushort get_dataChunkCount();
    internal HTTP_DATA_CHUNK* get_pDataChunks();
    private static Byte[] GetChunkHeader(int size, Int32& offset);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(HttpResponseStreamAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void Callback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    protected virtual void Cleanup();
}
internal class System.Net.HttpServerSessionHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private ulong _serverSessionId;
    internal HttpServerSessionHandle(ulong id);
    internal ulong DangerousGetServerSessionId();
    protected virtual bool ReleaseHandle();
}
internal static class System.Net.HttpStatusDescription : object {
    internal static string Get(HttpStatusCode code);
    internal static string Get(int code);
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _errorCode;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; }
    internal bool EndCalled { get; internal set; }
    internal int ErrorCode { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    internal int get_ErrorCode();
    internal void set_ErrorCode(int value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
    internal void InternalCleanup();
}
internal class System.Net.ListenerAsyncResult : LazyAsyncResult {
    private static IOCompletionCallback s_ioCallback;
    private AsyncRequestContext _requestContext;
    internal static IOCompletionCallback IOCallback { get; }
    internal ListenerAsyncResult(HttpListener listener, object userState, AsyncCallback callback);
    private static ListenerAsyncResult();
    internal static IOCompletionCallback get_IOCallback();
    private static void IOCompleted(ListenerAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    internal UInt32 QueueBeginGetContext();
    protected virtual void Cleanup();
}
internal class System.Net.ListenerClientCertAsyncResult : LazyAsyncResult {
    private ThreadPoolBoundHandle _boundHandle;
    private NativeOverlapped* _pOverlapped;
    private Byte[] _backingBuffer;
    private HTTP_SSL_CLIENT_CERT_INFO* _memoryBlob;
    private UInt32 _size;
    private static IOCompletionCallback s_IOCallback;
    internal NativeOverlapped* NativeOverlapped { get; }
    internal HTTP_SSL_CLIENT_CERT_INFO* RequestBlob { get; }
    internal ListenerClientCertAsyncResult(ThreadPoolBoundHandle boundHandle, object asyncObject, object userState, AsyncCallback callback, UInt32 size);
    private static ListenerClientCertAsyncResult();
    internal NativeOverlapped* get_NativeOverlapped();
    internal HTTP_SSL_CLIENT_CERT_INFO* get_RequestBlob();
    internal void Reset(UInt32 size);
    internal void IOCompleted(UInt32 errorCode, UInt32 numBytes);
    private static void IOCompleted(ListenerClientCertAsyncResult asyncResult, UInt32 errorCode, UInt32 numBytes);
    private static void WaitCallback(UInt32 errorCode, UInt32 numBytes, NativeOverlapped* nativeOverlapped);
    protected virtual void Cleanup();
    protected virtual override void Finalize();
}
internal enum System.Net.ListenerClientCertState : Enum {
    public int value__;
    public static ListenerClientCertState NotInitialized;
    public static ListenerClientCertState InProgress;
    public static ListenerClientCertState Completed;
}
internal class System.Net.ListenerPrefixEnumerator : object {
    private IEnumerator _enumerator;
    public string Current { get; }
    private object System.Collections.IEnumerator.Current { get; }
    internal ListenerPrefixEnumerator(IEnumerator enumerator);
    public sealed virtual string get_Current();
    public sealed virtual bool MoveNext();
    public sealed virtual void Dispose();
    private sealed virtual override void System.Collections.IEnumerator.Reset();
    private sealed virtual override object System.Collections.IEnumerator.get_Current();
}
internal static class System.Net.NegotiationInfoClass : object {
    internal static string GetAuthenticationPackageName(SafeHandle safeHandle, int negotiationState);
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, Byte[] buffer, int offset, int count, string memberName);
    [NonEventAttribute]
public static void DumpBuffer(object thisOrContextObject, IntPtr bufferPtr, int count, string memberName);
    [EventAttribute("7")]
private void DumpBuffer(string thisOrContextObject, string memberName, Byte[] buffer);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, Byte[] arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
    [EventAttribute("8")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("9")]
public void SspiPackageNotFound(string packageName);
    [EventAttribute("10")]
public void AcquireDefaultCredential(string packageName, CredentialUse intent);
    [NonEventAttribute]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata);
    [EventAttribute("11")]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata);
    [NonEventAttribute]
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags);
    [EventAttribute("12")]
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags);
    [NonEventAttribute]
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags);
    [EventAttribute("15")]
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags);
    [EventAttribute("16")]
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode);
    [EventAttribute("14")]
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode);
}
internal class System.Net.NTAuthentication : object {
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _package;
    private string _lastProtocolName;
    private string _protocolName;
    private string _clientSpecifiedSpn;
    private ChannelBinding _channelBinding;
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal string Package { get; }
    internal bool IsServer { get; }
    internal string ClientSpecifiedSpn { get; }
    internal string ProtocolName { get; }
    internal bool IsKerberos { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    internal string get_Package();
    internal bool get_IsServer();
    internal string get_ClientSpecifiedSpn();
    internal string get_ProtocolName();
    internal bool get_IsKerberos();
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal SafeDeleteContext GetContext(SecurityStatusPal& status);
    internal void CloseContext();
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
    private string GetClientSpecifiedSpn();
}
internal abstract class System.Net.RequestContextBase : object {
    private HTTP_REQUEST* _memoryBlob;
    private HTTP_REQUEST* _originalBlobAddress;
    private IntPtr _backingBuffer;
    private int _backingBufferLength;
    internal HTTP_REQUEST* RequestBlob { get; }
    internal IntPtr RequestBuffer { get; }
    internal UInt32 Size { get; }
    internal IntPtr OriginalBlobAddress { get; }
    protected void BaseConstruction(HTTP_REQUEST* requestBlob);
    internal void ReleasePins();
    protected abstract virtual void OnReleasePins();
    public void Close();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    protected virtual override void Finalize();
    internal HTTP_REQUEST* get_RequestBlob();
    internal IntPtr get_RequestBuffer();
    internal UInt32 get_Size();
    internal IntPtr get_OriginalBlobAddress();
    protected void SetBlob(HTTP_REQUEST* requestBlob);
    protected void UnsetBlob();
    protected void SetBuffer(int size);
}
internal class System.Net.SecPkgContext_NegotiationInfoW : ValueType {
    internal IntPtr PackageInfo;
    internal UInt32 NegotiationState;
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    internal static int QueryMaxTokenSize(string package);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static string QueryContextClientSpecifiedSpn(SafeDeleteContext securityContext);
    internal static string QueryContextAuthenticationPackage(SafeDeleteContext securityContext);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, Byte[] incomingBlob);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    internal CredHandle _handle;
    private static IdnMapping s_idnMapping;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, bool isContextAbsent, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate);
    internal static int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, bool isContextAbsent, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate);
    internal static int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inSecBuffer);
}
internal class System.Net.Security.SafeDeleteContext_SECURITY : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
}
internal class System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    internal CredHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
}
internal class System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecurityBuffer : ValueType {
    public int offset;
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
internal class System.Net.Security.SecurityContextTokenHandle : CriticalHandleZeroOrMinusOneIsInvalid {
    private int _disposed;
    internal IntPtr DangerousGetHandle();
    protected virtual bool ReleaseHandle();
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Net.Security.TwoSecurityBuffers : ValueType {
    internal SecurityBuffer _item0;
    private SecurityBuffer _item1;
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
internal static class System.Net.SecurityStatusAdapterPal : object {
    private static BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary;
    private static SecurityStatusAdapterPal();
    internal static SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException);
    internal static SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status);
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode DecryptFailure;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
}
internal class System.Net.ServiceNameStore : object {
    private List`1<string> _serviceNames;
    private ServiceNameCollection _serviceNameCollection;
    public ServiceNameCollection ServiceNames { get; }
    public ServiceNameCollection get_ServiceNames();
    private static string NormalizeServiceName(string inputServiceName);
    private bool AddSingleServiceName(string spn);
    public bool Add(string uriPrefix);
    public bool Remove(string uriPrefix);
    private bool Contains(string newServiceName);
    public void Clear();
    private string ExtractHostname(string uriPrefix, bool allowInvalidUriStrings);
    public string BuildSimpleServiceName(string uriPrefix);
    public String[] BuildServiceNames(string uriPrefix);
}
internal class System.Net.SSPIAuthType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private static int GetSecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& safeHandle);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal interface System.Net.SSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public abstract virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal class System.Net.SSPISecureChannelType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public sealed virtual int QuerySecurityContextToken(SafeDeleteContext phContext, SecurityContextTokenHandle& phToken);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal static class System.Net.SSPIWrapper : object {
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface secModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(SSPIInterface secModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    internal static int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer& inputBuffer);
    public static int QuerySecurityContextToken(SSPIInterface secModule, SafeDeleteContext context, SecurityContextTokenHandle& token);
    public static bool QueryBlittableContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, Type safeHandleType, SafeHandle& sspiHandle, T& attribute);
    public static string QueryStringContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.SyncRequestContext : RequestContextBase {
    internal SyncRequestContext(int size);
    private HTTP_REQUEST* Allocate(int newSize);
    internal void Reset(int size);
    protected virtual void OnReleasePins();
}
internal static class System.Net.WebHeaderEncoding : object {
    internal static string GetString(Byte[] bytes, int byteIndex, int byteCount);
    internal static string GetString(Byte* pBytes, int byteCount);
    internal static int GetByteCount(string myString);
    internal static void GetBytes(string myString, int charIndex, int charCount, Byte[] bytes, int byteIndex);
}
public class System.Net.WebSockets.HttpListenerWebSocketContext : WebSocketContext {
    private Uri _requestUri;
    private NameValueCollection _headers;
    private CookieCollection _cookieCollection;
    private IPrincipal _user;
    private bool _isAuthenticated;
    private bool _isLocal;
    private bool _isSecureConnection;
    private string _origin;
    private IEnumerable`1<string> _secWebSocketProtocols;
    private string _secWebSocketVersion;
    private string _secWebSocketKey;
    private WebSocket _webSocket;
    public Uri RequestUri { get; }
    public NameValueCollection Headers { get; }
    public string Origin { get; }
    public IEnumerable`1<string> SecWebSocketProtocols { get; }
    public string SecWebSocketVersion { get; }
    public string SecWebSocketKey { get; }
    public CookieCollection CookieCollection { get; }
    public IPrincipal User { get; }
    public bool IsAuthenticated { get; }
    public bool IsLocal { get; }
    public bool IsSecureConnection { get; }
    public WebSocket WebSocket { get; }
    internal HttpListenerWebSocketContext(Uri requestUri, NameValueCollection headers, CookieCollection cookieCollection, IPrincipal user, bool isAuthenticated, bool isLocal, bool isSecureConnection, string origin, IEnumerable`1<string> secWebSocketProtocols, string secWebSocketVersion, string secWebSocketKey, WebSocket webSocket);
    public virtual Uri get_RequestUri();
    public virtual NameValueCollection get_Headers();
    public virtual string get_Origin();
    public virtual IEnumerable`1<string> get_SecWebSocketProtocols();
    public virtual string get_SecWebSocketVersion();
    public virtual string get_SecWebSocketKey();
    public virtual CookieCollection get_CookieCollection();
    public virtual IPrincipal get_User();
    public virtual bool get_IsAuthenticated();
    public virtual bool get_IsLocal();
    public virtual bool get_IsSecureConnection();
    public virtual WebSocket get_WebSocket();
    private static IPrincipal CopyPrincipal(IPrincipal user);
}
[ExtensionAttribute]
internal static class System.Net.WebSockets.HttpWebSocket : object {
    private static Random s_keyGenerator;
    [CompilerGeneratedAttribute]
private static bool <WebSocketsSupported>k__BackingField;
    private static string SupportedVersion { get; }
    private static bool WebSocketsSupported { get; }
    private static HttpWebSocket();
    internal static string GetSecWebSocketAcceptString(string secWebSocketKey);
    internal static bool ProcessWebSocketProtocolHeader(string clientSecWebSocketProtocol, string subProtocol, String& acceptProtocol);
    internal static void ValidateOptions(string subProtocol, int receiveBufferSize, int sendBufferSize, TimeSpan keepAliveInterval);
    private static void ValidateWebSocketHeaders(HttpListenerContext context);
    internal static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsync(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    [AsyncStateMachineAttribute("System.Net.WebSockets.HttpWebSocket/<AcceptWebSocketAsyncCore>d__13")]
private static Task`1<HttpListenerWebSocketContext> AcceptWebSocketAsyncCore(HttpListenerContext context, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal static string GetTraceMsgForParameters(int offset, int count, CancellationToken cancellationToken);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable SuppressContextFlow(Task task);
    [ExtensionAttribute]
internal static ConfiguredTaskAwaitable`1<T> SuppressContextFlow(Task`1<T> task);
    private static ulong SendWebSocketHeaders(HttpListenerResponse response);
    internal static void ValidateInnerStream(Stream innerStream);
    internal static void ThrowIfConnectionAborted(Stream connection, bool read);
    internal static void ThrowPlatformNotSupportedException_WSPC();
    private static string get_SupportedVersion();
    [CompilerGeneratedAttribute]
private static bool get_WebSocketsSupported();
}
internal class System.Net.WebSockets.SafeWebSocketHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.WebSockets.ServerWebSocket : WebSocketBase {
    private SafeHandle _sessionHandle;
    private Property[] _properties;
    internal SafeHandle SessionHandle { get; }
    public ServerWebSocket(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal static WebSocket Create(Stream innerStream, string subProtocol, int receiveBufferSize, TimeSpan keepAliveInterval, ArraySegment`1<byte> internalBuffer);
    internal virtual SafeHandle get_SessionHandle();
    private SafeHandle CreateWebSocketHandle();
}
internal abstract class System.Net.WebSockets.WebSocketBase : WebSocket {
    private OutstandingOperationHelper _closeOutstandingOperationHelper;
    private OutstandingOperationHelper _closeOutputOutstandingOperationHelper;
    private OutstandingOperationHelper _receiveOutstandingOperationHelper;
    private OutstandingOperationHelper _sendOutstandingOperationHelper;
    private Stream _innerStream;
    private IWebSocketStream _innerStreamAsWebSocketStream;
    private string _subProtocol;
    private SemaphoreSlim _sendFrameThrottle;
    private object _thisLock;
    private WebSocketBuffer _internalBuffer;
    private KeepAliveTracker _keepAliveTracker;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _cleanedUp;
    private TaskCompletionSource`1 modreq(System.Runtime.CompilerServices.IsVolatile) _closeReceivedTaskCompletionSource;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _closeOutputTask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _isDisposed;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _closeNetworkConnectionTask;
    private Boolean modreq(System.Runtime.CompilerServices.IsVolatile) _closeAsyncStartedReceive;
    private WebSocketState modreq(System.Runtime.CompilerServices.IsVolatile) _state;
    private Task modreq(System.Runtime.CompilerServices.IsVolatile) _keepAliveTask;
    private ReceiveOperation modreq(System.Runtime.CompilerServices.IsVolatile) _receiveOperation;
    private SendOperation modreq(System.Runtime.CompilerServices.IsVolatile) _sendOperation;
    private SendOperation modreq(System.Runtime.CompilerServices.IsVolatile) _keepAliveOperation;
    private CloseOutputOperation modreq(System.Runtime.CompilerServices.IsVolatile) _closeOutputOperation;
    private Nullable`1<WebSocketCloseStatus> _closeStatus;
    private string _closeStatusDescription;
    private int _receiveState;
    private Exception _pendingException;
    public WebSocketState State { get; }
    public string SubProtocol { get; }
    public Nullable`1<WebSocketCloseStatus> CloseStatus { get; }
    public string CloseStatusDescription { get; }
    internal WebSocketBuffer InternalBuffer { get; }
    internal SafeHandle SessionHandle { get; }
    protected WebSocketBase(Stream innerStream, string subProtocol, TimeSpan keepAliveInterval, WebSocketBuffer internalBuffer);
    public virtual WebSocketState get_State();
    public virtual string get_SubProtocol();
    public virtual Nullable`1<WebSocketCloseStatus> get_CloseStatus();
    public virtual string get_CloseStatusDescription();
    internal WebSocketBuffer get_InternalBuffer();
    protected void StartKeepAliveTimer();
    internal abstract virtual SafeHandle get_SessionHandle();
    public virtual Task`1<WebSocketReceiveResult> ReceiveAsync(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<ReceiveAsyncCore>d__42")]
private Task`1<WebSocketReceiveResult> ReceiveAsyncCore(ArraySegment`1<byte> buffer, CancellationToken cancellationToken);
    public virtual Task SendAsync(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<SendAsyncCore>d__44")]
private Task SendAsyncCore(ArraySegment`1<byte> buffer, WebSocketMessageType messageType, bool endOfMessage, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<SendFrameAsync>d__45")]
private Task SendFrameAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public virtual void Abort();
    public virtual Task CloseOutputAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<CloseOutputAsyncCore>d__48")]
private Task CloseOutputAsyncCore(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    private bool OnCloseOutputCompleted();
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<StartOnCloseCompleted>d__50")]
private Task`1<bool> StartOnCloseCompleted(bool thisLockTakenSnapshot, bool sessionHandleLockTakenSnapshot, CancellationToken cancellationToken);
    private void FinishOnCloseCompleted();
    public virtual Task CloseAsync(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<CloseAsyncCore>d__53")]
private Task CloseAsyncCore(WebSocketCloseStatus closeStatus, string statusDescription, CancellationToken cancellationToken);
    public virtual void Dispose();
    private void ResetFlagAndTakeLock(object lockObject, Boolean& thisLockTaken);
    private void ResetFlagsAndTakeLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void TakeLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void ReleaseLocks(Boolean& thisLockTaken, Boolean& sessionHandleLockTaken);
    private void EnsureReceiveOperation();
    private void EnsureSendOperation();
    private void EnsureKeepAliveOperation();
    private void EnsureCloseOutputOperation();
    private static void ReleaseLock(object lockObject, Boolean& lockTaken);
    private static BufferType GetBufferType(WebSocketMessageType messageType, bool endOfMessage);
    private static WebSocketMessageType GetMessageType(BufferType bufferType);
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    private void ThrowIfAborted(bool aborted, Exception innerException);
    private bool CanHandleExceptionDuringClose(Exception error);
    private void ThrowIfConvertibleException(string methodName, Exception exception, CancellationToken cancellationToken, bool aborted);
    private void CleanUp();
    private void OnBackgroundTaskException(Exception exception);
    private void ThrowIfPendingException();
    private void ThrowIfDisposed();
    private void UpdateReceiveState(int newReceiveState, int expectedReceiveState);
    private bool StartOnCloseReceived(Boolean& thisLockTaken);
    private void FinishOnCloseReceived(WebSocketCloseStatus closeStatus, string closeStatusDescription);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketBase/<OnKeepAlive>d__77")]
private static void OnKeepAlive(object sender);
}
internal class System.Net.WebSockets.WebSocketBuffer : object {
    private static int s_PropertyBufferSize;
    private int _receiveBufferSize;
    private long _startAddress;
    private long _endAddress;
    private GCHandle _gcHandle;
    private ArraySegment`1<byte> _internalBuffer;
    private ArraySegment`1<byte> _nativeBuffer;
    private ArraySegment`1<byte> _payloadBuffer;
    private ArraySegment`1<byte> _propertyBuffer;
    private int _sendBufferSize;
    private Int32 modreq(System.Runtime.CompilerServices.IsVolatile) _payloadOffset;
    private PayloadReceiveResult modreq(System.Runtime.CompilerServices.IsVolatile) _bufferedPayloadReceiveResult;
    private long _pinnedSendBufferStartAddress;
    private long _pinnedSendBufferEndAddress;
    private ArraySegment`1<byte> _pinnedSendBuffer;
    private GCHandle _pinnedSendBufferHandle;
    private int _stateWhenDisposing;
    private int _sendBufferState;
    public int ReceiveBufferSize { get; }
    public int SendBufferSize { get; }
    private WebSocketBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize, int sendBufferSize);
    private static WebSocketBuffer();
    public int get_ReceiveBufferSize();
    public int get_SendBufferSize();
    internal static WebSocketBuffer CreateServerBuffer(ArraySegment`1<byte> internalBuffer, int receiveBufferSize);
    public void Dispose(WebSocketState webSocketState);
    public sealed virtual void Dispose();
    internal Property[] CreateProperties(bool useZeroMaskingKey);
    internal void PinSendBuffer(ArraySegment`1<byte> payload, Boolean& bufferHasBeenPinned);
    internal IntPtr ConvertPinnedSendPayloadToNative(ArraySegment`1<byte> payload);
    internal IntPtr ConvertPinnedSendPayloadToNative(Byte[] buffer, int offset, int count);
    internal ArraySegment`1<byte> ConvertPinnedSendPayloadFromNative(Buffer buffer, BufferType bufferType);
    private bool IsPinnedSendPayloadBuffer(Byte[] buffer, int offset, int count);
    internal bool IsPinnedSendPayloadBuffer(Buffer buffer, BufferType bufferType);
    internal void ReleasePinnedSendBuffer();
    internal void BufferPayload(ArraySegment`1<byte> payload, int unconsumedDataOffset, WebSocketMessageType messageType, bool endOfMessage);
    internal bool ReceiveFromBufferedPayload(ArraySegment`1<byte> buffer, WebSocketReceiveResult& receiveResult);
    internal ArraySegment`1<byte> ConvertNativeBuffer(Action action, Buffer buffer, BufferType bufferType);
    internal void ConvertCloseBuffer(Action action, Buffer buffer, WebSocketCloseStatus& closeStatus, String& reason);
    internal void ValidateNativeBuffers(Action action, BufferType bufferType, Buffer[] dataBuffers, UInt32 dataBufferCount);
    private static int GetNativeSendBufferSize(int sendBufferSize, bool isServerBuffer);
    internal static void UnwrapWebSocketBuffer(Buffer buffer, BufferType bufferType, IntPtr& bufferData, UInt32& bufferLength);
    private void ThrowIfDisposed();
    private int GetOffset(IntPtr pBuffer);
    private int GetMaxBufferSize();
    internal bool IsInternalBuffer(Byte[] buffer, int offset, int count);
    internal IntPtr ToIntPtr(int offset);
    private bool IsNativeBuffer(IntPtr pBuffer, UInt32 bufferSize);
    private void CleanUp();
    internal static ArraySegment`1<byte> CreateInternalBufferArraySegment(int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
    internal static void Validate(int count, int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
    private static int GetInternalBufferSize(int receiveBufferSize, int sendBufferSize, bool isServerBuffer);
}
internal class System.Net.WebSockets.WebSocketHttpListenerDuplexStream : Stream {
    private static EventHandler`1<HttpListenerAsyncEventArgs> s_OnReadCompleted;
    private static EventHandler`1<HttpListenerAsyncEventArgs> s_OnWriteCompleted;
    private static Func`2<Exception, bool> s_CanHandleException;
    private static Action`1<object> s_OnCancel;
    private HttpRequestStream _inputStream;
    private HttpResponseStream _outputStream;
    private HttpListenerContext _context;
    private bool _inOpaqueMode;
    private WebSocketBase _webSocket;
    private HttpListenerAsyncEventArgs _writeEventArgs;
    private HttpListenerAsyncEventArgs _readEventArgs;
    private TaskCompletionSource`1<object> _writeTaskCompletionSource;
    private TaskCompletionSource`1<int> _readTaskCompletionSource;
    private int _cleanedUp;
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanTimeout { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    public bool SupportsMultipleWrite { get; }
    public WebSocketHttpListenerDuplexStream(HttpRequestStream inputStream, HttpResponseStream outputStream, HttpListenerContext context);
    private static WebSocketHttpListenerDuplexStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanTimeout();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<ReadAsyncCore>d__30")]
private Task`1<int> ReadAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool ReadAsyncFast(HttpListenerAsyncEventArgs eventArgs);
    public virtual int ReadByte();
    public sealed virtual bool get_SupportsMultipleWrite();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public sealed virtual Task MultipleWriteAsync(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<MultipleWriteAsyncCore>d__38")]
private Task MultipleWriteAsyncCore(IList`1<ArraySegment`1<byte>> sendBuffers, CancellationToken cancellationToken);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<WriteAsyncCore>d__41")]
private Task WriteAsyncCore(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    private bool WriteAsyncFast(HttpListenerAsyncEventArgs eventArgs);
    public virtual void WriteByte(byte value);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    [AsyncStateMachineAttribute("System.Net.WebSockets.WebSocketHttpListenerDuplexStream/<CloseNetworkConnectionAsync>d__50")]
public sealed virtual Task CloseNetworkConnectionAsync(CancellationToken cancellationToken);
    protected virtual void Dispose(bool disposing);
    public sealed virtual void Abort();
    private static bool CanHandleException(Exception error);
    private static void OnCancel(object state);
    public sealed virtual void SwitchToOpaqueMode(WebSocketBase webSocket);
    private static void OnWriteCompleted(object sender, HttpListenerAsyncEventArgs eventArgs);
    private static void OnReadCompleted(object sender, HttpListenerAsyncEventArgs eventArgs);
}
internal static class System.Net.WebSockets.WebSocketProtocolComponent : object {
    private static string s_dummyWebsocketKeyBase64;
    private static SafeLibraryHandle s_webSocketDllHandle;
    private static string s_supportedVersion;
    private static HttpHeader[] s_initialClientRequestHeaders;
    private static HttpHeader[] s_ServerFakeRequestHeaders;
    internal static string SupportedVersion { get; }
    internal static bool IsSupported { get; }
    private static WebSocketProtocolComponent();
    internal static string get_SupportedVersion();
    internal static bool get_IsSupported();
    internal static string GetSupportedVersion();
    internal static void WebSocketCreateServerHandle(Property[] properties, int propertyCount, SafeWebSocketHandle& webSocketHandle);
    internal static void WebSocketAbortHandle(SafeHandle webSocketHandle);
    internal static void WebSocketDeleteHandle(IntPtr webSocketPtr);
    internal static void WebSocketSend(WebSocketBase webSocket, BufferType bufferType, Buffer buffer);
    internal static void WebSocketSendWithoutBody(WebSocketBase webSocket, BufferType bufferType);
    internal static void WebSocketReceive(WebSocketBase webSocket);
    internal static void WebSocketGetAction(WebSocketBase webSocket, ActionQueue actionQueue, Buffer[] dataBuffers, UInt32& dataBufferCount, Action& action, BufferType& bufferType, IntPtr& actionContext);
    internal static void WebSocketCompleteAction(WebSocketBase webSocket, IntPtr actionContext, int bytesTransferred);
    private static void DrainActionQueue(SafeHandle webSocketHandle, ActionQueue actionQueue);
    private static void MarshalAndVerifyHttpHeader(IntPtr httpHeaderPtr, HttpHeader& httpHeader);
    private static HttpHeader[] MarshalHttpHeaders(IntPtr nativeHeadersPtr, int nativeHeaderCount);
    public static bool Succeeded(int hr);
    private static void ThrowOnError(int errorCode);
    private static void ThrowIfSessionHandleClosed(WebSocketBase webSocket);
    private static WebSocketException ConvertObjectDisposedException(WebSocketBase webSocket, ObjectDisposedException innerException);
}
internal static class System.Net.WebSockets.WebSocketValidate : object {
    internal static void ValidateSubprotocol(string subProtocol);
    internal static void ValidateCloseStatus(WebSocketCloseStatus closeStatus, string statusDescription);
    internal static void ValidateArraySegment(ArraySegment`1<byte> arraySegment, string parameterName);
    internal static void ValidateBuffer(Byte[] buffer, int offset, int count);
}
[EmbeddedAttribute]
[CompilerGeneratedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_log_listener_delegate_exception { get; }
    internal static string net_log_listener_unsupported_authentication_scheme { get; }
    internal static string net_log_listener_unmatched_authentication_scheme { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_listener_cannot_set_custom_cbt { get; }
    internal static string net_listener_detach_error { get; }
    internal static string net_listener_scheme { get; }
    internal static string net_listener_host { get; }
    internal static string net_listener_mustcall { get; }
    internal static string net_listener_slash { get; }
    internal static string net_listener_already { get; }
    internal static string net_log_listener_no_cbt_disabled { get; }
    internal static string net_log_listener_no_cbt_http { get; }
    internal static string net_log_listener_no_cbt_trustedproxy { get; }
    internal static string net_log_listener_cbt { get; }
    internal static string net_log_listener_no_spn_kerberos { get; }
    internal static string net_log_listener_no_spn_disabled { get; }
    internal static string net_log_listener_no_spn_cbt { get; }
    internal static string net_log_listener_no_spn_whensupported { get; }
    internal static string net_log_listener_no_spn_loopback { get; }
    internal static string net_log_listener_spn { get; }
    internal static string net_log_listener_spn_passed { get; }
    internal static string net_log_listener_spn_failed { get; }
    internal static string net_log_listener_spn_failed_always { get; }
    internal static string net_log_listener_spn_failed_empty { get; }
    internal static string net_log_listener_spn_failed_dump { get; }
    internal static string net_log_listener_spn_add { get; }
    internal static string net_log_listener_spn_not_add { get; }
    internal static string net_log_listener_spn_remove { get; }
    internal static string net_log_listener_spn_not_remove { get; }
    internal static string net_listener_no_spns { get; }
    internal static string net_ssp_dont_support_cbt { get; }
    internal static string net_PropertyNotImplementedException { get; }
    internal static string net_array_too_small { get; }
    internal static string net_listener_mustcompletecall { get; }
    internal static string net_listener_invalid_cbt_type { get; }
    internal static string net_listener_callinprogress { get; }
    internal static string net_log_listener_cant_create_uri { get; }
    internal static string net_log_listener_cant_convert_raw_path { get; }
    internal static string net_log_listener_cant_convert_percent_value { get; }
    internal static string net_log_listener_cant_convert_to_utf8 { get; }
    internal static string net_log_listener_cant_convert_bytes { get; }
    internal static string net_invalidstatus { get; }
    internal static string net_WebHeaderInvalidControlChars { get; }
    internal static string net_rspsubmitted { get; }
    internal static string net_nochunkuploadonhttp10 { get; }
    internal static string net_cookie_exists { get; }
    internal static string net_clsmall { get; }
    internal static string net_wrongversion { get; }
    internal static string net_noseek { get; }
    internal static string net_writeonlystream { get; }
    internal static string net_entitytoobig { get; }
    internal static string net_io_notenoughbyteswritten { get; }
    internal static string net_listener_close_urlgroup_error { get; }
    internal static string net_WebSockets_NativeSendResponseHeaders { get; }
    internal static string net_WebSockets_ClientAcceptingNoProtocols { get; }
    internal static string net_WebSockets_AcceptUnsupportedProtocol { get; }
    internal static string net_WebSockets_AcceptNotAWebSocket { get; }
    internal static string net_WebSockets_AcceptHeaderNotFound { get; }
    internal static string net_WebSockets_AcceptUnsupportedWebSocketVersion { get; }
    internal static string net_WebSockets_InvalidEmptySubProtocol { get; }
    internal static string net_WebSockets_InvalidCharInProtocolString { get; }
    internal static string net_WebSockets_ReasonNotNull { get; }
    internal static string net_WebSockets_InvalidCloseStatusCode { get; }
    internal static string net_WebSockets_InvalidCloseStatusDescription { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooSmall { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_TooBig { get; }
    internal static string net_WebSockets_UnsupportedPlatform { get; }
    internal static string net_readonlystream { get; }
    internal static string net_WebSockets_InvalidState_ClosedOrAborted { get; }
    internal static string net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync { get; }
    internal static string net_Websockets_AlreadyOneOutstandingOperation { get; }
    internal static string net_WebSockets_InvalidMessageType { get; }
    internal static string net_WebSockets_InvalidBufferType { get; }
    internal static string net_WebSockets_ArgumentOutOfRange_InternalBuffer { get; }
    internal static string net_WebSockets_Argument_InvalidMessageType { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string SSPIInvalidHandleType { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static string Format(string resourceFormat, object p1, object p2, object p3);
    internal static string Format(string resourceFormat, Object[] args);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_log_listener_delegate_exception();
    internal static string get_net_log_listener_unsupported_authentication_scheme();
    internal static string get_net_log_listener_unmatched_authentication_scheme();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_listener_cannot_set_custom_cbt();
    internal static string get_net_listener_detach_error();
    internal static string get_net_listener_scheme();
    internal static string get_net_listener_host();
    internal static string get_net_listener_mustcall();
    internal static string get_net_listener_slash();
    internal static string get_net_listener_already();
    internal static string get_net_log_listener_no_cbt_disabled();
    internal static string get_net_log_listener_no_cbt_http();
    internal static string get_net_log_listener_no_cbt_trustedproxy();
    internal static string get_net_log_listener_cbt();
    internal static string get_net_log_listener_no_spn_kerberos();
    internal static string get_net_log_listener_no_spn_disabled();
    internal static string get_net_log_listener_no_spn_cbt();
    internal static string get_net_log_listener_no_spn_whensupported();
    internal static string get_net_log_listener_no_spn_loopback();
    internal static string get_net_log_listener_spn();
    internal static string get_net_log_listener_spn_passed();
    internal static string get_net_log_listener_spn_failed();
    internal static string get_net_log_listener_spn_failed_always();
    internal static string get_net_log_listener_spn_failed_empty();
    internal static string get_net_log_listener_spn_failed_dump();
    internal static string get_net_log_listener_spn_add();
    internal static string get_net_log_listener_spn_not_add();
    internal static string get_net_log_listener_spn_remove();
    internal static string get_net_log_listener_spn_not_remove();
    internal static string get_net_listener_no_spns();
    internal static string get_net_ssp_dont_support_cbt();
    internal static string get_net_PropertyNotImplementedException();
    internal static string get_net_array_too_small();
    internal static string get_net_listener_mustcompletecall();
    internal static string get_net_listener_invalid_cbt_type();
    internal static string get_net_listener_callinprogress();
    internal static string get_net_log_listener_cant_create_uri();
    internal static string get_net_log_listener_cant_convert_raw_path();
    internal static string get_net_log_listener_cant_convert_percent_value();
    internal static string get_net_log_listener_cant_convert_to_utf8();
    internal static string get_net_log_listener_cant_convert_bytes();
    internal static string get_net_invalidstatus();
    internal static string get_net_WebHeaderInvalidControlChars();
    internal static string get_net_rspsubmitted();
    internal static string get_net_nochunkuploadonhttp10();
    internal static string get_net_cookie_exists();
    internal static string get_net_clsmall();
    internal static string get_net_wrongversion();
    internal static string get_net_noseek();
    internal static string get_net_writeonlystream();
    internal static string get_net_entitytoobig();
    internal static string get_net_io_notenoughbyteswritten();
    internal static string get_net_listener_close_urlgroup_error();
    internal static string get_net_WebSockets_NativeSendResponseHeaders();
    internal static string get_net_WebSockets_ClientAcceptingNoProtocols();
    internal static string get_net_WebSockets_AcceptUnsupportedProtocol();
    internal static string get_net_WebSockets_AcceptNotAWebSocket();
    internal static string get_net_WebSockets_AcceptHeaderNotFound();
    internal static string get_net_WebSockets_AcceptUnsupportedWebSocketVersion();
    internal static string get_net_WebSockets_InvalidEmptySubProtocol();
    internal static string get_net_WebSockets_InvalidCharInProtocolString();
    internal static string get_net_WebSockets_ReasonNotNull();
    internal static string get_net_WebSockets_InvalidCloseStatusCode();
    internal static string get_net_WebSockets_InvalidCloseStatusDescription();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooSmall();
    internal static string get_net_WebSockets_ArgumentOutOfRange_TooBig();
    internal static string get_net_WebSockets_UnsupportedPlatform();
    internal static string get_net_readonlystream();
    internal static string get_net_WebSockets_InvalidState_ClosedOrAborted();
    internal static string get_net_WebSockets_ReceiveAsyncDisallowedAfterCloseAsync();
    internal static string get_net_Websockets_AlreadyOneOutstandingOperation();
    internal static string get_net_WebSockets_InvalidMessageType();
    internal static string get_net_WebSockets_InvalidBufferType();
    internal static string get_net_WebSockets_ArgumentOutOfRange_InternalBuffer();
    internal static string get_net_WebSockets_Argument_InvalidMessageType();
    internal static string get_net_securitypackagesupport();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_SSPIInvalidHandleType();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
