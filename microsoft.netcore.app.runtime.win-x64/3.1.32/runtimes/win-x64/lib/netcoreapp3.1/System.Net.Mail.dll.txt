internal static class FxResources.System.Net.Mail.SR : object {
}
internal static class Interop : object {
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class Microsoft.CodeAnalysis.EmbeddedAttribute : Attribute {
}
internal class System.Collections.Generic.BidirectionalDictionary`2 : object {
    private Dictionary`2<T1, T2> _forward;
    private Dictionary`2<T2, T1> _backward;
    public BidirectionalDictionary`2(int capacity);
    public void Add(T1 item1, T2 item2);
    public bool TryGetForward(T1 item1, T2& item2);
    public bool TryGetBackward(T2 item2, T1& item1);
    public Enumerator<T1, T2> GetEnumerator();
    private sealed virtual override IEnumerator`1<KeyValuePair`2<T1, T2>> System.Collections.Generic.IEnumerable<System.Collections.Generic.KeyValuePair<T1,T2>>.GetEnumerator();
    private sealed virtual override IEnumerator System.Collections.IEnumerable.GetEnumerator();
}
internal class System.Net.Base64Stream : DelegatedStream {
    private static Byte[] s_base64DecodeMap;
    private static Byte[] s_base64EncodeMap;
    private int _lineLength;
    private Base64WriteStateInfo _writeState;
    private ReadStateInfo _readState;
    private ReadStateInfo ReadState { get; }
    internal Base64WriteStateInfo WriteState { get; }
    internal Base64Stream(Stream stream, Base64WriteStateInfo writeStateInfo);
    internal Base64Stream(Base64WriteStateInfo writeStateInfo);
    private static Base64Stream();
    private ReadStateInfo get_ReadState();
    internal Base64WriteStateInfo get_WriteState();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    internal int EncodeBytes(Byte[] buffer, int offset, int count, bool dontDeferFinalBytes, bool shouldAppendSpaceToCRLF);
    public sealed virtual string GetEncodedString();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.BufferedReadStream : DelegatedStream {
    private Byte[] _storedBuffer;
    private int _storedLength;
    private int _storedOffset;
    private bool _readMore;
    public bool CanWrite { get; }
    public bool CanSeek { get; }
    internal BufferedReadStream(Stream stream);
    internal BufferedReadStream(Stream stream, bool readMore);
    public virtual bool get_CanWrite();
    public virtual bool get_CanSeek();
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    [AsyncStateMachineAttribute("System.Net.BufferedReadStream/<ReadMoreAsync>d__14")]
private Task`1<int> ReadMoreAsync(int bytesAlreadyRead, Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual int ReadByte();
    internal void Push(Byte[] buffer, int offset, int count);
    [CompilerGeneratedAttribute]
[DebuggerHiddenAttribute]
private Task`1<int> <>n__0(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal class System.Net.ClosableStream : DelegatedStream {
    private EventHandler _onClose;
    private int _closed;
    internal ClosableStream(Stream stream, EventHandler onClose);
    public virtual void Close();
}
internal class System.Net.ContextAwareResult : LazyAsyncResult {
    private ExecutionContext modreq(System.Runtime.CompilerServices.IsVolatile) _context;
    private object _lock;
    private StateFlags _flags;
    private WindowsIdentity _windowsIdentity;
    internal ExecutionContext ContextCopy { get; }
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, object myObject, object myState, AsyncCallback myCallBack);
    internal ContextAwareResult(bool captureIdentity, bool forceCaptureContext, bool threadSafeContextCopy, object myObject, object myState, AsyncCallback myCallBack);
    internal ExecutionContext get_ContextCopy();
    internal object StartPostingAsyncOp();
    internal object StartPostingAsyncOp(bool lockCapture);
    internal bool FinishPostingAsyncOp();
    protected virtual void Cleanup();
    private bool CaptureOrComplete(ExecutionContext& cachedContext, bool returnContext);
    protected virtual void Complete(IntPtr userToken);
    private void CompleteCallback();
    private void SafeCaptureIdentity();
    private void CleanupInternal();
}
internal static class System.Net.ContextFlagsAdapterPal : object {
    private static ContextFlagMapping[] s_contextFlagMapping;
    private static ContextFlagsAdapterPal();
    internal static ContextFlagsPal GetContextFlagsPalFromInterop(ContextFlags win32Flags);
    internal static ContextFlags GetInteropFromContextFlagsPal(ContextFlagsPal flags);
}
[FlagsAttribute]
internal enum System.Net.ContextFlagsPal : Enum {
    public int value__;
    public static ContextFlagsPal None;
    public static ContextFlagsPal Delegate;
    public static ContextFlagsPal MutualAuth;
    public static ContextFlagsPal ReplayDetect;
    public static ContextFlagsPal SequenceDetect;
    public static ContextFlagsPal Confidentiality;
    public static ContextFlagsPal UseSessionKey;
    public static ContextFlagsPal AllocateMemory;
    public static ContextFlagsPal Connection;
    public static ContextFlagsPal InitExtendedError;
    public static ContextFlagsPal AcceptExtendedError;
    public static ContextFlagsPal InitStream;
    public static ContextFlagsPal AcceptStream;
    public static ContextFlagsPal InitIntegrity;
    public static ContextFlagsPal AcceptIntegrity;
    public static ContextFlagsPal InitManualCredValidation;
    public static ContextFlagsPal InitUseSuppliedCreds;
    public static ContextFlagsPal InitIdentify;
    public static ContextFlagsPal AcceptIdentify;
    public static ContextFlagsPal ProxyBindings;
    public static ContextFlagsPal AllowMissingBindings;
    public static ContextFlagsPal UnverifiedTargetName;
}
internal class System.Net.DelegatedStream : Stream {
    private Stream _stream;
    private NetworkStream _netStream;
    protected Stream BaseStream { get; }
    public bool CanRead { get; }
    public bool CanSeek { get; }
    public bool CanWrite { get; }
    public long Length { get; }
    public long Position { get; public set; }
    protected DelegatedStream(Stream stream);
    protected Stream get_BaseStream();
    public virtual bool get_CanRead();
    public virtual bool get_CanSeek();
    public virtual bool get_CanWrite();
    public virtual long get_Length();
    public virtual long get_Position();
    public virtual void set_Position(long value);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    public virtual Task FlushAsync(CancellationToken cancellationToken);
    public virtual int Read(Byte[] buffer, int offset, int count);
    public virtual Task`1<int> ReadAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
    public virtual long Seek(long offset, SeekOrigin origin);
    public virtual void SetLength(long value);
    public virtual void Write(Byte[] buffer, int offset, int count);
    public virtual Task WriteAsync(Byte[] buffer, int offset, int count, CancellationToken cancellationToken);
}
internal static class System.Net.ExceptionCheck : object {
    internal static bool IsFatal(Exception exception);
}
internal static class System.Net.GlobalSSPI : object {
    internal static SSPIAuthType SSPIAuth;
    internal static SSPISecureChannelType SSPISecureChannel;
    private static GlobalSSPI();
}
internal class System.Net.InternalException : Exception {
    private object _unexpectedValue;
    public string Message { get; }
    internal InternalException(object unexpectedValue);
    public virtual string get_Message();
}
internal class System.Net.LazyAsyncResult : object {
    [ThreadStaticAttribute]
private static ThreadContext t_threadContext;
    private object _asyncObject;
    private object _asyncState;
    private AsyncCallback _asyncCallback;
    private object _result;
    private int _intCompleted;
    private bool _endCalled;
    private bool _userEvent;
    private object _event;
    private static ThreadContext CurrentThreadContext { get; }
    internal object AsyncObject { get; }
    public object AsyncState { get; }
    protected AsyncCallback AsyncCallback { get; }
    public WaitHandle AsyncWaitHandle { get; }
    public bool CompletedSynchronously { get; }
    public bool IsCompleted { get; }
    internal bool InternalPeekCompleted { get; }
    internal object Result { get; internal set; }
    internal bool EndCalled { get; internal set; }
    internal LazyAsyncResult(object myObject, object myState, AsyncCallback myCallBack);
    private static ThreadContext get_CurrentThreadContext();
    internal object get_AsyncObject();
    public sealed virtual object get_AsyncState();
    protected AsyncCallback get_AsyncCallback();
    public sealed virtual WaitHandle get_AsyncWaitHandle();
    private bool LazilyCreateEvent(ManualResetEvent& waitHandle);
    public sealed virtual bool get_CompletedSynchronously();
    public sealed virtual bool get_IsCompleted();
    internal bool get_InternalPeekCompleted();
    internal object get_Result();
    internal void set_Result(object value);
    internal bool get_EndCalled();
    internal void set_EndCalled(bool value);
    protected void ProtectedInvokeCallback(object result, IntPtr userToken);
    internal void InvokeCallback(object result);
    internal void InvokeCallback();
    protected virtual void Complete(IntPtr userToken);
    private static void WorkerThreadComplete(object state);
    protected virtual void Cleanup();
    internal object InternalWaitForCompletion();
    private object WaitForCompletion(bool snap);
}
public class System.Net.Mail.AlternateView : AttachmentBase {
    private LinkedResourceCollection _linkedResources;
    public LinkedResourceCollection LinkedResources { get; }
    public Uri BaseUri { get; public set; }
    public AlternateView(string fileName);
    public AlternateView(string fileName, string mediaType);
    public AlternateView(string fileName, ContentType contentType);
    public AlternateView(Stream contentStream);
    public AlternateView(Stream contentStream, string mediaType);
    public AlternateView(Stream contentStream, ContentType contentType);
    public LinkedResourceCollection get_LinkedResources();
    public Uri get_BaseUri();
    public void set_BaseUri(Uri value);
    public static AlternateView CreateAlternateViewFromString(string content);
    public static AlternateView CreateAlternateViewFromString(string content, Encoding contentEncoding, string mediaType);
    public static AlternateView CreateAlternateViewFromString(string content, ContentType contentType);
    protected virtual void Dispose(bool disposing);
}
public class System.Net.Mail.AlternateViewCollection : Collection`1<AlternateView> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, AlternateView item);
    protected virtual void InsertItem(int index, AlternateView item);
}
public class System.Net.Mail.Attachment : AttachmentBase {
    private string _name;
    private Encoding _nameEncoding;
    public string Name { get; public set; }
    public Encoding NameEncoding { get; public set; }
    public ContentDisposition ContentDisposition { get; }
    public Attachment(string fileName);
    public Attachment(string fileName, string mediaType);
    public Attachment(string fileName, ContentType contentType);
    public Attachment(Stream contentStream, string name);
    public Attachment(Stream contentStream, string name, string mediaType);
    public Attachment(Stream contentStream, ContentType contentType);
    internal void SetContentTypeName(bool allowUnicode);
    public string get_Name();
    public void set_Name(string value);
    public Encoding get_NameEncoding();
    public void set_NameEncoding(Encoding value);
    public ContentDisposition get_ContentDisposition();
    internal virtual void PrepareForSending(bool allowUnicode);
    public static Attachment CreateAttachmentFromString(string content, string name);
    public static Attachment CreateAttachmentFromString(string content, string name, Encoding contentEncoding, string mediaType);
    public static Attachment CreateAttachmentFromString(string content, ContentType contentType);
}
public abstract class System.Net.Mail.AttachmentBase : object {
    internal bool disposed;
    private MimePart _part;
    private static Char[] s_contentCIDInvalidChars;
    public Stream ContentStream { get; }
    public string ContentId { get; public set; }
    public ContentType ContentType { get; public set; }
    public TransferEncoding TransferEncoding { get; public set; }
    internal Uri ContentLocation { get; internal set; }
    internal MimePart MimePart { get; }
    protected AttachmentBase(string fileName);
    protected AttachmentBase(string fileName, string mediaType);
    protected AttachmentBase(string fileName, ContentType contentType);
    protected AttachmentBase(Stream contentStream);
    protected AttachmentBase(Stream contentStream, string mediaType);
    internal AttachmentBase(Stream contentStream, string name, string mediaType);
    protected AttachmentBase(Stream contentStream, ContentType contentType);
    private static AttachmentBase();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    internal void SetContentFromFile(string fileName, ContentType contentType);
    internal void SetContentFromFile(string fileName, string mediaType);
    internal void SetContentFromString(string content, ContentType contentType);
    internal void SetContentFromString(string content, Encoding encoding, string mediaType);
    internal virtual void PrepareForSending(bool allowUnicode);
    public Stream get_ContentStream();
    public string get_ContentId();
    public void set_ContentId(string value);
    public ContentType get_ContentType();
    public void set_ContentType(ContentType value);
    public TransferEncoding get_TransferEncoding();
    public void set_TransferEncoding(TransferEncoding value);
    internal Uri get_ContentLocation();
    internal void set_ContentLocation(Uri value);
    internal MimePart get_MimePart();
}
public class System.Net.Mail.AttachmentCollection : Collection`1<Attachment> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, Attachment item);
    protected virtual void InsertItem(int index, Attachment item);
}
internal static class System.Net.Mail.AuthCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string type, string message, AsyncCallback callback, object state);
    internal static IAsyncResult BeginSend(SmtpConnection conn, string message, AsyncCallback callback, object state);
    private static LineInfo CheckResponse(LineInfo[] lines);
    internal static LineInfo EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string type, string message);
    private static void PrepareCommand(SmtpConnection conn, string message);
    internal static LineInfo Send(SmtpConnection conn, string type, string message);
    internal static LineInfo Send(SmtpConnection conn, string message);
}
internal class System.Net.Mail.BufferBuilder : object {
    private Byte[] _buffer;
    private int _offset;
    internal int Length { get; }
    internal BufferBuilder(int initialSize);
    private void EnsureBuffer(int count);
    internal void Append(byte value);
    internal void Append(Byte[] value);
    internal void Append(Byte[] value, int offset, int count);
    internal void Append(string value);
    internal void Append(string value, bool allowUnicode);
    internal void Append(string value, int offset, int count, bool allowUnicode);
    internal void Append(string value, int offset, int count);
    internal int get_Length();
    internal Byte[] GetBuffer();
    internal void Reset();
}
internal static class System.Net.Mail.CheckCommand : object {
    private static AsyncCallback s_onReadLine;
    private static AsyncCallback s_onWrite;
    private static CheckCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static object EndSend(IAsyncResult result, String& response);
    private static void OnReadLine(IAsyncResult result);
    private static void OnWrite(IAsyncResult result);
    internal static SmtpStatusCode Send(SmtpConnection conn, String& response);
}
internal static class System.Net.Mail.DataCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
internal static class System.Net.Mail.DataStopCommand : object {
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
[FlagsAttribute]
public enum System.Net.Mail.DeliveryNotificationOptions : Enum {
    public int value__;
    public static DeliveryNotificationOptions None;
    public static DeliveryNotificationOptions OnSuccess;
    public static DeliveryNotificationOptions OnFailure;
    public static DeliveryNotificationOptions Delay;
    public static DeliveryNotificationOptions Never;
}
internal static class System.Net.Mail.DomainLiteralReader : object {
    internal static int ReadReverse(string data, int index);
}
internal static class System.Net.Mail.DotAtomReader : object {
    internal static int ReadReverse(string data, int index);
}
internal static class System.Net.Mail.EHelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    private static String[] CheckResponse(LineInfo[] lines);
    internal static String[] EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string domain);
    internal static String[] Send(SmtpConnection conn, string domain);
}
internal static class System.Net.Mail.HelloCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string domain, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string serverResponse);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, string domain);
    internal static void Send(SmtpConnection conn, string domain);
}
internal interface System.Net.Mail.ISmtpAuthenticationModule {
    public string AuthenticationType { get; }
    public abstract virtual Authorization Authenticate(string challenge, NetworkCredential credentials, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public abstract virtual string get_AuthenticationType();
    public abstract virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.LineInfo : ValueType {
    private string _line;
    private SmtpStatusCode _statusCode;
    internal string Line { get; }
    internal SmtpStatusCode StatusCode { get; }
    internal LineInfo(SmtpStatusCode statusCode, string line);
    internal string get_Line();
    internal SmtpStatusCode get_StatusCode();
}
public class System.Net.Mail.LinkedResource : AttachmentBase {
    public Uri ContentLink { get; public set; }
    public LinkedResource(string fileName);
    public LinkedResource(string fileName, string mediaType);
    public LinkedResource(string fileName, ContentType contentType);
    public LinkedResource(Stream contentStream);
    public LinkedResource(Stream contentStream, string mediaType);
    public LinkedResource(Stream contentStream, ContentType contentType);
    public Uri get_ContentLink();
    public void set_ContentLink(Uri value);
    public static LinkedResource CreateLinkedResourceFromString(string content);
    public static LinkedResource CreateLinkedResourceFromString(string content, Encoding contentEncoding, string mediaType);
    public static LinkedResource CreateLinkedResourceFromString(string content, ContentType contentType);
}
public class System.Net.Mail.LinkedResourceCollection : Collection`1<LinkedResource> {
    private bool _disposed;
    public sealed virtual void Dispose();
    protected virtual void RemoveItem(int index);
    protected virtual void ClearItems();
    protected virtual void SetItem(int index, LinkedResource item);
    protected virtual void InsertItem(int index, LinkedResource item);
}
public class System.Net.Mail.MailAddress : object {
    private static Char[] s_newLines;
    private static bool s_allowFullDomainLiterals;
    private Encoding _displayNameEncoding;
    private string _displayName;
    private string _userName;
    private string _host;
    private static EncodedStreamFactory s_encoderFactory;
    public string DisplayName { get; }
    public string User { get; }
    public string Host { get; }
    public string Address { get; }
    private string SmtpAddress { get; }
    internal MailAddress(string displayName, string userName, string domain);
    public MailAddress(string address);
    public MailAddress(string address, string displayName);
    public MailAddress(string address, string displayName, Encoding displayNameEncoding);
    private static MailAddress();
    public string get_DisplayName();
    public string get_User();
    private string GetUser(bool allowUnicode);
    public string get_Host();
    private string GetHost(bool allowUnicode);
    public string get_Address();
    private string GetAddress(bool allowUnicode);
    private string get_SmtpAddress();
    internal string GetSmtpAddress(bool allowUnicode);
    public virtual string ToString();
    public virtual bool Equals(object value);
    public virtual int GetHashCode();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
public class System.Net.Mail.MailAddressCollection : Collection`1<MailAddress> {
    public void Add(string addresses);
    protected virtual void SetItem(int index, MailAddress item);
    protected virtual void InsertItem(int index, MailAddress item);
    internal void ParseValue(string addresses);
    public virtual string ToString();
    internal string Encode(int charsConsumed, bool allowUnicode);
}
internal static class System.Net.Mail.MailAddressParser : object {
    internal static MailAddress ParseAddress(string data);
    internal static List`1<MailAddress> ParseMultipleAddresses(string data);
    private static MailAddress ParseAddress(string data, bool expectMultipleAddresses, Int32& index);
    private static int ReadCfwsAndThrowIfIncomplete(string data, int index);
    private static string ParseDomain(string data, Int32& index);
    private static string ParseLocalPart(string data, Int32& index, bool expectAngleBracket, bool expectMultipleAddresses);
    private static string ParseDisplayName(string data, Int32& index, bool expectMultipleAddresses);
    internal static string NormalizeOrThrow(string input);
}
internal static class System.Net.Mail.MailCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, Byte[] command, MailAddress from, bool allowUnicode, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string response);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn, Byte[] command, MailAddress from, bool allowUnicode);
    internal static void Send(SmtpConnection conn, Byte[] command, MailAddress from, bool allowUnicode);
}
internal enum System.Net.Mail.MailHeaderID : Enum {
    public int value__;
    public static MailHeaderID Bcc;
    public static MailHeaderID Cc;
    public static MailHeaderID Comments;
    public static MailHeaderID ContentDescription;
    public static MailHeaderID ContentDisposition;
    public static MailHeaderID ContentID;
    public static MailHeaderID ContentLocation;
    public static MailHeaderID ContentTransferEncoding;
    public static MailHeaderID ContentType;
    public static MailHeaderID Date;
    public static MailHeaderID From;
    public static MailHeaderID Importance;
    public static MailHeaderID InReplyTo;
    public static MailHeaderID Keywords;
    public static MailHeaderID Max;
    public static MailHeaderID MessageID;
    public static MailHeaderID MimeVersion;
    public static MailHeaderID Priority;
    public static MailHeaderID References;
    public static MailHeaderID ReplyTo;
    public static MailHeaderID ResentBcc;
    public static MailHeaderID ResentCc;
    public static MailHeaderID ResentDate;
    public static MailHeaderID ResentFrom;
    public static MailHeaderID ResentMessageID;
    public static MailHeaderID ResentSender;
    public static MailHeaderID ResentTo;
    public static MailHeaderID Sender;
    public static MailHeaderID Subject;
    public static MailHeaderID To;
    public static MailHeaderID XPriority;
    public static MailHeaderID XReceiver;
    public static MailHeaderID XSender;
    public static MailHeaderID ZMaxEnumValue;
    public static MailHeaderID Unknown;
}
internal static class System.Net.Mail.MailHeaderInfo : object {
    private static HeaderInfo[] s_headerInfo;
    private static Dictionary`2<string, int> s_headerDictionary;
    private static MailHeaderInfo();
    internal static string GetString(MailHeaderID id);
    internal static MailHeaderID GetID(string name);
    internal static bool IsUserSettable(string name);
    internal static bool IsSingleton(string name);
    internal static string NormalizeCase(string name);
    internal static bool AllowsUnicode(string name);
}
public class System.Net.Mail.MailMessage : object {
    private AlternateViewCollection _views;
    private AttachmentCollection _attachments;
    private AlternateView _bodyView;
    private string _body;
    private Encoding _bodyEncoding;
    private TransferEncoding _bodyTransferEncoding;
    private bool _isBodyHtml;
    private bool _disposed;
    private Message _message;
    private DeliveryNotificationOptions _deliveryStatusNotification;
    public MailAddress From { get; public set; }
    public MailAddress Sender { get; public set; }
    [ObsoleteAttribute("ReplyTo is obsoleted for this type.  Please use ReplyToList instead which can accept multiple addresses. https://go.microsoft.com/fwlink/?linkid=14202")]
public MailAddress ReplyTo { get; public set; }
    public MailAddressCollection ReplyToList { get; }
    public MailAddressCollection To { get; }
    public MailAddressCollection Bcc { get; }
    public MailAddressCollection CC { get; }
    public MailPriority Priority { get; public set; }
    public DeliveryNotificationOptions DeliveryNotificationOptions { get; public set; }
    public string Subject { get; public set; }
    public Encoding SubjectEncoding { get; public set; }
    public NameValueCollection Headers { get; }
    public Encoding HeadersEncoding { get; public set; }
    public string Body { get; public set; }
    public Encoding BodyEncoding { get; public set; }
    public TransferEncoding BodyTransferEncoding { get; public set; }
    public bool IsBodyHtml { get; public set; }
    public AttachmentCollection Attachments { get; }
    public AlternateViewCollection AlternateViews { get; }
    public MailMessage(string from, string to);
    public MailMessage(string from, string to, string subject, string body);
    public MailMessage(MailAddress from, MailAddress to);
    public MailAddress get_From();
    public void set_From(MailAddress value);
    public MailAddress get_Sender();
    public void set_Sender(MailAddress value);
    public MailAddress get_ReplyTo();
    public void set_ReplyTo(MailAddress value);
    public MailAddressCollection get_ReplyToList();
    public MailAddressCollection get_To();
    public MailAddressCollection get_Bcc();
    public MailAddressCollection get_CC();
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    public DeliveryNotificationOptions get_DeliveryNotificationOptions();
    public void set_DeliveryNotificationOptions(DeliveryNotificationOptions value);
    public string get_Subject();
    public void set_Subject(string value);
    public Encoding get_SubjectEncoding();
    public void set_SubjectEncoding(Encoding value);
    public NameValueCollection get_Headers();
    public Encoding get_HeadersEncoding();
    public void set_HeadersEncoding(Encoding value);
    public string get_Body();
    public void set_Body(string value);
    public Encoding get_BodyEncoding();
    public void set_BodyEncoding(Encoding value);
    public TransferEncoding get_BodyTransferEncoding();
    public void set_BodyTransferEncoding(TransferEncoding value);
    public bool get_IsBodyHtml();
    public void set_IsBodyHtml(bool value);
    public AttachmentCollection get_Attachments();
    public AlternateViewCollection get_AlternateViews();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    private void SetContent(bool allowUnicode);
    internal void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal IAsyncResult BeginSend(BaseWriter writer, bool sendEnvelope, bool allowUnicode, AsyncCallback callback, object state);
    internal void EndSend(IAsyncResult asyncResult);
    internal string BuildDeliveryStatusNotificationString();
}
public enum System.Net.Mail.MailPriority : Enum {
    public int value__;
    public static MailPriority Normal;
    public static MailPriority Low;
    public static MailPriority High;
}
internal class System.Net.Mail.MailWriter : BaseWriter {
    internal MailWriter(Stream stream);
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal virtual void Close();
    protected virtual void OnClose(object sender, EventArgs args);
}
internal class System.Net.Mail.Message : object {
    private MailAddress _from;
    private MailAddress _sender;
    private MailAddressCollection _replyToList;
    private MailAddress _replyTo;
    private MailAddressCollection _to;
    private MailAddressCollection _cc;
    private MailAddressCollection _bcc;
    private MimeBasePart _content;
    private HeaderCollection _headers;
    private HeaderCollection _envelopeHeaders;
    private string _subject;
    private Encoding _subjectEncoding;
    private Encoding _headersEncoding;
    private MailPriority _priority;
    public MailPriority Priority { get; public set; }
    internal MailAddress From { get; internal set; }
    internal MailAddress Sender { get; internal set; }
    internal MailAddress ReplyTo { get; internal set; }
    internal MailAddressCollection ReplyToList { get; }
    internal MailAddressCollection To { get; }
    internal MailAddressCollection Bcc { get; }
    internal MailAddressCollection CC { get; }
    internal string Subject { get; internal set; }
    internal Encoding SubjectEncoding { get; internal set; }
    internal HeaderCollection Headers { get; }
    internal Encoding HeadersEncoding { get; internal set; }
    internal HeaderCollection EnvelopeHeaders { get; }
    internal MimeBasePart Content { get; internal set; }
    internal Message(string from, string to);
    internal Message(MailAddress from, MailAddress to);
    public MailPriority get_Priority();
    public void set_Priority(MailPriority value);
    internal MailAddress get_From();
    internal void set_From(MailAddress value);
    internal MailAddress get_Sender();
    internal void set_Sender(MailAddress value);
    internal MailAddress get_ReplyTo();
    internal void set_ReplyTo(MailAddress value);
    internal MailAddressCollection get_ReplyToList();
    internal MailAddressCollection get_To();
    internal MailAddressCollection get_Bcc();
    internal MailAddressCollection get_CC();
    internal string get_Subject();
    internal void set_Subject(string value);
    internal Encoding get_SubjectEncoding();
    internal void set_SubjectEncoding(Encoding value);
    internal HeaderCollection get_Headers();
    internal Encoding get_HeadersEncoding();
    internal void set_HeadersEncoding(Encoding value);
    internal HeaderCollection get_EnvelopeHeaders();
    internal virtual MimeBasePart get_Content();
    internal virtual void set_Content(MimeBasePart value);
    internal void EmptySendCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, bool sendEnvelope, bool allowUnicode, AsyncCallback callback, object state);
    internal virtual void EndSend(IAsyncResult asyncResult);
    internal virtual void Send(BaseWriter writer, bool sendEnvelope, bool allowUnicode);
    internal void PrepareEnvelopeHeaders(bool sendEnvelope, bool allowUnicode);
    internal void PrepareHeaders(bool sendEnvelope, bool allowUnicode);
    internal void EncodeHeaders(HeaderCollection headers, bool allowUnicode);
    private bool IsHeaderSet(string headerName);
}
internal static class System.Net.Mail.QuotedPairReader : object {
    internal static int CountQuotedChars(string data, int index, bool permitUnicodeEscaping);
    private static int CountBackslashes(string data, int index);
}
internal static class System.Net.Mail.QuotedStringFormatReader : object {
    internal static int ReadReverseQuoted(string data, int index, bool permitUnicode);
    internal static int ReadReverseUnQuoted(string data, int index, bool permitUnicode, bool expectCommaDelimiter);
    private static bool IsValidQtext(bool allowUnicode, char ch);
}
internal static class System.Net.Mail.ReadLinesCommand : object {
    private static AsyncCallback s_onReadLines;
    private static AsyncCallback s_onWrite;
    private static ReadLinesCommand();
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    internal static LineInfo[] EndSend(IAsyncResult result);
    private static void OnReadLines(IAsyncResult result);
    private static void OnWrite(IAsyncResult result);
    internal static LineInfo[] Send(SmtpConnection conn);
}
internal static class System.Net.Mail.RecipientCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, string to, AsyncCallback callback, object state);
    private static bool CheckResponse(SmtpStatusCode statusCode, string response);
    internal static bool EndSend(IAsyncResult result, String& response);
    private static void PrepareCommand(SmtpConnection conn, string to);
    internal static bool Send(SmtpConnection conn, string to, String& response);
}
public class System.Net.Mail.SendCompletedEventHandler : MulticastDelegate {
    public SendCompletedEventHandler(object object, IntPtr method);
    public virtual void Invoke(object sender, AsyncCompletedEventArgs e);
    public virtual IAsyncResult BeginInvoke(object sender, AsyncCompletedEventArgs e, AsyncCallback callback, object object);
    public virtual void EndInvoke(IAsyncResult result);
}
internal class System.Net.Mail.SendMailAsyncResult : LazyAsyncResult {
    private SmtpConnection _connection;
    private MailAddress _from;
    private string _deliveryNotify;
    private static AsyncCallback s_sendMailFromCompleted;
    private static AsyncCallback s_sendToCollectionCompleted;
    private static AsyncCallback s_sendDataCompleted;
    private List`1<SmtpFailedRecipientException> _failedRecipientExceptions;
    private Stream _stream;
    private MailAddressCollection _toCollection;
    private int _toIndex;
    private bool _allowUnicode;
    internal SendMailAsyncResult(SmtpConnection connection, MailAddress from, MailAddressCollection toCollection, bool allowUnicode, string deliveryNotify, AsyncCallback callback, object state);
    private static SendMailAsyncResult();
    internal void Send();
    internal static MailWriter End(IAsyncResult result);
    private void SendMailFrom();
    private static void SendMailFromCompleted(IAsyncResult result);
    private void SendToCollection();
    private static void SendToCollectionCompleted(IAsyncResult result);
    private void SendData();
    private static void SendDataCompleted(IAsyncResult result);
    internal SmtpFailedRecipientException GetFailedRecipientException();
}
internal static class System.Net.Mail.SmtpAuthenticationManager : object {
    private static List`1<ISmtpAuthenticationModule> s_modules;
    private static SmtpAuthenticationManager();
    internal static void Register(ISmtpAuthenticationModule module);
    internal static ISmtpAuthenticationModule[] GetModules();
}
public class System.Net.Mail.SmtpClient : object {
    private string _host;
    private int _port;
    private bool _inCall;
    private bool _cancelled;
    private bool _timedOut;
    private string _targetName;
    private SmtpDeliveryMethod _deliveryMethod;
    private SmtpDeliveryFormat _deliveryFormat;
    private string _pickupDirectoryLocation;
    private SmtpTransport _transport;
    private MailMessage _message;
    private MailWriter _writer;
    private MailAddressCollection _recipients;
    private SendOrPostCallback _onSendCompletedDelegate;
    private Timer _timer;
    private ContextAwareResult _operationCompletedResult;
    private AsyncOperation _asyncOp;
    private static AsyncCallback s_contextSafeCompleteCallback;
    internal string clientDomain;
    private bool _disposed;
    private ServicePoint _servicePoint;
    private SmtpFailedRecipientException _failedRecipientException;
    [CompilerGeneratedAttribute]
private SendCompletedEventHandler SendCompleted;
    public string Host { get; public set; }
    public int Port { get; public set; }
    public bool UseDefaultCredentials { get; public set; }
    public ICredentialsByHost Credentials { get; public set; }
    public int Timeout { get; public set; }
    public ServicePoint ServicePoint { get; }
    public SmtpDeliveryMethod DeliveryMethod { get; public set; }
    public SmtpDeliveryFormat DeliveryFormat { get; public set; }
    public string PickupDirectoryLocation { get; public set; }
    public bool EnableSsl { get; public set; }
    public X509CertificateCollection ClientCertificates { get; }
    public string TargetName { get; public set; }
    private bool ServerSupportsEai { get; }
    internal bool InCall { get; internal set; }
    public SmtpClient(string host);
    public SmtpClient(string host, int port);
    private static SmtpClient();
    [CompilerGeneratedAttribute]
public void add_SendCompleted(SendCompletedEventHandler value);
    [CompilerGeneratedAttribute]
public void remove_SendCompleted(SendCompletedEventHandler value);
    private void Initialize();
    public string get_Host();
    public void set_Host(string value);
    public int get_Port();
    public void set_Port(int value);
    public bool get_UseDefaultCredentials();
    public void set_UseDefaultCredentials(bool value);
    public ICredentialsByHost get_Credentials();
    public void set_Credentials(ICredentialsByHost value);
    public int get_Timeout();
    public void set_Timeout(int value);
    public ServicePoint get_ServicePoint();
    public SmtpDeliveryMethod get_DeliveryMethod();
    public void set_DeliveryMethod(SmtpDeliveryMethod value);
    public SmtpDeliveryFormat get_DeliveryFormat();
    public void set_DeliveryFormat(SmtpDeliveryFormat value);
    public string get_PickupDirectoryLocation();
    public void set_PickupDirectoryLocation(string value);
    public bool get_EnableSsl();
    public void set_EnableSsl(bool value);
    public X509CertificateCollection get_ClientCertificates();
    public void set_TargetName(string value);
    public string get_TargetName();
    private bool get_ServerSupportsEai();
    private bool IsUnicodeSupported();
    internal MailWriter GetFileMailWriter(string pickupDirectory);
    protected void OnSendCompleted(AsyncCompletedEventArgs e);
    private void SendCompletedWaitCallback(object operationState);
    public void Send(string from, string recipients, string subject, string body);
    public void Send(MailMessage message);
    public void SendAsync(string from, string recipients, string subject, string body, object userToken);
    public void SendAsync(MailMessage message, object userToken);
    private bool IsSystemNetworkCredentialInCache(CredentialCache cache);
    public void SendAsyncCancel();
    public Task SendMailAsync(string from, string recipients, string subject, string body);
    public Task SendMailAsync(MailMessage message);
    private void HandleCompletion(TaskCompletionSource`1<object> tcs, AsyncCompletedEventArgs e, SendCompletedEventHandler handler);
    internal bool get_InCall();
    internal void set_InCall(bool value);
    private void CheckHostAndPort();
    private void TimeOutCallback(object state);
    private void Complete(Exception exception, IAsyncResult result);
    private static void ContextSafeCompleteCallback(IAsyncResult ar);
    private void SendMessageCallback(IAsyncResult result);
    private void SendMailCallback(IAsyncResult result);
    private void ConnectCallback(IAsyncResult result);
    private void ValidateUnicodeRequirement(MailMessage message, MailAddressCollection recipients, bool allowUnicode);
    private void GetConnection();
    private void Abort();
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
}
internal static class System.Net.Mail.SmtpCommands : object {
    internal static Byte[] Auth;
    internal static Byte[] CRLF;
    internal static Byte[] Data;
    internal static Byte[] DataStop;
    internal static Byte[] EHello;
    internal static Byte[] Expand;
    internal static Byte[] Hello;
    internal static Byte[] Help;
    internal static Byte[] Mail;
    internal static Byte[] Noop;
    internal static Byte[] Quit;
    internal static Byte[] Recipient;
    internal static Byte[] Reset;
    internal static Byte[] Send;
    internal static Byte[] SendAndMail;
    internal static Byte[] SendOrMail;
    internal static Byte[] Turn;
    internal static Byte[] Verify;
    internal static Byte[] StartTls;
    private static SmtpCommands();
}
internal class System.Net.Mail.SmtpConnection : object {
    private static ContextCallback s_AuthenticateCallback;
    private BufferBuilder _bufferBuilder;
    private bool _isConnected;
    private bool _isClosed;
    private bool _isStreamOpen;
    private EventHandler _onCloseHandler;
    internal SmtpTransport _parent;
    private SmtpClient _client;
    private NetworkStream _networkStream;
    internal TcpClient _tcpClient;
    private SmtpReplyReaderFactory _responseReader;
    private ICredentialsByHost _credentials;
    private int _timeout;
    private String[] _extensions;
    private ChannelBinding _channelBindingToken;
    private bool _enableSsl;
    private X509CertificateCollection _clientCertificates;
    private bool _serverSupportsEai;
    private bool _dsnEnabled;
    private bool _serverSupportsStartTls;
    private bool _sawNegotiate;
    private SupportedAuth _supportedAuth;
    private ISmtpAuthenticationModule[] _authenticationModules;
    private static Char[] s_authExtensionSplitters;
    internal BufferBuilder BufferBuilder { get; }
    internal bool IsConnected { get; }
    internal bool IsStreamOpen { get; }
    internal SmtpReplyReaderFactory Reader { get; }
    internal bool EnableSsl { get; internal set; }
    unknown int Timeout {internal set; }
    unknown X509CertificateCollection ClientCertificates {internal set; }
    internal bool DSNEnabled { get; }
    internal bool ServerSupportsEai { get; }
    internal SmtpConnection(SmtpTransport parent, SmtpClient client, ICredentialsByHost credentials, ISmtpAuthenticationModule[] authenticationModules);
    private static SmtpConnection();
    internal BufferBuilder get_BufferBuilder();
    internal bool get_IsConnected();
    internal bool get_IsStreamOpen();
    internal SmtpReplyReaderFactory get_Reader();
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal void set_Timeout(int value);
    internal void set_ClientCertificates(X509CertificateCollection value);
    internal void InitializeConnection(string host, int port);
    internal IAsyncResult BeginInitializeConnection(string host, int port, AsyncCallback callback, object state);
    internal void EndInitializeConnection(IAsyncResult result);
    internal IAsyncResult BeginGetConnection(ContextAwareResult outerResult, AsyncCallback callback, object state, string host, int port);
    internal IAsyncResult BeginFlush(AsyncCallback callback, object state);
    internal void EndFlush(IAsyncResult result);
    internal void Flush();
    internal void ReleaseConnection();
    internal void Abort();
    internal void GetConnection(string host, int port);
    private Authorization SetContextAndTryAuthenticate(ISmtpAuthenticationModule module, NetworkCredential credential, ContextAwareResult context);
    private static void AuthenticateCallback(object state);
    internal void EndGetConnection(IAsyncResult result);
    internal Stream GetClosableStream();
    private void OnClose(object sender, EventArgs args);
    internal bool get_DSNEnabled();
    internal bool get_ServerSupportsEai();
    internal void ParseExtensions(String[] extensions);
    internal bool AuthSupported(ISmtpAuthenticationModule module);
}
public enum System.Net.Mail.SmtpDeliveryFormat : Enum {
    public int value__;
    public static SmtpDeliveryFormat SevenBit;
    public static SmtpDeliveryFormat International;
}
public enum System.Net.Mail.SmtpDeliveryMethod : Enum {
    public int value__;
    public static SmtpDeliveryMethod Network;
    public static SmtpDeliveryMethod SpecifiedPickupDirectory;
    public static SmtpDeliveryMethod PickupDirectoryFromIis;
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpException : Exception {
    private SmtpStatusCode _statusCode;
    public SmtpStatusCode StatusCode { get; public set; }
    public SmtpException(SmtpStatusCode statusCode);
    public SmtpException(SmtpStatusCode statusCode, string message);
    public SmtpException(string message);
    public SmtpException(string message, Exception innerException);
    protected SmtpException(SerializationInfo serializationInfo, StreamingContext streamingContext);
    internal SmtpException(SmtpStatusCode statusCode, string serverMessage, bool serverResponse);
    internal SmtpException(string message, string serverResponse);
    private static string GetMessageForStatus(SmtpStatusCode statusCode, string serverResponse);
    private static string GetMessageForStatus(SmtpStatusCode statusCode);
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public SmtpStatusCode get_StatusCode();
    public void set_StatusCode(SmtpStatusCode value);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientException : SmtpException {
    private string _failedRecipient;
    internal bool fatal;
    public string FailedRecipient { get; }
    public SmtpFailedRecipientException(string message);
    public SmtpFailedRecipientException(string message, Exception innerException);
    protected SmtpFailedRecipientException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient);
    public SmtpFailedRecipientException(SmtpStatusCode statusCode, string failedRecipient, string serverResponse);
    public SmtpFailedRecipientException(string message, string failedRecipient, Exception innerException);
    public string get_FailedRecipient();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
[TypeForwardedFromAttribute("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089")]
public class System.Net.Mail.SmtpFailedRecipientsException : SmtpFailedRecipientException {
    private SmtpFailedRecipientException[] _innerExceptions;
    public SmtpFailedRecipientException[] InnerExceptions { get; }
    public SmtpFailedRecipientsException(string message);
    public SmtpFailedRecipientsException(string message, Exception innerException);
    protected SmtpFailedRecipientsException(SerializationInfo info, StreamingContext context);
    public SmtpFailedRecipientsException(string message, SmtpFailedRecipientException[] innerExceptions);
    internal SmtpFailedRecipientsException(List`1<SmtpFailedRecipientException> innerExceptions, bool allFailed);
    public SmtpFailedRecipientException[] get_InnerExceptions();
    private sealed virtual override void System.Runtime.Serialization.ISerializable.GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
    public virtual void GetObjectData(SerializationInfo serializationInfo, StreamingContext streamingContext);
}
internal class System.Net.Mail.SmtpLoginAuthenticationModule : object {
    private Dictionary`2<object, NetworkCredential> _sessions;
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpNegotiateAuthenticationModule : object {
    private Dictionary`2<object, NTAuthentication> _sessions;
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
    private string GetSecurityLayerOutgoingBlob(string challenge, NTAuthentication clientContext);
}
internal class System.Net.Mail.SmtpNtlmAuthenticationModule : object {
    private Dictionary`2<object, NTAuthentication> _sessions;
    public string AuthenticationType { get; }
    public sealed virtual Authorization Authenticate(string challenge, NetworkCredential credential, object sessionCookie, string spn, ChannelBinding channelBindingToken);
    public sealed virtual string get_AuthenticationType();
    public sealed virtual void CloseContext(object sessionCookie);
}
internal class System.Net.Mail.SmtpReplyReader : object {
    private SmtpReplyReaderFactory _reader;
    internal SmtpReplyReader(SmtpReplyReaderFactory reader);
    internal IAsyncResult BeginReadLines(AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(AsyncCallback callback, object state);
    public void Close();
    internal LineInfo[] EndReadLines(IAsyncResult result);
    internal LineInfo EndReadLine(IAsyncResult result);
    internal LineInfo[] ReadLines();
    internal LineInfo ReadLine();
}
internal class System.Net.Mail.SmtpReplyReaderFactory : object {
    private BufferedReadStream _bufferedStream;
    private Byte[] _byteBuffer;
    private SmtpReplyReader _currentReader;
    private ReadState _readState;
    private SmtpStatusCode _statusCode;
    internal SmtpReplyReader CurrentReader { get; }
    internal SmtpStatusCode StatusCode { get; }
    internal SmtpReplyReaderFactory(Stream stream);
    internal SmtpReplyReader get_CurrentReader();
    internal SmtpStatusCode get_StatusCode();
    internal IAsyncResult BeginReadLines(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal IAsyncResult BeginReadLine(SmtpReplyReader caller, AsyncCallback callback, object state);
    internal void Close(SmtpReplyReader caller);
    internal LineInfo[] EndReadLines(IAsyncResult result);
    internal LineInfo EndReadLine(IAsyncResult result);
    internal SmtpReplyReader GetNextReplyReader();
    private int ProcessRead(Byte[] buffer, int offset, int read, bool readLine);
    internal int Read(SmtpReplyReader caller, Byte[] buffer, int offset, int count);
    internal LineInfo ReadLine(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller);
    internal LineInfo[] ReadLines(SmtpReplyReader caller, bool oneLine);
}
public enum System.Net.Mail.SmtpStatusCode : Enum {
    public int value__;
    public static SmtpStatusCode SystemStatus;
    public static SmtpStatusCode HelpMessage;
    public static SmtpStatusCode ServiceReady;
    public static SmtpStatusCode ServiceClosingTransmissionChannel;
    public static SmtpStatusCode Ok;
    public static SmtpStatusCode UserNotLocalWillForward;
    public static SmtpStatusCode CannotVerifyUserWillAttemptDelivery;
    public static SmtpStatusCode StartMailInput;
    public static SmtpStatusCode ServiceNotAvailable;
    public static SmtpStatusCode MailboxBusy;
    public static SmtpStatusCode LocalErrorInProcessing;
    public static SmtpStatusCode InsufficientStorage;
    public static SmtpStatusCode ClientNotPermitted;
    public static SmtpStatusCode CommandUnrecognized;
    public static SmtpStatusCode SyntaxError;
    public static SmtpStatusCode CommandNotImplemented;
    public static SmtpStatusCode BadCommandSequence;
    public static SmtpStatusCode MustIssueStartTlsFirst;
    public static SmtpStatusCode CommandParameterNotImplemented;
    public static SmtpStatusCode MailboxUnavailable;
    public static SmtpStatusCode UserNotLocalTryAlternatePath;
    public static SmtpStatusCode ExceededStorageAllocation;
    public static SmtpStatusCode MailboxNameNotAllowed;
    public static SmtpStatusCode TransactionFailed;
    public static SmtpStatusCode GeneralFailure;
}
internal class System.Net.Mail.SmtpTransport : object {
    private ISmtpAuthenticationModule[] _authenticationModules;
    private SmtpConnection _connection;
    private SmtpClient _client;
    private ICredentialsByHost _credentials;
    private int _timeout;
    private List`1<SmtpFailedRecipientException> _failedRecipientExceptions;
    private bool _identityRequired;
    private bool _enableSsl;
    private X509CertificateCollection _clientCertificates;
    internal ICredentialsByHost Credentials { get; internal set; }
    internal bool IdentityRequired { get; internal set; }
    internal bool IsConnected { get; }
    internal int Timeout { get; internal set; }
    internal bool EnableSsl { get; internal set; }
    internal X509CertificateCollection ClientCertificates { get; }
    internal bool ServerSupportsEai { get; }
    internal SmtpTransport(SmtpClient client);
    internal SmtpTransport(SmtpClient client, ISmtpAuthenticationModule[] authenticationModules);
    internal ICredentialsByHost get_Credentials();
    internal void set_Credentials(ICredentialsByHost value);
    internal bool get_IdentityRequired();
    internal void set_IdentityRequired(bool value);
    internal bool get_IsConnected();
    internal int get_Timeout();
    internal void set_Timeout(int value);
    internal bool get_EnableSsl();
    internal void set_EnableSsl(bool value);
    internal X509CertificateCollection get_ClientCertificates();
    internal bool get_ServerSupportsEai();
    internal void GetConnection(string host, int port);
    internal IAsyncResult BeginGetConnection(ContextAwareResult outerResult, AsyncCallback callback, object state, string host, int port);
    internal void EndGetConnection(IAsyncResult result);
    internal IAsyncResult BeginSendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, AsyncCallback callback, object state);
    internal void ReleaseConnection();
    internal void Abort();
    internal MailWriter EndSendMail(IAsyncResult result);
    internal MailWriter SendMail(MailAddress sender, MailAddressCollection recipients, string deliveryNotify, bool allowUnicode, SmtpFailedRecipientException& exception);
}
internal static class System.Net.Mail.StartTlsCommand : object {
    internal static IAsyncResult BeginSend(SmtpConnection conn, AsyncCallback callback, object state);
    private static void CheckResponse(SmtpStatusCode statusCode, string response);
    internal static void EndSend(IAsyncResult result);
    private static void PrepareCommand(SmtpConnection conn);
    internal static void Send(SmtpConnection conn);
}
internal enum System.Net.Mail.SupportedAuth : Enum {
    public int value__;
    public static SupportedAuth None;
    public static SupportedAuth Login;
    public static SupportedAuth NTLM;
    public static SupportedAuth GSSAPI;
}
internal static class System.Net.Mail.WhitespaceReader : object {
    internal static int ReadFwsReverse(string data, int index);
    internal static int ReadCfwsReverse(string data, int index);
}
internal class System.Net.Mime.Base64WriteStateInfo : WriteStateInfoBase {
    [CompilerGeneratedAttribute]
private int <Padding>k__BackingField;
    [CompilerGeneratedAttribute]
private byte <LastBits>k__BackingField;
    internal int Padding { get; internal set; }
    internal byte LastBits { get; internal set; }
    internal Base64WriteStateInfo(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    [CompilerGeneratedAttribute]
internal int get_Padding();
    [CompilerGeneratedAttribute]
internal void set_Padding(int value);
    [CompilerGeneratedAttribute]
internal byte get_LastBits();
    [CompilerGeneratedAttribute]
internal void set_LastBits(byte value);
}
internal abstract class System.Net.Mime.BaseWriter : object {
    private static AsyncCallback s_onWrite;
    protected static Byte[] s_crlf;
    protected BufferBuilder _bufferBuilder;
    protected Stream _stream;
    private EventHandler _onCloseHandler;
    private bool _shouldEncodeLeadingDots;
    private int _lineLength;
    protected Stream _contentStream;
    protected bool _isInContent;
    protected BaseWriter(Stream stream, bool shouldEncodeLeadingDots);
    private static BaseWriter();
    internal abstract virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal void WriteHeader(string name, string value, bool allowUnicode);
    private void WriteAndFold(string value, int charsAlreadyOnLine, bool allowUnicode);
    internal Stream GetContentStream();
    private Stream GetContentStream(MultiAsyncResult multiResult);
    internal IAsyncResult BeginGetContentStream(AsyncCallback callback, object state);
    internal Stream EndGetContentStream(IAsyncResult result);
    protected void Flush(MultiAsyncResult multiResult);
    protected static void OnWrite(IAsyncResult result);
    internal abstract virtual void Close();
    protected abstract virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
public class System.Net.Mime.ContentDisposition : object {
    private TrackingValidationObjectDictionary _parameters;
    private string _disposition;
    private string _dispositionType;
    private bool _isChanged;
    private bool _isPersisted;
    private static ValidateAndParseValue s_dateParser;
    private static ValidateAndParseValue s_longParser;
    private static Dictionary`2<string, ValidateAndParseValue> s_validators;
    public string DispositionType { get; public set; }
    public StringDictionary Parameters { get; }
    public string FileName { get; public set; }
    public DateTime CreationDate { get; public set; }
    public DateTime ModificationDate { get; public set; }
    public bool Inline { get; public set; }
    public DateTime ReadDate { get; public set; }
    public long Size { get; public set; }
    internal bool IsChanged { get; }
    public ContentDisposition(string disposition);
    private static ContentDisposition();
    internal DateTime GetDateParameter(string parameterName);
    public string get_DispositionType();
    public void set_DispositionType(string value);
    public StringDictionary get_Parameters();
    public string get_FileName();
    public void set_FileName(string value);
    public DateTime get_CreationDate();
    public void set_CreationDate(DateTime value);
    public DateTime get_ModificationDate();
    public void set_ModificationDate(DateTime value);
    public bool get_Inline();
    public void set_Inline(bool value);
    public DateTime get_ReadDate();
    public void set_ReadDate(DateTime value);
    public long get_Size();
    public void set_Size(long value);
    internal void Set(string contentDisposition, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    private void ParseValue();
}
public class System.Net.Mime.ContentType : object {
    private TrackingStringDictionary _parameters;
    private string _mediaType;
    private string _subType;
    private bool _isChanged;
    private string _type;
    private bool _isPersisted;
    public string Boundary { get; public set; }
    public string CharSet { get; public set; }
    public string MediaType { get; public set; }
    public string Name { get; public set; }
    public StringDictionary Parameters { get; }
    internal bool IsChanged { get; }
    public ContentType(string contentType);
    public string get_Boundary();
    public void set_Boundary(string value);
    public string get_CharSet();
    public void set_CharSet(string value);
    public string get_MediaType();
    public void set_MediaType(string value);
    public string get_Name();
    public void set_Name(string value);
    public StringDictionary get_Parameters();
    internal void Set(string contentType, HeaderCollection headers);
    internal void PersistIfNeeded(HeaderCollection headers, bool forcePersist);
    internal bool get_IsChanged();
    public virtual string ToString();
    internal string Encode(bool allowUnicode);
    private static void EncodeToBuffer(string value, StringBuilder builder, bool allowUnicode);
    public virtual bool Equals(object rparam);
    public virtual int GetHashCode();
    private void ParseValue();
}
public static class System.Net.Mime.DispositionTypeNames : object {
    public static string Inline;
    public static string Attachment;
}
internal class System.Net.Mime.EightBitStream : DelegatedStream {
    private WriteStateInfoBase _writeState;
    private bool _shouldEncodeLeadingDots;
    private WriteStateInfoBase WriteState { get; }
    internal EightBitStream(Stream stream);
    internal EightBitStream(Stream stream, bool shouldEncodeLeadingDots);
    private WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Write(Byte[] buffer, int offset, int count);
    private void EncodeLines(Byte[] buffer, int offset, int count);
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual string GetEncodedString();
}
internal class System.Net.Mime.EncodedStreamFactory : object {
    internal IEncodableStream GetEncoderForHeader(Encoding encoding, bool useBase64Encoding, int headerTextLength);
    protected Byte[] CreateHeader(Encoding encoding, bool useBase64Encoding);
    protected Byte[] CreateFooter();
}
internal class System.Net.Mime.HeaderCollection : NameValueCollection {
    private MimeBasePart _part;
    public virtual void Remove(string name);
    public virtual string Get(string name);
    public virtual String[] GetValues(string name);
    internal void InternalRemove(string name);
    internal void InternalSet(string name, string value);
    internal void InternalAdd(string name, string value);
    public virtual void Set(string name, string value);
    public virtual void Add(string name, string value);
}
internal interface System.Net.Mime.IEncodableStream {
    public abstract virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public abstract virtual string GetEncodedString();
}
internal static class System.Net.Mime.MailBnfHelper : object {
    internal static Boolean[] Atext;
    internal static Boolean[] Qtext;
    internal static Boolean[] Dtext;
    internal static Boolean[] Ftext;
    internal static Boolean[] Ttext;
    internal static Boolean[] Ctext;
    internal static int Ascii7bitMaxValue;
    internal static char Quote;
    internal static char Space;
    internal static char Tab;
    internal static char CR;
    internal static char LF;
    internal static char StartComment;
    internal static char EndComment;
    internal static char Backslash;
    internal static char At;
    internal static char EndAngleBracket;
    internal static char StartAngleBracket;
    internal static char StartSquareBracket;
    internal static char EndSquareBracket;
    internal static char Comma;
    internal static char Dot;
    private static Char[] s_colonSeparator;
    private static String[] s_months;
    private static MailBnfHelper();
    private static Boolean[] CreateCharactersAllowedInAtoms();
    private static Boolean[] CreateCharactersAllowedInQuotedStrings();
    private static Boolean[] CreateCharactersAllowedInDomainLiterals();
    private static Boolean[] CreateCharactersAllowedInHeaderNames();
    private static Boolean[] CreateCharactersAllowedInTokens();
    private static Boolean[] CreateCharactersAllowedInComments();
    internal static bool SkipCFWS(string data, Int32& offset);
    internal static void ValidateHeaderName(string data);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder);
    internal static string ReadQuotedString(string data, Int32& offset, StringBuilder builder, bool doesntRequireQuotes, bool permitUnicodeInDisplayName);
    internal static string ReadParameterAttribute(string data, Int32& offset, StringBuilder builder);
    internal static string ReadToken(string data, Int32& offset, StringBuilder builder);
    internal static string GetDateTimeString(DateTime value, StringBuilder builder);
    internal static void GetTokenOrQuotedString(string data, StringBuilder builder, bool allowUnicode);
    private static bool CheckForUnicode(char ch, bool allowUnicode);
    internal static bool IsAllowedWhiteSpace(char c);
    internal static bool HasCROrLF(string data);
    internal static bool IsFWSAt(string data, int index);
}
public static class System.Net.Mime.MediaTypeNames : object {
}
internal class System.Net.Mime.MimeBasePart : object {
    private static Char[] s_decodeEncodingSplitChars;
    protected ContentType _contentType;
    protected ContentDisposition _contentDisposition;
    private HeaderCollection _headers;
    private static Char[] s_headerValueSplitChars;
    private static Char[] s_questionMarkSplitChars;
    internal string ContentID { get; internal set; }
    internal string ContentLocation { get; internal set; }
    internal NameValueCollection Headers { get; }
    internal ContentType ContentType { get; internal set; }
    private static MimeBasePart();
    internal static bool ShouldUseBase64Encoding(Encoding encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding);
    internal static string EncodeHeaderValue(string value, Encoding encoding, bool base64Encoding, int headerLength);
    internal static string DecodeHeaderValue(string value);
    internal static Encoding DecodeEncoding(string value);
    internal static bool IsAscii(string value, bool permitCROrLF);
    internal string get_ContentID();
    internal void set_ContentID(string value);
    internal string get_ContentLocation();
    internal void set_ContentLocation(string value);
    internal NameValueCollection get_Headers();
    internal ContentType get_ContentType();
    internal void set_ContentType(ContentType value);
    internal void PrepareHeaders(bool allowUnicode);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal void EndSend(IAsyncResult asyncResult);
}
internal class System.Net.Mime.MimeMultiPart : MimeBasePart {
    private Collection`1<MimeBasePart> _parts;
    private static int s_boundary;
    private AsyncCallback _mimePartSentCallback;
    private bool _allowUnicode;
    unknown MimeMultiPartType MimeMultiPartType {internal set; }
    internal Collection`1<MimeBasePart> Parts { get; }
    internal MimeMultiPart(MimeMultiPartType type);
    internal void set_MimeMultiPartType(MimeMultiPartType value);
    private void SetType(MimeMultiPartType type);
    internal Collection`1<MimeBasePart> get_Parts();
    internal void Complete(IAsyncResult result, Exception e);
    internal void MimeWriterCloseCallback(IAsyncResult result);
    private void MimeWriterCloseCallbackHandler(IAsyncResult result);
    internal void MimePartSentCallback(IAsyncResult result);
    private void MimePartSentCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    private void ContentStreamCallbackHandler(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal string GetNextBoundary();
}
internal enum System.Net.Mime.MimeMultiPartType : Enum {
    public int value__;
    public static MimeMultiPartType Mixed;
    public static MimeMultiPartType Alternative;
    public static MimeMultiPartType Parallel;
    public static MimeMultiPartType Related;
    public static MimeMultiPartType Unknown;
}
internal class System.Net.Mime.MimePart : MimeBasePart {
    private Stream _stream;
    private bool _streamSet;
    private bool _streamUsedOnce;
    private AsyncCallback _readCallback;
    private AsyncCallback _writeCallback;
    internal Stream Stream { get; }
    internal ContentDisposition ContentDisposition { get; internal set; }
    internal TransferEncoding TransferEncoding { get; internal set; }
    public sealed virtual void Dispose();
    internal Stream get_Stream();
    internal ContentDisposition get_ContentDisposition();
    internal void set_ContentDisposition(ContentDisposition value);
    internal TransferEncoding get_TransferEncoding();
    internal void set_TransferEncoding(TransferEncoding value);
    internal void SetContent(Stream stream);
    internal void SetContent(Stream stream, string name, string mimeType);
    internal void SetContent(Stream stream, ContentType contentType);
    internal void Complete(IAsyncResult result, Exception e);
    internal void ReadCallback(IAsyncResult result);
    internal void ReadCallbackHandler(IAsyncResult result);
    internal void WriteCallback(IAsyncResult result);
    internal void WriteCallbackHandler(IAsyncResult result);
    internal Stream GetEncodedStream(Stream stream);
    internal void ContentStreamCallbackHandler(IAsyncResult result);
    internal void ContentStreamCallback(IAsyncResult result);
    internal virtual IAsyncResult BeginSend(BaseWriter writer, AsyncCallback callback, bool allowUnicode, object state);
    internal virtual void Send(BaseWriter writer, bool allowUnicode);
    internal void ResetStream();
}
internal class System.Net.Mime.MimeWriter : BaseWriter {
    private static Byte[] s_DASHDASH;
    private Byte[] _boundaryBytes;
    private bool _writeBoundary;
    internal MimeWriter(Stream stream, string boundary);
    private static MimeWriter();
    internal virtual void WriteHeaders(NameValueCollection headers, bool allowUnicode);
    internal IAsyncResult BeginClose(AsyncCallback callback, object state);
    internal void EndClose(IAsyncResult result);
    internal virtual void Close();
    private void Close(MultiAsyncResult multiResult);
    protected virtual void OnClose(object sender, EventArgs args);
    protected virtual void CheckBoundary();
}
internal class System.Net.Mime.MultiAsyncResult : LazyAsyncResult {
    private object _context;
    private int _outstanding;
    internal object Context { get; }
    internal MultiAsyncResult(object context, AsyncCallback callback, object state);
    internal object get_Context();
    internal void Enter();
    internal void Leave();
    internal void Leave(object result);
    private void Decrement();
    private void Increment();
    internal void CompleteSequence();
    internal static object End(IAsyncResult result);
}
internal class System.Net.Mime.QEncodedStream : DelegatedStream {
    private static Byte[] s_hexDecodeMap;
    private static Byte[] s_hexEncodeMap;
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QEncodedStream(WriteStateInfoBase wsi);
    private static QEncodedStream();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    private static bool IsAsciiLetterOrDigit(char character);
    private static bool IsAsciiLetter(char character);
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.QuotedPrintableStream : DelegatedStream {
    private bool _encodeCRLF;
    private static Byte[] s_hexDecodeMap;
    private static Byte[] s_hexEncodeMap;
    private int _lineLength;
    private ReadStateInfo _readState;
    private WriteStateInfoBase _writeState;
    private ReadStateInfo ReadState { get; }
    internal WriteStateInfoBase WriteState { get; }
    internal QuotedPrintableStream(Stream stream, int lineLength);
    internal QuotedPrintableStream(Stream stream, bool encodeCRLF);
    private static QuotedPrintableStream();
    private ReadStateInfo get_ReadState();
    internal WriteStateInfoBase get_WriteState();
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual void Close();
    public sealed virtual int DecodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual int EncodeBytes(Byte[] buffer, int offset, int count);
    public sealed virtual string GetEncodedString();
    public virtual void EndWrite(IAsyncResult asyncResult);
    public virtual void Flush();
    private void FlushInternal();
    public virtual void Write(Byte[] buffer, int offset, int count);
}
internal class System.Net.Mime.SmtpDateTime : object {
    internal static String[] s_validDateTimeFormats;
    internal static Char[] s_allowedWhiteSpaceChars;
    internal static Dictionary`2<string, TimeSpan> s_timeZoneOffsetLookup;
    private DateTime _date;
    private TimeSpan _timeZone;
    private bool _unknownTimeZone;
    internal DateTime Date { get; }
    internal SmtpDateTime(DateTime value);
    internal SmtpDateTime(string value);
    private static SmtpDateTime();
    internal static Dictionary`2<string, TimeSpan> InitializeShortHandLookups();
    internal DateTime get_Date();
    public virtual string ToString();
    internal void ValidateAndGetTimeZoneOffsetValues(string offset, Boolean& positive, Int32& hours, Int32& minutes);
    internal void ValidateTimeZoneShortHandValue(string value);
    internal string FormatDate(DateTime value);
    internal DateTime ParseValue(string data, String& timeZone);
    internal bool TryParseTimeZoneString(string timeZoneString, TimeSpan& timeZone);
    internal TimeSpan ValidateAndGetSanitizedTimeSpan(TimeSpan span);
    internal string TimeSpanToOffset(TimeSpan span);
}
public enum System.Net.Mime.TransferEncoding : Enum {
    public int value__;
    public static TransferEncoding Unknown;
    public static TransferEncoding QuotedPrintable;
    public static TransferEncoding Base64;
    public static TransferEncoding SevenBit;
    public static TransferEncoding EightBit;
}
internal class System.Net.Mime.WriteStateInfoBase : object {
    protected Byte[] _header;
    protected Byte[] _footer;
    protected int _maxLineLength;
    protected Byte[] _buffer;
    protected int _currentLineLength;
    protected int _currentBufferUsed;
    internal int FooterLength { get; }
    internal Byte[] Footer { get; }
    internal Byte[] Header { get; }
    internal Byte[] Buffer { get; }
    internal int Length { get; }
    internal int CurrentLineLength { get; }
    internal int MaxLineLength { get; }
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength);
    internal WriteStateInfoBase(int bufferSize, Byte[] header, Byte[] footer, int maxLineLength, int mimeHeaderLength);
    internal int get_FooterLength();
    internal Byte[] get_Footer();
    internal Byte[] get_Header();
    internal Byte[] get_Buffer();
    internal int get_Length();
    internal int get_CurrentLineLength();
    private void EnsureSpaceInBuffer(int moreBytes);
    internal void Append(byte aByte);
    internal void Append(Byte[] bytes);
    internal void AppendCRLF(bool includeSpace);
    internal void AppendHeader();
    internal void AppendFooter();
    internal int get_MaxLineLength();
    internal void Reset();
    internal void BufferFlushed();
}
[EventSourceAttribute]
internal class System.Net.NetEventSource : EventSource {
    public static NetEventSource Log;
    public static bool IsEnabled { get; }
    private static NetEventSource();
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, string memberName);
    [NonEventAttribute]
public static void Enter(object thisOrContextObject, object arg0, object arg1, object arg2, string memberName);
    [EventAttribute("1")]
private void Enter(string thisOrContextObject, string memberName, string parameters);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Exit(object thisOrContextObject, object arg0, string memberName);
    [EventAttribute("2")]
private void Exit(string thisOrContextObject, string memberName, string result);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Info(object thisOrContextObject, object message, string memberName);
    [EventAttribute("4")]
private void Info(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Error(object thisOrContextObject, object message, string memberName);
    [EventAttribute("5")]
private void ErrorMessage(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, FormattableString formattableString, string memberName);
    [NonEventAttribute]
public static void Fail(object thisOrContextObject, object message, string memberName);
    [EventAttribute("6")]
private void CriticalFailure(string thisOrContextObject, string memberName, string message);
    [NonEventAttribute]
public static void Associate(object first, object second, string memberName);
    [EventAttribute("3")]
private void Associate(string thisOrContextObject, string memberName, string first, string second);
    public static bool get_IsEnabled();
    [NonEventAttribute]
public static string IdOf(object value);
    [NonEventAttribute]
public static int GetHashCode(object value);
    [NonEventAttribute]
public static object Format(object value);
    [NonEventAttribute]
private static string Format(FormattableString s);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, string arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, int arg3, int arg4);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, int arg2, string arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, int arg3);
    [NonEventAttribute]
private void WriteEvent(int eventId, string arg1, string arg2, string arg3, int arg4);
    [EventAttribute("8")]
public void EnumerateSecurityPackages(string securityPackage);
    [EventAttribute("9")]
public void SspiPackageNotFound(string packageName);
    [EventAttribute("10")]
public void AcquireDefaultCredential(string packageName, CredentialUse intent);
    [NonEventAttribute]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, object authdata);
    [EventAttribute("11")]
public void AcquireCredentialsHandle(string packageName, CredentialUse intent, string authdata);
    [NonEventAttribute]
public void InitializeSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, string targetName, ContextFlags inFlags);
    [EventAttribute("12")]
private void InitializeSecurityContext(string credential, string context, string targetName, ContextFlags inFlags);
    [NonEventAttribute]
public void AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext context, ContextFlags inFlags);
    [EventAttribute("15")]
private void AcceptSecurityContext(string credential, string context, ContextFlags inFlags);
    [EventAttribute("16")]
public void OperationReturnedSomething(string operation, SECURITY_STATUS errorCode);
    [EventAttribute("14")]
public void SecurityContextInputBuffers(string context, int inputBuffersSize, int outputBufferSize, SECURITY_STATUS errorCode);
}
internal class System.Net.NTAuthentication : object {
    private bool _isServer;
    private SafeFreeCredentials _credentialsHandle;
    private SafeDeleteContext _securityContext;
    private string _spn;
    private int _tokenSize;
    private ContextFlagsPal _requestedContextFlags;
    private ContextFlagsPal _contextFlags;
    private bool _isCompleted;
    private string _package;
    private ChannelBinding _channelBinding;
    internal bool IsCompleted { get; }
    internal bool IsValidContext { get; }
    internal NTAuthentication(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal bool get_IsCompleted();
    internal bool get_IsValidContext();
    private void Initialize(bool isServer, string package, NetworkCredential credential, string spn, ContextFlagsPal requestedContextFlags, ChannelBinding channelBinding);
    internal void CloseContext();
    internal int VerifySignature(Byte[] buffer, int offset, int count);
    internal int MakeSignature(Byte[] buffer, int offset, int count, Byte[]& output);
    internal string GetOutgoingBlob(string incomingBlob);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool thrownOnError);
    internal Byte[] GetOutgoingBlob(Byte[] incomingBlob, bool throwOnError, SecurityStatusPal& statusCode);
}
internal class System.Net.SecPkgContext_Sizes : ValueType {
    public int cbMaxToken;
    public int cbMaxSignature;
    public int cbBlockSize;
    public int cbSecurityTrailer;
}
internal static class System.Net.Security.NegotiateStreamPal : object {
    internal static int QueryMaxTokenSize(string package);
    internal static SafeFreeCredentials AcquireDefaultCredential(string package, bool isServer);
    internal static SafeFreeCredentials AcquireCredentialsHandle(string package, bool isServer, NetworkCredential credential);
    internal static SecurityStatusPal InitializeSecurityContext(SafeFreeCredentials& credentialsHandle, SafeDeleteContext& securityContext, string spn, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static SecurityStatusPal CompleteAuthToken(SafeDeleteContext& securityContext, Byte[] incomingBlob);
    internal static SecurityStatusPal AcceptSecurityContext(SafeFreeCredentials credentialsHandle, SafeDeleteContext& securityContext, ContextFlagsPal requestedContextFlags, Byte[] incomingBlob, ChannelBinding channelBinding, Byte[]& resultBlob, ContextFlagsPal& contextFlags);
    internal static Win32Exception CreateExceptionFromError(SecurityStatusPal statusCode);
    internal static int VerifySignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count);
    internal static int MakeSignature(SafeDeleteContext securityContext, Byte[] buffer, int offset, int count, Byte[]& output);
}
internal class System.Net.Security.SafeCredentialReference : CriticalHandleMinusOneIsInvalid {
    internal SafeFreeCredentials Target;
    private SafeCredentialReference(SafeFreeCredentials target);
    internal static SafeCredentialReference CreateReference(SafeFreeCredentials target);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeDeleteContext : SafeHandle {
    internal CredHandle _handle;
    private static IdnMapping s_idnMapping;
    protected SafeFreeCredentials _EffectiveCredential;
    public bool IsInvalid { get; }
    private static SafeDeleteContext();
    public virtual bool get_IsInvalid();
    public virtual string ToString();
    internal static int InitializeSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunInitializeSecurityContext(SafeFreeCredentials& inCredentials, bool isContextAbsent, Byte* targetName, ContextFlags inFlags, Endianness endianness, SecBufferDesc* inputBuffer, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& attributes, SafeFreeContextBuffer handleTemplate);
    internal static int AcceptSecurityContext(SafeFreeCredentials& inCredentials, SafeDeleteContext& refContext, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inSecBuffers, SecurityBuffer& outSecBuffer, ContextFlags& outFlags);
    private static int MustRunAcceptSecurityContext_SECURITY(SafeFreeCredentials& inCredentials, bool isContextAbsent, SecBufferDesc* inputBuffer, ContextFlags inFlags, Endianness endianness, SafeDeleteContext outContext, SecBufferDesc& outputBuffer, ContextFlags& outFlags, SafeFreeContextBuffer handleTemplate);
    internal static int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inSecBuffer);
}
internal class System.Net.Security.SafeDeleteContext_SECURITY : SafeDeleteContext {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCertContext : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeContextBuffer : SafeHandleZeroOrMinusOneIsInvalid {
    internal void Set(IntPtr value);
    internal static int EnumeratePackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    internal static SafeFreeContextBuffer CreateEmptyHandle();
    public static int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute contextAttribute, Byte* buffer, SafeHandle refHandle);
}
internal class System.Net.Security.SafeFreeContextBuffer_SECURITY : SafeFreeContextBuffer {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SafeFreeCredential_SECURITY : SafeFreeCredentials {
    protected virtual bool ReleaseHandle();
}
internal abstract class System.Net.Security.SafeFreeCredentials : SafeHandle {
    internal CredHandle _handle;
    public bool IsInvalid { get; }
    public virtual bool get_IsInvalid();
    public static int AcquireDefaultCredential(string package, CredentialUse intent, SafeFreeCredentials& outCredential);
    public static int AcquireCredentialsHandle(string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
}
internal class System.Net.Security.SafeSspiAuthDataHandle : SafeHandleZeroOrMinusOneIsInvalid {
    protected virtual bool ReleaseHandle();
}
internal class System.Net.Security.SecurityBuffer : ValueType {
    public int offset;
    public int size;
    public SecurityBufferType type;
    public Byte[] token;
    public SafeHandle unmanagedToken;
    public SecurityBuffer(Byte[] data, int offset, int size, SecurityBufferType tokentype);
    public SecurityBuffer(Byte[] data, SecurityBufferType tokentype);
    public SecurityBuffer(int size, SecurityBufferType tokentype);
    public SecurityBuffer(ChannelBinding binding);
}
internal enum System.Net.Security.SecurityBufferType : Enum {
    public int value__;
    public static SecurityBufferType SECBUFFER_EMPTY;
    public static SecurityBufferType SECBUFFER_DATA;
    public static SecurityBufferType SECBUFFER_TOKEN;
    public static SecurityBufferType SECBUFFER_PKG_PARAMS;
    public static SecurityBufferType SECBUFFER_MISSING;
    public static SecurityBufferType SECBUFFER_EXTRA;
    public static SecurityBufferType SECBUFFER_STREAM_TRAILER;
    public static SecurityBufferType SECBUFFER_STREAM_HEADER;
    public static SecurityBufferType SECBUFFER_PADDING;
    public static SecurityBufferType SECBUFFER_STREAM;
    public static SecurityBufferType SECBUFFER_CHANNEL_BINDINGS;
    public static SecurityBufferType SECBUFFER_TARGET_HOST;
    public static SecurityBufferType SECBUFFER_ALERT;
    public static SecurityBufferType SECBUFFER_APPLICATION_PROTOCOLS;
    public static SecurityBufferType SECBUFFER_READONLY;
    public static SecurityBufferType SECBUFFER_READONLY_WITH_CHECKSUM;
}
internal static class System.Net.Security.SSPIHandleCache : object {
    private static SafeCredentialReference[] s_cacheSlots;
    private static int s_current;
    private static SSPIHandleCache();
    internal static void CacheCredential(SafeFreeCredentials newHandle);
}
[IsByRefLikeAttribute]
[ObsoleteAttribute("Types with embedded references are not supported in this version of your compiler.", "True")]
internal class System.Net.Security.TwoSecurityBuffers : ValueType {
    internal SecurityBuffer _item0;
    private SecurityBuffer _item1;
}
internal class System.Net.SecurityPackageInfo : ValueType {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal IntPtr Name;
    internal IntPtr Comment;
}
internal class System.Net.SecurityPackageInfoClass : object {
    internal int Capabilities;
    internal short Version;
    internal short RPCID;
    internal int MaxToken;
    internal string Name;
    internal string Comment;
    internal SecurityPackageInfoClass(SafeHandle safeHandle, int index);
    public virtual string ToString();
}
internal static class System.Net.SecurityStatusAdapterPal : object {
    private static BidirectionalDictionary`2<SECURITY_STATUS, SecurityStatusPalErrorCode> s_statusDictionary;
    private static SecurityStatusAdapterPal();
    internal static SecurityStatusPal GetSecurityStatusPalFromInterop(SECURITY_STATUS win32SecurityStatus, bool attachException);
    internal static SECURITY_STATUS GetInteropFromSecurityStatusPal(SecurityStatusPal status);
}
[IsReadOnlyAttribute]
internal class System.Net.SecurityStatusPal : ValueType {
    public SecurityStatusPalErrorCode ErrorCode;
    public Exception Exception;
    public SecurityStatusPal(SecurityStatusPalErrorCode errorCode, Exception exception);
    public virtual string ToString();
}
internal enum System.Net.SecurityStatusPalErrorCode : Enum {
    public int value__;
    public static SecurityStatusPalErrorCode NotSet;
    public static SecurityStatusPalErrorCode OK;
    public static SecurityStatusPalErrorCode ContinueNeeded;
    public static SecurityStatusPalErrorCode CompleteNeeded;
    public static SecurityStatusPalErrorCode CompAndContinue;
    public static SecurityStatusPalErrorCode ContextExpired;
    public static SecurityStatusPalErrorCode CredentialsNeeded;
    public static SecurityStatusPalErrorCode Renegotiate;
    public static SecurityStatusPalErrorCode OutOfMemory;
    public static SecurityStatusPalErrorCode InvalidHandle;
    public static SecurityStatusPalErrorCode Unsupported;
    public static SecurityStatusPalErrorCode TargetUnknown;
    public static SecurityStatusPalErrorCode InternalError;
    public static SecurityStatusPalErrorCode PackageNotFound;
    public static SecurityStatusPalErrorCode NotOwner;
    public static SecurityStatusPalErrorCode CannotInstall;
    public static SecurityStatusPalErrorCode InvalidToken;
    public static SecurityStatusPalErrorCode CannotPack;
    public static SecurityStatusPalErrorCode QopNotSupported;
    public static SecurityStatusPalErrorCode NoImpersonation;
    public static SecurityStatusPalErrorCode LogonDenied;
    public static SecurityStatusPalErrorCode UnknownCredentials;
    public static SecurityStatusPalErrorCode NoCredentials;
    public static SecurityStatusPalErrorCode MessageAltered;
    public static SecurityStatusPalErrorCode OutOfSequence;
    public static SecurityStatusPalErrorCode NoAuthenticatingAuthority;
    public static SecurityStatusPalErrorCode IncompleteMessage;
    public static SecurityStatusPalErrorCode IncompleteCredentials;
    public static SecurityStatusPalErrorCode BufferNotEnough;
    public static SecurityStatusPalErrorCode WrongPrincipal;
    public static SecurityStatusPalErrorCode TimeSkew;
    public static SecurityStatusPalErrorCode UntrustedRoot;
    public static SecurityStatusPalErrorCode IllegalMessage;
    public static SecurityStatusPalErrorCode CertUnknown;
    public static SecurityStatusPalErrorCode CertExpired;
    public static SecurityStatusPalErrorCode DecryptFailure;
    public static SecurityStatusPalErrorCode AlgorithmMismatch;
    public static SecurityStatusPalErrorCode SecurityQosFailed;
    public static SecurityStatusPalErrorCode SmartcardLogonRequired;
    public static SecurityStatusPalErrorCode UnsupportedPreauth;
    public static SecurityStatusPalErrorCode BadBinding;
    public static SecurityStatusPalErrorCode DowngradeDetected;
    public static SecurityStatusPalErrorCode ApplicationProtocolMismatch;
}
internal class System.Net.SSPIAuthType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext context, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal interface System.Net.SSPIInterface {
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public abstract virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public abstract virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public abstract virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public abstract virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public abstract virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public abstract virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public abstract virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public abstract virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public abstract virtual int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal class System.Net.SSPISecureChannelType : object {
    private static SecurityPackageInfoClass[] modreq(System.Runtime.CompilerServices.IsVolatile) s_securityPackages;
    public SecurityPackageInfoClass[] SecurityPackages { get; public set; }
    public sealed virtual SecurityPackageInfoClass[] get_SecurityPackages();
    public sealed virtual void set_SecurityPackages(SecurityPackageInfoClass[] value);
    public sealed virtual int EnumerateSecurityPackages(Int32& pkgnum, SafeFreeContextBuffer& pkgArray);
    public sealed virtual int AcquireCredentialsHandle(string moduleName, CredentialUse usage, SafeSspiAuthDataHandle& authdata, SafeFreeCredentials& outCredential);
    public sealed virtual int AcquireDefaultCredential(string moduleName, CredentialUse usage, SafeFreeCredentials& outCredential);
    public sealed virtual int AcceptSecurityContext(SafeFreeCredentials credential, SafeDeleteContext& context, ReadOnlySpan`1<SecurityBuffer> inputBuffers, ContextFlags inFlags, Endianness endianness, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int InitializeSecurityContext(SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness endianness, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    public sealed virtual int EncryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int DecryptMessage(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int MakeSignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int VerifySignature(SafeDeleteContext context, SecBufferDesc& inputOutput, UInt32 sequenceNumber);
    public sealed virtual int QueryContextAttributes(SafeDeleteContext phContext, ContextAttribute attribute, Span`1<byte> buffer, Type handleType, SafeHandle& refHandle);
    public int CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& inputBuffer);
    private sealed virtual override int System.Net.SSPIInterface.CompleteAuthToken(SafeDeleteContext& refContext, SecurityBuffer& modreq(System.Runtime.InteropServices.InAttribute) inputBuffer);
}
internal static class System.Net.SSPIWrapper : object {
    internal static SecurityPackageInfoClass[] EnumerateSecurityPackages(SSPIInterface secModule);
    internal static SecurityPackageInfoClass GetVerifyPackageInfo(SSPIInterface secModule, string packageName, bool throwIfMissing);
    public static SafeFreeCredentials AcquireDefaultCredential(SSPIInterface secModule, string package, CredentialUse intent);
    public static SafeFreeCredentials AcquireCredentialsHandle(SSPIInterface secModule, string package, CredentialUse intent, SafeSspiAuthDataHandle& authdata);
    internal static int InitializeSecurityContext(SSPIInterface secModule, SafeFreeCredentials& credential, SafeDeleteContext& context, string targetName, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int AcceptSecurityContext(SSPIInterface secModule, SafeFreeCredentials credential, SafeDeleteContext& context, ContextFlags inFlags, Endianness datarep, ReadOnlySpan`1<SecurityBuffer> inputBuffers, SecurityBuffer& outputBuffer, ContextFlags& outFlags);
    internal static int CompleteAuthToken(SSPIInterface secModule, SafeDeleteContext& context, SecurityBuffer& inputBuffer);
    internal static int MakeSignature(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    public static int VerifySignature(SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    private static int EncryptDecryptHelper(OP op, SSPIInterface secModule, SafeDeleteContext context, Span`1<SecurityBuffer> input, UInt32 sequenceNumber);
    public static bool QueryBlittableContextAttributes(SSPIInterface secModule, SafeDeleteContext securityContext, ContextAttribute contextAttribute, T& attribute);
    public static string ErrorDescription(int errorCode);
}
internal class System.Net.TlsStream : NetworkStream {
    private SslStream _sslStream;
    private string _host;
    private X509CertificateCollection _clientCertificates;
    public TlsStream(NetworkStream stream, Socket socket, string host, X509CertificateCollection clientCertificates);
    public void AuthenticateAsClient();
    public IAsyncResult BeginAuthenticateAsClient(AsyncCallback asyncCallback, object state);
    public void EndAuthenticateAsClient(IAsyncResult asyncResult);
    public virtual IAsyncResult BeginWrite(Byte[] buffer, int offset, int size, AsyncCallback callback, object state);
    public virtual void EndWrite(IAsyncResult result);
    public virtual void Write(Byte[] buffer, int offset, int size);
    public virtual int Read(Byte[] buffer, int offset, int size);
    public virtual IAsyncResult BeginRead(Byte[] buffer, int offset, int count, AsyncCallback callback, object state);
    public virtual int EndRead(IAsyncResult asyncResult);
    public virtual void Close();
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingStringDictionary : StringDictionary {
    private bool _isReadOnly;
    private bool _isChanged;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingStringDictionary(bool isReadOnly);
    internal bool get_IsChanged();
    internal void set_IsChanged(bool value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
}
[DefaultMemberAttribute("Item")]
internal class System.Net.TrackingValidationObjectDictionary : StringDictionary {
    private Dictionary`2<string, ValidateAndParseValue> _validators;
    private Dictionary`2<string, object> _internalObjects;
    [CompilerGeneratedAttribute]
private bool <IsChanged>k__BackingField;
    internal bool IsChanged { get; internal set; }
    public string Item { get; public set; }
    internal TrackingValidationObjectDictionary(Dictionary`2<string, ValidateAndParseValue> validators);
    private void PersistValue(string key, string value, bool addValue);
    [CompilerGeneratedAttribute]
internal bool get_IsChanged();
    [CompilerGeneratedAttribute]
internal void set_IsChanged(bool value);
    internal object InternalGet(string key);
    internal void InternalSet(string key, object value);
    public virtual string get_Item(string key);
    public virtual void set_Item(string key, string value);
    public virtual void Add(string key, string value);
    public virtual void Clear();
    public virtual void Remove(string key);
}
internal static class System.NotImplemented : object {
    internal static Exception ByDesignWithMessage(string message);
}
[CompilerGeneratedAttribute]
[EmbeddedAttribute]
internal class System.Runtime.CompilerServices.IsUnmanagedAttribute : Attribute {
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string net_emptystringcall { get; }
    internal static string net_io_invalidasyncresult { get; }
    internal static string net_io_invalidendcall { get; }
    internal static string net_emptystringset { get; }
    internal static string net_MethodNotImplementedException { get; }
    internal static string event_OperationReturnedSomething { get; }
    internal static string SSPIInvalidHandleType { get; }
    internal static string net_auth_message_not_encrypted { get; }
    internal static string MailBase64InvalidCharacter { get; }
    internal static string net_securitypackagesupport { get; }
    internal static string MailCollectionIsReadOnly { get; }
    internal static string MailDateInvalidFormat { get; }
    internal static string MailHeaderFieldMalformedHeader { get; }
    internal static string MailWriterIsInContent { get; }
    internal static string net_log_operation_failed_with_error { get; }
    internal static string MimeTransferEncodingNotSupported { get; }
    internal static string InvalidHexDigit { get; }
    internal static string InvalidHeaderName { get; }
    internal static string ContentTypeInvalid { get; }
    internal static string ContentDispositionInvalid { get; }
    internal static string MimePartCantResetStream { get; }
    internal static string MediaTypeInvalid { get; }
    internal static string InvalidPort { get; }
    internal static string MailHeaderInvalidCID { get; }
    internal static string MailServerResponse { get; }
    internal static string net_inasync { get; }
    internal static string net_timeout { get; }
    internal static string SmtpAllRecipientsFailed { get; }
    internal static string SmtpBadCommandSequence { get; }
    internal static string SmtpClientNotPermitted { get; }
    internal static string SmtpCommandNotImplemented { get; }
    internal static string SmtpCommandParameterNotImplemented { get; }
    internal static string SmtpCommandUnrecognized { get; }
    internal static string SmtpExceededStorageAllocation { get; }
    internal static string SmtpFromRequired { get; }
    internal static string SmtpHelpMessage { get; }
    internal static string SmtpInsufficientStorage { get; }
    internal static string SmtpInvalidHostName { get; }
    internal static string SmtpInvalidOperationDuringSend { get; }
    internal static string SmtpLocalErrorInProcessing { get; }
    internal static string SmtpMailboxBusy { get; }
    internal static string SmtpMailboxNameNotAllowed { get; }
    internal static string SmtpMailboxUnavailable { get; }
    internal static string SmtpMustIssueStartTlsFirst { get; }
    internal static string SmtpNeedAbsolutePickupDirectory { get; }
    internal static string SmtpNonAsciiUserNotSupported { get; }
    internal static string SmtpOK { get; }
    internal static string SmtpPickupDirectoryDoesnotSupportSsl { get; }
    internal static string SmtpRecipientFailed { get; }
    internal static string SmtpRecipientRequired { get; }
    internal static string SmtpSendMailFailure { get; }
    internal static string SmtpServiceClosingTransmissionChannel { get; }
    internal static string SmtpServiceReady { get; }
    internal static string SmtpStartMailInput { get; }
    internal static string SmtpSyntaxError { get; }
    internal static string SmtpSystemStatus { get; }
    internal static string SmtpTransactionFailed { get; }
    internal static string SmtpUserNotLocalTryAlternatePath { get; }
    internal static string SmtpUserNotLocalWillForward { get; }
    internal static string UnspecifiedHost { get; }
    internal static string SmtpAlreadyConnected { get; }
    internal static string SmtpAuthenticationFailed { get; }
    internal static string net_completed_result { get; }
    internal static string MailHeaderFieldInvalidCharacter { get; }
    internal static string SeekNotSupported { get; }
    internal static string ReadNotSupported { get; }
    internal static string WriteNotSupported { get; }
    internal static string MailAddressInvalidFormat { get; }
    internal static string SmtpAuthResponseInvalid { get; }
    internal static string net_webstatus_ServerProtocolViolation { get; }
    internal static string SmtpDataStreamOpen { get; }
    internal static string SmtpEhloResponseInvalid { get; }
    internal static string net_io_readfailure { get; }
    internal static string net_io_connectionclosed { get; }
    internal static string SmtpInvalidResponse { get; }
    internal static string SmtpServiceNotAvailable { get; }
    internal static string MailSubjectInvalidFormat { get; }
    internal static string MailServerDoesNotSupportStartTls { get; }
    internal static string MailHostNotFound { get; }
    internal static string SmtpGetIisPickupDirectoryNotSupported { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_net_emptystringcall();
    internal static string get_net_io_invalidasyncresult();
    internal static string get_net_io_invalidendcall();
    internal static string get_net_emptystringset();
    internal static string get_net_MethodNotImplementedException();
    internal static string get_event_OperationReturnedSomething();
    internal static string get_SSPIInvalidHandleType();
    internal static string get_net_auth_message_not_encrypted();
    internal static string get_MailBase64InvalidCharacter();
    internal static string get_net_securitypackagesupport();
    internal static string get_MailCollectionIsReadOnly();
    internal static string get_MailDateInvalidFormat();
    internal static string get_MailHeaderFieldMalformedHeader();
    internal static string get_MailWriterIsInContent();
    internal static string get_net_log_operation_failed_with_error();
    internal static string get_MimeTransferEncodingNotSupported();
    internal static string get_InvalidHexDigit();
    internal static string get_InvalidHeaderName();
    internal static string get_ContentTypeInvalid();
    internal static string get_ContentDispositionInvalid();
    internal static string get_MimePartCantResetStream();
    internal static string get_MediaTypeInvalid();
    internal static string get_InvalidPort();
    internal static string get_MailHeaderInvalidCID();
    internal static string get_MailServerResponse();
    internal static string get_net_inasync();
    internal static string get_net_timeout();
    internal static string get_SmtpAllRecipientsFailed();
    internal static string get_SmtpBadCommandSequence();
    internal static string get_SmtpClientNotPermitted();
    internal static string get_SmtpCommandNotImplemented();
    internal static string get_SmtpCommandParameterNotImplemented();
    internal static string get_SmtpCommandUnrecognized();
    internal static string get_SmtpExceededStorageAllocation();
    internal static string get_SmtpFromRequired();
    internal static string get_SmtpHelpMessage();
    internal static string get_SmtpInsufficientStorage();
    internal static string get_SmtpInvalidHostName();
    internal static string get_SmtpInvalidOperationDuringSend();
    internal static string get_SmtpLocalErrorInProcessing();
    internal static string get_SmtpMailboxBusy();
    internal static string get_SmtpMailboxNameNotAllowed();
    internal static string get_SmtpMailboxUnavailable();
    internal static string get_SmtpMustIssueStartTlsFirst();
    internal static string get_SmtpNeedAbsolutePickupDirectory();
    internal static string get_SmtpNonAsciiUserNotSupported();
    internal static string get_SmtpOK();
    internal static string get_SmtpPickupDirectoryDoesnotSupportSsl();
    internal static string get_SmtpRecipientFailed();
    internal static string get_SmtpRecipientRequired();
    internal static string get_SmtpSendMailFailure();
    internal static string get_SmtpServiceClosingTransmissionChannel();
    internal static string get_SmtpServiceReady();
    internal static string get_SmtpStartMailInput();
    internal static string get_SmtpSyntaxError();
    internal static string get_SmtpSystemStatus();
    internal static string get_SmtpTransactionFailed();
    internal static string get_SmtpUserNotLocalTryAlternatePath();
    internal static string get_SmtpUserNotLocalWillForward();
    internal static string get_UnspecifiedHost();
    internal static string get_SmtpAlreadyConnected();
    internal static string get_SmtpAuthenticationFailed();
    internal static string get_net_completed_result();
    internal static string get_MailHeaderFieldInvalidCharacter();
    internal static string get_SeekNotSupported();
    internal static string get_ReadNotSupported();
    internal static string get_WriteNotSupported();
    internal static string get_MailAddressInvalidFormat();
    internal static string get_SmtpAuthResponseInvalid();
    internal static string get_net_webstatus_ServerProtocolViolation();
    internal static string get_SmtpDataStreamOpen();
    internal static string get_SmtpEhloResponseInvalid();
    internal static string get_net_io_readfailure();
    internal static string get_net_io_connectionclosed();
    internal static string get_SmtpInvalidResponse();
    internal static string get_SmtpServiceNotAvailable();
    internal static string get_MailSubjectInvalidFormat();
    internal static string get_MailServerDoesNotSupportStartTls();
    internal static string get_MailHostNotFound();
    internal static string get_SmtpGetIisPickupDirectoryNotSupported();
}
[ExtensionAttribute]
internal static class System.StringExtensions : object {
    [ExtensionAttribute]
internal static string SubstringTrim(string value, int startIndex, int length);
}
