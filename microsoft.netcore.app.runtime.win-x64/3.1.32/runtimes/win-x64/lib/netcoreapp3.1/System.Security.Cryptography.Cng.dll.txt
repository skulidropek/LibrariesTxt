internal static class FxResources.System.Security.Cryptography.Cng.SR : object {
}
internal static class Internal.Cryptography.AesBCryptModes : object {
    private static SafeAlgorithmHandle s_hAlgCbc;
    private static SafeAlgorithmHandle s_hAlgEcb;
    private static AesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode);
    internal static SafeAlgorithmHandle OpenAesAlgorithm(string cipherMode);
}
internal abstract class Internal.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes);
    public abstract virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public abstract virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
internal class Internal.Cryptography.BasicSymmetricCipherBCrypt : BasicSymmetricCipher {
    private bool _encrypting;
    private SafeKeyHandle _hKey;
    private Byte[] _currentIv;
    public BasicSymmetricCipherBCrypt(SafeAlgorithmHandle algorithm, CipherMode cipherMode, int blockSizeInBytes, Byte[] key, bool ownsParentHandle, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    private void Reset();
}
internal class Internal.Cryptography.BasicSymmetricCipherNCrypt : BasicSymmetricCipher {
    private CngKey _cngKey;
    private bool _encrypting;
    private static CngProperty s_ECBMode;
    private static CngProperty s_CBCMode;
    public BasicSymmetricCipherNCrypt(Func`1<CngKey> cngKeyFactory, CipherMode cipherMode, int blockSizeInBytes, Byte[] iv, bool encrypting);
    private static BasicSymmetricCipherNCrypt();
    public sealed virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public sealed virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
    private static CngProperty CreateCngPropertyForCipherMode(string cipherMode);
}
internal class Internal.Cryptography.CngAlgorithmCore : ValueType {
    private string _disposedName;
    public CngAlgorithm DefaultKeyType;
    private CngKey _lazyKey;
    private bool _disposed;
    public CngAlgorithmCore(string disposedName);
    public static CngKey Duplicate(CngKey key);
    public bool IsKeyGeneratedNamedCurve();
    public void DisposeKey();
    public CngKey GetOrGenerateKey(int keySize, CngAlgorithm algorithm);
    public CngKey GetOrGenerateKey(Nullable`1<ECCurve> curve);
    public void SetKey(CngKey key);
    public void Dispose();
    internal void ThrowIfDisposed();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CngCommon : object {
    public static Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    public static bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public static Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    [ExtensionAttribute]
public static Byte[] SignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, int estimatedSize);
    [ExtensionAttribute]
public static bool TrySignHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, Span`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo, Int32& bytesWritten);
    [ExtensionAttribute]
public static bool VerifyHash(SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, AsymmetricPaddingMode paddingMode, Void* pPaddingInfo);
}
internal class Internal.Cryptography.CngSymmetricAlgorithmCore : ValueType {
    private ICngSymmetricAlgorithm _outer;
    private string _keyName;
    private CngProvider _provider;
    private CngKeyOpenOptions _optionOptions;
    private bool KeyInPlainText { get; }
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer);
    public CngSymmetricAlgorithmCore(ICngSymmetricAlgorithm outer, string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public Byte[] GetKeyIfExportable();
    public void SetKey(Byte[] key);
    public void SetKeySize(int keySize, ICngSymmetricAlgorithm outer);
    public void GenerateKey();
    public void GenerateIV();
    public ICryptoTransform CreateEncryptor();
    public ICryptoTransform CreateDecryptor();
    public ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    private ICryptoTransform CreateCryptoTransform(bool encrypting);
    private ICryptoTransform CreateCryptoTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
    private ICryptoTransform CreateEphemeralCryptoTransformCore(Byte[] key, Byte[] iv, bool encrypting);
    private ICryptoTransform CreatePersistedCryptoTransformCore(Func`1<CngKey> cngKeyFactory, Byte[] iv, bool encrypting);
    private CngKey ProduceCngKey();
    private bool get_KeyInPlainText();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.ErrorCodeHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(ErrorCode errorCode);
}
internal abstract class Internal.Cryptography.HashProvider : object {
    public int HashSizeInBytes { get; }
    public void AppendHashData(Byte[] data, int offset, int count);
    public abstract virtual void AppendHashData(ReadOnlySpan`1<byte> data);
    public abstract virtual Byte[] FinalizeHashAndReset();
    public abstract virtual bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public abstract virtual int get_HashSizeInBytes();
    public sealed virtual void Dispose();
    public abstract virtual void Dispose(bool disposing);
}
internal class Internal.Cryptography.HashProviderCng : HashProvider {
    private SafeBCryptAlgorithmHandle _hAlgorithm;
    private SafeBCryptHashHandle _hHash;
    private Byte[] _key;
    private bool _reusable;
    private int _hashSize;
    public int HashSizeInBytes { get; }
    public HashProviderCng(string hashAlgId, Byte[] key);
    public sealed virtual void AppendHashData(ReadOnlySpan`1<byte> source);
    public sealed virtual Byte[] FinalizeHashAndReset();
    public virtual bool TryFinalizeHashAndReset(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual void Dispose(bool disposing);
    public sealed virtual int get_HashSizeInBytes();
    private void ResetHashObject();
    private void DestroyHash();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    [ExtensionAttribute]
public static Byte[] MapZeroLengthArrayToNonNullPointer(Byte[] src);
    [ExtensionAttribute]
public static SafeNCryptProviderHandle OpenStorageProvider(CngProvider provider);
    [ExtensionAttribute]
public static Byte[] GetProperty(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static string GetPropertyAsString(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static int GetPropertyAsDword(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static IntPtr GetPropertyAsIntPtr(SafeNCryptHandle ncryptHandle, string propertyName, CngPropertyOptions options);
    [ExtensionAttribute]
public static void SetExportPolicy(SafeNCryptKeyHandle keyHandle, CngExportPolicies exportPolicy);
    [ExtensionAttribute]
public static int BitSizeToByteSize(int bits);
    public static Byte[] GenerateRandom(int count);
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
}
internal interface Internal.Cryptography.ICngSymmetricAlgorithm {
    public int BlockSize { get; }
    public CipherMode Mode { get; }
    public PaddingMode Padding { get; }
    public Byte[] IV { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public Byte[] BaseKey { get; public set; }
    public int BaseKeySize { get; public set; }
    public abstract virtual int get_BlockSize();
    public abstract virtual CipherMode get_Mode();
    public abstract virtual PaddingMode get_Padding();
    public abstract virtual Byte[] get_IV();
    public abstract virtual void set_IV(Byte[] value);
    public abstract virtual KeySizes[] get_LegalKeySizes();
    public abstract virtual Byte[] get_BaseKey();
    public abstract virtual void set_BaseKey(Byte[] value);
    public abstract virtual int get_BaseKeySize();
    public abstract virtual void set_BaseKeySize(int value);
    public abstract virtual bool IsWeakKey(Byte[] key);
    public abstract virtual SafeAlgorithmHandle GetEphemeralModeHandle();
    public abstract virtual string GetNCryptAlgorithmIdentifier();
    public abstract virtual Byte[] PreprocessKey(Byte[] key);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.SymmetricImportExportExtensions : object {
    private static CngKeyBlobFormat s_cipherKeyBlobFormat;
    private static SymmetricImportExportExtensions();
    [ExtensionAttribute]
public static Byte[] GetSymmetricKeyDataIfExportable(CngKey cngKey, string algorithm);
}
internal static class Internal.Cryptography.TripleDesBCryptModes : object {
    private static SafeAlgorithmHandle s_hAlgCbc;
    private static SafeAlgorithmHandle s_hAlgEcb;
    private static TripleDesBCryptModes();
    internal static SafeAlgorithmHandle GetSharedHandle(CipherMode cipherMode);
    private static SafeAlgorithmHandle Open3DesAlgorithm(string cipherMode);
}
internal class Internal.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    private bool DepaddingRequired { get; }
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
    private bool get_DepaddingRequired();
    private Byte[] DepadBlock(Byte[] block, int offset, int count);
}
internal class Internal.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] PadBlock(Byte[] block, int offset, int count);
}
internal abstract class Internal.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static ICryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.Cng : object {
    public static SafeAlgorithmHandle BCryptOpenAlgorithmProvider(string pszAlgId, string pszImplementation, OpenAlgorithmProviderFlags dwFlags);
    [ExtensionAttribute]
public static SafeKeyHandle BCryptImportKey(SafeAlgorithmHandle hAlg, ReadOnlySpan`1<byte> key);
    [ExtensionAttribute]
public static void SetCipherMode(SafeAlgorithmHandle hAlg, string cipherMode);
    [ExtensionAttribute]
public static int BCryptEncrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    [ExtensionAttribute]
public static int BCryptDecrypt(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] iv, Byte[] output, int outputOffset, int outputCount);
    private static Exception CreateCryptographicException(NTSTATUS ntStatus);
}
internal class Internal.NativeCrypto.SafeAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptCloseAlgorithmProvider(IntPtr hAlgorithm, int dwFlags);
}
internal class Internal.NativeCrypto.SafeKeyHandle : SafeBCryptHandle {
    private SafeAlgorithmHandle _parentHandle;
    public void SetParentHandle(SafeAlgorithmHandle parentHandle);
    protected sealed virtual bool ReleaseHandle();
    private static UInt32 BCryptDestroyKey(IntPtr hKey);
}
internal static class Interop : object {
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptAlgorithmHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
internal abstract class Microsoft.Win32.SafeHandles.SafeBCryptHandle : SafeHandle {
    public bool IsInvalid { get; }
    public sealed virtual bool get_IsInvalid();
    protected abstract virtual bool ReleaseHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeBCryptHashHandle : SafeBCryptHandle {
    protected sealed virtual bool ReleaseHandle();
}
public abstract class Microsoft.Win32.SafeHandles.SafeNCryptHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private OwnershipState _ownershipState;
    private SafeNCryptHandle _holder;
    private SafeHandle _parentHandle;
    private SafeNCryptHandle Holder { get; private set; }
    protected SafeNCryptHandle(IntPtr handle, SafeHandle parentHandle);
    private SafeNCryptHandle get_Holder();
    private void set_Holder(SafeNCryptHandle value);
    internal T Duplicate();
    private T DuplicateDuplicatedHandle();
    private T DuplicateOwnerHandle();
    protected virtual bool ReleaseHandle();
    protected abstract virtual bool ReleaseNativeHandle();
    internal bool ReleaseNativeWithNCryptFreeObject();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptKeyHandle : SafeNCryptHandle {
    public SafeNCryptKeyHandle(IntPtr handle, SafeHandle parentHandle);
    internal SafeNCryptKeyHandle Duplicate();
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptProviderHandle : SafeNCryptHandle {
    internal SafeNCryptProviderHandle Duplicate();
    internal void SetHandleValue(IntPtr newHandleValue);
    protected virtual bool ReleaseNativeHandle();
}
public class Microsoft.Win32.SafeHandles.SafeNCryptSecretHandle : SafeNCryptHandle {
    protected virtual bool ReleaseNativeHandle();
}
internal class Microsoft.Win32.SafeHandles.SafeUnicodeStringHandle : SafeHandle {
    public bool IsInvalid { get; }
    public SafeUnicodeStringHandle(string s);
    public SafeUnicodeStringHandle(ReadOnlySpan`1<char> s);
    public sealed virtual bool get_IsInvalid();
    protected sealed virtual bool ReleaseHandle();
}
internal class System.Buffers.PointerMemoryManager`1 : MemoryManager`1<T> {
    private Void* _pointer;
    private int _length;
    internal PointerMemoryManager`1(Void* pointer, int length);
    protected virtual void Dispose(bool disposing);
    public virtual Span`1<T> GetSpan();
    public virtual MemoryHandle Pin(int elementIndex);
    public virtual void Unpin();
}
public class System.Security.Cryptography.AesCng : Aes {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int Internal.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    public AesCng(string keyName);
    public AesCng(string keyName, CngProvider provider);
    public AesCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool Internal.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override SafeAlgorithmHandle Internal.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle();
    private sealed virtual override string Internal.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
}
internal class System.Security.Cryptography.Asn1.AlgorithmIdentifierAsn : ValueType {
    internal Oid Algorithm;
    internal Nullable`1<ReadOnlyMemory`1<byte>> Parameters;
    internal static ReadOnlyMemory`1<byte> ExplicitDerNull;
    private static AlgorithmIdentifierAsn();
    internal static void Decode(AsnReader reader, AlgorithmIdentifierAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, AlgorithmIdentifierAsn& decoded);
    internal bool HasNullEquivalentParameters();
    private static bool RepresentsNull(Nullable`1<ReadOnlyMemory`1<byte>> parameters);
}
internal class System.Security.Cryptography.Asn1.Asn1Tag : ValueType {
    private byte _controlFlags;
    [CompilerGeneratedAttribute]
private int <TagValue>k__BackingField;
    public static Asn1Tag EndOfContents;
    public static Asn1Tag Boolean;
    public static Asn1Tag Integer;
    public static Asn1Tag PrimitiveBitString;
    public static Asn1Tag ConstructedBitString;
    public static Asn1Tag PrimitiveOctetString;
    public static Asn1Tag ConstructedOctetString;
    public static Asn1Tag Null;
    public static Asn1Tag ObjectIdentifier;
    public static Asn1Tag Enumerated;
    public static Asn1Tag Sequence;
    public static Asn1Tag SetOf;
    public static Asn1Tag UtcTime;
    public static Asn1Tag GeneralizedTime;
    public TagClass TagClass { get; }
    public bool IsConstructed { get; }
    public int TagValue { get; private set; }
    private Asn1Tag(byte controlFlags, int tagValue);
    private static Asn1Tag();
    public TagClass get_TagClass();
    public bool get_IsConstructed();
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public int get_TagValue();
    [CompilerGeneratedAttribute]
private void set_TagValue(int value);
    public Asn1Tag AsConstructed();
    public Asn1Tag AsPrimitive();
    public static bool TryDecode(ReadOnlySpan`1<byte> source, Asn1Tag& tag, Int32& bytesConsumed);
    public int CalculateEncodedSize();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public sealed virtual bool Equals(Asn1Tag other);
    public virtual bool Equals(object obj);
    public virtual int GetHashCode();
    public static bool op_Equality(Asn1Tag left, Asn1Tag right);
    public static bool op_Inequality(Asn1Tag left, Asn1Tag right);
    public bool HasSameClassAndValue(Asn1Tag other);
    public virtual string ToString();
}
internal enum System.Security.Cryptography.Asn1.AsnEncodingRules : Enum {
    public int value__;
    public static AsnEncodingRules BER;
    public static AsnEncodingRules CER;
    public static AsnEncodingRules DER;
}
internal class System.Security.Cryptography.Asn1.AsnReader : object {
    private ReadOnlyMemory`1<byte> _data;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public bool HasData { get; }
    public AsnReader(ReadOnlyMemory`1<byte> data, AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public bool get_HasData();
    public void ThrowIfNotEmpty();
    public Asn1Tag PeekTag();
    public ReadOnlyMemory`1<byte> PeekEncodedValue();
    public ReadOnlyMemory`1<byte> ReadEncodedValue();
    private static bool TryReadLength(ReadOnlySpan`1<byte> source, AsnEncodingRules ruleSet, Nullable`1& length, Int32& bytesRead);
    internal Asn1Tag ReadTagAndLength(Nullable`1& contentsLength, Int32& bytesRead);
    private static void ValidateEndOfContents(Asn1Tag tag, Nullable`1<int> length, int headerLength);
    private int SeekEndOfContents(ReadOnlyMemory`1<byte> source);
    private static ReadOnlyMemory`1<byte> Slice(ReadOnlyMemory`1<byte> source, int offset, Nullable`1<int> length);
    private static void CheckEncodingRules(AsnEncodingRules ruleSet);
    private static void CheckExpectedTag(Asn1Tag tag, Asn1Tag expectedTag, UniversalTagNumber tagNumber);
    public bool TryReadInt32(Int32& value);
    public bool TryReadInt32(Asn1Tag expectedTag, Int32& value);
    public bool TryReadUInt8(Byte& value);
    public bool TryReadUInt8(Asn1Tag expectedTag, Byte& value);
    private ReadOnlyMemory`1<byte> GetIntegerContents(Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int32& headerLength);
    private bool TryReadSignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, Int64& value);
    private bool TryReadUnsignedInteger(int sizeLimit, Asn1Tag expectedTag, UniversalTagNumber tagNumber, UInt64& value);
    public bool TryCopyOctetStringBytes(Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, Span`1<byte> destination, Int32& bytesWritten);
    public bool TryCopyOctetStringBytes(Asn1Tag expectedTag, ArraySegment`1<byte> destination, Int32& bytesWritten);
    public Byte[] ReadOctetString();
    public Byte[] ReadOctetString(Asn1Tag expectedTag);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, Asn1Tag& actualTag, Nullable`1& contentLength, Int32& headerLength, ReadOnlyMemory`1& contents, UniversalTagNumber universalTagNumber);
    private bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, UniversalTagNumber universalTagNumber, ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(ReadOnlyMemory`1& contents);
    public bool TryReadPrimitiveOctetStringBytes(Asn1Tag expectedTag, ReadOnlyMemory`1& contents);
    private int CountConstructedOctetString(ReadOnlyMemory`1<byte> source, bool isIndefinite);
    private void CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    private int CopyConstructedOctetString(ReadOnlyMemory`1<byte> source, Span`1<byte> destination, bool write, bool isIndefinite, Int32& bytesRead);
    private bool TryCopyConstructedOctetStringContents(ReadOnlyMemory`1<byte> source, Span`1<byte> dest, bool isIndefinite, Int32& bytesRead, Int32& bytesWritten);
    public Oid ReadObjectIdentifier();
    public Oid ReadObjectIdentifier(Asn1Tag expectedTag);
    private static void ReadSubIdentifier(ReadOnlySpan`1<byte> source, Int32& bytesRead, Nullable`1& smallValue, Nullable`1& largeValue);
    private string ReadObjectIdentifierAsString(Asn1Tag expectedTag, Int32& totalBytesRead);
    public AsnReader ReadSequence(Asn1Tag expectedTag);
}
internal class System.Security.Cryptography.Asn1.AsnWriter : object {
    private Byte[] _buffer;
    private int _offset;
    private Stack`1<ValueTuple`3<Asn1Tag, int, UniversalTagNumber>> _nestingStack;
    [CompilerGeneratedAttribute]
private AsnEncodingRules <RuleSet>k__BackingField;
    public AsnEncodingRules RuleSet { get; }
    public AsnWriter(AsnEncodingRules ruleSet);
    [CompilerGeneratedAttribute]
public AsnEncodingRules get_RuleSet();
    public sealed virtual void Dispose();
    public bool TryEncode(Span`1<byte> destination, Int32& bytesWritten);
    public Byte[] Encode();
    internal ReadOnlySpan`1<byte> EncodeAsSpan();
    private void CheckDisposed();
    private void EnsureWriteCapacity(int pendingCount);
    private void WriteTag(Asn1Tag tag);
    private void WriteLength(int length);
    private static int GetEncodedLengthSubsequentByteCount(int length);
    public void WriteEncodedValue(ReadOnlySpan`1<byte> preEncodedValue);
    private void WriteEncodedValue(ReadOnlyMemory`1<byte> preEncodedValue);
    private void WriteEndOfContents();
    private void PushTag(Asn1Tag tag, UniversalTagNumber tagType);
    private void PopTag(Asn1Tag tag, UniversalTagNumber tagType, bool sortContents);
    private static void SortContents(Byte[] buffer, int start, int end);
    internal static void Reverse(Span`1<byte> span);
    private static void CheckUniversalTag(Asn1Tag tag, UniversalTagNumber universalTagNumber);
    public void WriteInteger(long value);
    private void WriteIntegerCore(Asn1Tag tag, long value);
    private void WriteNonNegativeIntegerCore(Asn1Tag tag, ulong value);
    public void WriteNull();
    private void WriteNullCore(Asn1Tag tag);
    public void WriteOctetString(ReadOnlySpan`1<byte> octetString);
    public void WriteOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteOctetStringCore(Asn1Tag tag, ReadOnlySpan`1<byte> octetString);
    private void WriteConstructedCerOctetString(Asn1Tag tag, ReadOnlySpan`1<byte> payload);
    public void WriteObjectIdentifier(string oidValue);
    public void WriteObjectIdentifier(ReadOnlySpan`1<char> oidValue);
    private void WriteObjectIdentifierCore(Asn1Tag tag, ReadOnlySpan`1<char> oidValue);
    private static BigInteger ParseSubIdentifier(ReadOnlySpan`1& oidValue);
    private static int AtoI(char c);
    private static int EncodeSubIdentifier(Span`1<byte> dest, BigInteger& subIdentifier);
    public void PushSequence();
    public void PopSequence();
    private void PushSequenceCore(Asn1Tag tag);
    private void PopSequenceCore(Asn1Tag tag);
}
internal class System.Security.Cryptography.Asn1.EncryptedPrivateKeyInfoAsn : ValueType {
    internal AlgorithmIdentifierAsn EncryptionAlgorithm;
    internal ReadOnlyMemory`1<byte> EncryptedData;
    internal static void Decode(AsnReader reader, EncryptedPrivateKeyInfoAsn& decoded);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, EncryptedPrivateKeyInfoAsn& decoded);
}
internal class System.Security.Cryptography.Asn1.PBEParameter : ValueType {
    internal ReadOnlyMemory`1<byte> Salt;
    internal int IterationCount;
    internal static PBEParameter Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBEParameter Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBEParameter& decoded);
}
internal class System.Security.Cryptography.Asn1.PBES2Params : ValueType {
    internal AlgorithmIdentifierAsn KeyDerivationFunc;
    internal AlgorithmIdentifierAsn EncryptionScheme;
    internal static PBES2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static PBES2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, PBES2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2Params : ValueType {
    private static Byte[] s_defaultPrf;
    internal Pbkdf2SaltChoice Salt;
    internal int IterationCount;
    internal Nullable`1<byte> KeyLength;
    internal AlgorithmIdentifierAsn Prf;
    private static Pbkdf2Params();
    internal static Pbkdf2Params Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Pbkdf2Params Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Pbkdf2Params& decoded);
}
internal class System.Security.Cryptography.Asn1.Pbkdf2SaltChoice : ValueType {
    internal Nullable`1<ReadOnlyMemory`1<byte>> Specified;
    internal Nullable`1<AlgorithmIdentifierAsn> OtherSource;
    internal static void Decode(AsnReader reader, Pbkdf2SaltChoice& decoded);
}
internal class System.Security.Cryptography.Asn1.Rc2CbcParameters : ValueType {
    internal int Rc2Version;
    internal ReadOnlyMemory`1<byte> Iv;
    private static Byte[] s_rc2EkbEncoding;
    private static Rc2CbcParameters();
    internal static Rc2CbcParameters Decode(ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static Rc2CbcParameters Decode(Asn1Tag expectedTag, ReadOnlyMemory`1<byte> encoded, AsnEncodingRules ruleSet);
    internal static void Decode(AsnReader reader, Asn1Tag expectedTag, Rc2CbcParameters& decoded);
    internal int GetEffectiveKeyBits();
}
internal class System.Security.Cryptography.Asn1.SetOfValueComparer : object {
    [CompilerGeneratedAttribute]
private static SetOfValueComparer <Instance>k__BackingField;
    internal static SetOfValueComparer Instance { get; }
    private static SetOfValueComparer();
    [CompilerGeneratedAttribute]
internal static SetOfValueComparer get_Instance();
    public sealed virtual int Compare(ReadOnlyMemory`1<byte> x, ReadOnlyMemory`1<byte> y);
}
internal enum System.Security.Cryptography.Asn1.TagClass : Enum {
    public byte value__;
    public static TagClass Universal;
    public static TagClass Application;
    public static TagClass ContextSpecific;
    public static TagClass Private;
}
internal enum System.Security.Cryptography.Asn1.UniversalTagNumber : Enum {
    public int value__;
    public static UniversalTagNumber EndOfContents;
    public static UniversalTagNumber Boolean;
    public static UniversalTagNumber Integer;
    public static UniversalTagNumber BitString;
    public static UniversalTagNumber OctetString;
    public static UniversalTagNumber Null;
    public static UniversalTagNumber ObjectIdentifier;
    public static UniversalTagNumber ObjectDescriptor;
    public static UniversalTagNumber External;
    public static UniversalTagNumber InstanceOf;
    public static UniversalTagNumber Real;
    public static UniversalTagNumber Enumerated;
    public static UniversalTagNumber Embedded;
    public static UniversalTagNumber UTF8String;
    public static UniversalTagNumber RelativeObjectIdentifier;
    public static UniversalTagNumber Time;
    public static UniversalTagNumber Sequence;
    public static UniversalTagNumber SequenceOf;
    public static UniversalTagNumber Set;
    public static UniversalTagNumber SetOf;
    public static UniversalTagNumber NumericString;
    public static UniversalTagNumber PrintableString;
    public static UniversalTagNumber TeletexString;
    public static UniversalTagNumber T61String;
    public static UniversalTagNumber VideotexString;
    public static UniversalTagNumber IA5String;
    public static UniversalTagNumber UtcTime;
    public static UniversalTagNumber GeneralizedTime;
    public static UniversalTagNumber GraphicString;
    public static UniversalTagNumber VisibleString;
    public static UniversalTagNumber ISO646String;
    public static UniversalTagNumber GeneralString;
    public static UniversalTagNumber UniversalString;
    public static UniversalTagNumber UnrestrictedCharacterString;
    public static UniversalTagNumber BMPString;
    public static UniversalTagNumber Date;
    public static UniversalTagNumber TimeOfDay;
    public static UniversalTagNumber DateTime;
    public static UniversalTagNumber Duration;
    public static UniversalTagNumber ObjectIdentifierIRI;
    public static UniversalTagNumber RelativeObjectIdentifierIRI;
}
public class System.Security.Cryptography.CngAlgorithm : object {
    private static CngAlgorithm s_ecdh;
    private static CngAlgorithm s_ecdhp256;
    private static CngAlgorithm s_ecdhp384;
    private static CngAlgorithm s_ecdhp521;
    private static CngAlgorithm s_ecdsa;
    private static CngAlgorithm s_ecdsap256;
    private static CngAlgorithm s_ecdsap384;
    private static CngAlgorithm s_ecdsap521;
    private static CngAlgorithm s_md5;
    private static CngAlgorithm s_sha1;
    private static CngAlgorithm s_sha256;
    private static CngAlgorithm s_sha384;
    private static CngAlgorithm s_sha512;
    private static CngAlgorithm s_rsa;
    private string _algorithm;
    public string Algorithm { get; }
    public static CngAlgorithm Rsa { get; }
    public static CngAlgorithm ECDiffieHellman { get; }
    public static CngAlgorithm ECDiffieHellmanP256 { get; }
    public static CngAlgorithm ECDiffieHellmanP384 { get; }
    public static CngAlgorithm ECDiffieHellmanP521 { get; }
    public static CngAlgorithm ECDsa { get; }
    public static CngAlgorithm ECDsaP256 { get; }
    public static CngAlgorithm ECDsaP384 { get; }
    public static CngAlgorithm ECDsaP521 { get; }
    public static CngAlgorithm MD5 { get; }
    public static CngAlgorithm Sha1 { get; }
    public static CngAlgorithm Sha256 { get; }
    public static CngAlgorithm Sha384 { get; }
    public static CngAlgorithm Sha512 { get; }
    public CngAlgorithm(string algorithm);
    public string get_Algorithm();
    public static bool op_Equality(CngAlgorithm left, CngAlgorithm right);
    public static bool op_Inequality(CngAlgorithm left, CngAlgorithm right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithm other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithm get_Rsa();
    public static CngAlgorithm get_ECDiffieHellman();
    public static CngAlgorithm get_ECDiffieHellmanP256();
    public static CngAlgorithm get_ECDiffieHellmanP384();
    public static CngAlgorithm get_ECDiffieHellmanP521();
    public static CngAlgorithm get_ECDsa();
    public static CngAlgorithm get_ECDsaP256();
    public static CngAlgorithm get_ECDsaP384();
    public static CngAlgorithm get_ECDsaP521();
    public static CngAlgorithm get_MD5();
    public static CngAlgorithm get_Sha1();
    public static CngAlgorithm get_Sha256();
    public static CngAlgorithm get_Sha384();
    public static CngAlgorithm get_Sha512();
}
public class System.Security.Cryptography.CngAlgorithmGroup : object {
    private static CngAlgorithmGroup s_dh;
    private static CngAlgorithmGroup s_dsa;
    private static CngAlgorithmGroup s_ecdh;
    private static CngAlgorithmGroup s_ecdsa;
    private static CngAlgorithmGroup s_rsa;
    private string _algorithmGroup;
    public string AlgorithmGroup { get; }
    public static CngAlgorithmGroup DiffieHellman { get; }
    public static CngAlgorithmGroup Dsa { get; }
    public static CngAlgorithmGroup ECDiffieHellman { get; }
    public static CngAlgorithmGroup ECDsa { get; }
    public static CngAlgorithmGroup Rsa { get; }
    public CngAlgorithmGroup(string algorithmGroup);
    public string get_AlgorithmGroup();
    public static bool op_Equality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public static bool op_Inequality(CngAlgorithmGroup left, CngAlgorithmGroup right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngAlgorithmGroup other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngAlgorithmGroup get_DiffieHellman();
    public static CngAlgorithmGroup get_Dsa();
    public static CngAlgorithmGroup get_ECDiffieHellman();
    public static CngAlgorithmGroup get_ECDsa();
    public static CngAlgorithmGroup get_Rsa();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngExportPolicies : Enum {
    public int value__;
    public static CngExportPolicies None;
    public static CngExportPolicies AllowExport;
    public static CngExportPolicies AllowPlaintextExport;
    public static CngExportPolicies AllowArchiving;
    public static CngExportPolicies AllowPlaintextArchiving;
}
public class System.Security.Cryptography.CngKey : object {
    private SafeNCryptKeyHandle _keyHandle;
    private SafeNCryptProviderHandle _providerHandle;
    private static Byte[] s_pkcs12TripleDesOidBytes;
    public CngAlgorithm Algorithm { get; }
    public CngAlgorithmGroup AlgorithmGroup { get; }
    public CngExportPolicies ExportPolicy { get; internal set; }
    public SafeNCryptKeyHandle Handle { get; }
    public bool IsEphemeral { get; private set; }
    public bool IsMachineKey { get; }
    public string KeyName { get; }
    public int KeySize { get; }
    public CngKeyUsages KeyUsage { get; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; }
    public SafeNCryptProviderHandle ProviderHandle { get; }
    public CngUIPolicy UIPolicy { get; }
    public string UniqueName { get; }
    private CngKey(SafeNCryptProviderHandle providerHandle, SafeNCryptKeyHandle keyHandle);
    private static CngKey();
    public sealed virtual void Dispose();
    public CngProperty GetProperty(string name, CngPropertyOptions options);
    public bool HasProperty(string name, CngPropertyOptions options);
    public void SetProperty(CngProperty property);
    public CngAlgorithm get_Algorithm();
    public CngAlgorithmGroup get_AlgorithmGroup();
    public CngExportPolicies get_ExportPolicy();
    internal void set_ExportPolicy(CngExportPolicies value);
    public SafeNCryptKeyHandle get_Handle();
    public bool get_IsEphemeral();
    private void set_IsEphemeral(bool value);
    public bool get_IsMachineKey();
    public string get_KeyName();
    public int get_KeySize();
    public CngKeyUsages get_KeyUsage();
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public SafeNCryptProviderHandle get_ProviderHandle();
    public CngUIPolicy get_UIPolicy();
    public string get_UniqueName();
    public static CngKey Create(CngAlgorithm algorithm);
    public static CngKey Create(CngAlgorithm algorithm, string keyName);
    public static CngKey Create(CngAlgorithm algorithm, string keyName, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyProperties(SafeNCryptKeyHandle keyHandle, CngKeyCreationParameters creationParameters);
    private static void InitializeKeyUiPolicyProperties(SafeNCryptKeyHandle keyHandle, CngUIPolicy uiPolicy);
    internal bool IsECNamedCurve();
    internal static bool IsECNamedCurve(string algorithm);
    internal string GetCurveName(String& oidValue);
    private string GetECSpecificCurveName(String& oidValue);
    internal static CngProperty GetPropertyFromNamedCurve(ECCurve curve);
    internal static CngAlgorithm EcdsaCurveNameToAlgorithm(string name);
    internal static CngAlgorithm EcdhCurveNameToAlgorithm(string name);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, CngKeyBlobFormat format);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    public static CngKey Import(Byte[] keyBlob, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static CngKey ImportEncryptedPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password, CngProvider provider);
    internal static CngKey Import(Byte[] keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    internal static CngKey Import(ReadOnlySpan`1<byte> keyBlob, string curveName, CngKeyBlobFormat format, CngProvider provider);
    public Byte[] Export(CngKeyBlobFormat format);
    internal bool TryExportKeyBlob(string blobType, Span`1<byte> destination, Int32& bytesWritten);
    internal Byte[] ExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount);
    internal bool TryExportPkcs8KeyBlob(ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    internal static bool ExportPkcs8KeyBlob(bool allocate, SafeNCryptKeyHandle keyHandle, ReadOnlySpan`1<char> password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten, Byte[]& allocated);
    public void Delete();
    public static bool Exists(string keyName);
    public static bool Exists(string keyName, CngProvider provider);
    public static bool Exists(string keyName, CngProvider provider, CngKeyOpenOptions options);
    public static CngKey Open(string keyName);
    public static CngKey Open(string keyName, CngProvider provider);
    public static CngKey Open(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public static CngKey Open(SafeNCryptKeyHandle keyHandle, CngKeyHandleOpenOptions keyHandleOpenOptions);
}
public class System.Security.Cryptography.CngKeyBlobFormat : object {
    private static CngKeyBlobFormat s_eccPrivate;
    private static CngKeyBlobFormat s_eccPublic;
    private static CngKeyBlobFormat s_eccFullPrivate;
    private static CngKeyBlobFormat s_eccFullPublic;
    private static CngKeyBlobFormat s_genericPrivate;
    private static CngKeyBlobFormat s_genericPublic;
    private static CngKeyBlobFormat s_opaqueTransport;
    private static CngKeyBlobFormat s_pkcs8Private;
    private string _format;
    public string Format { get; }
    public static CngKeyBlobFormat EccPrivateBlob { get; }
    public static CngKeyBlobFormat EccPublicBlob { get; }
    public static CngKeyBlobFormat EccFullPrivateBlob { get; }
    public static CngKeyBlobFormat EccFullPublicBlob { get; }
    public static CngKeyBlobFormat GenericPrivateBlob { get; }
    public static CngKeyBlobFormat GenericPublicBlob { get; }
    public static CngKeyBlobFormat OpaqueTransportBlob { get; }
    public static CngKeyBlobFormat Pkcs8PrivateBlob { get; }
    public CngKeyBlobFormat(string format);
    public string get_Format();
    public static bool op_Equality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public static bool op_Inequality(CngKeyBlobFormat left, CngKeyBlobFormat right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngKeyBlobFormat other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngKeyBlobFormat get_EccPrivateBlob();
    public static CngKeyBlobFormat get_EccPublicBlob();
    public static CngKeyBlobFormat get_EccFullPrivateBlob();
    public static CngKeyBlobFormat get_EccFullPublicBlob();
    public static CngKeyBlobFormat get_GenericPrivateBlob();
    public static CngKeyBlobFormat get_GenericPublicBlob();
    public static CngKeyBlobFormat get_OpaqueTransportBlob();
    public static CngKeyBlobFormat get_Pkcs8PrivateBlob();
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyCreationOptions : Enum {
    public int value__;
    public static CngKeyCreationOptions None;
    public static CngKeyCreationOptions MachineKey;
    public static CngKeyCreationOptions OverwriteExistingKey;
}
public class System.Security.Cryptography.CngKeyCreationParameters : object {
    [CompilerGeneratedAttribute]
private Nullable`1<CngExportPolicies> <ExportPolicy>k__BackingField;
    [CompilerGeneratedAttribute]
private CngKeyCreationOptions <KeyCreationOptions>k__BackingField;
    [CompilerGeneratedAttribute]
private Nullable`1<CngKeyUsages> <KeyUsage>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyCollection <Parameters>k__BackingField;
    [CompilerGeneratedAttribute]
private IntPtr <ParentWindowHandle>k__BackingField;
    [CompilerGeneratedAttribute]
private CngUIPolicy <UIPolicy>k__BackingField;
    private CngProvider _provider;
    public Nullable`1<CngExportPolicies> ExportPolicy { get; public set; }
    public CngKeyCreationOptions KeyCreationOptions { get; public set; }
    public Nullable`1<CngKeyUsages> KeyUsage { get; public set; }
    public CngPropertyCollection Parameters { get; private set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CngProvider Provider { get; public set; }
    public CngUIPolicy UIPolicy { get; public set; }
    [CompilerGeneratedAttribute]
public Nullable`1<CngExportPolicies> get_ExportPolicy();
    [CompilerGeneratedAttribute]
public void set_ExportPolicy(Nullable`1<CngExportPolicies> value);
    [CompilerGeneratedAttribute]
public CngKeyCreationOptions get_KeyCreationOptions();
    [CompilerGeneratedAttribute]
public void set_KeyCreationOptions(CngKeyCreationOptions value);
    [CompilerGeneratedAttribute]
public Nullable`1<CngKeyUsages> get_KeyUsage();
    [CompilerGeneratedAttribute]
public void set_KeyUsage(Nullable`1<CngKeyUsages> value);
    [CompilerGeneratedAttribute]
public CngPropertyCollection get_Parameters();
    [CompilerGeneratedAttribute]
private void set_Parameters(CngPropertyCollection value);
    [CompilerGeneratedAttribute]
public IntPtr get_ParentWindowHandle();
    [CompilerGeneratedAttribute]
public void set_ParentWindowHandle(IntPtr value);
    public CngProvider get_Provider();
    public void set_Provider(CngProvider value);
    [CompilerGeneratedAttribute]
public CngUIPolicy get_UIPolicy();
    [CompilerGeneratedAttribute]
public void set_UIPolicy(CngUIPolicy value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyHandleOpenOptions : Enum {
    public int value__;
    public static CngKeyHandleOpenOptions None;
    public static CngKeyHandleOpenOptions EphemeralKey;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyOpenOptions : Enum {
    public int value__;
    public static CngKeyOpenOptions None;
    public static CngKeyOpenOptions UserKey;
    public static CngKeyOpenOptions MachineKey;
    public static CngKeyOpenOptions Silent;
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngKeyUsages : Enum {
    public int value__;
    public static CngKeyUsages None;
    public static CngKeyUsages Decryption;
    public static CngKeyUsages Signing;
    public static CngKeyUsages KeyAgreement;
    public static CngKeyUsages AllUsages;
}
internal static class System.Security.Cryptography.CngPkcs8 : object {
    private static PbeParameters s_platformParameters;
    private static CngPkcs8();
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob);
    private static Pkcs8Response ImportPkcs8(ReadOnlySpan`1<byte> keyBlob, ReadOnlySpan`1<char> password);
    internal static bool IsPlatformScheme(PbeParameters pbeParameters);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Byte[] ExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    internal static bool TryExportEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    internal static Pkcs8Response ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    internal static Pkcs8Response ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    private static AsnWriter RewriteEncryptedPkcs8PrivateKey(AsymmetricAlgorithm key, ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    private static void FillRandomAsciiString(Span`1<char> destination);
}
public class System.Security.Cryptography.CngProperty : ValueType {
    [CompilerGeneratedAttribute]
private string <Name>k__BackingField;
    [CompilerGeneratedAttribute]
private CngPropertyOptions <Options>k__BackingField;
    private Byte[] _value;
    private Nullable`1<int> _lazyHashCode;
    public string Name { get; private set; }
    public CngPropertyOptions Options { get; private set; }
    public CngProperty(string name, Byte[] value, CngPropertyOptions options);
    [CompilerGeneratedAttribute]
[IsReadOnlyAttribute]
public string get_Name();
    [CompilerGeneratedAttribute]
private void set_Name(string value);
    public Byte[] GetValue();
    [IsReadOnlyAttribute]
[CompilerGeneratedAttribute]
public CngPropertyOptions get_Options();
    [CompilerGeneratedAttribute]
private void set_Options(CngPropertyOptions value);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProperty other);
    public virtual int GetHashCode();
    public static bool op_Equality(CngProperty left, CngProperty right);
    public static bool op_Inequality(CngProperty left, CngProperty right);
    internal Byte[] GetValueWithoutCopying();
}
public class System.Security.Cryptography.CngPropertyCollection : Collection`1<CngProperty> {
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngPropertyOptions : Enum {
    public int value__;
    public static CngPropertyOptions None;
    public static CngPropertyOptions CustomProperty;
    public static CngPropertyOptions Persist;
}
public class System.Security.Cryptography.CngProvider : object {
    private static CngProvider s_msSmartCardKsp;
    private static CngProvider s_msSoftwareKsp;
    private string _provider;
    public string Provider { get; }
    public static CngProvider MicrosoftSmartCardKeyStorageProvider { get; }
    public static CngProvider MicrosoftSoftwareKeyStorageProvider { get; }
    public CngProvider(string provider);
    public string get_Provider();
    public static bool op_Equality(CngProvider left, CngProvider right);
    public static bool op_Inequality(CngProvider left, CngProvider right);
    public virtual bool Equals(object obj);
    public sealed virtual bool Equals(CngProvider other);
    public virtual int GetHashCode();
    public virtual string ToString();
    public static CngProvider get_MicrosoftSmartCardKeyStorageProvider();
    public static CngProvider get_MicrosoftSoftwareKeyStorageProvider();
}
public class System.Security.Cryptography.CngUIPolicy : object {
    [CompilerGeneratedAttribute]
private CngUIProtectionLevels <ProtectionLevel>k__BackingField;
    [CompilerGeneratedAttribute]
private string <FriendlyName>k__BackingField;
    [CompilerGeneratedAttribute]
private string <Description>k__BackingField;
    [CompilerGeneratedAttribute]
private string <UseContext>k__BackingField;
    [CompilerGeneratedAttribute]
private string <CreationTitle>k__BackingField;
    public CngUIProtectionLevels ProtectionLevel { get; private set; }
    public string FriendlyName { get; private set; }
    public string Description { get; private set; }
    public string UseContext { get; private set; }
    public string CreationTitle { get; private set; }
    public CngUIPolicy(CngUIProtectionLevels protectionLevel);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext);
    public CngUIPolicy(CngUIProtectionLevels protectionLevel, string friendlyName, string description, string useContext, string creationTitle);
    [CompilerGeneratedAttribute]
public CngUIProtectionLevels get_ProtectionLevel();
    [CompilerGeneratedAttribute]
private void set_ProtectionLevel(CngUIProtectionLevels value);
    [CompilerGeneratedAttribute]
public string get_FriendlyName();
    [CompilerGeneratedAttribute]
private void set_FriendlyName(string value);
    [CompilerGeneratedAttribute]
public string get_Description();
    [CompilerGeneratedAttribute]
private void set_Description(string value);
    [CompilerGeneratedAttribute]
public string get_UseContext();
    [CompilerGeneratedAttribute]
private void set_UseContext(string value);
    [CompilerGeneratedAttribute]
public string get_CreationTitle();
    [CompilerGeneratedAttribute]
private void set_CreationTitle(string value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CngUIProtectionLevels : Enum {
    public int value__;
    public static CngUIProtectionLevels None;
    public static CngUIProtectionLevels ProtectKey;
    public static CngUIProtectionLevels ForceHighProtection;
}
internal static class System.Security.Cryptography.CryptoPool : object {
    internal static Byte[] Rent(int minimumLength);
    internal static void Return(Byte[] array, int clearSize);
}
public class System.Security.Cryptography.DSACng : DSA {
    private CngAlgorithmCore _core;
    private CngAlgorithm _dsnCng;
    private static KeySizes[] s_legalKeySizes;
    private static int s_defaultKeySize;
    public CngKey Key { get; private set; }
    public KeySizes[] LegalKeySizes { get; }
    public string SignatureAlgorithm { get; }
    public string KeyExchangeAlgorithm { get; }
    public DSACng(CngKey key);
    public DSACng(int keySize);
    private static DSACng();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] dsaBlob, bool includePrivate);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual string get_SignatureAlgorithm();
    public virtual string get_KeyExchangeAlgorithm();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    private void ForceSetKeySize(int newKeySize);
    private static bool Supports2048KeySize();
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    private static void GenerateV1DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivate);
    private static void GenerateV2DsaBlob(Byte[]& blob, DSAParameters parameters, int cbKey, bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    private static int FromBigEndian(Byte[] b);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool TryCreateSignature(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    public virtual bool VerifySignature(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
    private ReadOnlySpan`1<byte> AdjustHashSizeIfNecessary(ReadOnlySpan`1<byte> hash, Span`1<byte> stackBuf);
    private int ComputeQLength();
}
internal static class System.Security.Cryptography.ECCng : object {
    internal static CngKey ImportKeyBlob(Byte[] ecBlob, string curveName, bool includePrivateParameters);
    internal static CngKey ImportFullKeyBlob(Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportFullKeyBlob(CngKey key, bool includePrivateParameters);
    internal static Byte[] ExportKeyBlob(CngKey key, bool includePrivateParameters, CngKeyBlobFormat& format, String& curveName);
    private static void FixupGenericBlob(Byte[] blob);
    internal static Byte[] GetNamedCurveBlob(ECParameters& parameters, bool ecdh);
    internal static Byte[] GetPrimeCurveBlob(ECParameters& parameters, bool ecdh);
    internal static void ExportNamedCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static void ExportPrimeCurveParameters(ECParameters& ecParams, Byte[] ecBlob, bool includePrivateParameters);
    internal static Byte[] GetPrimeCurveParameterBlob(ECCurve& curve);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static bool IsMagicValueOfKeyPrivate(KeyBlobMagicNumber magic);
    private static bool IsMagicValueOfKeyPublic(KeyBlobMagicNumber magic);
    private static KeyBlobMagicNumber EcdsaCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static KeyBlobMagicNumber EcdhCurveNameToMagicNumber(string name, bool includePrivateParameters);
    private static ECC_CURVE_TYPE_ENUM ConvertToCurveTypeEnum(ECCurveType value);
    private static ECCurveType ConvertToCurveTypeEnum(ECC_CURVE_TYPE_ENUM value);
    internal static SafeNCryptKeyHandle ImportKeyBlob(string blobType, ReadOnlySpan`1<byte> keyBlob, string curveName, SafeNCryptProviderHandle provider);
    internal static string EcdsaCurveNameToAlgorithm(string algorithm);
    internal static string EcdhCurveNameToAlgorithm(string algorithm);
    internal static ECC_CURVE_ALG_ID_ENUM GetHashAlgorithmId(Nullable`1<HashAlgorithmName> name);
    internal static Nullable`1<HashAlgorithmName> GetHashAlgorithmName(ECC_CURVE_ALG_ID_ENUM hashId);
}
public class System.Security.Cryptography.ECDiffieHellmanCng : ECDiffieHellman {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    private ECDiffieHellmanKeyDerivationFunction _kdf;
    private Byte[] _hmacKey;
    private Byte[] _label;
    private Byte[] _secretAppend;
    private Byte[] _secretPrepend;
    private Byte[] _seed;
    public CngAlgorithm HashAlgorithm { get; public set; }
    public ECDiffieHellmanKeyDerivationFunction KeyDerivationFunction { get; public set; }
    public Byte[] HmacKey { get; public set; }
    public Byte[] Label { get; public set; }
    public Byte[] SecretAppend { get; public set; }
    public Byte[] SecretPrepend { get; public set; }
    public Byte[] Seed { get; public set; }
    public bool UseSecretAgreementAsHmacKey { get; }
    public ECDiffieHellmanPublicKey PublicKey { get; }
    public CngKey Key { get; private set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public ECDiffieHellmanCng(CngKey key);
    public ECDiffieHellmanCng(int keySize);
    public ECDiffieHellmanCng(ECCurve curve);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    public ECDiffieHellmanKeyDerivationFunction get_KeyDerivationFunction();
    public void set_KeyDerivationFunction(ECDiffieHellmanKeyDerivationFunction value);
    public Byte[] get_HmacKey();
    public void set_HmacKey(Byte[] value);
    public Byte[] get_Label();
    public void set_Label(Byte[] value);
    public Byte[] get_SecretAppend();
    public void set_SecretAppend(Byte[] value);
    public Byte[] get_SecretPrepend();
    public void set_SecretPrepend(Byte[] value);
    public Byte[] get_Seed();
    public void set_Seed(Byte[] value);
    public bool get_UseSecretAgreementAsHmacKey();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public virtual Byte[] DeriveKeyMaterial(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public Byte[] DeriveKeyMaterial(CngKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(ECDiffieHellmanPublicKey otherPartyPublicKey);
    public SafeNCryptSecretHandle DeriveSecretAgreementHandle(CngKey otherPartyPublicKey);
    public virtual ECDiffieHellmanPublicKey get_PublicKey();
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public string ToXmlString(ECKeyXmlFormat format);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual Byte[] DeriveKeyFromHash(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyFromHmac(ECDiffieHellmanPublicKey otherPartyPublicKey, HashAlgorithmName hashAlgorithm, Byte[] hmacKey, Byte[] secretPrepend, Byte[] secretAppend);
    public virtual Byte[] DeriveKeyTls(ECDiffieHellmanPublicKey otherPartyPublicKey, Byte[] prfLabel, Byte[] prfSeed);
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
}
public class System.Security.Cryptography.ECDiffieHellmanCngPublicKey : ECDiffieHellmanPublicKey {
    private CngKeyBlobFormat _format;
    private string _curveName;
    private bool _disposed;
    public CngKeyBlobFormat BlobFormat { get; }
    internal ECDiffieHellmanCngPublicKey(Byte[] keyBlob, string curveName, CngKeyBlobFormat format);
    protected virtual void Dispose(bool disposing);
    public virtual string ToXmlString();
    public static ECDiffieHellmanCngPublicKey FromXmlString(string xml);
    public CngKeyBlobFormat get_BlobFormat();
    public static ECDiffieHellmanPublicKey FromByteArray(Byte[] publicKeyBlob, CngKeyBlobFormat format);
    internal static ECDiffieHellmanCngPublicKey FromKey(CngKey key);
    public CngKey Import();
    public virtual ECParameters ExportExplicitParameters();
    public virtual ECParameters ExportParameters();
}
public enum System.Security.Cryptography.ECDiffieHellmanKeyDerivationFunction : Enum {
    public int value__;
    public static ECDiffieHellmanKeyDerivationFunction Hash;
    public static ECDiffieHellmanKeyDerivationFunction Hmac;
    public static ECDiffieHellmanKeyDerivationFunction Tls;
}
public class System.Security.Cryptography.ECDsaCng : ECDsa {
    private CngAlgorithmCore _core;
    private CngAlgorithm _hashAlgorithm;
    public CngAlgorithm HashAlgorithm { get; public set; }
    public CngKey Key { get; private set; }
    public int KeySize { get; public set; }
    public KeySizes[] LegalKeySizes { get; }
    public ECDsaCng(CngKey key);
    public ECDsaCng(ECCurve curve);
    public ECDsaCng(int keySize);
    public CngAlgorithm get_HashAlgorithm();
    public void set_HashAlgorithm(CngAlgorithm value);
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void DisposeKey();
    private static bool IsEccAlgorithmGroup(CngAlgorithmGroup algorithmGroup);
    internal string GetCurveName(String& oidValue);
    private void ImportFullKeyBlob(Byte[] ecfullKeyBlob, bool includePrivateParameters);
    private void ImportKeyBlob(Byte[] ecfullKeyBlob, string curveName, bool includePrivateParameters);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    private Byte[] ExportFullKeyBlob(bool includePrivateParameters);
    private void AcceptImport(Pkcs8Response response);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public void FromXmlString(string xml, ECKeyXmlFormat format);
    public Byte[] SignData(Byte[] data);
    public Byte[] SignData(Byte[] data, int offset, int count);
    public Byte[] SignData(Stream data);
    public string ToXmlString(ECKeyXmlFormat format);
    public bool VerifyData(Byte[] data, Byte[] signature);
    public bool VerifyData(Byte[] data, int offset, int count, Byte[] signature);
    public bool VerifyData(Stream data, Byte[] signature);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    public virtual void GenerateKey(ECCurve curve);
    private CngKey GetKey();
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual void ImportParameters(ECParameters parameters);
    public virtual ECParameters ExportExplicitParameters(bool includePrivateParameters);
    public virtual ECParameters ExportParameters(bool includePrivateParameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    private void ForceSetKeySize(int newKeySize);
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> source, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    public virtual Byte[] SignHash(Byte[] hash);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> source, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature);
}
public enum System.Security.Cryptography.ECKeyXmlFormat : Enum {
    public int value__;
    public static ECKeyXmlFormat Rfc4050;
}
internal static class System.Security.Cryptography.KeyFormatHelper : object {
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    private static AsnWriter WriteEncryptedPkcs8(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, AsnWriter pkcs8Writer, PbeParameters pbeParameters);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    private static ArraySegment`1<byte> DecryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlySpan`1<byte> inputPasswordBytes, ReadOnlyMemory`1<byte> source, Int32& bytesRead);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<char> newPassword, PbeParameters pbeParameters);
    internal static AsnWriter ReencryptPkcs8(ReadOnlySpan`1<char> inputPassword, ReadOnlyMemory`1<byte> current, ReadOnlySpan`1<byte> newPasswordBytes, PbeParameters pbeParameters);
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
internal static class System.Security.Cryptography.PasswordBasedEncryption : object {
    private static CryptographicException AlgorithmKdfRequiresChars(string algId);
    internal static void ValidatePbeParameters(PbeParameters pbeParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes);
    internal static int Decrypt(AlgorithmIdentifierAsn& algorithmIdentifier, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    internal static void InitiateEncryption(PbeParameters pbeParameters, SymmetricAlgorithm& cipher, String& hmacOid, String& encryptionAlgorithmOid, Boolean& isPkcs12);
    internal static int Encrypt(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, SymmetricAlgorithm cipher, bool isPkcs12, ReadOnlySpan`1<byte> source, PbeParameters pbeParameters, ReadOnlySpan`1<byte> salt, Byte[] destination, Span`1<byte> ivDest);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pbes2Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static SymmetricAlgorithm OpenCipher(AlgorithmIdentifierAsn encryptionScheme, Nullable`1<byte> requestedKeyLength, Span`1& iv);
    private static void ReadIvParameter(Nullable`1<ReadOnlyMemory`1<byte>> encryptionSchemeParameters, int length, Span`1& iv);
    private static Rfc2898DeriveBytes OpenPbkdf2(ReadOnlySpan`1<byte> password, Nullable`1<ReadOnlyMemory`1<byte>> parameters, Nullable`1& requestedKeyLength);
    private static int Pbes1Decrypt(Nullable`1<ReadOnlyMemory`1<byte>> algorithmParameters, ReadOnlySpan`1<byte> password, IncrementalHash hasher, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Pkcs12PbeDecrypt(AlgorithmIdentifierAsn algorithmIdentifier, ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static int Decrypt(SymmetricAlgorithm cipher, ReadOnlySpan`1<byte> key, ReadOnlySpan`1<byte> iv, ReadOnlySpan`1<byte> encryptedData, Span`1<byte> destination);
    private static void Pbkdf1(IncrementalHash hasher, ReadOnlySpan`1<byte> password, ReadOnlySpan`1<byte> salt, int iterationCount, Span`1<byte> dk);
    internal static void WritePbeAlgorithmIdentifier(AsnWriter writer, bool isPkcs12, string encryptionAlgorithmOid, Span`1<byte> salt, int iterationCount, string hmacOid, Span`1<byte> iv);
    internal static int NormalizeIterationCount(int iterationCount);
}
internal static class System.Security.Cryptography.Pkcs.Pkcs12Kdf : object {
    private static Dictionary`2<HashAlgorithmName, Tuple`2<int, int>> s_uvLookup;
    private static Pkcs12Kdf();
    internal static void DeriveCipherKey(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    internal static void DeriveIV(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void Derive(ReadOnlySpan`1<char> password, HashAlgorithmName hashAlgorithm, int iterationCount, byte id, ReadOnlySpan`1<byte> salt, Span`1<byte> destination);
    private static void AddPlusOne(Span`1<byte> into, Span`1<byte> addend);
    private static void CircularCopy(ReadOnlySpan`1<byte> bytes, Span`1<byte> destination);
    private static void CircularCopyUtf16BE(ReadOnlySpan`1<char> password, Span`1<byte> destination);
}
public class System.Security.Cryptography.RSACng : RSA {
    private CngAlgorithmCore _core;
    private static CngKeyBlobFormat s_rsaFullPrivateBlob;
    private static CngKeyBlobFormat s_rsaPrivateBlob;
    private static CngKeyBlobFormat s_rsaPublicBlob;
    private static ConcurrentDictionary`2<HashAlgorithmName, int> s_hashSizes;
    public CngKey Key { get; private set; }
    public KeySizes[] LegalKeySizes { get; }
    public RSACng(CngKey key);
    public RSACng(int keySize);
    private static RSACng();
    protected virtual void Dispose(bool disposing);
    private void ThrowIfDisposed();
    private void ImportKeyBlob(Byte[] rsaBlob, bool includePrivate);
    private void AcceptImport(Pkcs8Response response);
    private Byte[] ExportKeyBlob(bool includePrivateParameters);
    public virtual bool TryExportPkcs8PrivateKey(Span`1<byte> destination, Int32& bytesWritten);
    private Byte[] ExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount);
    private bool TryExportEncryptedPkcs8(ReadOnlySpan`1<char> pkcs8Password, int kdfCount, Span`1<byte> destination, Int32& bytesWritten);
    public CngKey get_Key();
    private void set_Key(CngKey value);
    private SafeNCryptKeyHandle GetDuplicatedKeyHandle();
    public virtual KeySizes[] get_LegalKeySizes();
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual bool TryHashData(ReadOnlySpan`1<byte> data, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, Int32& bytesWritten);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    private void ForceSetKeySize(int newKeySize);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual bool TryEncrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    public virtual bool TryDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(Byte[] data, RSAEncryptionPadding padding, bool encrypt);
    private bool TryEncryptOrDecrypt(ReadOnlySpan`1<byte> data, Span`1<byte> destination, RSAEncryptionPadding padding, bool encrypt, Int32& bytesWritten);
    private Byte[] EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt);
    private bool TryEncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesWritten);
    private static ErrorCode EncryptOrDecrypt(SafeNCryptKeyHandle key, ReadOnlySpan`1<byte> input, Span`1<byte> output, AsymmetricPaddingMode paddingMode, Void* paddingInfo, bool encrypt, Int32& bytesNeeded);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual void ImportPkcs8PrivateKey(ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    private void ProcessPkcs8Response(Pkcs8Response response);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters);
    public virtual Byte[] ExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual bool TryExportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, PbeParameters pbeParameters, Span`1<byte> destination, Int32& bytesWritten);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    private static void ExportParameters(RSAParameters& rsaParams, Byte[] rsaBlob, bool includePrivateParameters);
    private static void CheckMagicValueOfKey(KeyBlobMagicNumber magic, bool includePrivateParameters);
    private static int GetHashSizeInBytes(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool TrySignHash(ReadOnlySpan`1<byte> hash, Span`1<byte> destination, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding, Int32& bytesWritten);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(ReadOnlySpan`1<byte> hash, ReadOnlySpan`1<byte> signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
}
internal class System.Security.Cryptography.RsaPaddingProcessor : object {
    private static Byte[] s_eightZeros;
    private static ConcurrentDictionary`2<HashAlgorithmName, RsaPaddingProcessor> s_lookup;
    private HashAlgorithmName _hashAlgorithmName;
    private int _hLen;
    private RsaPaddingProcessor(HashAlgorithmName hashAlgorithmName, int hLen);
    private static RsaPaddingProcessor();
    internal static int BytesRequiredForBitCount(int keySizeInBits);
    internal static RsaPaddingProcessor OpenProcessor(HashAlgorithmName hashAlgorithmName);
    internal static void PadPkcs1Encryption(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    internal void PadOaep(ReadOnlySpan`1<byte> source, Span`1<byte> destination);
    private void Mgf1(IncrementalHash hasher, ReadOnlySpan`1<byte> mgfSeed, Span`1<byte> mask);
    private static void FillNonZeroBytes(Span`1<byte> data);
    private static void Xor(Span`1<byte> a, ReadOnlySpan`1<byte> b);
}
public class System.Security.Cryptography.TripleDESCng : TripleDES {
    private CngSymmetricAlgorithmCore _core;
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    private Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.BaseKey { get; private set; }
    private int Internal.Cryptography.ICngSymmetricAlgorithm.BaseKeySize { get; private set; }
    public TripleDESCng(string keyName);
    public TripleDESCng(string keyName, CngProvider provider);
    public TripleDESCng(string keyName, CngProvider provider, CngKeyOpenOptions openOptions);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    protected virtual void Dispose(bool disposing);
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKey();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKey(Byte[] value);
    private sealed virtual override int Internal.Cryptography.ICngSymmetricAlgorithm.get_BaseKeySize();
    private sealed virtual override void Internal.Cryptography.ICngSymmetricAlgorithm.set_BaseKeySize(int value);
    private sealed virtual override bool Internal.Cryptography.ICngSymmetricAlgorithm.IsWeakKey(Byte[] key);
    private sealed virtual override SafeAlgorithmHandle Internal.Cryptography.ICngSymmetricAlgorithm.GetEphemeralModeHandle();
    private sealed virtual override string Internal.Cryptography.ICngSymmetricAlgorithm.GetNCryptAlgorithmIdentifier();
    private sealed virtual override Byte[] Internal.Cryptography.ICngSymmetricAlgorithm.PreprocessKey(Byte[] key);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string Argument_Invalid_SafeHandleInvalidOrClosed { get; }
    internal static string Argument_InvalidOffLen { get; }
    internal static string Argument_InvalidOidValue { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentNull_Buffer { get; }
    internal static string Cryptography_AlgKdfRequiresChars { get; }
    internal static string Cryptography_ArgECDHKeySizeMismatch { get; }
    internal static string Cryptography_ArgECDHRequiresECDHKey { get; }
    internal static string Cryptography_Asn_UniversalValueIsFixed { get; }
    internal static string Cryptography_AsnWriter_EncodeUnbalancedStack { get; }
    internal static string Cryptography_AsnWriter_PopWrongTag { get; }
    internal static string Cryptography_TlsRequiresLabelAndSeed { get; }
    internal static string Cryptography_ArgDSARequiresDSAKey { get; }
    internal static string Cryptography_ArgECDsaRequiresECDsaKey { get; }
    internal static string Cryptography_ArgRSARequiresRSAKey { get; }
    internal static string Cryptography_CngKeyWrongAlgorithm { get; }
    internal static string Cryptography_Der_Invalid_Encoding { get; }
    internal static string Cryptography_Encryption_MessageTooLong { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidAlgorithmGroup { get; }
    internal static string Cryptography_InvalidAlgorithmName { get; }
    internal static string Cryptography_InvalidCipherMode { get; }
    internal static string Cryptography_InvalidDsaParameters_MissingFields { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPGY { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedQX { get; }
    internal static string Cryptography_InvalidDsaParameters_MismatchedPJ { get; }
    internal static string Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_ShortKey { get; }
    internal static string Cryptography_InvalidDsaParameters_QRestriction_LargeKey { get; }
    internal static string Cryptography_CurveNotSupported { get; }
    internal static string Cryptography_InvalidCurveOid { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidKeyBlobFormat { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidProviderName { get; }
    internal static string Cryptography_InvalidRsaParameters { get; }
    internal static string Cryptography_KeyBlobParsingError { get; }
    internal static string Cryptography_KeyTooSmall { get; }
    internal static string Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_NotValidPrivateKey { get; }
    internal static string Cryptography_NotValidPublicOrPrivateKey { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_Pkcs8_EncryptedReadFailed { get; }
    internal static string Cryptography_SignHash_WrongSize { get; }
    internal static string Cryptography_UnsupportedPaddingMode { get; }
    internal static string Cryptography_TransformBeyondEndOfBuffer { get; }
    internal static string Cryptography_UnexpectedTransformTruncation { get; }
    internal static string Cryptography_UnknownAlgorithmIdentifier { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string Cryptography_WeakKey { get; }
    internal static string Cryptography_WriteEncodedValue_OneValueAtATime { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_Argument_Invalid_SafeHandleInvalidOrClosed();
    internal static string get_Argument_InvalidOffLen();
    internal static string get_Argument_InvalidOidValue();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentNull_Buffer();
    internal static string get_Cryptography_AlgKdfRequiresChars();
    internal static string get_Cryptography_ArgECDHKeySizeMismatch();
    internal static string get_Cryptography_ArgECDHRequiresECDHKey();
    internal static string get_Cryptography_Asn_UniversalValueIsFixed();
    internal static string get_Cryptography_AsnWriter_EncodeUnbalancedStack();
    internal static string get_Cryptography_AsnWriter_PopWrongTag();
    internal static string get_Cryptography_TlsRequiresLabelAndSeed();
    internal static string get_Cryptography_ArgDSARequiresDSAKey();
    internal static string get_Cryptography_ArgECDsaRequiresECDsaKey();
    internal static string get_Cryptography_ArgRSARequiresRSAKey();
    internal static string get_Cryptography_CngKeyWrongAlgorithm();
    internal static string get_Cryptography_Der_Invalid_Encoding();
    internal static string get_Cryptography_Encryption_MessageTooLong();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidAlgorithmGroup();
    internal static string get_Cryptography_InvalidAlgorithmName();
    internal static string get_Cryptography_InvalidCipherMode();
    internal static string get_Cryptography_InvalidDsaParameters_MissingFields();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPGY();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedQX();
    internal static string get_Cryptography_InvalidDsaParameters_MismatchedPJ();
    internal static string get_Cryptography_InvalidDsaParameters_SeedRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_ShortKey();
    internal static string get_Cryptography_InvalidDsaParameters_QRestriction_LargeKey();
    internal static string get_Cryptography_CurveNotSupported();
    internal static string get_Cryptography_InvalidCurveOid();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidKeyBlobFormat();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidProviderName();
    internal static string get_Cryptography_InvalidRsaParameters();
    internal static string get_Cryptography_KeyBlobParsingError();
    internal static string get_Cryptography_KeyTooSmall();
    internal static string get_Cryptography_OpenEphemeralKeyHandleWithoutEphemeralFlag();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_NotValidPrivateKey();
    internal static string get_Cryptography_NotValidPublicOrPrivateKey();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_Pkcs8_EncryptedReadFailed();
    internal static string get_Cryptography_SignHash_WrongSize();
    internal static string get_Cryptography_UnsupportedPaddingMode();
    internal static string get_Cryptography_TransformBeyondEndOfBuffer();
    internal static string get_Cryptography_UnexpectedTransformTruncation();
    internal static string get_Cryptography_UnknownAlgorithmIdentifier();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_Cryptography_WeakKey();
    internal static string get_Cryptography_WriteEncodedValue_OneValueAtATime();
}
