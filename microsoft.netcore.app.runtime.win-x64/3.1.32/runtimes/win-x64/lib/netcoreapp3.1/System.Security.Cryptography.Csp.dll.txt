internal static class FxResources.System.Security.Cryptography.Csp.SR : object {
}
internal abstract class Internal.Cryptography.BasicSymmetricCipher : object {
    [CompilerGeneratedAttribute]
private int <BlockSizeInBytes>k__BackingField;
    [CompilerGeneratedAttribute]
private Byte[] <IV>k__BackingField;
    public int BlockSizeInBytes { get; private set; }
    protected Byte[] IV { get; private set; }
    protected BasicSymmetricCipher(Byte[] iv, int blockSizeInBytes);
    public abstract virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public abstract virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    [CompilerGeneratedAttribute]
public int get_BlockSizeInBytes();
    [CompilerGeneratedAttribute]
private void set_BlockSizeInBytes(int value);
    public sealed virtual void Dispose();
    protected virtual void Dispose(bool disposing);
    [CompilerGeneratedAttribute]
protected Byte[] get_IV();
    [CompilerGeneratedAttribute]
private void set_IV(Byte[] value);
}
internal class Internal.Cryptography.BasicSymmetricCipherCsp : BasicSymmetricCipher {
    private bool _encrypting;
    private SafeProvHandle _hProvider;
    private SafeKeyHandle _hKey;
    public BasicSymmetricCipherCsp(int algId, CipherMode cipherMode, int blockSizeInBytes, Byte[] key, int effectiveKeyLength, bool addNoSaltFlag, Byte[] iv, bool encrypting);
    protected virtual void Dispose(bool disposing);
    public virtual int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset);
    public virtual Byte[] TransformFinal(Byte[] input, int inputOffset, int count);
    private void Reset();
    private int Transform(Byte[] input, int inputOffset, int count, Byte[] output, int outputOffset, bool isFinal);
    private static SafeKeyHandle ImportCspBlob(SafeProvHandle safeProvHandle, int algId, Byte[] rawKey, bool addNoSaltFlag);
    private static SafeProvHandle AcquireSafeProviderHandle();
}
[ExtensionAttribute]
internal static class Internal.Cryptography.CryptoThrowHelper : object {
    [ExtensionAttribute]
public static CryptographicException ToCryptographicException(int hr);
}
[ExtensionAttribute]
internal static class Internal.Cryptography.Helpers : object {
    [ExtensionAttribute]
public static bool UsesIv(CipherMode cipherMode);
    [ExtensionAttribute]
public static Byte[] GetCipherIv(CipherMode cipherMode, Byte[] iv);
    public static Byte[] TrimLargeIV(Byte[] currentIV, int blockSizeInBits);
    [ExtensionAttribute]
public static Byte[] CloneByteArray(Byte[] src);
}
internal class Internal.Cryptography.UniversalCryptoDecryptor : UniversalCryptoTransform {
    private Byte[] _heldoverCipher;
    private bool DepaddingRequired { get; }
    public UniversalCryptoDecryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected sealed virtual void Dispose(bool disposing);
    private void Reset();
    private bool get_DepaddingRequired();
    private Byte[] DepadBlock(Byte[] block, int offset, int count);
}
internal class Internal.Cryptography.UniversalCryptoEncryptor : UniversalCryptoTransform {
    public UniversalCryptoEncryptor(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    protected sealed virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected sealed virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    private Byte[] PadBlock(Byte[] block, int offset, int count);
}
internal abstract class Internal.Cryptography.UniversalCryptoTransform : object {
    [CompilerGeneratedAttribute]
private PaddingMode <PaddingMode>k__BackingField;
    [CompilerGeneratedAttribute]
private BasicSymmetricCipher <BasicSymmetricCipher>k__BackingField;
    public bool CanReuseTransform { get; }
    public bool CanTransformMultipleBlocks { get; }
    public int InputBlockSize { get; }
    public int OutputBlockSize { get; }
    protected PaddingMode PaddingMode { get; private set; }
    protected BasicSymmetricCipher BasicSymmetricCipher { get; private set; }
    protected UniversalCryptoTransform(PaddingMode paddingMode, BasicSymmetricCipher basicSymmetricCipher);
    public static ICryptoTransform Create(PaddingMode paddingMode, BasicSymmetricCipher cipher, bool encrypting);
    public sealed virtual bool get_CanReuseTransform();
    public sealed virtual bool get_CanTransformMultipleBlocks();
    public sealed virtual int get_InputBlockSize();
    public sealed virtual int get_OutputBlockSize();
    public sealed virtual void Dispose();
    public sealed virtual int TransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    public sealed virtual Byte[] TransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    protected virtual void Dispose(bool disposing);
    protected abstract virtual int UncheckedTransformBlock(Byte[] inputBuffer, int inputOffset, int inputCount, Byte[] outputBuffer, int outputOffset);
    protected abstract virtual Byte[] UncheckedTransformFinalBlock(Byte[] inputBuffer, int inputOffset, int inputCount);
    [CompilerGeneratedAttribute]
protected PaddingMode get_PaddingMode();
    [CompilerGeneratedAttribute]
private void set_PaddingMode(PaddingMode value);
    [CompilerGeneratedAttribute]
protected BasicSymmetricCipher get_BasicSymmetricCipher();
    [CompilerGeneratedAttribute]
private void set_BasicSymmetricCipher(BasicSymmetricCipher value);
}
[ExtensionAttribute]
internal static class Internal.NativeCrypto.CapiHelper : object {
    private static Byte[] s_RgbPubKey;
    private static CapiHelper();
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(DSAParameters dsaParameters);
    [ExtensionAttribute]
internal static DSAParameters ToDSAParameters(Byte[] cspBlob, bool includePrivateParameters, Byte[] cspPublicBlob);
    private static void ReadKeyBlobHeader(BinaryReader br, Byte& bVersion);
    private static void WriteKeyBlobHeader(DSAParameters dsaParameters, BinaryWriter bw, bool isPrivate, Boolean& isV3);
    private static void ReadDSSSeed(DSAParameters dsaParameters, BinaryReader br, bool isV3);
    private static void WriteDSSSeed(DSAParameters dsaParameters, BinaryWriter bw);
    [ExtensionAttribute]
internal static Byte[] ToKeyBlob(RSAParameters rsaParameters);
    [ExtensionAttribute]
private static void WriteReversed(BinaryWriter bw, Byte[] bytes);
    [ExtensionAttribute]
internal static RSAParameters ToRSAParameters(Byte[] cspBlob, bool includePrivateParameters);
    internal static byte GetKeyBlobHeaderVersion(Byte[] cspBlob);
    private static Byte[] ExponentAsBytes(UInt32 exponent);
    [ExtensionAttribute]
private static Byte[] ReadReversed(BinaryReader br, int count);
    public static string UpgradeDSS(int dwProvType, string wszProvider);
    private static void ReverseDsaSignature(Byte[] signature, int cbSignature);
    public static string UpgradeRSA(int dwProvType, string wszProvider);
    internal static string GetDefaultProvider(int dwType);
    private static void CreateCSP(CspParameters parameters, bool randomKeyContainer, SafeProvHandle& safeProvHandle);
    private static int AcquireCryptContext(SafeProvHandle& safeProvHandle, string keyContainer, string providerName, int providerType, UInt32 flags);
    internal static void AcquireCsp(CspParameters cspParameters, SafeProvHandle& safeProvHandle);
    public static int OpenCSP(CspParameters cspParameters, UInt32 flags, SafeProvHandle& safeProvHandle);
    internal static SafeProvHandle CreateProvHandle(CspParameters parameters, bool randomKeyContainer);
    internal static bool IsFlagBitSet(UInt32 dwImp, UInt32 flag);
    internal static int GetProviderParameterWorker(SafeProvHandle safeProvHandle, Byte[] impType, Int32& cb, CryptProvParam flags);
    public static object GetProviderParameter(SafeProvHandle safeProvHandle, int keyNumber, int keyParam);
    internal static int GetUserKey(SafeProvHandle safeProvHandle, int keySpec, SafeKeyHandle& safeKeyHandle);
    internal static int GenerateKey(SafeProvHandle safeProvHandle, int algID, int flags, UInt32 keySize, SafeKeyHandle& safeKeyHandle);
    internal static int MapCspKeyFlags(int flags);
    internal static UInt32 MapCspProviderFlags(int flags);
    internal static void VerifyValidHandle(SafeHandleZeroOrMinusOneIsInvalid handle);
    internal static Byte[] GetKeyParameter(SafeKeyHandle safeKeyHandle, int keyParam);
    internal static void SetKeyParameter(SafeKeyHandle safeKeyHandle, CryptGetKeyParamQueryType keyParam, Byte[] value);
    internal static void SetKeyParameter(SafeKeyHandle safeKeyHandle, CryptGetKeyParamQueryType keyParam, int value);
    internal static CspParameters SaveCspParameters(CspAlgorithmType keyType, CspParameters userParameters, CspProviderFlags defaultFlags, Boolean& randomKeyContainer);
    private static void ValidateCspFlags(CspProviderFlags flags);
    internal static SafeKeyHandle GetKeyPairHelper(CspAlgorithmType keyType, CspParameters parameters, int keySize, SafeProvHandle safeProvHandle);
    internal static int GetErrorCode();
    internal static bool GetPersistKeyInCsp(SafeProvHandle safeProvHandle);
    internal static void SetPersistKeyInCsp(SafeProvHandle safeProvHandle, bool fPersistKeyInCsp);
    internal static void DecryptKey(SafeKeyHandle safeKeyHandle, Byte[] encryptedData, int encryptedDataLength, bool fOAEP, Byte[]& decryptedData);
    internal static void EncryptKey(SafeKeyHandle safeKeyHandle, Byte[] pbKey, int cbKey, bool foep, Byte[]& pbEncryptedKey);
    internal static int EncryptData(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] output, int outputOffset, int outputCount, bool isFinal);
    internal static int DecryptData(SafeKeyHandle hKey, Byte[] input, int inputOffset, int inputCount, Byte[] output, int outputOffset, int outputCount);
    internal static void ImportKeyBlob(SafeProvHandle saveProvHandle, CspProviderFlags flags, bool addNoSaltFlag, Byte[] keyBlob, SafeKeyHandle& safeKeyHandle);
    internal static Byte[] ExportKeyBlob(bool includePrivateParameters, SafeKeyHandle safeKeyHandle);
    public static int NameOrOidToHashAlgId(string nameOrOid, OidGroup oidGroup);
    public static int ObjToHashAlgId(object hashAlg);
    internal static HashAlgorithm ObjToHashAlgorithm(object hashAlg);
    private static int GetAlgIdFromOid(string oid, OidGroup oidGroup);
    public static Byte[] SignValue(SafeProvHandle hProv, SafeKeyHandle hKey, int keyNumber, int calgKey, int calgHash, Byte[] hash);
    public static bool VerifySign(SafeProvHandle hProv, SafeKeyHandle hKey, int calgKey, int calgHash, Byte[] hash, Byte[] signature);
    public static void DeriveKey(SafeProvHandle hProv, int algid, int algidHash, Byte[] password, int cbPassword, int dwFlags, Byte[] IV_Out, int cbIV_In, Byte[]& pbKey);
    private static void UnloadKey(SafeProvHandle hProv, SafeKeyHandle hKey, Byte[]& key_out, Int32& cb_out);
    [ExtensionAttribute]
private static SafeHashHandle CreateHashHandle(SafeProvHandle hProv, Byte[] hash, int calgHash);
    public static CryptographicException GetBadDataException();
    public static CryptographicException GetEFailException();
    public static bool CryptGetUserKey(SafeProvHandle safeProvHandle, int dwKeySpec, SafeKeyHandle& safeKeyHandle);
    public static bool CryptGenKey(SafeProvHandle safeProvHandle, int algId, int dwFlags, SafeKeyHandle& safeKeyHandle);
    public static bool CryptImportKey(SafeProvHandle hProv, Byte[] pbData, int dwDataLen, SafeKeyHandle hPubKey, int dwFlags, SafeKeyHandle& phKey);
    public static bool CryptCreateHash(SafeProvHandle hProv, int algId, SafeKeyHandle hKey, CryptCreateHashFlags dwFlags, SafeHashHandle& phHash);
    public static bool CryptDeriveKey(SafeProvHandle hProv, int algId, SafeHashHandle phHash, int dwFlags, SafeKeyHandle& phKey);
    internal static Byte[] ToPlainTextKeyBlob(int algId, Byte[] rawKey);
    private static void WriteKeyBlobHeader(int algId, BinaryWriter bw);
}
internal static class Interop : object {
}
internal static class Microsoft.Win32.SafeHandles.SafeHandleCache`1 : object {
    private static T s_invalidHandle;
    internal static T GetInvalidHandle(Func`1<T> invalidHandleFactory);
    internal static bool IsCachedInvalidHandle(SafeHandle handle);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.AesCryptoServiceProvider : Aes {
    private Aes _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.CspKeyContainerInfo : object {
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    public bool Accessible { get; }
    public bool Exportable { get; }
    public bool HardwareDevice { get; }
    public string KeyContainerName { get; }
    public KeyNumber KeyNumber { get; }
    public bool MachineKeyStore { get; }
    public bool Protected { get; }
    public string ProviderName { get; }
    public int ProviderType { get; }
    public bool RandomlyGenerated { get; }
    public bool Removable { get; }
    public string UniqueKeyContainerName { get; }
    public CspKeyContainerInfo(CspParameters parameters);
    internal CspKeyContainerInfo(CspParameters parameters, bool randomKeyContainer);
    public bool get_Accessible();
    public bool get_Exportable();
    public bool get_HardwareDevice();
    public string get_KeyContainerName();
    public KeyNumber get_KeyNumber();
    public bool get_MachineKeyStore();
    public bool get_Protected();
    public string get_ProviderName();
    public int get_ProviderType();
    public bool get_RandomlyGenerated();
    public bool get_Removable();
    public string get_UniqueKeyContainerName();
    private object ReadKeyParameterSilent(int keyParam, bool throwOnNotFound);
    private object ReadDeviceParameterVerifyContext(int keyParam);
}
public class System.Security.Cryptography.CspParameters : object {
    public int ProviderType;
    public string ProviderName;
    public string KeyContainerName;
    public int KeyNumber;
    private int _flags;
    private IntPtr _parentWindowHandle;
    [CompilerGeneratedAttribute]
private SecureString <KeyPassword>k__BackingField;
    public CspProviderFlags Flags { get; public set; }
    [CLSCompliantAttribute("False")]
public SecureString KeyPassword { get; public set; }
    public IntPtr ParentWindowHandle { get; public set; }
    public CspParameters(int dwTypeIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn);
    public CspParameters(int dwTypeIn, string strProviderNameIn, string strContainerNameIn);
    internal CspParameters(int providerType, string providerName, string keyContainerName, CspProviderFlags flags);
    internal CspParameters(CspParameters parameters);
    public CspProviderFlags get_Flags();
    public void set_Flags(CspProviderFlags value);
    [CompilerGeneratedAttribute]
public SecureString get_KeyPassword();
    [CompilerGeneratedAttribute]
public void set_KeyPassword(SecureString value);
    public IntPtr get_ParentWindowHandle();
    public void set_ParentWindowHandle(IntPtr value);
}
[FlagsAttribute]
public enum System.Security.Cryptography.CspProviderFlags : Enum {
    public int value__;
    public static CspProviderFlags NoFlags;
    public static CspProviderFlags UseMachineKeyStore;
    public static CspProviderFlags UseDefaultKeyContainer;
    public static CspProviderFlags UseNonExportableKey;
    public static CspProviderFlags UseExistingKey;
    public static CspProviderFlags UseArchivableKey;
    public static CspProviderFlags UseUserProtectedKey;
    public static CspProviderFlags NoPrompt;
    public static CspProviderFlags CreateEphemeralKey;
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.DESCryptoServiceProvider : DES {
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    public virtual ICryptoTransform CreateDecryptor();
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
}
public class System.Security.Cryptography.DSACryptoServiceProvider : DSA {
    private int _keySize;
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    private SafeKeyHandle _safeKeyHandle;
    private SafeProvHandle _safeProvHandle;
    private SHA1 _sha1;
    private static CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_useMachineKeyStore;
    private bool _disposed;
    private SafeProvHandle SafeProvHandle { get; private set; }
    private SafeKeyHandle SafeKeyHandle { get; private set; }
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public DSACryptoServiceProvider(int dwKeySize);
    public DSACryptoServiceProvider(CspParameters parameters);
    public DSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    private static DSACryptoServiceProvider();
    private SafeProvHandle get_SafeProvHandle();
    private void set_SafeProvHandle(SafeProvHandle value);
    private SafeKeyHandle get_SafeKeyHandle();
    private void set_SafeKeyHandle(SafeKeyHandle value);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    protected virtual void Dispose(bool disposing);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual DSAParameters ExportParameters(bool includePrivateParameters);
    private SafeProvHandle AcquireSafeProviderHandle();
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(DSAParameters parameters);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] SignData(Stream inputStream);
    public Byte[] SignData(Byte[] buffer);
    public Byte[] SignData(Byte[] buffer, int offset, int count);
    public bool VerifyData(Byte[] rgbData, Byte[] rgbSignature);
    public virtual Byte[] CreateSignature(Byte[] rgbHash);
    public virtual bool VerifySignature(Byte[] rgbHash, Byte[] rgbSignature);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    private static bool IsPublic(Byte[] keyBlob);
    private void ThrowIfDisposed();
}
public interface System.Security.Cryptography.ICspAsymmetricAlgorithm {
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public abstract virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public abstract virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public abstract virtual void ImportCspBlob(Byte[] rawData);
}
public enum System.Security.Cryptography.KeyNumber : Enum {
    public int value__;
    public static KeyNumber Exchange;
    public static KeyNumber Signature;
}
[ExtensionAttribute]
internal static class System.Security.Cryptography.KeySizeHelpers : object {
    [ExtensionAttribute]
public static KeySizes[] CloneKeySizesArray(KeySizes[] src);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
    [ExtensionAttribute]
public static bool IsLegalSize(int size, KeySizes[] legalSizes, Boolean& validatedByZeroSkipSizeKeySizes);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.MD5CryptoServiceProvider : MD5 {
    private IncrementalHash _incrementalHash;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.PasswordDeriveBytes : DeriveBytes {
    private int _extraCount;
    private int _prefix;
    private int _iterations;
    private Byte[] _baseValue;
    private Byte[] _extra;
    private Byte[] _salt;
    private Byte[] _password;
    private string _hashName;
    private HashAlgorithm _hash;
    private CspParameters _cspParams;
    private SafeProvHandle _safeProvHandle;
    public string HashName { get; public set; }
    public int IterationCount { get; public set; }
    public Byte[] Salt { get; public set; }
    private SafeProvHandle ProvHandle { get; }
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, CspParameters cspParams);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, CspParameters cspParams);
    public PasswordDeriveBytes(string strPassword, Byte[] rgbSalt, string strHashName, int iterations, CspParameters cspParams);
    public PasswordDeriveBytes(Byte[] password, Byte[] salt, string hashName, int iterations, CspParameters cspParams);
    public string get_HashName();
    public void set_HashName(string value);
    public int get_IterationCount();
    public void set_IterationCount(int value);
    public Byte[] get_Salt();
    public void set_Salt(Byte[] value);
    [ObsoleteAttribute("Rfc2898DeriveBytes replaces PasswordDeriveBytes for deriving key material from a password and is preferred in new applications.")]
public virtual Byte[] GetBytes(int cb);
    public virtual void Reset();
    protected virtual void Dispose(bool disposing);
    private Byte[] ComputeBaseValue();
    private Byte[] ComputeBytes(int cb);
    private void HashPrefix(CryptoStream cs);
    public Byte[] CryptDeriveKey(string algname, string alghashname, int keySize, Byte[] rgbIV);
    private SafeProvHandle get_ProvHandle();
    private static SafeProvHandle AcquireSafeProviderHandle(CspParameters cspParams);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RC2CryptoServiceProvider : RC2 {
    private bool _use40bitSalt;
    private static KeySizes[] s_legalKeySizes;
    public int EffectiveKeySize { get; public set; }
    public bool UseSalt { get; public set; }
    private static RC2CryptoServiceProvider();
    public virtual int get_EffectiveKeySize();
    public virtual void set_EffectiveKeySize(int value);
    public bool get_UseSalt();
    public void set_UseSalt(bool value);
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual void GenerateKey();
    public virtual void GenerateIV();
    private ICryptoTransform CreateTransform(Byte[] rgbKey, Byte[] rgbIV, bool encrypting);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.RNGCryptoServiceProvider : RandomNumberGenerator {
    private RandomNumberGenerator _impl;
    public RNGCryptoServiceProvider(string str);
    public RNGCryptoServiceProvider(Byte[] rgb);
    public RNGCryptoServiceProvider(CspParameters cspParams);
    public virtual void GetBytes(Byte[] data);
    public virtual void GetBytes(Byte[] data, int offset, int count);
    public virtual void GetBytes(Span`1<byte> data);
    public virtual void GetNonZeroBytes(Byte[] data);
    public virtual void GetNonZeroBytes(Span`1<byte> data);
    protected virtual void Dispose(bool disposing);
}
public class System.Security.Cryptography.RSACryptoServiceProvider : RSA {
    private int _keySize;
    private CspParameters _parameters;
    private bool _randomKeyContainer;
    private SafeKeyHandle _safeKeyHandle;
    private SafeProvHandle _safeProvHandle;
    private static CspProviderFlags modreq(System.Runtime.CompilerServices.IsVolatile) s_useMachineKeyStore;
    private bool _disposed;
    private SafeProvHandle SafeProvHandle { get; private set; }
    private SafeKeyHandle SafeKeyHandle { get; private set; }
    public CspKeyContainerInfo CspKeyContainerInfo { get; }
    public int KeySize { get; }
    public KeySizes[] LegalKeySizes { get; }
    public bool PersistKeyInCsp { get; public set; }
    public bool PublicOnly { get; }
    public static bool UseMachineKeyStore { get; public set; }
    public string KeyExchangeAlgorithm { get; }
    public string SignatureAlgorithm { get; }
    public RSACryptoServiceProvider(int dwKeySize);
    public RSACryptoServiceProvider(int dwKeySize, CspParameters parameters);
    public RSACryptoServiceProvider(CspParameters parameters);
    private RSACryptoServiceProvider(int keySize, CspParameters parameters, bool useDefaultKeySize);
    private static RSACryptoServiceProvider();
    private SafeProvHandle get_SafeProvHandle();
    private void set_SafeProvHandle(SafeProvHandle value);
    private SafeKeyHandle get_SafeKeyHandle();
    private void set_SafeKeyHandle(SafeKeyHandle value);
    public sealed virtual CspKeyContainerInfo get_CspKeyContainerInfo();
    public virtual int get_KeySize();
    public virtual KeySizes[] get_LegalKeySizes();
    public bool get_PersistKeyInCsp();
    public void set_PersistKeyInCsp(bool value);
    public bool get_PublicOnly();
    public static bool get_UseMachineKeyStore();
    public static void set_UseMachineKeyStore(bool value);
    public Byte[] Decrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] DecryptValue(Byte[] rgb);
    protected virtual void Dispose(bool disposing);
    public Byte[] Encrypt(Byte[] rgb, bool fOAEP);
    public virtual Byte[] EncryptValue(Byte[] rgb);
    public sealed virtual Byte[] ExportCspBlob(bool includePrivateParameters);
    public virtual RSAParameters ExportParameters(bool includePrivateParameters);
    private SafeProvHandle AcquireSafeProviderHandle();
    public sealed virtual void ImportCspBlob(Byte[] keyBlob);
    public virtual void ImportParameters(RSAParameters parameters);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<byte> passwordBytes, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public virtual void ImportEncryptedPkcs8PrivateKey(ReadOnlySpan`1<char> password, ReadOnlySpan`1<byte> source, Int32& bytesRead);
    public Byte[] SignData(Byte[] buffer, int offset, int count, object halg);
    public Byte[] SignData(Byte[] buffer, object halg);
    public Byte[] SignData(Stream inputStream, object halg);
    public Byte[] SignHash(Byte[] rgbHash, string str);
    private Byte[] SignHash(Byte[] rgbHash, int calgHash);
    public bool VerifyData(Byte[] buffer, object halg, Byte[] signature);
    public bool VerifyHash(Byte[] rgbHash, string str, Byte[] rgbSignature);
    private bool VerifyHash(Byte[] rgbHash, int calgHash, Byte[] rgbSignature);
    private static bool IsPublic(Byte[] keyBlob);
    protected virtual Byte[] HashData(Byte[] data, int offset, int count, HashAlgorithmName hashAlgorithm);
    protected virtual Byte[] HashData(Stream data, HashAlgorithmName hashAlgorithm);
    private static HashAlgorithm GetHashAlgorithm(HashAlgorithmName hashAlgorithm);
    private static int GetAlgorithmId(HashAlgorithmName hashAlgorithm);
    public virtual Byte[] Encrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] Decrypt(Byte[] data, RSAEncryptionPadding padding);
    public virtual Byte[] SignHash(Byte[] hash, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual bool VerifyHash(Byte[] hash, Byte[] signature, HashAlgorithmName hashAlgorithm, RSASignaturePadding padding);
    public virtual string get_KeyExchangeAlgorithm();
    public virtual string get_SignatureAlgorithm();
    private static Exception PaddingModeNotSupported();
    private static Exception HashAlgorithmNameNullOrEmpty();
    private void ThrowIfDisposed();
}
internal class System.Security.Cryptography.SafeHashHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private SafeProvHandle _parent;
    internal static SafeHashHandle InvalidHandle { get; }
    internal void SetParent(SafeProvHandle parent);
    internal static SafeHashHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeKeyHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private int _keySpec;
    private bool _fPublicOnly;
    private SafeProvHandle _parent;
    unknown int KeySpec {internal set; }
    internal bool PublicOnly { get; internal set; }
    internal static SafeKeyHandle InvalidHandle { get; }
    internal void set_KeySpec(int value);
    internal bool get_PublicOnly();
    internal void set_PublicOnly(bool value);
    internal void SetParent(SafeProvHandle parent);
    internal static SafeKeyHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
internal class System.Security.Cryptography.SafeProvHandle : SafeHandleZeroOrMinusOneIsInvalid {
    private string _containerName;
    private string _providerName;
    private int _type;
    private UInt32 _flags;
    private bool _fPersistKeyInCsp;
    unknown string ContainerName {internal set; }
    unknown string ProviderName {internal set; }
    unknown int Types {internal set; }
    unknown UInt32 Flags {internal set; }
    internal bool PersistKeyInCsp { get; internal set; }
    internal static SafeProvHandle InvalidHandle { get; }
    internal void set_ContainerName(string value);
    internal void set_ProviderName(string value);
    internal void set_Types(int value);
    internal void set_Flags(UInt32 value);
    internal bool get_PersistKeyInCsp();
    internal void set_PersistKeyInCsp(bool value);
    internal static SafeProvHandle get_InvalidHandle();
    protected virtual void Dispose(bool disposing);
    protected virtual bool ReleaseHandle();
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA1CryptoServiceProvider : SHA1 {
    private IncrementalHash _incrementalHash;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA256CryptoServiceProvider : SHA256 {
    private IncrementalHash _incrementalHash;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA384CryptoServiceProvider : SHA384 {
    private IncrementalHash _incrementalHash;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.SHA512CryptoServiceProvider : SHA512 {
    private IncrementalHash _incrementalHash;
    public virtual void Initialize();
    protected virtual void HashCore(Byte[] array, int ibStart, int cbSize);
    protected virtual void HashCore(ReadOnlySpan`1<byte> source);
    protected virtual Byte[] HashFinal();
    protected virtual bool TryHashFinal(Span`1<byte> destination, Int32& bytesWritten);
    protected virtual void Dispose(bool disposing);
}
[EditorBrowsableAttribute("1")]
public class System.Security.Cryptography.TripleDESCryptoServiceProvider : TripleDES {
    private TripleDES _impl;
    public int FeedbackSize { get; public set; }
    public int BlockSize { get; public set; }
    public Byte[] IV { get; public set; }
    public Byte[] Key { get; public set; }
    public int KeySize { get; public set; }
    public CipherMode Mode { get; public set; }
    public PaddingMode Padding { get; public set; }
    public KeySizes[] LegalBlockSizes { get; }
    public KeySizes[] LegalKeySizes { get; }
    public virtual int get_FeedbackSize();
    public virtual void set_FeedbackSize(int value);
    public virtual int get_BlockSize();
    public virtual void set_BlockSize(int value);
    public virtual Byte[] get_IV();
    public virtual void set_IV(Byte[] value);
    public virtual Byte[] get_Key();
    public virtual void set_Key(Byte[] value);
    public virtual int get_KeySize();
    public virtual void set_KeySize(int value);
    public virtual CipherMode get_Mode();
    public virtual void set_Mode(CipherMode value);
    public virtual PaddingMode get_Padding();
    public virtual void set_Padding(PaddingMode value);
    public virtual KeySizes[] get_LegalBlockSizes();
    public virtual KeySizes[] get_LegalKeySizes();
    public virtual ICryptoTransform CreateEncryptor();
    public virtual ICryptoTransform CreateDecryptor();
    public virtual void GenerateIV();
    public virtual void GenerateKey();
    public virtual ICryptoTransform CreateEncryptor(Byte[] rgbKey, Byte[] rgbIV);
    public virtual ICryptoTransform CreateDecryptor(Byte[] rgbKey, Byte[] rgbIV);
    protected virtual void Dispose(bool disposing);
}
internal static class System.SR : object {
    private static ResourceManager s_resourceManager;
    internal static ResourceManager ResourceManager { get; }
    internal static string Arg_EnumIllegalVal { get; }
    internal static string Argument_InvalidValue { get; }
    internal static string ArgumentOutOfRange_NeedNonNegNum { get; }
    internal static string ArgumentOutOfRange_NeedPosNum { get; }
    internal static string Cryptography_CSP_NoPrivateKey { get; }
    internal static string Cryptography_CSP_NotFound { get; }
    internal static string Cryptography_CSP_WrongKeySpec { get; }
    internal static string Cryptography_HashAlgorithmNameNullOrEmpty { get; }
    internal static string Cryptography_InvalidDSASignatureSize { get; }
    internal static string Cryptography_InvalidHashSize { get; }
    internal static string Cryptography_InvalidIVSize { get; }
    internal static string Cryptography_InvalidKey_Weak { get; }
    internal static string Cryptography_InvalidKey_SemiWeak { get; }
    internal static string Cryptography_InvalidKeySize { get; }
    internal static string Cryptography_InvalidOID { get; }
    internal static string Cryptography_InvalidPadding { get; }
    internal static string Cryptography_InvalidPaddingMode { get; }
    internal static string Cryptography_MissingIV { get; }
    internal static string Cryptography_MustTransformWholeBlock { get; }
    internal static string Cryptography_OpenInvalidHandle { get; }
    internal static string Cryptography_PartialBlock { get; }
    internal static string Cryptography_PasswordDerivedBytes_InvalidAlgorithm { get; }
    internal static string Cryptography_PasswordDerivedBytes_InvalidIV { get; }
    internal static string Cryptography_PasswordDerivedBytes_TooManyBytes { get; }
    internal static string Cryptography_PasswordDerivedBytes_ValuesFixed { get; }
    internal static string Cryptography_RC2_EKSKS2 { get; }
    internal static string Cryptography_RSA_DecryptWrongSize { get; }
    internal static string Cryptography_TransformBeyondEndOfBuffer { get; }
    internal static string Cryptography_UnknownHashAlgorithm { get; }
    internal static string Cryptography_UnknownPaddingMode { get; }
    internal static string CryptSetKeyParam_Failed { get; }
    internal static string CspParameter_invalid { get; }
    private static bool UsingResourceKeys();
    internal static string GetResourceString(string resourceKey, string defaultString);
    internal static string Format(string resourceFormat, object p1);
    internal static string Format(string resourceFormat, object p1, object p2);
    internal static ResourceManager get_ResourceManager();
    internal static string get_Arg_EnumIllegalVal();
    internal static string get_Argument_InvalidValue();
    internal static string get_ArgumentOutOfRange_NeedNonNegNum();
    internal static string get_ArgumentOutOfRange_NeedPosNum();
    internal static string get_Cryptography_CSP_NoPrivateKey();
    internal static string get_Cryptography_CSP_NotFound();
    internal static string get_Cryptography_CSP_WrongKeySpec();
    internal static string get_Cryptography_HashAlgorithmNameNullOrEmpty();
    internal static string get_Cryptography_InvalidDSASignatureSize();
    internal static string get_Cryptography_InvalidHashSize();
    internal static string get_Cryptography_InvalidIVSize();
    internal static string get_Cryptography_InvalidKey_Weak();
    internal static string get_Cryptography_InvalidKey_SemiWeak();
    internal static string get_Cryptography_InvalidKeySize();
    internal static string get_Cryptography_InvalidOID();
    internal static string get_Cryptography_InvalidPadding();
    internal static string get_Cryptography_InvalidPaddingMode();
    internal static string get_Cryptography_MissingIV();
    internal static string get_Cryptography_MustTransformWholeBlock();
    internal static string get_Cryptography_OpenInvalidHandle();
    internal static string get_Cryptography_PartialBlock();
    internal static string get_Cryptography_PasswordDerivedBytes_InvalidAlgorithm();
    internal static string get_Cryptography_PasswordDerivedBytes_InvalidIV();
    internal static string get_Cryptography_PasswordDerivedBytes_TooManyBytes();
    internal static string get_Cryptography_PasswordDerivedBytes_ValuesFixed();
    internal static string get_Cryptography_RC2_EKSKS2();
    internal static string get_Cryptography_RSA_DecryptWrongSize();
    internal static string get_Cryptography_TransformBeyondEndOfBuffer();
    internal static string get_Cryptography_UnknownHashAlgorithm();
    internal static string get_Cryptography_UnknownPaddingMode();
    internal static string get_CryptSetKeyParam_Failed();
    internal static string get_CspParameter_invalid();
}
